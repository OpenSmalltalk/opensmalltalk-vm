/* Automatically generated by
	CCodeGenerator VMMaker.oscog-eem.3419 uuid: 70017fea-1b4a-4603-a657-4d77106c4cf0
   from
	StackToRegisterMappingCogit VMMaker.oscog-eem.3419 uuid: 70017fea-1b4a-4603-a657-4d77106c4cf0
 */
static char __buildInfo[] = "StackToRegisterMappingCogit VMMaker.oscog-eem.3419 uuid: 70017fea-1b4a-4603-a657-4d77106c4cf0 " __DATE__ ;
char *__cogitBuildInfo = __buildInfo;



#include "sqConfig.h"
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sqPlatformSpecific.h"
#include "sqMemoryAccess.h"
#include "sqCogStackAlignment.h"
#include "dispdbg.h"
#include "cogmethod.h"
#if COGMTVM
#include "cointerpmt.h"
#else
#include "cointerp.h"
#endif
#include "cogit.h"


/*** Constants ***/
#define ABICalleeSavedRegisterMask 0xF008
#define ABICallerSavedRegisterMask 0xFC7
#define ABIResultReg 0
#undef ABIResultRegHigh
#define AddCqR 106
#define AddCqRR 123
#define AddCwR 114
#define AddcCqR 120
#define AddcRR 119
#define AddRdRd 132
#define AddRR 100
#define AddRRR 126
#define AddRsRs 139
#define AlignmentNops 3
#define AltBlockCreationBytecodeSize 3
#define AltFirstSpecialSelector 96
#define AltNumSpecialSelectors 32
#define AndCqR 108
#define AndCqRR 124
#define AndCwR 116
#define AndRR 102
#define AnnotationShift 5
#define Arg0Reg 7
#define Arg1Reg 6
#define ArithmeticShiftRightCqR 91
#define ArithmeticShiftRightCqRR 128
#define ArithmeticShiftRightRR 92
#define BadRegisterSet 1
#define BlockCreationBytecodeSize 4
#define BSR 169
#define BytecodeSetHasDirectedSuperSend 1
#define CArg0Reg 7
#define CArg1Reg 6
#define CArg2Reg 2
#define CArg3Reg 1
#define Call 6
#define CallerSavedRegisterMask 0x2C6
#define CallFull 7
#define CallR 8
#define CDQ 161
#if !defined(CheckRememberedInTrampoline) /* Allow this to be overridden on the compiler command line */
# define CheckRememberedInTrampoline 0
#endif
#define CLD 165
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBlockClosureCompactIndex 37
#define ClassFloatCompactIndex 34
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMethodContextCompactIndex 36
#define ClassPointCompactIndex 54
#define ClassReg 1
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define ClzRR 157
#define CMBlock 4
#define CMClosedPIC 2
#define CMFree 1
#define CMMaxUsageCount 7
#define CMMethod 5
#define CMMethodFlaggedForBecome 6
#define CMOpenPIC 3
#define CMPXCHGRMr 174
#define CmpC32R 113
#define CmpCqR 105
#define CmpCwR 112
#define CmpRdRd 131
#define CmpRR 99
#define CmpRsRs 138
#define CompletePrimitive 4
#define ConstZero 1
#define ConvertRdR 146
#define ConvertRdRs 148
#define ConvertRRd 145
#define ConvertRRs 150
#define ConvertRsR 149
#define ConvertRsRd 147
#define CPUID 160
#if !defined(Debug) /* Allow this to be overridden on the compiler command line */
# define Debug DEBUGVM
#endif
#define DisplacementMask 0x1F
#define DisplacementX2N 0
#define DivRdRd 135
#define DivRsRs 142
#define DPFPReg0 0
#define DPFPReg1 1
#define DPFPReg2 2
#define DPFPReg3 3
#define DPFPReg4 4
#define DPFPReg5 5
#define DPFPReg6 6
#define DPFPReg7 7
#define EncounteredUnknownBytecode -6
#define Extra0Reg 10
#define Extra1Reg 11
#define Extra2Reg 12
#define Extra3Reg 13
#define Extra4Reg 14
#define Extra5Reg 15
#define Fill32 4
#define FirstAnnotation 64
#define FirstJump 12
#define FirstShortJump 16
#define FirstSpecialSelector 176
#define FoxCallerSavedIP 8
#define FoxIFSavedIP -32
#define FoxMethod -8
#define FoxMFReceiver -24
#define FoxSavedFP 0
#define FoxThisContext -16
#define FPReg 5
#define FullClosureCompiledBlockIndex 1
#define FullClosureFirstCopiedValueIndex 4
#define FullClosureReceiverIndex 3
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define HasBytecodePC 5
#define HashMultiplyConstant 1664525
#define HashMultiplyMask 0xFFFFFFF
#define HeaderIndex 0
#define IDIVR 162
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 1
#endif
#define IMULRR 163
#define InFullBlock 2
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define InsufficientCodeSpace -2
#define InVanillaBlock 1
#define IsAbsPCReference 3
#define IsAnnotationExtension 1
#define IsDirectedSuperBindingSend 10
#define IsDirectedSuperSend 9
#define IsDisplacementX2N 0
#define IsNSDynamicSuperSend null
#define IsNSSelfSend null
#define IsNSSendCall null
#define IsObjectReference 2
#define IsRelativeCall 4
#define IsSendCall 7
#define IsSuperSend 8
#define Jump 16
#define JumpAbove 33
#define JumpAboveOrEqual 32
#define JumpBelow 31
#define JumpBelowOrEqual 34
#define JumpCarry 25
#define JumpFPEqual 35
#define JumpFPGreater 39
#define JumpFPGreaterOrEqual 40
#define JumpFPLess 37
#define JumpFPLessOrEqual 38
#define JumpFPNotEqual 36
#define JumpFPOrdered 41
#define JumpFPUnordered 42
#define JumpFull 12
#define JumpGreater 29
#define JumpGreaterOrEqual 28
#define JumpLess 27
#define JumpLessOrEqual 30
#define JumpLong 13
#define JumpLongNonZero 15
#define JumpLongZero 14
#define JumpNegative 19
#define JumpNoCarry 26
#define JumpNonNegative 20
#define JumpNonZero 18
#define JumpNoOverflow 22
#define JumpOverflow 21
#define JumpR 10
#define JumpZero 17
#define Label 1
#define LargeContextSlots 62
#define LastJump 42
#define LFENCE 170
#undef LinkReg
#define Literal 2
#define LiteralStart 1
#define LOCK 173
#define LoadEffectiveAddressMwrR 88
#define LogicalShiftLeftCqR 95
#define LogicalShiftLeftCqRR 129
#define LogicalShiftLeftRR 96
#define LogicalShiftRightCqR 93
#define LogicalShiftRightCqRR 130
#define LogicalShiftRightRR 94
#define LowcodeContextMark 60
#define MapEnd 0
#define MaxCompiledPrimitiveIndex 582
#define MaxCPICCases 6
#define MaxMethodSize 65535
#define MaxNegativeErrorCode -8
#define MaxStackAllocSize 1572864
#define MaxStackCheckOffset 0xFFF
#define MaxX2NDisplacement 992
#define MethodCacheClass 2
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCacheSelector 1
#define MethodIndex 3
#define MethodTooBig -4
#define MFENCE 171
#define MFMethodFlagHasContextFlag 1
#define MFMethodFlagIsBlockFlag 2
#define MOVSB 167
#define MOVSQ 168
#define ModReg 3
#define ModRegInd 0
#define ModRegRegDisp32 2
#define ModRegRegDisp8 1
#define MoveA32R 45
#define MoveAbR 48
#define MoveAwR 44
#define MoveC32R 71
#define MoveCqR 69
#define MoveCwR 70
#define MoveM16rR 57
#define MoveM32rR 61
#define MoveM32rRs 78
#define MoveM64rRd 75
#define MoveM8rR 54
#define MoveMbrR 65
#define MoveMs8rR 55
#define MoveMwrR 50
#define MovePerfCnt64RL 159
#define MovePerfCnt64RRL 158
#define MoveRA32 47
#define MoveRAb 49
#define MoveRAw 46
#define MoveRAwNoVBR 176
#define MoveRdM64r 76
#define MoveRdR 73
#define MoveRdRd 74
#define MoveRM16r 58
#define MoveRM32r 62
#define MoveRM8r 56
#define MoveRMbr 66
#define MoveRMwr 51
#define MoveRR 43
#define MoveRRd 72
#define MoveRsM32r 79
#define MoveRsRs 77
#define MoveRX32rR 64
#define MoveRXbrR 68
#define MoveRXwrR 53
#define MoveX32rRR 63
#define MoveXbrRR 67
#define MoveXwrRR 52
#define MulRdRd 134
#define MulRsRs 141
#define NativePopR 84
#define NativePushR 85
#define NativeRetN 86
#define NativeSPReg 4
#define NeedsMergeFixupFlag 2
#define NeedsNonMergeFixupFlag 1
#define NegateR 89
#define Nop 5
#define NoReg -1
#define NotFullyInitialized -1
#define NotR 90
#define NumObjRefsInRuntime 0
#define NumOopsPerNSC 6
#define NumSendTrampolines 4
#define NumSpecialSelectors 32
#define NumStoreTrampolines 5
#define NumTrampolines (80 + (IMMUTABILITY ? 5 : 0))
#define OrCqR 109
#define OrCqRR 125
#define OrCwR 117
#define OrRR 103
#undef PCReg
#define PopR 80
#define PrefetchAw 87
#define PrimCallCollectsProfileSamples 16
#define PrimCallIsExternalCall 32
#define PrimCallMayEndureCodeCompaction 8
#define PrimCallNeedsNewMethod 4
#define PrimCallOnSmalltalkStack 1
#define PrimCallOnSmalltalkStackAlign2x 2
#define PrimNumberExternalCall 117
#define PrimNumberFFICall 120
#define PushCq 82
#define PushCw 83
#define PushR 81
#define R12 12
#define R13 13
#define R15 15
#define R8 8
#define RAX 0
#define RBP 5
#define RBX 3
#define RCX 1
#define RDI 7
#define RDX 2
#define REP 166
#define ReceiverIndex 5
#define ReceiverResultReg 2
#define RetN 9
#define RISCTempReg 8
#define RotateLeftCqR 97
#define RotateRightCqR 98
#define RSI 6
#define RSP 4
#define SETE 175
#define SelectorCannotInterpret 34
#define SelectorDoesNotUnderstand 20
#define SenderIndex 0
#define SendNumArgsReg 9
#define SFENCE 172
#define ShouldNotJIT -8
#define SIB1 0
#define SIB4 2
#define SIB8 3
#define SignExtend16RR 152
#define SignExtend32RR 153
#define SignExtend8RR 151
#define SistaV1BytecodeSet 1
#define SmallContextSlots 22
#define SPReg 4
#define SpecialSelectors 23
#define SqrtRd 136
#define SqrtRs 143
#define SSBaseOffset 1
#define SSConstant 2
#define SSConstantFloat32 15
#define SSConstantFloat64 16
#define SSConstantInt32 13
#define SSConstantInt64 14
#define SSConstantNativePointer 17
#define SSNativeRegister 5
#define SSRegister 3
#define SSRegisterDoubleFloat 7
#define SSRegisterPair 6
#define SSRegisterSingleFloat 8
#define SSSpill 4
#define SSSpillFloat32 11
#define SSSpillFloat64 12
#define SSSpillInt64 10
#define SSSpillNative 9
#define StackPointerIndex 2
#define Stop 11
#define SubbCqR 122
#define SubbRR 121
#define SubCqR 107
#define SubCwR 115
#define SubRdRd 133
#define SubRR 101
#define SubRRR 127
#define SubRsRs 140
#define SysV 1
#define TempReg 0
#define TstCqR 110
#define UnfailingPrimitive 3
#define UnimplementedPrimitive -7
#define ValueIndex 1
#define VarBaseReg 3
#define XCHGRR 164
#define XMM0L 0
#define XMM1L 1
#define XMM2L 2
#define XMM3L 3
#define XorCwR 118
#define XorRdRd 137
#define XorRR 104
#define XorRsRs 144
#define YoungSelectorInPIC -5
#define ZeroExtend16RR 155
#define ZeroExtend32RR 156
#define ZeroExtend8RR 154

typedef struct _AbstractInstruction {
	unsigned char	opcode;
	unsigned char	machineCodeSize;
	unsigned char	maxSize;
	unsigned char	annotation;
	usqInt		operands[3];
	usqInt	address;
	struct _AbstractInstruction *dependent;
	unsigned char		machineCode[14];
 } AbstractInstruction;

#define CogInLineLiteralsX64Compiler AbstractInstruction
#define CogX64Compiler AbstractInstruction
#define CogAbstractInstruction AbstractInstruction


typedef struct {
	AbstractInstruction *fakeHeader;
	AbstractInstruction *fillInstruction;
	sqInt	numArgs;
	sqInt	numCopied;
	sqInt	numInitialNils;
	sqInt	startpc;
	AbstractInstruction *entryLabel;
	AbstractInstruction *stackCheckLabel;
	sqInt	span;
	sqInt	hasInstVarRef;
 } BlockStart;

#define CogBlockStart BlockStart


typedef struct _BytecodeDescriptor {
	sqInt (*generator)(void);
	sqInt NoDbgRegParms (*spanFunction)(struct _BytecodeDescriptor *,sqInt,sqInt,sqInt);
	sqInt NoDbgRegParms (*needsFrameFunction)(sqInt);
	signed char	stackDelta;
	unsigned char	opcode;
	unsigned char	numBytes;
	unsigned		isBranchTrue : 1;
	unsigned		isBranchFalse : 1;
	unsigned		isReturn : 1;
	unsigned		isBlockCreation : 1;
	unsigned		isMapped : 1;
	unsigned		isMappedInBlock : 1;
	unsigned		isExtension : 1;
	unsigned		isInstVarRef : 1;
	unsigned		is1ByteInstVarStore : 1;
	unsigned		hasUnsafeJump : 1;
 } BytecodeDescriptor;

#define CogBytecodeDescriptor BytecodeDescriptor


typedef struct {
	sqInt (*primitiveGenerator)(void);
	sqInt	primNumArgs;
 } PrimitiveDescriptor;

#define CogPrimitiveDescriptor PrimitiveDescriptor


typedef struct {
	char	type;
	char	spilled;
	signed char	liveRegister;
	signed char	registerr;
	sqInt	offset;
	sqInt	constant;
	sqInt	bcptr;
 } SimStackEntry;

#define CogSimStackEntry SimStackEntry


typedef struct {
	AbstractInstruction *targetInstruction;
	unsigned char	simStackPtr;
	char	isTargetOfBackwardBranch;
	unsigned short	instructionIndex;
	short	simNativeStackPtr;
	unsigned short	simNativeStackSize;
 } BytecodeFixup;

#define CogSSBytecodeFixup BytecodeFixup
#define CogBytecodeFixup BytecodeFixup


typedef struct {
	sqInt	isReceiverResultRegLive;
	CogSimStackEntry *ssEntry;
 } CogSSOptStatus;


typedef struct {
	char	type;
	char	spilled;
	sqInt	registerr;
	sqInt	registerSecond;
	sqInt	offset;
	sqInt	constant;
	sqInt	constantInt32;
	sqLong	constantInt64;
	float	constantFloat32;
	double	constantFloat64;
	sqInt	constantNativePointer;
	sqInt	bcptr;
 } CogSimStackNativeEntry;



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

static AbstractInstruction * NoDbgRegParms addDependent(AbstractInstruction * self_in_addDependent, AbstractInstruction *anInstruction);
static sqInt NoDbgRegParms availableFloatRegisterOrNoneFor(AbstractInstruction * self_in_availableFloatRegisterOrNoneFor, sqInt liveRegsMask);
static void NoDbgRegParms cloneLiteralFrom(AbstractInstruction * self_in_cloneLiteralFrom, AbstractInstruction *existingLiteral);
static sqInt NoDbgRegParms concretizeAt(AbstractInstruction * self_in_concretizeAt, sqInt actualAddress);
static sqInt NoDbgRegParms genLoadCStackPointer(AbstractInstruction * self_in_genLoadCStackPointer);
static sqInt NoDbgRegParms genLoadCStackPointers(AbstractInstruction * self_in_genLoadCStackPointers);
static sqInt NoDbgRegParms genLoadStackPointerForPrimCall(AbstractInstruction * self_in_genLoadStackPointerForPrimCall, sqInt spareReg);
static sqInt NoDbgRegParms genLoadStackPointers(AbstractInstruction * self_in_genLoadStackPointers);
static sqInt NoDbgRegParms genLoadStackPointersForPrimCall(AbstractInstruction * self_in_genLoadStackPointersForPrimCall, sqInt spareReg);
static sqInt NoDbgRegParms genSaveStackPointers(AbstractInstruction * self_in_genSaveStackPointers);
static void NoDbgRegParms genWriteCResultIntoReg(AbstractInstruction * self_in_genWriteCResultIntoReg, sqInt abstractRegister);
static void NoDbgRegParms genWriteCSecondResultIntoReg(AbstractInstruction * self_in_genWriteCSecondResultIntoReg, sqInt abstractRegister);
static void NoDbgRegParms initializeSharableLiteral(AbstractInstruction * self_in_initializeSharableLiteral, sqInt literal);
static void NoDbgRegParms initializeUniqueLiteral(AbstractInstruction * self_in_initializeUniqueLiteral, sqInt literal);
static sqInt NoDbgRegParms isJump(AbstractInstruction * self_in_isJump);
static void NoDbgRegParms relocateJumpLongBeforeFollowingAddressby(AbstractInstruction * self_in_relocateJumpLongBeforeFollowingAddressby, sqInt pc, sqInt delta);
static void NoDbgRegParms relocateJumpLongConditionalBeforeFollowingAddressby(AbstractInstruction * self_in_relocateJumpLongConditionalBeforeFollowingAddressby, sqInt pc, sqInt delta);
static void NoDbgRegParms resolveJumpTarget(AbstractInstruction * self_in_resolveJumpTarget);
static sqInt NoDbgRegParms rewriteConditionalJumpLongAttarget(AbstractInstruction * self_in_rewriteConditionalJumpLongAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static CogMethod * NoDbgRegParms cmHomeMethod(CogBlockMethod * self_in_cmHomeMethod);
static sqInt NoDbgRegParms isCMBlock(CogBlockMethod * self_in_isCMBlock);
static sqInt NoDbgRegParms isCMClosedPIC(CogBlockMethod * self_in_isCMClosedPIC);
static sqInt NoDbgRegParms isCMFree(CogBlockMethod * self_in_isCMFree);
static sqInt NoDbgRegParms isCMMethodEtAl(CogBlockMethod * self_in_isCMMethodEtAl);
static sqInt NoDbgRegParms isCMOpenPIC(CogBlockMethod * self_in_isCMOpenPIC);
static sqInt NoDbgRegParms isBranch(BytecodeDescriptor * self_in_isBranch);
static sqInt NoDbgRegParms computeSizeOfArithCqR(AbstractInstruction * self_in_computeSizeOfArithCqR);
static sqInt NoDbgRegParms computeSizeOfArithCwR(AbstractInstruction * self_in_computeSizeOfArithCwR);
static sqInt NoDbgRegParms concretizeArithCwR(AbstractInstruction * self_in_concretizeArithCwR, sqInt x64opcode);
static sqInt NoDbgRegParms concretizeMoveCwR(AbstractInstruction * self_in_concretizeMoveCwR);
static usqInt NoDbgRegParms inlineCacheTagAt(AbstractInstruction * self_in_inlineCacheTagAt, sqInt callSiteReturnAddress);
static sqInt NoDbgRegParms isPCDependent(AbstractInstruction * self_in_isPCDependent);
static usqInt NoDbgRegParms literal32BeforeFollowingAddress(AbstractInstruction * self_in_literal32BeforeFollowingAddress, sqInt followingAddress);
static sqInt NoDbgRegParms literalBeforeFollowingAddress(AbstractInstruction * self_in_literalBeforeFollowingAddress, sqInt followingAddress);
static sqInt NoDbgRegParms loadLiteralByteSize(AbstractInstruction * self_in_loadLiteralByteSize);
static usqInt NoDbgRegParms sizePCDependentInstructionAt(AbstractInstruction * self_in_sizePCDependentInstructionAt, sqInt eventualAbsoluteAddress);
static void NoDbgRegParms storeLiteralbeforeFollowingAddress(AbstractInstruction * self_in_storeLiteralbeforeFollowingAddress, sqInt literal, sqInt followingAddress);
static AbstractInstruction * NoDbgRegParms gAddCqR(sqInt quickConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gAddCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static AbstractInstruction * NoDbgRegParms gAddRRR(sqInt addendReg, sqInt badendReg, sqInt destReg);
static AbstractInstruction * NoDbgRegParms gAndCqR(sqInt quickConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gAndCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static AbstractInstruction * NoDbgRegParms gArithmeticShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
extern sqInt abortOffset(void);
static sqInt NoDbgRegParms abstractInstructionfollows(AbstractInstruction *theAbstractInstruction, AbstractInstruction *anAbstractInstruction);
static void addCleanBlockStarts(void);
extern void addCogMethodsToHeapMap(void);
static sqInt NoDbgRegParms addressIsInFixups(BytecodeFixup *address);
static sqInt NoDbgRegParms addressOfEndOfCaseinCPIC(sqInt n, CogMethod *cPIC);
static void alignMethodZoneBase(void);
static sqInt NoDbgRegParms alignUptoRoutineBoundary(sqInt anAddress);
static sqInt allMachineCodeObjectReferencesValid(void);
static sqInt allMethodsHaveCorrectHeader(void);
static AbstractInstruction * NoDbgRegParms annotateAbsolutePCRef(AbstractInstruction *abstractInstruction);
static AbstractInstruction * NoDbgRegParms annotateBytecode(AbstractInstruction *abstractInstruction);
static AbstractInstruction * NoDbgRegParms annotateobjRef(AbstractInstruction *abstractInstruction, sqInt anOop);
static void NoDbgRegParms assertSaneJumpTarget(AbstractInstruction *jumpTarget);
static sqInt NoDbgRegParms availableRegisterOrNoneIn(sqInt liveRegsMask);
static sqInt NoDbgRegParms blockDispatchTargetsForperformarg(CogMethod *cogMethod, usqInt (*binaryFunction)(sqInt mcpc, sqInt arg), sqInt arg);
extern sqInt bytecodePCForstartBcpcin(sqInt mcpc, sqInt startbcpc, CogBlockMethod *cogMethod);
static AbstractInstruction * NoDbgRegParms CallRTregistersToBeSavedMask(sqInt callTarget, sqInt registersToBeSaved);
static AbstractInstruction * NoDbgRegParms gCall(sqInt callTarget);
static AbstractInstruction * NoDbgRegParms gCmpCqR(sqInt quickConstant, sqInt reg);
static void callCogCodePopReceiver(void);
static void callCogCodePopReceiverAndClassRegs(void);
static sqInt NoDbgRegParms ceCPICMissreceiver(CogMethod *cPIC, sqInt receiver);
static void NoDbgRegParms ceFree(void *pointer);
static void* NoDbgRegParms ceMalloc(size_t size);
static sqInt NoDbgRegParms ceSICMiss(sqInt receiver);
static sqInt NoDbgRegParms checkIfValidOopRefAndTargetpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
static sqInt NoDbgRegParms checkIfValidOopRefpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
extern sqInt checkIntegrityOfObjectReferencesInCode(sqInt gcModes);
static sqInt NoDbgRegParms checkMaybeObjRefInClosedPIC(sqInt maybeObject);
static sqInt NoDbgRegParms checkValidObjectReferencesInClosedPIC(CogMethod *cPIC);
static sqInt NoDbgRegParms NeverInline cleanUpFailingCogCodeConstituents(CogMethod *cogMethodArg);
static sqInt NoDbgRegParms closedPICRefersToUnmarkedObject(CogMethod *cPIC);
extern char * codeEntryFor(char *address);
extern char * codeEntryNameFor(char *address);
extern sqInt cogCodeBase(void);
extern sqInt cogCodeConstituents(sqInt withDetails);
static void NoDbgRegParms cogExtendPICCaseNMethodtagisMNUCase(CogMethod *cPIC, sqInt caseNMethod, sqInt caseNTag, sqInt isMNUCase);
extern CogMethod * cogFullBlockMethodnumCopied(sqInt aMethodObj, sqInt numCopied);
extern void cogitPostGCAction(sqInt gcMode);
static sqInt NoDbgRegParms cogMethodDoesntLookKosher(CogMethod *cogMethod);
extern CogMethod * cogMNUPICSelectorreceivermethodOperandnumArgs(sqInt selector, sqInt rcvr, sqInt methodOperand, sqInt numArgs);
static CogMethod * NoDbgRegParms cogOpenPICSelectornumArgs(sqInt selector, sqInt numArgs);
static CogMethod * NoDbgRegParms cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase(sqInt selector, sqInt numArgs, CogMethod *case0CogMethod, sqInt case1MethodOrNil, sqInt case1Tag, sqInt isMNUCase);
extern CogMethod * cogselector(sqInt aMethodObj, sqInt aSelectorOop);
static sqInt NoDbgRegParms collectCogConstituentForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg);
static sqInt NoDbgRegParms collectCogMethodConstituent(CogMethod *cogMethod);
extern void compactCogCompiledCode(void);
static void compactPICsWithFreedTargets(void);
static AbstractInstruction * compileAbort(void);
static sqInt NoDbgRegParms compileBlockDispatchFromto(sqInt lowBlockStartIndex, sqInt highBlockStartIndex);
static void NoDbgRegParms compileBlockEntry(BlockStart *blockStart);
static void NoDbgRegParms compileCallFornumArgsargargargargfloatResultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask);
static void NoDbgRegParms compileCallFornumArgsargargargargresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask);
static void NoDbgRegParms compileCallFornumArgsargargargargresultRegresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt resultReg2OrNone, sqInt regMask);
static void NoDbgRegParms compileCallFornumArgsfloatArgfloatArgfloatArgfloatArgresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask);
static AbstractInstruction * compileCPICEntry(void);
static sqInt NoDbgRegParms compileEntireFullBlockMethod(sqInt numCopied);
static void compileEntry(void);
static sqInt compileFullBlockEntry(void);
static sqInt compileMethodBody(void);
static sqInt NoDbgRegParms compilePICAbort(sqInt numArgs);
static AbstractInstruction * NoDbgRegParms compileStackOverflowCheck(sqInt canContextSwitch);
static void NoDbgRegParms compileTrampolineFornumArgsargargargargregsToSavepushLinkRegfloatResultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone);
static void NoDbgRegParms compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone);
static void NoDbgRegParms compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt resultReg2OrNone);
static void NoDbgRegParms compileTrampolineFornumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone);
static void computeEntryOffsets(void);
static void computeFullBlockEntryOffsets(void);
static usqInt computeGoodVarBaseAddress(void);
static void computeMaximumSizes(void);
static sqInt NoDbgRegParms configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(CogMethod *cPIC, CogMethod *case0CogMethod, sqInt case1Method, sqInt case1Tag, sqInt isMNUCase, sqInt numArgs, sqInt addrDelta);
static sqInt NoDbgRegParms configureMNUCPICmethodOperandnumArgsdelta(CogMethod *cPIC, sqInt methodOperand, sqInt numArgs, sqInt addrDelta);
static sqInt NoDbgRegParms cPICCompactAndIsNowEmpty(CogMethod *cPIC);
static sqInt NoDbgRegParms cPICHasForwardedClass(CogMethod *cPIC);
static sqInt NoDbgRegParms cPICHasFreedTargets(CogMethod *cPIC);
static usqInt cPICPrototypeCaseOffset(void);
static sqInt NoDbgRegParms cPICHasTarget(CogMethod *cPIC, CogMethod *targetMethod);
static sqInt NoDbgRegParms createCPICData(CogMethod *cPIC);
static AbstractInstruction * NoDbgRegParms gDivRRQuoRem(sqInt rDivisor, sqInt rDividend, sqInt rQuotient, sqInt rRemainder);
extern sqInt defaultCogCodeSize(void);
static sqInt NoDbgRegParms deltaToSkipPrimAndErrorStoreInheader(sqInt aMethodObj, sqInt aMethodHeader);
static sqInt NoDbgRegParms endPCOf(sqInt aMethod);
static void enterCogCodePopReceiver(void);
static sqInt NoDbgRegParms entryPointTagIsSelector(sqInt entryPoint);
static sqInt NoDbgRegParms expectedClosedPICPrototype(CogMethod *cPIC);
static sqInt extABytecode(void);
static sqInt extBBytecode(void);
static sqInt NoDbgRegParms fillInBlockHeadersAt(sqInt startAddress);
static void NoDbgRegParms fillInMethodHeadersizeselector(CogMethod *method, sqInt size, sqInt selector);
static usqInt NoDbgRegParms findBlockMethodWithEntrystartBcpc(sqInt blockEntryMcpc, sqInt startBcpc);
static usqInt NoDbgRegParms findMapLocationForMcpcinMethod(usqInt targetMcpc, CogMethod *cogMethod);
extern CogBlockMethod * findMethodForStartBcpcinHomeMethod(sqInt startbcpc, CogMethod *cogMethod);
static sqInt NoDbgRegParms findIsBackwardBranchMcpcBcpcMatchingMcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetMcpc);
static sqInt NoDbgRegParms firstMappedPCFor(CogMethod *cogMethod);
static sqInt firstPrototypeMethodOop(void);
static BytecodeFixup * NoDbgRegParms fixupAt(sqInt fixupPC);
extern void flagCogMethodForBecome(CogMethod *cogMethod);
static void NoDbgRegParms followForwardedLiteralsImplementationIn(CogMethod *cogMethod);
extern void followForwardedLiteralsIn(CogMethod *cogMethod);
extern void followMovableLiteralsAndUpdateYoungReferrers(void);
extern void freeBecomeFlaggedMethods(void);
extern void freeCogMethod(CogMethod *cogMethod);
extern void freeUnmarkedMachineCode(void);
static AbstractInstruction * NoDbgRegParms genCallMustBeBooleanFor(sqInt boolean);
static AbstractInstruction * NoDbgRegParms genConditionalBranchoperand(sqInt opcode, sqInt operandOne);
static void (*genEnilopmartForandandforCallcalled(sqInt regArg1, sqInt regArg2OrNone, sqInt regArg3OrNone, sqInt forCall, char *trampolineName))(void);
static void NoDbgRegParms genEnilopmartReturn(sqInt forCall);
static void NoDbgRegParms NeverInline generateCaptureCStackPointers(sqInt captureFramePointer);
static void generateClosedPICPrototype(void);
static CogMethod * generateCogFullBlock(void);
static CogMethod * NoDbgRegParms generateCogMethod(sqInt selector);
static sqInt NoDbgRegParms generateMapAtstart(usqInt addressOrNull, usqInt startAddress);
static void generateOpenPICPrototype(void);
static void generateRunTimeTrampolines(void);
static void generateStackPointerCapture(void);
static void generateTrampolines(void);
static BytecodeDescriptor * NoDbgRegParms generatorForPC(sqInt pc);
static usqInt genFFICalloutTrampoline(void);
static void genGetLeafCallStackPointers(void);
static usqInt NoDbgRegParms genInnerPICAbortTrampoline(char *name);
static void (*genInvokeInterpretTrampoline(void))(void);
static void NoDbgRegParms genLoadInlineCacheWithSelector(sqInt selectorIndex);
static usqInt genReturnToInterpreterTrampoline(void);
static sqInt NoDbgRegParms genSmalltalkToCStackSwitch(sqInt pushLinkReg);
static usqInt NoDbgRegParms genTrampolineForcalledargfloatResult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg);
static usqInt NoDbgRegParms genTrampolineForcalledargresultresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg, sqInt resultReg2);
static usqInt NoDbgRegParms genTrampolineForcalledfloatArgresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg);
static usqInt NoDbgRegParms genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegfloatResultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean);
static usqInt NoDbgRegParms genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean);
static usqInt NoDbgRegParms genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt resultReg2OrNone, sqInt appendBoolean);
static usqInt NoDbgRegParms genTrampolineForcallednumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean);
static void NoDbgRegParms genTrampolineReturn(sqInt lnkRegWasPushed);
static AbstractInstruction * NoDbgRegParms gen(sqInt opcode);
static AbstractInstruction * NoDbgRegParms genoperand(sqInt opcode, sqInt operand);
static AbstractInstruction * NoDbgRegParms genoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo);
static AbstractInstruction * NoDbgRegParms genoperandoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo, sqInt operandThree);
static sqInt NoDbgRegParms getLiteral(sqInt litIndex);
static sqInt NoDbgRegParms incrementUsageOfTargetIfLinkedSendmcpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static sqInt NoDbgRegParms indexForSelectorin(sqInt selector, CogMethod *cogMethod);
static sqInt initialClosedPICUsageCount(void);
static void initializeBackend(void);
extern void initializeCodeZoneFromupTo(sqInt startAddress, sqInt endAddress);
static sqInt initialMethodUsageCount(void);
static sqInt initialOpenPICUsageCount(void);
static sqInt NoDbgRegParms inverseBranchFor(sqInt opcode);
static sqInt NoDbgRegParms isPCWithinMethodZone(void *address);
extern sqInt isSendReturnPC(sqInt retpc);
static AbstractInstruction * NoDbgRegParms gJumpFPEqual(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpFPGreaterOrEqual(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpFPGreater(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpFPLessOrEqual(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpFPLess(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpFPNotEqual(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gLogicalShiftLeftCqR(sqInt quickConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gLogicalShiftLeftCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static AbstractInstruction * NoDbgRegParms gLogicalShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static AbstractInstruction * lastOpcode(void);
extern void linkSendAtintooffsetreceiver(sqInt callSiteReturnAddress, CogMethod *sendingMethod, CogMethod *targetMethod, sqInt theEntryOffset, sqInt receiver);
static BytecodeDescriptor * loadBytesAndGetDescriptor(void);
static void NoDbgRegParms loadSubsequentBytesForDescriptorat(BytecodeDescriptor *descriptor, sqInt pc);
static AbstractInstruction * NoDbgRegParms gMoveCwR(sqInt wordConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gMovePerfCnt64RL(sqInt destReg, sqInt liveRegisterMask);
static AbstractInstruction * NoDbgRegParms gMovePerfCnt64RRL(sqInt destRegLo, sqInt destRegHi, sqInt liveRegisterMask);
static usqInt NoDbgRegParms mapEndFor(CogMethod *cogMethod);
static sqInt NoDbgRegParms mapForperformUntilarg(CogMethod *cogMethod, sqInt (*functionSymbol)(sqInt annotation, char *mcpc, CogMethod *arg), CogMethod *arg);
static sqInt NoDbgRegParms mapObjectReferencesInClosedPIC(CogMethod *cPIC);
static void mapObjectReferencesInGeneratedRuntime(void);
static void mapObjectReferencesInMachineCodeForBecome(void);
static void mapObjectReferencesInMachineCodeForFullGC(void);
static void mapObjectReferencesInMachineCodeForYoungGC(void);
extern void mapObjectReferencesInMachineCode(sqInt gcMode);
extern void markAndTraceMachineCodeOfMarkedMethods(void);
static void markAndTraceObjectReferencesInGeneratedRuntime(void);
static sqInt NoDbgRegParms markAndTraceOrFreeCogMethodfirstVisit(CogMethod *cogMethod, sqInt firstVisit);
static sqInt NoDbgRegParms markAndTraceOrFreePICTargetin(sqInt entryPoint, CogMethod *cPIC);
static sqInt NoDbgRegParms markLiteralsAndUnlinkIfUnmarkedSendpcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
static sqInt NoDbgRegParms markLiteralspcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
extern void markMethodAndReferents(CogBlockMethod *aCogMethod);
extern usqInt maxCogMethodAddress(void);
static sqInt NoDbgRegParms maximumDistanceFromCodeZone(sqInt anAddress);
static sqInt maybeAllocAndInitIRCs(void);
static sqInt NoDbgRegParms maybeFreeCogMethodDoesntLookKosher(CogMethod *cogMethod);
static sqInt mclassCouldBeContext(void);
static sqInt mclassIsSmallInteger(void);
extern usqInt mcPCForBackwardBranchstartBcpcin(sqInt bcpc, sqInt startbcpc, CogBlockMethod *cogMethod);
static sqInt NoDbgRegParms methodhasSameCodeAscheckPenultimate(sqInt methodA, sqInt methodB, sqInt comparePenultimateLiteral);
extern sqInt mnuOffset(void);
static AbstractInstruction * NoDbgRegParms gNativePopR(sqInt reg);
static AbstractInstruction * NoDbgRegParms gNativePushR(sqInt reg);
static AbstractInstruction * NoDbgRegParms gNativeRetN(sqInt offset);
static sqInt NoDbgRegParms needsFrameIfImmutability(sqInt stackDelta);
static sqInt NoDbgRegParms needsFrameIfInBlock(sqInt stackDelta);
static sqInt NoDbgRegParms needsFrameNever(sqInt stackDelta);
static sqInt NoDbgRegParms noAssertMethodClassAssociationOf(sqInt methodPointer);
static sqInt noCogMethodsMaximallyMarked(void);
static sqInt NoDbgRegParms noTargetsFreeInClosedPIC(CogMethod *cPIC);
static AbstractInstruction * NoDbgRegParms gOrCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms outputInstructionsAt(sqInt startAddress);
static sqInt NoDbgRegParms outputInstructionsForGeneratedRuntimeAt(sqInt startAddress);
extern sqInt patchToOpenPICFornumArgsreceiver(sqInt selector, sqInt numArgs, sqInt receiver);
static sqInt picAbortDiscriminatorValue(void);
static sqInt picInterpretAbortOffset(void);
static AbstractInstruction * previousInstruction(void);
extern void printCogMethodFor(void *address);
extern void printTrampolineTable(void);
static sqInt processorHasDivQuoRemAndMClassIsSmallInteger(void);
static sqInt processorHasMultiplyAndMClassIsSmallInteger(void);
static void NoDbgRegParms recordGeneratedRunTimeaddress(char *aString, sqInt address);
extern sqInt recordPrimTraceFunc(void);
static void recordRunTimeObjectReferences(void);
static sqInt NoDbgRegParms registerMaskFor(sqInt reg);
static sqInt NoDbgRegParms registerMaskForand(sqInt reg1, sqInt reg2);
static sqInt NoDbgRegParms registerMaskForandandand(sqInt reg1, sqInt reg2, sqInt reg3, sqInt reg4);
static void NoDbgRegParms relocateCallsAndSelfReferencesInMethod(CogMethod *cogMethod);
static void NoDbgRegParms relocateCallsInClosedPIC(CogMethod *cPIC);
static sqInt NoDbgRegParms relocateIfCallOrMethodReferencemcpcdelta(sqInt annotation, char *mcpc, CogMethod *refDeltaArg);
static sqInt NoDbgRegParms remapIfObjectRefpchasYoung(sqInt annotation, char *mcpc, CogMethod *hasYoungPtr);
static sqInt NoDbgRegParms remapMaybeObjRefInClosedPICAt(sqInt mcpc);
static void NoDbgRegParms rewriteCPICCaseAttagobjReftarget(sqInt followingAddress, sqInt newTag, sqInt newObjRef, sqInt newTarget);
static AbstractInstruction * NoDbgRegParms gSubRRR(sqInt subReg, sqInt fromReg, sqInt destReg);
static sqInt scanForCleanBlocks(void);
extern void setSelectorOfto(CogMethod *cogMethod, sqInt aSelectorOop);
static sqInt NoDbgRegParms spanForCleanBlockStartingAt(sqInt startPC);
static usqInt NoDbgRegParms stackCheckOffsetOfBlockAtisMcpc(sqInt blockEntryMcpc, sqInt mcpc);
static sqInt subsequentPrototypeMethodOop(void);
static AbstractInstruction * NoDbgRegParms gTstCqR(sqInt quickConstant, sqInt reg);
extern sqInt traceLinkedSendOffset(void);
static char * NoDbgRegParms trampolineNamenumArgs(char *routinePrefix, sqInt numArgs);
static char * NoDbgRegParms trampolineNamenumArgslimit(char *routinePrefix, int numArgs, sqInt argsLimit);
static char * NoDbgRegParms trampolineNamenumRegArgs(char *routinePrefix, sqInt numArgs);
extern void unflagBecomeFlaggedMethods(void);
static sqInt unknownBytecode(void);
extern void unlinkAllSends(void);
static sqInt NoDbgRegParms unlinkIfFreeOrLinkedSendpcof(sqInt annotation, char *mcpc, CogMethod *theSelector);
static sqInt NoDbgRegParms unlinkIfInvalidClassSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static sqInt NoDbgRegParms unlinkIfLinkedSendToFreepcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static sqInt NoDbgRegParms unlinkIfLinkedSendpcif(sqInt annotation, char *mcpc, CogMethod *criterionArg);
static sqInt NoDbgRegParms unlinkIfLinkedSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static sqInt NoDbgRegParms unlinkIfLinkedSendpcto(sqInt annotation, char *mcpc, CogMethod *theCogMethod);
extern void unlinkSendsLinkedForInvalidClasses(void);
extern void unlinkSendsOfisMNUSelector(sqInt selector, sqInt isMNUSelector);
static void unlinkSendsToFree(void);
extern void unlinkSendsToMethodsSuchThatAndFreeIf(sqInt (*criterion)(CogMethod *), sqInt freeIfTrue);
extern void unlinkSendsToandFreeIf(sqInt targetMethodObject, sqInt freeIfTrue);
extern void voidCogCompiledCode(void);
static void zeroOpcodeIndex(void);
static sqInt NoDbgRegParms counters(CogMethod * self_in_counters);
static void NoDbgRegParms addToOpenPICList(CogMethod *anOpenPIC);
static void NoDbgRegParms addToYoungReferrers(CogMethod *writableCogMethod);
static usqInt NoDbgRegParms allocate(sqInt numBytes);
extern CogMethod * cogMethodContaining(usqInt mcpc);
static void compactCompiledCode(void);
static void NoDbgRegParms ensureInYoungReferrers(CogMethod *cogMethod);
static void followForwardedLiteralsInOpenPICList(void);
static void NoDbgRegParms freeMethod(CogMethod *cogMethod);
static void freeOlderMethodsForCompaction(void);
extern sqInt kosherYoungReferrers(void);
static sqInt NoDbgRegParms mcpcisAtStackCheckOfBlockMethodIn(sqInt mcpc, CogMethod *cogMethod);
extern CogMethod * methodFor(void *address);
extern sqInt methodsCompiledToMachineCodeInto(sqInt arrayObj);
extern sqInt numMethods(void);
extern sqInt numMethodsOfType(sqInt cogMethodType);
static sqInt NoDbgRegParms occurrencesInYoungReferrers(CogMethod *cogMethod);
static CogMethod * NoDbgRegParms openPICWithSelector(sqInt aSelector);
static void planCompaction(void);
extern void printCogMethods(void);
extern void printCogMethodsOfType(sqInt cmType);
extern void printCogMethodsWithMethod(sqInt methodOop);
extern void printCogMethodsWithPrimitive(sqInt primIdx);
extern void printCogMethodsWithSelector(sqInt selectorOop);
extern void printCogYoungReferrers(void);
extern sqInt printOpenPICList(void);
static sqInt pruneYoungReferrers(void);
static sqInt relocateAndPruneYoungReferrers(void);
static sqInt relocateMethodsPreCompaction(void);
static sqInt NoDbgRegParms removeFromOpenPICList(CogMethod *anOpenPIC);
static void NoDbgRegParms restorePICUsageCount(CogMethod *cogMethod);
static sqInt NoDbgRegParms roundUpLength(sqInt numBytes);
static void NoDbgRegParms savePICUsageCount(CogMethod *cogMethod);
static void voidOpenPICList(void);
static void voidUnpairedMethodList(void);
static void voidYoungReferrersPostTenureAll(void);
extern char * whereIsMaybeCodeThing(sqInt anOop);
static sqInt zoneAlignment(void);
static sqInt NoDbgRegParms checkValidObjectReference(sqInt anOop);
static AbstractInstruction * NoDbgRegParms genCmpClassFloatCompactIndexR(sqInt reg);
static AbstractInstruction * NoDbgRegParms genCmpClassMethodContextCompactIndexR(sqInt reg);
static void generateLowcodeObjectTrampolines(void);
static sqInt NoDbgRegParms genGetMethodHeaderOfintoscratch(sqInt methodReg, sqInt headerReg, sqInt scratchReg);
static void NoDbgRegParms genLcByteSizeOfto(sqInt oop, sqInt resultRegister);
static void NoDbgRegParms genLcFloat32toOop(sqInt value, sqInt object);
static void NoDbgRegParms genLcFloat64toOop(sqInt value, sqInt object);
static void NoDbgRegParms genLcInstantiateOop(sqInt classOop);
static void NoDbgRegParms genLcInstantiateOopconstantIndexableSize(sqInt classOop, sqInt indexableSize);
static void NoDbgRegParms genLcInstantiateOopindexableSize(sqInt classOop, sqInt indexableSize);
static void NoDbgRegParms genLcInt64ToOop(sqInt value);
static void NoDbgRegParms genLcInt64ToOophighPart(sqInt valueLow, sqInt valueHigh);
static void NoDbgRegParms genLcOopToInt64(sqInt value);
static void NoDbgRegParms genLcOopToPointer(sqInt object);
static void NoDbgRegParms genLcOopToUInt64(sqInt value);
static void NoDbgRegParms genLcOoptoFloat32(sqInt object, sqInt value);
static void NoDbgRegParms genLcOoptoFloat64(sqInt object, sqInt value);
static void NoDbgRegParms genLcOoptoInt64highPart(sqInt object, sqInt valueLow, sqInt valueHigh);
static void NoDbgRegParms genLcOoptoUInt64highPart(sqInt object, sqInt valueLow, sqInt valueHigh);
static void NoDbgRegParms genLcPointerToOopclass(sqInt pointer, sqInt pointerClass);
static void NoDbgRegParms genLcUInt64ToOop(sqInt value);
static void NoDbgRegParms genLcUInt64ToOophighPart(sqInt valueLow, sqInt valueHigh);
static sqInt NoDbgRegParms genLoadSlotsourceRegdestReg(sqInt index, sqInt sourceReg, sqInt destReg);
static sqInt genPrimitiveAdd(void);
static sqInt genPrimitiveAsFloat(void);
static sqInt genPrimitiveBitAnd(void);
static sqInt genPrimitiveBitOr(void);
static sqInt genPrimitiveBitShift(void);
static sqInt genPrimitiveBitXor(void);
static sqInt genPrimitiveClass(void);
static sqInt genPrimitiveDiv(void);
static sqInt genPrimitiveDivide(void);
static sqInt genPrimitiveEqual(void);
static sqInt genPrimitiveFloatAdd(void);
static sqInt genPrimitiveFloatDivide(void);
static sqInt genPrimitiveFloatMultiply(void);
static sqInt genPrimitiveFloatSquareRoot(void);
static sqInt genPrimitiveFloatSubtract(void);
static sqInt genPrimitiveGreaterOrEqual(void);
static sqInt genPrimitiveGreaterThan(void);
static sqInt genPrimitiveHighBit(void);
static sqInt genPrimitiveIdentical(void);
static sqInt genPrimitiveLessOrEqual(void);
static sqInt genPrimitiveLessThan(void);
static sqInt genPrimitiveMod(void);
static sqInt genPrimitiveMultiply(void);
static sqInt genPrimitiveNewMethod(void);
static sqInt genPrimitiveNotEqual(void);
static sqInt genPrimitiveNotIdentical(void);
static sqInt genPrimitiveQuo(void);
static sqInt genPrimitiveSmallFloatAdd(void);
static sqInt genPrimitiveSmallFloatDivide(void);
static sqInt genPrimitiveSmallFloatEqual(void);
static sqInt genPrimitiveSmallFloatGreaterOrEqual(void);
static sqInt genPrimitiveSmallFloatGreaterThan(void);
static sqInt genPrimitiveSmallFloatLessOrEqual(void);
static sqInt genPrimitiveSmallFloatLessThan(void);
static sqInt genPrimitiveSmallFloatMultiply(void);
static sqInt genPrimitiveSmallFloatNotEqual(void);
static sqInt genPrimitiveSmallFloatSquareRoot(void);
static sqInt genPrimitiveSmallFloatSubtract(void);
static sqInt genPrimitiveSubtract(void);
static sqInt NoDbgRegParms genSmallIntegerComparison(sqInt jumpOpcode);
static sqInt NoDbgRegParms isUnannotatableConstant(CogSimStackEntry *simStackEntry);
static sqInt NoDbgRegParms classForInlineCacheTag(sqInt classIndex);
static sqInt NoDbgRegParms genAddSmallIntegerTagsTo(sqInt aRegister);
static AbstractInstruction * NoDbgRegParms genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(sqInt valueReg, sqInt resultReg, sqInt scratch1, sqInt scratch2);
static AbstractInstruction * NoDbgRegParms genAlloc64BitSignedIntegerValueintoscratchRegscratchReg(sqInt valueReg, sqInt resultReg, sqInt scratch1, sqInt scratch2);
static AbstractInstruction * NoDbgRegParms genAllocFloatValueintoscratchRegscratchReg(sqInt dpreg, sqInt resultReg, sqInt scratch1, sqInt scratch2);
static sqInt NoDbgRegParms genClearAndSetSmallIntegerTagsIn(sqInt scratchReg);
static sqInt NoDbgRegParms genConvertBitsToSmallFloatInscratch(sqInt reg, sqInt scratch);
static void NoDbgRegParms genConvertCharacterToSmallIntegerInReg(sqInt reg);
static sqInt NoDbgRegParms genConvertIntegerInRegtoSmallIntegerInReg(sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms genConvertIntegerToSmallIntegerInReg(sqInt reg);
static sqInt NoDbgRegParms genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(sqInt reg, sqInt scratch);
static void NoDbgRegParms genConvertSmallIntegerToCharacterInReg(sqInt reg);
static sqInt NoDbgRegParms genConvertSmallIntegerToIntegerInReg(sqInt reg);
static sqInt NoDbgRegParms genFetchRegArgsForPerformWithArguments(sqInt sizeReg);
static sqInt NoDbgRegParms genFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed);
static sqInt NoDbgRegParms genFloatComparisonorIntegerComparisoninvertboxed(AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt jumpOpcode, sqInt invertComparison, sqInt rcvrBoxed);
static sqInt NoDbgRegParms genGetHashFieldNonImmOfasSmallIntegerInto(sqInt instReg, sqInt destReg);
static sqInt NoDbgRegParms genGetHashFieldNonImmOfinto(sqInt instReg, sqInt destReg);
static AbstractInstruction * NoDbgRegParms genGetInlineCacheClassTagFromintoforEntry(sqInt sourceReg, sqInt destReg, sqInt forEntry);
static sqInt NoDbgRegParms genGetNumBytesOfinto(sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms genGetOverflowSlotsOfinto(sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms genGetSmallFloatValueOfscratchinto(sqInt oopReg, sqInt scratch, sqInt dpReg);
static AbstractInstruction * NoDbgRegParms genJumpIsSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg);
static AbstractInstruction * NoDbgRegParms genJumpNotCharacter(sqInt reg);
static AbstractInstruction * NoDbgRegParms genJumpNotSmallFloatValueBitsscratch(sqInt reg, sqInt exponent);
static AbstractInstruction * NoDbgRegParms genJumpNotSmallFloat(sqInt reg);
static AbstractInstruction * NoDbgRegParms genJumpNotSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg);
static AbstractInstruction * NoDbgRegParms genJumpNotSmallInteger(sqInt reg);
static AbstractInstruction * NoDbgRegParms genJumpSmallInteger(sqInt aRegister);
static sqInt NoDbgRegParms genLcInt32ToOop(sqInt value);
static sqInt NoDbgRegParms genLcOopToInt32(sqInt value);
static sqInt NoDbgRegParms genLcOopToUInt32(sqInt value);
static sqInt NoDbgRegParms genLcUInt32ToOop(sqInt value);
static sqInt NoDbgRegParms genPrimitiveAtPutSigned(sqInt signedVersion);
static sqInt NoDbgRegParms genPrimitiveAtSigned(sqInt signedVersion);
static sqInt genPrimitiveFloatEqual(void);
static sqInt genPrimitiveFloatGreaterOrEqual(void);
static sqInt genPrimitiveFloatGreaterThan(void);
static sqInt genPrimitiveFloatLessOrEqual(void);
static sqInt genPrimitiveFloatLessThan(void);
static sqInt genPrimitiveFloatNotEqual(void);
static sqInt genPrimitiveIdentityHash(void);
static sqInt genPrimitiveImmediateAsInteger(void);
static sqInt genPrimitiveNew(void);
static sqInt genPrimitiveNewWithArg(void);
static sqInt genPrimitiveShallowCopy(void);
static sqInt genPrimitiveSlotAt(void);
static sqInt genPrimitiveSlotAtPut(void);
static sqInt genPrimitiveStringAt(void);
static sqInt genPrimitiveStringAtPut(void);
static sqInt genPrimitiveUninitializedNewWithArg(void);
static sqInt NoDbgRegParms genPureFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed);
static sqInt NoDbgRegParms genPureFloatComparisoninvertboxed(AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt invertComparison, sqInt rcvrBoxed);
static sqInt NoDbgRegParms genRemoveSmallIntegerTagsInScratchReg(sqInt scratchReg);
static sqInt NoDbgRegParms genShiftAwaySmallIntegerTagsInScratchReg(sqInt scratchReg);
static sqInt NoDbgRegParms genSmallIntegerComparisonorDoubleComparisoninvert(sqInt jumpOpcode, AbstractInstruction * NoDbgRegParms (*jumpFPOpcodeGenerator)(void *), sqInt invertComparison);
static sqInt NoDbgRegParms getLiteralCountOfplusOneinBytesintoscratch(sqInt methodReg, sqInt plusOne, sqInt inBytes, sqInt litCountReg, sqInt scratchReg);
static sqInt NoDbgRegParms inlineCacheTagForInstance(sqInt oop);
static sqInt log2BytesPerWord(void);
static void maybeGenerateSelectorIndexDereferenceRoutine(void);
static sqInt numSmallIntegerBits(void);
static sqInt numSmallIntegerTagBits(void);
static sqInt NoDbgRegParms validInlineCacheTag(sqInt classIndexOrTagPattern);
static void callStoreCheckTrampoline(void);
static sqInt NoDbgRegParms checkValidDerivedObjectReference(sqInt bodyAddress);
static sqInt NoDbgRegParms checkValidOopReference(sqInt anOop);
static sqInt NoDbgRegParms couldBeDerivedObject(sqInt bodyAddress);
static sqInt NoDbgRegParms couldBeObject(sqInt literal);
static usqInt NoDbgRegParms genActiveContextTrampolineLargeinBlockcalled(sqInt isLarge, sqInt isInBlock, char *aString);
static AbstractInstruction * NoDbgRegParms genCheckRememberedBitOfscratch(sqInt objReg, sqInt scratchReg);
static sqInt NoDbgRegParms genConvertCharacterToCodeInReg(sqInt reg);
static sqInt NoDbgRegParms genConvertIntegerToCharacterInReg(sqInt reg);
static sqInt NoDbgRegParms genCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock);
static sqInt NoDbgRegParms genCreateFullClosurenumArgsnumCopiedignoreContextcontextNumArgslargeinBlock(sqInt compiledBlock, sqInt numArgs, sqInt numCopied, sqInt ignoreContext, sqInt contextNumArgs, sqInt contextIsLarge, sqInt contextIsBlock);
static sqInt NoDbgRegParms genEnsureObjInRegNotForwardedscratchReg(sqInt reg, sqInt scratch);
static sqInt NoDbgRegParms genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(sqInt reg, sqInt scratch, void *fwdJumpTarget, void *nonFwdJumpTargetOrZero);
static sqInt NoDbgRegParms genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(sqInt reg, sqInt scratch, sqInt index, sqInt objReg);
static void generateObjectRepresentationTrampolines(void);
static sqInt NoDbgRegParms genGetActiveContextLargeinBlock(sqInt isLarge, sqInt isInBlock);
static sqInt NoDbgRegParms genGetActiveContextNumArgslargeinBlock(sqInt numArgs, sqInt isLargeContext, sqInt isInBlock);
static sqInt NoDbgRegParms genGetBitsofFormatByteOfinto(sqInt mask, sqInt sourceReg, sqInt destReg);
static sqInt NoDbgRegParms genGetClassIndexOfNonImminto(sqInt sourceReg, sqInt destReg);
static sqInt NoDbgRegParms genGetClassObjectOfClassIndexintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static sqInt NoDbgRegParms genGetClassObjectOfintoscratchRegmayBeAForwarder(sqInt instReg, sqInt destReg, sqInt scratchReg, sqInt mayBeForwarder);
static AbstractInstruction * NoDbgRegParms genGetClassTagOfintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static sqInt NoDbgRegParms genGetCompactClassIndexNonImmOfinto(sqInt instReg, sqInt destReg);
static sqInt NoDbgRegParms genGetDoubleValueOfinto(sqInt srcReg, sqInt destFPReg);
static sqInt NoDbgRegParms genGetFormatOfinto(sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(sqInt sourceReg, sqInt destReg, sqInt scratchRegOrNone);
static sqInt NoDbgRegParms genGetNumSlotsOfinto(sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms genGetRawSlotSizeOfNonImminto(sqInt sourceReg, sqInt destReg);
static AbstractInstruction * NoDbgRegParms genJumpImmediate(sqInt aRegister);
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms genJumpImmutablescratchReg(sqInt sourceReg, sqInt scratchReg);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms genJumpMutablescratchReg(sqInt sourceReg, sqInt scratchReg);
#endif /* IMMUTABILITY */
static void NoDbgRegParms genLcFirstFieldPointer(sqInt objectReg);
static void NoDbgRegParms genLcFirstIndexableFieldPointer(sqInt objectReg);
static void NoDbgRegParms genLcIsBytesto(sqInt objectReg, sqInt valueReg);
static void NoDbgRegParms genLcIsFloatObjectto(sqInt objectReg, sqInt valueReg);
static void NoDbgRegParms genLcIsIndexableto(sqInt objectReg, sqInt valueReg);
static void NoDbgRegParms genLcIsIntegerObjectto(sqInt objectReg, sqInt valueReg);
static void NoDbgRegParms genLcIsPointersto(sqInt objectReg, sqInt valueReg);
static void NoDbgRegParms genLcIsWordsOrBytesto(sqInt objectReg, sqInt valueReg);
static void NoDbgRegParms genLcIsWordsto(sqInt objectReg, sqInt valueReg);
static void NoDbgRegParms genLcLoadObjectat(sqInt object, sqInt fieldIndex);
static void NoDbgRegParms genLcLoadObjectfield(sqInt object, sqInt fieldIndex);
static void NoDbgRegParms genLcStoreobjectat(sqInt value, sqInt object, sqInt fieldIndex);
static void NoDbgRegParms genLcStoreobjectfield(sqInt value, sqInt object, sqInt fieldIndex);
static sqInt NoDbgRegParms genNewArrayOfSizeinitialized(sqInt size, sqInt initialize);
static sqInt NoDbgRegParms genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock);
static sqInt genPrimitiveAsCharacter(void);
static sqInt genPrimitiveAt(void);
static sqInt genPrimitiveAtPut(void);
static sqInt NoDbgRegParms genPrimitiveIdenticalOrNotIf(sqInt orNot);
static sqInt genPrimitiveIntegerAt(void);
static sqInt genPrimitiveIntegerAtPut(void);
static sqInt genPrimitiveMakePoint(void);
static sqInt genPrimitiveObjectAt(void);
static sqInt genPrimitiveSize(void);
static sqInt genPrimitiveStringCompareWith(void);
static sqInt genPrimitiveStringReplace(void);
static sqInt NoDbgRegParms genSetSmallIntegerTagsIn(sqInt scratchReg);
static usqInt genStoreCheckContextReceiverTrampoline(void);
static sqInt NoDbgRegParms genStoreCheckReceiverRegvalueRegscratchReginFrame(sqInt destReg, sqInt valueReg, sqInt scratchReg, sqInt inFrame);
static sqInt NoDbgRegParms genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt inFrame, sqInt needsStoreCheck);
static sqInt NoDbgRegParms genStoreSourceRegslotIndexintoNewObjectInDestReg(sqInt sourceReg, sqInt index, sqInt destReg);
#if IMMUTABILITY
static usqInt NoDbgRegParms genStoreTrampolineCalledinstVarIndex(char *trampolineName, sqInt instVarIndex);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static sqInt NoDbgRegParms genStoreWithImmutabilityAndStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needRestoreRcvr);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static sqInt NoDbgRegParms genStoreWithImmutabilityButNoStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needRestoreRcvr);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static sqInt NoDbgRegParms genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needsStoreCheck, sqInt needRestoreRcvr);
#endif /* IMMUTABILITY */
static sqInt getActiveContextAllocatesInMachineCode(void);
static sqInt NoDbgRegParms inlineCacheTagIsYoung(sqInt cacheTag);
static AbstractInstruction * NoDbgRegParms jumpNotCharacterUnsignedValueInRegister(sqInt reg);
static sqInt NoDbgRegParms markAndTraceLiteralinatpc(sqInt literal, CogMethod *cogMethodOrNil, usqInt address);
static void NoDbgRegParms markAndTraceLiteralinat(sqInt literal, CogMethod *cogMethod, sqInt *address);
static void NoDbgRegParms markAndTraceUpdatedLiteralin(sqInt objOop, CogMethod *cogMethodOrNil);
static sqInt NoDbgRegParms maybeCompileRetryOfonPrimitiveFailflags(void (*primitiveRoutine)(void), sqInt primIndex, sqInt flags);
static sqInt NoDbgRegParms maybeShiftClassTagRegisterForMethodCacheProbe(sqInt classTagReg);
static sqInt numCharacterBits(void);
static sqInt NoDbgRegParms remapObject(sqInt objOop);
static sqInt NoDbgRegParms remapOop(sqInt objOop);
static sqInt NoDbgRegParms shouldAnnotateObjectReference(sqInt anOop);
static sqInt NoDbgRegParms slotOffsetOfInstVarIndex(sqInt index);
static SimStackEntry * NoDbgRegParms ensureSpilledAtfrom(SimStackEntry * self_in_ensureSpilledAtfrom, sqInt baseOffset, sqInt baseRegister);
static sqInt NoDbgRegParms isSameEntryAs(SimStackEntry * self_in_isSameEntryAs, CogSimStackEntry *ssEntry);
static sqInt NoDbgRegParms mayBeAForwarder(SimStackEntry * self_in_mayBeAForwarder);
static void NoDbgRegParms popToReg(SimStackEntry * self_in_popToReg, sqInt reg);
static sqInt NoDbgRegParms registerMask(SimStackEntry * self_in_registerMask);
static sqInt NoDbgRegParms registerMaskOrNone(SimStackEntry * self_in_registerMaskOrNone);
static sqInt NoDbgRegParms registerOrNone(SimStackEntry * self_in_registerOrNone);
static void NoDbgRegParms storeToReg(SimStackEntry * self_in_storeToReg, sqInt reg);
static void NoDbgRegParms ensureIsMarkedAsSpilled(CogSimStackNativeEntry * self_in_ensureIsMarkedAsSpilled);
static void NoDbgRegParms ensureSpilledSPscratchRegister(CogSimStackNativeEntry * self_in_ensureSpilledSPscratchRegister, sqInt spRegister, sqInt scratchRegister);
static sqInt NoDbgRegParms nativeFloatRegisterMask(CogSimStackNativeEntry * self_in_nativeFloatRegisterMask);
static sqInt NoDbgRegParms nativeFloatRegisterOrNone(CogSimStackNativeEntry * self_in_nativeFloatRegisterOrNone);
static void NoDbgRegParms nativePopToReg(CogSimStackNativeEntry * self_in_nativePopToReg, sqInt reg);
static void NoDbgRegParms nativePopToRegsecondReg(CogSimStackNativeEntry * self_in_nativePopToRegsecondReg, sqInt reg, sqInt secondReg);
static sqInt NoDbgRegParms nativeRegisterMask(CogSimStackNativeEntry * self_in_nativeRegisterMask);
static sqInt NoDbgRegParms nativeRegisterOrNone(CogSimStackNativeEntry * self_in_nativeRegisterOrNone);
static sqInt NoDbgRegParms nativeRegisterSecondOrNone(CogSimStackNativeEntry * self_in_nativeRegisterSecondOrNone);
static void NoDbgRegParms nativeStackPopToReg(CogSimStackNativeEntry * self_in_nativeStackPopToReg, sqInt reg);
static void NoDbgRegParms nativeStackPopToRegsecondReg(CogSimStackNativeEntry * self_in_nativeStackPopToRegsecondReg, sqInt reg, sqInt secondReg);
static sqInt NoDbgRegParms spillingNeedsScratchRegister(CogSimStackNativeEntry * self_in_spillingNeedsScratchRegister);
static sqInt NoDbgRegParms stackSpillSize(CogSimStackNativeEntry * self_in_stackSpillSize);
static sqInt NoDbgRegParms isMergeFixup(BytecodeFixup * self_in_isMergeFixup);
static sqInt NoDbgRegParms availableRegisterOrNoneFor(AbstractInstruction * self_in_availableRegisterOrNoneFor, sqInt liveRegsMask);
static sqInt NoDbgRegParms callFullInstructionByteSize(AbstractInstruction * self_in_callFullInstructionByteSize);
static sqInt NoDbgRegParms callFullTargetFromReturnAddress(AbstractInstruction * self_in_callFullTargetFromReturnAddress, sqInt callSiteReturnAddress);
static sqInt NoDbgRegParms callInstructionByteSize(AbstractInstruction * self_in_callInstructionByteSize);
static sqInt NoDbgRegParms callTargetFromReturnAddress(AbstractInstruction * self_in_callTargetFromReturnAddress, sqInt callSiteReturnAddress);
static void NoDbgRegParms cFloatResultToRd(AbstractInstruction * self_in_cFloatResultToRd, sqInt reg);
static void NoDbgRegParms cFloatResultToRs(AbstractInstruction * self_in_cFloatResultToRs, sqInt reg);
static sqInt NoDbgRegParms cmpC32RTempByteSize(AbstractInstruction * self_in_cmpC32RTempByteSize);
static sqInt NoDbgRegParms computeMaximumSize(AbstractInstruction * self_in_computeMaximumSize);
static sqInt NoDbgRegParms computeShiftRRSize(AbstractInstruction * self_in_computeShiftRRSize);
static sqInt NoDbgRegParms computeSizeOfPushCw(AbstractInstruction * self_in_computeSizeOfPushCw);
static sqInt NoDbgRegParms concretizeArithCqRWithROraxOpcode(AbstractInstruction * self_in_concretizeArithCqRWithROraxOpcode, sqInt regOpcode, sqInt raxOpcode);
static sqInt NoDbgRegParms concretizeFill32(AbstractInstruction * self_in_concretizeFill32);
static sqInt NoDbgRegParms concretizeMovePerfCnt64RL(AbstractInstruction * self_in_concretizeMovePerfCnt64RL);
static sqInt NoDbgRegParms concretizeMoveRX32rR(AbstractInstruction * self_in_concretizeMoveRX32rR);
static sqInt NoDbgRegParms concretizeMoveX32rRR(AbstractInstruction * self_in_concretizeMoveX32rRR);
static sqInt NoDbgRegParms concretizeOpRR(AbstractInstruction * self_in_concretizeOpRR, sqInt x64opcode);
static sqInt NoDbgRegParms concretizePrefetchAw(AbstractInstruction * self_in_concretizePrefetchAw);
static sqInt NoDbgRegParms concretizeReverseOpRR(AbstractInstruction * self_in_concretizeReverseOpRR, sqInt x64opcode);
static sqInt NoDbgRegParms concretizeSet(AbstractInstruction * self_in_concretizeSet, sqInt conditionCode);
static sqInt NoDbgRegParms concretizeXCHGRR(AbstractInstruction * self_in_concretizeXCHGRR);
static void NoDbgRegParms detectFeatures(AbstractInstruction * self_in_detectFeatures);
static sqInt NoDbgRegParms dispatchConcretize(AbstractInstruction * self_in_dispatchConcretize);
static sqInt NoDbgRegParms dispatchConcretizeProcessorSpecific(AbstractInstruction * self_in_dispatchConcretizeProcessorSpecific);
static sqInt NoDbgRegParms fullCallsAreRelative(AbstractInstruction * self_in_fullCallsAreRelative);
static AbstractInstruction * NoDbgRegParms genDivRRQuoRem(AbstractInstruction * self_in_genDivRRQuoRem, sqInt abstractRegDivisor, sqInt abstractRegDividend, sqInt abstractRegQuotient, sqInt abstractRegRemainder);
static void NoDbgRegParms genMemCopytoconstantSize(AbstractInstruction * self_in_genMemCopytoconstantSize, sqInt originalSourceReg, sqInt originalDestReg, sqInt size);
static void NoDbgRegParms genMemCopytosize(AbstractInstruction * self_in_genMemCopytosize, sqInt originalSourceReg, sqInt originalDestReg, sqInt originalSize);
static AbstractInstruction * NoDbgRegParms genMulRR(AbstractInstruction * self_in_genMulRR, sqInt regSource, sqInt regDest);
static AbstractInstruction * NoDbgRegParms genPushRegisterArgsForAbortMissNumArgs(AbstractInstruction * self_in_genPushRegisterArgsForAbortMissNumArgs, sqInt numArgs);
static void NoDbgRegParms genPushRegisterArgsForNumArgsscratchReg(AbstractInstruction * self_in_genPushRegisterArgsForNumArgsscratchReg, sqInt numArgs, sqInt scratchReg);
static sqInt NoDbgRegParms genRemoveNArgsFromStack(AbstractInstruction * self_in_genRemoveNArgsFromStack, sqInt n);
static sqInt NoDbgRegParms genRestoreRegs(AbstractInstruction * self_in_genRestoreRegs, sqInt regMask);
static sqInt NoDbgRegParms genSaveRegs(AbstractInstruction * self_in_genSaveRegs, sqInt regMask);
static AbstractInstruction * NoDbgRegParms genSubstituteReturnAddress(AbstractInstruction * self_in_genSubstituteReturnAddress, sqInt retpc);
static AbstractInstruction * NoDbgRegParms genSwapRRScratch(AbstractInstruction * self_in_genSwapRRScratch, sqInt regA, sqInt regB, sqInt regTmp);
static sqInt NoDbgRegParms hasVarBaseRegister(AbstractInstruction * self_in_hasVarBaseRegister);
static sqInt NoDbgRegParms instructionSizeAt(AbstractInstruction * self_in_instructionSizeAt, sqInt pc);
static sqInt NoDbgRegParms is32BitSignedImmediate(AbstractInstruction * self_in_is32BitSignedImmediate, sqInt a64BitUnsignedOperand);
static sqInt NoDbgRegParms isCallPrecedingReturnPC(AbstractInstruction * self_in_isCallPrecedingReturnPC, sqInt mcpc);
static sqInt NoDbgRegParms isJumpAt(AbstractInstruction * self_in_isJumpAt, sqInt pc);
static sqInt NoDbgRegParms isQuick(AbstractInstruction * self_in_isQuick, usqIntptr_t operand);
static sqInt NoDbgRegParms isWithinMwOffsetRange(AbstractInstruction * self_in_isWithinMwOffsetRange, sqInt anAddress);
static AbstractInstruction * NoDbgRegParms jmpTarget(AbstractInstruction * self_in_jmpTarget, AbstractInstruction *anAbstractInstruction);
static sqInt NoDbgRegParms jumpLongByteSize(AbstractInstruction * self_in_jumpLongByteSize);
static sqInt NoDbgRegParms jumpLongConditionalByteSize(AbstractInstruction * self_in_jumpLongConditionalByteSize);
static sqInt NoDbgRegParms jumpLongTargetBeforeFollowingAddress(AbstractInstruction * self_in_jumpLongTargetBeforeFollowingAddress, sqInt mcpc);
static usqInt NoDbgRegParms jumpTargetPCAt(AbstractInstruction * self_in_jumpTargetPCAt, sqInt pc);
static sqInt NoDbgRegParms leafCallStackPointerDelta(AbstractInstruction * self_in_leafCallStackPointerDelta);
static sqInt NoDbgRegParms literalBeforeInlineCacheTagAt(AbstractInstruction * self_in_literalBeforeInlineCacheTagAt, sqInt callSiteReturnAddress);
static sqInt NoDbgRegParms loadPICLiteralByteSize(AbstractInstruction * self_in_loadPICLiteralByteSize);
static usqInt NoDbgRegParms machineCodeAt(AbstractInstruction * self_in_machineCodeAt, sqInt anOffset);
static sqInt NoDbgRegParms machineCodeBytes(AbstractInstruction * self_in_machineCodeBytes);
static sqInt NoDbgRegParms modRMRO(AbstractInstruction * self_in_modRMRO, sqInt mod, sqInt regMode, sqInt regOpcode);
static sqInt NoDbgRegParms numIntRegArgs(AbstractInstruction * self_in_numIntRegArgs);
static void NoDbgRegParms padIfPossibleWithStopsFromto(AbstractInstruction * self_in_padIfPossibleWithStopsFromto, sqInt startAddr, sqInt endAddr);
static sqInt NoDbgRegParms registerToSaveIP(AbstractInstruction * self_in_registerToSaveIP);
static void NoDbgRegParms relocateCallBeforeReturnPCby(AbstractInstruction * self_in_relocateCallBeforeReturnPCby, sqInt retpc, sqInt delta);
static void NoDbgRegParms relocateMethodReferenceBeforeAddressby(AbstractInstruction * self_in_relocateMethodReferenceBeforeAddressby, sqInt pc, sqInt delta);
static sqInt NoDbgRegParms rewriteCallAttarget(AbstractInstruction * self_in_rewriteCallAttarget, usqInt callSiteReturnAddress, usqInt callTargetAddress);
static sqInt NoDbgRegParms rewriteCallFullAttarget(AbstractInstruction * self_in_rewriteCallFullAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static void NoDbgRegParms rewriteCPICJumpAttarget(AbstractInstruction * self_in_rewriteCPICJumpAttarget, usqInt addressFollowingJump, usqInt jumpTargetAddr);
static sqInt NoDbgRegParms rewriteInlineCacheAttagtarget(AbstractInstruction * self_in_rewriteInlineCacheAttagtarget, usqInt callSiteReturnAddress, sqInt cacheTag, usqInt callTargetAddress);
static void NoDbgRegParms rewriteInlineCacheTagat(AbstractInstruction * self_in_rewriteInlineCacheTagat, sqInt cacheTag, sqInt callSiteReturnAddress);
static sqInt NoDbgRegParms rewriteJumpFullAttarget(AbstractInstruction * self_in_rewriteJumpFullAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static sqInt NoDbgRegParms rexRxb(AbstractInstruction * self_in_rexRxb, sqInt reg, sqInt sibReg, sqInt fieldReg);
static sqInt NoDbgRegParms rexwrxb(AbstractInstruction * self_in_rexwrxb, sqInt width64, sqInt reg, sqInt sibReg, sqInt fieldReg);
static sqInt NoDbgRegParms setsConditionCodesFor(AbstractInstruction * self_in_setsConditionCodesFor, sqInt aConditionalJumpOpcode);
static sqInt NoDbgRegParms sizeHasModrmat(AbstractInstruction * self_in_sizeHasModrmat, sqInt op, sqInt pc);
static sqInt NoDbgRegParms sizeImmediateGroup1at(AbstractInstruction * self_in_sizeImmediateGroup1at, sqInt op, sqInt pc);
static void NoDbgRegParms stopsFromto(AbstractInstruction * self_in_stopsFromto, sqInt startAddr, sqInt endAddr);
static void NoDbgRegParms storeLiteral32beforeFollowingAddress(AbstractInstruction * self_in_storeLiteral32beforeFollowingAddress, sqInt literal, sqInt followingAddress);
static sqInt NoDbgRegParms sib(AbstractInstruction * self_in_sib, sqInt scale, sqInt indexReg, sqInt baseReg);
static sqInt NoDbgRegParms twoByteInstructionSizeAt(AbstractInstruction * self_in_twoByteInstructionSizeAt, sqInt pc);
static sqInt NoDbgRegParms zoneCallsAreRelative(AbstractInstruction * self_in_zoneCallsAreRelative);
extern sqInt cogMethodHasExternalPrim(CogMethod *aCogMethod);
extern sqInt cogMethodHasMachineCodePrim(CogMethod *aCogMethod);
static sqInt compileBlockDispatch(void);
static void compileGetErrorCode(void);
static sqInt compileInterpreterPrimitive(void);
static sqInt NoDbgRegParms compileInterpreterPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags);
static sqInt NoDbgRegParms compileOnStackExternalPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags);
static AbstractInstruction * NoDbgRegParms compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selector, sqInt shift, sqInt baseRegOrNone);
static void NoDbgRegParms compileOpenPICnumArgs(sqInt selector, sqInt numArgs);
static AbstractInstruction * NoDbgRegParms compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selectorReg, sqInt shift, sqInt baseRegOrNone);
static sqInt compilePrimitive(void);
static sqInt extendedPushBytecode(void);
static sqInt extendedStoreAndPopBytecode(void);
static sqInt extendedStoreBytecode(void);
static sqInt frameOffsetOfNativeFrameMark(void);
static sqInt frameOffsetOfNativeFramePointer(void);
static sqInt frameOffsetOfNativeStackPointer(void);
static sqInt frameOffsetOfPreviousNativeStackPointer(void);
static sqInt NoDbgRegParms frameOffsetOfTemporary(sqInt index);
static sqInt genCallMappedInlinedPrimitive(void);
static AbstractInstruction * NoDbgRegParms genDoubleFailIfZeroArgRcvrarg(int rcvrReg, int argReg);
static sqInt genExtendedSendBytecode(void);
static sqInt genExtendedSuperBytecode(void);
static sqInt genExtJumpIfFalse(void);
static sqInt genExtJumpIfTrue(void);
static sqInt genExtNopBytecode(void);
static sqInt genExtPushCharacterBytecode(void);
static sqInt genExtPushIntegerBytecode(void);
static sqInt genExtPushLiteralBytecode(void);
static sqInt genExtPushLiteralVariableBytecode(void);
static sqInt genExtPushPseudoVariable(void);
static sqInt genExtPushReceiverVariableBytecode(void);
static sqInt genExtSendBytecode(void);
static sqInt genExtSendSuperBytecode(void);
static sqInt genExtStoreAndPopLiteralVariableBytecode(void);
static sqInt genExtStoreAndPopReceiverVariableBytecode(void);
static sqInt genExtStoreLiteralVariableBytecode(void);
static sqInt genExtStoreReceiverVariableBytecode(void);
static sqInt genExtUnconditionalJump(void);
static sqInt genFastPrimFail(void);
static void NoDbgRegParms genFastPrimTraceUsingand(sqInt r1, sqInt r2);
static void genLoadNewMethod(void);
static sqInt genLongJumpIfFalse(void);
static sqInt genLongJumpIfTrue(void);
static sqInt genLongPushTemporaryVariableBytecode(void);
static sqInt genLongStoreAndPopTemporaryVariableBytecode(void);
static sqInt genLongStoreTemporaryVariableBytecode(void);
static sqInt genLongUnconditionalBackwardJump(void);
static sqInt genLongUnconditionalForwardJump(void);
static sqInt NoDbgRegParms genLookupForPerformNumArgs(sqInt numArgs);
static usqInt NoDbgRegParms genMustBeBooleanTrampolineForcalled(sqInt boolean, char *trampolineName);
static sqInt genPrimitiveHashMultiply(void);
static void NoDbgRegParms genPrimReturnEnterCogCodeEnilopmart(sqInt profiling);
static sqInt genPushConstantFalseBytecode(void);
static sqInt genPushConstantNilBytecode(void);
static sqInt genPushConstantOneBytecode(void);
static sqInt genPushConstantTrueBytecode(void);
static sqInt genPushConstantZeroBytecode(void);
static sqInt genPushLiteralConstantBytecode(void);
static sqInt genPushLiteralVariable16CasesBytecode(void);
static sqInt genPushLiteralVariableBytecode(void);
static sqInt genPushQuickIntegerConstantBytecode(void);
static sqInt genPushReceiverVariableBytecode(void);
static sqInt genPushTemporaryVariableBytecode(void);
extern sqInt genQuickReturnConst(void);
extern sqInt genQuickReturnInstVar(void);
extern sqInt genQuickReturnSelf(void);
static sqInt genReturnFalse(void);
static sqInt genReturnNil(void);
static sqInt genReturnNilFromBlock(void);
static sqInt genReturnTrue(void);
static sqInt genSecondExtendedSendBytecode(void);
static sqInt genSendLiteralSelector0ArgsBytecode(void);
static sqInt genSendLiteralSelector1ArgBytecode(void);
static sqInt genSendLiteralSelector2ArgsBytecode(void);
static sqInt genShortJumpIfFalse(void);
static sqInt genShortJumpIfTrue(void);
static sqInt genShortUnconditionalJump(void);
static sqInt genSpecialSelectorEqualsEquals(void);
static sqInt genSpecialSelectorNotEqualsEquals(void);
static sqInt genSpecialSelectorSend(void);
static sqInt genStoreAndPopReceiverVariableBytecode(void);
static sqInt genStoreAndPopRemoteTempLongBytecode(void);
static sqInt genStoreAndPopTemporaryVariableBytecode(void);
static sqInt genStoreRemoteTempLongBytecode(void);
static void genTakeProfileSample(void);
static sqInt genUnconditionalTrapBytecode(void);
static void NoDbgRegParms loadNativeArgumentAddressto(sqInt baseOffset, sqInt reg);
static void NoDbgRegParms loadNativeFramePointerInto(sqInt reg);
static void NoDbgRegParms loadNativeLocalAddressto(sqInt baseOffset, sqInt reg);
extern sqInt mapPCDataForinto(CogMethod *cogMethod, sqInt arrayObj);
static sqInt numSpecialSelectors(void);
static usqInt NoDbgRegParms pcDataForBlockEntryMethod(sqInt blockEntryMcpc, sqInt cogMethod);
static sqInt NoDbgRegParms pcDataForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg);
static PrimitiveDescriptor * primitiveGeneratorOrNil(void);
static sqInt NoDbgRegParms registerisInMask(sqInt reg, sqInt mask);
static sqInt NoDbgRegParms registerisNotInMask(sqInt reg, sqInt mask);
static sqInt NoDbgRegParms v3BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v3LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v3LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v3ShortForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v4BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v4LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v4LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
extern double getCogCodeZoneThreshold(void);
extern sqInt setCogCodeZoneThreshold(double ratio);
static BlockStart * NoDbgRegParms addBlockStartAtnumArgsnumCopiedspan(sqInt bytecodepc, sqInt numArgs, sqInt numCopied, sqInt span);
static void NoDbgRegParms adjustArgumentsForPerform(sqInt numArgs);
static sqInt NoDbgRegParms allocateFloatRegNotConflictingWith(sqInt regMask);
static sqInt NoDbgRegParms allocateRegForStackEntryAtnotConflictingWith(sqInt index, sqInt regMask);
static sqInt NoDbgRegParms allocateRegNotConflictingWith(sqInt regMask);
static sqInt NoDbgRegParms anyReferencesToRegisterinTopNItems(sqInt reg, sqInt n);
static void NoDbgRegParms beginHighLevelCall(sqInt alignment);
extern void callCogCodePopReceiverArg0Regs(void);
extern void callCogCodePopReceiverArg1Arg0Regs(void);
static sqInt callSwitchToCStack(void);
static void callSwitchToSmalltalkStack(void);
static sqInt NoDbgRegParms compileAbstractInstructionsFromthrough(sqInt start, sqInt end);
static sqInt compileBlockBodies(void);
static void NoDbgRegParms compileBlockFrameBuild(BlockStart *blockStart);
static void NoDbgRegParms compileBlockFramelessEntry(BlockStart *blockStart);
static CogMethod * NoDbgRegParms compileCogFullBlockMethod(sqInt numCopied);
static CogMethod * NoDbgRegParms compileCogMethod(sqInt selector);
static sqInt compileEntireMethod(void);
static void compileFrameBuild(void);
static void NoDbgRegParms compileFullBlockFramelessEntry(sqInt numCopied);
static void NoDbgRegParms compileFullBlockMethodFrameBuild(sqInt numCopied);
#if IMMUTABILITY
static void compileTwoPathFrameBuild(void);
#endif /* IMMUTABILITY */
static void compileTwoPathFramelessInit(void);
static sqInt NoDbgRegParms cPICMissTrampolineFor(sqInt numArgs);
static sqInt doubleExtendedDoAnythingBytecode(void);
static sqInt duplicateTopBytecode(void);
static void endHighLevelCallWithCleanup(void);
static void endHighLevelCallWithoutCleanup(void);
static BytecodeFixup * NoDbgRegParms ensureFixupAt(sqInt targetPC);
static BytecodeFixup * NoDbgRegParms ensureNonMergeFixupAt(sqInt targetPC);
static void ensureReceiverResultRegContainsSelf(void);
static void NoDbgRegParms evaluateat(BytecodeDescriptor *descriptor, sqInt pc);
static sqInt NoDbgRegParms eventualTargetOf(sqInt targetBytecodePC);
static sqInt NoDbgRegParms freeAnyFloatRegNotConflictingWith(sqInt regMask);
static sqInt NoDbgRegParms freeAnyRegNotConflictingWith(sqInt regMask);
static sqInt genBlockReturn(void);
static void (*genCallPICEnilopmartNumArgs(sqInt numArgs))(void);
static sqInt genCallPrimitiveBytecode(void);
static sqInt genExternalizePointersForPrimitiveCall(void);
static AbstractInstruction * genExternalizeStackPointerForFastPrimitiveCall(void);
static sqInt genExtPushClosureBytecode(void);
static sqInt genExtPushFullClosureBytecode(void);
static void generateEnilopmarts(void);
static sqInt NoDbgRegParms generateInstructionsAt(sqInt eventualAbsoluteAddress);
static void generateMissAbortTrampolines(void);
static void generateSendTrampolines(void);
static void generateTracingTrampolines(void);
static sqInt NoDbgRegParms genForwardersInlinedIdenticalOrNotIf(sqInt orNot);
static sqInt NoDbgRegParms genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(sqInt argIsConstant, sqInt rcvrIsConstant, sqInt argReg, sqInt rcvrRegOrNone, sqInt orNot);
static sqInt NoDbgRegParms genInlinedIdenticalOrNotIf(sqInt orNot);
static sqInt NoDbgRegParms genJumpBackTo(sqInt targetBytecodePC);
static sqInt NoDbgRegParms genJumpIfto(sqInt boolean, sqInt targetBytecodePC);
static sqInt NoDbgRegParms genJumpTo(sqInt targetBytecodePC);
static sqInt NoDbgRegParms genLowcodeBinaryInlinePrimitive(sqInt prim);
static sqInt NoDbgRegParms genLowcodeNullaryInlinePrimitive(sqInt prim);
static sqInt NoDbgRegParms genLowcodeTrinaryInlinePrimitive(sqInt prim);
static sqInt NoDbgRegParms genLowcodeUnaryInlinePrimitive2(sqInt prim);
static sqInt NoDbgRegParms genLowcodeUnaryInlinePrimitive3(sqInt prim);
static sqInt NoDbgRegParms genLowcodeUnaryInlinePrimitive4(sqInt prim);
static sqInt NoDbgRegParms genLowcodeUnaryInlinePrimitive5(sqInt prim);
static sqInt NoDbgRegParms genLowcodeUnaryInlinePrimitive(sqInt prim);
static sqInt NoDbgRegParms genMarshalledSendnumArgssendTable(sqInt selectorIndex, sqInt numArgs, sqInt *sendTable);
static usqInt NoDbgRegParms genMethodAbortTrampolineFor(sqInt numArgs);
static usqInt NoDbgRegParms genPICAbortTrampolineFor(sqInt numArgs);
static usqInt NoDbgRegParms genPICMissTrampolineFor(sqInt numArgs);
static sqInt genPopStackBytecode(void);
static sqInt genPrimitiveClosureValue(void);
static sqInt genPrimitiveFullClosureValue(void);
static sqInt genPrimitivePerform(void);
static sqInt genPrimitivePerformWithArguments(void);
static sqInt genPushActiveContextBytecode(void);
static sqInt genPushClosureCopyCopiedValuesBytecode(void);
static sqInt NoDbgRegParms genPushLiteralIndex(sqInt literalIndex);
static sqInt NoDbgRegParms genPushLiteralVariable(sqInt literalIndex);
static sqInt NoDbgRegParms genPushMaybeContextReceiverVariable(sqInt slotIndex);
static sqInt genPushNewArrayBytecode(void);
static sqInt genPushReceiverBytecode(void);
static sqInt NoDbgRegParms genPushReceiverVariable(sqInt index);
static void genPushRegisterArgs(void);
static sqInt genPushRemoteTempLongBytecode(void);
static sqInt NoDbgRegParms genPushTemporaryVariable(sqInt index);
static sqInt genReturnReceiver(void);
static sqInt genReturnTopFromBlock(void);
static sqInt genReturnTopFromMethod(void);
static sqInt NoDbgRegParms genSendDirectedSupernumArgs(sqInt selectorIndex, sqInt numArgs);
static sqInt NoDbgRegParms genSendSupernumArgs(sqInt selectorIndex, sqInt numArgs);
static usqInt NoDbgRegParms genSendTrampolineFornumArgscalledargargargarg(void *aRoutine, sqInt numArgs, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3);
static sqInt NoDbgRegParms genSendnumArgs(sqInt selectorIndex, sqInt numArgs);
static sqInt genSpecialSelectorArithmetic(void);
static sqInt genSpecialSelectorClass(void);
static sqInt genSpecialSelectorComparison(void);
static sqInt genStaticallyResolvedSpecialSelectorComparison(void);
static sqInt NoDbgRegParms genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt litVarIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static sqInt NoDbgRegParms genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static sqInt NoDbgRegParms genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static sqInt NoDbgRegParms genStorePopRemoteTempAtneedsStoreCheck(sqInt popBoolean, sqInt slotIndex, sqInt remoteTempIndex, sqInt needsStoreCheck);
static sqInt NoDbgRegParms genStorePopTemporaryVariable(sqInt popBoolean, sqInt tempIndex);
static sqInt genUpArrowReturn(void);
static sqInt NoDbgRegParms genVanillaInlinedIdenticalOrNotIf(sqInt orNot);
static void NoDbgRegParms initSimStackForFramefulMethod(sqInt startpc);
static void NoDbgRegParms initSimStackForFramelessBlock(sqInt startpc);
static void NoDbgRegParms initSimStackForFramelessMethod(sqInt startpc);
static sqInt NoDbgRegParms isNonForwarderReceiver(sqInt reg);
static void leaveNativeFrame(void);
static sqInt liveFloatRegisters(void);
static sqInt liveRegisters(void);
static sqInt NoDbgRegParms mapDeadDescriptorIfNeeded(BytecodeDescriptor *descriptor);
static void NoDbgRegParms marshallSendArguments(sqInt numArgs);
static sqInt maybeCompilingFirstPassOfBlockWithInitialPushNil(void);
static sqInt NoDbgRegParms mergeWithFixupIfRequired(BytecodeFixup *fixup);
static sqInt NoDbgRegParms methodAbortTrampolineFor(sqInt numArgs);
static sqInt methodFoundInvalidPostScan(void);
static sqInt NoDbgRegParms needsFrameIfMod16GENumArgs(sqInt stackDelta);
static sqInt NoDbgRegParms needsFrameIfStackGreaterThanOne(sqInt stackDelta);
static sqInt NoDbgRegParms numberOfSpillsInTopNItems(sqInt n);
static sqInt NoDbgRegParms picAbortTrampolineFor(sqInt numArgs);
static sqInt prevInstIsPCAnnotated(void);
static sqInt receiverIsInReceiverResultReg(void);
static void NoDbgRegParms reinitializeFixupsFromthrough(sqInt start, sqInt end);
static sqInt NoDbgRegParms scanBlock(BlockStart *blockStart);
static sqInt scanMethod(void);
static sqInt NoDbgRegParms squeakV3orSistaV1PushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils);
static sqInt NoDbgRegParms squeakV3orSistaV1NumPushNils(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static void NoDbgRegParms ssAllocateRequiredFloatRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr);
static void NoDbgRegParms ssAllocateRequiredFloatReg(sqInt requiredReg);
static void NoDbgRegParms ssAllocateRequiredRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr);
static void NoDbgRegParms ssFlushUpThroughReceiverVariable(sqInt slotIndex);
static void NoDbgRegParms ssFlushUpThroughTemporaryVariable(sqInt tempIndex);
static void NoDbgRegParms ssNativeFlushTo(sqInt index);
static void NoDbgRegParms ssNativePop(sqInt n);
static void NoDbgRegParms ssNativePush(sqInt n);
static CogSimStackNativeEntry * ssNativeTop(void);
static CogSimStackNativeEntry * NoDbgRegParms ssNativeValue(sqInt n);
static void NoDbgRegParms ssPopNativeSize(sqInt popSize);
static void NoDbgRegParms ssPop(sqInt n);
static sqInt NoDbgRegParms ssPushAnnotatedConstant(sqInt literal);
static sqInt NoDbgRegParms ssPushBaseoffset(sqInt reg, sqInt offset);
static sqInt NoDbgRegParms ssPushConstant(sqInt literal);
static sqInt NoDbgRegParms ssPushDesc(SimStackEntry simStackEntry);
static sqInt NoDbgRegParms ssPushNativeConstantFloat32(float aFloat32);
static sqInt NoDbgRegParms ssPushNativeConstantFloat64(double aFloat64);
static sqInt NoDbgRegParms ssPushNativeConstantInt32(sqInt anInt32);
static sqInt NoDbgRegParms ssPushNativeConstantInt64(sqLong anInt64);
static sqInt NoDbgRegParms ssPushNativeConstantPointer(sqInt aNativePointer);
static sqInt NoDbgRegParms ssPushNativeRegisterDoubleFloat(sqInt reg);
static sqInt NoDbgRegParms ssPushNativeRegisterSingleFloat(sqInt reg);
static sqInt NoDbgRegParms ssPushNativeRegister(sqInt reg);
static sqInt NoDbgRegParms ssPushNativeRegistersecondRegister(sqInt reg, sqInt secondReg);
static sqInt NoDbgRegParms ssPushRegister(sqInt reg);
static void NoDbgRegParms ssPush(sqInt n);
static SimStackEntry ssSelfDescriptor(void);
static void NoDbgRegParms ssStoreAndReplacePoptoReg(sqInt popBoolean, sqInt reg);
static sqInt NoDbgRegParms ssStorePoptoPreferredReg(sqInt popBoolean, sqInt preferredReg);
static void NoDbgRegParms ssStorePoptoReg(sqInt popBoolean, sqInt reg);
static CogSimStackEntry * ssTop(void);
static CogSimStackEntry * NoDbgRegParms ssValue(sqInt n);
static sqInt NoDbgRegParms stackEntryIsBoolean(CogSimStackEntry *simStackEntry);
static sqInt tempsValidAndVolatileEntriesSpilled(void);
static sqInt NoDbgRegParms tryCollapseTempVectorInitializationOfSize(sqInt slots);
static sqInt violatesEnsureSpilledSpillAssert(void);
static void voidReceiverResultRegContainsSelf(void);


/*** Variables ***/
static AbstractInstruction * abstractOpcodes;
static usqInt allocationThreshold;
static usqInt baseAddress;
static sqInt blockCount;
static AbstractInstruction * blockEntryLabel;
static AbstractInstruction * blockEntryNoContextSwitch;
static BlockStart * blockStarts;
static sqInt breakBlock;
static sqInt breakMethod;
static sqInt byte0;
static sqInt byte1;
static sqInt byte2;
static sqInt byte3;
static sqInt bytecodePC;
static sqInt bytecodeSetOffset;
static sqInt ceByteSizeOfTrampoline;
static sqInt ceCPICMissTrampoline;
static sqInt ceDereferenceSelectorIndex;
static sqInt ceFetchContextInstVarTrampoline;
static sqInt ceFFICalloutTrampoline;
static sqInt ceFloatObjectOfTrampoline;
static sqInt ceFloatValueOfTrampoline;
static sqInt ceFlushICache;
static sqInt ceFreeTrampoline;
static sqInt ceInlineNewHashTrampoline;
static sqInt ceInstantiateClassIndexableSizeTrampoline;
static sqInt ceInstantiateClassTrampoline;
static sqInt ceLargeActiveContextInBlockTrampoline;
static sqInt ceLargeActiveContextInFullBlockTrampoline;
static sqInt ceLargeActiveContextInMethodTrampoline;
static sqInt ceMallocTrampoline;
static sqInt ceMethodAbortTrampoline;
static sqInt ceNewHashTrampoline;
static sqInt ceNonLocalReturnTrampoline;
static sqInt cePICAbortTrampoline;
static sqInt cePositive64BitIntegerTrampoline;
static sqInt cePositive64BitValueOfTrampoline;
static sqInt cePrimReturnEnterCogCode;
static sqInt cePrimReturnEnterCogCodeProfiling;
static sqInt ceReapAndResetErrorCodeTrampoline;
static sqInt ceScheduleScavengeTrampoline;
static sqInt ceSendMustBeBooleanAddFalseTrampoline;
static sqInt ceSendMustBeBooleanAddTrueTrampoline;
static sqInt ceSigned64BitIntegerTrampoline;
static sqInt ceSigned64BitValueOfTrampoline;
static sqInt ceSmallActiveContextInBlockTrampoline;
static sqInt ceSmallActiveContextInFullBlockTrampoline;
static sqInt ceSmallActiveContextInMethodTrampoline;
static sqInt ceStoreCheckContextReceiverTrampoline;
static sqInt ceStoreCheckTrampoline;
static sqInt ceStoreContextInstVarTrampoline;
static sqInt ceTraceBlockActivationTrampoline;
static sqInt ceTraceLinkedSendTrampoline;
static sqInt ceTraceStoreTrampoline;
static sqInt checkedEntryAlignment;
static sqInt closedPICSize;
static sqInt codeBase;
static sqInt codeModified;
#if DUAL_MAPPED_CODE_ZONE
static sqInt codeToDataDelta;
#else
# define codeToDataDelta 0
#endif
static sqInt cogConstituentIndex;
static sqInt compactionInProgress;
static sqInt compilationPass;
static sqInt compilationTrace;
static sqInt cPICCaseSize;
static sqInt cPICEndOfCodeOffset;
static sqInt cPICEndSize;
static CogMethod * cPICPrototype;
static usqIntptr_t cpuidWord1;
static sqInt currentCallCleanUpSize;
static sqInt deadCode;
static sqInt debugBytecodePointers;
static sqInt debugFixupBreaks;
static sqInt debugOpcodeIndices;
static sqInt debugStackPointers;
static sqInt directedSendUsesBinding;
static sqInt directedSuperBindingSendTrampolines[NumSendTrampolines];
static sqInt directedSuperSendTrampolines[NumSendTrampolines];
static sqInt disassemblingMethod;
static AbstractInstruction * endCPICCase0;
static sqInt endPC;
static AbstractInstruction * entry;
static sqInt entryPointMask;
static CogMethod * enumeratingCogMethod;
static sqInt expectedFPAlignment;
static sqInt expectedSPAlignment;
static sqInt extA;
static sqInt extB;
static sqInt firstCPICCaseOffset;
static sqInt firstSend;
static BytecodeFixup * fixups;
static AbstractInstruction * fullBlockEntry;
static AbstractInstruction * fullBlockNoContextSwitchEntry;
static BytecodeDescriptor generatorTable[512] = {
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushReceiverBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantTrueBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantFalseBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantNilBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genReturnReceiver, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTrue, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnFalse, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnNil, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTopFromMethod, 0, needsFrameIfInBlock, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTopFromBlock, 0, needsFrameNever, -1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ extendedPushBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ extendedStoreBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ extendedStoreAndPopBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ genExtendedSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ doubleExtendedDoAnythingBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtendedSuperBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0 },
	{ genSecondExtendedSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genPopStackBytecode, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ duplicateTopBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushActiveContextBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushNewArrayBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genCallPrimitiveBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushClosureCopyCopiedValuesBytecode, v3BlockCodeSize, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AddRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, SubRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLess, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreater, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLessOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreaterOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpNonZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AndRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, OrRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorClass, 0, needsFrameIfStackGreaterThanOne, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorNotEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushReceiverBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantTrueBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantFalseBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantNilBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantZeroBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantOneBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushPseudoVariable, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ duplicateTopBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genReturnReceiver, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTrue, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnFalse, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnNil, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTopFromMethod, 0, needsFrameIfInBlock, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnNilFromBlock, 0, needsFrameNever, -1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
	{ genReturnTopFromBlock, 0, needsFrameNever, -1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtNopBytecode, 0, needsFrameNever, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AddRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, SubRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLess, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreater, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLessOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreaterOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpNonZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AndRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, OrRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorClass, 0, needsFrameIfStackGreaterThanOne, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorNotEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPopStackBytecode, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genUnconditionalTrapBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ extABytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ extBBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genExtPushReceiverVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genExtPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushLiteralBytecode, 0, needsFrameNever, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongPushTemporaryVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genPushNewArrayBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushIntegerBytecode, 0, needsFrameNever, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushCharacterBytecode, 0, needsFrameNever, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtSendSuperBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genCallMappedInlinedPrimitive, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },
	{ genExtUnconditionalJump, v4LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtJumpIfTrue, v4LongBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtJumpIfFalse, v4LongBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtStoreAndPopReceiverVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ genExtStoreAndPopLiteralVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 0, 0, 0 },
	{ genLongStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtStoreReceiverVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ genExtStoreLiteralVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 0, 0, 0 },
	{ genLongStoreTemporaryVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genCallPrimitiveBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genExtPushFullClosureBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushClosureBytecode, v4BlockCodeSize, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
	{ genPushRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 }
};
static sqInt guardPageSize;
static sqInt hasMovableLiteral;
static sqInt hasNativeFrame;
static sqInt hasYoungReferent;
static sqInt inBlock;
static sqInt initialPC;
static sqInt introspectionData;
static sqInt introspectionDataIndex;
static sqInt lastSend;
static usqInt limitAddress;
static sqInt maxLitIndex;
static sqInt methodAbortTrampolines[4];
static sqInt methodBytesFreedSinceLastCompaction;
static sqInt methodCount;
static sqInt methodHeader;
static sqInt methodObj;
static sqInt methodOrBlockNumArgs;
static sqInt methodOrBlockNumTemps;
static usqIntptr_t minValidCallAddress;
static usqInt mzFreeStart;
static sqInt needsFrame;
static AbstractInstruction * noCheckEntry;
static sqInt numAbstractOpcodes;
static sqInt numExtB;
static usqInt objectReferencesInRuntime[NumObjRefsInRuntime+1];
static sqInt opcodeIndex;
static CogMethod *openPICList = 0;
static sqInt openPICSize;
static sqInt ordinarySendTrampolines[NumSendTrampolines];
static sqInt picAbortTrampolines[4];
static AbstractInstruction * picInterpretAbort;
static sqInt picMissTrampolines[4];
static AbstractInstruction * picMNUAbort;
static BytecodeDescriptor * prevBCDescriptor;
static PrimitiveDescriptor primitiveGeneratorTable[MaxCompiledPrimitiveIndex+1] = {
	{ 0, -1 },
	{ genPrimitiveAdd, 1 },
	{ genPrimitiveSubtract, 1 },
	{ genPrimitiveLessThan, 1 },
	{ genPrimitiveGreaterThan, 1 },
	{ genPrimitiveLessOrEqual, 1 },
	{ genPrimitiveGreaterOrEqual, 1 },
	{ genPrimitiveEqual, 1 },
	{ genPrimitiveNotEqual, 1 },
	{ genPrimitiveMultiply, 1 },
	{ genPrimitiveDivide, 1 },
	{ genPrimitiveMod, 1 },
	{ genPrimitiveDiv, 1 },
	{ genPrimitiveQuo, 1 },
	{ genPrimitiveBitAnd, 1 },
	{ genPrimitiveBitOr, 1 },
	{ genPrimitiveBitXor, 1 },
	{ genPrimitiveBitShift, 1 },
	{ genPrimitiveMakePoint, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveAsFloat, 0 },
	{ genPrimitiveFloatAdd, 1 },
	{ genPrimitiveFloatSubtract, 1 },
	{ genPrimitiveFloatLessThan, 1 },
	{ genPrimitiveFloatGreaterThan, 1 },
	{ genPrimitiveFloatLessOrEqual, 1 },
	{ genPrimitiveFloatGreaterOrEqual, 1 },
	{ genPrimitiveFloatEqual, 1 },
	{ genPrimitiveFloatNotEqual, 1 },
	{ genPrimitiveFloatMultiply, 1 },
	{ genPrimitiveFloatDivide, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveFloatSquareRoot, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveAt, 1 },
	{ genPrimitiveAtPut, 2 },
	{ genPrimitiveSize, 0 },
	{ genPrimitiveStringAt, 1 },
	{ genPrimitiveStringAtPut, 2 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ genPrimitiveObjectAt, 1 },
	{ 0, -1 },
	{ genPrimitiveNew, 0 },
	{ genPrimitiveNewWithArg, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentityHash, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveNewMethod, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitivePerform, -1 },
	{ genPrimitivePerformWithArguments, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveStringReplace, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentical, 1 },
	{ genPrimitiveClass, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveShallowCopy, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveStringCompareWith, 1 },
	{ genPrimitiveHashMultiply, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIntegerAt, 1 },
	{ genPrimitiveIntegerAtPut, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveNotIdentical, 1 },
	{ genPrimitiveAsCharacter, -1 },
	{ genPrimitiveImmediateAsInteger, 0 },
	{ 0, -1 },
	{ genPrimitiveSlotAt, 1 },
	{ genPrimitiveSlotAtPut, 2 },
	{ genPrimitiveIdentityHash, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ 0, -1 },
	{ genPrimitiveClosureValue, 0 },
	{ genPrimitiveClosureValue, 1 },
	{ genPrimitiveClosureValue, 2 },
	{ genPrimitiveClosureValue, 3 },
	{ genPrimitiveClosureValue, 4 },
	{ 0, -1 },
	{ genPrimitiveFullClosureValue, -1 },
	{ 0, -1 },
	{ genPrimitiveFullClosureValue, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveClosureValue, 0 },
	{ genPrimitiveClosureValue, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveSmallFloatAdd, 1 },
	{ genPrimitiveSmallFloatSubtract, 1 },
	{ genPrimitiveSmallFloatLessThan, 1 },
	{ genPrimitiveSmallFloatGreaterThan, 1 },
	{ genPrimitiveSmallFloatLessOrEqual, 1 },
	{ genPrimitiveSmallFloatGreaterOrEqual, 1 },
	{ genPrimitiveSmallFloatEqual, 1 },
	{ genPrimitiveSmallFloatNotEqual, 1 },
	{ genPrimitiveSmallFloatMultiply, 1 },
	{ genPrimitiveSmallFloatDivide, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveSmallFloatSquareRoot, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveHighBit, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveUninitializedNewWithArg, 1 }
};
static sqInt primitiveIndex;
static sqInt processorLock;
static sqInt receiverTags;
static sqInt regArgsHaveBeenPushed;
static sqInt runtimeObjectRefIndex;
static AbstractInstruction * sendMiss;
static sqInt simNativeSpillBase;
static CogSimStackNativeEntry simNativeStack[70];
static sqInt simNativeStackPtr;
static sqInt simNativeStackSize;
static sqInt simSpillBase;
static SimStackEntry simStack[70];
static sqInt simStackPtr;
static AbstractInstruction * stackCheckLabel;
static AbstractInstruction * stackOverflowCall;
static sqInt superSendTrampolines[NumSendTrampolines];
static sqInt tempOop;
static char *trampolineAddresses[NumTrampolines*2];
static sqInt trampolineTableIndex;
static sqInt uncheckedEntryAlignment;
static usqInt unpairedMethodList;
static sqInt useTwoPaths;
static sqInt varBaseAddress;
static usqInt youngReferrers;
static const int cStackAlignment = STACK_ALIGN_BYTES;
static int labelCounter;
static AbstractInstruction aMethodLabel;
static AbstractInstruction * const backEnd = &aMethodLabel;
#if DUAL_MAPPED_CODE_ZONE
static void (*ceFlushDCache)(usqIntptr_t from, usqIntptr_t to);
#endif
#if IMMUTABILITY
static sqInt ceStoreTrampolines[5];;
#endif
static AbstractInstruction * const methodLabel = &aMethodLabel;
static double thresholdRatio = 0.5;
sqInt blockNoContextSwitchOffset;
sqInt breakPC;
sqInt cbEntryOffset;
sqInt cbNoSwitchEntryOffset;
sqInt ceBaseFrameReturnTrampoline;
sqInt ceCannotResumeTrampoline;
sqInt ceCheckForInterruptTrampoline;
sqInt ceReturnToInterpreterTrampoline;
#if !defined(cFramePointerInUse)
sqInt cFramePointerInUse;
#endif
sqInt cmEntryOffset;
sqInt cmNoCheckEntryOffset;
usqInt methodZoneBase;
sqInt missOffset;
const char * traceFlagsMeanings[] = {
		"1: print trace", "2: trace sends", "4: trace block activations", "8: trace interpreter primitives",
		"16: trace events (context switches, GCs, etc)", "32: trace stack overflow (poll for events hook)",
		"64: trace linked sends", "128: trace fast C call interpreter primitives", null
	};
sqInt traceStores;
int traceFlags = 8 /* prim trace log on by default */;
void (*ceCall0ArgsPIC)(void);
void (*ceCall1ArgsPIC)(void);
void (*ceCall2ArgsPIC)(void);
void (*ceCallCogCodePopReceiverAndClassRegs)(void);
void (*ceCallCogCodePopReceiverArg0Regs)(void);
void (*ceCallCogCodePopReceiverArg1Arg0Regs)(void);
void (*ceCallCogCodePopReceiverReg)(void);
void (*ceCaptureCStackPointers)(void);
void (*ceEnterCogCodePopReceiverReg)(void);
usqIntptr_t (*ceGetFP)(void);
usqIntptr_t (*ceGetSP)(void);
void (*ceInvokeInterpret)(void);
void (*realCECallCogCodePopReceiverAndClassRegs)(void);
void (*realCECallCogCodePopReceiverArg0Regs)(void);
void (*realCECallCogCodePopReceiverArg1Arg0Regs)(void);
void (*realCECallCogCodePopReceiverReg)(void);
void (*realCEEnterCogCodePopReceiverReg)(void);


/*** Macros ***/
#define roundUpToMethodAlignment(ignored,numBytes) ((numBytes) + 7 & -8)
#define cPICNumCases stackCheckOffset
#define cPICNumCasesHack hack hack hack i.e. the getter macro does all the work
#define abstractInstructionAt(index) (&abstractOpcodes[index])
#define addressIsInInstructions(address) (!((usqInt)(address) & (BytesPerWord-1)) \
							&& (address) >= &abstractOpcodes[0] \
							&& (address) < &abstractOpcodes[opcodeIndex])
#define allocateBlockStarts(numBlocks) do { \
		blockStarts = (numBlocks) ? alloca(sizeof(BlockStart) * (numBlocks)) : 0; \
} while (0)
#define assertValidDualZone() true
#define assertValidDualZoneReadAddress(address) 0
#define assertValidDualZoneWriteAddress(address) 0
#define backEnd() backEnd
#define blockAlignment() 8
#define blockStartAt(index) (&blockStarts[index])
#define ceBaseFrameReturnPC() ceBaseFrameReturnTrampoline
#define ceCannotResumePC() ((usqInt)ceCannotResumeTrampoline)
#define ceCheckForInterruptTrampoline() ceCheckForInterruptTrampoline
#define ceReturnToInterpreterPC() ((usqInt)ceReturnToInterpreterTrampoline)
#define codeByteAtput(address,value) byteAtput((address) + codeToDataDelta, value)
#define codeLong32Atput(address,value) long32Atput((address) + codeToDataDelta, value)
#define codeLong64Atput(address,value) long64Atput((address) + codeToDataDelta, value)
#define codeLongAtput(address,value) longAtput((address) + codeToDataDelta, value)
#define codeMemcpy(dest,src,bytes) memcpy(dest,src,bytes)
#define codeMemmove(dest,src,bytes) memmove((char *)(dest)+codeToDataDelta,src,bytes)
#define cr() putchar('\n')
#define entryOffset() cmEntryOffset
#define generatorAt(index) (&generatorTable[index])
#define getCodeToDataDelta() codeToDataDelta
#define getIsObjectReference() 2
#define halt() warning("halt")
#define haltmsg(msg) warning("halt: " msg)
#define interpretOffset() missOffset
#define mapPerMethodProfile() 0
#define maxCogCodeSize() (16*1024*1024)
#define maybeBreakGeneratingFromto(address,end) 0
#define maybeBreakGeneratingInstructionWithIndex(i) 0
#define maybeHaltIfDebugPC() 0
#define methodLabel() methodLabel
#define methodZoneBase() methodZoneBase
#define minCogMethodAddress() methodZoneBase
#define moveProfileToMethods() 0
#define noCheckEntryOffset() cmNoCheckEntryOffset
#define noContextSwitchBlockEntryOffset() blockNoContextSwitchOffset
#define notYetImplemented() warning("not yet implemented")
#define null 0
#define printNum(n) printf("%" PRIdSQINT, (sqInt) (n))
#define printOnTrace() (traceFlags & 1)
#define recordBlockTrace() (traceFlags & 4)
#define recordEventTrace() (traceFlags & 16)
#define recordFastCCallPrimTrace() (traceFlags & 128)
#define recordOverflowTrace() (traceFlags & 32)
#define recordPrimTrace() (traceFlags & 8)
#define recordSendTrace() (traceFlags & 2)
#define reportError(n) warning("compilation error")
#define setHasMovableLiteral(b) (hasMovableLiteral = (b))
#define setHasYoungReferent(b) (hasYoungReferent = (b))
#define varBaseAddress() varBaseAddress
#define nextOpenPIC methodObject
#define nextOpenPICHack hack hack hack i.e. the getter macro does all the work
#define freeStart() mzFreeStart
#define limitZony() ((CogMethod *)mzFreeStart)
#define methodBytesFreedSinceLastCompaction() methodBytesFreedSinceLastCompaction
#define youngReferrers() youngReferrers
#define numRegArgs() 2
#define maybeConstant(sse) ((sse)->constant)
#define cpuidWord1(ign) cpuidWord1
#define flushDCacheFromto(me,startAddress,endAddress) 0
#define flushICacheFromto(me,startAddress,endAddress) 0
#define inlineCacheValueForSelectorin(backEnd,selector,aCogMethod) indexForSelectorin(selector,aCogMethod)
#define setCpuidWord1(ign,word) cpuidWord1 = word
#define unalignedLong32At(inst,byteAddress) long32At(byteAddress)
#define unalignedLong32Atput(inst,byteAddress,aWord) long32Atput(byteAddress,aWord)
#define unalignedLongAt(byteAddress) longAt(byteAddress)
#define unalignedLongAtput(byteAddress,aWord) longAtput(byteAddress,aWord)
#define fullBlockEntryOffset() cbEntryOffset
#define fullBlockNoContextSwitchEntryOffset() cbNoSwitchEntryOffset
#define needsFrame() needsFrame
#define fixupAtIndex(index) (&fixups[index])
#define simNativeStackAt(index) (simNativeStack + (index))
#define simSelf() simStack
#define simStackAt(index) (simStack + (index))
#define traceDescriptor(ign) 0
#define traceFixupmerge(igu,ana) 0
#define traceMerge(ign) 0
#define traceSimStack() 0
#define traceSpill(ign) 0
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))


	/* CogAbstractInstruction>>#addDependent: */
static AbstractInstruction * NoDbgRegParms
addDependent(AbstractInstruction * self_in_addDependent, AbstractInstruction *anInstruction)
{
	if (!(((self_in_addDependent->dependent)) == null)) {
		(anInstruction->dependent = (self_in_addDependent->dependent));
	}
	return ((self_in_addDependent->dependent) = anInstruction);
}


/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them. */

	/* CogAbstractInstruction>>#availableFloatRegisterOrNoneFor: */
static sqInt NoDbgRegParms
availableFloatRegisterOrNoneFor(AbstractInstruction * self_in_availableFloatRegisterOrNoneFor, sqInt liveRegsMask)
{
	if (!(((liveRegsMask & ((1U << DPFPReg0))) != 0))) {
		return DPFPReg0;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg1))) != 0))) {
		return DPFPReg1;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg2))) != 0))) {
		return DPFPReg2;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg3))) != 0))) {
		return DPFPReg3;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg4))) != 0))) {
		return DPFPReg4;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg5))) != 0))) {
		return DPFPReg5;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg6))) != 0))) {
		return DPFPReg6;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg7))) != 0))) {
		return DPFPReg7;
	}
	return NoReg;
}


/*	For out-of-line literal support, clone a literal from a literal. */

	/* CogAbstractInstruction>>#cloneLiteralFrom: */
static void NoDbgRegParms
cloneLiteralFrom(AbstractInstruction * self_in_cloneLiteralFrom, AbstractInstruction *existingLiteral)
{
	assert((((existingLiteral->opcode)) == Literal)
	 && ((((self_in_cloneLiteralFrom->dependent)) == null)
	 && (((self_in_cloneLiteralFrom->address)) == null)));
	(self_in_cloneLiteralFrom->opcode) = Literal;
	(self_in_cloneLiteralFrom->annotation) = (existingLiteral->annotation);
	((self_in_cloneLiteralFrom->operands))[0] = (((existingLiteral->operands))[0]);
	((self_in_cloneLiteralFrom->operands))[1] = (((existingLiteral->operands))[1]);
	((self_in_cloneLiteralFrom->operands))[2] = (((existingLiteral->operands))[2]);
}


/*	Generate concrete machine code for the instruction at actualAddress,
	setting machineCodeSize, and answer the following address. */

	/* CogAbstractInstruction>>#concretizeAt: */
static sqInt NoDbgRegParms
concretizeAt(AbstractInstruction * self_in_concretizeAt, sqInt actualAddress)
{
	(self_in_concretizeAt->address) = actualAddress;
	(self_in_concretizeAt->machineCodeSize) = dispatchConcretize(self_in_concretizeAt);
	assert((((self_in_concretizeAt->maxSize)) == null)
	 || (((self_in_concretizeAt->maxSize)) >= ((self_in_concretizeAt->machineCodeSize))));
	return actualAddress + ((self_in_concretizeAt->machineCodeSize));
}


/*	Load the stack pointer register with that of the C stack, effecting
	a switch to the C stack. Used when machine code calls into the
	CoInterpreter run-time (e.g. to invoke interpreter primitives). */

	/* CogAbstractInstruction>>#genLoadCStackPointer */
static sqInt NoDbgRegParms
genLoadCStackPointer(AbstractInstruction * self_in_genLoadCStackPointer)
{
    sqInt address;

	/* begin MoveAw:R: */
	address = cStackPointerAddress();
	genoperandoperand(MoveAwR, address, NativeSPReg);
	return 0;
}


/*	Load the frame and stack pointer registers with those of the C stack,
	effecting a switch to the C stack. Used when machine code calls into
	the CoInterpreter run-time (e.g. to invoke interpreter primitives).
	N.B. CoInterpreter stack layout dictates that the stack pointer should be
	loaded first.
	The stack zone is allocated on the C stack before the interpreter runs and
	hence before CStackPointer and CFramePointer are captured. So when running
	in machine
	code the native stack pointer and frame pointer appear to be on a colder
	part of the
	stack to CStackPointer and CFramePointer. When CStackPointerhas been set
	and the frame pointer is still in machine code the current frame looks
	like it has lots of
	stack. If the frame pointer was set to CFramePointer before hand then it
	would be beyond the stack pointer for that one instruction. */

	/* CogAbstractInstruction>>#genLoadCStackPointers */
static sqInt NoDbgRegParms
genLoadCStackPointers(AbstractInstruction * self_in_genLoadCStackPointers)
{
    sqInt address;
    sqInt address1;

	/* begin MoveAw:R: */
	address = cStackPointerAddress();
	genoperandoperand(MoveAwR, address, NativeSPReg);
	/* begin MoveAw:R: */
	address1 = cFramePointerAddress();
	genoperandoperand(MoveAwR, address1, FPReg);
	return 0;
}


/*	Switch back to the Smalltalk stack where there may be a C return address
	on top of stack below
	the last primitive argument. Assign SPReg first because typically it is
	used immediately afterwards.
 */

	/* CogAbstractInstruction>>#genLoadStackPointerForPrimCall: */
static sqInt NoDbgRegParms
genLoadStackPointerForPrimCall(AbstractInstruction * self_in_genLoadStackPointerForPrimCall, sqInt spareReg)
{
    sqInt address1;
    AbstractInstruction *anInstruction;

	/* begin MoveAw:R: */
	address1 = stackPointerAddress();
	genoperandoperand(MoveAwR, address1, spareReg);
	/* begin SubCq:R: */
	
	BytesPerWord;
	anInstruction = genoperandoperand(SubCqR, BytesPerWord, spareReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, spareReg, SPReg);
	return 0;
}


/*	Switch back to the Smalltalk stack. Assign SPReg first
	because typically it is used immediately afterwards. */

	/* CogAbstractInstruction>>#genLoadStackPointers */
static sqInt NoDbgRegParms
genLoadStackPointers(AbstractInstruction * self_in_genLoadStackPointers)
{
    sqInt address;
    sqInt address1;

	/* begin MoveAw:R: */
	address = stackPointerAddress();
	genoperandoperand(MoveAwR, address, SPReg);
	/* begin MoveAw:R: */
	address1 = framePointerAddress();
	genoperandoperand(MoveAwR, address1, FPReg);
	return 0;
}


/*	Switch back to the Smalltalk stack where there may be a C return address
	on top of stack below
	the last primitive argument. Assign SPReg first because typically it is
	used immediately afterwards.
 */

	/* CogAbstractInstruction>>#genLoadStackPointersForPrimCall: */
static sqInt NoDbgRegParms
genLoadStackPointersForPrimCall(AbstractInstruction * self_in_genLoadStackPointersForPrimCall, sqInt spareReg)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;

	/* begin MoveAw:R: */
	address = stackPointerAddress();
	genoperandoperand(MoveAwR, address, spareReg);
	/* begin SubCq:R: */
	
	BytesPerWord;
	anInstruction = genoperandoperand(SubCqR, BytesPerWord, spareReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, spareReg, SPReg);
	/* begin MoveAw:R: */
	address1 = framePointerAddress();
	genoperandoperand(MoveAwR, address1, FPReg);
	return 0;
}


/*	Save the frame and stack pointer registers to the framePointer
	and stackPointer variables. Used to save the machine code frame
	for use by the run-time when calling into the CoInterpreter run-time. */

	/* CogAbstractInstruction>>#genSaveStackPointers */
static sqInt NoDbgRegParms
genSaveStackPointers(AbstractInstruction * self_in_genSaveStackPointers)
{
    sqInt address;
    sqInt address1;

	/* begin MoveR:Aw: */
	address = framePointerAddress();
	genoperandoperand(MoveRAw, FPReg, address);
	/* begin MoveR:Aw: */
	address1 = stackPointerAddress();
	genoperandoperand(MoveRAw, SPReg, address1);
	return 0;
}

	/* CogAbstractInstruction>>#genWriteCResultIntoReg: */
static void NoDbgRegParms
genWriteCResultIntoReg(AbstractInstruction * self_in_genWriteCResultIntoReg, sqInt abstractRegister)
{
	if ((abstractRegister != NoReg)
	 && (abstractRegister != ABIResultReg)) {
		genoperandoperand(MoveRR, ABIResultReg, abstractRegister);
	}
}

	/* CogAbstractInstruction>>#genWriteCSecondResultIntoReg: */
static void NoDbgRegParms
genWriteCSecondResultIntoReg(AbstractInstruction * self_in_genWriteCSecondResultIntoReg, sqInt abstractRegister)
{
	if ((abstractRegister != NoReg)
	 && (abstractRegister != RDX)) {
		genoperandoperand(MoveRR, RDX, abstractRegister);
	}
}


/*	For out-of-line literal support, initialize a sharable literal. */

	/* CogAbstractInstruction>>#initializeSharableLiteral: */
static void NoDbgRegParms
initializeSharableLiteral(AbstractInstruction * self_in_initializeSharableLiteral, sqInt literal)
{
	(self_in_initializeSharableLiteral->opcode) = Literal;

	/* separate := nil for Slang */
	(self_in_initializeSharableLiteral->annotation) = null;
	(self_in_initializeSharableLiteral->address) = null;
	(self_in_initializeSharableLiteral->dependent) = null;
	((self_in_initializeSharableLiteral->operands))[0] = literal;
	((self_in_initializeSharableLiteral->operands))[1] = (1 + (((sqInt)((usqInt)(BytesPerOop) << 1))));
	((self_in_initializeSharableLiteral->operands))[2] = -1;
}


/*	For out-of-line literal support, initialize an unsharable literal. */

	/* CogAbstractInstruction>>#initializeUniqueLiteral: */
static void NoDbgRegParms
initializeUniqueLiteral(AbstractInstruction * self_in_initializeUniqueLiteral, sqInt literal)
{
	(self_in_initializeUniqueLiteral->opcode) = Literal;

	/* separate := nil for Slang */
	(self_in_initializeUniqueLiteral->annotation) = null;
	(self_in_initializeUniqueLiteral->address) = null;
	(self_in_initializeUniqueLiteral->dependent) = null;
	((self_in_initializeUniqueLiteral->operands))[0] = literal;
	((self_in_initializeUniqueLiteral->operands))[1] = (0 + (((sqInt)((usqInt)(BytesPerOop) << 1))));
	((self_in_initializeUniqueLiteral->operands))[2] = -1;
}

	/* CogAbstractInstruction>>#isJump */
static sqInt NoDbgRegParms
isJump(AbstractInstruction * self_in_isJump)
{
	return ((((self_in_isJump->opcode)) >= FirstJump) && (((self_in_isJump->opcode)) <= LastJump));
}


/*	We assume here that calls and jumps look the same as regards their
	displacement. This works on at least x86, ARM and x86_64. Processors on
	which that isn't the
	case can override as necessary. */

	/* CogAbstractInstruction>>#relocateJumpLongBeforeFollowingAddress:by: */
static void NoDbgRegParms
relocateJumpLongBeforeFollowingAddressby(AbstractInstruction * self_in_relocateJumpLongBeforeFollowingAddressby, sqInt pc, sqInt delta)
{
	relocateCallBeforeReturnPCby(self_in_relocateJumpLongBeforeFollowingAddressby, pc, delta);
}


/*	Relocate a long conditional jump before pc. Default to relocating a
	non-conditional jump.
	Processors that have different formats for conditional and unconditional
	jumps override. */

	/* CogAbstractInstruction>>#relocateJumpLongConditionalBeforeFollowingAddress:by: */
static void NoDbgRegParms
relocateJumpLongConditionalBeforeFollowingAddressby(AbstractInstruction * self_in_relocateJumpLongConditionalBeforeFollowingAddressby, sqInt pc, sqInt delta)
{
	relocateJumpLongBeforeFollowingAddressby(self_in_relocateJumpLongConditionalBeforeFollowingAddressby, pc, delta);
}

	/* CogAbstractInstruction>>#resolveJumpTarget */
static void NoDbgRegParms
resolveJumpTarget(AbstractInstruction * self_in_resolveJumpTarget)
{
    BytecodeFixup *fixup;

	assert(isJump(self_in_resolveJumpTarget));
	fixup = ((BytecodeFixup *) (((self_in_resolveJumpTarget->operands))[0]));
	if (addressIsInFixups(fixup)) {
		assert(addressIsInInstructions((fixup->targetInstruction)));
		jmpTarget(self_in_resolveJumpTarget, (fixup->targetInstruction));
	}
}


/*	Rewrite a conditional jump long to jump to target. This version defaults
	to using
	rewriteJumpLongAt:, which works for many ISAs. Subclasses override if
	necessary.  */

	/* CogAbstractInstruction>>#rewriteConditionalJumpLongAt:target: */
static sqInt NoDbgRegParms
rewriteConditionalJumpLongAttarget(AbstractInstruction * self_in_rewriteConditionalJumpLongAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteCallAttarget(self_in_rewriteConditionalJumpLongAttarget, callSiteReturnAddress, callTargetAddress);
}

	/* CogBlockMethod>>#cmHomeMethod */
static CogMethod * NoDbgRegParms
cmHomeMethod(CogBlockMethod * self_in_cmHomeMethod)
{
	return ((self_in_cmHomeMethod->cpicHasMNUCaseOrCMIsFullBlock)
		? ((CogMethod *) self_in_cmHomeMethod)
		: ((CogMethod *) ((((usqInt)self_in_cmHomeMethod)) - ((self_in_cmHomeMethod->homeOffset)))));
}

	/* CogBlockMethod>>#isCMBlock */
static sqInt NoDbgRegParms
isCMBlock(CogBlockMethod * self_in_isCMBlock)
{
	return ((self_in_isCMBlock->cmType)) == CMBlock;
}

	/* CogBlockMethod>>#isCMClosedPIC */
static sqInt NoDbgRegParms
isCMClosedPIC(CogBlockMethod * self_in_isCMClosedPIC)
{
	return ((self_in_isCMClosedPIC->cmType)) == CMClosedPIC;
}

	/* CogBlockMethod>>#isCMFree */
static sqInt NoDbgRegParms
isCMFree(CogBlockMethod * self_in_isCMFree)
{
	return ((self_in_isCMFree->cmType)) == CMFree;
}

	/* CogBlockMethod>>#isCMMethodEtAl */
static sqInt NoDbgRegParms
isCMMethodEtAl(CogBlockMethod * self_in_isCMMethodEtAl)
{
	return ((self_in_isCMMethodEtAl->cmType)) >= CMMethod;
}

	/* CogBlockMethod>>#isCMOpenPIC */
static sqInt NoDbgRegParms
isCMOpenPIC(CogBlockMethod * self_in_isCMOpenPIC)
{
	return ((self_in_isCMOpenPIC->cmType)) == CMOpenPIC;
}

	/* CogBytecodeDescriptor>>#isBranch */
static sqInt NoDbgRegParms
isBranch(BytecodeDescriptor * self_in_isBranch)
{
	return (((self_in_isBranch->spanFunction)) != null)
	 && (!((self_in_isBranch->isBlockCreation)));
}


/*	With CqR we assume constants are 32-bits or less. */

	/* CogInLineLiteralsX64Compiler>>#computeSizeOfArithCqR */
static sqInt NoDbgRegParms
computeSizeOfArithCqR(AbstractInstruction * self_in_computeSizeOfArithCqR)
{
	if (isQuick(self_in_computeSizeOfArithCqR, ((self_in_computeSizeOfArithCqR->operands))[0])) {
		return 4;
	}
	if (is32BitSignedImmediate(self_in_computeSizeOfArithCqR, ((self_in_computeSizeOfArithCqR->operands))[0])) {
		return ((((self_in_computeSizeOfArithCqR->operands))[1]) == RAX
			? 6
			: 7);
	}
	return 13;
}

	/* CogInLineLiteralsX64Compiler>>#computeSizeOfArithCwR */
static sqInt NoDbgRegParms
computeSizeOfArithCwR(AbstractInstruction * self_in_computeSizeOfArithCwR)
{
	return 13;
}

	/* CogInLineLiteralsX64Compiler>>#concretizeArithCwR: */
static sqInt NoDbgRegParms
concretizeArithCwR(AbstractInstruction * self_in_concretizeArithCwR, sqInt x64opcode)
{
    usqInt reg;
    sqInt reverse;
    usqInt value;

	value = ((self_in_concretizeArithCwR->operands))[0];
	reg = ((self_in_concretizeArithCwR->operands))[1];

	/* Tst & Cmp; backwards */
	reverse = (x64opcode == 133)
	 || (x64opcode == 57);
	((self_in_concretizeArithCwR->machineCode))[0] = (rexRxb(self_in_concretizeArithCwR, RISCTempReg, 0, RISCTempReg));
	((self_in_concretizeArithCwR->machineCode))[1] = (184 + (RISCTempReg & 7));
	((self_in_concretizeArithCwR->machineCode))[2] = (value & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[3] = (((value) >> 8) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[4] = (((value) >> 16) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[5] = (((value) >> 24) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[6] = (((value) >> 32) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[7] = (((value) >> 40) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[8] = (((value) >> 48) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[9] = (((value) >> 56) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[10] = ((reverse
	? rexRxb(self_in_concretizeArithCwR, RISCTempReg, 0, reg)
	: rexRxb(self_in_concretizeArithCwR, reg, 0, RISCTempReg)));
	((self_in_concretizeArithCwR->machineCode))[11] = x64opcode;
	((self_in_concretizeArithCwR->machineCode))[12] = ((reverse
	? modRMRO(self_in_concretizeArithCwR, ModReg, reg, RISCTempReg)
	: modRMRO(self_in_concretizeArithCwR, ModReg, RISCTempReg, reg)));
	assert((((self_in_concretizeArithCwR->machineCode))[12]) > 144);
	return 13;
}


/*	Will get inlined into concretizeAt: switch. */

	/* CogInLineLiteralsX64Compiler>>#concretizeMoveCwR */
static sqInt NoDbgRegParms
concretizeMoveCwR(AbstractInstruction * self_in_concretizeMoveCwR)
{
    sqInt offset;
    usqInt reg;
    usqInt value;

	value = ((self_in_concretizeMoveCwR->operands))[0];
	reg = ((self_in_concretizeMoveCwR->operands))[1];
	if ((addressIsInInstructions(((AbstractInstruction *) value)))
	 || ((((AbstractInstruction *) value)) == (methodLabel()))) {
		value = ((((AbstractInstruction *) value))->address);
	}
	if (((((usqInt)value)) >= ((methodLabel->address)))
	 && ((((usqInt)value)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))) {
		offset = value - (((self_in_concretizeMoveCwR->address)) + 7);
		((self_in_concretizeMoveCwR->machineCode))[0] = (rexRxb(self_in_concretizeMoveCwR, reg, 0, 0));
		((self_in_concretizeMoveCwR->machineCode))[1] = 141;
		((self_in_concretizeMoveCwR->machineCode))[2] = (modRMRO(self_in_concretizeMoveCwR, ModRegInd, 5, reg));
		((self_in_concretizeMoveCwR->machineCode))[3] = (offset & 0xFF);
		((self_in_concretizeMoveCwR->machineCode))[4] = ((((usqInt)(offset)) >> 8) & 0xFF);
		((self_in_concretizeMoveCwR->machineCode))[5] = ((((usqInt)(offset)) >> 16) & 0xFF);
		((self_in_concretizeMoveCwR->machineCode))[6] = ((((usqInt)(offset)) >> 24) & 0xFF);
		return 7;
	}
	((self_in_concretizeMoveCwR->machineCode))[0] = (rexRxb(self_in_concretizeMoveCwR, 0, 0, reg));
	((self_in_concretizeMoveCwR->machineCode))[1] = (184 + (reg & 7));
	((self_in_concretizeMoveCwR->machineCode))[2] = (value & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[3] = (((value) >> 8) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[4] = (((value) >> 16) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[5] = (((value) >> 24) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[6] = (((value) >> 32) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[7] = (((value) >> 40) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[8] = (((value) >> 48) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[9] = (((value) >> 56) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[10] = 144;
	return 11;
}


/*	Answer the inline cache tag for the return address of a send. */

	/* CogInLineLiteralsX64Compiler>>#inlineCacheTagAt: */
static usqInt NoDbgRegParms
inlineCacheTagAt(AbstractInstruction * self_in_inlineCacheTagAt, sqInt callSiteReturnAddress)
{
	return literal32BeforeFollowingAddress(self_in_inlineCacheTagAt, ((usqInt)(callSiteReturnAddress - 5)));
}


/*	Answer if the receiver is a pc-dependent instruction. */

	/* CogInLineLiteralsX64Compiler>>#isPCDependent */
static sqInt NoDbgRegParms
isPCDependent(AbstractInstruction * self_in_isPCDependent)
{
	return (isJump(self_in_isPCDependent))
	 || (((self_in_isPCDependent->opcode)) == AlignmentNops);
}


/*	Answer the 32-bit literal embedded in the instruction immediately
	preceding followingAddress.
 */

	/* CogInLineLiteralsX64Compiler>>#literal32BeforeFollowingAddress: */
static usqInt NoDbgRegParms
literal32BeforeFollowingAddress(AbstractInstruction * self_in_literal32BeforeFollowingAddress, sqInt followingAddress)
{
	return ((unsigned int) (unalignedLong32At(self_in_literal32BeforeFollowingAddress, followingAddress - 4)));
}


/*	Answer the literal embedded in the instruction immediately preceding
	followingAddress. This is used in the MoveCwR, PushCw and ArithCwR cases;
	these are distinguished by a
	nop following the literal load in MoveCwR, a 16r48 + reg ending the PushCw
	sequence, and
	a (self mod: ModReg RM: rX RO: rY) ending the ArithCwR sequence, which is
	at least 16rC0. */

	/* CogInLineLiteralsX64Compiler>>#literalBeforeFollowingAddress: */
static sqInt NoDbgRegParms
literalBeforeFollowingAddress(AbstractInstruction * self_in_literalBeforeFollowingAddress, sqInt followingAddress)
{
    sqInt base;
    sqInt lastByte;

	lastByte = byteAt(followingAddress - 1);

	/* ArithCwR */
	base = followingAddress - ((lastByte == 144
	? 9
	: (lastByte < 144
			? 10
			: 11)));
	return unalignedLongAt(base);
}

	/* CogInLineLiteralsX64Compiler>>#loadLiteralByteSize */
static sqInt NoDbgRegParms
loadLiteralByteSize(AbstractInstruction * self_in_loadLiteralByteSize)
{
	/* begin moveCwRByteSize */
	return 11;
}


/*	Size a jump and set its address. The target may be another instruction
	or an absolute address. On entry the address inst var holds our virtual
	address. On exit address is set to eventualAbsoluteAddress, which is
	where this instruction will be output. The span of a jump to a following
	instruction is therefore between that instruction's address and this
	instruction's address ((which are both still their virtual addresses), but
	the span of a jump to a preceding instruction or to an absolute address is
	between that instruction's address (which by now is its eventual absolute
	address) or absolute address and eventualAbsoluteAddress. */

	/* CogInLineLiteralsX64Compiler>>#sizePCDependentInstructionAt: */
static usqInt NoDbgRegParms
sizePCDependentInstructionAt(AbstractInstruction * self_in_sizePCDependentInstructionAt, sqInt eventualAbsoluteAddress)
{
    AbstractInstruction *abstractInstruction;
    usqInt alignment;
    sqInt maximumSpan;
    usqInt target;

	if (((self_in_sizePCDependentInstructionAt->opcode)) == AlignmentNops) {
		(self_in_sizePCDependentInstructionAt->address) = eventualAbsoluteAddress;
		alignment = ((self_in_sizePCDependentInstructionAt->operands))[0];
		return ((self_in_sizePCDependentInstructionAt->machineCodeSize) = ((eventualAbsoluteAddress + (alignment - 1)) & (-alignment)) - eventualAbsoluteAddress);
	}
	assert(isJump(self_in_sizePCDependentInstructionAt));
	target = ((self_in_sizePCDependentInstructionAt->operands))[0];
	abstractInstruction = ((AbstractInstruction *) target);
	if ((addressIsInInstructions(abstractInstruction))
	 || (abstractInstruction == (methodLabel()))) {
		maximumSpan = ((abstractInstruction->address)) - (((abstractInstructionfollows(self_in_sizePCDependentInstructionAt, abstractInstruction)
	? eventualAbsoluteAddress
	: (self_in_sizePCDependentInstructionAt->address))) + 2);
	}
	else {
		maximumSpan = target - (eventualAbsoluteAddress + 2);
	}
	(self_in_sizePCDependentInstructionAt->address) = eventualAbsoluteAddress;
	if (((self_in_sizePCDependentInstructionAt->opcode)) >= FirstShortJump) {
		(self_in_sizePCDependentInstructionAt->machineCodeSize) = (isQuick(self_in_sizePCDependentInstructionAt, maximumSpan)
			? 2
			: (((self_in_sizePCDependentInstructionAt->opcode)) == Jump
					? 5
					: 6));
	}
	else {
		switch ((self_in_sizePCDependentInstructionAt->opcode)) {
		case JumpLong:
			(self_in_sizePCDependentInstructionAt->machineCodeSize) = 5;
			break;

		case JumpFull:
			(self_in_sizePCDependentInstructionAt->machineCodeSize) = 12;
			break;

		case JumpLongZero:
		case JumpLongNonZero:
			(self_in_sizePCDependentInstructionAt->machineCodeSize) = 6;
			break;

		default:
			error("Case not found and no otherwise clause");
			(self_in_sizePCDependentInstructionAt->machineCodeSize) = -1;
		}
	}
	return (self_in_sizePCDependentInstructionAt->machineCodeSize);
}


/*	Rewrite the literal in the instruction immediately preceding
	followingAddress. This is used in the MoveCwR, PushCw and CmpCwR cases;
	these are distinguished by a
	nop following the literal load in MoveCwR, a 16r50 + reg ending the PushCw
	sequence, and
	a (self mod: ModReg RM: rX RO: rY) ending the CmpCwR sequence, which is at
	least 16rC0. */

	/* CogInLineLiteralsX64Compiler>>#storeLiteral:beforeFollowingAddress: */
static void NoDbgRegParms
storeLiteralbeforeFollowingAddress(AbstractInstruction * self_in_storeLiteralbeforeFollowingAddress, sqInt literal, sqInt followingAddress)
{
    sqInt base;
    sqInt lastByte;

	lastByte = byteAt(followingAddress - 1);

	/* ArithCwR */
	base = followingAddress - ((lastByte <= 144
	? (lastByte == 144
			? 9
			: 10)
	: 11));
	unalignedLongAtput(base, literal);
}

	/* Cogit>>#AddCq:R: */
static AbstractInstruction * NoDbgRegParms
gAddCqR(sqInt quickConstant, sqInt reg)
{
	return genoperandoperand(AddCqR, quickConstant, reg);
}


/*	N.B. if the condition codes don't require setting and three address
	arithmetic is unavailable, then LoadEffectiveAddressMw:r:R: can be used
	instead. 
 */

	/* Cogit>>#AddCq:R:R: */
static AbstractInstruction * NoDbgRegParms
gAddCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	if (srcReg == destReg) {
		/* begin gen:quickConstant:operand: */
		return genoperandoperand(AddCqR, quickConstant, destReg);
	}
	first = genoperandoperand(MoveRR, srcReg, destReg);
	/* begin gen:quickConstant:operand: */
	genoperandoperand(AddCqR, quickConstant, destReg);
	return first;
}


/*	destReg := addendReg + badendReg */

	/* Cogit>>#AddR:R:R: */
static AbstractInstruction * NoDbgRegParms
gAddRRR(sqInt addendReg, sqInt badendReg, sqInt destReg)
{
    AbstractInstruction *first;

	assert(badendReg != destReg);
	first = genoperandoperand(MoveRR, addendReg, destReg);
	genoperandoperand(AddRR, badendReg, destReg);
	return first;
}

	/* Cogit>>#AndCq:R: */
static AbstractInstruction * NoDbgRegParms
gAndCqR(sqInt quickConstant, sqInt reg)
{
	return genoperandoperand(AndCqR, quickConstant, reg);
}

	/* Cogit>>#AndCq:R:R: */
static AbstractInstruction * NoDbgRegParms
gAndCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	if (srcReg == destReg) {
		/* begin gen:quickConstant:operand: */
		return genoperandoperand(AndCqR, quickConstant, destReg);
	}
	first = genoperandoperand(MoveRR, srcReg, destReg);
	/* begin gen:quickConstant:operand: */
	genoperandoperand(AndCqR, quickConstant, destReg);
	return first;
}


/*	destReg := (signed)srcReg >> quickConstant */

	/* Cogit>>#ArithmeticShiftRightCq:R:R: */
static AbstractInstruction * NoDbgRegParms
gArithmeticShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	first = genoperandoperand(MoveRR, srcReg, destReg);
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, destReg);
	return first;
}

	/* Cogit>>#abortOffset */
sqInt
abortOffset(void)
{
	return missOffset;
}

	/* Cogit>>#abstractInstruction:follows: */
static sqInt NoDbgRegParms
abstractInstructionfollows(AbstractInstruction *theAbstractInstruction, AbstractInstruction *anAbstractInstruction)
{
	return theAbstractInstruction > anAbstractInstruction;
}

	/* Cogit>>#addCleanBlockStarts */
static void
addCleanBlockStarts(void)
{
    sqInt i;
    sqInt iLimiT;
    sqInt lit;
    sqInt startPCOrNil;

	for (i = 1, iLimiT = (literalCountOf(methodObj)); i <= iLimiT; i += 1) {
		lit = fetchPointerofObject(i, methodObj);
		startPCOrNil = startPCOrNilOfLiteralin(lit, methodObj);
		if (!(startPCOrNil == null)) {
			maxLitIndex = ((maxLitIndex < i) ? i : maxLitIndex);
			addBlockStartAtnumArgsnumCopiedspan(startPCOrNil - 1, argumentCountOfClosure(lit), copiedValueCountOfClosure(lit), spanForCleanBlockStartingAt(startPCOrNil - 1));
		}
	}
}


/*	Perform an integrity/leak check using the heapMap.
	Set a bit at each cog method's header. */

	/* Cogit>>#addCogMethodsToHeapMap */
void
addCogMethodsToHeapMap(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			heapMapAtWordPut(cogMethod, 1);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* Cogit>>#addressIsInFixups: */
static sqInt NoDbgRegParms
addressIsInFixups(BytecodeFixup *address)
{
	return (BytecodeFixup *)address >= fixups && (BytecodeFixup *)address < (fixups + numAbstractOpcodes);
}


/*	calculate the end of the n'th case statement - which is complicated
	because we have case 1 right at the top of our CPIC and then build up from
	the last one. Yes I know this sounds strange, but trust me - I'm an
	Engineer, we do things backwards all the emit
 */

	/* Cogit>>#addressOfEndOfCase:inCPIC: */
static sqInt NoDbgRegParms
addressOfEndOfCaseinCPIC(sqInt n, CogMethod *cPIC)
{
	assert((n >= 1)
	 && (n <= MaxCPICCases));
	return (n == 1
		? (((sqInt)cPIC)) + firstCPICCaseOffset
		: ((((sqInt)cPIC)) + firstCPICCaseOffset) + (((MaxCPICCases + 1) - n) * cPICCaseSize));
}


/*	Align methodZoneBase to that for the start of a method. */

	/* Cogit>>#alignMethodZoneBase */
static void
alignMethodZoneBase(void)
{
    usqInt numBytes;
    usqInt oldBase;

	oldBase = methodZoneBase;
	/* begin roundUpLength: */
	numBytes = methodZoneBase;
	methodZoneBase = roundUpToMethodAlignment(backEnd(), numBytes);
	stopsFromto(backEnd, oldBase, methodZoneBase - 1);
}

	/* Cogit>>#alignUptoRoutineBoundary: */
static sqInt NoDbgRegParms
alignUptoRoutineBoundary(sqInt anAddress)
{
	return (((anAddress + 7) | 7) - 7);
}


/*	Check that all methods have valid selectors, and that all linked sends are
	to valid targets and have valid cache tags
 */

	/* Cogit>>#allMachineCodeObjectReferencesValid */
static sqInt
allMachineCodeObjectReferencesValid(void)
{
    CogMethod *cogMethod;
    sqInt ok;

	ok = 1;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (!(asserta(checkValidOopReference((cogMethod->selector))))) {
				ok = 0;
			}
			if (!(asserta((cogMethodDoesntLookKosher(cogMethod)) == 0))) {
				ok = 0;
			}
		}
		if ((((cogMethod->cmType)) >= CMMethod)
		 || (((cogMethod->cmType)) == CMOpenPIC)) {
			if (!(asserta((mapForperformUntilarg(cogMethod, checkIfValidOopRefAndTargetpccogMethod, cogMethod)) == 0))) {
				ok = 0;
			}
		}
		if ((((cogMethod->cmType)) >= CMMethod)) {
					}
		if (((cogMethod->cmType)) == CMClosedPIC) {
			if (!(asserta(noTargetsFreeInClosedPIC(cogMethod)))) {
				ok = 0;
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return ok;
}

	/* Cogit>>#allMethodsHaveCorrectHeader */
static sqInt
allMethodsHaveCorrectHeader(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			if (!(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()))) {
				return 0;
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return 1;
}

	/* Cogit>>#annotateAbsolutePCRef: */
static AbstractInstruction * NoDbgRegParms
annotateAbsolutePCRef(AbstractInstruction *abstractInstruction)
{
	(abstractInstruction->annotation = IsAbsPCReference);
	return abstractInstruction;
}

	/* Cogit>>#annotateBytecode: */
static AbstractInstruction * NoDbgRegParms
annotateBytecode(AbstractInstruction *abstractInstruction)
{
	(abstractInstruction->annotation = HasBytecodePC);
	return abstractInstruction;
}

	/* Cogit>>#annotate:objRef: */
static AbstractInstruction * NoDbgRegParms
annotateobjRef(AbstractInstruction *abstractInstruction, sqInt anOop)
{
	if (shouldAnnotateObjectReference(anOop)) {
		setHasMovableLiteral(1);
		if (isYoungObject(anOop)) {
			setHasYoungReferent(1);
		}
		(abstractInstruction->annotation = IsObjectReference);
	}
	return abstractInstruction;
}

	/* Cogit>>#assertSaneJumpTarget: */
static void NoDbgRegParms
assertSaneJumpTarget(AbstractInstruction *jumpTarget)
{
	assert((closedPICSize == null)
	 || ((openPICSize == null)
	 || ((addressIsInInstructions(jumpTarget))
	 || ((((((usqInt)jumpTarget)) >= codeBase) && ((((usqInt)jumpTarget)) <= ((((sqInt)(limitZony()))) + (((closedPICSize < openPICSize) ? openPICSize : closedPICSize)))))))));
}


/*	Answer an unused abstract register in the registerMask, or NoReg if none. */

	/* Cogit>>#availableRegisterOrNoneIn: */
static sqInt NoDbgRegParms
availableRegisterOrNoneIn(sqInt liveRegsMask)
{
    sqInt reg;

	if (liveRegsMask != 0) {
		for (reg = 0; reg <= 0x1F; reg += 1) {
			if (((liveRegsMask & (1ULL << reg)) != 0)) {
				return reg;
			}
		}
	}
	return NoReg;
}


/*	Evaluate binaryFunction with the block start mcpc and supplied arg for
	each entry in the block dispatch. If the function answers non-zero answer
	the value
	it answered. Used to update back-references to the home method in
	compaction.  */

	/* Cogit>>#blockDispatchTargetsFor:perform:arg: */
static sqInt NoDbgRegParms
blockDispatchTargetsForperformarg(CogMethod *cogMethod, usqInt (*binaryFunction)(sqInt mcpc, sqInt arg), sqInt arg)
{
    sqInt blockEntry;
    usqInt end;
    sqInt pc;
    sqInt result;
    usqInt targetpc;

	if (((cogMethod->blockEntryOffset)) == 0) {
		return null;
	}
	blockEntry = ((cogMethod->blockEntryOffset)) + (((sqInt)cogMethod));
	pc = blockEntry;
	end = (mapEndFor(cogMethod)) - 1;
	while (pc < end) {
		if (isJumpAt(backEnd, pc)) {
			targetpc = jumpTargetPCAt(backEnd, pc);
			if (targetpc < blockEntry) {
				result = binaryFunction(targetpc, arg);
				if (result != 0) {
					return result;
				}
			}
		}
		pc += instructionSizeAt(backEnd, pc);
	}
	return 0;
}


/*	Answer the zero-relative bytecode pc matching the machine code pc argument
	in cogMethod, given the start of the bytecodes for cogMethod's block or
	method object. */

	/* Cogit>>#bytecodePCFor:startBcpc:in: */
sqInt
bytecodePCForstartBcpcin(sqInt mcpc, sqInt startbcpc, CogBlockMethod *cogMethod)
{
    sqInt aMethodHeader;
    sqInt aMethodHeader1;
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    usqInt map;
    sqInt mapByte;
    usqInt mcpc1;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt targetPC;

	latestContinuation = 0;
	/* begin mapFor:bcpc:performUntil:arg: */
	assert(((cogMethod->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc1 = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	result = findIsBackwardBranchMcpcBcpcMatchingMcpc(null, (0 + (((sqInt)((usqInt)(HasBytecodePC) << 1)))), (((char *) mcpc1)), startbcpc, (((void *)mcpc)));
	if (result != 0) {
		return result;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if (((cogMethod->cmType)) >= CMMethod) {
		/* begin cmIsFullBlock */
		isInBlock = (cogMethod->cpicHasMNUCaseOrCMIsFullBlock);
		homeMethod = ((CogMethod *) cogMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		/* begin mapStartFor: */
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader = (homeMethod->methodHeader);
		bsOffset = (headerIndicatesAlternateBytecodeSet(aMethodHeader)
						? 0x100
						: 0);
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == ((cogMethod->startpc)));
		homeMethod = cmHomeMethod(cogMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - ((headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
		? AltBlockCreationBytecodeSize
		: BlockCreationBytecodeSize));
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader1 = (homeMethod->methodHeader);
		bsOffset = (headerIndicatesAlternateBytecodeSet(aMethodHeader1)
						? 0x100
						: 0);
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		/* begin nextBytecodePCFor:at:exts:in: */
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj))
	: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	enumeratingCogMethod = homeMethod;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc1 += (mapByte & DisplacementMask);
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							return 0;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							return 0;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					/* begin nextBytecodePCFor:at:exts:in: */
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj))
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && ((assert(((descriptor->spanFunction)) != null),
				(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = findIsBackwardBranchMcpcBcpcMatchingMcpc(descriptor, ((isBackwardBranch
	? (((sqInt)((usqInt)(annotation) << 1))) + 1
	: ((sqInt)((usqInt)(annotation) << 1)))), (((char *) mcpc1)), ((isBackwardBranch
	? bcpc - (2 * nExts)
	: bcpc)), (((void *)mcpc)));
				if (result != 0) {
					return result;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc1 += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
			}
		}
		map -= 1;
	}
	return 0;
}

	/* Cogit>>#CallRT:registersToBeSavedMask: */
static AbstractInstruction * NoDbgRegParms
CallRTregistersToBeSavedMask(sqInt callTarget, sqInt registersToBeSaved)
{
    AbstractInstruction *abstractInstruction;
    sqInt callerSavedRegsToBeSaved;
    AbstractInstruction *lastInst;
    sqInt reg;
    sqInt registersToBePushed;

	reg = 0;
	callerSavedRegsToBeSaved = CallerSavedRegisterMask & registersToBeSaved;
	registersToBePushed = callerSavedRegsToBeSaved;
	reg = 0;
	while (registersToBePushed != 0) {
		if (((registersToBePushed & 1) != 0)) {
			/* begin PushR: */
			genoperand(PushR, reg);
		}
		reg += 1;
		registersToBePushed = (registersToBePushed) >> 1;
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, callTarget);
	(abstractInstruction->annotation = IsRelativeCall);
	lastInst = abstractInstruction;
	while (reg > 0) {
		reg -= 1;
		if (((callerSavedRegsToBeSaved & (1ULL << reg)) != 0)) {
			/* begin PopR: */
			lastInst = genoperand(PopR, reg);
		}
	}
	return lastInst;
}

	/* Cogit>>#Call: */
static AbstractInstruction * NoDbgRegParms
gCall(sqInt callTarget)
{
	return genoperand(Call, callTarget);
}

	/* Cogit>>#CmpCq:R: */
static AbstractInstruction * NoDbgRegParms
gCmpCqR(sqInt quickConstant, sqInt reg)
{
	return genoperandoperand(CmpCqR, quickConstant, reg);
}


/*	This is a static version of ceCallCogCodePopReceiverReg for break-pointing
	when debugging in C. Marked <api> so the code generator won't delete it. */

	/* Cogit>>#callCogCodePopReceiver */
static void
callCogCodePopReceiver(void)
{
	realCECallCogCodePopReceiverReg();
	if (!Debug) {
		error("what??");
	}
}


/*	This is a static version of ceCallCogCodePopReceiverAndClassRegs for
	break-pointing when debugging in C. Marked <api> so the code generator
	won't delete it. */

	/* Cogit>>#callCogCodePopReceiverAndClassRegs */
static void
callCogCodePopReceiverAndClassRegs(void)
{
	realCECallCogCodePopReceiverAndClassRegs();
}


/*	Code entry closed PIC miss. A send has fallen
	through a closed (finite) polymorphic inline cache.
	Either extend it or patch the send site to an open PIC.
	The stack looks like:
	receiver
	args
	sp=>	sender return address */
/*	Marked <api> so the code generator won't delete it. */

	/* Cogit>>#ceCPICMiss:receiver: */
static sqInt NoDbgRegParms
ceCPICMissreceiver(CogMethod *cPIC, sqInt receiver)
{
    sqInt cacheTag;
    sqInt errorSelectorOrNil;
    sqInt methodOrSelectorIndex;
    sqInt newTargetMethodOrNil;
    sqInt outerReturn;
    sqInt result;
    sqInt selector;

	if (isOopForwarded(receiver)) {
		return ceSendFromInLineCacheMiss(cPIC);
	}
	outerReturn = stackTop();
	assert(!(((inlineCacheTagAt(backEnd, outerReturn)) == (picAbortDiscriminatorValue()))));
	if (((cPIC->cPICNumCases)) < MaxCPICCases) {
		/* begin lookup:for:methodAndErrorSelectorInto: */
		selector = (cPIC->selector);
		methodOrSelectorIndex = lookupOrdinaryreceiver(selector, receiver);
		if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
			if (!(isOopCompiledMethod(methodOrSelectorIndex))) {
				newTargetMethodOrNil = methodOrSelectorIndex;
				errorSelectorOrNil = SelectorCannotInterpret;
				goto l1;
			}
			if ((!(methodHasCogMethod(methodOrSelectorIndex)))
			 && (methodShouldBeCogged(methodOrSelectorIndex))) {

				/* We assume cog:selector: will *not* reclaim the method zone */
				cogselector(methodOrSelectorIndex, selector);
			}
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = null;
			goto l1;
		}
		if (methodOrSelectorIndex == SelectorDoesNotUnderstand) {
			methodOrSelectorIndex = lookupMNUreceiver(splObj(SelectorDoesNotUnderstand), receiver);
			if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
				assert(isOopCompiledMethod(methodOrSelectorIndex));
				if ((!(methodHasCogMethod(methodOrSelectorIndex)))
				 && (methodShouldBeCogged(methodOrSelectorIndex))) {

					/* We assume cog:selector: will *not* reclaim the method zone */
					cogselector(methodOrSelectorIndex, splObj(SelectorDoesNotUnderstand));
				}
				newTargetMethodOrNil = methodOrSelectorIndex;
				errorSelectorOrNil = SelectorDoesNotUnderstand;
				goto l1;
			}
			newTargetMethodOrNil = null;
			errorSelectorOrNil = SelectorDoesNotUnderstand;
			goto l1;
		}
		newTargetMethodOrNil = null;
		errorSelectorOrNil = methodOrSelectorIndex;
	l1:	/* end lookup:for:methodAndErrorSelectorInto: */;
	}
	else {
		newTargetMethodOrNil = (errorSelectorOrNil = null);
	}
	assert(outerReturn == (stackTop()));
	/* begin ensureWritableCodeZone */
	cacheTag = inlineCacheTagForInstance(receiver);
	if ((((cPIC->cPICNumCases)) >= MaxCPICCases)
	 || (((errorSelectorOrNil != null)
	 && (errorSelectorOrNil != SelectorDoesNotUnderstand))
	 || ((newTargetMethodOrNil == null)
	 || (isYoung(newTargetMethodOrNil))))) {
		result = patchToOpenPICFornumArgsreceiver((cPIC->selector), (cPIC->cmNumArgs), receiver);
		assert(!result);
		/* begin ensureExecutableCodeZone */
		return ceSendFromInLineCacheMiss(cPIC);
	}
	cogExtendPICCaseNMethodtagisMNUCase(cPIC, newTargetMethodOrNil, cacheTag, errorSelectorOrNil == SelectorDoesNotUnderstand);
	/* begin ensureExecutableCodeZone */
	executeCogPICfromLinkedSendWithReceiverandCacheTag(cPIC, receiver, literal32BeforeFollowingAddress(backEnd, ((usqInt)(outerReturn - 5))));
	return null;
}


/*	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it. 
 */

	/* Cogit>>#ceFree: */
static void NoDbgRegParms
ceFree(void *pointer)
{
	free(pointer);
}


/*	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it. 
 */

	/* Cogit>>#ceMalloc: */
static void* NoDbgRegParms
ceMalloc(size_t size)
{
	return malloc(size);
}


/*	An in-line cache check in a method has failed. The failing entry check has
	jumped to the ceMethodAbort abort call at the start of the method which
	has called this routine.
	If possible allocate a closed PIC for the current and existing classes.
	The stack looks like:
	receiver
	args
	sender return address
	sp=>	ceMethodAbort call return address
	So we can find the method that did the failing entry check at
	ceMethodAbort call return address - missOffset
	and we can find the send site from the outer return address.
	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it.  */

	/* Cogit>>#ceSICMiss: */
static sqInt NoDbgRegParms
ceSICMiss(sqInt receiver)
{
    sqInt cacheTag;
    sqInt entryPoint;
    sqInt errorSelectorOrNil;
    sqInt extent;
    usqInt innerReturn;
    sqInt methodOrSelectorIndex;
    sqInt newTargetMethodOrNil;
    usqInt outerReturn;
    CogMethod *pic;
    sqInt result;
    sqInt selector;
    CogMethod *targetMethod;


	/* Whether we can relink to a PIC or not we need to pop off the inner return and identify the target method. */
	innerReturn = ((usqInt)(popStack()));
	targetMethod = ((CogMethod *) (innerReturn - missOffset));
	if (isOopForwarded(receiver)) {
		return ceSendFromInLineCacheMiss(targetMethod);
	}
	outerReturn = ((usqInt)(stackTop()));
	assert(((outerReturn >= methodZoneBase) && (outerReturn <= (freeStart()))));
	entryPoint = callTargetFromReturnAddress(backEnd, outerReturn);
	assert(((targetMethod->selector)) != (nilObject()));
	assert(((((sqInt)targetMethod)) + cmEntryOffset) == entryPoint);
	/* begin lookup:for:methodAndErrorSelectorInto: */
	selector = (targetMethod->selector);
	methodOrSelectorIndex = lookupOrdinaryreceiver(selector, receiver);
	if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
		if (!(isOopCompiledMethod(methodOrSelectorIndex))) {
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = SelectorCannotInterpret;
			goto l1;
		}
		if ((!(methodHasCogMethod(methodOrSelectorIndex)))
		 && (methodShouldBeCogged(methodOrSelectorIndex))) {

			/* We assume cog:selector: will *not* reclaim the method zone */
			cogselector(methodOrSelectorIndex, selector);
		}
		newTargetMethodOrNil = methodOrSelectorIndex;
		errorSelectorOrNil = null;
		goto l1;
	}
	if (methodOrSelectorIndex == SelectorDoesNotUnderstand) {
		methodOrSelectorIndex = lookupMNUreceiver(splObj(SelectorDoesNotUnderstand), receiver);
		if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
			assert(isOopCompiledMethod(methodOrSelectorIndex));
			if ((!(methodHasCogMethod(methodOrSelectorIndex)))
			 && (methodShouldBeCogged(methodOrSelectorIndex))) {

				/* We assume cog:selector: will *not* reclaim the method zone */
				cogselector(methodOrSelectorIndex, splObj(SelectorDoesNotUnderstand));
			}
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = SelectorDoesNotUnderstand;
			goto l1;
		}
		newTargetMethodOrNil = null;
		errorSelectorOrNil = SelectorDoesNotUnderstand;
		goto l1;
	}
	newTargetMethodOrNil = null;
	errorSelectorOrNil = methodOrSelectorIndex;
	l1:	/* end lookup:for:methodAndErrorSelectorInto: */;
	assert(outerReturn == (stackTop()));
	cacheTag = inlineCacheTagForInstance(receiver);
	if ((((errorSelectorOrNil != null)
	 && (errorSelectorOrNil != SelectorDoesNotUnderstand))
	 || ((newTargetMethodOrNil == null)
	 || (isYoung(newTargetMethodOrNil))))
	 || ((literal32BeforeFollowingAddress(backEnd, ((usqInt)(outerReturn - 5)))) == 0 /* picAbortDiscriminatorValue */)) {
		result = patchToOpenPICFornumArgsreceiver((targetMethod->selector), (targetMethod->cmNumArgs), receiver);
		assert(!result);
		return ceSendFromInLineCacheMiss(targetMethod);
	}
	/* begin ensureWritableCodeZone */
	pic = openPICWithSelector((targetMethod->selector));
	if ((pic == null)) {

		/* otherwise attempt to create a closed PIC for the two cases. */
		pic = cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase((targetMethod->selector), (targetMethod->cmNumArgs), targetMethod, newTargetMethodOrNil, cacheTag, errorSelectorOrNil == SelectorDoesNotUnderstand);
		if ((((((sqInt)pic)) >= MaxNegativeErrorCode) && ((((sqInt)pic)) <= -1))) {

			/* For some reason the PIC couldn't be generated, most likely a lack of code memory.
			   Continue as if this is an unlinked send. */
			if ((((sqInt)pic)) == InsufficientCodeSpace) {
				callForCogCompiledCodeCompaction();
			}
			/* begin ensureExecutableCodeZone */
			return ceSendFromInLineCacheMiss(targetMethod);
		}
	}
	extent = (((pic->cmType)) == CMOpenPIC
		? rewriteInlineCacheAttagtarget(backEnd, outerReturn, inlineCacheValueForSelectorin(backEnd, (targetMethod->selector), mframeHomeMethodExport()), (((sqInt)pic)) + cmEntryOffset)
		: rewriteCallAttarget(backEnd, outerReturn, (((sqInt)pic)) + cmEntryOffset));
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, (((usqInt)pic)) + cmNoCheckEntryOffset, codeToDataDelta);
#  endif
	flushICacheFromto(backEnd, ((usqInt)pic), (((usqInt)pic)) + closedPICSize);
	flushICacheFromto(backEnd, (((usqInt)outerReturn)) - extent, ((usqInt)outerReturn));
	executeCogPICfromLinkedSendWithReceiverandCacheTag(pic, receiver, literal32BeforeFollowingAddress(backEnd, ((usqInt)(outerReturn - 5))));
	return null;
}


/*	Check for a valid object reference, if any, at a map entry. Answer a code
	unique to each error for debugging. */

	/* Cogit>>#checkIfValidOopRefAndTarget:pc:cogMethod: */
static sqInt NoDbgRegParms
checkIfValidOopRefAndTargetpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    usqInt cacheTag1;
    sqInt entryPoint;
    sqInt entryPoint1;
    sqInt literal;
    sqInt offset1;
    sqInt *sendTable1;
    sqInt tagCouldBeObj;
    CogMethod *targetMethod1;

	if (annotation == IsObjectReference) {
		/* begin fetchLiteralAtAnnotatedAddress:using: */
		literal = literalBeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)mcpc));
		if (!(asserta(checkValidOopReference(literal)))) {
			return 1;
		}
		if ((couldBeObject(literal))
		 && (isReallyYoungObject(literal))) {
			if (!(asserta(((((CogMethod *) cogMethod))->cmRefersToYoung)))) {
				return 2;
			}
		}
	}
	if (annotation >= IsSendCall) {
		if (!(asserta(isCMMethodEtAl(((CogBlockMethod *) (((CogMethod *) cogMethod))))))) {
			return 3;
		}
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		
		cacheTag1 = literal32BeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 5)));

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj = 0;
		entryPoint = entryPoint1;
		if (tagCouldBeObj) {
			if (couldBeObject(cacheTag1)) {
				if (!(asserta(checkValidOopReference(cacheTag1)))) {
					return 4;
				}
			}
			else {
				if (!(asserta(validInlineCacheTag(cacheTag1)))) {
					return 5;
				}
			}
			if ((couldBeObject(cacheTag1))
			 && (isReallyYoungObject(cacheTag1))) {
				if (!(asserta(((((CogMethod *) cogMethod))->cmRefersToYoung)))) {
					return 6;
				}
			}
		}
		else {
			if (entryPointTagIsSelector(entryPoint)) {
				if ((((int) cacheTag1)) < 0) {
					if ((-(((int) cacheTag1))) > NumSpecialSelectors) {
						return 7;
					}
				}
				else {
					if (cacheTag1 >= (literalCountOf((enumeratingCogMethod->methodObject)))) {
						return 8;
					}
				}
			}
			else {
				if (!(asserta(validInlineCacheTag(cacheTag1)))) {
					return 9;
				}
			}
		}
		if (entryPoint > methodZoneBase) {

			/* It's a linked send; find which kind. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (!(asserta((isCMMethodEtAl(((CogBlockMethod *) targetMethod1)))
				 || ((isCMClosedPIC(((CogBlockMethod *) targetMethod1)))
				 || (isCMOpenPIC(((CogBlockMethod *) targetMethod1))))))) {
				return 10;
			}
		}
	}
	return 0;
}


/*	Check for a valid object reference, if any, at a map entry. Answer a code
	unique to each error for debugging. */

	/* Cogit>>#checkIfValidOopRef:pc:cogMethod: */
static sqInt NoDbgRegParms
checkIfValidOopRefpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    sqInt entryPoint;
    sqInt literal;
    sqInt offset;
    sqInt offset1;
    usqInt selectorOrCacheTag;
    sqInt *sendTable;

	if (annotation == IsObjectReference) {
		/* begin fetchLiteralAtAnnotatedAddress:using: */
		literal = literalBeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)mcpc));
		if (!(checkValidOopReference(literal))) {
			print("object ref leak in CM ");
			printHex(((sqInt)cogMethod));
			print(" @ ");
			printHex(((sqInt)mcpc));
			eekcr();
			return 1;
		}
	}
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint <= methodZoneBase) {
			offset = entryPoint;
		}
		else {
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable = superSendTrampolines;
					}
				}
			}
			offset = offset1;
		}
		/* begin inlineCacheTagAt: */
		selectorOrCacheTag = literal32BeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 5)));
		if ((entryPoint > methodZoneBase)
		 && ((offset != cmNoCheckEntryOffset)
		 && (!((((((CogMethod *) (entryPoint - offset)))->cmType)) == CMOpenPIC)))) {

			/* linked non-super send, cacheTag is a cacheTag */
			if (!(validInlineCacheTag(selectorOrCacheTag))) {
				print("cache tag leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" @ ");
				printHex(((sqInt)mcpc));
				eekcr();
				return 1;
			}
		}
		else {

			/* unlinked send or super send; cacheTag is a selector unless 64-bit, in which case it is an index. */
					}
	}
	return 0;
}


/*	Answer if all references to objects in machine-code are valid. */

	/* Cogit>>#checkIntegrityOfObjectReferencesInCode: */
sqInt
checkIntegrityOfObjectReferencesInCode(sqInt gcModes)
{
    CogMethod *cogMethod;
    sqInt count;
    sqInt ok;

	cogMethod = ((CogMethod *) methodZoneBase);
	ok = 1;
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if ((cogMethod->cmRefersToYoung)) {
				if (((count = occurrencesInYoungReferrers(cogMethod))) != 1) {
					print("young referrer CM ");
					printHex(((sqInt)cogMethod));
					if (count == 0) {
						print(" is not in youngReferrers");
						eekcr();
					}
					else {
						print(" is in youngReferrers ");
						printNum(count);
						print(" times!");
						eekcr();
					}
					ok = 0;
				}
			}
			if (!(checkValidOopReference((cogMethod->selector)))) {
				print("object leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" selector");
				eekcr();
				ok = 0;
			}
			if (((cogMethod->cmType)) >= CMMethod) {
				assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
				if (!(checkValidObjectReference((cogMethod->methodObject)))) {
					print("object leak in CM ");
					printHex(((sqInt)cogMethod));
					print(" methodObject");
					eekcr();
					ok = 0;
				}
				if (!(isOopCompiledMethod((cogMethod->methodObject)))) {
					print("non-method in CM ");
					printHex(((sqInt)cogMethod));
					print(" methodObject");
					eekcr();
					ok = 0;
				}
				if ((mapForperformUntilarg(cogMethod, checkIfValidOopRefpccogMethod, cogMethod)) != 0) {
					ok = 0;
				}
				if (((isYoungObject((cogMethod->methodObject)))
				 || (isYoung((cogMethod->selector))))
				 && (!((cogMethod->cmRefersToYoung)))) {
					print("CM ");
					printHex(((sqInt)cogMethod));
					print(" refers to young but not marked as such");
					eekcr();
					ok = 0;
				}
			}
			else {
				if (((cogMethod->cmType)) == CMClosedPIC) {
					if (!(checkValidObjectReferencesInClosedPIC(cogMethod))) {
						ok = 0;
					}
				}
				else {
					if (((cogMethod->cmType)) == CMOpenPIC) {
						if ((mapForperformUntilarg(cogMethod, checkIfValidOopRefpccogMethod, cogMethod)) != 0) {
							ok = 0;
						}
					}
				}
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return ok;
}

	/* Cogit>>#checkMaybeObjRefInClosedPIC: */
static sqInt NoDbgRegParms
checkMaybeObjRefInClosedPIC(sqInt maybeObject)
{
	if (maybeObject == 0) {
		return 1;
	}
	if (!(couldBeObject(maybeObject))) {
		return 1;
	}
	return checkValidObjectReference(maybeObject);
}

	/* Cogit>>#checkValidObjectReferencesInClosedPIC: */
static sqInt NoDbgRegParms
checkValidObjectReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt ok;
    sqInt pc;

	ok = 1;

	/* first we check the obj ref at the beginning of the CPIC */
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	if (!(checkMaybeObjRefInClosedPIC(literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)))))) {
		print("object leak in CPIC ");
		printHex(((sqInt)cPIC));
		print(" @ ");
		printHex(pc - (jumpLongByteSize(backEnd)));
		cr();
		ok = 0;
	}

	/* For each case we check any object reference at the end address - sizeof(conditional instruction) and then increment the end address by case size */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (!(checkMaybeObjRefInClosedPIC(literalBeforeFollowingAddress(backEnd, (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))))) {
			print("object leak in CPIC ");
			printHex(((sqInt)cPIC));
			print(" @ ");
			printHex(pc - (jumpLongConditionalByteSize(backEnd)));
			cr();
			ok = 0;
		}
		pc += cPICCaseSize;
	}
	return ok;
}


/*	i.e. this should never be called, so keep it out of the main path. */

	/* Cogit>>#cleanUpFailingCogCodeConstituents: */
static sqInt NoDbgRegParms NeverInline
cleanUpFailingCogCodeConstituents(CogMethod *cogMethodArg)
{
    CogMethod *cogMethod;

	cogMethod = cogMethodArg;
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMClosedPIC) {
			(cogMethod->methodObject = 0);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	popRemappableOop();
	return null;
}


/*	Answer if the ClosedPIC refers to any unmarked objects or freed/freeable
	target methods,
	applying markAndTraceOrFreeCogMethod:firstVisit: to those targets to
	determine if freed/freeable.
 */

	/* Cogit>>#closedPICRefersToUnmarkedObject: */
static sqInt NoDbgRegParms
closedPICRefersToUnmarkedObject(CogMethod *cPIC)
{
    sqInt i;
    usqInt object;
    sqInt pc;

	if (!((isImmediate((cPIC->selector)))
		 || (isMarked((cPIC->selector))))) {
		return 1;
	}
	pc = addressOfEndOfCaseinCPIC(1, cPIC);
	if (couldBeObject((object = literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)))))) {
		if (!(isMarked(object))) {
			return 1;
		}
	}
	if (markAndTraceOrFreePICTargetin(jumpLongTargetBeforeFollowingAddress(backEnd, pc), cPIC)) {
		return 1;
	}
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (couldBeObject((object = literalBeforeFollowingAddress(backEnd, (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))))) {
			if (!(isMarked(object))) {
				return 1;
			}
		}
		if (markAndTraceOrFreePICTargetin(jumpLongTargetBeforeFollowingAddress(backEnd, pc), cPIC)) {
			return 1;
		}
	}
	return 0;
}

	/* Cogit>>#codeEntryFor: */
char *
codeEntryFor(char *address)
{
    sqInt i;

	for (i = 0; i <= (trampolineTableIndex - 3); i += 2) {
		if (((address >= (trampolineAddresses[i + 1])) && (address <= ((trampolineAddresses[i + 3]) - 1)))) {
			return trampolineAddresses[i + 1];
		}
	}
	return null;
}

	/* Cogit>>#codeEntryNameFor: */
char *
codeEntryNameFor(char *address)
{
    sqInt i;

	for (i = 0; i <= (trampolineTableIndex - 3); i += 2) {
		if (((address >= (trampolineAddresses[i + 1])) && (address <= ((trampolineAddresses[i + 3]) - 1)))) {
			return trampolineAddresses[i];
		}
	}
	return null;
}


/*	used e.g. in the platform's backtrace generators. Declared api to place it
	in cogit.h
 */

	/* Cogit>>#cogCodeBase */
sqInt
cogCodeBase(void)
{
	return codeBase;
}


/*	Answer the contents of the code zone as an array of pair-wise element,
	address in ascending address order.
	Answer a string for a runtime routine or abstract label (beginning, end,
	etc), a CompiledMethod for a CMMethod,
	or a selector (presumably a Symbol) for a PIC.
	If withDetails is true
	- answer machine-code to bytecode pc mapping information for methods
	- answer class, target pair information for closed PIC
	N.B. Since the class tag for the first case of a closed PIC is stored at
	the send site, it must be collected
	by scanning methods (see
	collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method:). Since closed PICs
	are never shared they always come after the method that references them,
	so we don't need an extra pass
	to collect the first case class tags, which are (temporarily) assigned to
	each closed PIC's methodObject field.
	But we do need to reset the methodObject fields to zero. This is done in
	createPICData:, unless memory
	runs out, in which case it is done by cleanUpFailingCogCodeConstituents:. */

	/* Cogit>>#cogCodeConstituents: */
sqInt
cogCodeConstituents(sqInt withDetails)
{
    CogMethod *cogMethod;
    sqInt constituents;
    sqInt count;
    sqInt i;
    sqInt label;
    sqInt profileData;
    sqInt value;


	/* + 3 for start, freeStart and end */
	count = (trampolineTableIndex / 2) + 3;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			count += 1;
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	constituents = instantiateClassindexableSize(classArray(), count * 2);
	if (!constituents) {
		return constituents;
	}
	pushRemappableOop(constituents);
	if ((((label = stringForCString("CogCode"))) == null)
	 || (((value = positive64BitIntegerFor(codeBase))) == null)) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(0, constituents, label);
	storePointerUncheckedofObjectwithValue(1, constituents, value);
	for (i = 0; i < trampolineTableIndex; i += 2) {
		if ((((label = stringForCString(trampolineAddresses[i]))) == null)
		 || (((value = positive64BitIntegerFor(((usqInt)(trampolineAddresses[i + 1]))))) == null)) {
			popRemappableOop();
			return null;
		}
		storePointerUncheckedofObjectwithValue(2 + i, constituents, label);
		storePointerUncheckedofObjectwithValue(3 + i, constituents, value);
	}
	count = trampolineTableIndex + 2;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			/* begin profileDataFor:withDetails: */
			profileData = (((cogMethod->cmType)) >= CMMethod
				? (cogMethod->methodObject)
				: (withDetails
					 && (((cogMethod->cmType)) == CMClosedPIC)
						? createCPICData(cogMethod)
						: (cogMethod->selector)));
			if (!profileData) {
				return cleanUpFailingCogCodeConstituents(cogMethod);
			}
			storePointerUncheckedofObjectwithValue(count, constituents, profileData);
			if (withDetails) {
				value = collectCogMethodConstituent(cogMethod);
			}
			else {
				/* begin positiveMachineIntegerFor: */
				value = positive64BitIntegerFor(((usqInt)cogMethod));
			}
			if (!value) {
				return cleanUpFailingCogCodeConstituents(cogMethod);
			}
			storePointerUncheckedofObjectwithValue(count + 1, constituents, value);
			count += 2;
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if ((((label = stringForCString("CCFree"))) == null)
	 || (((value = positive64BitIntegerFor(mzFreeStart))) == null)) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(count, constituents, label);
	storePointerUncheckedofObjectwithValue(count + 1, constituents, value);
	if ((((label = stringForCString("CCEnd"))) == null)
	 || (((value = positive64BitIntegerFor(limitAddress))) == null)) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(count + 2, constituents, label);
	storePointerUncheckedofObjectwithValue(count + 3, constituents, value);
	constituents = popRemappableOop();
	beRootIfOld(constituents);
	return constituents;
}


/*	Extend the cPIC with the supplied case. If caseNMethod is cogged dispatch
	direct to
	its unchecked entry-point. If caseNMethod is not cogged, jump to the fast
	interpreter dispatch, and if isMNUCase then dispatch to fast MNU
	invocation and mark the cPIC as
	having the MNU case for cache flushing. */

	/* Cogit>>#cogExtendPIC:CaseNMethod:tag:isMNUCase: */
static void NoDbgRegParms
cogExtendPICCaseNMethodtagisMNUCase(CogMethod *cPIC, sqInt caseNMethod, sqInt caseNTag, sqInt isMNUCase)
{
    sqInt address;
    sqInt operand;
    CogBlockMethod * self_in_cpicHasMNUCase;
    sqInt target;

	compilationBreakpointclassTagisMNUCase((cPIC->selector), caseNTag, isMNUCase);
	assert(!(inlineCacheTagIsYoung(caseNTag)));
	assert((caseNMethod != null)
	 && (!(isYoung(caseNMethod))));
	if ((!isMNUCase)
	 && (methodHasCogMethod(caseNMethod))) {

		/* this isn't an MNU and we have an already cogged method to jump to */
		operand = 0;
		target = (((sqInt)(cogMethodOf(caseNMethod)))) + cmNoCheckEntryOffset;
	}
	else {
		operand = caseNMethod;
		if (isMNUCase) {

			/* this is an MNU so tag the CPIC header and setup a jump to the MNUAbort */
			/* begin cpicHasMNUCase: */
			self_in_cpicHasMNUCase = ((CogBlockMethod *) (((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta))));
			(self_in_cpicHasMNUCase->cpicHasMNUCaseOrCMIsFullBlock) = 1;
			target = (((sqInt)cPIC)) + (sizeof(CogMethod));
		}
		else {

			/* setup a jump to the interpretAborth so we can cog the target method */
			target = (((sqInt)cPIC)) + (picInterpretAbortOffset());
		}
	}
	address = addressOfEndOfCaseinCPIC(((cPIC->cPICNumCases)) + 1, cPIC);
	rewriteCPICCaseAttagobjReftarget(address, caseNTag, operand, target);
	/* begin rewriteCPIC:caseJumpTo: */
	rewriteCPICJumpAttarget(backEnd, (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd)), address - cPICCaseSize);
	((((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta)))->cPICNumCases = ((cPIC->cPICNumCases)) + 1);
	flushICacheFromto(backEnd, ((usqInt)cPIC), (((usqInt)cPIC)) + closedPICSize);
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, (((usqInt)cPIC)) + cmNoCheckEntryOffset, codeToDataDelta);
#  endif
	return;
}


/*	Attempt to produce a machine code method for the bytecode method
	object aMethodObj. N.B. If there is no code memory available do *NOT*
	attempt to reclaim the method zone. Certain clients (e.g. ceSICMiss:)
	depend on the zone remaining constant across method generation. */

	/* Cogit>>#cogFullBlockMethod:numCopied: */
CogMethod *
cogFullBlockMethodnumCopied(sqInt aMethodObj, sqInt numCopied)
{
    CogMethod *cogMethod;

	assert(!((methodHasCogMethod(aMethodObj))));
	if (aMethodObj == breakMethod) {
		haltmsg("Compilation of breakMethod");
	}
	ensureNoForwardedLiteralsIn(aMethodObj);
	if (methodUsesAlternateBytecodeSet(aMethodObj)) {
		if ((numElementsIn(generatorTable)) <= 0x100) {
			return null;
		}
		bytecodeSetOffset = 0x100;
	}
	else {
		bytecodeSetOffset = 0;
	}
	assert(isFullBlockMethod(aMethodObj));
	methodObj = aMethodObj;
	methodHeader = methodHeaderOf(aMethodObj);

	/* lazy initialization */
	receiverTags = -1;
	cogMethod = compileCogFullBlockMethod(numCopied);
	if ((((((sqInt)cogMethod)) >= MaxNegativeErrorCode) && ((((sqInt)cogMethod)) <= -1))) {
		if ((((sqInt)cogMethod)) == InsufficientCodeSpace) {
			callForCogCompiledCodeCompaction();
		}
		return null;
	}
	return cogMethod;
}

	/* Cogit>>#cogitPostGCAction: */
void
cogitPostGCAction(sqInt gcMode)
{
	if (gcMode == GCModeBecome) {
		followForwardedLiteralsInOpenPICList();
	}
	assert(allMethodsHaveCorrectHeader());
	assert(((!(gcMode & (GCModeFull + GCModeNewSpace))))
	 || (kosherYoungReferrers()));
	/* begin ensureExecutableCodeZone */
	return;
}


/*	Check that the header fields onf a non-free method are consistent with
	the type. Answer 0 if it is ok, otherwise answer a code for the error. */

	/* Cogit>>#cogMethodDoesntLookKosher: */
static sqInt NoDbgRegParms
cogMethodDoesntLookKosher(CogMethod *cogMethod)
{
	if (((((cogMethod->blockSize)) & (BytesPerWord - 1)) != 0)
	 || ((((cogMethod->blockSize)) < (sizeof(CogMethod)))
	 || (((cogMethod->blockSize)) >= 0x8000))) {
		return 1;
	}
	if (((cogMethod->cmType)) == CMFree) {
		return 2;
	}
	if (((cogMethod->cmType)) >= CMMethod) {
		if (!((((((cogMethod->methodHeader))) & 7) == 1))) {
			return 11;
		}
		if (!(couldBeObject((cogMethod->methodObject)))) {
			return 12;
		}
		if ((((cogMethod->stackCheckOffset)) > 0)
		 && (((cogMethod->stackCheckOffset)) < cmNoCheckEntryOffset)) {
			return 13;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		if (((cogMethod->blockSize)) != openPICSize) {
			return 21;
		}
		if (((cogMethod->methodHeader)) != 0) {
			return 22;
		}
		if (((cogMethod->objectHeader)) >= 0) {
			if (!((((cogMethod->methodObject)) == 0)
				 || (compactionInProgress
				 || (((cogMethod->methodObject)) == (((usqInt)(methodFor(((void *)((cogMethod->methodObject))))))))))) {
				return 23;
			}
		}
		if (((cogMethod->stackCheckOffset)) != 0) {
			return 24;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		if (((cogMethod->blockSize)) != closedPICSize) {
			return 0x1F;
		}
		if (!(((((cogMethod->cPICNumCases)) >= 1) && (((cogMethod->cPICNumCases)) <= MaxCPICCases)))) {
			return 32;
		}
		if (((cogMethod->methodHeader)) != 0) {
			return 33;
		}
		if (((cogMethod->methodObject)) != 0) {
			return 34;
		}
		return 0;
	}
	return 9;
}


/*	Attempt to create a one-case PIC for an MNU.
	The tag for the case is at the send site and so doesn't need to be
	generated. 
 */

	/* Cogit>>#cogMNUPICSelector:receiver:methodOperand:numArgs: */
CogMethod *
cogMNUPICSelectorreceivermethodOperandnumArgs(sqInt selector, sqInt rcvr, sqInt methodOperand, sqInt numArgs)
{
    CogMethod *actualPIC;
    usqInt startAddress;
    CogMethod *writablePIC;

	if ((isYoung(selector))
	 || ((inlineCacheTagForInstance(rcvr)) == 0 /* picAbortDiscriminatorValue */)) {
		return 0;
	}
	compilationBreakpointclassTagisMNUCase(selector, fetchClassTagOf(rcvr), 1);
	assert(endCPICCase0 != null);
	startAddress = allocate(closedPICSize);
	if (startAddress == 0) {
		callForCogCompiledCodeCompaction();
		return 0;
	}
	maybeBreakGeneratingFromto(startAddress, startAddress + closedPICSize);
	/* begin ensureWritableCodeZone */
	/* begin writableMethodFor: */
	writablePIC = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	codeMemcpy(writablePIC, cPICPrototype, closedPICSize);
	/* begin fillInCPICHeader:numArgs:numCases:hasMNUCase:selector: */
	assert(!(isYoung(selector)));
	(writablePIC->cmType = CMClosedPIC);
	(writablePIC->objectHeader = 0);
	(writablePIC->blockSize = closedPICSize);
	(writablePIC->methodObject = 0);
	(writablePIC->methodHeader = 0);
	(writablePIC->selector = selector);
	(writablePIC->cmNumArgs = numArgs);
	(writablePIC->cmHasMovableLiteral = 0);
	(writablePIC->cmRefersToYoung = 0);
	(writablePIC->cmUsageCount = initialClosedPICUsageCount());
	/* begin cpicHasMNUCase: */
	((((CogBlockMethod *) writablePIC))->cpicHasMNUCaseOrCMIsFullBlock) = 1;
	(writablePIC->cPICNumCases = 1);
	(writablePIC->blockEntryOffset = 0);
	assert(isCMClosedPIC(((CogBlockMethod *) writablePIC)));
	assert(((writablePIC->selector)) == selector);
	assert(((writablePIC->cmNumArgs)) == numArgs);
	assert(((writablePIC->cPICNumCases)) == 1);
	assert(closedPICSize == (roundUpLength(closedPICSize)));
	/* begin maybeEnableSingleStep */
	configureMNUCPICmethodOperandnumArgsdelta((actualPIC = ((CogMethod *) startAddress)), methodOperand, numArgs, startAddress - (((usqInt)cPICPrototype)));
	flushICacheFromto(backEnd, startAddress, startAddress + closedPICSize);
	assert((callTargetFromReturnAddress(backEnd, startAddress + missOffset)) == (picAbortTrampolineFor(numArgs)));
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, startAddress + cmNoCheckEntryOffset, codeToDataDelta);
#  endif
	return actualPIC;
}


/*	Create an Open PIC. Temporarily create a direct call of
	ceSendFromOpenPIC:. Should become a probe of the first-level method lookup
	cache followed by a
	call of ceSendFromOpenPIC: if the probe fails. */

	/* Cogit>>#cogOpenPICSelector:numArgs: */
static CogMethod * NoDbgRegParms
cogOpenPICSelectornumArgs(sqInt selector, sqInt numArgs)
{
    sqInt codeSize;
    sqInt end;
    sqInt fixupSize;
    sqInt mapSize;
    sqInt opcodeSize;
    CogMethod *pic;
    usqInt startAddress;

	compilationBreakpointisMNUCase(selector, 0);
	startAddress = allocate(openPICSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	(methodLabel->address = startAddress);
	(methodLabel->dependent = null);
	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 100;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	compileOpenPICnumArgs(selector, numArgs);
	computeMaximumSizes();
	concretizeAt(methodLabel, startAddress);
	codeSize = generateInstructionsAt(startAddress + (sizeof(CogMethod)));
	/* begin ensureWritableCodeZone */
	mapSize = generateMapAtstart((startAddress + openPICSize) - 1, startAddress + cmNoCheckEntryOffset);
	assert((((entry->address)) - startAddress) == cmEntryOffset);
	assert(((roundUpLength((sizeof(CogMethod)) + codeSize)) + (roundUpLength(mapSize))) <= openPICSize);
	end = outputInstructionsAt(startAddress + (sizeof(CogMethod)));
	/* begin fillInOPICHeader:numArgs:selector: */
	pic = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	(pic->cmType = CMOpenPIC);
	(pic->objectHeader = 0);
	(pic->blockSize = openPICSize);
	addToOpenPICList(pic);
	(pic->methodHeader = 0);
	(pic->selector = selector);
	(pic->cmNumArgs = numArgs);
	(pic->cmHasMovableLiteral = isNonImmediate(selector));
	if ((pic->cmRefersToYoung = isYoung(selector))) {
		addToYoungReferrers(pic);
	}
	(pic->cmUsageCount = initialOpenPICUsageCount());
	/* begin cpicHasMNUCase: */
	((((CogBlockMethod *) pic))->cpicHasMNUCaseOrCMIsFullBlock) = 0;
	(pic->cPICNumCases = 0);
	(pic->blockEntryOffset = 0);
	flushICacheFromto(backEnd, (((usqInt)pic)) - codeToDataDelta, ((((usqInt)pic)) - codeToDataDelta) + openPICSize);
	assert(isCMOpenPIC(((CogBlockMethod *) pic)));
	assert(((pic->selector)) == selector);
	assert(((pic->cmNumArgs)) == numArgs);
	assert((callTargetFromReturnAddress(backEnd, ((((sqInt)pic)) - codeToDataDelta) + missOffset)) == (picAbortTrampolineFor(numArgs)));
	assert(openPICSize == (roundUpLength(openPICSize)));
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, ((((usqInt)pic)) - codeToDataDelta) + cmNoCheckEntryOffset, codeToDataDelta);
#  endif
	/* begin maybeEnableSingleStep */
	return ((CogMethod *) startAddress);
}


/*	Attempt to create a two-case PIC for case0CogMethod and
	case1Method,case1Tag. The tag for case0CogMethod is at the send site and
	so doesn't need to be generated.
	case1Method may be any of
	- a Cog method; link to its unchecked entry-point
	- a CompiledMethod; link to ceInterpretMethodFromPIC:
	- a CompiledMethod; link to ceMNUFromPICMNUMethod:receiver: */

	/* Cogit>>#cogPICSelector:numArgs:Case0Method:Case1Method:tag:isMNUCase: */
static CogMethod * NoDbgRegParms
cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase(sqInt selector, sqInt numArgs, CogMethod *case0CogMethod, sqInt case1MethodOrNil, sqInt case1Tag, sqInt isMNUCase)
{
    CogMethod *actualPIC;
    usqInt startAddress;
    CogMethod *writablePIC;

	if (isYoung(selector)) {
		return ((CogMethod *) YoungSelectorInPIC);
	}
	compilationBreakpointclassTagisMNUCase(selector, case1Tag, isMNUCase);
	startAddress = allocate(closedPICSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	maybeBreakGeneratingFromto(startAddress, startAddress + closedPICSize);
	/* begin writableMethodFor: */
	writablePIC = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	codeMemcpy(writablePIC, cPICPrototype, closedPICSize);
	/* begin fillInCPICHeader:numArgs:numCases:hasMNUCase:selector: */
	assert(!(isYoung(selector)));
	(writablePIC->cmType = CMClosedPIC);
	(writablePIC->objectHeader = 0);
	(writablePIC->blockSize = closedPICSize);
	(writablePIC->methodObject = 0);
	(writablePIC->methodHeader = 0);
	(writablePIC->selector = selector);
	(writablePIC->cmNumArgs = numArgs);
	(writablePIC->cmHasMovableLiteral = 0);
	(writablePIC->cmRefersToYoung = 0);
	(writablePIC->cmUsageCount = initialClosedPICUsageCount());
	/* begin cpicHasMNUCase: */
	((((CogBlockMethod *) writablePIC))->cpicHasMNUCaseOrCMIsFullBlock) = isMNUCase;
	(writablePIC->cPICNumCases = 2);
	(writablePIC->blockEntryOffset = 0);
	assert(isCMClosedPIC(((CogBlockMethod *) writablePIC)));
	assert(((writablePIC->selector)) == selector);
	assert(((writablePIC->cmNumArgs)) == numArgs);
	assert(((writablePIC->cPICNumCases)) == 2);
	assert(closedPICSize == (roundUpLength(closedPICSize)));
	/* begin maybeEnableSingleStep */
	configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta((actualPIC = ((CogMethod *) startAddress)), case0CogMethod, case1MethodOrNil, case1Tag, isMNUCase, numArgs, startAddress - (((usqInt)cPICPrototype)));
	assert((callTargetFromReturnAddress(backEnd, startAddress + missOffset)) == (picAbortTrampolineFor(numArgs)));
	return actualPIC;
}


/*	Attempt to produce a machine code method for the bytecode method
	object aMethodObj. N.B. If there is no code memory available do *NOT*
	attempt to reclaim the method zone. Certain clients (e.g. ceSICMiss:)
	depend on the zone remaining constant across method generation. */

	/* Cogit>>#cog:selector: */
CogMethod *
cogselector(sqInt aMethodObj, sqInt aSelectorOop)
{
    CogMethod *cogMethod;
    sqInt selector;

	assert(!((methodHasCogMethod(aMethodObj))));

	/* coInterpreter stringOf: selector */
	selector = (aSelectorOop == (nilObject())
		? maybeSelectorOfMethod(aMethodObj)
		: aSelectorOop);
	if (!(selector == null)) {
		compilationBreakpointisMNUCase(selector, 0);
	}
	if (aMethodObj == breakMethod) {
		haltmsg("Compilation of breakMethod");
	}
	ensureNoForwardedLiteralsIn(aMethodObj);
	if (methodUsesAlternateBytecodeSet(aMethodObj)) {
		if ((numElementsIn(generatorTable)) <= 0x100) {
			return null;
		}
		bytecodeSetOffset = 0x100;
	}
	else {
		bytecodeSetOffset = 0;
	}
	assert(!((isFullBlockMethod(aMethodObj))));
	methodObj = aMethodObj;
	methodHeader = methodHeaderOf(aMethodObj);

	/* lazy initialization */
	receiverTags = -1;
	cogMethod = compileCogMethod(aSelectorOop);
	if ((((((sqInt)cogMethod)) >= MaxNegativeErrorCode) && ((((sqInt)cogMethod)) <= -1))) {
		if ((((sqInt)cogMethod)) == InsufficientCodeSpace) {
			callForCogCompiledCodeCompaction();
		}
		return null;
	}
	return cogMethod;
}

	/* Cogit>>#collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method: */
static sqInt NoDbgRegParms
collectCogConstituentForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg)
{
    sqInt address;
    sqInt annotation;
    sqInt entryPoint;
    sqInt offset1;
    sqInt *sendTable1;
    CogMethod *targetMethod1;

	if (!descriptor) {
		return 0;
	}
	if (!((descriptor->isMapped))) {
		return 0;
	}
	/* begin positiveMachineIntegerFor: */
	address = positive64BitIntegerFor(((usqInt)mcpc));
	if (!address) {
		return PrimErrNoMemory;
	}
	storePointerUncheckedofObjectwithValue(cogConstituentIndex, topRemappableOop(), address);
	storePointerUncheckedofObjectwithValue(cogConstituentIndex + 1, topRemappableOop(), (((usqInt)bcpc << 3) | 1));

	/* Collect any first case classTags for closed PICs. */
	cogConstituentIndex += 2;
	if (((!(isBackwardBranchAndAnnotation & 1)))
	 && (((((usqInt)(isBackwardBranchAndAnnotation)) >> 1) >= IsSendCall))) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* send is linked */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			annotation = ((usqInt)(isBackwardBranchAndAnnotation)) >> 1;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (((targetMethod1->cmType)) == CMClosedPIC) {
				(targetMethod1->methodObject = classForInlineCacheTag(literal32BeforeFollowingAddress(backEnd, ((usqInt)((((sqInt)mcpc)) - 5)))));
			}
		}
	}
	return 0;
}


/*	Answer a description of the mapping between machine code pointers and
	bytecode pointers for the Cog Method.
	First value is the address of the cog method.
	Following values are pairs of machine code pc and bytecode pc */

	/* Cogit>>#collectCogMethodConstituent: */
static sqInt NoDbgRegParms
collectCogMethodConstituent(CogMethod *cogMethod)
{
    sqInt address;
    sqInt aMethodHeader;
    sqInt aMethodHeader1;
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    CogBlockMethod *cogBlockMethod;
    sqInt data;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    sqInt errCode;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    usqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt nSlots;
    sqInt result;
    sqInt startbcpc;
    sqInt targetPC;

	latestContinuation = 0;
	if (!(((cogMethod->cmType)) >= CMMethod)) {
		/* begin positiveMachineIntegerFor: */
		return positive64BitIntegerFor(((usqInt)cogMethod));
	}
	cogBlockMethod = ((CogBlockMethod *) cogMethod);
	if (((cogBlockMethod->stackCheckOffset)) == 0) {

		/* isFrameless ? */
		/* begin positiveMachineIntegerFor: */
		return positive64BitIntegerFor(((usqInt)cogMethod));
	}

	/* +1 for first address */
	nSlots = ((((byteSizeOf((cogMethod->methodObject))) - (startPCOfMethodHeader((cogMethod->methodHeader)))) * 2) + (minSlotsForShortening())) + 1;
	data = instantiateClassindexableSize(splObj(ClassArray), nSlots);
	if (!data) {
		return null;
	}
	pushRemappableOop(data);
	/* begin positiveMachineIntegerFor: */
	address = positive64BitIntegerFor(((usqInt)cogMethod));
	if (!address) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(0, topRemappableOop(), address);
	cogConstituentIndex = 1;
	/* begin mapFor:bcpc:performUntil:arg: */
	startbcpc = startPCOfMethod((cogMethod->methodObject));
	assert(((cogBlockMethod->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)cogBlockMethod)) + ((cogBlockMethod->stackCheckOffset));
	result = collectCogConstituentForAnnotationMcpcBcpcMethod(null, (0 + (((sqInt)((usqInt)(HasBytecodePC) << 1)))), (((char *) mcpc)), startbcpc, (((void *)cogMethod)));
	if (result != 0) {
		errCode = result;
		goto l12;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if (((cogBlockMethod->cmType)) >= CMMethod) {
		/* begin cmIsFullBlock */
		isInBlock = (cogBlockMethod->cpicHasMNUCaseOrCMIsFullBlock);
		homeMethod = ((CogMethod *) cogBlockMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		/* begin mapStartFor: */
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader = (homeMethod->methodHeader);
		bsOffset = (headerIndicatesAlternateBytecodeSet(aMethodHeader)
						? 0x100
						: 0);
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == ((cogBlockMethod->startpc)));
		homeMethod = cmHomeMethod(cogBlockMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogBlockMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - ((headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
		? AltBlockCreationBytecodeSize
		: BlockCreationBytecodeSize));
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader1 = (homeMethod->methodHeader);
		bsOffset = (headerIndicatesAlternateBytecodeSet(aMethodHeader1)
						? 0x100
						: 0);
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		/* begin nextBytecodePCFor:at:exts:in: */
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj))
	: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	enumeratingCogMethod = homeMethod;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask);
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							errCode = 0;
							goto l12;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							errCode = 0;
							goto l12;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					/* begin nextBytecodePCFor:at:exts:in: */
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj))
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && ((assert(((descriptor->spanFunction)) != null),
				(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = collectCogConstituentForAnnotationMcpcBcpcMethod(descriptor, ((isBackwardBranch
	? (((sqInt)((usqInt)(annotation) << 1))) + 1
	: ((sqInt)((usqInt)(annotation) << 1)))), (((char *) mcpc)), ((isBackwardBranch
	? bcpc - (2 * nExts)
	: bcpc)), (((void *)cogMethod)));
				if (result != 0) {
					errCode = result;
					goto l12;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
			}
		}
		map -= 1;
	}
	errCode = 0;
	l12:	/* end mapFor:bcpc:performUntil:arg: */;
	if (errCode != 0) {
		popRemappableOop();
		return null;
	}
	if (cogConstituentIndex < nSlots) {
		shortentoIndexableSize(topRemappableOop(), cogConstituentIndex);
	}
	return popRemappableOop();
}

	/* Cogit>>#compactCogCompiledCode */
void
compactCogCompiledCode(void)
{
	assertValidDualZone();
	assert(noCogMethodsMaximallyMarked());
	moveProfileToMethods();
	/* begin ensureWritableCodeZone */
	markActiveMethodsAndReferents();
	freeOlderMethodsForCompaction();
	compactPICsWithFreedTargets();
	planCompaction();
	updateStackZoneReferencesToCompiledCodePreCompaction();
	relocateMethodsPreCompaction();
	assertValidDualZone();
	compactCompiledCode();
	stopsFromto(backEnd, freeStart(), (youngReferrers()) - 1);
	flushICacheFromto(backEnd, ((usqInt)methodZoneBase), ((usqInt)(youngReferrers())));
	assert(allMethodsHaveCorrectHeader());
	assert(kosherYoungReferrers());
	assertValidDualZone();
}

	/* Cogit>>#compactPICsWithFreedTargets */
static void
compactPICsWithFreedTargets(void)
{
    CogMethod *cogMethod;
    sqInt count;

	cogMethod = ((CogMethod *) methodZoneBase);
	count = 0;
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) == CMClosedPIC)
		 && (cPICCompactAndIsNowEmpty(cogMethod))) {
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMFree);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		count += 1;
	}
	assert(count == (numMethods()));
}


/*	The start of a CogMethod has a call to a run-time abort routine that
	either handles an in-line cache failure or a stack overflow. The routine
	selects the
	path depending on ReceiverResultReg; if zero it takes the stack overflow
	path; if nonzero the in-line cache miss path. Neither of these paths
	returns. The abort routine must be called; In the callee the method is
	located by
	adding the relevant offset to the return address of the call.
	
	N.B. This code must match that in compilePICAbort: so that the offset of
	the return address of the call is the same in methods and closed PICs. */

	/* Cogit>>#compileAbort */
static AbstractInstruction *
compileAbort(void)
{
	/* begin MoveCq:R: */
	stackOverflowCall = genoperandoperand(MoveCqR, 0, ReceiverResultReg);
	return (sendMiss = gCall(methodAbortTrampolineFor(methodOrBlockNumArgs)));
}

	/* Cogit>>#compileBlockDispatchFrom:to: */
static sqInt NoDbgRegParms
compileBlockDispatchFromto(sqInt lowBlockStartIndex, sqInt highBlockStartIndex)
{
    BlockStart *blockStart;
    sqInt halfWay;
    AbstractInstruction *jmp;
    void *jumpTarget;
    void *jumpTarget1;
    void *jumpTarget2;
    sqInt quickConstant;

	if (lowBlockStartIndex == highBlockStartIndex) {
		blockStart = blockStartAt(lowBlockStartIndex);
		/* begin Jump: */
		jumpTarget = (blockStart->entryLabel);
		genoperand(Jump, ((sqInt)jumpTarget));
		return null;
	}
	halfWay = (highBlockStartIndex + lowBlockStartIndex) / 2;
	assert(((halfWay >= lowBlockStartIndex) && (halfWay <= highBlockStartIndex)));

	/* N.B. FLAGS := TempReg - startpc */
	blockStart = blockStartAt(halfWay);
	/* begin CmpCq:R: */
	quickConstant = (((usqInt)(((blockStart->startpc)) + 1) << 3) | 1);
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (lowBlockStartIndex == halfWay) {
		/* begin JumpLessOrEqual: */
		jumpTarget1 = (blockStart->entryLabel);
		genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)jumpTarget1));
		compileBlockDispatchFromto(halfWay + 1, highBlockStartIndex);
		return null;
	}
	if ((halfWay + 1) == highBlockStartIndex) {
		blockStart = blockStartAt(highBlockStartIndex);
		/* begin JumpGreater: */
		jumpTarget2 = (blockStart->entryLabel);
		genConditionalBranchoperand(JumpGreater, ((sqInt)jumpTarget2));
		return compileBlockDispatchFromto(lowBlockStartIndex, halfWay);
	}
	/* begin JumpGreater: */
	jmp = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	compileBlockDispatchFromto(lowBlockStartIndex, halfWay);
	if (halfWay == highBlockStartIndex) {
		blockStart = blockStartAt(highBlockStartIndex);
		jmpTarget(jmp, (blockStart->entryLabel));
	}
	else {
		jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileBlockDispatchFromto(halfWay + 1, highBlockStartIndex);
	}
	return 0;
}


/*	Compile a block's entry. This looks like a dummy CogBlockMethod header
	(for frame parsing)
	followed by either a frame build, if a frame is required, or nothing. The
	CogMethodHeader's objectHeader field is a back pointer to the method, but
	this can't be filled in until code generation. */

	/* Cogit>>#compileBlockEntry: */
static void NoDbgRegParms
compileBlockEntry(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    sqInt alignment;

	/* begin AlignmentNops: */
	alignment = blockAlignment();
	genoperand(AlignmentNops, alignment);
	(blockStart->fakeHeader = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	switch (sizeof(CogBlockMethod)) {
	case 8:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		break;
	case 12:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		break;
	case 16:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	(blockStart->entryLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (needsFrame) {
		compileBlockFrameBuild(blockStart);
		if (recordBlockTrace()) {
			/* begin CallRT: */
			
			abstractInstruction = genoperand(Call, ceTraceBlockActivationTrampoline);
			(abstractInstruction->annotation = IsRelativeCall);
		}
	}
	else {
		compileBlockFramelessEntry(blockStart);
	}
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. The encoding for constants is defined by
	trampolineArgConstant: & trampolineArgValue:. Pass a constant as the
	result of trampolineArgConstant:. */

	/* Cogit>>#compileCallFor:numArgs:arg:arg:arg:arg:floatResultReg:regsToSave: */
static void NoDbgRegParms
compileCallFornumArgsargargargargfloatResultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask)
{
    AbstractInstruction *anInstruction;
    sqInt delta;
    sqInt numRegsPushed;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    usqInt regMaskCopy;
    sqInt regsToSave;
    sqInt wordsPushedModAlignment;

	regsToSave = (resultRegOrNone == NoReg
		? regMask
		: ((regMask | (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))) - (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))));
	if (cStackAlignment > BytesPerWord) {
		/* begin genAlignCStackSavingRegisters:numArgs:wordAlignment: */
		regMaskCopy = ((usqInt)regsToSave);
		numRegsPushed = 0;
		while (regMaskCopy != 0) {
			numRegsPushed += regMaskCopy & 1;
			regMaskCopy = ((regMaskCopy) >> 1);
		}
		if ((numRegsPushed == 0)
		 && ((numIntRegArgs(((AbstractInstruction *) backEnd))) >= numArgs)) {
			goto l6;
		}
		wordsPushedModAlignment = (numRegsPushed + ((((numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd)))) < 0) ? 0 : (numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd))))))) % (cStackAlignment / BytesPerWord);
		if (wordsPushedModAlignment != 0) {
			delta = (cStackAlignment / BytesPerWord) - wordsPushedModAlignment;
			/* begin SubCq:R: */
			
			delta * BytesPerWord;
			anInstruction = genoperandoperand(SubCqR, delta * BytesPerWord, SPReg);
		}
	l6:	/* end genAlignCStackSavingRegisters:numArgs:wordAlignment: */;
	}
	genSaveRegs(backEnd, regsToSave);
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	assert(numArgs <= 4);
	if (numArgs > 0) {
		if (regOrConst0 < NoReg) {
			/* begin MoveCq:R: */
			quickConstant = -2 - regOrConst0;
			genoperandoperand(MoveCqR, quickConstant, CArg0Reg);
		}
		else {
			if (regOrConst0 != CArg0Reg) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, regOrConst0, CArg0Reg);
			}
		}
		if (numArgs > 1) {
			if (regOrConst1 < NoReg) {
				/* begin MoveCq:R: */
				quickConstant1 = -2 - regOrConst1;
				genoperandoperand(MoveCqR, quickConstant1, CArg1Reg);
			}
			else {
				if (regOrConst1 != CArg1Reg) {
					/* begin MoveR:R: */
					genoperandoperand(MoveRR, regOrConst1, CArg1Reg);
				}
			}
			if (numArgs > 2) {
				if (regOrConst2 < NoReg) {
					/* begin MoveCq:R: */
					quickConstant2 = -2 - regOrConst2;
					genoperandoperand(MoveCqR, quickConstant2, CArg2Reg);
				}
				else {
					if (regOrConst2 != CArg2Reg) {
						/* begin MoveR:R: */
						genoperandoperand(MoveRR, regOrConst2, CArg2Reg);
					}
				}
				if (numArgs > 3) {
					if (regOrConst3 < NoReg) {
						/* begin MoveCq:R: */
						quickConstant3 = -2 - regOrConst3;
						genoperandoperand(MoveCqR, quickConstant3, CArg3Reg);
					}
					else {
						if (regOrConst3 != CArg3Reg) {
							/* begin MoveR:R: */
							genoperandoperand(MoveRR, regOrConst3, CArg3Reg);
						}
					}
				}
			}
		}
	}
	/* begin CallFullRT: */
	/* begin CallFull: */
	genoperand(CallFull, ((usqInt)aRoutine));
	if (resultRegOrNone != NoReg) {
		cFloatResultToRd(backEnd, resultRegOrNone);
	}
	/* begin genRemoveNArgsFromStack: */
	assert(numArgs <= 4);
	genRestoreRegs(backEnd, regsToSave);
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. The encoding for constants is defined by
	trampolineArgConstant: & trampolineArgValue:. Pass a constant as the
	result of trampolineArgConstant:. */

	/* Cogit>>#compileCallFor:numArgs:arg:arg:arg:arg:resultReg:regsToSave: */
static void NoDbgRegParms
compileCallFornumArgsargargargargresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask)
{
    AbstractInstruction *anInstruction;
    sqInt delta;
    sqInt numRegsPushed;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    usqInt regMaskCopy;
    sqInt regsToSave;
    sqInt wordsPushedModAlignment;

	regsToSave = (resultRegOrNone == NoReg
		? regMask
		: ((regMask | (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))) - (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))));
	if (cStackAlignment > BytesPerWord) {
		/* begin genAlignCStackSavingRegisters:numArgs:wordAlignment: */
		regMaskCopy = ((usqInt)regsToSave);
		numRegsPushed = 0;
		while (regMaskCopy != 0) {
			numRegsPushed += regMaskCopy & 1;
			regMaskCopy = ((regMaskCopy) >> 1);
		}
		if ((numRegsPushed == 0)
		 && ((numIntRegArgs(((AbstractInstruction *) backEnd))) >= numArgs)) {
			goto l6;
		}
		wordsPushedModAlignment = (numRegsPushed + ((((numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd)))) < 0) ? 0 : (numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd))))))) % (cStackAlignment / BytesPerWord);
		if (wordsPushedModAlignment != 0) {
			delta = (cStackAlignment / BytesPerWord) - wordsPushedModAlignment;
			/* begin SubCq:R: */
			
			delta * BytesPerWord;
			anInstruction = genoperandoperand(SubCqR, delta * BytesPerWord, SPReg);
		}
	l6:	/* end genAlignCStackSavingRegisters:numArgs:wordAlignment: */;
	}
	genSaveRegs(backEnd, regsToSave);
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	assert(numArgs <= 4);
	if (numArgs > 0) {
		if (regOrConst0 < NoReg) {
			/* begin MoveCq:R: */
			quickConstant = -2 - regOrConst0;
			genoperandoperand(MoveCqR, quickConstant, CArg0Reg);
		}
		else {
			if (regOrConst0 != CArg0Reg) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, regOrConst0, CArg0Reg);
			}
		}
		if (numArgs > 1) {
			if (regOrConst1 < NoReg) {
				/* begin MoveCq:R: */
				quickConstant1 = -2 - regOrConst1;
				genoperandoperand(MoveCqR, quickConstant1, CArg1Reg);
			}
			else {
				if (regOrConst1 != CArg1Reg) {
					/* begin MoveR:R: */
					genoperandoperand(MoveRR, regOrConst1, CArg1Reg);
				}
			}
			if (numArgs > 2) {
				if (regOrConst2 < NoReg) {
					/* begin MoveCq:R: */
					quickConstant2 = -2 - regOrConst2;
					genoperandoperand(MoveCqR, quickConstant2, CArg2Reg);
				}
				else {
					if (regOrConst2 != CArg2Reg) {
						/* begin MoveR:R: */
						genoperandoperand(MoveRR, regOrConst2, CArg2Reg);
					}
				}
				if (numArgs > 3) {
					if (regOrConst3 < NoReg) {
						/* begin MoveCq:R: */
						quickConstant3 = -2 - regOrConst3;
						genoperandoperand(MoveCqR, quickConstant3, CArg3Reg);
					}
					else {
						if (regOrConst3 != CArg3Reg) {
							/* begin MoveR:R: */
							genoperandoperand(MoveRR, regOrConst3, CArg3Reg);
						}
					}
				}
			}
		}
	}
	/* begin CallFullRT: */
	/* begin CallFull: */
	genoperand(CallFull, ((usqInt)aRoutine));
	genWriteCResultIntoReg(backEnd, resultRegOrNone);
	/* begin genRemoveNArgsFromStack: */
	assert(numArgs <= 4);
	genRestoreRegs(backEnd, regsToSave);
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. The encoding for constants is defined by
	trampolineArgConstant: & trampolineArgValue:. Pass a constant as the
	result of trampolineArgConstant:. */

	/* Cogit>>#compileCallFor:numArgs:arg:arg:arg:arg:resultReg:resultReg:regsToSave: */
static void NoDbgRegParms
compileCallFornumArgsargargargargresultRegresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt resultReg2OrNone, sqInt regMask)
{
    AbstractInstruction *anInstruction;
    sqInt delta;
    sqInt numRegsPushed;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    usqInt regMaskCopy;
    sqInt regsToSave;
    sqInt wordsPushedModAlignment;

	regsToSave = (resultRegOrNone == NoReg
		? regMask
		: ((regMask | (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))) - (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))));
	if (cStackAlignment > BytesPerWord) {
		/* begin genAlignCStackSavingRegisters:numArgs:wordAlignment: */
		regMaskCopy = ((usqInt)regsToSave);
		numRegsPushed = 0;
		while (regMaskCopy != 0) {
			numRegsPushed += regMaskCopy & 1;
			regMaskCopy = ((regMaskCopy) >> 1);
		}
		if ((numRegsPushed == 0)
		 && ((numIntRegArgs(((AbstractInstruction *) backEnd))) >= numArgs)) {
			goto l6;
		}
		wordsPushedModAlignment = (numRegsPushed + ((((numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd)))) < 0) ? 0 : (numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd))))))) % (cStackAlignment / BytesPerWord);
		if (wordsPushedModAlignment != 0) {
			delta = (cStackAlignment / BytesPerWord) - wordsPushedModAlignment;
			/* begin SubCq:R: */
			
			delta * BytesPerWord;
			anInstruction = genoperandoperand(SubCqR, delta * BytesPerWord, SPReg);
		}
	l6:	/* end genAlignCStackSavingRegisters:numArgs:wordAlignment: */;
	}
	genSaveRegs(backEnd, regsToSave);
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	assert(numArgs <= 4);
	if (numArgs > 0) {
		if (regOrConst0 < NoReg) {
			/* begin MoveCq:R: */
			quickConstant = -2 - regOrConst0;
			genoperandoperand(MoveCqR, quickConstant, CArg0Reg);
		}
		else {
			if (regOrConst0 != CArg0Reg) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, regOrConst0, CArg0Reg);
			}
		}
		if (numArgs > 1) {
			if (regOrConst1 < NoReg) {
				/* begin MoveCq:R: */
				quickConstant1 = -2 - regOrConst1;
				genoperandoperand(MoveCqR, quickConstant1, CArg1Reg);
			}
			else {
				if (regOrConst1 != CArg1Reg) {
					/* begin MoveR:R: */
					genoperandoperand(MoveRR, regOrConst1, CArg1Reg);
				}
			}
			if (numArgs > 2) {
				if (regOrConst2 < NoReg) {
					/* begin MoveCq:R: */
					quickConstant2 = -2 - regOrConst2;
					genoperandoperand(MoveCqR, quickConstant2, CArg2Reg);
				}
				else {
					if (regOrConst2 != CArg2Reg) {
						/* begin MoveR:R: */
						genoperandoperand(MoveRR, regOrConst2, CArg2Reg);
					}
				}
				if (numArgs > 3) {
					if (regOrConst3 < NoReg) {
						/* begin MoveCq:R: */
						quickConstant3 = -2 - regOrConst3;
						genoperandoperand(MoveCqR, quickConstant3, CArg3Reg);
					}
					else {
						if (regOrConst3 != CArg3Reg) {
							/* begin MoveR:R: */
							genoperandoperand(MoveRR, regOrConst3, CArg3Reg);
						}
					}
				}
			}
		}
	}
	/* begin CallFullRT: */
	/* begin CallFull: */
	genoperand(CallFull, ((usqInt)aRoutine));
	genWriteCResultIntoReg(backEnd, resultRegOrNone);
	genWriteCSecondResultIntoReg(backEnd, resultReg2OrNone);
	/* begin genRemoveNArgsFromStack: */
	assert(numArgs <= 4);
	genRestoreRegs(backEnd, regsToSave);
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. */

	/* Cogit>>#compileCallFor:numArgs:floatArg:floatArg:floatArg:floatArg:resultReg:regsToSave: */
static void NoDbgRegParms
compileCallFornumArgsfloatArgfloatArgfloatArgfloatArgresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask)
{
    AbstractInstruction *anInstruction;
    double constantFloat64;
    double constantFloat641;
    double constantFloat642;
    double constantFloat643;
    sqInt delta;
    AbstractInstruction *inst;
    AbstractInstruction *inst1;
    AbstractInstruction *inst11;
    AbstractInstruction *inst12;
    AbstractInstruction *inst13;
    AbstractInstruction *inst2;
    AbstractInstruction *inst3;
    AbstractInstruction *inst4;
    sqInt numRegsPushed;
    usqInt regMaskCopy;
    sqInt regsToSave;
    sqInt wordConstant;
    sqInt wordConstant1;
    sqInt wordConstant2;
    sqInt wordConstant3;
    sqInt wordsPushedModAlignment;

	regsToSave = (resultRegOrNone == NoReg
		? regMask
		: ((regMask | (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))) - (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))));
	if (cStackAlignment > BytesPerWord) {
		/* begin genAlignCStackSavingRegisters:numArgs:wordAlignment: */
		regMaskCopy = ((usqInt)regsToSave);
		numRegsPushed = 0;
		while (regMaskCopy != 0) {
			numRegsPushed += regMaskCopy & 1;
			regMaskCopy = ((regMaskCopy) >> 1);
		}
		if ((numRegsPushed == 0)
		 && ((numIntRegArgs(((AbstractInstruction *) backEnd))) >= numArgs)) {
			goto l6;
		}
		wordsPushedModAlignment = (numRegsPushed + ((((numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd)))) < 0) ? 0 : (numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd))))))) % (cStackAlignment / BytesPerWord);
		if (wordsPushedModAlignment != 0) {
			delta = (cStackAlignment / BytesPerWord) - wordsPushedModAlignment;
			/* begin SubCq:R: */
			
			delta * BytesPerWord;
			anInstruction = genoperandoperand(SubCqR, delta * BytesPerWord, SPReg);
		}
	l6:	/* end genAlignCStackSavingRegisters:numArgs:wordAlignment: */;
	}
	genSaveRegs(backEnd, regsToSave);
	/* begin genMarshallNArgs:floatArg:floatArg:floatArg:floatArg: */
	if (numArgs == 0) {
		goto l32;
	}
	if (regOrConst0 < NoReg) {
		/* begin genMoveCf64:Rd: */
		constantFloat64 = -2 - regOrConst0;
		/* begin PushCw: */
		wordConstant = asIEEE64BitWord(constantFloat64);
		inst = genoperand(PushCw, wordConstant);
		/* begin genPopRd: */
		
		inst1 = genoperandoperandoperand(MoveM64rRd, 0, SPReg, XMM0L);
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 8, SPReg);
	}
	else {
		if (regOrConst0 != XMM0L) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst0, XMM0L);
		}
	}
	if (numArgs == 1) {
		goto l32;
	}
	if (regOrConst1 < NoReg) {
		/* begin genMoveCf64:Rd: */
		constantFloat641 = -2 - regOrConst1;
		/* begin PushCw: */
		wordConstant1 = asIEEE64BitWord(constantFloat641);
		inst2 = genoperand(PushCw, wordConstant1);
		/* begin genPopRd: */
		
		inst11 = genoperandoperandoperand(MoveM64rRd, 0, SPReg, XMM1L);
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 8, SPReg);
	}
	else {
		if (regOrConst1 != XMM1L) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst1, XMM1L);
		}
	}
	if (numArgs == 2) {
		goto l32;
	}
	if (regOrConst2 < NoReg) {
		/* begin genMoveCf64:Rd: */
		constantFloat642 = -2 - regOrConst2;
		/* begin PushCw: */
		wordConstant2 = asIEEE64BitWord(constantFloat642);
		inst3 = genoperand(PushCw, wordConstant2);
		/* begin genPopRd: */
		
		inst12 = genoperandoperandoperand(MoveM64rRd, 0, SPReg, XMM2L);
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 8, SPReg);
	}
	else {
		if (regOrConst2 != XMM2L) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst2, XMM2L);
		}
	}
	if (numArgs == 3) {
		goto l32;
	}
	if (regOrConst3 < NoReg) {
		/* begin genMoveCf64:Rd: */
		constantFloat643 = -2 - regOrConst3;
		/* begin PushCw: */
		wordConstant3 = asIEEE64BitWord(constantFloat643);
		inst4 = genoperand(PushCw, wordConstant3);
		/* begin genPopRd: */
		
		inst13 = genoperandoperandoperand(MoveM64rRd, 0, SPReg, XMM3L);
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 8, SPReg);
	}
	else {
		if (regOrConst3 != XMM3L) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst3, XMM3L);
		}
	}
	assert(numArgs <= 4);
	l32:	/* end genMarshallNArgs:floatArg:floatArg:floatArg:floatArg: */;
	/* begin CallFullRT: */
	/* begin CallFull: */
	genoperand(CallFull, ((usqInt)aRoutine));
	genWriteCResultIntoReg(backEnd, resultRegOrNone);
	/* begin genRemoveNFloatArgsFromStack: */
	assert(numArgs <= 4);
	genRestoreRegs(backEnd, regsToSave);
}


/*	Compile the cache tag computation and the first comparison. Answer the
	address of that comparison. */

	/* Cogit>>#compileCPICEntry */
static AbstractInstruction *
compileCPICEntry(void)
{
	entry = genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, TempReg, 1);
	/* begin CmpR:R: */
	assert(!((ClassReg == SPReg)));
	genoperandoperand(CmpRR, ClassReg, TempReg);
	/* begin JumpNonZero: */
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}


/*	Compile the abstract instructions for the entire full block method. */

	/* Cogit>>#compileEntireFullBlockMethod: */
static sqInt NoDbgRegParms
compileEntireFullBlockMethod(sqInt numCopied)
{
    sqInt result;

	/* begin preenMethodLabel */
	((methodLabel->operands))[1] = 0;
	compileFullBlockEntry();
	compileFullBlockMethodFrameBuild(numCopied);
	if (((result = compileMethodBody())) < 0) {
		return result;
	}
	assert(blockCount == 0);
	return 0;
}


/*	The entry code to a method checks that the class of the current receiver
	matches that in the inline cache. Other non-obvious elements are that its
	alignment must be
	different from the alignment of the noCheckEntry so that the method map
	machinery can distinguish normal and super sends (super sends bind to the
	noCheckEntry).  */

	/* Cogit>>#compileEntry */
static void
compileEntry(void)
{
	entry = genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, TempReg, 1);
	/* begin CmpR:R: */
	assert(!((ClassReg == SPReg)));
	genoperandoperand(CmpRR, ClassReg, TempReg);
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)sendMiss));
	/* begin Label */
	noCheckEntry = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (((traceFlags & 64) == 64)) {
		/* begin saveAndRestoreLinkRegAround: */
		/* begin CallFullRT: */
		/* begin CallFull: */
		genoperand(CallFull, ceTraceLinkedSendTrampoline);
	}
}


/*	Compile the abstract instructions for the entire method, including blocks. */
/*	Abort for stack overflow on full block activation (no inline cache miss
	possible). The flag is SendNumArgsReg. */

	/* Cogit>>#compileFullBlockEntry */
static sqInt
compileFullBlockEntry(void)
{
    sqInt callTarget;
    AbstractInstruction *jumpNoContextSwitch;

	/* begin MoveCq:R: */
	stackOverflowCall = genoperandoperand(MoveCqR, 0, ReceiverResultReg);
	/* begin Call: */
	callTarget = methodAbortTrampolineFor(methodOrBlockNumArgs);
	genoperand(Call, callTarget);
	/* begin MoveCq:R: */
	fullBlockNoContextSwitchEntry = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
	/* begin Jump: */
	jumpNoContextSwitch = genoperand(Jump, ((sqInt)0));
	/* begin AlignmentNops: */
	genoperand(AlignmentNops, ((BytesPerWord < 8) ? 8 : BytesPerWord));
	/* begin MoveR:R: */
	fullBlockEntry = genoperandoperand(MoveRR, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jumpNoContextSwitch, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	Compile the top-level method body. */

	/* Cogit>>#compileMethodBody */
static sqInt
compileMethodBody(void)
{
	if (endPC < initialPC) {
		return 0;
	}
	return compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
}


/*	The start of a PIC has a call to a run-time abort routine that either
	handles a dispatch to an
	interpreted method or a dispatch of an MNU case. The routine selects the
	path by testing
	ClassReg, which holds the inline cache tag; if equal to the
	picAbortDiscriminatorValue (zero)
	it takes the MNU path; if nonzero the dispatch to interpreter path.
	Neither of these paths
	returns. The abort routine must be called; In the callee the PIC is
	located by adding the
	relevant offset to the return address of the call.
	
	N.B. This code must match that in compileAbort so that the offset of the
	return address of
	the call is the same in methods and closed PICs. */

	/* Cogit>>#compilePICAbort: */
static sqInt NoDbgRegParms
compilePICAbort(sqInt numArgs)
{
    sqInt callTarget1;
    sqInt quickConstant;

	/* begin MoveCq:R: */
	quickConstant = 0 /* picAbortDiscriminatorValue */;
	picMNUAbort = genoperandoperand(MoveCqR, quickConstant, ClassReg);
	/* begin Call: */
	callTarget1 = picAbortTrampolineFor(numArgs);
	picInterpretAbort = genoperand(Call, callTarget1);
	return 0;
}


/*	Compile the compare of stackLimit against the stack pointer, jumping to
	the stackOverflowCall if
	the stack pointer is below the limit. Answer a bytecode annotated label
	that follows the sequence.
	
	The stack check functions both as a genuine stack limit check to prevent
	calls overflowing stack pages,
	and as an event/context-switch break out. To cause an event check
	(including a check for a required
	context switch), stackLimit is set to the highest possible value, and
	hence all stack limit checks will
	fail. A path in the stack overflow abort then arranges to call event
	checking if it has been requested.
	
	Certain block activations (e.g. valueNoContextSwitch:) must not context
	switch, and in that
	case, SendNumArgs is set to zero to communicate to the stack overflow
	abort that it should
	not perform event/context-switch (yet). */

	/* Cogit>>#compileStackOverflowCheck: */
static AbstractInstruction * NoDbgRegParms
compileStackOverflowCheck(sqInt canContextSwitch)
{
    sqInt address;
    AbstractInstruction *jumpSkip;
    AbstractInstruction *label;

	/* begin MoveAw:R: */
	address = stackLimitAddress();
	genoperandoperand(MoveAwR, address, TempReg);
	/* begin CmpR:R: */
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, SPReg);
	if (canContextSwitch) {
		/* begin JumpBelow: */
		genConditionalBranchoperand(JumpBelow, ((sqInt)stackOverflowCall));
		/* begin Label */
		label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	else {
		/* begin JumpAboveOrEqual: */
		jumpSkip = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, SendNumArgsReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)stackOverflowCall));
		jmpTarget(jumpSkip, (label = genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	}
	/* begin annotateBytecode: */
	(label->annotation = HasBytecodePC);
	return label;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:floatResultReg: */
static void NoDbgRegParms
compileTrampolineFornumArgsargargargargregsToSavepushLinkRegfloatResultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsargargargargfloatResultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, regMask);
	genLoadStackPointers(backEnd);
	genTrampolineReturn(pushLinkReg);
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg: */
static void NoDbgRegParms
compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsargargargargresultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, regMask);
	genLoadStackPointers(backEnd);
	genTrampolineReturn(pushLinkReg);
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg:resultReg: */
static void NoDbgRegParms
compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt resultReg2OrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsargargargargresultRegresultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, resultReg2OrNone, regMask);
	genLoadStackPointers(backEnd);
	genTrampolineReturn(pushLinkReg);
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:floatArg:floatArg:floatArg:floatArg:regsToSave:pushLinkReg:resultReg: */
static void NoDbgRegParms
compileTrampolineFornumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsfloatArgfloatArgfloatArgfloatArgresultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, regMask);
	genLoadStackPointers(backEnd);
	genTrampolineReturn(pushLinkReg);
}


/*	Generate the entry code for a method to determine cmEntryOffset and
	cmNoCheckEntryOffset. We
	need cmNoCheckEntryOffset up front to be able to generate the map starting
	from cmNoCheckEntryOffset */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#computeEntryOffsets */
static void
computeEntryOffsets(void)
{
    sqInt fixupSize;
    sqInt opcodeSize;
    AbstractInstruction *sendMissCall;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 24;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	methodOrBlockNumArgs = 0;
	sendMissCall = compileAbort();
	compileEntry();
	computeMaximumSizes();
	generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	cmEntryOffset = ((entry->address)) - methodZoneBase;
	cmNoCheckEntryOffset = ((noCheckEntry->address)) - methodZoneBase;
	missOffset = (((sendMissCall->address)) + ((sendMissCall->machineCodeSize))) - methodZoneBase;
	entryPointMask = BytesPerWord - 1;
	while ((cmEntryOffset & entryPointMask) == (cmNoCheckEntryOffset & entryPointMask)) {
		entryPointMask = (entryPointMask + entryPointMask) + 1;
	}
	if (entryPointMask >= (roundUpToMethodAlignment(backEnd(), 1))) {
		error("cannot differentiate checked and unchecked entry-points with current cog method alignment");
	}
	checkedEntryAlignment = cmEntryOffset & entryPointMask;
	uncheckedEntryAlignment = cmNoCheckEntryOffset & entryPointMask;
	assert(checkedEntryAlignment != uncheckedEntryAlignment);
}


/*	Generate the entry code for a method to determine cmEntryOffset and
	cmNoCheckEntryOffset. We
	need cmNoCheckEntryOffset up front to be able to generate the map starting
	from cmNoCheckEntryOffset */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#computeFullBlockEntryOffsets */
static void
computeFullBlockEntryOffsets(void)
{
    sqInt fixupSize;
    sqInt opcodeSize;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 24;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	methodOrBlockNumArgs = 0;
	compileFullBlockEntry();
	computeMaximumSizes();
	generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	cbEntryOffset = ((fullBlockEntry->address)) - methodZoneBase;
	cbNoSwitchEntryOffset = ((fullBlockNoContextSwitchEntry->address)) - methodZoneBase;
}


/*	While we order variables in the CoInterpreter in order of dynamic
	frequency, and hence
	expect that stackPointer will be output first, C optimizers and linkers
	may get their own
	ideas and ``improve upon'' this ordering. So we cannot depend on
	stackPointer being
	at the lowest address of the variables we want to access through
	VarBaseReg. Here we
	choose the minimum amongst a set to try to choose a varBaseAddress that is
	just less
	than but iwht in range of all variables we want to access through it. */

	/* Cogit>>#computeGoodVarBaseAddress */
static usqInt
computeGoodVarBaseAddress(void)
{
    usqInt minAddress;


	/* stackLimit is e.g. lowest using the clang toolchain on MacOS X */
	minAddress = stackLimitAddress();
	if ((stackPointerAddress()) < minAddress) {
		minAddress = stackPointerAddress();
	}
	if ((framePointerAddress()) < minAddress) {
		minAddress = framePointerAddress();
	}
	if ((instructionPointerAddress()) < minAddress) {
		minAddress = instructionPointerAddress();
	}
	if ((argumentCountAddress()) < minAddress) {
		minAddress = argumentCountAddress();
	}
	if ((primFailCodeAddress()) < minAddress) {
		minAddress = primFailCodeAddress();
	}
	return minAddress;
}


/*	This pass assigns maximum sizes to all abstract instructions and
	eliminates jump fixups.
	It hence assigns the maximum address an instruction will occur at which
	allows the next
	pass to conservatively size jumps. */

	/* Cogit>>#computeMaximumSizes */
static void
computeMaximumSizes(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt relativeAddress;

	relativeAddress = 0;
	for (i = 0; i < opcodeIndex; i += 1) {
		maybeBreakGeneratingInstructionWithIndex(i);
		abstractInstruction = abstractInstructionAt(i);
		(abstractInstruction->address = relativeAddress);
		(abstractInstruction->maxSize = computeMaximumSize(abstractInstruction));
		relativeAddress += (abstractInstruction->maxSize);
	}
}


/*	Configure a copy of the prototype CPIC for a two-case PIC for 
	case0CogMethod and
	case1Method
	case1Tag.
	The tag for case0CogMethod is at the send site and so doesn't need to be
	generated. case1Method may be any of
	- a Cog method; jump to its unchecked entry-point
	- a CompiledMethod; jump to the ceInterpretFromPIC trampoline
	- nil; call ceMNUFromPIC
	addDelta is the address change from the prototype to the new CPIC
	location, needed
	because the loading of the CPIC label at the end may use a literal instead
	of a pc relative load. */
/*	self disassembleFrom: cPIC asInteger + (self sizeof: CogMethod) to: cPIC
	asInteger + closedPICSize
 */

	/* Cogit>>#configureCPIC:Case0:Case1Method:tag:isMNUCase:numArgs:delta: */
static sqInt NoDbgRegParms
configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(CogMethod *cPIC, CogMethod *case0CogMethod, sqInt case1Method, sqInt case1Tag, sqInt isMNUCase, sqInt numArgs, sqInt addrDelta)
{
    sqInt caseEndAddress;
    sqInt jumpTargetAddr;
    sqInt operand;
    sqInt pc;
    sqInt targetEntry;

	assert(case1Method != null);
	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + missOffset, picAbortTrampolineFor(numArgs));
	assert(!(inlineCacheTagIsYoung(case1Tag)));
	if ((!isMNUCase)
	 && (methodHasCogMethod(case1Method))) {
		operand = 0;
		targetEntry = (((sqInt)(cogMethodOf(case1Method)))) + cmNoCheckEntryOffset;
	}
	else {

		/* We do not scavenge PICs, hence we cannot cache the MNU method if it is in new space. */
		operand = ((case1Method == null)
		 || (isYoungObject(case1Method))
			? 0
			: case1Method);
		targetEntry = (case1Method == null
			? (((sqInt)cPIC)) + (sizeof(CogMethod))
			: (((sqInt)cPIC)) + (picInterpretAbortOffset()));
	}
	/* begin rewriteJumpLongAt:target: */
	rewriteCallAttarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + firstCPICCaseOffset, (((sqInt)case0CogMethod)) + cmNoCheckEntryOffset);

	/* update the cpic case */
	caseEndAddress = addressOfEndOfCaseinCPIC(2, cPIC);
	rewriteCPICCaseAttagobjReftarget(caseEndAddress, case1Tag, operand, ((sqInt)((isMNUCase
	? (((sqInt)cPIC)) + (sizeof(CogMethod))
	: targetEntry))));
	/* begin relocateMethodReferenceBeforeAddress:by: */
	pc = ((((sqInt)cPIC)) + cPICEndOfCodeOffset) - (jumpLongByteSize(backEnd));
	assert((((byteAt(pc - 6)) == 141)
	 && (((byteAt(pc - 5)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7))))
	 || (((byteAt(pc - 8)) == 141)
	 && (((byteAt(pc - 7)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7)))));
	/* begin rewriteJumpLongAt:target: */
	jumpTargetAddr = cPICMissTrampolineFor(numArgs);
	rewriteCallAttarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + cPICEndOfCodeOffset, jumpTargetAddr);
	return 0;
}


/*	Configure a copy of the prototype CPIC for a one-case MNU CPIC that calls
	ceMNUFromPIC for
	case0Tag The tag for case0 is at the send site and so doesn't need to be
	generated. addDelta is the address change from the prototype to the new
	CPIC location, needed
	because the loading of the CPIC label at the end may be a literal instead
	of a pc-relative load. */
/*	adjust the jump at missOffset, the ceAbortXArgs */

	/* Cogit>>#configureMNUCPIC:methodOperand:numArgs:delta: */
static sqInt NoDbgRegParms
configureMNUCPICmethodOperandnumArgsdelta(CogMethod *cPIC, sqInt methodOperand, sqInt numArgs, sqInt addrDelta)
{
    sqInt jumpTargetAddr;
    sqInt jumpTargetAddr1;
    sqInt operand;
    sqInt pc;
    sqInt target;

	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + missOffset, picAbortTrampolineFor(numArgs));

	/* set the jump to the case0 method */
	operand = ((methodOperand == null)
	 || (isYoungObject(methodOperand))
		? 0
		: methodOperand);
	/* begin rewriteJumpLongAt:target: */
	jumpTargetAddr = (((sqInt)cPIC)) + (sizeof(CogMethod));
	rewriteCallAttarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + firstCPICCaseOffset, jumpTargetAddr);
	storeLiteralbeforeFollowingAddress(backEnd, operand, ((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd)));
	/* begin rewriteJumpLongAt:target: */
	jumpTargetAddr1 = cPICMissTrampolineFor(numArgs);
	rewriteCallAttarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + cPICEndOfCodeOffset, jumpTargetAddr1);
	/* begin relocateMethodReferenceBeforeAddress:by: */
	pc = ((((sqInt)cPIC)) + cPICEndOfCodeOffset) - (jumpLongByteSize(backEnd));
	assert((((byteAt(pc - 6)) == 141)
	 && (((byteAt(pc - 5)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7))))
	 || (((byteAt(pc - 8)) == 141)
	 && (((byteAt(pc - 7)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7)))));
	/* begin rewriteCPIC:caseJumpTo: */
	target = addressOfEndOfCaseinCPIC(2, cPIC);
	rewriteCPICJumpAttarget(backEnd, (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd)), target);
	return 0;
}


/*	Scan the CPIC for target methods that have been freed and eliminate them.
	Since the first entry cannot be eliminated, answer that the PIC should be
	freed if the first entry is to a free target. Answer if the PIC is now
	empty or should be freed. */

	/* Cogit>>#cPICCompactAndIsNowEmpty: */
static sqInt NoDbgRegParms
cPICCompactAndIsNowEmpty(CogMethod *cPIC)
{
    sqInt entryPoint;
    sqInt i;
    sqInt methods[MaxCPICCases];
    sqInt pc;
    int tags[MaxCPICCases];
    CogMethod *targetMethod;
    sqInt targets[MaxCPICCases];
    sqInt used;
    sqInt valid;

	used = 0;
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (i == 1) {
			entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		}
		else {
			/* begin jumpLongConditionalTargetBeforeFollowingAddress: */
			entryPoint = jumpLongTargetBeforeFollowingAddress(((AbstractInstruction *) backEnd), pc);
		}

		/* Collect all target triples except for triples whose entry-point is a freed method */
		valid = 1;
		if (!(((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
			 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint))))) {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
			 || (isCMFree(((CogBlockMethod *) targetMethod))));
			if (((targetMethod->cmType)) == CMFree) {
				if (i == 1) {
					return 1;
				}
				valid = 0;
			}
		}
		if (valid) {
			tags[used] = ((i > 1
	? literal32BeforeFollowingAddress(backEnd, pc - (jumpLongConditionalByteSize(backEnd)))
	: 0));
			targets[used] = entryPoint;
			methods[used] = (literalBeforeFollowingAddress(backEnd, pc - ((i == 1
	? jumpLongByteSize(backEnd)
	: (jumpLongConditionalByteSize(backEnd)) + (cmpC32RTempByteSize(backEnd))))));
			used += 1;
		}
	}
	if (used == ((cPIC->cPICNumCases))) {
		return 0;
	}
	if (used == 0) {
		return 1;
	}
	((((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta)))->cPICNumCases = used);
	if (used == 1) {
		pc = addressOfEndOfCaseinCPIC(2, cPIC);
		/* begin rewriteCPIC:caseJumpTo: */
		rewriteCPICJumpAttarget(backEnd, (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd)), pc);
		return 0;
	}
	for (i = 1; i < used; i += 1) {
		pc = addressOfEndOfCaseinCPIC(i + 1, cPIC);
		rewriteCPICCaseAttagobjReftarget(pc, tags[i], methods[i], targets[i]);
	}
	/* begin rewriteCPIC:caseJumpTo: */
	rewriteCPICJumpAttarget(backEnd, (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd)), pc - cPICCaseSize);
	return 0;
}


/*	The first case in a CPIC doesn't have a class reference so we need only
	step over actually usd subsequent cases.
 */

	/* Cogit>>#cPICHasForwardedClass: */
static sqInt NoDbgRegParms
cPICHasForwardedClass(CogMethod *cPIC)
{
    usqInt classIndex;
    sqInt i;
    sqInt pc;


	/* start by finding the address of the topmost case, the cPICNumCases'th one */
	pc = (addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC)) - (jumpLongConditionalByteSize(backEnd));
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		classIndex = literal32BeforeFollowingAddress(backEnd, pc);
		if (isForwardedClassIndex(classIndex)) {
			return 1;
		}
		pc += cPICCaseSize;
	}
	return 0;
}


/*	scan the CPIC for target methods that have been freed. */

	/* Cogit>>#cPICHasFreedTargets: */
static sqInt NoDbgRegParms
cPICHasFreedTargets(CogMethod *cPIC)
{
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    CogMethod *targetMethod;

	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (i == 1) {
			entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		}
		else {
			/* begin jumpLongConditionalTargetBeforeFollowingAddress: */
			entryPoint = jumpLongTargetBeforeFollowingAddress(((AbstractInstruction *) backEnd), pc);
		}
		if (!(((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
			 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint))))) {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
			 || (isCMFree(((CogBlockMethod *) targetMethod))));
			if (((targetMethod->cmType)) == CMFree) {
				return 1;
			}
		}
	}
	return 0;
}


/*	Whimsey; we want 16rCA5E10 + cPICPrototypeCaseOffset to be somewhere in
	the middle of the zone.
 */

	/* Cogit>>#cPICPrototypeCaseOffset */
static usqInt
cPICPrototypeCaseOffset(void)
{
	return ((methodZoneBase + (youngReferrers())) / 2) - 13262352;
}


/*	Are any of the jumps from this CPIC to targetMethod? */

	/* Cogit>>#cPIC:HasTarget: */
static sqInt NoDbgRegParms
cPICHasTarget(CogMethod *cPIC, CogMethod *targetMethod)
{
    sqInt i;
    sqInt pc;
    sqInt target;

	target = (((usqInt)targetMethod)) + cmNoCheckEntryOffset;

	/* Since this is a fast test doing simple compares we don't need to care that some
	   cases have nonsense addresses in there. Just zip on through. */
	/* First jump is unconditional; subsequent ones are conditional */
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	if (target == (jumpLongTargetBeforeFollowingAddress(backEnd, pc))) {
		return 1;
	}
	for (i = 2; i <= MaxCPICCases; i += 1) {
		pc += cPICCaseSize;
		if (target == (jumpLongTargetBeforeFollowingAddress(backEnd, pc))) {
			return 1;
		}
	}
	return 0;
}


/*	Answer an Array of the PIC's selector, followed by class and
	targetMethod/doesNotUnderstand: for each entry in the PIC.
 */

	/* Cogit>>#createCPICData: */
static sqInt NoDbgRegParms
createCPICData(CogMethod *cPIC)
{
    sqInt class;
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    sqInt picData;
    sqInt target;
    CogMethod *targetMethod;

	assert((((cPIC->methodObject)) == 0)
	 || (addressCouldBeOop((cPIC->methodObject))));
	picData = instantiateClassindexableSize(classArray(), (((cPIC->cPICNumCases)) * 2) + 1);
	if (!picData) {
		return picData;
	}
	storePointerUncheckedofObjectwithValue(0, picData, (cPIC->selector));
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (i == 1) {

			/* first case may have been collected and stored here by collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method: */
			class = (cPIC->methodObject);
			if (class == 0) {
				class = nilObject();
			}
			entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		}
		else {
			class = classForInlineCacheTag(literal32BeforeFollowingAddress(backEnd, pc - (jumpLongConditionalByteSize(backEnd))));
			/* begin jumpLongConditionalTargetBeforeFollowingAddress: */
			entryPoint = jumpLongTargetBeforeFollowingAddress(((AbstractInstruction *) backEnd), pc);
		}
		if (((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
		 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {
			target = splObj(SelectorDoesNotUnderstand);
		}
		else {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert(isCMMethodEtAl(((CogBlockMethod *) targetMethod)));
			target = (targetMethod->methodObject);
		}
		storePointerUncheckedofObjectwithValue((i * 2) - 1, picData, class);
		storePointerUncheckedofObjectwithValue(i * 2, picData, target);
	}
	beRootIfOld(picData);
	(cPIC->methodObject = 0);
	return picData;
}


/*	Division is a little weird on some processors. Defer to the backEnd
	to allow it to generate any special code it may need to. */

	/* Cogit>>#DivR:R:Quo:Rem: */
static AbstractInstruction * NoDbgRegParms
gDivRRQuoRem(sqInt rDivisor, sqInt rDividend, sqInt rQuotient, sqInt rRemainder)
{
	genDivRRQuoRem(backEnd, rDivisor, rDividend, rQuotient, rRemainder);
	return abstractInstructionAt(opcodeIndex - 1);
}


/*	Return the default number of bytes to allocate for native code at startup.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file. */

	/* Cogit>>#defaultCogCodeSize */
sqInt
defaultCogCodeSize(void)
{
	return 1433600;
}


/*	Answer the number of bytecodes to skip to get to the first bytecode
	past the primitive call and any store of the error code. */

	/* Cogit>>#deltaToSkipPrimAndErrorStoreIn:header: */
static sqInt NoDbgRegParms
deltaToSkipPrimAndErrorStoreInheader(sqInt aMethodObj, sqInt aMethodHeader)
{
	return (((primitiveIndexOfMethodheader(aMethodObj, aMethodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(aMethodHeader)) == (fetchByteofObject((startPCOfMethodHeader(aMethodHeader)) + (sizeOfCallPrimitiveBytecode(aMethodHeader)), aMethodObj)))
		? (sizeOfCallPrimitiveBytecode(aMethodHeader)) + (sizeOfLongStoreTempBytecode(aMethodHeader))
		: 0);
}

	/* Cogit>>#endPCOf: */
static sqInt NoDbgRegParms
endPCOf(sqInt aMethod)
{
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt end;
    sqInt latestContinuation;
    sqInt nExts;
    sqInt pc;
    sqInt prim;
    sqInt targetPC;

	pc = (latestContinuation = startPCOfMethod(aMethod));
	if (((prim = primitiveIndexOf(aMethod))) > 0) {
		if (isQuickPrimitiveIndex(prim)) {
			return pc - 1;
		}
	}
	/* begin bytecodeSetOffsetFor: */
	bsOffset = (methodUsesAlternateBytecodeSet(aMethod)
				? 0x100
				: 0);
	nExts = 0;
	end = numBytesOf(aMethod);
	while (pc <= end) {
		byte = fetchByteofObject(pc, aMethod);
		descriptor = generatorAt(byte + bsOffset);
		if (((descriptor->isReturn))
		 && (pc >= latestContinuation)) {
			end = pc;
		}
		if ((isBranch(descriptor))
		 || ((descriptor->isBlockCreation))) {
			/* begin spanFor:at:exts:in: */
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, aMethod);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
			if ((descriptor->isBlockCreation)) {
				pc += distance;
			}
		}
		else {
		}
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
		pc += (descriptor->numBytes);
	}
	return end;
}


/*	This is a static version of ceEnterCogCodePopReceiverReg for
	break-pointing when debugging in C. Marked <api> so the code generator
	won't delete it. */

	/* Cogit>>#enterCogCodePopReceiver */
static void
enterCogCodePopReceiver(void)
{
	realCEEnterCogCodePopReceiverReg();
	if (!Debug) {
		error("what??");
	}
}


/*	Answer if the entryPoint's tag is expected to be a selector reference, as
	opposed to a class tag.
 */

	/* Cogit>>#entryPointTagIsSelector: */
static sqInt NoDbgRegParms
entryPointTagIsSelector(sqInt entryPoint)
{
	return (entryPoint < methodZoneBase)
	 || (((entryPoint & entryPointMask) == uncheckedEntryAlignment)
	 || (((entryPoint & entryPointMask) == checkedEntryAlignment)
	 && ((((((CogMethod *) (entryPoint - cmEntryOffset)))->cmType)) == CMOpenPIC)));
}


/*	Use asserts to check if the ClosedPICPrototype is as expected from
	compileClosedPICPrototype, and can be updated as required via
	rewriteCPICCaseAt:tag:objRef:target:. If all asserts pass, answer
	0, otherwise answer a bit mask identifying all the errors. */
/*	self disassembleFrom: methodZoneBase + (self sizeof: CogMethod) to:
	methodZoneBase + closedPICSize
 */

	/* Cogit>>#expectedClosedPICPrototype: */
static sqInt NoDbgRegParms
expectedClosedPICPrototype(CogMethod *cPIC)
{
    usqInt classTag;
    sqInt classTagPC;
    sqInt entryPoint;
    sqInt errors;
    sqInt i;
    sqInt methodObjPC;
    sqInt object;
    sqInt pc;

	errors = 0;

	/* First jump is unconditional; subsequent ones are conditional */
	pc = (((usqInt)cPIC)) + firstCPICCaseOffset;
	object = literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)));
	if (!(asserta(object == (firstPrototypeMethodOop())))) {
		errors = 1;
	}
	entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
	if (!(asserta(entryPoint == ((cPICPrototypeCaseOffset()) + 13262352)))) {
		errors += 2;
	}
	for (i = 1; i < MaxCPICCases; i += 1) {

		/* verify information in case is as expected. */
		pc += cPICCaseSize;
		methodObjPC = (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd));
		object = literalBeforeFollowingAddress(backEnd, methodObjPC);
		if (!(asserta(object == ((subsequentPrototypeMethodOop()) + i)))) {
			errors = errors | 4;
		}
		classTagPC = pc - (jumpLongConditionalByteSize(backEnd));
		classTag = literal32BeforeFollowingAddress(backEnd, classTagPC);
		if (!(asserta(classTag == (0xBABE1F15U + i)))) {
			errors = errors | 8;
		}
		/* begin jumpLongConditionalTargetBeforeFollowingAddress: */
		entryPoint = jumpLongTargetBeforeFollowingAddress(((AbstractInstruction *) backEnd), pc);
		if (!(asserta(entryPoint == (((cPICPrototypeCaseOffset()) + 13262352) + (i * 16))))) {
			errors = errors | 16;
		}
		rewriteCPICCaseAttagobjReftarget(pc, classTag ^ 0x5A5A5A5A, object ^ 0xA5A5A5A5U, entryPoint ^ 0x55AA50);
		object = literalBeforeFollowingAddress(backEnd, methodObjPC);
		if (!(asserta(object == (((subsequentPrototypeMethodOop()) + i) ^ 0xA5A5A5A5U)))) {
			errors = errors | 32;
		}
		classTag = literal32BeforeFollowingAddress(backEnd, classTagPC);
		if (!(asserta(classTag == ((0xBABE1F15U + i) ^ 0x5A5A5A5A)))) {
			errors = errors | 64;
		}
		/* begin jumpLongConditionalTargetBeforeFollowingAddress: */
		entryPoint = jumpLongTargetBeforeFollowingAddress(((AbstractInstruction *) backEnd), pc);
		if (!(asserta(entryPoint == ((((cPICPrototypeCaseOffset()) + 13262352) + (i * 16)) ^ 0x55AA50)))) {
			errors = errors | 128;
		}
		rewriteCPICCaseAttagobjReftarget(pc, classTag ^ 0x5A5A5A5A, object ^ 0xA5A5A5A5U, entryPoint ^ 0x55AA50);
	}
	entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, (((usqInt)cPIC)) + cPICEndOfCodeOffset);
	if (!(asserta(entryPoint == (cPICMissTrampolineFor(0))))) {
		errors += 0x100;
	}
	return errors;
}


/*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A) */

	/* Cogit>>#extABytecode */
static sqInt
extABytecode(void)
{
	extA = ((((sqInt)((usqInt)(extA) << 8)))) + byte1;
	return 0;
}


/*	225		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B) */

	/* Cogit>>#extBBytecode */
static sqInt
extBBytecode(void)
{
	extB = ((numExtB == 0)
	 && (byte1 > 0x7F)
		? byte1 - 0x100
		: ((((sqInt)((usqInt)(extB) << 8)))) + byte1);
	numExtB += 1;
	return 0;
}


/*	Fill in the block headers now we know the exact layout of the code. */

	/* Cogit>>#fillInBlockHeadersAt: */
static sqInt NoDbgRegParms
fillInBlockHeadersAt(sqInt startAddress)
{
    sqInt aCogMethodOrInteger;
    CogBlockMethod *blockHeader;
    BlockStart *blockStart;
    sqInt i;

	if (!(needsFrame
		 && (blockCount > 0))) {
		return null;
	}
	if (blockNoContextSwitchOffset == null) {
		blockNoContextSwitchOffset = ((blockEntryLabel->address)) - ((blockEntryNoContextSwitch->address));
	}
	else {
		assert(blockNoContextSwitchOffset == (((blockEntryLabel->address)) - ((blockEntryNoContextSwitch->address))));
	}
	for (i = 0; i < blockCount; i += 1) {
		blockStart = blockStartAt(i);
		/* begin writableBlockMethodFor: */
		aCogMethodOrInteger = (((blockStart->fakeHeader))->address);
		blockHeader = ((CogBlockMethod *) ((((usqInt)aCogMethodOrInteger)) + codeToDataDelta));
		(blockHeader->homeOffset = ((((blockStart->fakeHeader))->address)) - startAddress);
		(blockHeader->startpc = (blockStart->startpc));
		(blockHeader->cmType = CMBlock);
		(blockHeader->cmNumArgs = (blockStart->numArgs));
		(blockHeader->cbUsesInstVars = (blockStart->hasInstVarRef));
		(blockHeader->stackCheckOffset = (((blockStart->stackCheckLabel)) == null
			? 0
			: ((((blockStart->stackCheckLabel))->address)) - ((((blockStart->fakeHeader))->address))));
	}
	return 0;
}


/*	Fill in the header for theCogMethod method. This may be located at the
	writable mapping. */

	/* Cogit>>#fillInMethodHeader:size:selector: */
static void NoDbgRegParms
fillInMethodHeadersizeselector(CogMethod *method, sqInt size, sqInt selector)
{
    sqInt actualMethodLocation;
    CogMethod *originalMethod;
    sqInt rawHeader;

	actualMethodLocation = (((usqInt)method)) - codeToDataDelta;
	(method->cmType = CMMethod);
	(method->objectHeader = nullHeaderForMachineCodeMethod());
	(method->blockSize = size);
	(method->methodObject = methodObj);

	/* If the method has already been cogged (e.g. Newspeak accessors) then
	   leave the original method attached to its cog method, but get the right header. */
	rawHeader = rawHeaderOf(methodObj);
	if (isCogMethodReference(rawHeader)) {
		originalMethod = ((CogMethod *) rawHeader);
		assert(((originalMethod->blockSize)) == size);
		assert(methodHeader == ((originalMethod->methodHeader)));
			}
	else {
		rawHeaderOfput(methodObj, actualMethodLocation);
			}
	(method->methodHeader = methodHeader);
	(method->selector = selector);
	(method->cmNumArgs = argumentCountOfMethodHeader(methodHeader));
	(method->cmHasMovableLiteral = hasMovableLiteral);
	if ((method->cmRefersToYoung = hasYoungReferent)) {
		addToYoungReferrers(method);
	}
	(method->cmUsageCount = initialMethodUsageCount());
	/* begin cpicHasMNUCase: */
	((((CogBlockMethod *) method))->cpicHasMNUCaseOrCMIsFullBlock) = 0;
	(method->cmUsesPenultimateLit = maxLitIndex >= ((literalCountOfMethodHeader(methodHeader)) - 2));
	(method->blockEntryOffset = (blockEntryLabel != null
		? ((blockEntryLabel->address)) - actualMethodLocation
		: 0));
	if (needsFrame) {
		if (!((((stackCheckLabel->address)) - actualMethodLocation) <= MaxStackCheckOffset)) {
			error("too much code for stack check offset");
		}
	}
	(method->stackCheckOffset = (needsFrame
		? ((stackCheckLabel->address)) - actualMethodLocation
		: 0));
	assert((callTargetFromReturnAddress(backEnd, actualMethodLocation + missOffset)) == (methodAbortTrampolineFor((method->cmNumArgs))));
	assert(size == (roundUpLength(size)));
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, actualMethodLocation + cmNoCheckEntryOffset, codeToDataDelta);
#  endif
	/* begin maybeEnableSingleStep */
	return;
}

	/* Cogit>>#findBlockMethodWithEntry:startBcpc: */
static usqInt NoDbgRegParms
findBlockMethodWithEntrystartBcpc(sqInt blockEntryMcpc, sqInt startBcpc)
{
    CogBlockMethod *cogBlockMethod;

	cogBlockMethod = ((CogBlockMethod *) (blockEntryMcpc - (sizeof(CogBlockMethod))));
	if (((cogBlockMethod->startpc)) == startBcpc) {
		return ((usqInt)cogBlockMethod);
	}
	return 0;
}

	/* Cogit>>#findMapLocationForMcpc:inMethod: */
static usqInt NoDbgRegParms
findMapLocationForMcpcinMethod(usqInt targetMcpc, CogMethod *cogMethod)
{
    sqInt annotation;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;

	/* begin firstMappedPCFor: */
	mcpc = ((((cogMethod->cmType)) >= CMMethod)
	 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
		? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
		: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	/* begin mapStartFor: */
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	if (mcpc == targetMcpc) {
		return map;
	}
	while (((mapByte = byteAt(map))) != MapEnd) {
		annotation = ((usqInt)(mapByte)) >> AnnotationShift;
		if (annotation != IsAnnotationExtension) {
			mcpc += 1 /* codeGranularity */ * ((annotation == IsDisplacementX2N
	? ((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))
	: mapByte & DisplacementMask));
		}
		if (mcpc >= targetMcpc) {
			assert(mcpc == targetMcpc);
			if (annotation == IsDisplacementX2N) {
				map -= 1;
				mapByte = byteAt(map);
				annotation = ((usqInt)(mapByte)) >> AnnotationShift;
				assert(annotation > IsAnnotationExtension);
			}
			return map;
		}
		map -= 1;
	}
	return 0;
}


/*	Find the CMMethod or CMBlock that has zero-relative startbcpc as its first
	bytecode pc.
	As this is for cannot resume processing and/or conversion to machine-code
	on backward
	branch, it doesn't have to be fast. Enumerate block returns and map to
	bytecode pcs. */

	/* Cogit>>#findMethodForStartBcpc:inHomeMethod: */
CogBlockMethod *
findMethodForStartBcpcinHomeMethod(sqInt startbcpc, CogMethod *cogMethod)
{
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
	if (startbcpc == (startPCOfMethodHeader((cogMethod->methodHeader)))) {
		return ((CogBlockMethod *) cogMethod);
	}
	assert(((cogMethod->blockEntryOffset)) != 0);
	return ((CogBlockMethod *) (blockDispatchTargetsForperformarg(cogMethod, findBlockMethodWithEntrystartBcpc, startbcpc)));
}


/*	Machine code addresses map to the following bytecode for all bytecodes
	except backward branches, where they map to the backward branch itself.
	This is so that loops continue, rather than terminate prematurely. */

	/* Cogit>>#find:IsBackwardBranch:Mcpc:Bcpc:MatchingMcpc: */
static sqInt NoDbgRegParms
findIsBackwardBranchMcpcBcpcMatchingMcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetMcpc)
{
	return (targetMcpc == mcpc
		? ((descriptor == null)
			 || (((isBackwardBranchAndAnnotation & 1) != 0))
				? bcpc
				: bcpc + ((descriptor->numBytes)))
		: 0);
}

	/* Cogit>>#firstMappedPCFor: */
static sqInt NoDbgRegParms
firstMappedPCFor(CogMethod *cogMethod)
{
	return ((((cogMethod->cmType)) >= CMMethod)
	 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
		? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
		: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
}


/*	Answer a fake value for the first method oop in the PIC prototype.
	Since we use MoveUniqueCw:R: it must not be confused with a
	method-relative address. */

	/* Cogit>>#firstPrototypeMethodOop */
static sqInt
firstPrototypeMethodOop(void)
{
	return (((((usqInt)0x5EAF00D)) >= ((methodLabel->address)))
	 && ((((usqInt)0x5EAF00D)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))
		? 0xCA7F00D
		: 0x5EAF00D);
}

	/* Cogit>>#fixupAt: */
static BytecodeFixup * NoDbgRegParms
fixupAt(sqInt fixupPC)
{
	return fixupAtIndex(fixupPC - initialPC);
}

	/* Cogit>>#flagCogMethodForBecome: */
void
flagCogMethodForBecome(CogMethod *cogMethod)
{
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
	/* begin ensureWritableCodeZone */
	((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMMethodFlaggedForBecome);
}

	/* Cogit>>#followForwardedLiteralsImplementationIn: */
static void NoDbgRegParms
followForwardedLiteralsImplementationIn(CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt hasYoungObj;
    sqInt hasYoungObjPtr;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *writableCogMethod;

	assert((!(isCMMethodEtAl(((CogBlockMethod *) cogMethod))))
	 || (!(isForwarded((cogMethod->methodObject)))));
	/* begin writableMethodFor: */
	writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
	hasYoungObj = isYoung((cogMethod->methodObject));
	if (shouldRemapOop((cogMethod->selector))) {
		(writableCogMethod->selector = remapObj((cogMethod->selector)));
		if (isYoung((cogMethod->selector))) {
			hasYoungObj = 1;
		}
	}
	hasYoungObjPtr = ((sqInt)((&hasYoungObj)));
	/* begin mapFor:performUntil:arg: */
	
	mcpc = ((((cogMethod->cmType)) >= CMMethod)
	 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
		? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
		: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	/* begin mapStartFor: */
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {

			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask);
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = remapIfObjectRefpchasYoung(annotation, (((char *) mcpc)), (((void *)hasYoungObjPtr)));
			if (result != 0) {
				goto l4;
			}
		}
		else {
			if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
			}
		}
		map -= 1;
	}
	l4:	/* end mapFor:performUntil:arg: */;
	if (hasYoungObj) {
		ensureInYoungReferrers(cogMethod);
	}
	else {
		(writableCogMethod->cmRefersToYoung = 0);
	}
}

	/* Cogit>>#followForwardedLiteralsIn: */
void
followForwardedLiteralsIn(CogMethod *cogMethod)
{
    usqInt wasInYoungReferrers;

	/* begin ensureWritableCodeZone */
	wasInYoungReferrers = (cogMethod->cmRefersToYoung);
	followForwardedLiteralsImplementationIn(cogMethod);
	if (wasInYoungReferrers
	 && (!((cogMethod->cmRefersToYoung)))) {
		pruneYoungReferrers();
	}
	/* begin ensureExecutableCodeZone */
	return;
}


/*	To avoid runtime checks on literal variable and literal accesses in == and
	~~, 
	we follow literals in methods having movable literals in the postBecome
	action. To avoid scanning every method, we annotate cogMethods with the 
	cmHasMovableLiteral flag. */

	/* Cogit>>#followMovableLiteralsAndUpdateYoungReferrers */
void
followMovableLiteralsAndUpdateYoungReferrers(void)
{
    CogMethod *cogMethod;

	assert(kosherYoungReferrers());
	codeModified = 0;
	/* begin ensureWritableCodeZone */
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!((((cogMethod->cmType)) == CMFree)
			 || (((cogMethod->cmType)) == CMMethodFlaggedForBecome))) {
			if ((cogMethod->cmHasMovableLiteral)) {
				followForwardedLiteralsImplementationIn(cogMethod);
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)codeBase), freeStart());
	}
	/* begin ensureExecutableCodeZone */
	return;
}


/*	N.B. because becomeEffectFlags indicates whether jitted methods were
	becommed or not, if this method is called flagged methods exist, will be
	freed, and so on. So there is no need to check. Just do it. */

	/* Cogit>>#freeBecomeFlaggedMethods */
void
freeBecomeFlaggedMethods(void)
{
    CogMethod *cogMethod;

	/* begin ensureWritableCodeZone */
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
			freeMethod(cogMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	unlinkSendsToFree();
	/* begin ensureExecutableCodeZone */
	return;
}

	/* Cogit>>#freeCogMethod: */
void
freeCogMethod(CogMethod *cogMethod)
{
	moveProfileToMethods();
	freeMethod(cogMethod);
	/* begin ensureExecutableCodeZone */
	return;
}


/*	Free machine-code methods whose compiled methods are unmarked
	and open PICs whose selectors are not marked, and closed PICs that
	refer to unmarked objects. */

	/* Cogit>>#freeUnmarkedMachineCode */
void
freeUnmarkedMachineCode(void)
{
    CogMethod *cogMethod;
    sqInt freedMethod;

	moveProfileToMethods();
	freedMethod = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) >= CMMethod)
		 && (!(isMarked((cogMethod->methodObject))))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		if ((((cogMethod->cmType)) == CMOpenPIC)
		 && ((!(isImmediate((cogMethod->selector))))
		 && (!(isMarked((cogMethod->selector)))))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		if ((((cogMethod->cmType)) == CMClosedPIC)
		 && (closedPICRefersToUnmarkedObject(cogMethod))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedMethod) {
		unlinkSendsToFree();
	}
	/* begin ensureExecutableCodeZone */
	return;
}


/*	Call ceSendMustBeBooleanTo: via the relevant trampoline. */

	/* Cogit>>#genCallMustBeBooleanFor: */
static AbstractInstruction * NoDbgRegParms
genCallMustBeBooleanFor(sqInt boolean)
{
    AbstractInstruction *abstractInstruction;
    sqInt callTarget;

	/* begin CallRT: */
	callTarget = (boolean == (falseObject())
		? ceSendMustBeBooleanAddFalseTrampoline
		: ceSendMustBeBooleanAddTrueTrampoline);
	/* begin annotateCall: */
	abstractInstruction = genoperand(Call, callTarget);
	(abstractInstruction->annotation = IsRelativeCall);
	return abstractInstruction;
}

	/* Cogit>>#genConditionalBranch:operand: */
static AbstractInstruction * NoDbgRegParms
genConditionalBranchoperand(sqInt opcode, sqInt operandOne)
{
    AbstractInstruction *branch;

	/* begin noteFollowingConditionalBranch: */
	previousInstruction();
	branch = genoperand(opcode, operandOne);
	return branch;
}


/*	An enilopmart (the reverse of a trampoline) is a piece of code that makes
	the system-call-like transition from the C runtime into generated machine
	code. The desired arguments and entry-point are pushed on a stackPage's
	stack. The enilopmart pops off the values to be loaded into registers and
	then executes a return instruction to pop off the entry-point and jump to
	it. 
	BEFORE				AFTER			(stacks grow down)
	whatever			stackPointer ->	whatever
	target address =>	reg1 = reg1val, etc
	reg1val				pc = target address
	reg2val
	stackPointer ->	reg3val */

	/* Cogit>>#genEnilopmartFor:and:and:forCall:called: */
static void (*genEnilopmartForandandforCallcalled(sqInt regArg1, sqInt regArg2OrNone, sqInt regArg3OrNone, sqInt forCall, char *trampolineName))(void)
{
    sqInt endAddress;
    usqInt enilopmart;
    sqInt quickConstant;
    sqInt size;

	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	genLoadStackPointers(backEnd);
	if (regArg3OrNone != NoReg) {
		/* begin PopR: */
		genoperand(PopR, regArg3OrNone);
	}
	if (regArg2OrNone != NoReg) {
		/* begin PopR: */
		genoperand(PopR, regArg2OrNone);
	}
	/* begin PopR: */
	genoperand(PopR, regArg1);
	genEnilopmartReturn(forCall);
	computeMaximumSizes();
	size = generateInstructionsAt(methodZoneBase);
	endAddress = outputInstructionsAt(methodZoneBase);
	assert((methodZoneBase + size) == endAddress);
	enilopmart = methodZoneBase;
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	recordGeneratedRunTimeaddress(trampolineName, enilopmart);
	return ((void (*)(void)) enilopmart);
}


/*	An enilopmart (the reverse of a trampoline) is a piece of code that makes
	the system-call-like transition from the C runtime into generated machine
	code. At the point the enilopmart enters machine code via a return
	instruction, any argument registers have been loaded with their values and
	the stack, if
	for call, looks like
	ret pc
	stackPointer ->	target address
	
	and if not for call, looks like
	whatever
	stackPointer ->	target address
	
	If forCall and running on a CISC, ret pc must be left on the stack. If
	forCall and
	running on a RISC, ret pc must be popped into LinkReg. In either case,
	target address must be removed from the stack and jumped/returned to. */

	/* Cogit>>#genEnilopmartReturn: */
static void NoDbgRegParms
genEnilopmartReturn(sqInt forCall)
{
	/* begin RetN: */
	genoperand(RetN, 0);
}


/*	Generate the routine that writes the current values of the C frame and
	stack pointers into
	variables. These are used to establish the C stack in trampolines back
	into the C run-time.
	This routine assumes the system's frame pointer is the same as that used
	in generated code. */

	/* Cogit>>#generateCaptureCStackPointers: */
static void NoDbgRegParms NeverInline
generateCaptureCStackPointers(sqInt captureFramePointer)
{
    sqInt address;
    sqInt address1;
    sqInt callerSavedReg;
    sqInt fixupSize;
    sqInt offset;
    sqInt opcodeSize;
    sqInt pushedVarBaseReg;
    sqInt quickConstant;
    usqInt startAddress;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 32;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;

	/* Must happen first; value may be used in accessing any of the following addresses */
	startAddress = methodZoneBase;
	callerSavedReg = 0;
	pushedVarBaseReg = 0;
	if (!(((CallerSavedRegisterMask & ((1U << VarBaseReg))) != 0))) {

		/* VarBaseReg is not caller-saved; must save and restore it, either by using an available caller-saved reg or push/pop. */

		/* TempReg used below */
		callerSavedReg = availableRegisterOrNoneIn(((ABICallerSavedRegisterMask | (1U << TempReg)) - (1U << TempReg)));
		if (callerSavedReg == NoReg) {
			gNativePushR(VarBaseReg);
			pushedVarBaseReg = 1;
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, VarBaseReg, callerSavedReg);
		}
	}
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (captureFramePointer) {
		/* begin MoveR:Aw: */
		address = cFramePointerAddress();
		genoperandoperand(MoveRAw, FPReg, address);
	}
	/* begin LoadEffectiveAddressMw:r:R: */
	offset = (pushedVarBaseReg
		? (leafCallStackPointerDelta(backEnd)) + BytesPerWord
		: leafCallStackPointerDelta(backEnd));
	genoperandoperandoperand(LoadEffectiveAddressMwrR, offset, NativeSPReg, TempReg);
	/* begin MoveR:Aw: */
	address1 = cStackPointerAddress();
	genoperandoperand(MoveRAw, TempReg, address1);
	if (!(((CallerSavedRegisterMask & ((1U << VarBaseReg))) != 0))) {
		if (pushedVarBaseReg) {
			gNativePopR(VarBaseReg);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, callerSavedReg, VarBaseReg);
		}
	}
	gNativeRetN(0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	flushICacheFromto(backEnd, ((usqInt)startAddress), ((usqInt)methodZoneBase));
	recordGeneratedRunTimeaddress("ceCaptureCStackPointers", startAddress);
	ceCaptureCStackPointers = ((void (*)(void)) startAddress);
}


/*	Generate the prototype ClosedPIC to determine how much space a full closed
	PIC takes.
	When we first allocate a closed PIC it only has one or two cases and we
	want to grow it.
	So we have to determine how big a full one is before hand. */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#generateClosedPICPrototype */
static void
generateClosedPICPrototype(void)
{
    CogMethod *cPIC;
    AbstractInstruction * cPICEndOfCodeLabel;
    sqInt endAddress;
    AbstractInstruction * endCPICCase1;
    sqInt fixupSize;
    sqInt h;
    AbstractInstruction *jumpNext;
    sqInt jumpTarget;
    sqInt jumpTarget1;
    sqInt jumpTarget2;
    sqInt numArgs;
    sqInt opcode;
    sqInt opcodeSize;
    sqInt wordConstant;
    sqInt wordConstant1;
    sqInt wordConstant2;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = MaxCPICCases * 9;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	(methodLabel->address = methodZoneBase);
	(methodLabel->dependent = null);
	/* begin compileClosedPICPrototype */
	compilePICAbort((numArgs = 0));

	/* At the end of the entry code we need to jump to the first case code, which is actually the last chunk.
	   On each entension we must update this jump to move back one case. */
	jumpNext = compileCPICEntry();
	/* begin MoveUniqueCw:R: */
	wordConstant1 = firstPrototypeMethodOop();
	genoperandoperand(MoveCwR, wordConstant1, SendNumArgsReg);
	/* begin JumpLong: */
	jumpTarget1 = (((methodZoneBase + (youngReferrers())) / 2) - 13262352) + 13262352;
	genoperand(JumpLong, jumpTarget1);
	/* begin Label */
	endCPICCase0 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	for (h = 1; h < MaxCPICCases; h += 1) {
		if (h == (MaxCPICCases - 1)) {
			jmpTarget(jumpNext, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		}
		/* begin MoveUniqueCw:R: */
		wordConstant = (subsequentPrototypeMethodOop()) + h;
		genoperandoperand(MoveCwR, wordConstant, SendNumArgsReg);
		/* begin CmpC32:R: */
		
		opcode = CmpC32R;
		genoperandoperand(opcode, 0xBABE1F15U + h, TempReg);
		/* begin JumpLongZero: */
		jumpTarget = ((((methodZoneBase + (youngReferrers())) / 2) - 13262352) + 13262352) + (h * 16);
		genConditionalBranchoperand(JumpLongZero, ((sqInt)jumpTarget));
		if (h == 1) {
			/* begin Label */
			endCPICCase1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
	}
	/* begin MoveCw:R: */
	wordConstant2 = (methodLabel->address);
	genoperandoperand(MoveCwR, wordConstant2, ClassReg);
	/* begin JumpLong: */
	jumpTarget2 = cPICMissTrampolineFor(numArgs);
	genoperand(JumpLong, jumpTarget2);
	/* begin Label */
	cPICEndOfCodeLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	computeMaximumSizes();
	cPIC = ((CogMethod *) methodZoneBase);
	closedPICSize = (sizeof(CogMethod)) + (generateInstructionsAt(methodZoneBase + (sizeof(CogMethod))));
	endAddress = outputInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	assert((methodZoneBase + closedPICSize) == endAddress);
	firstCPICCaseOffset = ((endCPICCase0->address)) - methodZoneBase;
	cPICEndOfCodeOffset = ((cPICEndOfCodeLabel->address)) - methodZoneBase;
	cPICCaseSize = ((endCPICCase1->address)) - ((endCPICCase0->address));
	cPICEndSize = closedPICSize - (((MaxCPICCases - 1) * cPICCaseSize) + firstCPICCaseOffset);
	/* begin roundUpLength: */
	closedPICSize = roundUpToMethodAlignment(backEnd(), closedPICSize);
	assert(((picInterpretAbort->address)) == (((methodLabel->address)) + (picInterpretAbortOffset())));
	assert((expectedClosedPICPrototype(cPIC)) == 0);
	storeLiteralbeforeFollowingAddress(backEnd, 0, ((endCPICCase0->address)) - (jumpLongByteSize(backEnd)));
	methodZoneBase = alignUptoRoutineBoundary(endAddress);

	/* self cCode: ''
	   inSmalltalk:
	   [self disassembleFrom: cPIC + (self sizeof: CogMethod) to: cPIC + closedPICSize - 1.
	   self halt] */
	cPICPrototype = cPIC;
}


/*	We handle jump sizing simply. First we make a pass that asks each
	instruction to compute its maximum size. Then we make a pass that
	sizes jumps based on the maxmimum sizes. Then we make a pass
	that fixes up jumps. When fixing up a jump the jump is not allowed to
	choose a smaller offset but must stick to the size set in the second pass. */

	/* Cogit>>#generateCogFullBlock */
static CogMethod *
generateCogFullBlock(void)
{
    sqInt codeSize;
    usqIntptr_t headerSize;
    sqInt mapSize;
    CogMethod *method;
    sqInt result;
    usqInt startAddress;
    sqInt totalSize;

	headerSize = sizeof(CogMethod);
	(methodLabel->address = freeStart());
	computeMaximumSizes();
	concretizeAt(methodLabel, freeStart());
	codeSize = generateInstructionsAt(((methodLabel->address)) + headerSize);
	mapSize = generateMapAtstart(null, ((methodLabel->address)) + cbNoSwitchEntryOffset);
	/* begin roundUpLength: */
	totalSize = roundUpToMethodAlignment(backEnd(), (headerSize + codeSize) + mapSize);
	if (totalSize > MaxMethodSize) {
		return ((CogMethod *) MethodTooBig);
	}
	startAddress = allocate(totalSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	assert((startAddress + cbEntryOffset) == ((fullBlockEntry->address)));
	assert((startAddress + cbNoSwitchEntryOffset) == ((fullBlockNoContextSwitchEntry->address)));
	result = outputInstructionsAt(startAddress + headerSize);
	assert(((startAddress + headerSize) + codeSize) == result);
	padIfPossibleWithStopsFromto(backEnd, result, ((startAddress + totalSize) - mapSize) - 1);
	generateMapAtstart((startAddress + totalSize) - 1, startAddress + cbNoSwitchEntryOffset);
	flag("TOCHECK");
	/* begin writableMethodFor: */
	method = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	fillInMethodHeadersizeselector(method, totalSize, nilObject());
	(method->cpicHasMNUCaseOrCMIsFullBlock = 1);
	flushICacheFromto(backEnd, startAddress, startAddress + totalSize);
	return ((CogMethod *) startAddress);
}


/*	We handle jump sizing simply. First we make a pass that asks each
	instruction to compute its maximum size. Then we make a pass that
	sizes jumps based on the maxmimum sizes. Then we make a pass
	that fixes up jumps. When fixing up a jump the jump is not allowed to
	choose a smaller offset but must stick to the size set in the second pass. */

	/* Cogit>>#generateCogMethod: */
static CogMethod * NoDbgRegParms
generateCogMethod(sqInt selector)
{
    sqInt codeSize;
    usqIntptr_t headerSize;
    sqInt mapSize;
    sqInt result;
    usqInt startAddress;
    sqInt totalSize;

	headerSize = sizeof(CogMethod);
	(methodLabel->address = freeStart());
	computeMaximumSizes();
	concretizeAt(methodLabel, freeStart());
	codeSize = generateInstructionsAt(((methodLabel->address)) + headerSize);
	mapSize = generateMapAtstart(null, ((methodLabel->address)) + cmNoCheckEntryOffset);
	/* begin roundUpLength: */
	totalSize = roundUpToMethodAlignment(backEnd(), (headerSize + codeSize) + mapSize);
	if (totalSize > MaxMethodSize) {
		return ((CogMethod *) MethodTooBig);
	}
	startAddress = allocate(totalSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	assert((startAddress + cmEntryOffset) == ((entry->address)));
	assert((startAddress + cmNoCheckEntryOffset) == ((noCheckEntry->address)));
	result = outputInstructionsAt(startAddress + headerSize);
	assert(((startAddress + headerSize) + codeSize) == result);
	padIfPossibleWithStopsFromto(backEnd, result, ((startAddress + totalSize) - mapSize) - 1);
	generateMapAtstart((startAddress + totalSize) - 1, startAddress + cmNoCheckEntryOffset);
	fillInBlockHeadersAt(startAddress);
	fillInMethodHeadersizeselector(((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta)), totalSize, selector);
	flushICacheFromto(backEnd, startAddress, startAddress + totalSize);
	return ((CogMethod *) startAddress);
}


/*	Generate the method map at addressrNull (or compute it if addressOrNull is
	null). Answer the length of the map in byes. Each entry in the map is in
	two parts. In the
	least signficant bits are a displacement of how far from the start or
	previous entry,
	unless it is an IsAnnotationExtension byte, in which case those bits are
	the extension.
	In the most signficant bits are the type of annotation at the point
	reached. A null
	byte ends the map. */

	/* Cogit>>#generateMapAt:start: */
static sqInt NoDbgRegParms
generateMapAtstart(usqInt addressOrNull, usqInt startAddress)
{
    unsigned char annotation;
    sqInt delta;
    sqInt i;
    AbstractInstruction *instruction;
    sqInt length;
    usqInt location;
    sqInt mapEntry;
    sqInt maxDelta;
    usqInt mcpc;

	length = 0;
	location = startAddress;
	for (i = 0; i < opcodeIndex; i += 1) {
		instruction = abstractInstructionAt(i);
		annotation = (instruction->annotation);
		if (!(annotation == null)) {
			/* begin mapEntryAddress */
			mcpc = ((instruction->address)) + ((instruction->machineCodeSize));
			while (((delta = (mcpc - location) / 1 /* codeGranularity */)) > DisplacementMask) {
				maxDelta = (((((delta < MaxX2NDisplacement) ? delta : MaxX2NDisplacement)) | DisplacementMask) - DisplacementMask);
				assert((((usqInt)(maxDelta)) >> AnnotationShift) <= DisplacementMask);
				if (!(addressOrNull == null)) {
					/* begin addToMap:instruction:byte:at:for: */
					codeByteAtput(addressOrNull - length, (((usqInt)(maxDelta)) >> AnnotationShift) + DisplacementX2N);
				}
				location += maxDelta;
				length += 1;
			}
			if (!(addressOrNull == null)) {
				mapEntry = delta + (((sqInt)((usqInt)((((annotation < IsSendCall) ? annotation : IsSendCall))) << AnnotationShift)));
				/* begin addToMap:instruction:byte:at:for: */
				codeByteAtput(addressOrNull - length, mapEntry);
			}
			location += delta;
			length += 1;
			if (annotation > IsSendCall) {

				/* Add the necessary IsAnnotationExtension */
				if (!(addressOrNull == null)) {
					mapEntry = (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift))) + (annotation - IsSendCall);
					/* begin addToMap:instruction:byte:at:for: */
					codeByteAtput(addressOrNull - length, mapEntry);
				}
				length += 1;
			}
		}
	}
	if (!(addressOrNull == null)) {
		/* begin addToMap:instruction:byte:at:for: */
		codeByteAtput(addressOrNull - length, MapEnd);
	}
	return length + 1;
}


/*	Generate the prototype OpenPIC to determine how much space an open PIC
	takes. 
 */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#generateOpenPICPrototype */
static void
generateOpenPICPrototype(void)
{
    sqInt codeSize;
    sqInt fixupSize;
    sqInt mapSize;
    sqInt opcodeSize;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 100;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	(methodLabel->address = methodZoneBase);
	(methodLabel->dependent = null);
	compileOpenPICnumArgs(specialSelector(0), numRegArgs());
	computeMaximumSizes();
	concretizeAt(methodLabel, methodZoneBase);
	codeSize = generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	mapSize = generateMapAtstart(null, methodZoneBase + cmNoCheckEntryOffset);

	/* self cCode: ''
	   inSmalltalk:
	   [| end |
	   end := self outputInstructionsAt: methodZoneBase + headerSize.
	   self disassembleFrom: methodZoneBase + (self sizeof: CogMethod) to: end - 1.
	   self halt] */
	openPICSize = (roundUpLength((sizeof(CogMethod)) + codeSize)) + (roundUpToMethodAlignment(backEnd(), mapSize));
}


/*	Generate the run-time entries at the base of the native code zone and
	update the base.
 */

	/* Cogit>>#generateRunTimeTrampolines */
static void
generateRunTimeTrampolines(void)
{
    sqInt address1;
    sqInt address11;

	ceSendMustBeBooleanAddFalseTrampoline = genMustBeBooleanTrampolineForcalled(falseObject(), "ceSendMustBeBooleanAddFalseTrampoline");
	ceSendMustBeBooleanAddTrueTrampoline = genMustBeBooleanTrampolineForcalled(trueObject(), "ceSendMustBeBooleanAddTrueTrampoline");
	/* begin genNonLocalReturnTrampoline */
	zeroOpcodeIndex();
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin MoveR:Aw: */
	address1 = instructionPointerAddress();
	genoperandoperand(MoveRAw, TempReg, address1);
	ceNonLocalReturnTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNonLocalReturn, "ceNonLocalReturnTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 1);
	/* begin genCheckForInterruptsTrampoline */
	zeroOpcodeIndex();
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin MoveR:Aw: */
	address11 = instructionPointerAddress();
	genoperandoperand(MoveRAw, TempReg, address11);
	ceCheckForInterruptTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCheckForInterrupt, "ceCheckForInterruptTrampoline", 0, null, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 1);
	/* begin genTrampolineFor:called:arg:arg:result: */
	ceFetchContextInstVarTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceContextinstVar, "ceFetchContextInstVarTrampoline", 2, ReceiverResultReg, SendNumArgsReg, null, null, 0 /* emptyRegisterMask */, 1, SendNumArgsReg, 0);
	/* begin genTrampolineFor:called:arg:arg:arg:result: */
	ceStoreContextInstVarTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceContextinstVarvalue, "ceStoreContextInstVarTrampoline", 3, ReceiverResultReg, SendNumArgsReg, ClassReg, null, 0 /* emptyRegisterMask */, 1, ReceiverResultReg, 0);
	/* begin genTrampolineFor:called: */
	ceCannotResumeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCannotResume, "ceCannotResumeTrampoline", 0, null, null, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 0);

	/* These two are unusual; they are reached by return instructions. */
	ceInvokeInterpret = genInvokeInterpretTrampoline();
	ceReturnToInterpreterTrampoline = genReturnToInterpreterTrampoline();
	/* begin genReturnTrampolineFor:called:arg: */
	ceBaseFrameReturnTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceBaseFrameReturn, "ceBaseFrameReturnTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 0);
	ceFFICalloutTrampoline = genFFICalloutTrampoline();
	/* begin genTrampolineFor:called:arg:result: */
	ceMallocTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceMalloc, "ceMallocTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	/* begin genTrampolineFor:called:arg: */
	ceFreeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceFree, "ceFreeTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 0);
}


/*	Generate a routine ceCaptureCStackPointers that will capture the C stack
	pointer, and, if it is in use, the C frame pointer. These are used in
	trampolines to call
	run-time routines in the interpreter from machine-code. */

	/* Cogit>>#generateStackPointerCapture */
static void
generateStackPointerCapture(void)
{
    usqInt oldMethodZoneBase;
    sqInt oldTrampolineTableIndex;


#  if defined(cFramePointerInUse)
	assertCStackWellAligned();
	generateCaptureCStackPointers(cFramePointerInUse);
#  else

	/* For the benefit of the following assert, assume the minimum at first. */
	cFramePointerInUse = 0;
	assertCStackWellAligned();
	oldMethodZoneBase = methodZoneBase;
	oldTrampolineTableIndex = trampolineTableIndex;
	generateCaptureCStackPointers(1);
	ceCaptureCStackPointers();
	if (!((cFramePointerInUse = checkIfCFramePointerInUse()))) {
		methodZoneBase = oldMethodZoneBase;
		trampolineTableIndex = oldTrampolineTableIndex;
		generateCaptureCStackPointers(0);
	}
#  endif // defined(cFramePointerInUse)
	/* begin ensureWritableCodeZone */
	assertCStackWellAligned();
}


/*	Generate the run-time entries and exits at the base of the native code
	zone and update the base.
	Read the class-side method trampolines for documentation on the various
	trampolines 
 */

	/* Cogit>>#generateTrampolines */
static void
generateTrampolines(void)
{
    sqInt fixupSize;
    usqInt methodZoneStart;
    sqInt opcodeSize;

	methodZoneStart = methodZoneBase;
	(methodLabel->address = methodZoneStart);
	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 80;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	setHasYoungReferent(0);
	maybeGenerateSelectorIndexDereferenceRoutine();
	generateSendTrampolines();
	generateMissAbortTrampolines();
	generateObjectRepresentationTrampolines();
	generateRunTimeTrampolines();
	generateEnilopmarts();
	generateTracingTrampolines();
	recordGeneratedRunTimeaddress("methodZoneBase", methodZoneBase);
}

	/* Cogit>>#generatorForPC: */
static BytecodeDescriptor * NoDbgRegParms
generatorForPC(sqInt pc)
{
	return generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
}

	/* Cogit>>#genFFICalloutTrampoline */
static usqInt
genFFICalloutTrampoline(void)
{
    sqInt address1;
    sqInt address3;
    sqInt reg;
    sqInt reg1;
    sqInt reg2;
    sqInt reg3;
    usqInt startAddress;

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	/* begin PopR: */
	reg = R15;
	genoperand(PopR, reg);
	/* begin MoveR:Aw: */
	reg1 = R15;
	address1 = instructionPointerAddress();
	genoperandoperand(MoveRAw, reg1, address1);
	/* begin CallR: */
	genoperand(CallR, TempReg);
	/* begin MoveAw:R: */
	address3 = instructionPointerAddress();
	reg2 = R15;
	genoperandoperand(MoveAwR, address3, reg2);
	/* begin PushR: */
	reg3 = R15;
	genoperand(PushR, reg3);
	/* begin RetN: */
	genoperand(RetN, 0);
	startAddress = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceFFICalloutTrampoline", startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate a pair of routines that answer the frame pointer, and the stack
	pointer immediately
	after a leaf call, used for checking stack pointer alignment, frame
	pointer usage, etc. N.B.
	these are exported to the CoInterpreter et al via Cogit
	class>>mustBeGlobal:. 
 */

	/* Cogit>>#genGetLeafCallStackPointers */
static void
genGetLeafCallStackPointers(void)
{
    sqInt fixupSize;
    sqInt opcodeSize;
    sqInt quickConstant;
    usqInt startAddress;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 4;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	startAddress = methodZoneBase;
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, FPReg, ABIResultReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceGetFP", startAddress);
	ceGetFP = ((usqIntptr_t (*)(void)) startAddress);
	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, NativeSPReg, ABIResultReg);
	/* begin AddCq:R: */
	quickConstant = leafCallStackPointerDelta(backEnd);
	genoperandoperand(AddCqR, quickConstant, ABIResultReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceGetSP", startAddress);
	ceGetSP = ((usqIntptr_t (*)(void)) startAddress);
}


/*	Generate the abort for a PIC. This abort performs either a call of
	ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged target
	or a call of ceMNUFromPICMNUMethod:receiver: to handle an MNU dispatch
	in a closed PIC. It distinguishes the two by testing ClassReg. If the
	register is zero then this is an MNU.
	
	This poses a problem in 32-bit Spur, where zero is the cache tag for
	immediate characters (tag pattern 2r10) because SmallIntegers have tag
	patterns 2r11
	and 2r01, so anding with 1 reduces these to 0 & 1. We solve the ambiguity
	by patching send sites with a 0 cache tag to open PICs instead of closed
	PICs.  */

	/* Cogit>>#genInnerPICAbortTrampoline: */
static usqInt NoDbgRegParms
genInnerPICAbortTrampoline(char *name)
{
    AbstractInstruction *jumpMNUCase;
    sqInt quickConstant;

	/* begin CmpCq:R: */
	quickConstant = 0 /* picAbortDiscriminatorValue */;
	genoperandoperand(CmpCqR, quickConstant, ClassReg);
	/* begin JumpZero: */
	jumpMNUCase = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceInterpretMethodFromPICreceiver, 2, SendNumArgsReg, ReceiverResultReg, null, null, 0 /* emptyRegisterMask */, 0, NoReg);
	jmpTarget(jumpMNUCase, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceMNUFromPICMNUMethodreceiver, name, 2, SendNumArgsReg, ReceiverResultReg, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 1);
}


/*	Switch to the C stack (do *not* save the Smalltalk stack pointers;
	this is the caller's responsibility), and invoke interpret PDQ. */

	/* Cogit>>#genInvokeInterpretTrampoline */
static void (*genInvokeInterpretTrampoline(void))(void)
{
    sqInt address1;
    AbstractInstruction *anInstruction1;
    sqInt quickConstant;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	assert(0 <= 4);
	/* begin MoveAw:R: */
	address1 = cReturnAddressAddress();
	genoperandoperand(MoveAwR, address1, ABIResultReg);
	/* begin genSubstituteReturnAddressR: */
	genoperand(PushR, ABIResultReg);
	/* begin JumpFullRT: */
	/* begin JumpFull: */
	
	((sqInt)(((usqInt)interpret)));
	anInstruction1 = genoperand(JumpFull, ((sqInt)(((usqInt)interpret))));
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceInvokeInterpret", startAddress);
	return ((void (*)(void)) startAddress);
}


/*	The in-line cache for a send is implemented as a constant load into
	ClassReg. We always use a 32-bit load, even in 64-bits.
	
	In the initial (unlinked) state the in-line cache is notionally loaded
	with the selector.
	But since in 64-bits an arbitrary selector oop won't fit in a 32-bit
	constant load, we
	instead load the cache with the selector's index, either into the literal
	frame of the
	current method, or into the special selector array. Negative values are
	1-relative indices into the special selector array.
	
	When a send is linked, the load of the selector, or selector index, is
	overwritten with a
	load of the receiver's class, or class tag. Hence, the 64-bit VM is
	currently constrained
	to use class indices as cache tags. If out-of-line literals are used,
	distinct caches /must
	not/ share acche locations, for if they do, send cacheing will be confused
	by the sharing.
	Hence we use the MoveUniqueC32:R: instruction that will not share literal
	locations.  */

	/* Cogit>>#genLoadInlineCacheWithSelector: */
static void NoDbgRegParms
genLoadInlineCacheWithSelector(sqInt selectorIndex)
{
    sqInt cacheValue;
    sqInt opcode;

	assert((selectorIndex < 0
		? (((-selectorIndex) >= 1) && ((-selectorIndex) <= (numSpecialSelectors())))
		: ((selectorIndex >= 0) && (selectorIndex <= ((literalCountOf(methodObj)) - 1)))));
	cacheValue = selectorIndex;
	/* begin MoveUniqueC32:R: */
	
	opcode = MoveC32R;
	genoperandoperand(opcode, cacheValue, ClassReg);
	return;
}

	/* Cogit>>#genReturnToInterpreterTrampoline */
static usqInt
genReturnToInterpreterTrampoline(void)
{
    sqInt address1;
    sqInt address2;
    AbstractInstruction *anInstruction1;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, FoxIFSavedIP, FPReg, TempReg);
	/* begin MoveR:Aw: */
	address2 = instructionPointerAddress();
	genoperandoperand(MoveRAw, TempReg, address2);
	genSmalltalkToCStackSwitch(0);
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	assert(0 <= 4);
	/* begin MoveAw:R: */
	address1 = cReturnAddressAddress();
	genoperandoperand(MoveAwR, address1, ABIResultReg);
	/* begin genSubstituteReturnAddressR: */
	genoperand(PushR, ABIResultReg);
	/* begin JumpFullRT: */
	/* begin JumpFull: */
	
	((sqInt)(((usqInt)interpret)));
	anInstruction1 = genoperand(JumpFull, ((sqInt)(((usqInt)interpret))));
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceReturnToInterpreterTrampoline", startAddress);
	return startAddress;
}


/*	If the client requires, then on an ARM-like RISC processor, the return
	address needs to
	be pushed to the stack so that the interpreter sees the same stack layout
	as on CISC.
 */

	/* Cogit>>#genSmalltalkToCStackSwitch: */
static sqInt NoDbgRegParms
genSmalltalkToCStackSwitch(sqInt pushLinkReg)
{
	genSaveStackPointers(backEnd);
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	return 0;
}


/*	Generate a trampoline with one argument that answers a result.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:floatResult: */
static usqInt NoDbgRegParms
genTrampolineForcalledargfloatResult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegfloatResultRegappendOpcodes(aRoutine, aString, 1, regOrConst0, null, null, null, 0 /* emptyRegisterMask */, 1, resultReg, 0);
}


/*	Generate a trampoline with one argument that answers a result.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:result:result: */
static usqInt NoDbgRegParms
genTrampolineForcalledargresultresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg, sqInt resultReg2)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegresultRegappendOpcodes(aRoutine, aString, 1, regOrConst0, null, null, null, 0 /* emptyRegisterMask */, 1, resultReg, resultReg2, 0);
}


/*	Generate a trampoline with one argument that answers a result.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:floatArg:result: */
static usqInt NoDbgRegParms
genTrampolineForcalledfloatArgresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg)
{
	return genTrampolineForcallednumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 1, regOrConst0, null, null, null, 0 /* emptyRegisterMask */, 1, resultReg, 0);
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:floatResultReg:appendOpcodes: */
static usqInt NoDbgRegParms
genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegfloatResultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegfloatResultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg:appendOpcodes: */
static usqInt NoDbgRegParms
genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, codeBase + cmNoCheckEntryOffset, codeToDataDelta);
#  endif
	return startAddress;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg:resultReg:appendOpcodes: */
static usqInt NoDbgRegParms
genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt resultReg2OrNone, sqInt appendBoolean)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultRegresultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone, resultReg2OrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:floatArg:floatArg:floatArg:floatArg:regsToSave:pushLinkReg:resultReg:appendOpcodes: */
static usqInt NoDbgRegParms
genTrampolineForcallednumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	To return from a trampoline call we have to take the return address off
	the stack,
	iof it has been saved */

	/* Cogit>>#genTrampolineReturn: */
static void NoDbgRegParms
genTrampolineReturn(sqInt lnkRegWasPushed)
{
	/* begin RetN: */
	genoperand(RetN, 0);
}


/*	<Integer> */

	/* Cogit>>#gen: */
static AbstractInstruction * NoDbgRegParms
gen(sqInt opcode)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand: */
static AbstractInstruction * NoDbgRegParms
genoperand(sqInt opcode, sqInt operand)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operand;
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand:operand: */
static AbstractInstruction * NoDbgRegParms
genoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operandOne;
	((abstractInstruction->operands))[1] = operandTwo;
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand:operand:operand: */
static AbstractInstruction * NoDbgRegParms
genoperandoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo, sqInt operandThree)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operandOne;
	((abstractInstruction->operands))[1] = operandTwo;
	((abstractInstruction->operands))[2] = operandThree;
	return abstractInstruction;
}

	/* Cogit>>#getLiteral: */
static sqInt NoDbgRegParms
getLiteral(sqInt litIndex)
{
	if (maxLitIndex < litIndex) {
		maxLitIndex = litIndex;
	}
	return literalofMethod(litIndex, methodObj);
}

	/* Cogit>>#incrementUsageOfTargetIfLinkedSend:mcpc:ignored: */
static sqInt NoDbgRegParms
incrementUsageOfTargetIfLinkedSendmcpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offset1;
    sqInt *sendTable1;
    CogMethod *targetMethod1;

	if (annotation >= IsSendCall) {
		assert(annotation != IsNSSendCall);
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (((targetMethod1->cmUsageCount)) < (CMMaxUsageCount / 2)) {
				((((CogMethod *) ((((usqInt)targetMethod1)) + codeToDataDelta)))->cmUsageCount = ((targetMethod1->cmUsageCount)) + 1);
			}
		}
	}
	return 0;
}


/*	Answer the value to put in an inline-cache that is being loaded with the
	selector. Usually this is simply the selector, but in 64-bits the cache is
	only 32-bits wide
	and so the cache is loaded with the index of the selector. */
/*	First search the special selectors; there are only 32 of them so this
	shouldn't take too long.
	We could short-circuit this by keeping a hint bit in the target method, or
	by maintaining the
	maximum range of selector oops in specialSelectors since they're likely to
	cluster. 
 */

	/* Cogit>>#indexForSelector:in: */
static sqInt NoDbgRegParms
indexForSelectorin(sqInt selector, CogMethod *cogMethod)
{
    sqInt i;
    sqInt iLimiT;
    sqInt methodOop;

	for (i = 0; i < NumSpecialSelectors; i += 1) {
		if (selector == (specialSelector(i))) {
			return -1 - i;
		}
	}

	/* Then search the method's literal frame... open code fetchPointer:ofObject: for speed... */
	methodOop = (cogMethod->methodObject);
	for (i = LiteralStart, iLimiT = (literalCountOfMethodHeader((cogMethod->methodHeader))); i <= iLimiT; i += 1) {
		if ((longAt(((i * BytesPerOop) + BaseHeaderSize) + methodOop)) == selector) {
			assert(selector == (literalofMethod(i - 1, methodOop)));
			return i - 1;
		}
	}
	error("could not find selector in method when unlinking send site");
	return 0;
}


/*	Answer a usage count that reflects likely long-term usage. */

	/* Cogit>>#initialClosedPICUsageCount */
static sqInt
initialClosedPICUsageCount(void)
{
	return CMMaxUsageCount / 2;
}

	/* Cogit>>#initializeBackend */
static void
initializeBackend(void)
{
	(methodLabel->machineCodeSize = 0);
	(methodLabel->opcode = Label);
	((methodLabel->operands))[0] = 0;
	((methodLabel->operands))[1] = 0;
	assert((!((registerMaskFor(VarBaseReg)) & CallerSavedRegisterMask)));
	varBaseAddress = computeGoodVarBaseAddress();
	assert((stackLimitAddress()) >= varBaseAddress);
	assert((cStackPointerAddress()) >= varBaseAddress);
	assert((cFramePointerAddress()) >= varBaseAddress);
	assert((cReturnAddressAddress()) >= varBaseAddress);
	assert((nextProfileTickAddress()) >= varBaseAddress);
	}

	/* Cogit>>#initializeCodeZoneFrom:upTo: */
void
initializeCodeZoneFromupTo(sqInt startAddress, sqInt endAddress)
{
	initializeBackend();
	sqMakeMemoryExecutableFromToCodeToDataDelta(startAddress, endAddress, 
#  if DUAL_MAPPED_CODE_ZONE
		(&codeToDataDelta)
#  else
		null
#  endif
		);
	codeBase = (methodZoneBase = startAddress);
	stopsFromto(backEnd, startAddress, endAddress - 1);
	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress = methodZoneBase);
	youngReferrers = (limitAddress = endAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;
	/* begin computeAllocationThreshold */
	allocationThreshold = ((((((usqInt)((limitAddress - baseAddress) * thresholdRatio))) + ((zoneAlignment()) - 1)) & ~7)) + baseAddress;
	assertValidDualZone();
	detectFeatures(backEnd);
	/* begin maybeGenerateCacheFlush */
	genGetLeafCallStackPointers();
	generateStackPointerCapture();
	generateTrampolines();
	computeEntryOffsets();
	computeFullBlockEntryOffsets();
	generateClosedPICPrototype();
	alignMethodZoneBase();
	flushICacheFromto(backEnd, startAddress, ((usqInt)methodZoneBase));
	/* begin maybeFlushWritableZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	if (codeToDataDelta > 0) {
		flushDCacheFromto(backEnd, startAddress, ((usqInt)methodZoneBase));
	}
#  endif
	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress = methodZoneBase);
	youngReferrers = (limitAddress = endAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;
	/* begin computeAllocationThreshold */
	allocationThreshold = ((((((usqInt)((limitAddress - baseAddress) * thresholdRatio))) + ((zoneAlignment()) - 1)) & ~7)) + baseAddress;
	generateOpenPICPrototype();
}


/*	Answer a usage count that reflects likely long-term usage.
	Answer 1 for non-primitives or quick primitives (inst var accessors),
	2 for methods with interpreter primitives, and 3 for compiled primitives. */

	/* Cogit>>#initialMethodUsageCount */
static sqInt
initialMethodUsageCount(void)
{
	if ((primitiveIndex == 1)
	 || (isQuickPrimitiveIndex(primitiveIndex))) {
		return 1;
	}
	if (!(primitiveGeneratorOrNil())) {
		return 2;
	}
	return 3;
}


/*	Answer a usage count that reflects likely long-term usage. */

	/* Cogit>>#initialOpenPICUsageCount */
static sqInt
initialOpenPICUsageCount(void)
{
	return CMMaxUsageCount - 1;
}

	/* Cogit>>#inverseBranchFor: */
static sqInt NoDbgRegParms
inverseBranchFor(sqInt opcode)
{
	switch (opcode) {
	case JumpLongZero:
		return JumpLongNonZero;

	case JumpLongNonZero:
		return JumpLongZero;

	case JumpZero:
		return JumpNonZero;

	case JumpNonZero:
		return JumpZero;

	case JumpNegative:
		return JumpNonNegative;

	case JumpNonNegative:
		return JumpNegative;

	case JumpOverflow:
		return JumpNoOverflow;

	case JumpNoOverflow:
		return JumpOverflow;

	case JumpCarry:
		return JumpNoCarry;

	case JumpNoCarry:
		return JumpCarry;

	case JumpLess:
		return JumpGreaterOrEqual;

	case JumpGreaterOrEqual:
		return JumpLess;

	case JumpGreater:
		return JumpLessOrEqual;

	case JumpLessOrEqual:
		return JumpGreater;

	case JumpBelow:
		return JumpAboveOrEqual;

	case JumpAboveOrEqual:
		return JumpBelow;

	case JumpAbove:
		return JumpBelowOrEqual;

	case JumpBelowOrEqual:
		return JumpAbove;

	default:
		error("Case not found and no otherwise clause");
	}
	error("invalid opcode for inverse");
	return 0;
}


/*	Useful for debugging. Marked <api> so the code generator won't delete it. */

	/* Cogit>>#isPCWithinMethodZone: */
static sqInt NoDbgRegParms
isPCWithinMethodZone(void *address)
{
	return (((((usqInt)address)) >= methodZoneBase) && ((((usqInt)address)) <= (freeStart())));
}


/*	Answer if the instruction preceding retpc is a call instruction. */

	/* Cogit>>#isSendReturnPC: */
sqInt
isSendReturnPC(sqInt retpc)
{
    sqInt target;

	if (!(isCallPrecedingReturnPC(backEnd, retpc))) {
		return 0;
	}
	target = callTargetFromReturnAddress(backEnd, retpc);
	return (((target >= firstSend) && (target <= lastSend)))
	 || (((target >= methodZoneBase) && (target <= (freeStart()))));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPEqual: */
static AbstractInstruction * NoDbgRegParms
gJumpFPEqual(void *jumpTarget)
{
    AbstractInstruction *jumpToTarget;
    AbstractInstruction *jumpUnordered;

	/* begin genJumpFPOrderedAnd:to: */
	jumpUnordered = genoperand(JumpFPUnordered, ((sqInt)jumpTarget));
	jumpToTarget = genoperand(JumpFPEqual, ((sqInt)jumpTarget));
	jmpTarget(jumpUnordered, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return jumpToTarget;
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPGreaterOrEqual: */
static AbstractInstruction * NoDbgRegParms
gJumpFPGreaterOrEqual(void *jumpTarget)
{
	return genoperand(JumpFPGreaterOrEqual, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPGreater: */
static AbstractInstruction * NoDbgRegParms
gJumpFPGreater(void *jumpTarget)
{
	return genoperand(JumpFPGreater, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPLessOrEqual: */
static AbstractInstruction * NoDbgRegParms
gJumpFPLessOrEqual(void *jumpTarget)
{
    AbstractInstruction *jumpToTarget;
    AbstractInstruction *jumpUnordered;

	/* begin genJumpFPOrderedAnd:to: */
	jumpUnordered = genoperand(JumpFPUnordered, ((sqInt)jumpTarget));
	jumpToTarget = genoperand(JumpFPLessOrEqual, ((sqInt)jumpTarget));
	jmpTarget(jumpUnordered, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return jumpToTarget;
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPLess: */
static AbstractInstruction * NoDbgRegParms
gJumpFPLess(void *jumpTarget)
{
    AbstractInstruction *jumpToTarget;
    AbstractInstruction *jumpUnordered;

	/* begin genJumpFPOrderedAnd:to: */
	jumpUnordered = genoperand(JumpFPUnordered, ((sqInt)jumpTarget));
	jumpToTarget = genoperand(JumpFPLess, ((sqInt)jumpTarget));
	jmpTarget(jumpUnordered, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return jumpToTarget;
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPNotEqual: */
static AbstractInstruction * NoDbgRegParms
gJumpFPNotEqual(void *jumpTarget)
{
    AbstractInstruction *jumpToTarget;
    AbstractInstruction *jumpUnordered;

	/* begin genJumpFPUnorderedOr:to: */
	jumpToTarget = genoperand(JumpFPNotEqual, ((sqInt)jumpTarget));
	jumpUnordered = genoperand(JumpFPUnordered, ((sqInt)jumpTarget));
	addDependent(jumpToTarget, jumpUnordered);
	return jumpToTarget;
}

	/* Cogit>>#LogicalShiftLeftCq:R: */
static AbstractInstruction * NoDbgRegParms
gLogicalShiftLeftCqR(sqInt quickConstant, sqInt reg)
{
	return genoperandoperand(LogicalShiftLeftCqR, quickConstant, reg);
}


/*	destReg := srcReg << quickConstant */

	/* Cogit>>#LogicalShiftLeftCq:R:R: */
static AbstractInstruction * NoDbgRegParms
gLogicalShiftLeftCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	first = genoperandoperand(MoveRR, srcReg, destReg);
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, destReg);
	return first;
}


/*	destReg := (unsigned)srcReg >> quickConstant */

	/* Cogit>>#LogicalShiftRightCq:R:R: */
static AbstractInstruction * NoDbgRegParms
gLogicalShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	first = genoperandoperand(MoveRR, srcReg, destReg);
	genoperandoperand(LogicalShiftRightCqR, quickConstant, destReg);
	return first;
}

	/* Cogit>>#lastOpcode */
static AbstractInstruction *
lastOpcode(void)
{
	assert(opcodeIndex > 0);
	return abstractInstructionAt(opcodeIndex - 1);
}

	/* Cogit>>#linkSendAt:in:to:offset:receiver: */
void
linkSendAtintooffsetreceiver(sqInt callSiteReturnAddress, CogMethod *sendingMethod, CogMethod *targetMethod, sqInt theEntryOffset, sqInt receiver)
{
    sqInt extent;
    sqInt inlineCacheTag;

	assert((theEntryOffset == cmEntryOffset)
	 || (theEntryOffset == cmNoCheckEntryOffset));
	assert(((callSiteReturnAddress >= methodZoneBase) && (callSiteReturnAddress <= (freeStart()))));
	/* begin ensureWritableCodeZone */
	if (theEntryOffset == cmNoCheckEntryOffset) {

		/* no need to change selector cache tag */
		extent = rewriteCallAttarget(backEnd, callSiteReturnAddress, (((sqInt)targetMethod)) + cmNoCheckEntryOffset);
	}
	else {
		inlineCacheTag = inlineCacheTagForInstance(receiver);
		extent = rewriteInlineCacheAttagtarget(backEnd, callSiteReturnAddress, inlineCacheTag, (((sqInt)targetMethod)) + theEntryOffset);
	}
	flushICacheFromto(backEnd, (((usqInt)callSiteReturnAddress)) - extent, ((usqInt)callSiteReturnAddress));
}

	/* Cogit>>#loadBytesAndGetDescriptor */
static BytecodeDescriptor *
loadBytesAndGetDescriptor(void)
{
    BytecodeDescriptor *descriptor;

	byte0 = (fetchByteofObject(bytecodePC, methodObj)) + bytecodeSetOffset;
	descriptor = generatorAt(byte0);
	loadSubsequentBytesForDescriptorat(descriptor, bytecodePC);
	return descriptor;
}

	/* Cogit>>#loadSubsequentBytesForDescriptor:at: */
static void NoDbgRegParms
loadSubsequentBytesForDescriptorat(BytecodeDescriptor *descriptor, sqInt pc)
{
	if (((descriptor->numBytes)) > 1) {
		byte1 = fetchByteofObject(pc + 1, methodObj);
		if (((descriptor->numBytes)) > 2) {
			byte2 = fetchByteofObject(pc + 2, methodObj);
			if (((descriptor->numBytes)) > 3) {
				byte3 = fetchByteofObject(pc + 3, methodObj);
				if (((descriptor->numBytes)) > 4) {
					notYetImplemented();
				}
			}
		}
	}
}

	/* Cogit>>#MoveCw:R: */
static AbstractInstruction * NoDbgRegParms
gMoveCwR(sqInt wordConstant, sqInt reg)
{
	return genoperandoperand(MoveCwR, wordConstant, reg);
}

	/* Cogit>>#MovePerfCnt64R:L: */
static AbstractInstruction * NoDbgRegParms
gMovePerfCnt64RL(sqInt destReg, sqInt liveRegisterMask)
{
	assert(BytesPerWord == 8);
	return genoperandoperand(MovePerfCnt64RL, destReg, liveRegisterMask);
}

	/* Cogit>>#MovePerfCnt64R:R:L: */
static AbstractInstruction * NoDbgRegParms
gMovePerfCnt64RRL(sqInt destRegLo, sqInt destRegHi, sqInt liveRegisterMask)
{
	assert(BytesPerWord == 4);
	return genoperandoperandoperand(MovePerfCnt64RRL, destRegLo, destRegHi, liveRegisterMask);
}


/*	Answer the address of the null byte at the end of the method map. */

	/* Cogit>>#mapEndFor: */
static usqInt NoDbgRegParms
mapEndFor(CogMethod *cogMethod)
{
    usqInt end;

	/* begin mapStartFor: */
	end = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	while ((byteAt(end)) != MapEnd) {
		end -= 1;
		assert(end > (firstMappedPCFor(cogMethod)));
	}
	return end;
}


/*	Unlinking/GC/Disassembly support */
/*	most of the time arg is a CogMethod... */

	/* Cogit>>#mapFor:performUntil:arg: */
static sqInt NoDbgRegParms
mapForperformUntilarg(CogMethod *cogMethod, sqInt (*functionSymbol)(sqInt annotation, char *mcpc, CogMethod *arg), CogMethod *arg)
{
    sqInt annotation;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	/* begin firstMappedPCFor: */
	mcpc = ((((cogMethod->cmType)) >= CMMethod)
	 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
		? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
		: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	/* begin mapStartFor: */
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {

			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask);
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = functionSymbol(annotation, (((char *) mcpc)), arg);
			if (result != 0) {
				return result;
			}
		}
		else {
			if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
			}
		}
		map -= 1;
	}
	return 0;
}


/*	Remap all object references in the closed PIC. Answer if any references
	are young.
	Set codeModified if any modifications are made. */

	/* Cogit>>#mapObjectReferencesInClosedPIC: */
static sqInt NoDbgRegParms
mapObjectReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt pc;
    sqInt refersToYoung;


	/* first we check the potential method oop load at the beginning of the CPIC */
	pc = addressOfEndOfCaseinCPIC(1, cPIC);

	/* We find the end address of the cPICNumCases'th case and can then just step forward by the case size thereafter */
	refersToYoung = remapMaybeObjRefInClosedPICAt(pc - (jumpLongByteSize(backEnd)));

	/* Next we check the potential class ref in the compare instruction, and the potential method oop load for each case. */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (remapMaybeObjRefInClosedPICAt((pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))) {
			refersToYoung = 1;
		}
		pc += cPICCaseSize;
	}
	return refersToYoung;
}


/*	Update all references to objects in the generated runtime. */

	/* Cogit>>#mapObjectReferencesInGeneratedRuntime */
static void
mapObjectReferencesInGeneratedRuntime(void)
{
    sqInt i;
    sqInt literal;
    sqInt mappedLiteral;
    usqInt mcpc;

	for (i = 0; i < runtimeObjectRefIndex; i += 1) {
		mcpc = objectReferencesInRuntime[i];
		/* begin fetchLiteralAtAnnotatedAddress:using: */
		literal = literalBeforeFollowingAddress(((AbstractInstruction *) backEnd), mcpc);
		mappedLiteral = remapObject(literal);
		if (mappedLiteral != literal) {
			/* begin setCodeModified */
#      if DUAL_MAPPED_CODE_ZONE
			codeModified = 1;
#      else
			codeModified = 1;
#      endif
			/* begin storeLiteral:atAnnotatedAddress:using: */
			storeLiteralbeforeFollowingAddress(((AbstractInstruction *) backEnd), mappedLiteral, mcpc);
			/* return self */
		}
	}
}


/*	Update all references to objects in machine code for a become.
	Unlike incrementalGC or fullGC a method that does not refer to young may
	refer to young as a result of the become operation. Unlike incrementalGC
	or fullGC the reference from a Cog method to its methodObject *must not*
	change since the two are two halves of the same object. */

	/* Cogit>>#mapObjectReferencesInMachineCodeForBecome */
static void
mapObjectReferencesInMachineCodeForBecome(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedPIC;
    sqInt hasYoungObj;
    sqInt hasYoungObjPtr;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt remappedMethod;
    sqInt result;
    CogMethod *writableCogMethod;

	hasYoungObj = 0;
	hasYoungObjPtr = ((sqInt)((&hasYoungObj)));
	codeModified = (freedPIC = 0);
	mapObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		assert(!hasYoungObj);
		if (!(((cogMethod->cmType)) == CMFree)) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			/* begin writableMethodFor: */
			writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
			(writableCogMethod->selector = remapOop((cogMethod->selector)));
			if (((cogMethod->cmType)) == CMClosedPIC) {
				if ((isYoung((cogMethod->selector)))
				 || (mapObjectReferencesInClosedPIC(cogMethod))) {
					freedPIC = 1;
					freeMethod(cogMethod);
				}
			}
			else {
				if (isYoung((cogMethod->selector))) {
					hasYoungObj = 1;
				}
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					remappedMethod = remapOop((cogMethod->methodObject));
					if (remappedMethod != ((cogMethod->methodObject))) {
						if (methodHasCogMethod(remappedMethod)) {
							error("attempt to become two cogged methods");
						}
						if (!(withoutForwardingOnandwithsendToCogit((cogMethod->methodObject), remappedMethod, (cogMethod->cmUsesPenultimateLit), methodhasSameCodeAscheckPenultimate))) {
							error("attempt to become cogged method into different method");
						}
						if ((rawHeaderOf((cogMethod->methodObject))) == (((sqInt)cogMethod))) {
							rawHeaderOfput((cogMethod->methodObject), (cogMethod->methodHeader));
							(writableCogMethod->methodHeader = rawHeaderOf(remappedMethod));
							(writableCogMethod->methodObject = remappedMethod);
							rawHeaderOfput(remappedMethod, ((sqInt)cogMethod));
						}
						else {
							assert((noAssertMethodClassAssociationOf((cogMethod->methodObject))) == (nilObject()));
							(writableCogMethod->methodHeader = rawHeaderOf(remappedMethod));
							(writableCogMethod->methodObject = remappedMethod);
						}
					}
					if (isYoung((cogMethod->methodObject))) {
						hasYoungObj = 1;
					}
				}
				/* begin mapFor:performUntil:arg: */
				
				mcpc = ((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
					? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
					: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
				/* begin mapStartFor: */
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {

						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask);
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, (((char *) mcpc)), (((CogMethod *) hasYoungObjPtr)));
						if (result != 0) {
							goto l3;
						}
					}
					else {
						if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
						}
					}
					map -= 1;
				}
	l3:	/* end mapFor:performUntil:arg: */;
				if (hasYoungObj) {
					ensureInYoungReferrers(cogMethod);
					hasYoungObj = 0;
				}
				else {
					(cogMethod->cmRefersToYoung = 0);
				}
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (freedPIC) {
		unlinkSendsToFree();
	}
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)codeBase), freeStart());
	}
}


/*	Update all references to objects in machine code for a full gc. Since
	the current (New)ObjectMemory GC makes everything old in a full GC
	a method not referring to young will not refer to young afterwards */

	/* Cogit>>#mapObjectReferencesInMachineCodeForFullGC */
static void
mapObjectReferencesInMachineCodeForFullGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *writableCogMethod;

	codeModified = 0;
	mapObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			/* begin writableMethodFor: */
			writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
			(writableCogMethod->selector = remapOop((cogMethod->selector)));
			if (((cogMethod->cmType)) == CMClosedPIC) {
				assert(!((cogMethod->cmRefersToYoung)));
				mapObjectReferencesInClosedPIC(cogMethod);
			}
			else {
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					(writableCogMethod->methodObject = remapOop((cogMethod->methodObject)));
				}
				/* begin mapFor:performUntil:arg: */
				
				mcpc = ((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
					? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
					: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
				/* begin mapStartFor: */
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {

						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask);
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, (((char *) mcpc)), 0);
						if (result != 0) {
							goto l5;
						}
					}
					else {
						if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
						}
					}
					map -= 1;
				}
	l5:	/* end mapFor:performUntil:arg: */;
							}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)codeBase), freeStart());
	}
}


/*	Update all references to objects in machine code for either a Spur
	scavenging gc
	or a Squeak V3 incremental GC. Avoid scanning all code by using the
	youngReferrers list. In a young gc a method referring to young may no
	longer refer to young, but a
	method not referring to young cannot and will not refer to young
	afterwards.  */

	/* Cogit>>#mapObjectReferencesInMachineCodeForYoungGC */
static void
mapObjectReferencesInMachineCodeForYoungGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt hasYoungObj;
    sqInt hasYoungObjPtr;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    usqInt pointer;
    sqInt result;
    CogMethod *writableCogMethod;
    sqInt zoneIsWritable;

	codeModified = (zoneIsWritable = (hasYoungObj = 0));
	hasYoungObjPtr = ((sqInt)((&hasYoungObj)));
	pointer = youngReferrers();
	while (pointer < limitAddress) {
		assert(!hasYoungObj);
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (((cogMethod->cmType)) == CMFree) {
			assert(!((cogMethod->cmRefersToYoung)));
		}
		else {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			if ((cogMethod->cmRefersToYoung)) {
				assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
				 || (isCMOpenPIC(((CogBlockMethod *) cogMethod))));
				if (!zoneIsWritable) {
					/* begin ensureWritableCodeZone */
					zoneIsWritable = 1;
				}
				/* begin writableMethodFor: */
				writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
				(writableCogMethod->selector = remapOop((cogMethod->selector)));
				if (isYoung((cogMethod->selector))) {
					hasYoungObj = 1;
				}
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					(writableCogMethod->methodObject = remapOop((cogMethod->methodObject)));
					if (isYoung((cogMethod->methodObject))) {
						hasYoungObj = 1;
					}
				}
				/* begin mapFor:performUntil:arg: */
				
				mcpc = ((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
					? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
					: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
				/* begin mapStartFor: */
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {

						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask);
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, (((char *) mcpc)), (((void *)hasYoungObjPtr)));
						if (result != 0) {
							goto l4;
						}
					}
					else {
						if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
						}
					}
					map -= 1;
				}
	l4:	/* end mapFor:performUntil:arg: */;
				if (hasYoungObj) {
					hasYoungObj = 0;
				}
				else {
					(writableCogMethod->cmRefersToYoung = 0);
				}
			}
		}
		pointer += BytesPerWord;
	}
	pruneYoungReferrers();
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
}


/*	Update all references to objects in machine code. */

	/* Cogit>>#mapObjectReferencesInMachineCode: */
void
mapObjectReferencesInMachineCode(sqInt gcMode)
{
	switch (gcMode) {
	case GCModeNewSpace:
		
		/* N.B. do *not* ensureWritableCodeZone for every scavenge. */
		mapObjectReferencesInMachineCodeForYoungGC();
		break;
	case GCModeFull:
		/* begin ensureWritableCodeZone */
		mapObjectReferencesInMachineCodeForFullGC();
		break;
	case GCModeBecome:
		/* begin ensureWritableCodeZone */
		mapObjectReferencesInMachineCodeForBecome();
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	mapPerMethodProfile();
	if (!(asserta((freeStart()) <= (youngReferrers())))) {
		error("youngReferrers list overflowed");
	}
}


/*	Mark objects in machine-code of marked methods (or open PICs with marked
	selectors). 
 */

	/* Cogit>>#markAndTraceMachineCodeOfMarkedMethods */
void
markAndTraceMachineCodeOfMarkedMethods(void)
{
    sqInt annotation;
    sqInt annotation1;
    CogMethod *cogMethod;
    usqInt map;
    usqInt map1;
    sqInt mapByte;
    sqInt mapByte1;
    sqInt mcpc;
    sqInt mcpc1;
    sqInt result;
    sqInt result1;

	if (leakCheckFullGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	codeModified = 0;
	markAndTraceObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) >= CMMethod)
		 && (isMarked((cogMethod->methodObject)))) {
			/* begin markAndTraceLiteralsIn: */
			assert(((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
			 && (isMarked((cogMethod->methodObject))))
			 || ((isCMOpenPIC(((CogBlockMethod *) cogMethod)))
			 && ((isImmediate((cogMethod->selector)))
			 || (isMarked((cogMethod->selector))))));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));
			/* begin maybeMarkIRCsIn: */
			/* begin mapFor:performUntil:arg: */
			
			mcpc = ((((cogMethod->cmType)) >= CMMethod)
			 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			/* begin mapStartFor: */
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = markLiteralspcmethod(annotation, (((char *) mcpc)), cogMethod);
					if (result != 0) {
						goto l4;
					}
				}
				else {
					if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
					}
				}
				map -= 1;
			}
	l4:	/* end markAndTraceLiteralsIn: */;
		}
		if ((((cogMethod->cmType)) == CMOpenPIC)
		 && ((isImmediate((cogMethod->selector)))
		 || (isMarked((cogMethod->selector))))) {
			/* begin markAndTraceLiteralsIn: */
			assert(((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
			 && (isMarked((cogMethod->methodObject))))
			 || ((isCMOpenPIC(((CogBlockMethod *) cogMethod)))
			 && ((isImmediate((cogMethod->selector)))
			 || (isMarked((cogMethod->selector))))));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));
			/* begin maybeMarkIRCsIn: */
			/* begin mapFor:performUntil:arg: */
			
			mcpc1 = ((((cogMethod->cmType)) >= CMMethod)
			 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			/* begin mapStartFor: */
			map1 = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte1 = byteAt(map1))) != MapEnd) {
				if (mapByte1 >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc1 += (mapByte1 & DisplacementMask);
					if ((((annotation1 = ((usqInt)(mapByte1)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte1 = byteAt(map1 - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation1 += mapByte1 & DisplacementMask;
						map1 -= 1;
					}
					result1 = markLiteralspcmethod(annotation1, (((char *) mcpc1)), cogMethod);
					if (result1 != 0) {
						goto l7;
					}
				}
				else {
					if (mapByte1 < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc1 += (((sqInt)((usqInt)((mapByte1 - DisplacementX2N)) << AnnotationShift)));
					}
				}
				map1 -= 1;
			}
	l7:	/* end markAndTraceLiteralsIn: */;
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (leakCheckFullGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
}


/*	Mark and trace any object references in the generated run-time. */

	/* Cogit>>#markAndTraceObjectReferencesInGeneratedRuntime */
static void
markAndTraceObjectReferencesInGeneratedRuntime(void)
{
    sqInt i;
    sqInt literal;
    usqInt mcpc;

	for (i = 0; i < runtimeObjectRefIndex; i += 1) {
		mcpc = objectReferencesInRuntime[i];
		/* begin fetchLiteralAtAnnotatedAddress:using: */
		literal = literalBeforeFollowingAddress(((AbstractInstruction *) backEnd), mcpc);
		markAndTraceLiteralinatpc(literal, ((CogMethod *) null), ((usqInt)mcpc));
	}
}


/*	Mark and trace objects in the argument and free if it is appropriate.
	Answer if the method has been freed. firstVisit is a hint used to avoid
	scanning methods we've already seen. False positives are fine.
	For a CMMethod this
	frees if the bytecode method isnt marked,
	marks and traces object literals and selectors,
	unlinks sends to targets that should be freed.
	For a CMClosedPIC this
	frees if it refers to anything that should be freed or isn't marked.
	For a CMOpenPIC this
	frees if the selector isn't marked. */
/*	this recurses at most one level down */

	/* Cogit>>#markAndTraceOrFreeCogMethod:firstVisit: */
static sqInt NoDbgRegParms
markAndTraceOrFreeCogMethodfirstVisit(CogMethod *cogMethod, sqInt firstVisit)
{
    sqInt annotation;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (((cogMethod->cmType)) == CMFree) {
		return 1;
	}
	assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
	if (((cogMethod->cmType)) >= CMMethod) {
		if (!(isMarked((cogMethod->methodObject)))) {
			/* begin ensureWritableCodeZone */
			freeMethod(cogMethod);
			return 1;
		}
		if (firstVisit) {
			/* begin markLiteralsAndUnlinkUnmarkedSendsIn: */
			assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
			assert(isMarked((cogMethod->methodObject)));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));
			/* begin maybeMarkIRCsIn: */
			/* begin mapFor:performUntil:arg: */
			
			mcpc = ((((cogMethod->cmType)) >= CMMethod)
			 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			/* begin mapStartFor: */
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = markLiteralsAndUnlinkIfUnmarkedSendpcmethod(annotation, (((char *) mcpc)), cogMethod);
					if (result != 0) {
						goto l3;
					}
				}
				else {
					if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
					}
				}
				map -= 1;
			}
	l3:	/* end markLiteralsAndUnlinkUnmarkedSendsIn: */;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		if (!(closedPICRefersToUnmarkedObject(cogMethod))) {
			return 0;
		}
		/* begin ensureWritableCodeZone */
		freeMethod(cogMethod);
		return 1;
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		if (isMarked((cogMethod->selector))) {
			return 0;
		}
		/* begin ensureWritableCodeZone */
		freeMethod(cogMethod);
		return 1;
	}
	assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
	 || ((isCMClosedPIC(((CogBlockMethod *) cogMethod)))
	 || (isCMOpenPIC(((CogBlockMethod *) cogMethod)))));
	return 0;
}


/*	If entryPoint is that of some method, then mark and trace objects in it
	and free if it is appropriate.
	Answer if the method has been freed. */

	/* Cogit>>#markAndTraceOrFreePICTarget:in: */
static sqInt NoDbgRegParms
markAndTraceOrFreePICTargetin(sqInt entryPoint, CogMethod *cPIC)
{
    CogMethod *targetMethod;

	assert((entryPoint > methodZoneBase)
	 && (entryPoint < (freeStart())));
	if (((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
	 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {
		return 0;
	}
	targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
	assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
	 || (isCMFree(((CogBlockMethod *) targetMethod))));
	return markAndTraceOrFreeCogMethodfirstVisit(targetMethod, (((usqInt)targetMethod)) > (((usqInt)cPIC)));
}


/*	Mark and trace literals. Unlink sends that have unmarked cache tags or
	targets. 
 */

	/* Cogit>>#markLiteralsAndUnlinkIfUnmarkedSend:pc:method: */
static sqInt NoDbgRegParms
markLiteralsAndUnlinkIfUnmarkedSendpcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    usqInt cacheTag1;
    sqInt cacheTagMarked;
    sqInt entryPoint1;
    sqInt literal;
    sqInt offset1;
    sqInt *sendTable1;
    sqInt tagCouldBeObj1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	literal = 0;
	if (annotation == IsObjectReference) {
		/* begin fetchLiteralAtAnnotatedAddress:using: */
		literal = literalBeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)mcpc));
		if (markAndTraceLiteralinatpc(literal, ((CogMethod *) cogMethod), ((usqInt)mcpc))) {
			codeModified = 1;
		}
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		
		cacheTag1 = literal32BeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 5)));

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 0;
		cacheTagMarked = tagCouldBeObj1;
		if (entryPoint1 > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint1 - offset1));
			if ((!cacheTagMarked)
			 || (markAndTraceOrFreeCogMethodfirstVisit(targetMethod1, (((usqInt)targetMethod1)) > (((usqInt)mcpc))))) {

				/* Either the cacheTag is unmarked (e.g. new class) or the target
				   has been freed (because it is unmarked), so unlink the send. */
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
				markAndTraceLiteralinat((targetMethod1->selector), targetMethod1, (&((targetMethod1->selector))));
			}
		}
		else {

			/* cacheTag is selector */
					}
	}
	return 0;
}


/*	Mark and trace literals.
	Additionally in Newspeak, void push implicits that have unmarked classes. */

	/* Cogit>>#markLiterals:pc:method: */
static sqInt NoDbgRegParms
markLiteralspcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    usqInt cacheTag1;
    sqInt entryPoint1;
    sqInt literal;
    sqInt tagCouldBeObj1;

	literal = 0;
	if (annotation == IsObjectReference) {
		/* begin fetchLiteralAtAnnotatedAddress:using: */
		literal = literalBeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)mcpc));
		if (markAndTraceLiteralinatpc(literal, cogMethod, ((usqInt)mcpc))) {
			codeModified = 1;
		}
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		
		cacheTag1 = literal32BeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 5)));

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 0;
			}
	return 0;
}

	/* Cogit>>#markMethodAndReferents: */
void
markMethodAndReferents(CogBlockMethod *aCogMethod)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *writableMethod;

	assert((isCMMethodEtAl(aCogMethod))
	 || (isCMBlock(aCogMethod)));
	cogMethod = (((aCogMethod->cmType)) >= CMMethod
		? ((CogMethod *) aCogMethod)
		: cmHomeMethod(aCogMethod));
	/* begin writableMethodFor: */
	writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
	(writableMethod->cmUsageCount = CMMaxUsageCount);
	/* begin mapFor:performUntil:arg: */
	
	mcpc = ((((cogMethod->cmType)) >= CMMethod)
	 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
		? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
		: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	/* begin mapStartFor: */
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {

			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask);
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = incrementUsageOfTargetIfLinkedSendmcpcignored(annotation, (((char *) mcpc)), 0);
			if (result != 0) {
				return;
			}
		}
		else {
			if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
			}
		}
		map -= 1;
	}
	return;
}

	/* Cogit>>#maxCogMethodAddress */
usqInt
maxCogMethodAddress(void)
{
	return ((usqInt)(limitZony()));
}

	/* Cogit>>#maximumDistanceFromCodeZone: */
static sqInt NoDbgRegParms
maximumDistanceFromCodeZone(sqInt anAddress)
{
	return (anAddress > codeBase
		? anAddress - codeBase
		: limitAddress - anAddress);
}


/*	If this is the Newspeak VM and the objectRepresentation supports pinning
	then allocate space for the implicit receiver caches on the heap. */

	/* Cogit>>#maybeAllocAndInitIRCs */
static sqInt
maybeAllocAndInitIRCs(void)
{
	return 1;
}


/*	Check that the header fields are consistent with the type.
	Answer 0 if it is ok, otherwise answer a code for the error. */

	/* Cogit>>#maybeFreeCogMethodDoesntLookKosher: */
static sqInt NoDbgRegParms
maybeFreeCogMethodDoesntLookKosher(CogMethod *cogMethod)
{
    sqInt result;

	result = cogMethodDoesntLookKosher(cogMethod);
	return (result == 2
		? 0
		: result);
}

	/* Cogit>>#mclassCouldBeContext */
static sqInt
mclassCouldBeContext(void)
{
	if (receiverTags < 0) {
		receiverTags = receiverTagBitsForMethod(methodObj);
	}
	return ((receiverTags & ((1U << (numTagBits())))) != 0);
}

	/* Cogit>>#mclassIsSmallInteger */
static sqInt
mclassIsSmallInteger(void)
{
	if (receiverTags < 0) {
		receiverTags = receiverTagBitsForMethod(methodObj);
	}
	return (((receiverTags) & 7) == 1);
}


/*	Answer the absolute machine code pc matching the zero-relative
	bytecode pc of a backward branch in cogMethod, given the start
	of the bytecodes for cogMethod's block or method object. */

	/* Cogit>>#mcPCForBackwardBranch:startBcpc:in: */
usqInt
mcPCForBackwardBranchstartBcpcin(sqInt bcpc, sqInt startbcpc, CogBlockMethod *cogMethod)
{
    sqInt aMethodHeader;
    sqInt aMethodHeader1;
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc1;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    usqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt targetPC;

	latestContinuation = 0;
	/* begin mapFor:bcpc:performUntil:arg: */
	assert(((cogMethod->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	result = (((((0 + (((sqInt)((usqInt)(HasBytecodePC) << 1)))) & 1) != 0))
	 && ((((sqInt)(((void *)bcpc)))) == startbcpc)
		? ((sqInt)(((char *) mcpc)))
		: 0);
	if (result != 0) {
		return result;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc1 = startbcpc;
	if (((cogMethod->cmType)) >= CMMethod) {
		/* begin cmIsFullBlock */
		isInBlock = (cogMethod->cpicHasMNUCaseOrCMIsFullBlock);
		homeMethod = ((CogMethod *) cogMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		/* begin mapStartFor: */
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader = (homeMethod->methodHeader);
		bsOffset = (headerIndicatesAlternateBytecodeSet(aMethodHeader)
						? 0x100
						: 0);
		bcpc1 += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc1 == ((cogMethod->startpc)));
		homeMethod = cmHomeMethod(cogMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc1 = startbcpc - ((headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
		? AltBlockCreationBytecodeSize
		: BlockCreationBytecodeSize));
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader1 = (homeMethod->methodHeader);
		bsOffset = (headerIndicatesAlternateBytecodeSet(aMethodHeader1)
						? 0x100
						: 0);
		byte = (fetchByteofObject(bcpc1, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		/* begin nextBytecodePCFor:at:exts:in: */
		endbcpc = (bcpc1 + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bcpc1, -1, aMethodObj))
	: 0));
		bcpc1 = startbcpc;
	}
	nExts = 0;
	enumeratingCogMethod = homeMethod;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask);
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc1, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc1 >= endbcpc) {
							return 0;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc1 >= latestContinuation)) {
							return 0;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							
							distance = ((descriptor->spanFunction))(descriptor, bcpc1, nExts, aMethodObj);
							targetPC = (bcpc1 + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					/* begin nextBytecodePCFor:at:exts:in: */
					nextBcpc = (bcpc1 + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bcpc1, nExts, aMethodObj))
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc1 = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && ((assert(((descriptor->spanFunction)) != null),
				(((descriptor->spanFunction))(descriptor, bcpc1, nExts, aMethodObj)) < 0));
				result = ((((((isBackwardBranch
					? (((sqInt)((usqInt)(annotation) << 1))) + 1
					: ((sqInt)((usqInt)(annotation) << 1)))) & 1) != 0))
				 && ((((sqInt)(((void *)bcpc)))) == ((isBackwardBranch
					? bcpc1 - (2 * nExts)
					: bcpc1)))
					? ((sqInt)(((char *) mcpc)))
					: 0);
				if (result != 0) {
					return result;
				}
				bcpc1 = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
			}
		}
		map -= 1;
	}
	return 0;
}


/*	For the purposes of become: see if the two methods are similar, i.e. can
	be safely becommed.
	This is pretty strict. All literals and bytecodes must be identical. Only
	trailer bytes and header
	flags can differ. */

	/* Cogit>>#method:hasSameCodeAs:checkPenultimate: */
static sqInt NoDbgRegParms
methodhasSameCodeAscheckPenultimate(sqInt methodA, sqInt methodB, sqInt comparePenultimateLiteral)
{
    sqInt bi;
    sqInt endPCA;
    sqInt headerA;
    sqInt headerB;
    sqInt li;
    sqInt numLitsA;

	headerA = methodHeaderOf(methodA);
	headerB = methodHeaderOf(methodB);
	numLitsA = literalCountOfMethodHeader(headerA);
	endPCA = endPCOf(methodA);
	if (((argumentCountOfMethodHeader(headerA)) != (argumentCountOfMethodHeader(headerB)))
	 || (((temporaryCountOfMethodHeader(headerA)) != (temporaryCountOfMethodHeader(headerB)))
	 || (((primitiveIndexOfMethodheader(methodA, headerA)) != (primitiveIndexOfMethodheader(methodB, headerB)))
	 || ((numLitsA != (literalCountOfMethodHeader(headerB)))
	 || (endPCA > (numBytesOf(methodB))))))) {
		return 0;
	}
	for (li = 1; li < numLitsA; li += 1) {
		if ((fetchPointerofObject(li, methodA)) != (fetchPointerofObject(li, methodB))) {
			if ((li < (numLitsA - 1))
			 || (comparePenultimateLiteral)) {
				return 0;
			}
		}
	}
	for (bi = (startPCOfMethodHeader(headerA)); bi <= endPCA; bi += 1) {
		if ((fetchByteofObject(bi, methodA)) != (fetchByteofObject(bi, methodB))) {
			return 0;
		}
	}
	return 1;
}

	/* Cogit>>#mnuOffset */
sqInt
mnuOffset(void)
{
	return missOffset;
}

	/* Cogit>>#NativePopR: */
static AbstractInstruction * NoDbgRegParms
gNativePopR(sqInt reg)
{
	return genoperand(PopR, reg);
}

	/* Cogit>>#NativePushR: */
static AbstractInstruction * NoDbgRegParms
gNativePushR(sqInt reg)
{
	return genoperand(PushR, reg);
}

	/* Cogit>>#NativeRetN: */
static AbstractInstruction * NoDbgRegParms
gNativeRetN(sqInt offset)
{
	return genoperand(RetN, offset);
}

	/* Cogit>>#needsFrameIfImmutability: */
static sqInt NoDbgRegParms
needsFrameIfImmutability(sqInt stackDelta)
{
	return IMMUTABILITY;
}

	/* Cogit>>#needsFrameIfInBlock: */
static sqInt NoDbgRegParms
needsFrameIfInBlock(sqInt stackDelta)
{
	return inBlock > 0;
}

	/* Cogit>>#needsFrameNever: */
static sqInt NoDbgRegParms
needsFrameNever(sqInt stackDelta)
{
	return 0;
}

	/* Cogit>>#noAssertMethodClassAssociationOf: */
static sqInt NoDbgRegParms
noAssertMethodClassAssociationOf(sqInt methodPointer)
{
	return literalofMethod((literalCountOfMethodHeader(noAssertHeaderOf(methodPointer))) - 1, methodPointer);
}


/*	Check that no method is maximally marked. A maximal mark is an indication
	the method has been scanned to increase the usage count of its referent
	methods.  */

	/* Cogit>>#noCogMethodsMaximallyMarked */
static sqInt
noCogMethodsMaximallyMarked(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->cmUsageCount)) == CMMaxUsageCount)) {
			return 0;
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return 1;
}


/*	Answer if all targets in the PIC are in-use methods. */

	/* Cogit>>#noTargetsFreeInClosedPIC: */
static sqInt NoDbgRegParms
noTargetsFreeInClosedPIC(CogMethod *cPIC)
{
	return !(cPICHasFreedTargets(cPIC));
}

	/* Cogit>>#OrCq:R:R: */
static AbstractInstruction * NoDbgRegParms
gOrCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	if (srcReg == destReg) {
		/* begin gen:quickConstant:operand: */
		return genoperandoperand(OrCqR, quickConstant, destReg);
	}
	first = genoperandoperand(MoveRR, srcReg, destReg);
	/* begin gen:quickConstant:operand: */
	genoperandoperand(OrCqR, quickConstant, destReg);
	return first;
}


/*	Store the generated machine code, answering the last address */

	/* Cogit>>#outputInstructionsAt: */
static sqInt NoDbgRegParms
outputInstructionsAt(sqInt startAddress)
{
    sqInt absoluteAddress;
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt j;

	/* begin ensureWritableCodeZone */
	absoluteAddress = startAddress;
	for (i = 0; i < opcodeIndex; i += 1) {
		maybeBreakGeneratingInstructionWithIndex(i);
		abstractInstruction = abstractInstructionAt(i);
		assert(((abstractInstruction->address)) == absoluteAddress);
		/* begin outputMachineCodeAt: */
		for (j = 0; j < ((abstractInstruction->machineCodeSize)); j += 1) {
			byteAtput(absoluteAddress + j, ((abstractInstruction->machineCode))[j]);
		}
		absoluteAddress += (abstractInstruction->machineCodeSize);
	}
	return absoluteAddress;
}


/*	Output instructions generated for one of the generated run-time routines,
	a trampoline, etc
 */

	/* Cogit>>#outputInstructionsForGeneratedRuntimeAt: */
static sqInt NoDbgRegParms
outputInstructionsForGeneratedRuntimeAt(sqInt startAddress)
{
    sqInt endAddress;
    sqInt size;

	computeMaximumSizes();
	(methodLabel->address = startAddress);
	size = generateInstructionsAt(startAddress);
	endAddress = outputInstructionsAt(startAddress);
	assert((startAddress + size) == endAddress);
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	return startAddress;
}


/*	Code entry closed PIC full or miss to an instance of a young class or to a
	young target method.
	Attempt to patch the send site to an open PIC. Answer if the attempt
	succeeded; in fact it will
	only return if the attempt failed.
	The stack looks like:
	receiver
	args
	sp=>	sender return address */

	/* Cogit>>#patchToOpenPICFor:numArgs:receiver: */
sqInt
patchToOpenPICFornumArgsreceiver(sqInt selector, sqInt numArgs, sqInt receiver)
{
    sqInt extent;
    CogMethod *oPIC;
    sqInt outerReturn;


	/* See if an Open PIC is already available. */
	outerReturn = stackTop();
	oPIC = openPICWithSelector(selector);
	if (!oPIC) {

		/* otherwise attempt to create an Open PIC. */
		oPIC = cogOpenPICSelectornumArgs(selector, numArgs);
		if ((((((sqInt)oPIC)) >= MaxNegativeErrorCode) && ((((sqInt)oPIC)) <= -1))) {

			/* For some reason the PIC couldn't be generated, most likely a lack of code memory. */
			if ((((sqInt)oPIC)) == InsufficientCodeSpace) {
				callForCogCompiledCodeCompaction();
			}
			return 0;
		}
	}
	/* begin ensureWritableCodeZone */
	extent = rewriteInlineCacheAttagtarget(backEnd, outerReturn, inlineCacheValueForSelectorin(backEnd, selector, mframeHomeMethodExport()), (((sqInt)oPIC)) + cmEntryOffset);
	flushICacheFromto(backEnd, (((usqInt)outerReturn)) - extent, ((usqInt)outerReturn));
	flushICacheFromto(backEnd, ((usqInt)oPIC), (((usqInt)oPIC)) + openPICSize);
	executeCogMethodfromLinkedSendWithReceiver(oPIC, receiver);
	return 1;
}


/*	This value is used to decide between MNU processing
	or interpretation in the closed PIC aborts. */

	/* Cogit>>#picAbortDiscriminatorValue */
static sqInt
picAbortDiscriminatorValue(void)
{
	return 0;
}


/*	Answer the start of the abort sequence for invoking the interpreter in a
	closed PIC.
 */

	/* Cogit>>#picInterpretAbortOffset */
static sqInt
picInterpretAbortOffset(void)
{
	return (interpretOffset()) - (callInstructionByteSize(backEnd));
}

	/* Cogit>>#previousInstruction */
static AbstractInstruction *
previousInstruction(void)
{
	assert(opcodeIndex > 0);
	return abstractInstructionAt(opcodeIndex - 1);
}


/*	useful for debugging */

	/* Cogit>>#printCogMethodFor: */
void
printCogMethodFor(void *address)
{
    CogMethod *cogMethod;

	cogMethod = methodFor(address);
	if (cogMethod == null) {
		if ((codeEntryFor(address)) == null) {
			print("not a method");
			cr();
		}
		else {
			print("trampoline ");
			print(codeEntryNameFor(address));
			cr();
		}
	}
	else {
		printCogMethod(cogMethod);
	}
}


/*	useful for debugging */

	/* Cogit>>#printTrampolineTable */
void
printTrampolineTable(void)
{
    sqInt i;

	for (i = 0; i < trampolineTableIndex; i += 2) {
		fprintf(getTranscript(),
				"%p: %s\n",
				((void *)(trampolineAddresses[i + 1])),
				((char *)(trampolineAddresses[i])));
	}
}

	/* Cogit>>#processorHasDivQuoRemAndMClassIsSmallInteger */
static sqInt
processorHasDivQuoRemAndMClassIsSmallInteger(void)
{
	return mclassIsSmallInteger();
}

	/* Cogit>>#processorHasMultiplyAndMClassIsSmallInteger */
static sqInt
processorHasMultiplyAndMClassIsSmallInteger(void)
{
	return mclassIsSmallInteger();
}

	/* Cogit>>#recordGeneratedRunTime:address: */
static void NoDbgRegParms
recordGeneratedRunTimeaddress(char *aString, sqInt address)
{
	assert((trampolineTableIndex + 2) <= (NumTrampolines * 2));
	trampolineAddresses[trampolineTableIndex] = aString;
	trampolineAddresses[trampolineTableIndex + 1] = (((char *) address));

	/* self printTrampolineTable */
	trampolineTableIndex += 2;
}


/*	This one for C support code. */

	/* Cogit>>#recordPrimTraceFunc */
sqInt
recordPrimTraceFunc(void)
{
	return recordPrimTrace();
}

	/* Cogit>>#recordRunTimeObjectReferences */
static void
recordRunTimeObjectReferences(void)
{
    sqInt i;
    AbstractInstruction *instruction;

	for (i = 0; i < opcodeIndex; i += 1) {
		instruction = abstractInstructionAt(i);
		if (((instruction->annotation)) == IsObjectReference) {
			assert(runtimeObjectRefIndex < NumObjRefsInRuntime);
			assert(!hasYoungReferent);
			if (hasYoungReferent) {
				error("attempt to generate run-time routine containing young object reference.  Cannot initialize Cogit run-time.");
			}
			objectReferencesInRuntime[runtimeObjectRefIndex] = (((usqInt)(((instruction->address)) + ((instruction->machineCodeSize)))));
			runtimeObjectRefIndex += 1;
		}
	}
}


/*	N.B. (self registerMaskFor: NoReg) = 0 */

	/* Cogit>>#registerMaskFor: */
static sqInt NoDbgRegParms
registerMaskFor(sqInt reg)
{
	return ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
}

	/* Cogit>>#registerMaskFor:and: */
static sqInt NoDbgRegParms
registerMaskForand(sqInt reg1, sqInt reg2)
{
	return (1ULL << reg1) | (1ULL << reg2);
}

	/* Cogit>>#registerMaskFor:and:and:and: */
static sqInt NoDbgRegParms
registerMaskForandandand(sqInt reg1, sqInt reg2, sqInt reg3, sqInt reg4)
{
	return (((1ULL << reg1) | (1ULL << reg2)) | (1ULL << reg3)) | (1ULL << reg4);
}

	/* Cogit>>#relocateCallsAndSelfReferencesInMethod: */
static void NoDbgRegParms
relocateCallsAndSelfReferencesInMethod(CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt callDelta;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqLong refDelta;
    sqInt result;

	refDelta = (cogMethod->objectHeader);
	callDelta = refDelta;
	assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
	 || (isCMOpenPIC(((CogBlockMethod *) cogMethod))));
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)cogMethod)) + missOffset)) == ((isCMMethodEtAl(((CogBlockMethod *) cogMethod))
		? methodAbortTrampolineFor((cogMethod->cmNumArgs))
		: picAbortTrampolineFor((cogMethod->cmNumArgs)))));
	relocateCallBeforeReturnPCby(backEnd, (((sqInt)cogMethod)) + missOffset, -callDelta);
	/* begin mapFor:performUntil:arg: */
	
	mcpc = ((((cogMethod->cmType)) >= CMMethod)
	 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
		? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
		: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	/* begin mapStartFor: */
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {

			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask);
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = relocateIfCallOrMethodReferencemcpcdelta(annotation, (((char *) mcpc)), (((void *)refDelta)));
			if (result != 0) {
				return;
			}
		}
		else {
			if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
			}
		}
		map -= 1;
	}
	return;
}

	/* Cogit>>#relocateCallsInClosedPIC: */
static void NoDbgRegParms
relocateCallsInClosedPIC(CogMethod *cPIC)
{
    sqInt callDelta;
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    sqInt pc1;
    sqLong refDelta;
    CogMethod *targetMethod;

	refDelta = (cPIC->objectHeader);
	callDelta = refDelta;
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)cPIC)) + missOffset)) == (picAbortTrampolineFor((cPIC->cmNumArgs))));
	relocateCallBeforeReturnPCby(backEnd, (((sqInt)cPIC)) + missOffset, -callDelta);
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (i == 1) {
			entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		}
		else {
			/* begin jumpLongConditionalTargetBeforeFollowingAddress: */
			entryPoint = jumpLongTargetBeforeFollowingAddress(((AbstractInstruction *) backEnd), pc);
		}
		if (((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
		 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {

			/* Interpret/MNU */
					}
		else {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert(isCMMethodEtAl(((CogBlockMethod *) targetMethod)));
			if (i == 1) {
				relocateJumpLongBeforeFollowingAddressby(backEnd, pc, -(callDelta - ((targetMethod->objectHeader))));
			}
			else {
				relocateJumpLongConditionalBeforeFollowingAddressby(backEnd, pc, -(callDelta - ((targetMethod->objectHeader))));
			}
		}
	}
	assert(((cPIC->cPICNumCases)) > 0);
	/* begin relocateMethodReferenceBeforeAddress:by: */
	pc1 = (addressOfEndOfCaseinCPIC(2, cPIC)) + 7 /* loadPICLiteralByteSize */;
	assert((((byteAt(pc1 - 6)) == 141)
	 && (((byteAt(pc1 - 5)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7))))
	 || (((byteAt(pc1 - 8)) == 141)
	 && (((byteAt(pc1 - 7)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7)))));
	relocateJumpLongBeforeFollowingAddressby(backEnd, (((sqInt)cPIC)) + cPICEndOfCodeOffset, -callDelta);
}


/*	To placate the C static type system... */

	/* Cogit>>#relocateIfCallOrMethodReference:mcpc:delta: */
static sqInt NoDbgRegParms
relocateIfCallOrMethodReferencemcpcdelta(sqInt annotation, char *mcpc, CogMethod *refDeltaArg)
{
    sqInt callDelta;
    sqInt entryPoint;
    sqInt offset1;
    sqInt pc;
    sqInt refDelta;
    sqInt *sendTable1;
    CogMethod *targetMethod;
    sqInt unlinkedRoutine;

	refDelta = ((sqInt) refDeltaArg);
	callDelta = refDelta;
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint <= methodZoneBase) {

			/* send is not linked; just relocate */
			relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -callDelta);
			return 0;
		}
		/* begin offsetAndSendTableFor:annotation:into: */
		if (annotation == IsSendCall) {
			offset1 = cmEntryOffset;
			sendTable1 = ordinarySendTrampolines;
		}
		else {
			if (annotation == IsDirectedSuperSend) {
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = directedSuperSendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperBindingSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperBindingSendTrampolines;
				}
				else {
					assert(annotation == IsSuperSend);
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = superSendTrampolines;
				}
			}
		}
		targetMethod = ((CogMethod *) (entryPoint - offset1));
		if (!(((targetMethod->cmType)) == CMFree)) {

			/* send target not freed; just relocate. */
			relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -(callDelta - ((targetMethod->objectHeader))));
			
			/* See comment in planCompaction */
			restorePICUsageCount(targetMethod);
			return 0;
		}
		unlinkedRoutine = sendTable1[((((targetMethod->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod->cmNumArgs)) : (NumSendTrampolines - 1))];
		unlinkedRoutine -= callDelta;
		rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod->selector), enumeratingCogMethod), unlinkedRoutine);
		return 0;
	}
	if (annotation == IsRelativeCall) {
		relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -callDelta);
		return 0;
	}
	if (annotation == IsAbsPCReference) {
		/* begin relocateMethodReferenceBeforeAddress:by: */
		pc = ((sqInt)mcpc);
		assert((((byteAt(pc - 6)) == 141)
		 && (((byteAt(pc - 5)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7))))
		 || (((byteAt(pc - 8)) == 141)
		 && (((byteAt(pc - 7)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7)))));
	}
	return 0;
}


/*	to placate the C static type system... */

	/* Cogit>>#remapIfObjectRef:pc:hasYoung: */
static sqInt NoDbgRegParms
remapIfObjectRefpchasYoung(sqInt annotation, char *mcpc, CogMethod *hasYoungPtr)
{
    usqInt cacheTag1;
    sqInt entryPoint1;
    sqInt literal;
    sqInt mappedCacheTag;
    sqInt mappedLiteral;
    sqInt offset1;
    sqInt *sendTable1;
    sqInt tagCouldBeObj1;
    CogMethod *targetMethod1;

	if (annotation == IsObjectReference) {
		/* begin fetchLiteralAtAnnotatedAddress:using: */
		literal = literalBeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)mcpc));
		if (couldBeObject(literal)) {
			mappedLiteral = remapObject(literal);
			if (literal != mappedLiteral) {
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif
				/* begin storeLiteral:atAnnotatedAddress:using: */
				storeLiteralbeforeFollowingAddress(((AbstractInstruction *) backEnd), mappedLiteral, ((usqInt)mcpc));
				/* return self */
			}
			if ((hasYoungPtr != 0)
			 && (isYoung(mappedLiteral))) {
				(*((sqInt *) hasYoungPtr) = 1);
			}
		}
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		
		cacheTag1 = literal32BeforeFollowingAddress(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 5)));

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 0;
		if (tagCouldBeObj1
		 && (couldBeObject(cacheTag1))) {
			mappedCacheTag = remapObject(cacheTag1);
			if (cacheTag1 != mappedCacheTag) {
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif
				rewriteInlineCacheTagat(backEnd, mappedCacheTag, ((usqInt)mcpc));
			}
			if ((hasYoungPtr != 0)
			 && (isYoung(mappedCacheTag))) {
				(*((sqInt *) hasYoungPtr) = 1);
			}
		}
		if (hasYoungPtr != 0) {

			/* Since the unlinking routines may rewrite the cacheTag to the send's selector, and
			   since they don't have the cogMethod to hand and can't add it to youngReferrers,
			   the method must remain in youngReferrers if the targetMethod's selector is young. */
			if (entryPoint1 > methodZoneBase) {

				/* It's a linked send. */
				/* begin targetMethodAndSendTableFor:annotation:into: */
				
				if (annotation == IsSendCall) {
					offset1 = cmEntryOffset;
					sendTable1 = ordinarySendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperSendTrampolines;
					}
					else {
						if (annotation == IsDirectedSuperBindingSend) {
							offset1 = cmNoCheckEntryOffset;
							sendTable1 = directedSuperBindingSendTrampolines;
						}
						else {
							assert(annotation == IsSuperSend);
							offset1 = cmNoCheckEntryOffset;
							sendTable1 = superSendTrampolines;
						}
					}
				}
				targetMethod1 = ((CogMethod *) (entryPoint1 - offset1));
				if (isYoung((targetMethod1->selector))) {
					(*((sqInt *) hasYoungPtr) = 1);
				}
			}
		}
	}
	return 0;
}


/*	Remap a potential object reference from a closed PIC.
	This may be an object reference, an inline cache tag or null.
	Answer if the updated literal is young.
	mcpc is the address of the next instruction following either
	the load of the method literal or the compare of the class tag. */

	/* Cogit>>#remapMaybeObjRefInClosedPICAt: */
static sqInt NoDbgRegParms
remapMaybeObjRefInClosedPICAt(sqInt mcpc)
{
    sqInt object;
    sqInt subject;

	object = literalBeforeFollowingAddress(backEnd, mcpc);
	if (!(couldBeObject(object))) {
		return 0;
	}
	subject = remapOop(object);
	if (object != subject) {
		/* begin setCodeModified */
#    if DUAL_MAPPED_CODE_ZONE
		codeModified = 1;
#    else
		codeModified = 1;
#    endif
		storeLiteralbeforeFollowingAddress(backEnd, subject, mcpc);
	}
	return isYoungObject(subject);
}


/*	Rewrite the three values involved in a CPIC case. Used by the initialize &
	extend CPICs.
	c.f. expectedClosedPICPrototype: */
/*	write the obj ref/operand via the second ldr */

	/* Cogit>>#rewriteCPICCaseAt:tag:objRef:target: */
static void NoDbgRegParms
rewriteCPICCaseAttagobjReftarget(sqInt followingAddress, sqInt newTag, sqInt newObjRef, sqInt newTarget)
{
    sqInt classTagPC;
    sqInt methodObjPC;

	methodObjPC = (followingAddress - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd));
	storeLiteralbeforeFollowingAddress(backEnd, newObjRef, methodObjPC);

	/* rewite the tag via the first ldr */
	classTagPC = followingAddress - (jumpLongConditionalByteSize(backEnd));
	storeLiteral32beforeFollowingAddress(backEnd, newTag, classTagPC);
	rewriteConditionalJumpLongAttarget(backEnd, followingAddress, newTarget);
}


/*	destReg := fromReg - subReg */

	/* Cogit>>#SubR:R:R: */
static AbstractInstruction * NoDbgRegParms
gSubRRR(sqInt subReg, sqInt fromReg, sqInt destReg)
{
    AbstractInstruction *first;

	assert(subReg != destReg);
	first = genoperandoperand(MoveRR, fromReg, destReg);
	genoperandoperand(SubRR, subReg, destReg);
	return first;
}


/*	Answer the number of clean blocks found in the literal frame */

	/* Cogit>>#scanForCleanBlocks */
static sqInt
scanForCleanBlocks(void)
{
    sqInt i;
    sqInt iLimiT;
    sqInt lit;
    sqInt numCleanBlocks;
    sqInt startPCOrNil;

	numCleanBlocks = 0;
	for (i = 1, iLimiT = (literalCountOf(methodObj)); i <= iLimiT; i += 1) {
		lit = fetchPointerofObject(i, methodObj);
		startPCOrNil = startPCOrNilOfLiteralin(lit, methodObj);
		if (!(startPCOrNil == null)) {
			numCleanBlocks += 1;
		}
	}
	return numCleanBlocks;
}


/*	If a method is compiled to machine code via a block entry it won't have a
	selector. A subsequent send can find the method and hence fill in the
	selector. 
 */
/*	self disassembleMethod: cogMethod */

	/* Cogit>>#setSelectorOf:to: */
void
setSelectorOfto(CogMethod *cogMethod, sqInt aSelectorOop)
{
	compilationBreakpointisMNUCase(aSelectorOop, 0);
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
	/* begin ensureWritableCodeZone */
	((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->selector = aSelectorOop);
	if (isYoung(aSelectorOop)) {
		ensureInYoungReferrers(cogMethod);
	}
	/* begin ensureExecutableCodeZone */
	return;
}

	/* Cogit>>#spanForCleanBlockStartingAt: */
static sqInt NoDbgRegParms
spanForCleanBlockStartingAt(sqInt startPC)
{
    BytecodeDescriptor *descriptor;
    sqInt end;
    sqInt pc;

	pc = startPC;
	end = numBytesOf(methodObj);
	while (pc <= end) {
		/* begin generatorForPC: */
		descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
		pc += (descriptor->numBytes);
		if ((descriptor->isReturn)) {
			return pc - startPC;
		}
	}
	error("couldn't locate end of clean block");
	return 0;
}

	/* Cogit>>#stackCheckOffsetOfBlockAt:isMcpc: */
static usqInt NoDbgRegParms
stackCheckOffsetOfBlockAtisMcpc(sqInt blockEntryMcpc, sqInt mcpc)
{
    CogBlockMethod *cogBlockMethod;

	cogBlockMethod = ((CogBlockMethod *) (blockEntryMcpc - (sizeof(CogBlockMethod))));
	if (((((sqInt)cogBlockMethod)) + ((cogBlockMethod->stackCheckOffset))) == mcpc) {
		return ((usqInt)cogBlockMethod);
	}
	return 0;
}


/*	Answer a fake value for the method oop in other than the first case in the
	PIC prototype.
	Since we use MoveUniqueCw:R: it must not be confused with a
	method-relative address.
 */

	/* Cogit>>#subsequentPrototypeMethodOop */
static sqInt
subsequentPrototypeMethodOop(void)
{
	return (((((usqInt)0xBADA550)) >= ((methodLabel->address)))
	 && ((((usqInt)0xBADA550)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))
		? 0xDEADEAD
		: 0xBADA550);
}

	/* Cogit>>#TstCq:R: */
static AbstractInstruction * NoDbgRegParms
gTstCqR(sqInt quickConstant, sqInt reg)
{
	return genoperandoperand(TstCqR, quickConstant, reg);
}

	/* Cogit>>#traceLinkedSendOffset */
sqInt
traceLinkedSendOffset(void)
{
	return (cmNoCheckEntryOffset + (callFullInstructionByteSize(backEnd))) + (0);
}

	/* Cogit>>#trampolineName:numArgs: */
static char * NoDbgRegParms
trampolineNamenumArgs(char *routinePrefix, sqInt numArgs)
{
    char *theString;

	/* begin trampolineName:numArgs:limit: */
	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, ((((int) numArgs)) <= (NumSendTrampolines - 2)
		? '0' + (((int) numArgs))
		: 'N'));
	return theString;
}


/*	Malloc a string with the contents for the trampoline table */

	/* Cogit>>#trampolineName:numArgs:limit: */
static char * NoDbgRegParms
trampolineNamenumArgslimit(char *routinePrefix, int numArgs, sqInt argsLimit)
{
    char *theString;

	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, (numArgs <= argsLimit
		? '0' + numArgs
		: 'N'));
	return theString;
}

	/* Cogit>>#trampolineName:numRegArgs: */
static char * NoDbgRegParms
trampolineNamenumRegArgs(char *routinePrefix, sqInt numArgs)
{
    sqInt argsLimit;
    char *theString;

	/* begin trampolineName:numArgs:limit: */
	argsLimit = numRegArgs();
	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, ((((int) numArgs)) <= argsLimit
		? '0' + (((int) numArgs))
		: 'N'));
	return theString;
}

	/* Cogit>>#unflagBecomeFlaggedMethods */
void
unflagBecomeFlaggedMethods(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* Cogit>>#unknownBytecode */
static sqInt
unknownBytecode(void)
{
	return EncounteredUnknownBytecode;
}


/*	Unlink all sends in cog methods. */

	/* Cogit>>#unlinkAllSends */
void
unlinkAllSends(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	/* begin ensureWritableCodeZone */
	cogMethod = ((CogMethod *) methodZoneBase);
	voidOpenPICList();
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			
			mcpc = ((((cogMethod->cmType)) >= CMMethod)
			 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			/* begin mapStartFor: */
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendpcignored(annotation, (((char *) mcpc)), 0);
					if (result != 0) {
						goto l4;
					}
				}
				else {
					if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
					}
				}
				map -= 1;
			}
	l4:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if (!(((cogMethod->cmType)) == CMFree)) {
				freeMethod(cogMethod);
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
}


/*	To placate the C static type system... */

	/* Cogit>>#unlinkIfFreeOrLinkedSend:pc:of: */
static sqInt NoDbgRegParms
unlinkIfFreeOrLinkedSendpcof(sqInt annotation, char *mcpc, CogMethod *theSelector)
{
    sqInt entryPoint;
    sqInt offset1;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if ((((targetMethod1->cmType)) == CMFree)
			 || (((targetMethod1->selector)) == (((sqInt) theSelector)))) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfInvalidClassSend:pc:ignored: */
static sqInt NoDbgRegParms
unlinkIfInvalidClassSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offset1;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send, but maybe a super send or linked to an OpenPIC, in which case the cache tag will be a selector.... */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (!(((annotation == IsSuperSend)
				 || (((annotation >= IsDirectedSuperSend) && (annotation <= IsDirectedSuperBindingSend))))
				 || (((targetMethod1->cmType)) == CMOpenPIC))) {
				if (!(isValidClassTag(literal32BeforeFollowingAddress(backEnd, ((usqInt)((((sqInt)mcpc)) - 5)))))) {
					/* begin unlinkSendAt:targetMethod:sendTable: */
					unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
					/* begin setCodeModified */
#          if DUAL_MAPPED_CODE_ZONE
					codeModified = 1;
#          else
					codeModified = 1;
#          endif
					rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
				}
			}
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSendToFree:pc:ignored: */
static sqInt NoDbgRegParms
unlinkIfLinkedSendToFreepcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offset1;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (((targetMethod1->cmType)) == CMFree) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}


/*	To placate the C static type system... */

	/* Cogit>>#unlinkIfLinkedSend:pc:if: */
static sqInt NoDbgRegParms
unlinkIfLinkedSendpcif(sqInt annotation, char *mcpc, CogMethod *criterionArg)
{
    sqInt (*criterion)(CogMethod *);
    sqInt entryPoint;
    sqInt offset1;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	criterion = ((void *)criterionArg);
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (criterion(targetMethod1)) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSend:pc:ignored: */
static sqInt NoDbgRegParms
unlinkIfLinkedSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offset1;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			/* begin unlinkSendAt:targetMethod:sendTable: */
			unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
			/* begin setCodeModified */
#      if DUAL_MAPPED_CODE_ZONE
			codeModified = 1;
#      else
			codeModified = 1;
#      endif
			rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSend:pc:to: */
static sqInt NoDbgRegParms
unlinkIfLinkedSendpcto(sqInt annotation, char *mcpc, CogMethod *theCogMethod)
{
    sqInt entryPoint;
    sqInt offset1;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offset1 = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (targetMethod1 == theCogMethod) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}


/*	Unlink all sends in cog methods whose class tag is that of a forwarded
	class. 
 */

	/* Cogit>>#unlinkSendsLinkedForInvalidClasses */
void
unlinkSendsLinkedForInvalidClasses(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedPIC;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	cogMethod = ((CogMethod *) methodZoneBase);
	codeModified = (freedPIC = 0);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			
			mcpc = ((((cogMethod->cmType)) >= CMMethod)
			 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			/* begin mapStartFor: */
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfInvalidClassSendpcignored(annotation, (((char *) mcpc)), 0);
					if (result != 0) {
						goto l4;
					}
				}
				else {
					if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
					}
				}
				map -= 1;
			}
	l4:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if ((((cogMethod->cmType)) == CMClosedPIC)
			 && (cPICHasForwardedClass(cogMethod))) {
				freeMethod(cogMethod);
				freedPIC = 1;
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedPIC) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {

			/* After possibly updating inline caches we need to flush the icache. */
			flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
		}
	}
}


/*	Unlink all sends in cog methods. Free all Closed PICs with the selector,
	or with an MNU case if isMNUSelector. First check if any method actually
	has the selector; if not there can't be any linked send to it. This
	routine (including descendents) is performance critical. It contributes
	perhaps 30% of entire execution time in Compiler recompileAll. */

	/* Cogit>>#unlinkSendsOf:isMNUSelector: */
void
unlinkSendsOfisMNUSelector(sqInt selector, sqInt isMNUSelector)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt mustScanAndUnlink;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	cogMethod = ((CogMethod *) methodZoneBase);
	mustScanAndUnlink = 0;
	if (isMNUSelector) {
		while (cogMethod < (limitZony())) {
			if (!(((cogMethod->cmType)) == CMFree)) {
				if (((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				 && (((cogMethod->cmType)) == CMClosedPIC)) {
					assert(isCMClosedPIC(((CogBlockMethod *) cogMethod)));
					freeMethod(cogMethod);
					mustScanAndUnlink = 1;
				}
				else {
					if (((cogMethod->selector)) == selector) {
						mustScanAndUnlink = 1;
						if (((cogMethod->cmType)) == CMClosedPIC) {
							freeMethod(cogMethod);
						}
					}
				}
			}
			/* begin methodAfter: */
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	}
	else {
		while (cogMethod < (limitZony())) {
			if ((!(((cogMethod->cmType)) == CMFree))
			 && (((cogMethod->selector)) == selector)) {
				mustScanAndUnlink = 1;
				if (((cogMethod->cmType)) == CMClosedPIC) {
					freeMethod(cogMethod);
				}
			}
			/* begin methodAfter: */
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	}
	if (!mustScanAndUnlink) {
		return;
	}
	codeModified = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			
			mcpc = ((((cogMethod->cmType)) >= CMMethod)
			 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			/* begin mapStartFor: */
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfFreeOrLinkedSendpcof(annotation, (((char *) mcpc)), (((CogMethod *) selector)));
					if (result != 0) {
						goto l5;
					}
				}
				else {
					if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
					}
				}
				map -= 1;
			}
	l5:	/* end mapFor:performUntil:arg: */;
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (codeModified) {

		/* After possibly updating inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
	/* begin ensureExecutableCodeZone */
	return;
}


/*	Unlink all sends in cog methods to free methods and/or pics. */

	/* Cogit>>#unlinkSendsToFree */
static void
unlinkSendsToFree(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	codeModified = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			
			mcpc = ((((cogMethod->cmType)) >= CMMethod)
			 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			/* begin mapStartFor: */
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendToFreepcignored(annotation, (((char *) mcpc)), 0);
					if (result != 0) {
						goto l4;
					}
				}
				else {
					if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
					}
				}
				map -= 1;
			}
	l4:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				assert(noTargetsFreeInClosedPIC(cogMethod));
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (codeModified) {

		/* After possibly updating inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
}


/*	Unlink all sends in cog methods to methods with a machine code
	primitive, and free machine code primitive methods if freeIfTrue.
	To avoid having to scan PICs, free any and all PICs */

	/* Cogit>>#unlinkSendsToMethodsSuchThat:AndFreeIf: */
void
unlinkSendsToMethodsSuchThatAndFreeIf(sqInt (*criterion)(CogMethod *), sqInt freeIfTrue)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedSomething;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	codeModified = (freedSomething = 0);
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			if (freeIfTrue
			 && (criterion(cogMethod))) {
				freeMethod(cogMethod);
				freedSomething = 1;
			}
			else {
				/* begin mapFor:performUntil:arg: */
				
				mcpc = ((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
					? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
					: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
				/* begin mapStartFor: */
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {

						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask);
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = unlinkIfLinkedSendpcif(annotation, (((char *) mcpc)), (((CogMethod *) criterion)));
						if (result != 0) {
							goto l4;
						}
					}
					else {
						if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
						}
					}
					map -= 1;
				}
	l4:	/* end mapFor:performUntil:arg: */;
			}
		}
		else {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				freeMethod(cogMethod);
				freedSomething = 1;
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedSomething) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {

			/* After possibly updating inline caches we need to flush the icache. */
			flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
		}
	}
	/* begin ensureExecutableCodeZone */
	return;
}


/*	Unlink all sends in cog methods to a particular target method.
	If targetMethodObject isn't actually a method (perhaps being
	used via invokeAsMethod) then there's nothing to do. */

	/* Cogit>>#unlinkSendsTo:andFreeIf: */
void
unlinkSendsToandFreeIf(sqInt targetMethodObject, sqInt freeIfTrue)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedPIC;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *targetMethod;

	if (!((isOopCompiledMethod(targetMethodObject))
		 && (methodHasCogMethod(targetMethodObject)))) {
		return;
	}
	targetMethod = cogMethodOf(targetMethodObject);
	if (!methodZoneBase) {
		return;
	}
	/* begin ensureWritableCodeZone */
	codeModified = (freedPIC = 0);
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			
			mcpc = ((((cogMethod->cmType)) >= CMMethod)
			 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			/* begin mapStartFor: */
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendpcto(annotation, (((char *) mcpc)), targetMethod);
					if (result != 0) {
						goto l4;
					}
				}
				else {
					if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
					}
				}
				map -= 1;
			}
	l4:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if ((((cogMethod->cmType)) == CMClosedPIC)
			 && (cPICHasTarget(cogMethod, targetMethod))) {
				freeMethod(cogMethod);
				freedPIC = 1;
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freeIfTrue) {
		freeMethod(targetMethod);
	}
	if (freedPIC) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {

			/* After possibly updating inline caches we need to flush the icache. */
			flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
		}
	}
	/* begin ensureExecutableCodeZone */
	return;
}

	/* Cogit>>#voidCogCompiledCode */
void
voidCogCompiledCode(void)
{
    CogMethod *cogMethod;

	/* begin clearCogCompiledCode */
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) >= CMMethod) {
			freeMethod(cogMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress);
	youngReferrers = (limitAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;
	/* begin computeAllocationThreshold */
	allocationThreshold = ((((((usqInt)((limitAddress - baseAddress) * thresholdRatio))) + ((zoneAlignment()) - 1)) & ~7)) + baseAddress;
	/* begin ensureExecutableCodeZone */
	return;
}


/*	Access for the object representations when they need to prepend code to
	trampolines. 
 */
/*	Eliminate stale dependent info. */

	/* Cogit>>#zeroOpcodeIndex */
static void
zeroOpcodeIndex(void)
{
    sqInt i;

	for (i = 0; i < opcodeIndex; i += 1) {
		((abstractOpcodes[i]).dependent = null);
	}
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	return;
}

	/* CogMethod>>#counters */
static sqInt NoDbgRegParms
counters(CogMethod * self_in_counters)
{
	return 0;
}

	/* CogMethodZone>>#addToOpenPICList: */
static void NoDbgRegParms
addToOpenPICList(CogMethod *anOpenPIC)
{
	assert(isCMOpenPIC(((CogBlockMethod *) anOpenPIC)));
	assert((openPICList == null)
	 || (isCMOpenPIC(((CogBlockMethod *) openPICList))));
	assertValidDualZoneWriteAddress(anOpenPIC);
	(anOpenPIC->nextOpenPIC = ((usqInt)openPICList));
	openPICList = ((CogMethod *) ((((usqInt)anOpenPIC)) - (getCodeToDataDelta())));
}

	/* CogMethodZone>>#addToYoungReferrers: */
static void NoDbgRegParms
addToYoungReferrers(CogMethod *writableCogMethod)
{
	assertValidDualZoneWriteAddress(writableCogMethod);
	assert((occurrencesInYoungReferrers(writableCogMethod)) == 0);
	assert((writableCogMethod->cmRefersToYoung));
	assert((youngReferrers <= limitAddress)
	 && (youngReferrers >= (limitAddress - (methodCount * BytesPerWord))));
	if (!(asserta((limitAddress - (methodCount * BytesPerWord)) >= mzFreeStart))) {
		error("no room on youngReferrers list");
	}
	youngReferrers -= BytesPerWord;
	codeLongAtput(youngReferrers, (((usqInt)writableCogMethod)) - (getCodeToDataDelta()));
}

	/* CogMethodZone>>#allocate: */
static usqInt NoDbgRegParms
allocate(sqInt numBytes)
{
    usqInt allocation;
    sqInt roundedBytes;

	roundedBytes = (numBytes + 7) & -8;
	if ((mzFreeStart + roundedBytes) >= ((((limitAddress - (methodCount * BytesPerWord)) < allocationThreshold) ? (limitAddress - (methodCount * BytesPerWord)) : allocationThreshold))) {
		return 0;
	}
	allocation = mzFreeStart;
	mzFreeStart += roundedBytes;
	methodCount += 1;
	return allocation;
}


/*	Answer the method containing mcpc for the purposes of code zone
	compaction, where mcpc is actually the value of instructionPointer at the
	time of a compaction. */

	/* CogMethodZone>>#cogMethodContaining: */
CogMethod *
cogMethodContaining(usqInt mcpc)
{
    CogMethod *cogMethod;
    CogMethod *prevMethod;

	if (mcpc > limitAddress) {
		return null;
	}
	if (mcpc < baseAddress) {
		/* begin assertMcpcIsPrimReturn: */
		assert((mcpc == cePrimReturnEnterCogCode)
		 || (mcpc == cePrimReturnEnterCogCodeProfiling));
		return null;
	}
	assert(mcpc < (freeStart()));
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mcpc) {
		prevMethod = cogMethod;
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	assert((prevMethod != null)
	 && ((mcpc == ((((usqInt)prevMethod)) + ((prevMethod->stackCheckOffset))))
	 || ((mcpcisAtStackCheckOfBlockMethodIn(mcpc, prevMethod))
	 || (((primitiveIndexOfMethodheader((prevMethod->methodObject), (prevMethod->methodHeader))) > 0)
	 || ((isCallPrecedingReturnPC(backEnd(), mcpc))
	 && ((callTargetFromReturnAddress(backEnd(), mcpc)) == (ceCheckForInterruptTrampoline())))))));
	return prevMethod;
}

	/* CogMethodZone>>#compactCompiledCode */
static void
compactCompiledCode(void)
{
    unsigned short bytes;
    CogMethod *dest;
    sqLong objectHeaderValue;
    CogMethod *source;
    CogMethod *writableVersion;

	compactionInProgress = 1;
	methodCount = 0;
	objectHeaderValue = nullHeaderForMachineCodeMethod();
	source = ((CogMethod *) baseAddress);
	voidOpenPICList();
	voidUnpairedMethodList();
	while ((source < (limitZony()))
	 && (!(((source->cmType)) == CMFree))) {
		assert((cogMethodDoesntLookKosher(source)) == 0);
		/* begin writableMethodFor: */
		writableVersion = ((CogMethod *) ((((usqInt)source)) + codeToDataDelta));
		(writableVersion->objectHeader = objectHeaderValue);
		if (((source->cmUsageCount)) > 0) {
			(writableVersion->cmUsageCount = ((source->cmUsageCount)) / 2);
		}
		/* begin maybeLinkOnUnpairedMethodList: */
		/* begin clearSavedPICUsageCount: */
		if (((writableVersion->cmType)) == CMClosedPIC) {
			(writableVersion->blockEntryOffset = 0);
		}
		if (((source->cmType)) == CMOpenPIC) {
			addToOpenPICList(writableVersion);
		}
		methodCount += 1;
		/* begin methodAfter: */
		source = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)source)) + ((source->blockSize)))));
	}
	if (source >= (limitZony())) {
		haltmsg("no free methods; cannot compact.");
		return;
	}
	dest = source;
	while (source < (limitZony())) {
		assert((maybeFreeCogMethodDoesntLookKosher(source)) == 0);
		bytes = (source->blockSize);
		if (!(((source->cmType)) == CMFree)) {
			methodCount += 1;
			codeMemmove(dest, source, bytes);
			/* begin maybeFlushWritableZoneFrom:to: */
#      if DUAL_MAPPED_CODE_ZONE
			if (codeToDataDelta > 0) {
				flushDCacheFromto(backEnd, ((usqInt)dest), (((usqInt)dest)) + bytes);
			}
#      endif
			((writableVersion = ((CogMethod *) ((((usqInt)dest)) + codeToDataDelta)))->objectHeader = objectHeaderValue);
			if (((dest->cmType)) >= CMMethod) {

				/* For non-Newspeak there should be a one-to-one mapping between bytecoded and
				   cog methods.  For Newspeak not necessarily, but only for anonymous accessors. */
				/* Only update the original method's header if it is referring to this CogMethod. */
				if ((((sqInt)(rawHeaderOf((dest->methodObject))))) == (((sqInt)source))) {
					rawHeaderOfput((dest->methodObject), ((sqInt)dest));
				}
				else {
					assert((noAssertMethodClassAssociationOf((dest->methodObject))) == (nilObject()));
					/* begin linkOnUnpairedMethodList: */
									}
			}
			else {
				/* begin clearSavedPICUsageCount: */
				if (((writableVersion->cmType)) == CMClosedPIC) {
					(writableVersion->blockEntryOffset = 0);
				}
				if (((dest->cmType)) == CMOpenPIC) {
					addToOpenPICList(writableVersion);
				}
			}
			if (((dest->cmUsageCount)) > 0) {
				(writableVersion->cmUsageCount = ((dest->cmUsageCount)) / 2);
			}
			/* begin maybeFlushWritableZoneFrom:to: */
#      if DUAL_MAPPED_CODE_ZONE
			if (codeToDataDelta > 0) {
				flushDCacheFromto(backEnd, ((usqInt)dest), ((usqInt)(dest + 1)));
			}
#      endif
			dest = ((CogMethod *) ((((usqInt)dest)) + bytes));
		}
		source = ((CogMethod *) ((((usqInt)source)) + bytes));
	}
	mzFreeStart = ((usqInt)dest);
	methodBytesFreedSinceLastCompaction = 0;
	compactionInProgress = 0;
}

	/* CogMethodZone>>#ensureInYoungReferrers: */
static void NoDbgRegParms
ensureInYoungReferrers(CogMethod *cogMethod)
{
    CogMethod *writableMethod;

	assertValidDualZoneReadAddress(cogMethod);
	if (!((cogMethod->cmRefersToYoung))) {
		assert((occurrencesInYoungReferrers(cogMethod)) == 0);
		/* begin ensureWritableCodeZone */
		((writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmRefersToYoung = 1);
		addToYoungReferrers(writableMethod);
	}
}

	/* CogMethodZone>>#followForwardedLiteralsInOpenPICList */
static void
followForwardedLiteralsInOpenPICList(void)
{
    CogMethod *openPIC;

	openPIC = openPICList;
	while (openPIC != null) {
		followForwardedLiteralsImplementationIn(openPIC);
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	}
	pruneYoungReferrers();
}

	/* CogMethodZone>>#freeMethod: */
static void NoDbgRegParms
freeMethod(CogMethod *cogMethod)
{
    CogMethod *writableMethod;

	assert(!((isCMFree(((CogBlockMethod *) cogMethod)))));
	assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
	/* begin ensureWritableCodeZone */
	if (((cogMethod->cmType)) >= CMMethod) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
					}
		else {

			/* For non-Newspeak there should be a one-to-one mapping between bytecoded and
			   cog methods.  For Newspeak not necessarily, but only for anonymous accessors. */
			/* Only reset the original method's header if it is referring to this CogMethod. */
			if ((((sqInt)(rawHeaderOf((cogMethod->methodObject))))) == (((sqInt)cogMethod))) {
				rawHeaderOfput((cogMethod->methodObject), (cogMethod->methodHeader));
							}
			else {
				assert((noAssertMethodClassAssociationOf((cogMethod->methodObject))) == (nilObject()));
							}
		}
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		removeFromOpenPICList(cogMethod);
	}
	/* begin writableMethodFor: */
	writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
	(writableMethod->cmRefersToYoung = 0);
	(writableMethod->cmType = CMFree);
	methodBytesFreedSinceLastCompaction += (cogMethod->blockSize);
}


/*	Free methods, preferring older methods for compaction, up to some
	fraction, currently a quarter.
 */

	/* CogMethodZone>>#freeOlderMethodsForCompaction */
static void
freeOlderMethodsForCompaction(void)
{
    sqInt amountToFree;
    CogMethod *cogMethod;
    sqInt freeableUsage;
    sqInt freedSoFar;
    sqInt initialFreeSpace;
    sqInt zoneSize;

	zoneSize = ((((limitAddress) < allocationThreshold) ? (limitAddress) : allocationThreshold)) - baseAddress;
	initialFreeSpace = (((((limitAddress) < allocationThreshold) ? (limitAddress) : allocationThreshold)) - mzFreeStart) + methodBytesFreedSinceLastCompaction;
	freedSoFar = initialFreeSpace;

	/* 4 needs to be e.g. a start-up parameter */
	amountToFree = zoneSize / 4;
	freeableUsage = 0;
	do {
		cogMethod = ((CogMethod *) baseAddress);
		while (((((usqInt)cogMethod)) < mzFreeStart)
		 && (freedSoFar < amountToFree)) {
			if ((((cogMethod->cmType)) >= CMMethod
				? ((cogMethod->cmUsageCount)) <= freeableUsage
				: (!(((cogMethod->cmType)) == CMFree))
					 && (((cogMethod->cmUsageCount)) == 0))) {
				freeMethod(cogMethod);
				freedSoFar += (cogMethod->blockSize);
			}
			/* begin methodAfter: */
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	} while((freedSoFar < amountToFree)
		 && (((freeableUsage += 1)) < CMMaxUsageCount));
}


/*	Answer that all entries in youngReferrers are in-use and have the
	cmRefersToYoung flag set.
	Used to check that the youngreferrers pruning routines work correctly. */

	/* CogMethodZone>>#kosherYoungReferrers */
sqInt
kosherYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt pointer;
    CogMethod *prevMethod;

	if ((youngReferrers > limitAddress)
	 || (youngReferrers < mzFreeStart)) {
		return 0;
	}
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (!((cogMethod->cmRefersToYoung))) {
				return 0;
			}
			if ((occurrencesInYoungReferrers(cogMethod)) != 1) {
				return 0;
			}
		}
		pointer += BytesPerWord;
	}
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		prevMethod = cogMethod;
		if (!(((cogMethod->cmType)) == CMFree)) {
			if ((occurrencesInYoungReferrers(cogMethod)) != (((cogMethod->cmRefersToYoung)
				? 1
				: 0))) {
				return 0;
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		if (cogMethod == prevMethod) {
			return 0;
		}
	}
	return 1;
}


/*	For assert checking... */

	/* CogMethodZone>>#mcpc:isAtStackCheckOfBlockMethodIn: */
static sqInt NoDbgRegParms
mcpcisAtStackCheckOfBlockMethodIn(sqInt mcpc, CogMethod *cogMethod)
{
	if (((cogMethod->blockEntryOffset)) == 0) {
		return 0;
	}
	return (blockDispatchTargetsForperformarg(cogMethod, stackCheckOffsetOfBlockAtisMcpc, mcpc)) != 0;
}

	/* CogMethodZone>>#methodFor: */
CogMethod *
methodFor(void *address)
{
    CogMethod *cogMethod;
    CogMethod *nextMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((cogMethod < (limitZony()))
	 && ((((usqInt)cogMethod)) <= (((usqInt)address)))) {
		/* begin methodAfter: */
		nextMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		if (nextMethod == cogMethod) {
			return null;
		}
		if (((((usqInt)address)) >= (((usqInt)cogMethod)))
		 && ((((usqInt)address)) < (((usqInt)nextMethod)))) {
			return cogMethod;
		}
		cogMethod = nextMethod;
	}
	return null;
}

	/* CogMethodZone>>#methodsCompiledToMachineCodeInto: */
sqInt
methodsCompiledToMachineCodeInto(sqInt arrayObj)
{
    CogMethod *cogMethod;
    sqInt methodIndex;

	methodIndex = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			storePointerUncheckedofObjectwithValue(methodIndex, arrayObj, (cogMethod->methodObject));
			methodIndex += 1;
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return methodIndex;
}

	/* CogMethodZone>>#numMethods */
sqInt
numMethods(void)
{
	return methodCount;
}

	/* CogMethodZone>>#numMethodsOfType: */
sqInt
numMethodsOfType(sqInt cogMethodType)
{
    CogMethod *cogMethod;
    sqInt n;

	n = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == cogMethodType) {
			n += 1;
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return n;
}

	/* CogMethodZone>>#occurrencesInYoungReferrers: */
static sqInt NoDbgRegParms
occurrencesInYoungReferrers(CogMethod *cogMethod)
{
    sqInt count;
    usqInt pointer;

	assert(youngReferrers <= limitAddress);
	count = 0;
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		if ((((sqInt)cogMethod)) == (longAt(pointer))) {
			count += 1;
		}
		pointer += BytesPerWord;
	}
	return count;
}

	/* CogMethodZone>>#openPICWithSelector: */
static CogMethod * NoDbgRegParms
openPICWithSelector(sqInt aSelector)
{
    CogMethod *openPIC;

	openPIC = openPICList;
	do {
		if ((openPIC == null)
		 || (((openPIC->selector)) == aSelector)) {
			return openPIC;
		}
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	} while(1);
	return 0;
}


/*	Some methods have been freed. Compute how much each survivor needs to
	move during the ensuing compaction and record it in the objectHeader
	field. 
	For Sista, where we want PICs to last so they can be observed, we need to
	keep PICs unless
	they are definitely unused. So we need to identify unused PICs. So in
	planCompact, zero the
	usage counts of all PICs, saving the actual usage count in
	blockEntryOffset. Then in
	relocateMethodsPreCompaction (actually in
	relocateIfCallOrMethodReference:mcpc:delta:) restore the usage counts of
	used PICs. Finally in compactCompiledCode, clear the blockEntryOffset
	of the unused PICs; they will then have a zero count and be reclaimed in
	the next code compaction. */

	/* CogMethodZone>>#planCompaction */
static void
planCompaction(void)
{
    CogMethod *cogMethod;
    sqInt delta;

	delta = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) == CMFree) {
			delta -= (cogMethod->blockSize);
		}
		else {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->objectHeader = delta);
			savePICUsageCount(cogMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethods */
void
printCogMethods(void)
{
    CogMethod *cogMethod;
    sqInt nb;
    sqInt nc;
    sqInt nf;
    sqInt nm;
    sqInt no;
    sqInt nu;

	/* begin printCogMethodsSummarizing: */
	nm = (nb = (nc = (no = (nf = (nu = 0)))));
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		printCogMethod(cogMethod);
		switch ((cogMethod->cmType)) {
		case CMFree:
			nf += 1;
			break;
		case CMMethod:
			nm += 1;
			break;
		case CMMethodFlaggedForBecome:
			nb += 1;
			break;
		case CMClosedPIC:
			nc += 1;
			break;
		case CMOpenPIC:
			no += 1;
			break;
		default:
			nu += 1;

		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	print("CMMethod ");
	printNum(nm);
	if (nb > 0) {
		print(" (flagged for become: ");
		printNum(nb);
		print(")");
	}
	print(" CMClosedPIC ");
	printNum(nc);
	print(" CMOpenPIC ");
	printNum(no);
	print(" CMFree ");
	printNum(nf);
	if (nu > 0) {
		print(" UNKNOWN ");
		printNum(nu);
	}
	print(" total ");
	printNum(((((nm + nc) + no) + nf) + nu) + nb);
	cr();
	return;
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsOfType: */
void
printCogMethodsOfType(sqInt cmType)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == cmType) {
			printCogMethod(cogMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithMethod: */
void
printCogMethodsWithMethod(sqInt methodOop)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->methodObject)) == methodOop)) {
			printCogMethod(cogMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithPrimitive: */
void
printCogMethodsWithPrimitive(sqInt primIdx)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) >= CMMethod)
		 && (primIdx == (primitiveIndexOfMethodheader((cogMethod->methodObject), (cogMethod->methodHeader))))) {
			printCogMethod(cogMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithSelector: */
void
printCogMethodsWithSelector(sqInt selectorOop)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->selector)) == selectorOop)) {
			printCogMethod(cogMethod);
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogYoungReferrers */
void
printCogYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt pointer;

	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!((cogMethod->cmRefersToYoung))) {
			print("*");
		}
		if (((cogMethod->cmType)) == CMFree) {
			print("!");
		}
		if (!(((cogMethod->cmRefersToYoung))
			 && (!(((cogMethod->cmType)) == CMFree)))) {
			print(" ");
		}
		printCogMethod(cogMethod);
		pointer += BytesPerWord;
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printOpenPICList */
sqInt
printOpenPICList(void)
{
    sqInt n;
    CogMethod *openPIC;

	/* begin printOpenPICListSummarizing: */
	n = 0;
	openPIC = openPICList;
	while (!(openPIC == null)) {
		n += 1;
		printCogMethod(openPIC);
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	}
	return n;
}

	/* CogMethodZone>>#pruneYoungReferrers */
static sqInt
pruneYoungReferrers(void)
{
    usqInt dest;
    usqInt next;
    usqInt source;

	assert(youngReferrers <= limitAddress);
	if (youngReferrers == limitAddress) {
		return null;
	}
	dest = limitAddress;
	while (1) {
		next = dest - BytesPerWord;
		if (!((next >= youngReferrers)
		 && (((((CogMethod *) (longAt(next))))->cmRefersToYoung)))) break;
		dest = next;
	}
	assert(dest >= youngReferrers);
	source = dest - BytesPerWord;
	while (source >= youngReferrers) {
		if (((((CogMethod *) (longAt(source))))->cmRefersToYoung)) {
			assert(source < (dest - BytesPerWord));
			if (!(next == null)) {

				/* convenient first-time flag */
				next = null;
				/* begin ensureWritableCodeZone */
			}
			codeLongAtput((dest -= BytesPerWord), longAt(source));
		}
		source -= BytesPerWord;
	}
	youngReferrers = dest;
	assert(kosherYoungReferrers());
	return 0;
}

	/* CogMethodZone>>#relocateAndPruneYoungReferrers */
static sqInt
relocateAndPruneYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt dest;
    usqInt next;
    usqInt source;

	assert(youngReferrers <= limitAddress);
	if (youngReferrers == limitAddress) {
		return null;
	}
	dest = limitAddress;
	while (1) {
		next = dest - BytesPerWord;
		if (!((next >= youngReferrers)
		 && ((!((((cogMethod = ((CogMethod *) (longAt(next))))->cmType)) == CMFree))
		 && ((cogMethod->cmRefersToYoung))))) break;
		if (((cogMethod->objectHeader)) != 0) {
			codeLongAtput(next, (((sqInt)cogMethod)) + ((cogMethod->objectHeader)));
		}
		dest = next;
	}
	assert(dest >= youngReferrers);
	source = dest - BytesPerWord;
	while (source >= youngReferrers) {
		cogMethod = ((CogMethod *) (longAt(source)));
		if ((!(((cogMethod->cmType)) == CMFree))
		 && ((cogMethod->cmRefersToYoung))) {
			assert(source < (dest - BytesPerWord));
			if (((cogMethod->objectHeader)) != 0) {
				cogMethod = ((CogMethod *) ((((sqInt)cogMethod)) + (((sqInt)((cogMethod->objectHeader))))));
			}
			codeLongAtput((dest -= BytesPerWord), ((sqInt)cogMethod));
		}
		source -= BytesPerWord;
	}

	/* this assert must be deferred until after compaction.  See the end of compactCogCompiledCode */
	/* self assert: self kosherYoungReferrers */
	youngReferrers = dest;
	return 0;
}


/*	All surviving methods have had the amount they are going to relocate by
	stored in their objectHeader fields. Relocate all relative calls so that
	after the compaction of both the method containing each call and the call
	target the calls invoke the same target. */

	/* CogMethodZone>>#relocateMethodsPreCompaction */
static sqInt
relocateMethodsPreCompaction(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				relocateCallsInClosedPIC(cogMethod);
			}
			else {
				relocateCallsAndSelfReferencesInMethod(cogMethod);
			}
		}
		/* begin methodAfter: */
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	relocateAndPruneYoungReferrers();
	return 1;
}

	/* CogMethodZone>>#removeFromOpenPICList: */
static sqInt NoDbgRegParms
removeFromOpenPICList(CogMethod *anOpenPIC)
{
    CogMethod *prevPIC;

	assert(isCMOpenPIC(((CogBlockMethod *) anOpenPIC)));
	if (!openPICList) {
		return null;
	}
	assert((isCMOpenPIC(((CogBlockMethod *) openPICList)))
	 && ((((openPICList->nextOpenPIC)) == null)
	 || (isCMOpenPIC(((CogBlockMethod *) (((CogMethod *) ((openPICList->nextOpenPIC)))))))));
	if (anOpenPIC == openPICList) {

		/* N.B. Use self rather than coInterpreter to avoid attempting to cast nil.
		   Conversion to CogMethod done in the nextOpenPIC accessor. */
		openPICList = ((CogMethod *) ((anOpenPIC->nextOpenPIC)));
		return null;
	}
	prevPIC = openPICList;
	do {
		assert((prevPIC != null)
		 && (isCMOpenPIC(((CogBlockMethod *) prevPIC))));
		if (((prevPIC->nextOpenPIC)) == (((usqInt)anOpenPIC))) {
			((((CogMethod *) ((((usqInt)prevPIC)) + codeToDataDelta)))->nextOpenPIC = (anOpenPIC->nextOpenPIC));
			return null;
		}
		prevPIC = ((CogMethod *) ((prevPIC->nextOpenPIC)));
	} while(1);
	return 0;
}


/*	For Sista, where we want PICs to last so they can be observed, we need to
	keep PICs unless
	they are definitely unused. So we need to identify unused PICs. So in
	planCompact, zero the
	usage counts of all PICs, saving the actual usage count in
	blockEntryOffset. Then in
	relocateMethodsPreCompaction (actually in
	relocateIfCallOrMethodReference:mcpc:delta:) restore the usage counts of
	used PICs. Finally in compactCompiledCode, clear the blockEntryOffset
	of the unused PICs; they will then have a zero count and be reclaimed in
	the next code compaction. */

	/* CogMethodZone>>#restorePICUsageCount: */
static void NoDbgRegParms
restorePICUsageCount(CogMethod *cogMethod)
{
	if ((((cogMethod->cmType)) == CMClosedPIC)
	 && (((cogMethod->blockEntryOffset)) != 0)) {
		(cogMethod->cmUsageCount = (cogMethod->blockEntryOffset));
		(cogMethod->blockEntryOffset = 0);
	}
}


/*	Determine the default alignment for the start of a CogMethod, which in
	turn determines the size of the mask used to distinguish the checked and
	unchecked entry-points, used to distinguish normal and super sends on
	method unlinking.
	This is passed onto the backEnd to allow processors with coarse
	instructions (ARM) to increase the alignment if required. */

	/* CogMethodZone>>#roundUpLength: */
static sqInt NoDbgRegParms
roundUpLength(sqInt numBytes)
{
	return roundUpToMethodAlignment(backEnd(), numBytes);
}


/*	For Sista, where we want PICs to last so they can be observed, we need to
	keep PICs unless
	they are definitely unused. So we need to identify unused PICs. So in
	planCompact, zero the
	usage counts of all PICs, saving the actual usage count in
	blockEntryOffset. Then in
	relocateMethodsPreCompaction (actually in
	relocateIfCallOrMethodReference:mcpc:delta:) restore the usage counts of
	used PICs. Finally in compactCompiledCode, clear the blockEntryOffset
	of the unused PICs; they will then have a zero count and be reclaimed in
	the next code compaction. */

	/* CogMethodZone>>#savePICUsageCount: */
static void NoDbgRegParms
savePICUsageCount(CogMethod *cogMethod)
{
	if (((cogMethod->cmType)) == CMClosedPIC) {
		(cogMethod->blockEntryOffset = (cogMethod->cmUsageCount));
		(cogMethod->cmUsageCount = 0);
	}
}

	/* CogMethodZone>>#voidOpenPICList */
static void
voidOpenPICList(void)
{
	openPICList = null;
}

	/* CogMethodZone>>#voidUnpairedMethodList */
static void
voidUnpairedMethodList(void)
{
	}

	/* CogMethodZone>>#voidYoungReferrersPostTenureAll */
static void
voidYoungReferrersPostTenureAll(void)
{
    CogMethod *cogMethod;
    usqInt pointer;

	assert(youngReferrers <= limitAddress);
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!(((cogMethod->cmType)) == CMFree)) {
			(cogMethod->cmRefersToYoung = 0);
		}
		pointer += BytesPerWord;
	}
	youngReferrers = limitAddress;
}

	/* CogMethodZone>>#whereIsMaybeCodeThing: */
char *
whereIsMaybeCodeThing(sqInt anOop)
{
	if (oopisGreaterThanOrEqualToandLessThan(anOop, codeBase, limitAddress)) {
		if (oopisLessThan(anOop, minCogMethodAddress())) {
			return " is in generated runtime";
		}
		if (oopisLessThan(anOop, mzFreeStart)) {
			return " is in generated methods";
		}
		if (oopisLessThan(anOop, youngReferrers)) {
			return " is in code zone";
		}
		return " is in young referrers";
	}
	return null;
}

	/* CogMethodZone>>#zoneAlignment */
static sqInt
zoneAlignment(void)
{
	return 8;
}

	/* CogObjectRepresentation>>#checkValidObjectReference: */
static sqInt NoDbgRegParms
checkValidObjectReference(sqInt anOop)
{
	return (!(isImmediate(anOop)))
	 && ((heapMapAtWord(pointerForOop(anOop))) != 0);
}

	/* CogObjectRepresentation>>#genCmpClassFloatCompactIndexR: */
static AbstractInstruction * NoDbgRegParms
genCmpClassFloatCompactIndexR(sqInt reg)
{
	/* begin gen:quickConstant:operand: */
	return genoperandoperand(CmpCqR, ClassFloatCompactIndex, reg);
}

	/* CogObjectRepresentation>>#genCmpClassMethodContextCompactIndexR: */
static AbstractInstruction * NoDbgRegParms
genCmpClassMethodContextCompactIndexR(sqInt reg)
{
	/* begin gen:quickConstant:operand: */
	return genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, reg);
}

	/* CogObjectRepresentation>>#generateLowcodeObjectTrampolines */
static void
generateLowcodeObjectTrampolines(void)
{
	ceFloatObjectOfTrampoline = genTrampolineForcalledfloatArgresult(floatObjectOf, "ceFloatObjectOfTrampoline", DPFPReg0, TempReg);
	ceFloatValueOfTrampoline = genTrampolineForcalledargfloatResult(floatValueOf, "ceFloatValueOfTrampoline", ReceiverResultReg, DPFPReg0);
	/* begin genTrampolineFor:called:arg:arg:result: */
	ceInstantiateClassIndexableSizeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(instantiateClassindexableSize, "ceInstantiateClassIndexableSizeTrampoline", 2, Arg0Reg, Arg1Reg, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	/* begin genTrampolineFor:called:arg:arg:result: */
	ceInstantiateClassTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(instantiateClassindexableSize, "ceInstantiateClassTrampoline", 2, ReceiverResultReg, 0, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	/* begin genTrampolineFor:called:arg:result: */
	ceByteSizeOfTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(byteSizeOf, "ceByteSizeOfTrampoline", 1, Arg0Reg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	/* begin genTrampolineFor:called:arg:result: */
	cePositive64BitIntegerTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(positive64BitIntegerFor, "cePositive64BitIntegerTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	/* begin genTrampolineFor:called:arg:result: */
	cePositive64BitValueOfTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(positive64BitValueOf, "cePositive64BitValueOfTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	/* begin genTrampolineFor:called:arg:result: */
	ceSigned64BitIntegerTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(signed64BitIntegerFor, "ceSigned64BitIntegerTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	/* begin genTrampolineFor:called:arg:result: */
	ceSigned64BitValueOfTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(signed64BitValueOf, "ceSigned64BitValueOfTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
}


/*	Get the method header (first word) of a CompiledMethod into headerReg.
	Deal with the method possibly being cogged. */

	/* CogObjectRepresentation>>#genGetMethodHeaderOf:into:scratch: */
static sqInt NoDbgRegParms
genGetMethodHeaderOfintoscratch(sqInt methodReg, sqInt headerReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpNotCogged;
    sqInt offset;

	/* begin MoveMw:r:R: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, methodReg, headerReg);
	/* begin genJumpSmallInteger:scratchReg: */
	jumpNotCogged = genJumpSmallInteger(headerReg);
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodHeader);
	genoperandoperandoperand(MoveMwrR, offset, headerReg, headerReg);
	jmpTarget(jumpNotCogged, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	TODO: Optimize this one avoiding the trampoline */

	/* CogObjectRepresentation>>#genLcByteSizeOf:to: */
static void NoDbgRegParms
genLcByteSizeOfto(sqInt oop, sqInt resultRegister)
{
    AbstractInstruction *abstractInstruction;

	if (oop != Arg0Reg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, oop, Arg0Reg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceByteSizeOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, resultRegister);
	ssPushNativeRegister(resultRegister);
}

	/* CogObjectRepresentation>>#genLcFloat32:toOop: */
static void NoDbgRegParms
genLcFloat32toOop(sqInt value, sqInt object)
{
    AbstractInstruction *abstractInstruction;

	/* begin ConvertRs:Rd: */
	genoperandoperand(ConvertRsRd, value, DPFPReg0);
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceFloatObjectOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, object);
	ssPushRegister(object);
}

	/* CogObjectRepresentation>>#genLcFloat64:toOop: */
static void NoDbgRegParms
genLcFloat64toOop(sqInt value, sqInt object)
{
    AbstractInstruction *abstractInstruction;

	if (value != DPFPReg0) {
		/* begin MoveRd:Rd: */
		genoperandoperand(MoveRdRd, value, DPFPReg0);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceFloatObjectOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, object);
	ssPushRegister(object);
}

	/* CogObjectRepresentation>>#genLcInstantiateOop: */
static void NoDbgRegParms
genLcInstantiateOop(sqInt classOop)
{
    AbstractInstruction *abstractInstruction;

	if (classOop != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, classOop, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceInstantiateClassTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, classOop);
	ssPushRegister(classOop);
}

	/* CogObjectRepresentation>>#genLcInstantiateOop:constantIndexableSize: */
static void NoDbgRegParms
genLcInstantiateOopconstantIndexableSize(sqInt classOop, sqInt indexableSize)
{
    AbstractInstruction *abstractInstruction;

	if (classOop != Arg0Reg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, classOop, Arg0Reg);
	}
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, indexableSize, Arg1Reg);
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceInstantiateClassIndexableSizeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, classOop);
	ssPushRegister(classOop);
}

	/* CogObjectRepresentation>>#genLcInstantiateOop:indexableSize: */
static void NoDbgRegParms
genLcInstantiateOopindexableSize(sqInt classOop, sqInt indexableSize)
{
    AbstractInstruction *abstractInstruction;

	if (classOop != Arg0Reg) {
		if (indexableSize == Arg0Reg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, indexableSize, TempReg);
		}
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, classOop, Arg0Reg);
	}
	if (indexableSize != Arg1Reg) {
		if (indexableSize == Arg0Reg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, TempReg, Arg1Reg);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, indexableSize, Arg1Reg);
		}
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceInstantiateClassIndexableSizeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, classOop);
	ssPushRegister(classOop);
}

	/* CogObjectRepresentation>>#genLcInt64ToOop: */
static void NoDbgRegParms
genLcInt64ToOop(sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (value != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceSigned64BitIntegerTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
}


/*	Put the arguments in the correct registers */

	/* CogObjectRepresentation>>#genLcInt64ToOop:highPart: */
static void NoDbgRegParms
genLcInt64ToOophighPart(sqInt valueLow, sqInt valueHigh)
{
    AbstractInstruction *abstractInstruction;

	if (valueLow != ReceiverResultReg) {
		if (valueHigh == ReceiverResultReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, valueHigh, TempReg);
		}
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, valueLow, ReceiverResultReg);
	}
	if (valueHigh != Arg0Reg) {
		if (valueHigh == ReceiverResultReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, TempReg, Arg0Reg);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, valueHigh, Arg0Reg);
		}
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceSigned64BitIntegerTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
}

	/* CogObjectRepresentation>>#genLcOopToInt64: */
static void NoDbgRegParms
genLcOopToInt64(sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (value != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceSigned64BitValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushNativeRegister(ReceiverResultReg);
}


/*	Assume this is always correct */

	/* CogObjectRepresentation>>#genLcOopToPointer: */
static void NoDbgRegParms
genLcOopToPointer(sqInt object)
{
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, BaseHeaderSize, object, object);
	ssPushNativeRegister(object);
}

	/* CogObjectRepresentation>>#genLcOopToUInt64: */
static void NoDbgRegParms
genLcOopToUInt64(sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (value != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, cePositive64BitValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushNativeRegister(ReceiverResultReg);
}

	/* CogObjectRepresentation>>#genLcOop:toFloat32: */
static void NoDbgRegParms
genLcOoptoFloat32(sqInt object, sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (object != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, object, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceFloatValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin ConvertRd:Rs: */
	genoperandoperand(ConvertRdRs, DPFPReg0, value);
	ssPushNativeRegisterSingleFloat(value);
}

	/* CogObjectRepresentation>>#genLcOop:toFloat64: */
static void NoDbgRegParms
genLcOoptoFloat64(sqInt object, sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (object != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, object, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceFloatValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	if (DPFPReg0 != value) {
		/* begin MoveRd:Rd: */
		genoperandoperand(MoveRdRd, DPFPReg0, value);
	}
	ssPushNativeRegisterDoubleFloat(value);
}

	/* CogObjectRepresentation>>#genLcOop:toInt64:highPart: */
static void NoDbgRegParms
genLcOoptoInt64highPart(sqInt object, sqInt valueLow, sqInt valueHigh)
{
    AbstractInstruction *abstractInstruction;

	if (object != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, object, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceSigned64BitValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	if (Arg0Reg != valueHigh) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, valueHigh);
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, valueLow);
	ssPushNativeRegistersecondRegister(valueLow, valueHigh);
}

	/* CogObjectRepresentation>>#genLcOop:toUInt64:highPart: */
static void NoDbgRegParms
genLcOoptoUInt64highPart(sqInt object, sqInt valueLow, sqInt valueHigh)
{
    AbstractInstruction *abstractInstruction;

	if (object != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, object, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, cePositive64BitValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	if (Arg0Reg != valueHigh) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, valueHigh);
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, valueLow);
	ssPushNativeRegistersecondRegister(valueLow, valueHigh);
}

	/* CogObjectRepresentation>>#genLcPointerToOop:class: */
static void NoDbgRegParms
genLcPointerToOopclass(sqInt pointer, sqInt pointerClass)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;

	/* begin PushR: */
	genoperand(PushR, pointer);
	annotateobjRef(checkLiteralforInstruction(pointerClass, genoperandoperand(MoveCwR, pointerClass, Arg0Reg)), pointerClass);
	/* begin MoveCq:R: */
	
	BytesPerOop;
	anInstruction = genoperandoperand(MoveCqR, BytesPerOop, Arg1Reg);
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceInstantiateClassIndexableSizeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin PopR: */
	genoperand(PopR, pointer);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, pointer, BaseHeaderSize, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, pointer);
	ssPushRegister(pointer);
}

	/* CogObjectRepresentation>>#genLcUInt64ToOop: */
static void NoDbgRegParms
genLcUInt64ToOop(sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (value != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value, ReceiverResultReg);
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, cePositive64BitIntegerTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
}


/*	Put the arguments in the correct registers */

	/* CogObjectRepresentation>>#genLcUInt64ToOop:highPart: */
static void NoDbgRegParms
genLcUInt64ToOophighPart(sqInt valueLow, sqInt valueHigh)
{
    AbstractInstruction *abstractInstruction;

	if (valueLow != ReceiverResultReg) {
		if (valueHigh == ReceiverResultReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, valueHigh, TempReg);
		}
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, valueLow, ReceiverResultReg);
	}
	if (valueHigh != Arg0Reg) {
		if (valueHigh == ReceiverResultReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, TempReg, Arg0Reg);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, valueHigh, Arg0Reg);
		}
	}
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, cePositive64BitIntegerTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
}

	/* CogObjectRepresentation>>#genLoadSlot:sourceReg:destReg: */
static sqInt NoDbgRegParms
genLoadSlotsourceRegdestReg(sqInt index, sqInt sourceReg, sqInt destReg)
{
    sqInt offset;

	/* begin MoveMw:r:R: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	genoperandoperandoperand(MoveMwrR, offset, sourceReg, destReg);
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveAdd */
static sqInt
genPrimitiveAdd(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(ClassReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, ReceiverResultReg, ClassReg);
	/* begin JumpOverflow: */
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveAsFloat */
static sqInt
genPrimitiveAsFloat(void)
{
    AbstractInstruction *jumpFailAlloc;

	/* begin hasDoublePrecisionFloatingPointSupport */
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, TempReg, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveBitAnd */
static sqInt
genPrimitiveBitAnd(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin AndR:R: */
	genoperandoperand(AndRR, Arg0Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitOr */
static sqInt
genPrimitiveBitOr(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin OrR:R: */
	genoperandoperand(OrRR, Arg0Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	rTemp := rArg0
	rClass := tTemp
	rTemp := rTemp & 1
	jz nonInt
	rClass >>= 1
	cmp 0,rClass
	jge neg
	cmp 31,rClass // numSmallIntegerBits, jge for sign
	jge tooBig
	rTemp := rReceiver
	rTemp <<= rClass
	rTemp >>= rClass (arithmetic)
	cmp rTemp,rReceiver
	jnz ovfl
	rReceiver := rReceiver - 1
	rReceiver := rReceiver <<= rClass
	rReceiver := rReceiver + 1
	ret
	neg:
	rClass := 0 - rClass
	cmp 31,rClass // numSmallIntegerBits
	jge inRange
	rClass := 31
	inRange
	rReceiver := rReceiver >>= rClass.
	rReceiver := rReceiver | smallIntegerTags.
	ret
	ovfl
	tooBig
	nonInt:
	fail
 */

	/* CogObjectRepresentation>>#genPrimitiveBitShift */
static sqInt
genPrimitiveBitShift(void)
{
    AbstractInstruction *jumpInRange;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;
    AbstractInstruction *jumpTooBig;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpNegative))) {
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, ClassReg);
	}
	/* begin JumpNegative: */
	jumpNegative = genConditionalBranchoperand(JumpNegative, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant = numSmallIntegerBits();
	genoperandoperand(CmpCqR, quickConstant, ClassReg);
	/* begin JumpGreaterOrEqual: */
	jumpTooBig = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	/* begin LogicalShiftLeftR:R: */
	genoperandoperand(LogicalShiftLeftRR, ClassReg, TempReg);
	/* begin ArithmeticShiftRightR:R: */
	genoperandoperand(ArithmeticShiftRightRR, ClassReg, TempReg);
	/* begin CmpR:R: */
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, ReceiverResultReg);
	/* begin JumpNonZero: */
	jumpOvfl = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genRemoveSmallIntegerTagsInScratchReg(ReceiverResultReg);
	/* begin LogicalShiftLeftR:R: */
	genoperandoperand(LogicalShiftLeftRR, ClassReg, ReceiverResultReg);
	genAddSmallIntegerTagsTo(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNegative, genoperand(NegateR, ClassReg));
	/* begin CmpCq:R: */
	quickConstant1 = numSmallIntegerBits();
	genoperandoperand(CmpCqR, quickConstant1, ClassReg);
	/* begin JumpLessOrEqual: */
	jumpInRange = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin MoveCq:R: */
	quickConstant2 = numSmallIntegerBits();
	genoperandoperand(MoveCqR, quickConstant2, ClassReg);
	jmpTarget(jumpInRange, genoperandoperand(ArithmeticShiftRightRR, ClassReg, ReceiverResultReg));
	genClearAndSetSmallIntegerTagsIn(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, jmpTarget(jumpTooBig, jmpTarget(jumpOvfl, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitXor */
static sqInt
genPrimitiveBitXor(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(Arg0Reg);
	/* begin XorR:R: */
	genoperandoperand(XorRR, Arg0Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveClass */
static sqInt
genPrimitiveClass(void)
{
    sqInt reg;

	reg = ReceiverResultReg;
	if (methodOrBlockNumArgs > 0) {
		if (methodOrBlockNumArgs > 1) {
			return UnimplementedPrimitive;
		}
		/* begin genLoadArgAtDepth:into: */
		reg = Arg0Reg;
		assert(0 < (numRegArgs()));
	}
	if ((genGetClassObjectOfintoscratchRegmayBeAForwarder(reg, ReceiverResultReg, TempReg, reg != ReceiverResultReg)) == BadRegisterSet) {
		genGetClassObjectOfintoscratchRegmayBeAForwarder(reg, ClassReg, TempReg, reg != ReceiverResultReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveDiv */
static sqInt
genPrimitiveDiv(void)
{
    AbstractInstruction *convert;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpIsSI;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpSameSign;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, ClassReg);
	}
	/* begin JumpZero: */
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpZero: */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, Arg1Reg);
	}
	/* begin JumpGreaterOrEqual: */
	jumpSameSign = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, TempReg);
	jmpTarget(jumpSameSign, (convert = genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpIsSI = genJumpIsSmallIntegerValuescratch(TempReg, Arg1Reg);
	jmpTarget(jumpIsSI, convert);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveDivide */
static sqInt
genPrimitiveDivide(void)
{
    AbstractInstruction *jumpInexact;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOverflow;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	/* begin JumpZero: */
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpNonZero: */
	jumpInexact = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	jumpOverflow = genJumpNotSmallIntegerValuescratch(TempReg, Arg1Reg);
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOverflow, jmpTarget(jumpInexact, jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveEqual */
static sqInt
genPrimitiveEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpZero, gJumpFPEqual, 0)
		: genSmallIntegerComparison(JumpZero));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatAdd */
static sqInt
genPrimitiveFloatAdd(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleArithmetic:preOpCheck: */
			genFloatArithmeticpreOpCheckboxed(AddRdRd, null, 1))
		: (/* begin genPureDoubleArithmetic:preOpCheck: */
			genPureFloatArithmeticpreOpCheckboxed(AddRdRd, null, 1)));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatDivide */
static sqInt
genPrimitiveFloatDivide(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleArithmetic:preOpCheck: */
			genFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 1))
		: (/* begin genPureDoubleArithmetic:preOpCheck: */
			genPureFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 1)));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatMultiply */
static sqInt
genPrimitiveFloatMultiply(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleArithmetic:preOpCheck: */
			genFloatArithmeticpreOpCheckboxed(MulRdRd, null, 1))
		: (/* begin genPureDoubleArithmetic:preOpCheck: */
			genPureFloatArithmeticpreOpCheckboxed(MulRdRd, null, 1)));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatSquareRoot */
static sqInt
genPrimitiveFloatSquareRoot(void)
{
    AbstractInstruction *jumpFailAlloc;

	/* begin hasDoublePrecisionFloatingPointSupport */
	genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	/* begin SqrtRd: */
	genoperand(SqrtRd, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveFloatSubtract */
static sqInt
genPrimitiveFloatSubtract(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleArithmetic:preOpCheck: */
			genFloatArithmeticpreOpCheckboxed(SubRdRd, null, 1))
		: (/* begin genPureDoubleArithmetic:preOpCheck: */
			genPureFloatArithmeticpreOpCheckboxed(SubRdRd, null, 1)));
}

	/* CogObjectRepresentation>>#genPrimitiveGreaterOrEqual */
static sqInt
genPrimitiveGreaterOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpGreaterOrEqual, gJumpFPGreaterOrEqual, 0)
		: genSmallIntegerComparison(JumpGreaterOrEqual));
}

	/* CogObjectRepresentation>>#genPrimitiveGreaterThan */
static sqInt
genPrimitiveGreaterThan(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpGreater, gJumpFPGreater, 0)
		: genSmallIntegerComparison(JumpGreater));
}


/*	Implementation notes: there are two reasons to use TempReg
	-1) if primitive fails, ReceiverResultReg must remain unchanged (we
	CompletePrimitive) -2) CLZ/BSR only work on 64bits for registers R0-R7 on
	Intel X64. But Win64 uses R9
	Normally, this should be backEnd dependent, but for now we have a single
	64bits target...
 */

	/* CogObjectRepresentation>>#genPrimitiveHighBit */
static sqInt
genPrimitiveHighBit(void)
{
    AbstractInstruction *jumpNegativeReceiver;
    AbstractInstruction *jumpNegativeReceiver1;
    AbstractInstruction *jumpNegativeReceiver2;
    sqInt quickConstant;
    AbstractInstruction * self_in_genHighBitInofSmallIntegerOopWithSingleTagBit;


	/* remove excess tag bits from the receiver oop */
	gOrCqRR((1U << (numSmallIntegerTagBits())) - 1, ReceiverResultReg, TempReg);
	/* begin ArithmeticShiftRightCq:R: */
	quickConstant = (numSmallIntegerTagBits()) - 1;
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, TempReg);
	/* begin genHighBitIn:ofSmallIntegerOopWithSingleTagBit: */
	self_in_genHighBitInofSmallIntegerOopWithSingleTagBit = ((AbstractInstruction *) (backEnd()));
	if ((((cpuidWord1(self_in_genHighBitInofSmallIntegerOopWithSingleTagBit)) & (32)) != 0)) {
		/* begin genHighBitClzIn:ofSmallIntegerOopWithSingleTagBit: */
		
		genoperandoperand(ClzRR, TempReg, TempReg);
		if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
			/* begin CmpCq:R: */
			genoperandoperand(CmpCqR, 0, TempReg);
		}
		/* begin JumpZero: */
		jumpNegativeReceiver2 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin XorCw:R: */
		genoperandoperand(XorCwR, (BytesPerWord * 8) - 1, TempReg);
		jumpNegativeReceiver = jumpNegativeReceiver2;
		goto l10;
	}
	else {
		/* begin genHighBitAlternativeIn:ofSmallIntegerOopWithSingleTagBit: */
		if (!(setsConditionCodesFor(lastOpcode(), JumpNegative))) {
			/* begin CmpCq:R: */
			genoperandoperand(CmpCqR, 0, TempReg);
		}
		/* begin JumpNegative: */
		jumpNegativeReceiver1 = genConditionalBranchoperand(JumpNegative, ((sqInt)0));
		genoperandoperand(BSR, TempReg, TempReg);
		jumpNegativeReceiver = jumpNegativeReceiver1;
		goto l10;
	}
	l10:	/* end genHighBitIn:ofSmallIntegerOopWithSingleTagBit: */;
	if (jumpNegativeReceiver == 0) {
		return UnimplementedPrimitive;
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNegativeReceiver, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveIdentical */
static sqInt
genPrimitiveIdentical(void)
{
	return genPrimitiveIdenticalOrNotIf(0);
}

	/* CogObjectRepresentation>>#genPrimitiveLessOrEqual */
static sqInt
genPrimitiveLessOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpLessOrEqual, gJumpFPGreaterOrEqual, 1)
		: genSmallIntegerComparison(JumpLessOrEqual));
}

	/* CogObjectRepresentation>>#genPrimitiveLessThan */
static sqInt
genPrimitiveLessThan(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpLess, gJumpFPGreater, 1)
		: genSmallIntegerComparison(JumpLess));
}

	/* CogObjectRepresentation>>#genPrimitiveMod */
static sqInt
genPrimitiveMod(void)
{
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpSameSign;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(ClassReg);
	/* begin JumpZero: */
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, Arg1Reg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genRemoveSmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpZero: */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, Arg1Reg);
	}
	/* begin JumpGreaterOrEqual: */
	jumpSameSign = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ClassReg);
	jmpTarget(jumpSameSign, jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genSetSmallIntegerTagsIn(ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveMultiply */
static sqInt
genPrimitiveMultiply(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(processorHasMultiplyAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	genRemoveSmallIntegerTagsInScratchReg(Arg1Reg);
	/* begin MulOverflowR:R: */
	genMulRR(backEnd, Arg1Reg, ClassReg);
	/* begin JumpOverflow: */
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	genSetSmallIntegerTagsIn(ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveNewMethod */
static sqInt
genPrimitiveNewMethod(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveNotEqual */
static sqInt
genPrimitiveNotEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpNonZero, gJumpFPNotEqual, 0)
		: genSmallIntegerComparison(JumpNonZero));
}

	/* CogObjectRepresentation>>#genPrimitiveNotIdentical */
static sqInt
genPrimitiveNotIdentical(void)
{
	return genPrimitiveIdenticalOrNotIf(1);
}

	/* CogObjectRepresentation>>#genPrimitiveQuo */
static sqInt
genPrimitiveQuo(void)
{
    AbstractInstruction *convert;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpIsSI;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, ClassReg);
	}
	/* begin JumpZero: */
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpZero: */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin Label */
	convert = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpIsSI = genJumpIsSmallIntegerValuescratch(TempReg, Arg1Reg);
	jmpTarget(jumpIsSI, convert);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatAdd */
static sqInt
genPrimitiveSmallFloatAdd(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatArithmetic:preOpCheck: */
			genFloatArithmeticpreOpCheckboxed(AddRdRd, null, 0))
		: (/* begin genPureSmallFloatArithmetic:preOpCheck: */
			genPureFloatArithmeticpreOpCheckboxed(AddRdRd, null, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatDivide */
static sqInt
genPrimitiveSmallFloatDivide(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatArithmetic:preOpCheck: */
			genFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 0))
		: (/* begin genPureSmallFloatArithmetic:preOpCheck: */
			genPureFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatEqual */
static sqInt
genPrimitiveSmallFloatEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPEqual, JumpZero, 0, 0))
		: (/* begin genPureSmallFloatComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPEqual, 0, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatGreaterOrEqual */
static sqInt
genPrimitiveSmallFloatGreaterOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreaterOrEqual, JumpGreaterOrEqual, 0, 0))
		: (/* begin genPureSmallFloatComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 0, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatGreaterThan */
static sqInt
genPrimitiveSmallFloatGreaterThan(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreater, JumpGreater, 0, 0))
		: (/* begin genPureSmallFloatComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPGreater, 0, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatLessOrEqual */
static sqInt
genPrimitiveSmallFloatLessOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreaterOrEqual, JumpLessOrEqual, 1, 0))
		: (/* begin genPureSmallFloatComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 1, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatLessThan */
static sqInt
genPrimitiveSmallFloatLessThan(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreater, JumpLess, 1, 0))
		: (/* begin genPureSmallFloatComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPGreater, 1, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatMultiply */
static sqInt
genPrimitiveSmallFloatMultiply(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatArithmetic:preOpCheck: */
			genFloatArithmeticpreOpCheckboxed(MulRdRd, null, 0))
		: (/* begin genPureSmallFloatArithmetic:preOpCheck: */
			genPureFloatArithmeticpreOpCheckboxed(MulRdRd, null, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatNotEqual */
static sqInt
genPrimitiveSmallFloatNotEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPNotEqual, JumpNonZero, 0, 0))
		: (/* begin genPureSmallFloatComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPNotEqual, 0, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatSquareRoot */
static sqInt
genPrimitiveSmallFloatSquareRoot(void)
{
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpNegative;

	genGetSmallFloatValueOfscratchinto(ReceiverResultReg, SendNumArgsReg, DPFPReg0);
	/* begin XorRd:Rd: */
	genoperandoperand(XorRdRd, DPFPReg1, DPFPReg1);
	/* begin CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	jumpNegative = gJumpFPGreater(0);
	/* begin SqrtRd: */
	genoperand(SqrtRd, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNegative, jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatSubtract */
static sqInt
genPrimitiveSmallFloatSubtract(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genSmallFloatArithmetic:preOpCheck: */
			genFloatArithmeticpreOpCheckboxed(SubRdRd, null, 0))
		: (/* begin genPureSmallFloatArithmetic:preOpCheck: */
			genPureFloatArithmeticpreOpCheckboxed(SubRdRd, null, 0)));
}

	/* CogObjectRepresentation>>#genPrimitiveSubtract */
static sqInt
genPrimitiveSubtract(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, Arg0Reg, TempReg);
	/* begin JumpOverflow: */
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	genAddSmallIntegerTagsTo(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genSmallIntegerComparison: */
static sqInt NoDbgRegParms
genSmallIntegerComparison(sqInt jumpOpcode)
{
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpTrue;
    sqInt quickConstant;
    sqInt quickConstant1;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpFail = genJumpNotSmallInteger(Arg0Reg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpTrue = genConditionalBranchoperand(jumpOpcode, 0);
	if (shouldAnnotateObjectReference(falseObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, falseObject(), ReceiverResultReg), falseObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = falseObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpTrue, (shouldAnnotateObjectReference(trueObject())
		? annotateobjRef(genoperandoperand(MoveCwR, trueObject(), ReceiverResultReg), trueObject())
		: (/* begin MoveCq:R: */
			(quickConstant1 = trueObject()),
			genoperandoperand(MoveCqR, quickConstant1, ReceiverResultReg))));
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#isUnannotatableConstant: */
static sqInt NoDbgRegParms
isUnannotatableConstant(CogSimStackEntry *simStackEntry)
{
	return (((simStackEntry->type)) == SSConstant)
	 && ((isImmediate((simStackEntry->constant)))
	 || (!(shouldAnnotateObjectReference((simStackEntry->constant)))));
}

	/* CogObjectRepresentationFor64BitSpur>>#classForInlineCacheTag: */
static sqInt NoDbgRegParms
classForInlineCacheTag(sqInt classIndex)
{
	return classOrNilAtIndex(classIndex);
}

	/* CogObjectRepresentationFor64BitSpur>>#genAddSmallIntegerTagsTo: */
static sqInt NoDbgRegParms
genAddSmallIntegerTagsTo(sqInt aRegister)
{
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 1, aRegister);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genAlloc64BitPositiveIntegerValue:into:scratchReg:scratchReg: */
static AbstractInstruction * NoDbgRegParms
genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(sqInt valueReg, sqInt resultReg, sqInt scratch1, sqInt scratch2)
{
    sqInt address;
    sqInt address1;
    sqInt allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    usqLong newLPIHeader;
    sqInt quickConstant;

	allocSize = BaseHeaderSize + BytesPerWord;
	newLPIHeader = headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargePositiveIntegerCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, resultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratch1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant, scratch1);
	/* begin JumpAboveOrEqual: */
	jumpFail = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, scratch1, address1);
	/* begin genStoreHeader:intoNewInstance:using: */
	
	genoperandoperand(MoveCqR, newLPIHeader, scratch1);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, scratch1, 0, resultReg);
	/* begin MoveR:Mw:r: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveRMwr, valueReg, BaseHeaderSize, resultReg);
	return jumpFail;
}

	/* CogObjectRepresentationFor64BitSpur>>#genAlloc64BitSignedIntegerValue:into:scratchReg:scratchReg: */
static AbstractInstruction * NoDbgRegParms
genAlloc64BitSignedIntegerValueintoscratchRegscratchReg(sqInt valueReg, sqInt resultReg, sqInt scratch1, sqInt scratch2)
{
    sqInt address;
    sqInt address1;
    sqInt allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpNeg;
    usqLong newLNIHeader;
    sqInt quickConstant;

	allocSize = BaseHeaderSize + BytesPerWord;
	newLNIHeader = headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargeNegativeIntegerCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, resultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratch1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant, scratch1);
	/* begin JumpAboveOrEqual: */
	jumpFail = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, scratch1, address1);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, newLNIHeader, scratch1);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, valueReg);
	/* begin JumpLess: */
	jumpNeg = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	assert((headerForSlotsformatclassIndex(0, 0, 1)) == 1);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, ClassLargePositiveIntegerCompactIndex - ClassLargeNegativeIntegerCompactIndex, scratch1);
	jmpTarget(jumpNeg, checkQuickConstantforInstruction(0, genoperandoperandoperand(MoveRMwr, scratch1, 0, resultReg)));
	/* begin MoveR:Mw:r: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveRMwr, valueReg, BaseHeaderSize, resultReg);
	return jumpFail;
}


/*	Override to answer a SmallFloat64 if possible. */

	/* CogObjectRepresentationFor64BitSpur>>#genAllocFloatValue:into:scratchReg:scratchReg: */
static AbstractInstruction * NoDbgRegParms
genAllocFloatValueintoscratchRegscratchReg(sqInt dpreg, sqInt resultReg, sqInt scratch1, sqInt scratch2)
{
    sqInt address;
    sqInt address1;
    usqIntptr_t allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpFail1;
    AbstractInstruction *jumpMerge;
    AbstractInstruction *jumpNotSF;
    usqLong newFloatHeader;
    sqInt quickConstant;

	/* begin MoveRd:R: */
	assert(BytesPerWord == 8);
	genoperandoperand(MoveRdR, dpreg, resultReg);
	jumpNotSF = genJumpNotSmallFloatValueBitsscratch(resultReg, scratch1);
	genConvertBitsToSmallFloatInscratch(resultReg, scratch1);
	/* begin Jump: */
	jumpMerge = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpNotSF, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	allocSize = BaseHeaderSize + (sizeof(double));
	newFloatHeader = headerForSlotsformatclassIndex((sizeof(double)) / BytesPerWord, firstLongFormat(), ClassFloatCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, resultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratch1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant, scratch1);
	/* begin JumpAboveOrEqual: */
	jumpFail1 = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, scratch1, address1);
	/* begin genStoreHeader:intoNewInstance:using: */
	
	genoperandoperand(MoveCqR, newFloatHeader, scratch1);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, scratch1, 0, resultReg);
	/* begin MoveRd:M64:r: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveRdM64r, dpreg, BaseHeaderSize, resultReg);
	jumpFail = jumpFail1;
	jmpTarget(jumpMerge, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return jumpFail;
}


/*	Set the SmallInteger tag bits when the tag bits may be filled with
	garbage. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genClearAndSetSmallIntegerTagsIn: */
static sqInt NoDbgRegParms
genClearAndSetSmallIntegerTagsIn(sqInt scratchReg)
{
    sqInt quickConstant;

	/* begin AndCq:R: */
	quickConstant = -1 - (tagMask());
	genoperandoperand(AndCqR, quickConstant, scratchReg);
	/* begin OrCq:R: */
	genoperandoperand(OrCqR, 1, scratchReg);
	return 0;
}


/*	Convert the in-SmallFloat64-range floating point value in integer register
	into a tagged SmallFloat64 oop.
	c.f. Spur64BitMemoryManager>>smallFloatObjectOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertBitsToSmallFloatIn:scratch: */
static sqInt NoDbgRegParms
genConvertBitsToSmallFloatInscratch(sqInt reg, sqInt scratch)
{
    AbstractInstruction *jumpZero;
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin RotateLeftCq:R: */
	genoperandoperand(RotateLeftCqR, 1, reg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 1, reg);
	/* begin JumpBelowOrEqual: */
	jumpZero = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin SubCq:R: */
	quickConstant = ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	genoperandoperand(SubCqR, quickConstant, reg);
	jmpTarget(jumpZero, genoperandoperand(LogicalShiftLeftCqR, numTagBits(), reg));
	/* begin AddCq:R: */
	quickConstant1 = smallFloatTag();
	genoperandoperand(AddCqR, quickConstant1, reg);
	return 0;
}


/*	Convert the Character in reg to a SmallInteger, assuming
	the Character's value is a valid character. */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertCharacterToSmallIntegerInReg: */
static void NoDbgRegParms
genConvertCharacterToSmallIntegerInReg(sqInt reg)
{
    sqInt quickConstant;

	/* begin SubCq:R: */
	quickConstant = (characterTag()) - (smallIntegerTag());
	genoperandoperand(SubCqR, quickConstant, reg);
	return;
}

	/* CogObjectRepresentationFor64BitSpur>>#genConvertIntegerInReg:toSmallIntegerInReg: */
static sqInt NoDbgRegParms
genConvertIntegerInRegtoSmallIntegerInReg(sqInt srcReg, sqInt destReg)
{
	gLogicalShiftLeftCqRR(numTagBits(), srcReg, destReg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 1, destReg);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genConvertIntegerToSmallIntegerInReg: */
static sqInt NoDbgRegParms
genConvertIntegerToSmallIntegerInReg(sqInt reg)
{
    sqInt quickConstant;

	/* begin LogicalShiftLeftCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, reg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 1, reg);
	return 0;
}


/*	Convert the SmallFloat in reg to its identityHash as a SmallInteger.
	Rotate the sign bit from bit 3 (zero-relative) to the sign bit. 
	c.f. Spur64BitMemoryManager>>rotatedFloatBitsOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallFloatToSmallFloatHashAsIntegerInReg:scratch: */
static sqInt NoDbgRegParms
genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(sqInt reg, sqInt scratch)
{
    sqInt quickConstant;
    sqInt quickConstant1;

	assert(((((usqInt)((smallFloatTag()))) >> 1) - (smallIntegerTag())) == (smallIntegerTag()));
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 1, reg);
	gAndCqRR(1U << ((numTagBits()) - 1), reg, scratch);
	/* begin SubR:R: */
	genoperandoperand(SubRR, scratch, reg);
	/* begin SubCq:R: */
	quickConstant = (((usqInt)((smallFloatTag()))) >> 1) - (smallIntegerTag());
	genoperandoperand(SubCqR, quickConstant, reg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant1 = 0x3F - ((numTagBits()) - 1);
	genoperandoperand(LogicalShiftLeftCqR, quickConstant1, scratch);
	/* begin OrR:R: */
	genoperandoperand(OrRR, scratch, reg);
	return 0;
}


/*	Convert the SmallInteger in reg to a Character, assuming
	the SmallInteger's value is a valid character. */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallIntegerToCharacterInReg: */
static void NoDbgRegParms
genConvertSmallIntegerToCharacterInReg(sqInt reg)
{
    sqInt quickConstant;

	/* begin AddCq:R: */
	quickConstant = (characterTag()) - (smallIntegerTag());
	genoperandoperand(AddCqR, quickConstant, reg);
	return;
}

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallIntegerToIntegerInReg: */
static sqInt NoDbgRegParms
genConvertSmallIntegerToIntegerInReg(sqInt reg)
{
    sqInt quickConstant;

	/* begin ArithmeticShiftRightCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, reg);
	return 0;
}


/*	The arguments are in an array in Arg1Reg. Its size is in sizeReg.
	Load Arg0Reg and Arg1Reg with the first two slots, as appropriate.
	Since objects always have at least one slot it is safe to load arg0
	without checking.
	But the array could be at the end of memory so we must check that it has
	two slots before it is safe to access the second slot. */

	/* CogObjectRepresentationFor64BitSpur>>#genFetchRegArgsForPerformWithArguments: */
static sqInt NoDbgRegParms
genFetchRegArgsForPerformWithArguments(sqInt sizeReg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    AbstractInstruction *skip;

	/* begin MoveMw:r:R: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, Arg0Reg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 2, sizeReg);
	/* begin JumpLess: */
	skip = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = BaseHeaderSize + BytesPerWord;
	genoperandoperandoperand(MoveMwrR, offset, Arg1Reg, Arg1Reg);
	jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genFloatArithmetic:preOpCheck:boxed: */
static sqInt NoDbgRegParms
genFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed)
{
    AbstractInstruction *doOp;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFailCheck;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;
    AbstractInstruction *jumpNotSmallInteger;

	jumpFailCheck = ((AbstractInstruction *) 0);
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	/* begin Label */
	doOp = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (!(preOpCheckOrNil == null)) {
		jumpFailCheck = preOpCheckOrNil(DPFPReg0, DPFPReg1);
	}
	genoperandoperand(arithmeticOperator, DPFPReg1, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpNotSmallInteger = genJumpNotSmallInteger(Arg0Reg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, Arg1Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, jmpTarget(jumpNotSmallInteger, jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	if (!(preOpCheckOrNil == null)) {
		jmpTarget(jumpFailCheck, ((AbstractInstruction *) (((jumpFailAlloc->operands))[0])));
	}
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genFloatComparison:orIntegerComparison:invert:boxed: */
static sqInt NoDbgRegParms
genFloatComparisonorIntegerComparisoninvertboxed(AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt jumpOpcode, sqInt invertComparison, sqInt rcvrBoxed)
{
    AbstractInstruction *compareFloat;
    AbstractInstruction *jumpAmbiguous;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;
    AbstractInstruction *jumpNotSmallInteger;
    AbstractInstruction *jumpTrue;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    AbstractInstruction *returnTrue;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	if (invertComparison) {

		/* May need to invert for NaNs */
		/* begin CmpRd:Rd: */
		compareFloat = genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		/* begin CmpRd:Rd: */
		compareFloat = genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}

	/* FP jumps are a little weird */
	jumpCond = jumpFPOpcodeGenerator(0);
	if (shouldAnnotateObjectReference(falseObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, falseObject(), ReceiverResultReg), falseObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = falseObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, (shouldAnnotateObjectReference(trueObject())
		? (returnTrue = annotateobjRef(genoperandoperand(MoveCwR, trueObject(), ReceiverResultReg), trueObject()))
		: (/* begin MoveCq:R: */
			(quickConstant1 = trueObject()),
			(returnTrue = genoperandoperand(MoveCqR, quickConstant1, ReceiverResultReg)))));
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* Test for ambiguity, that is when floatRcvr == (double) intArg */
	jumpNotSmallInteger = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, Arg0Reg, DPFPReg1);
	/* begin CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);

	/* Case of non ambiguity, use compareFloat(floatRcvr,(double) intArg) */
	jumpAmbiguous = gJumpFPEqual(0);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)compareFloat));
	jmpTarget(jumpAmbiguous, genoperandoperand(ConvertRdR, DPFPReg0, ReceiverResultReg));
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpTrue = genConditionalBranchoperand(jumpOpcode, 0);
	if (shouldAnnotateObjectReference(falseObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, falseObject(), ReceiverResultReg), falseObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant2 = falseObject();
		genoperandoperand(MoveCqR, quickConstant2, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpTrue, returnTrue);
	jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)compareFloat));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	Fetch the instance's identity hash into destReg, encoded as a
	SmallInteger. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genGetHashFieldNonImmOf:asSmallIntegerInto: */
static sqInt NoDbgRegParms
genGetHashFieldNonImmOfasSmallIntegerInto(sqInt instReg, sqInt destReg)
{
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = (identityHashFullWordShift()) - (numTagBits());
	genoperandoperand(LogicalShiftRightCqR, quickConstant, destReg);
	/* begin AndCq:R: */
	quickConstant1 = ((sqInt)((usqInt)((identityHashHalfWordMask())) << (numTagBits())));
	genoperandoperand(AndCqR, quickConstant1, destReg);
	/* begin AddCq:R: */
	quickConstant2 = smallIntegerTag();
	genoperandoperand(AddCqR, quickConstant2, destReg);
	return 0;
}


/*	Fetch the instance's identity hash into destReg, unencoded. */

	/* CogObjectRepresentationFor64BitSpur>>#genGetHashFieldNonImmOf:into: */
static sqInt NoDbgRegParms
genGetHashFieldNonImmOfinto(sqInt instReg, sqInt destReg)
{
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 32, destReg);
	/* begin AndCq:R: */
	quickConstant = identityHashHalfWordMask();
	genoperandoperand(AndCqR, quickConstant, destReg);
	return 0;
}


/*	Extract the inline cache tag for the object in sourceReg into destReg. The
	inline cache tag for a given object is the value loaded in inline caches
	to distinguish
	objects of different classes. In Spur this is either the tags for
	immediates, or
	the receiver's classIndex. Answer the label for the start of the sequence. */

	/* CogObjectRepresentationFor64BitSpur>>#genGetInlineCacheClassTagFrom:into:forEntry: */
static AbstractInstruction * NoDbgRegParms
genGetInlineCacheClassTagFromintoforEntry(sqInt sourceReg, sqInt destReg, sqInt forEntry)
{
    AbstractInstruction *entryLabel;
    AbstractInstruction *jumpImm;
    sqInt quickConstant;

	if (forEntry) {
		/* begin AlignmentNops: */
		genoperand(AlignmentNops, BytesPerWord);
	}
	/* begin Label */
	entryLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	gAndCqRR(tagMask(), sourceReg, destReg);
	/* begin JumpNonZero: */
	jumpImm = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	flag("endianness");
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, sourceReg, destReg);
	/* begin AndCq:R: */
	quickConstant = classIndexMask();
	genoperandoperand(AndCqR, quickConstant, destReg);
	jmpTarget(jumpImm, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return entryLabel;
}


/*	Get the size in byte-sized slots of the object in srcReg into destReg.
	srcReg may equal destReg.
	destReg <- numSlots << self shiftForWord - (fmt bitAnd: 7).
	Assumes the object in srcReg has a byte format, i.e. 16 to 23 or 24 to 31 */

	/* CogObjectRepresentationFor64BitSpur>>#genGetNumBytesOf:into: */
static sqInt NoDbgRegParms
genGetNumBytesOfinto(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *jmp;
    sqInt quickConstant;

	genGetRawSlotSizeOfNonImminto(srcReg, destReg);
	/* begin CmpCq:R: */
	quickConstant = numSlotsMask();
	genoperandoperand(CmpCqR, quickConstant, destReg);
	/* begin JumpLess: */
	jmp = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genGetOverflowSlotsOfinto(srcReg, destReg);
	jmpTarget(jmp, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), destReg));
	genGetBitsofFormatByteOfinto(7, srcReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, destReg);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genGetOverflowSlotsOf:into: */
static sqInt NoDbgRegParms
genGetOverflowSlotsOfinto(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveMw:r:R: */
	
	-BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveMwrR, -BaseHeaderSize, srcReg, destReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 8, destReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 8, destReg);
	return 0;
}


/*	Convert the SmallFloat oop in ooppReg into the corresponding float value
	in dpReg.
	c.f. Spur64BitMemoryManager>>smallFloatBitsOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genGetSmallFloatValueOf:scratch:into: */
static sqInt NoDbgRegParms
genGetSmallFloatValueOfscratchinto(sqInt oopReg, sqInt scratch, sqInt dpReg)
{
    AbstractInstruction *jumpSFZero;
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, oopReg, scratch);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(LogicalShiftRightCqR, quickConstant, scratch);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 1, scratch);
	/* begin JumpLessOrEqual: */
	jumpSFZero = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant1 = ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	genoperandoperand(AddCqR, quickConstant1, scratch);
	jmpTarget(jumpSFZero, genoperandoperand(RotateRightCqR, 1, scratch));
	/* begin MoveR:Rd: */
	assert(BytesPerWord == 8);
	genoperandoperand(MoveRRd, scratch, dpReg);
	return 0;
}


/*	Generate a test for aRegister containing an integer value in the
	SmallInteger range, and a jump if so, answering the jump.
	c.f. Spur64BitMemoryManager>>isIntegerValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpIsSmallIntegerValue:scratch: */
static AbstractInstruction * NoDbgRegParms
genJumpIsSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg)
{
    sqInt quickConstant;

	return (gArithmeticShiftRightCqRR(0x3F - (numTagBits()), aRegister, scratchReg),
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 1, scratchReg),
		/* begin AndCq:R: */
		(quickConstant = (1U << ((numTagBits()) + 1)) - 1),
		genoperandoperand(AndCqR, quickConstant, scratchReg),
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 1, scratchReg),
		/* begin JumpLessOrEqual: */
		genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0)));
}


/*	Generate a compare and branch to test if aRegister contains other than a
	Character. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotCharacter: */
static AbstractInstruction * NoDbgRegParms
genJumpNotCharacter(sqInt reg)
{
    sqInt quickConstant;

	return (/* begin TstCq:R: */
		(quickConstant = characterTag()),
		genoperandoperand(TstCqR, quickConstant, reg),
		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)0)));
}


/*	Generate a test to check that the integer register contains a floating
	point value within the SmallFloat64 range,
	and answer the jump. c.f. Spur64BitMemoryManager>>isSmallFloatValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallFloatValueBits:scratch: */
static AbstractInstruction * NoDbgRegParms
genJumpNotSmallFloatValueBitsscratch(sqInt reg, sqInt exponent)
{
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpMaxExponent;
    AbstractInstruction *jumpMinExponent;
    AbstractInstruction *jumpTest;
    AbstractInstruction *jumpZeroMantissa;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;

	flag("if we combine the exponent range test with the conversion to tagged representation we test for a zero exponent only once. further, if we extract tags once into a scratch on the input side we test for immediates, SmallInteger and SmallFloat using the same intermediate result.  so to do is to move fp arithmetic into the object representations");
	gLogicalShiftLeftCqRR(1, reg, exponent);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = (smallFloatMantissaBits()) + 1;
	genoperandoperand(LogicalShiftRightCqR, quickConstant, exponent);
	/* begin CmpCq:R: */
	quickConstant1 = smallFloatExponentOffset();
	genoperandoperand(CmpCqR, quickConstant1, exponent);
	/* begin JumpLessOrEqual: */
	jumpMinExponent = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = 0xFF + (smallFloatExponentOffset());
	genoperandoperand(CmpCqR, quickConstant2, exponent);
	/* begin JumpLessOrEqual: */
	jumpMaxExponent = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin Jump: */
	jumpFail = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpMinExponent, gTstCqR((1ULL << (smallFloatMantissaBits())) - 1, reg));
	/* begin JumpZero: */
	jumpZeroMantissa = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = smallFloatExponentOffset();
	genoperandoperand(CmpCqR, quickConstant3, exponent);
	/* begin Jump: */
	jumpTest = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpZeroMantissa, checkQuickConstantforInstruction(0, genoperandoperand(CmpCqR, 0, exponent)));
	jmpTarget(jumpTest, genConditionalBranchoperand(JumpNonZero, ((sqInt)jumpFail)));
	jmpTarget(jumpMaxExponent, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return jumpFail;
}


/*	Generate a compare and branch to test if aRegister contains other than a
	SmallFloat. Answer the jump. */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallFloat: */
static AbstractInstruction * NoDbgRegParms
genJumpNotSmallFloat(sqInt reg)
{
    sqInt quickConstant;

	return (/* begin TstCq:R: */
		(quickConstant = smallFloatTag()),
		genoperandoperand(TstCqR, quickConstant, reg),
		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)0)));
}


/*	Generate a test for aRegister containing an integer value outside the
	SmallInteger range, and a jump if so, answering the jump.
	c.f. Spur64BitMemoryManager>>isIntegerValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallIntegerValue:scratch: */
static AbstractInstruction * NoDbgRegParms
genJumpNotSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg)
{
    sqInt quickConstant;

	return (gArithmeticShiftRightCqRR(0x3F - (numTagBits()), aRegister, scratchReg),
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 1, scratchReg),
		/* begin AndCq:R: */
		(quickConstant = (1U << ((numTagBits()) + 1)) - 1),
		genoperandoperand(AndCqR, quickConstant, scratchReg),
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 1, scratchReg),
		/* begin JumpGreater: */
		genConditionalBranchoperand(JumpGreater, ((sqInt)0)));
}


/*	Generate a compare and branch to test if aRegister contains other than a
	SmallInteger. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallInteger: */
static AbstractInstruction * NoDbgRegParms
genJumpNotSmallInteger(sqInt reg)
{
    sqInt quickConstant;

	return (/* begin TstCq:R: */
		(quickConstant = smallIntegerTag()),
		genoperandoperand(TstCqR, quickConstant, reg),
		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)0)));
}


/*	Generate a compare and branch to test if aRegister contains a
	SmallInteger. Answer the jump, or UnimplementedOperation if this cannot be
	done with
	a single register. */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpSmallInteger: */
static AbstractInstruction * NoDbgRegParms
genJumpSmallInteger(sqInt aRegister)
{
    sqInt quickConstant;

	return (/* begin TstCq:R: */
		(quickConstant = smallIntegerTag()),
		genoperandoperand(TstCqR, quickConstant, aRegister),
		/* begin JumpNonZero: */
		genConditionalBranchoperand(JumpNonZero, ((sqInt)0)));
}

	/* CogObjectRepresentationFor64BitSpur>>#genLcInt32ToOop: */
static sqInt NoDbgRegParms
genLcInt32ToOop(sqInt value)
{
	/* begin SignExtend32R:R: */
	genoperandoperand(SignExtend32RR, value, value);
	goto l5;
	l5:	/* end SignExtend32R:R: */;
	genConvertIntegerToSmallIntegerInReg(value);
	ssPushRegister(value);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genLcOopToInt32: */
static sqInt NoDbgRegParms
genLcOopToInt32(sqInt value)
{
	genConvertSmallIntegerToIntegerInReg(value);
	ssPushNativeRegister(value);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genLcOopToUInt32: */
static sqInt NoDbgRegParms
genLcOopToUInt32(sqInt value)
{
	genConvertSmallIntegerToIntegerInReg(value);
	ssPushNativeRegister(value);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genLcUInt32ToOop: */
static sqInt NoDbgRegParms
genLcUInt32ToOop(sqInt value)
{
	/* begin ZeroExtend32R:R: */
	genoperandoperand(ZeroExtend32RR, value, value);
	l5:	/* end ZeroExtend32R:R: */;
	genConvertIntegerToSmallIntegerInReg(value);
	ssPushRegister(value);
	return 0;
}


/*	Generate the code for primitives 61 & 165, at:put:/basicAt:put: &
	integerAt:put:. If signedVersion is true
	then generate signed accesses to the bits classes (a la 164 & 165). If
	signedVersion is false,
	generate unsigned accesses (a la 60, 61, 63 & 64). */
/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveAtPutSigned: */
static sqInt NoDbgRegParms
genPrimitiveAtPutSigned(sqInt signedVersion)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    sqInt formatReg;
    AbstractInstruction *jump64BitArgIsImmediate;
    AbstractInstruction *jump64BitsOutOfBounds;
    AbstractInstruction *jumpArrayOutOfBounds;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpBytesOutOfRange;
    AbstractInstruction *jumpDoubleWordsOutOfRange;
    AbstractInstruction *jumpFixedFieldsOutOfBounds;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsCompiledMethod;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpIsWords;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNonSmallIntegerValue;
    AbstractInstruction *jumpNot64BitIndexable;
    AbstractInstruction *jumpNot8ByteInteger;
    AbstractInstruction *jumpNotIndexableBits;
    AbstractInstruction *jumpNotIndexablePointers;
    AbstractInstruction *jumpNotPointers;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpShortsOutOfRange;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfRange;
    AbstractInstruction *methodInBounds;
    sqInt nSlotsOrBytesReg;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant10;
    sqInt quickConstant11;
    sqInt quickConstant12;
    sqInt quickConstant13;
    sqInt quickConstant14;
    sqInt quickConstant15;
    sqInt quickConstant16;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    sqInt quickConstant9;
    AbstractInstruction *rejoin;

	jumpDoubleWordsOutOfRange = ((AbstractInstruction *) 0);
	jumpImmutable = ((AbstractInstruction *) 0);
	jumpNegative = ((AbstractInstruction *) 0);
	nSlotsOrBytesReg = ClassReg;
	/* begin genLoadArgAtDepth:into: */
	assert(1 < (numRegArgs()));
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, Arg0Reg);
#  if IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	/* begin genJumpBaseHeaderImmutable: */
	
	quickConstant = immutableBitMask();
	genoperandoperand(TstCqR, quickConstant, TempReg);
	/* begin JumpNonZero: */
	jumpImmutable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
#  else // IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
#  endif // IMMUTABILITY
	genGetNumSlotsOfinto(ReceiverResultReg, nSlotsOrBytesReg);
	/* begin CmpCq:R: */
	quickConstant1 = weakArrayFormat();
	genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpAbove: */
	jumpNotPointers = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genStoreCheckReceiverRegvalueRegscratchReginFrame(ReceiverResultReg, Arg1Reg, TempReg, 0);
	/* begin CmpCq:R: */
	quickConstant2 = arrayFormat();
	genoperandoperand(CmpCqR, quickConstant2, formatReg);
	/* begin JumpBelow: */
	jumpNotIndexablePointers = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin JumpNonZero: */
	jumpHasFixedFields = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpArrayOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant3 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant3, Arg0Reg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, Arg1Reg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpHasFixedFields, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genGetClassIndexOfNonImminto(ReceiverResultReg, formatReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, formatReg);
	/* begin JumpZero: */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(formatReg, Extra0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Extra0Reg, formatReg);
	genConvertSmallIntegerToIntegerInReg(formatReg);
	/* begin AndCq:R: */
	quickConstant4 = fixedFieldsOfClassFormatMask();
	genoperandoperand(AndCqR, quickConstant4, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);
	/* begin AddCq:R: */
	quickConstant5 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant5, formatReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpFixedFieldsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, formatReg, Arg0Reg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, Arg1Reg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotPointers, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNonSmallIntegerValue = genJumpNotSmallInteger(Arg1Reg);
	/* begin CmpCq:R: */
	quickConstant6 = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant6, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant7 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant7, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant8 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant8, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant9 = sixtyFourBitIndexableFormat();
	genoperandoperand(CmpCqR, quickConstant9, formatReg);
	/* begin JumpNonZero: */
	jumpNotIndexableBits = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, SendNumArgsReg);
	genConvertSmallIntegerToIntegerInReg(SendNumArgsReg);
	if (!signedVersion) {
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, SendNumArgsReg);
		/* begin JumpLess: */
		jumpNegative = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	}
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	rejoin = genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jump64BitsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant10 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant10, Arg0Reg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, SendNumArgsReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNonSmallIntegerValue, checkQuickConstantforInstruction(sixtyFourBitIndexableFormat(), genoperandoperand(CmpCqR, sixtyFourBitIndexableFormat(), formatReg)));
	/* begin JumpNonZero: */
	jumpNot64BitIndexable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	jump64BitArgIsImmediate = genJumpImmediate(Arg1Reg);
	if (signedVersion) {

		/* Test top bit of 64-bit word in large integer for range check. */
		/* begin MoveMw:r:R: */
		
		BaseHeaderSize;
		anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, TempReg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, TempReg);
		/* begin JumpLess: */
		jumpDoubleWordsOutOfRange = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	}
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, Arg1Reg, SendNumArgsReg);
	/* begin AndCq:R: */
	quickConstant11 = headerForSlotsformatclassIndex(numSlotsMask(), formatMask(), classIndexMask());
	genoperandoperand(AndCqR, quickConstant11, SendNumArgsReg);
	/* begin CmpCq:R: */
	quickConstant12 = headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargePositiveIntegerCompactIndex);
	genoperandoperand(CmpCqR, quickConstant12, SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNot8ByteInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	
	BaseHeaderSize;
	anInstruction2 = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, SendNumArgsReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)rejoin));
	if (signedVersion) {

		/* Now check if the header is that of an 8 byte LargeNegativeInteger */
		jmpTarget(jumpNot8ByteInteger, gCmpCqR(headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargeNegativeIntegerCompactIndex), SendNumArgsReg));
		/* begin JumpNonZero: */
		jumpNot8ByteInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveMw:r:R: */
		
		BaseHeaderSize;
		anInstruction1 = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, TempReg);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, SendNumArgsReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, TempReg, SendNumArgsReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)rejoin));
	}
	if (signedVersion) {
		jmpTarget(jumpIsWords, gArithmeticShiftRightCqRR(0x1F + (numTagBits()), Arg1Reg, TempReg));
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 1, TempReg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 1, TempReg);
	}
	else {
		jmpTarget(jumpIsWords, checkQuickConstantforInstruction((((usqInt)0xFFFFFFFFU << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)0xFFFFFFFFU << 3) | 1), Arg1Reg)));
	}
	/* begin JumpAbove: */
	jumpWordsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, nSlotsOrBytesReg);
	/* begin AndCq:R: */
	quickConstant13 = (BytesPerWord / 4) - 1;
	genoperandoperand(AndCqR, quickConstant13, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddCq:R: */
	quickConstant14 = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);
	genoperandoperand(AddCqR, quickConstant14, Arg0Reg);
	/* begin MoveR:X32r:R: */
	genoperandoperandoperand(MoveRX32rR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	if (signedVersion) {
		jmpTarget(jumpIsBytes, gArithmeticShiftRightCqRR(7 + (numTagBits()), Arg1Reg, TempReg));
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 1, TempReg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 1, TempReg);
	}
	else {
		jmpTarget(jumpIsBytes, checkQuickConstantforInstruction((((usqInt)0xFF << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)0xFF << 3) | 1), Arg1Reg)));
	}
	/* begin JumpAbove: */
	jumpBytesOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), nSlotsOrBytesReg);
	gAndCqRR(BytesPerWord - 1, formatReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, nSlotsOrBytesReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant15 = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant15, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsCompiledMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	methodInBounds = genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddCq:R: */
	
	BaseHeaderSize;
	anInstruction3 = genoperandoperand(AddCqR, BaseHeaderSize, Arg0Reg);
	/* begin MoveR:Xbr:R: */
	genoperandoperandoperand(MoveRXbrR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	if (signedVersion) {
		jmpTarget(jumpIsShorts, gArithmeticShiftRightCqRR(15 + (numTagBits()), Arg1Reg, TempReg));
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 1, TempReg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 1, TempReg);
	}
	else {
		jmpTarget(jumpIsShorts, checkQuickConstantforInstruction((((usqInt)0xFFFF << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)0xFFFF << 3) | 1), Arg1Reg)));
	}
	/* begin JumpAbove: */
	jumpShortsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 1, nSlotsOrBytesReg);
	/* begin AndCq:R: */
	quickConstant16 = (BytesPerWord / 2) - 1;
	genoperandoperand(AndCqR, quickConstant16, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:M16:r: */
	
	BaseHeaderSize;
	anInstruction4 = genoperandoperandoperand(MoveRM16r, TempReg, BaseHeaderSize, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsCompiledMethod, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	getLiteralCountOfplusOneinBytesintoscratch(ReceiverResultReg, 1, 1, nSlotsOrBytesReg, TempReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelow: */
	genConditionalBranchoperand(JumpBelow, ((sqInt)methodInBounds));
	jmpTarget(jumpNot8ByteInteger, jmpTarget(jump64BitArgIsImmediate, jmpTarget(jumpNot64BitIndexable, jmpTarget(jumpIsContext, jmpTarget(jumpNotIndexableBits, jmpTarget(jumpBytesOutOfRange, jmpTarget(jumpShortsOutOfRange, jmpTarget(jumpWordsOutOfRange, jmpTarget(jumpIsCompiledMethod, jmpTarget(jumpArrayOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jump64BitsOutOfBounds, jmpTarget(jumpNotIndexablePointers, jmpTarget(jumpFixedFieldsOutOfBounds, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))))))))))))));
	if (signedVersion) {
		jmpTarget(jumpDoubleWordsOutOfRange, ((AbstractInstruction *) (((jumpIsContext->operands))[0])));
	}
	else {
		jmpTarget(jumpNegative, ((AbstractInstruction *) (((jumpIsContext->operands))[0])));
	}
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, ((AbstractInstruction *) (((jumpIsContext->operands))[0])));
#  endif
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 1, Arg0Reg);
	genConvertIntegerToSmallIntegerInReg(Arg0Reg);
	jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}


/*	Generate the code for primitives 60 & 164, at:/basicAt: & integerAt:. If
	signedVersion is true
	then generate signed accesses to the bits classes (a la 164 & 165). If
	signedVersion is false,
	generate unsigned accesses (a la 60, 61, 63 & 64). */
/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveAtSigned: */
static sqInt NoDbgRegParms
genPrimitiveAtSigned(sqInt signedVersion)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *convertToIntAndReturn;
    sqInt formatReg;
    AbstractInstruction *jumpArrayOutOfBounds;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFixedFieldsOutOfBounds;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpIsArray;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsLongs;
    AbstractInstruction *jumpIsMethod;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpIsWords;
    AbstractInstruction *jumpLongsOutOfBounds;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpNotSmallInteger;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *methodInBounds;
    sqInt nSlotsOrElementsReg;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant10;
    sqInt quickConstant11;
    sqInt quickConstant12;
    sqInt quickConstant13;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    sqInt quickConstant9;

	nSlotsOrElementsReg = ClassReg;
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, Arg1Reg);
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	genGetNumSlotsOfinto(ReceiverResultReg, nSlotsOrElementsReg);
	/* begin CmpCq:R: */
	quickConstant2 = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant2, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = arrayFormat();
	genoperandoperand(CmpCqR, quickConstant3, formatReg);
	/* begin JumpZero: */
	jumpIsArray = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin JumpBelow: */
	jumpNotIndexable = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = weakArrayFormat();
	genoperandoperand(CmpCqR, quickConstant4, formatReg);
	/* begin JumpBelowOrEqual: */
	jumpHasFixedFields = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant5, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant6 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant6, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant7 = sixtyFourBitIndexableFormat();
	genoperandoperand(CmpCqR, quickConstant7, formatReg);
	/* begin JumpZero: */
	jumpIsLongs = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	jmpTarget(jumpNotIndexable, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin Jump: */
	jumpNotIndexable = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsArray, (assert(!((Arg1Reg == SPReg))),
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg)));
	/* begin JumpBelowOrEqual: */
	jumpArrayOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant8 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant8, Arg1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsBytes, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), nSlotsOrElementsReg));
	gAndCqRR(7, formatReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, nSlotsOrElementsReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant9 = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant9, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	methodInBounds = anInstruction;
	if (signedVersion) {
		/* begin MoveXbr:R:R: */
		genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	}
	else {

		/* formatReg already contains a value <= 16r1f, so no need to zero it */
		/* begin MoveXbr:R:R: */
		genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, formatReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, formatReg, ReceiverResultReg);
	}
	if (signedVersion) {
		/* begin SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, ReceiverResultReg, ReceiverResultReg);
		goto l8;
	l8:	/* end SignExtend8R:R: */;
	}
	/* begin Label */
	convertToIntAndReturn = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, nSlotsOrElementsReg));
	/* begin AndCq:R: */
	genoperandoperand(AndCqR, 3, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveM16:r:R: */
	
	BaseHeaderSize;
	anInstruction1 = genoperandoperandoperand(MoveM16rR, BaseHeaderSize, ReceiverResultReg, ReceiverResultReg);
	if (signedVersion) {
		/* begin SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, ReceiverResultReg, ReceiverResultReg);
		goto l13;
	l13:	/* end SignExtend16R:R: */;
	}
	/* begin Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpIsWords, gLogicalShiftLeftCqR((shiftForWord()) - 2, nSlotsOrElementsReg));
	/* begin AndCq:R: */
	genoperandoperand(AndCqR, 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant10 = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);
	genoperandoperand(AddCqR, quickConstant10, Arg1Reg);
	/* begin MoveX32r:R:R: */
	genoperandoperandoperand(MoveX32rRR, Arg1Reg, ReceiverResultReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	if (signedVersion) {
		/* begin SignExtend32R:R: */
		genoperandoperand(SignExtend32RR, ReceiverResultReg, ReceiverResultReg);
		goto l18;
	l18:	/* end SignExtend32R:R: */;
	}
	/* begin Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpHasFixedFields, checkQuickConstantforInstruction(classIndexMask(), genoperandoperand(AndCqR, classIndexMask(), TempReg)));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, formatReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	/* begin JumpZero: */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(formatReg, Extra0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Extra0Reg, formatReg);
	genConvertSmallIntegerToIntegerInReg(formatReg);
	/* begin AndCq:R: */
	quickConstant11 = fixedFieldsOfClassFormatMask();
	genoperandoperand(AndCqR, quickConstant11, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpFixedFieldsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, formatReg, Arg1Reg);
	/* begin AddCq:R: */
	quickConstant12 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant12, Arg1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsLongs, (assert(!((Arg1Reg == SPReg))),
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg)));
	/* begin JumpBelowOrEqual: */
	jumpLongsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant13 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant13, Arg1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	if (signedVersion) {

		/* c.f. Spur64BitMemoryManager>>#isIntegerValue: */
		/* begin ArithmeticShiftRightCq:R: */
		quickConstant = numSmallIntegerBits();
		genoperandoperand(ArithmeticShiftRightCqR, quickConstant, TempReg);
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, 15, TempReg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 1, TempReg);
		/* begin JumpAbove: */
		jumpNotSmallInteger = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)convertToIntAndReturn));
		jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jumpFailAlloc = genAlloc64BitSignedIntegerValueintoscratchRegscratchReg(ClassReg, SendNumArgsReg, Extra0Reg, TempReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
		/* begin genPrimReturn */
		if (methodOrBlockNumArgs <= (numRegArgs())) {
			/* begin RetN: */
			genoperand(RetN, 0);
		}
		else {
			/* begin RetN: */
			genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
		}
	}
	else {
		/* begin LogicalShiftRightCq:R: */
		quickConstant1 = (numSmallIntegerBits()) - 1;
		genoperandoperand(LogicalShiftRightCqR, quickConstant1, TempReg);
		if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
			/* begin CmpCq:R: */
			genoperandoperand(CmpCqR, 0, TempReg);
		}
		/* begin JumpNonZero: */
		jumpNotSmallInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)convertToIntAndReturn));
		jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jumpFailAlloc = genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(ClassReg, SendNumArgsReg, Extra0Reg, TempReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
		/* begin genPrimReturn */
		if (methodOrBlockNumArgs <= (numRegArgs())) {
			/* begin RetN: */
			genoperand(RetN, 0);
		}
		else {
			/* begin RetN: */
			genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
		}
	}
	jmpTarget(jumpIsMethod, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	getLiteralCountOfplusOneinBytesintoscratch(ReceiverResultReg, 1, 1, nSlotsOrElementsReg, TempReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelow: */
	genConditionalBranchoperand(JumpBelow, ((sqInt)methodInBounds));
	jmpTarget(jumpFailAlloc, jmpTarget(jumpLongsOutOfBounds, jmpTarget(jumpFixedFieldsOutOfBounds, jmpTarget(jumpArrayOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpNotIndexable, jmpTarget(jumpIsContext, jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))))))))));
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatEqual */
static sqInt
genPrimitiveFloatEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPEqual, JumpZero, 0, 1))
		: (/* begin genPureDoubleComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPEqual, 0, 1)));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatGreaterOrEqual */
static sqInt
genPrimitiveFloatGreaterOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreaterOrEqual, JumpGreaterOrEqual, 0, 1))
		: (/* begin genPureDoubleComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 0, 1)));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatGreaterThan */
static sqInt
genPrimitiveFloatGreaterThan(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreater, JumpGreater, 0, 1))
		: (/* begin genPureDoubleComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPGreater, 0, 1)));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatLessOrEqual */
static sqInt
genPrimitiveFloatLessOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreaterOrEqual, JumpLessOrEqual, 1, 1))
		: (/* begin genPureDoubleComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 1, 1)));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatLessThan */
static sqInt
genPrimitiveFloatLessThan(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreater, JumpLess, 1, 1))
		: (/* begin genPureDoubleComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPGreater, 1, 1)));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatNotEqual */
static sqInt
genPrimitiveFloatNotEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? (/* begin genDoubleComparison:orIntegerComparison:invert: */
			genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPNotEqual, JumpNonZero, 0, 1))
		: (/* begin genPureDoubleComparison:invert: */
			genPureFloatComparisoninvertboxed(gJumpFPNotEqual, 0, 1)));
}


/*	Arguably we should fail for immediates, but so far no one has complained,
	so... 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveIdentityHash */
static sqInt
genPrimitiveIdentityHash(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *jumpImm;
    AbstractInstruction *jumpNotCharacter;
    AbstractInstruction *jumpNotSet;
    sqInt quickConstant;
    AbstractInstruction *ret;


	/* uses TstCqR */
	jumpImm = genJumpImmediate(ReceiverResultReg);
	genGetHashFieldNonImmOfasSmallIntegerInto(ReceiverResultReg, TempReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ConstZero, TempReg);
	/* begin JumpZero: */
	jumpNotSet = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		ret = genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		ret = genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpImm, gAndCqRR(tagMask(), ReceiverResultReg, TempReg));
	/* begin CmpCq:R: */
	quickConstant = characterTag();
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpNonZero: */
	jumpNotCharacter = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertCharacterToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		ret = genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		ret = genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotCharacter, checkQuickConstantforInstruction(smallFloatTag(), genoperandoperand(CmpCqR, smallFloatTag(), TempReg)));
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)ret));
	genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(ReceiverResultReg, TempReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSet, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (!(primitiveIndex == 75)) {
		return 0;
	}
	/* begin saveAndRestoreLinkRegAround: */
	backEnd();
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceNewHashTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveImmediateAsInteger */
static sqInt
genPrimitiveImmediateAsInteger(void)
{
    AbstractInstruction *jumpNotCharacter;
    sqInt quickConstant;
    AbstractInstruction *ret;

	gAndCqRR(tagMask(), ReceiverResultReg, TempReg);
	/* begin CmpCq:R: */
	quickConstant = characterTag();
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpNonZero: */
	jumpNotCharacter = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertCharacterToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		ret = genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		ret = genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotCharacter, checkQuickConstantforInstruction(smallFloatTag(), genoperandoperand(CmpCqR, smallFloatTag(), TempReg)));
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)ret));
	genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(ReceiverResultReg, TempReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}


/*	Implement primitiveNew for convenient cases:
	- the receiver has a hash
	- the receiver is fixed size (excluding ephemerons to save instructions &
	miniscule time)
	- single word header/num slots < numSlotsMask
	- the result fits in eden (actually below scavengeThreshold)
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveNew */
static sqInt
genPrimitiveNew(void)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt byteSizeReg;
    AbstractInstruction *fillLoop;
    sqInt fillReg;
    sqInt headerReg;
    sqInt instSpecReg;
    AbstractInstruction *jumpHasSlots;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpTooBig;
    AbstractInstruction *jumpUnhashed;
    AbstractInstruction *jumpVariableOrEphemeron;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    AbstractInstruction *skip;

	if (methodOrBlockNumArgs != 0) {
		return UnimplementedPrimitive;
	}

	/* inst spec will hold class's instance specification, then byte size and finally end of new object. */
	headerReg = (fillReg = SendNumArgsReg);

	/* get freeStart as early as possible so as not to wait later... */
	instSpecReg = (byteSizeReg = ClassReg);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, Arg1Reg);
	genGetHashFieldNonImmOfinto(ReceiverResultReg, headerReg);
	/* begin JumpZero: */
	jumpUnhashed = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, ReceiverResultReg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = fixedFieldsFieldWidth();
	genoperandoperand(LogicalShiftRightCqR, quickConstant, TempReg);
	/* begin AndCq:R: */
	quickConstant1 = formatMask();
	genoperandoperand(AndCqR, quickConstant1, TempReg);
	/* begin AndCq:R: */
	quickConstant2 = fixedFieldsOfClassFormatMask();
	genoperandoperand(AndCqR, quickConstant2, instSpecReg);
	/* begin CmpCq:R: */
	quickConstant3 = nonIndexablePointerFormat();
	genoperandoperand(CmpCqR, quickConstant3, TempReg);
	/* begin JumpAbove: */
	jumpVariableOrEphemeron = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = numSlotsMask();
	genoperandoperand(CmpCqR, quickConstant4, instSpecReg);
	/* begin JumpAboveOrEqual: */
	jumpTooBig = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	quickConstant5 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant5, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant6 = numSlotsFullShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant6, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, byteSizeReg);
	/* begin JumpNonZero: */
	jumpHasSlots = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveCq:R: */
	
	BaseHeaderSize * 2;
	anInstruction = genoperandoperand(MoveCqR, BaseHeaderSize * 2, byteSizeReg);
	/* begin Jump: */
	skip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasSlots, checkQuickConstantforInstruction(BaseHeaderSize / BytesPerWord, genoperandoperand(AddCqR, BaseHeaderSize / BytesPerWord, byteSizeReg)));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	jmpTarget(skip, genoperandoperand(AddRR, Arg1Reg, byteSizeReg));
	/* begin CmpCq:R: */
	quickConstant7 = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant7, byteSizeReg);
	/* begin JumpAboveOrEqual: */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, byteSizeReg, address1);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, headerReg, 0, Arg1Reg);
	/* begin LoadEffectiveAddressMw:r:R: */
	
	BaseHeaderSize;
	anInstruction1 = genoperandoperandoperand(LoadEffectiveAddressMwrR, BaseHeaderSize, ReceiverResultReg, Arg1Reg);
	/* begin MoveCq:R: */
	quickConstant8 = nilObject();
	genoperandoperand(MoveCqR, quickConstant8, fillReg);
	/* begin MoveR:Mw:r: */
	fillLoop = genoperandoperandoperand(MoveRMwr, fillReg, 0, Arg1Reg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 8, Arg1Reg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, byteSizeReg);
	/* begin JumpAbove: */
	genConditionalBranchoperand(JumpAbove, ((sqInt)fillLoop));
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpUnhashed, jmpTarget(jumpVariableOrEphemeron, jmpTarget(jumpTooBig, jmpTarget(jumpNoSpace, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	return 0;
}


/*	Implement primitiveNewWithArg for convenient cases:
	- the receiver has a hash
	- the receiver is variable and not compiled method
	- single word header/num slots < numSlotsMask
	- the result fits in eden
	See superclass method for dynamic frequencies of formats.
	For the moment we implement only arrayFormat, firstByteFormat &
	firstLongFormat 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveNewWithArg */
static sqInt
genPrimitiveNewWithArg(void)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    sqInt byteSizeReg;
    AbstractInstruction *fillLoop;
    sqInt fillReg;
    sqInt headerReg;
    sqInt instSpecReg;
    AbstractInstruction *jumpArrayFormat;
    AbstractInstruction *jumpArrayTooBig;
    AbstractInstruction *jumpByteFormat;
    AbstractInstruction *jumpBytePrepDone;
    AbstractInstruction *jumpByteTooBig;
    AbstractInstruction *jumpFailCuzFixed;
    AbstractInstruction *jumpHasSlots;
    AbstractInstruction *jumpLongPrepDone;
    AbstractInstruction *jumpLongTooBig;
    AbstractInstruction *jumpNElementsNonInt;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpUnhashed;
    sqInt maxSlots;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant10;
    sqInt quickConstant11;
    sqInt quickConstant12;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    sqInt quickConstant9;
    AbstractInstruction *skip;

	if (methodOrBlockNumArgs != 1) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));

	/* Assume there's an available scratch register on 64-bit machines.  This holds the saved numFixedFields and then the value to fill with */
	headerReg = SendNumArgsReg;
	fillReg = Extra0Reg;
	assert(fillReg > 0);

	/* The max slots we'll allocate here are those for a single header */
	instSpecReg = (byteSizeReg = ClassReg);

	/* get freeStart as early as possible so as not to wait later... */
	maxSlots = (numSlotsMask()) - 1;
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, Arg1Reg);
	genGetHashFieldNonImmOfinto(ReceiverResultReg, headerReg);
	/* begin JumpZero: */
	jumpUnhashed = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNElementsNonInt = genJumpNotSmallInteger(Arg0Reg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, ReceiverResultReg, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = (fixedFieldsFieldWidth()) + (numSmallIntegerTagBits());
	genoperandoperand(LogicalShiftRightCqR, quickConstant, instSpecReg);
	/* begin AndCq:R: */
	quickConstant1 = formatMask();
	genoperandoperand(AndCqR, quickConstant1, instSpecReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant2 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant2, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, fillReg);
	genConvertSmallIntegerToIntegerInReg(fillReg);
	/* begin CmpCq:R: */
	quickConstant3 = arrayFormat();
	genoperandoperand(CmpCqR, quickConstant3, instSpecReg);
	/* begin JumpZero: */
	jumpArrayFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant4, instSpecReg);
	/* begin JumpZero: */
	jumpByteFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant5, instSpecReg);
	/* begin JumpNonZero: */
	jumpFailCuzFixed = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin CmpCq:R: */
	
	(((usqInt)(maxSlots * 2) << 3) | 1);
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)(maxSlots * 2) << 3) | 1), Arg0Reg);
	/* begin JumpAbove: */
	jumpLongTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	
	BytesPerWord / 4;
	anInstruction1 = genoperandoperand(MoveCqR, BytesPerWord / 4, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	/* begin AndCq:R: */
	quickConstant6 = (BytesPerWord / 4) - 1;
	genoperandoperand(AndCqR, quickConstant6, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant7 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant7, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin AddCq:R: */
	quickConstant8 = (BytesPerWord / 4) - 1;
	genoperandoperand(AddCqR, quickConstant8, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, (shiftForWord()) - 2, instSpecReg);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, fillReg);
	/* begin Jump: */
	jumpLongPrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpByteFormat, checkQuickConstantforInstruction((((usqInt)(maxSlots * BytesPerWord) << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)(maxSlots * BytesPerWord) << 3) | 1), Arg0Reg)));
	/* begin JumpAbove: */
	jumpByteTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	
	BytesPerWord;
	anInstruction2 = genoperandoperand(MoveCqR, BytesPerWord, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	/* begin AndCq:R: */
	
	BytesPerWord - 1;
	anInstruction3 = genoperandoperand(AndCqR, BytesPerWord - 1, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant9 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant9, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin AddCq:R: */
	
	BytesPerWord - 1;
	anInstruction4 = genoperandoperand(AddCqR, BytesPerWord - 1, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, shiftForWord(), instSpecReg);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, fillReg);
	/* begin Jump: */
	jumpBytePrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpArrayFormat, checkQuickConstantforInstruction((((usqInt)maxSlots << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)maxSlots << 3) | 1), Arg0Reg)));
	/* begin JumpAbove: */
	jumpArrayTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	quickConstant10 = nilObject();
	genoperandoperand(MoveCqR, quickConstant10, fillReg);
	jmpTarget(jumpBytePrepDone, jmpTarget(jumpLongPrepDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant11 = numSlotsFullShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant11, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, byteSizeReg);
	/* begin JumpNonZero: */
	jumpHasSlots = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveCq:R: */
	
	BaseHeaderSize * 2;
	anInstruction5 = genoperandoperand(MoveCqR, BaseHeaderSize * 2, byteSizeReg);
	/* begin Jump: */
	skip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasSlots, checkQuickConstantforInstruction(BaseHeaderSize / BytesPerWord, genoperandoperand(AddCqR, BaseHeaderSize / BytesPerWord, byteSizeReg)));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	jmpTarget(skip, genoperandoperand(AddRR, Arg1Reg, byteSizeReg));
	/* begin CmpCq:R: */
	quickConstant12 = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant12, byteSizeReg);
	/* begin JumpAboveOrEqual: */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, byteSizeReg, address1);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, headerReg, 0, ReceiverResultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	
	BaseHeaderSize;
	anInstruction6 = genoperandoperandoperand(LoadEffectiveAddressMwrR, BaseHeaderSize, ReceiverResultReg, Arg1Reg);
	/* begin MoveR:Mw:r: */
	fillLoop = genoperandoperandoperand(MoveRMwr, fillReg, 0, Arg1Reg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 8, Arg1Reg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, byteSizeReg);
	/* begin JumpAbove: */
	genConditionalBranchoperand(JumpAbove, ((sqInt)fillLoop));
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNoSpace, jmpTarget(jumpUnhashed, jmpTarget(jumpFailCuzFixed, jmpTarget(jumpArrayTooBig, jmpTarget(jumpByteTooBig, jmpTarget(jumpLongTooBig, jmpTarget(jumpNElementsNonInt, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))))));
	return 0;
}


/*	Implement primitiveShallowCopy/primitiveClone for convenient cases:
	- the receiver is not a context
	- the receiver is not a compiled method
	- the result fits in eden (actually below scavengeThreshold) */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveShallowCopy */
static sqInt
genPrimitiveShallowCopy(void)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *continuance;
    AbstractInstruction *copyLoop;
    sqInt formatReg;
    AbstractInstruction *jumpEmpty;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpIsMethod;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpTooBig;
    AbstractInstruction *jumpVariable;
    sqInt ptrReg;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt resultReg;
    sqInt slotsReg;

	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	resultReg = Arg0Reg;

	/* get freeStart as early as possible so as not to wait later... */
	slotsReg = Arg1Reg;
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, resultReg);
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (ptrReg = (formatReg = SendNumArgsReg)), NoReg);
	/* begin CmpCq:R: */
	quickConstant = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = indexablePointersFormat();
	genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpZero: */
	jumpVariable = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin Label */
	continuance = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genGetRawSlotSizeOfNonImminto(ReceiverResultReg, slotsReg);
	/* begin CmpCq:R: */
	quickConstant2 = numSlotsMask();
	genoperandoperand(CmpCqR, quickConstant2, slotsReg);
	/* begin JumpZero: */
	jumpTooBig = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, slotsReg);
	/* begin JumpZero: */
	jumpEmpty = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant3 = BaseHeaderSize / BytesPerWord;
	genoperandoperand(AddCqR, quickConstant3, slotsReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), slotsReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, resultReg, slotsReg);
	/* begin CmpCq:R: */
	quickConstant4 = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant4, slotsReg);
	/* begin JumpAboveOrEqual: */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, resultReg, ptrReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, slotsReg, address1);
	/* begin SubCq:R: */
	
	BytesPerWord * 2;
	anInstruction = genoperandoperand(SubCqR, BytesPerWord * 2, slotsReg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, ReceiverResultReg, TempReg);
	/* begin AndCq:R: */
	quickConstant5 = headerForSlotsformatclassIndex(numSlotsMask(), formatMask(), classIndexMask());
	genoperandoperand(AndCqR, quickConstant5, TempReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, TempReg, 0, resultReg);
	/* begin Label */
	copyLoop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin AddCq:R: */
	
	BytesPerWord;
	anInstruction1 = genoperandoperand(AddCqR, BytesPerWord, ReceiverResultReg);
	/* begin AddCq:R: */
	
	BytesPerWord;
	anInstruction2 = genoperandoperand(AddCqR, BytesPerWord, ptrReg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, ReceiverResultReg, TempReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, TempReg, 0, ptrReg);
	/* begin CmpR:R: */
	assert(!((ptrReg == SPReg)));
	genoperandoperand(CmpRR, ptrReg, slotsReg);
	/* begin JumpAboveOrEqual: */
	genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)copyLoop));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, resultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpVariable, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genGetClassIndexOfNonImminto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, ClassReg);
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)continuance));
	jmpTarget(jumpImmediate, jmpTarget(jumpNoSpace, jmpTarget(jumpIsMethod, jmpTarget(jumpTooBig, jmpTarget(jumpEmpty, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	return 0;
}


/*	Generate the code for primitive 173, instVarAt:. Defer to
	StackInterpreterPrimitives>>primitiveSlotAt for Contexts.
 */
/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveSlotAt */
static sqInt
genPrimitiveSlotAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *convertToIntAndReturn;
    sqInt formatReg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsMethod;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpIsWords;
    AbstractInstruction *jumpLongsOutOfBounds;
    AbstractInstruction *jumpNonPointers;
    AbstractInstruction *jumpPointersOutOfBounds;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpToReturnLargeInteger;
    AbstractInstruction *jumpWordsOutOfBounds;
    sqInt nSlotsOrElementsReg;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;

	nSlotsOrElementsReg = ClassReg;
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, Arg1Reg);
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	genGetNumSlotsOfinto(ReceiverResultReg, nSlotsOrElementsReg);
	/* begin CmpCq:R: */
	quickConstant = sixtyFourBitIndexableFormat();
	genoperandoperand(CmpCqR, quickConstant, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpNonPointers = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin AndCq:R: */
	quickConstant1 = classIndexMask();
	genoperandoperand(AndCqR, quickConstant1, TempReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	/* begin JumpZero: */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpPointersOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant2 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant2, Arg1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNonPointers, checkQuickConstantforInstruction(firstByteFormat(), genoperandoperand(CmpCqR, firstByteFormat(), formatReg)));
	/* begin JumpAboveOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant3, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant4, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpLongsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant5 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant5, Arg1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant6 = (numSmallIntegerBits()) - 1;
	genoperandoperand(LogicalShiftRightCqR, quickConstant6, TempReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, TempReg);
	}
	/* begin JumpNonZero: */
	jumpToReturnLargeInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertIntegerInRegtoSmallIntegerInReg(ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpToReturnLargeInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpFailAlloc = genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(ClassReg, SendNumArgsReg, Extra0Reg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsBytes, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), nSlotsOrElementsReg));
	gAndCqRR(7, formatReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, nSlotsOrElementsReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant7 = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant7, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	
	/* formatReg already contains a value <= 16r1f, so no need to zero it */
	/* begin MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, formatReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, formatReg, ReceiverResultReg);
	/* begin Label */
	convertToIntAndReturn = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, nSlotsOrElementsReg));
	/* begin AndCq:R: */
	genoperandoperand(AndCqR, 3, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveM16:r:R: */
	
	BaseHeaderSize;
	anInstruction1 = genoperandoperandoperand(MoveM16rR, BaseHeaderSize, ReceiverResultReg, ReceiverResultReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpIsWords, gLogicalShiftLeftCqR((shiftForWord()) - 2, nSlotsOrElementsReg));
	/* begin AndCq:R: */
	genoperandoperand(AndCqR, 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant8 = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);
	genoperandoperand(AddCqR, quickConstant8, Arg1Reg);
	/* begin MoveX32r:R:R: */
	genoperandoperandoperand(MoveX32rRR, Arg1Reg, ReceiverResultReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpFailAlloc, jmpTarget(jumpLongsOutOfBounds, jmpTarget(jumpPointersOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpIsMethod, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpIsContext, jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))))))));
	return 0;
}


/*	Generate the code for primitive 174, instVarAt:put:. Defer to
	StackInterpreterPrimitives>>primitiveSlotAtPut for Contexts.
 */
/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveSlotAtPut */
static sqInt
genPrimitiveSlotAtPut(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt formatReg;
    AbstractInstruction *jump64BitArgIsImmediate;
    AbstractInstruction *jump64BitsOutOfBounds;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpBytesOutOfRange;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsCompiledMethod;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpIsWords;
    AbstractInstruction *jumpNonSmallIntegerValue;
    AbstractInstruction *jumpNot64BitIndexable;
    AbstractInstruction *jumpNot8ByteInteger;
    AbstractInstruction *jumpNotIndexableBits;
    AbstractInstruction *jumpNotPointers;
    AbstractInstruction *jumpPointersOutOfBounds;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpShortsOutOfRange;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfRange;
    sqInt nSlotsOrBytesReg;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant10;
    sqInt quickConstant11;
    sqInt quickConstant12;
    sqInt quickConstant13;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    sqInt quickConstant9;
    AbstractInstruction *rejoin;

	jumpImmutable = ((AbstractInstruction *) 0);
	nSlotsOrBytesReg = Extra0Reg;
	/* begin genLoadArgAtDepth:into: */
	assert(1 < (numRegArgs()));
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, Arg0Reg);
#  if IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	/* begin genJumpBaseHeaderImmutable: */
	
	quickConstant = immutableBitMask();
	genoperandoperand(TstCqR, quickConstant, TempReg);
	/* begin JumpNonZero: */
	jumpImmutable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
#  else // IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
#  endif // IMMUTABILITY
	genGetNumSlotsOfinto(ReceiverResultReg, nSlotsOrBytesReg);
	/* begin CmpCq:R: */
	quickConstant1 = weakArrayFormat();
	genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpAbove: */
	jumpNotPointers = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genGetClassIndexOfNonImminto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, ClassReg);
	/* begin JumpZero: */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genStoreCheckReceiverRegvalueRegscratchReginFrame(ReceiverResultReg, Arg1Reg, TempReg, 0);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpPointersOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant2 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant2, Arg0Reg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, Arg1Reg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotPointers, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNonSmallIntegerValue = genJumpNotSmallInteger(Arg1Reg);
	/* begin CmpCq:R: */
	quickConstant3 = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant3, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant4, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant5, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant6 = sixtyFourBitIndexableFormat();
	genoperandoperand(CmpCqR, quickConstant6, formatReg);
	/* begin JumpNonZero: */
	jumpNotIndexableBits = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, SendNumArgsReg);
	genConvertSmallIntegerToIntegerInReg(SendNumArgsReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	rejoin = genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jump64BitsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant7 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant7, Arg0Reg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, SendNumArgsReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNonSmallIntegerValue, checkQuickConstantforInstruction(sixtyFourBitIndexableFormat(), genoperandoperand(CmpCqR, sixtyFourBitIndexableFormat(), formatReg)));
	/* begin JumpNonZero: */
	jumpNot64BitIndexable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* Now check if the header is that of an 8 byte LargePositiveInteger */
	jump64BitArgIsImmediate = genJumpImmediate(Arg1Reg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, Arg1Reg, SendNumArgsReg);
	/* begin AndCq:R: */
	quickConstant8 = headerForSlotsformatclassIndex(numSlotsMask(), formatMask(), classIndexMask());
	genoperandoperand(AndCqR, quickConstant8, SendNumArgsReg);
	/* begin CmpCq:R: */
	quickConstant9 = headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargePositiveIntegerCompactIndex);
	genoperandoperand(CmpCqR, quickConstant9, SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNot8ByteInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, SendNumArgsReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)rejoin));
	jmpTarget(jumpIsWords, checkQuickConstantforInstruction((((usqInt)0xFFFFFFFFU << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)0xFFFFFFFFU << 3) | 1), Arg1Reg)));
	/* begin JumpAbove: */
	jumpWordsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, nSlotsOrBytesReg);
	/* begin AndCq:R: */
	quickConstant10 = (BytesPerWord / 4) - 1;
	genoperandoperand(AndCqR, quickConstant10, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddCq:R: */
	quickConstant11 = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);
	genoperandoperand(AddCqR, quickConstant11, Arg0Reg);
	/* begin MoveR:X32r:R: */
	genoperandoperandoperand(MoveRX32rR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, checkQuickConstantforInstruction((((usqInt)0xFFFF << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)0xFFFF << 3) | 1), Arg1Reg)));
	/* begin JumpAbove: */
	jumpShortsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 1, nSlotsOrBytesReg);
	/* begin AndCq:R: */
	quickConstant12 = (BytesPerWord / 2) - 1;
	genoperandoperand(AndCqR, quickConstant12, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:M16:r: */
	
	BaseHeaderSize;
	anInstruction1 = genoperandoperandoperand(MoveRM16r, TempReg, BaseHeaderSize, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsBytes, checkQuickConstantforInstruction((((usqInt)0xFF << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)0xFF << 3) | 1), Arg1Reg)));
	/* begin JumpAbove: */
	jumpBytesOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), nSlotsOrBytesReg);
	gAndCqRR(BytesPerWord - 1, formatReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, nSlotsOrBytesReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant13 = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant13, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsCompiledMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddCq:R: */
	
	BaseHeaderSize;
	anInstruction2 = genoperandoperand(AddCqR, BaseHeaderSize, Arg0Reg);
	/* begin MoveR:Xbr:R: */
	genoperandoperandoperand(MoveRXbrR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNot8ByteInteger, jmpTarget(jump64BitArgIsImmediate, jmpTarget(jumpNot64BitIndexable, jmpTarget(jumpIsContext, jmpTarget(jumpNotIndexableBits, jmpTarget(jumpBytesOutOfRange, jmpTarget(jumpShortsOutOfRange, jmpTarget(jumpWordsOutOfRange, jmpTarget(jumpIsCompiledMethod, jmpTarget(jumpPointersOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jump64BitsOutOfBounds, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))))))))))));
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, ((AbstractInstruction *) (((jumpIsContext->operands))[0])));
#  endif
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 1, Arg0Reg);
	genConvertIntegerToSmallIntegerInReg(Arg0Reg);
	jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}


/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveStringAt */
static sqInt
genPrimitiveStringAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *done;
    sqInt formatReg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpWordsDone;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordTooBig;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, Arg1Reg);
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	quickConstant = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant, formatReg);
	/* begin JumpGreaterOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpGreaterOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant2, formatReg);
	/* begin JumpLess: */
	jumpNotIndexable = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, ClassReg);
	/* begin AndCq:R: */
	quickConstant3 = (BytesPerWord / 4) - 1;
	genoperandoperand(AndCqR, quickConstant3, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant4 = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);
	genoperandoperand(AddCqR, quickConstant4, Arg1Reg);
	/* begin MoveX32r:R:R: */
	genoperandoperandoperand(MoveX32rRR, Arg1Reg, ReceiverResultReg, TempReg);
	jumpWordTooBig = jumpNotCharacterUnsignedValueInRegister(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin Jump: */
	jumpWordsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsBytes, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), ClassReg));
	/* begin AndCq:R: */
	
	BytesPerWord - 1;
	anInstruction = genoperandoperand(AndCqR, BytesPerWord - 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	
	BaseHeaderSize;
	anInstruction1 = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	/* begin MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin AndCq:R: */
	genoperandoperand(AndCqR, 0xFF, ReceiverResultReg);
	jmpTarget(jumpWordsDone, (done = genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genConvertIntegerToCharacterInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, ClassReg));
	/* begin AndCq:R: */
	quickConstant5 = (BytesPerWord / 2) - 1;
	genoperandoperand(AndCqR, quickConstant5, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	assert(!((Arg1Reg == SPReg)));
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveM16:r:R: */
	
	BaseHeaderSize;
	anInstruction2 = genoperandoperandoperand(MoveM16rR, BaseHeaderSize, ReceiverResultReg, ReceiverResultReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)done));
	jmpTarget(jumpWordTooBig, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpNotIndexable, jmpTarget(jumpBadIndex, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))));
	return CompletePrimitive;
}


/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveStringAtPut */
static sqInt
genPrimitiveStringAtPut(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt formatReg;
    AbstractInstruction *jumpBadArg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpBytesOutOfRange;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsCompiledMethod;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpNotString;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpShortsOutOfRange;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfRange;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;

	jumpImmutable = ((AbstractInstruction *) 0);
	/* begin genLoadArgAtDepth:into: */
	assert(1 < (numRegArgs()));
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	jumpBadArg = genJumpNotCharacter(Arg1Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, Arg0Reg);
#  if IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	/* begin genJumpBaseHeaderImmutable: */
	
	quickConstant = immutableBitMask();
	genoperandoperand(TstCqR, quickConstant, TempReg);
	/* begin JumpNonZero: */
	jumpImmutable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
#  else // IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
#  endif // IMMUTABILITY
	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	quickConstant1 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpBelow: */
	jumpNotString = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant2, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsCompiledMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant3, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant4, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = characterObjectOf((1U << (numCharacterBits())) - 1);
	genoperandoperand(CmpCqR, quickConstant5, Arg1Reg);
	/* begin JumpAbove: */
	jumpWordsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, ClassReg);
	/* begin AndCq:R: */
	quickConstant6 = (BytesPerWord / 4) - 1;
	genoperandoperand(AndCqR, quickConstant6, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);
	/* begin AddCq:R: */
	quickConstant7 = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);
	genoperandoperand(AddCqR, quickConstant7, Arg0Reg);
	/* begin MoveR:X32r:R: */
	genoperandoperandoperand(MoveRX32rR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gCmpCqR(characterObjectOf(0xFFFF), Arg1Reg));
	/* begin JumpAbove: */
	jumpShortsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 1, ClassReg);
	/* begin AndCq:R: */
	quickConstant8 = (BytesPerWord / 2) - 1;
	genoperandoperand(AndCqR, quickConstant8, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:M16:r: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveRM16r, TempReg, BaseHeaderSize, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsBytes, gCmpCqR(characterObjectOf(0xFF), Arg1Reg));
	/* begin JumpAbove: */
	jumpBytesOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), ClassReg);
	/* begin AndCq:R: */
	
	BytesPerWord - 1;
	anInstruction1 = genoperandoperand(AndCqR, BytesPerWord - 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);
	/* begin AddCq:R: */
	
	BaseHeaderSize;
	anInstruction2 = genoperandoperand(AddCqR, BaseHeaderSize, Arg0Reg);
	/* begin MoveR:Xbr:R: */
	genoperandoperandoperand(MoveRXbrR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotString, jmpTarget(jumpBytesOutOfRange, jmpTarget(jumpShortsOutOfRange, jmpTarget(jumpWordsOutOfRange, jmpTarget(jumpIsCompiledMethod, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))))));
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, ((AbstractInstruction *) (((jumpNotString->operands))[0])));
#  endif
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 1, Arg0Reg);
	genConvertIntegerToSmallIntegerInReg(Arg0Reg);
	jmpTarget(jumpBadArg, jmpTarget(jumpBadIndex, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	Implement primitiveUninitializedNewWithArg for convenient cases:
	- the receiver has a hash
	- the receiver is variable and not compiled method
	- the result fits in eden
	See superclass method for dynamic frequencies of formats.
	For the moment we implement only arrayFormat, firstByteFormat &
	firstLongFormat 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveUninitializedNewWithArg */
static sqInt
genPrimitiveUninitializedNewWithArg(void)
{
    sqInt address;
    sqInt address1;
    sqInt address2;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    sqInt byteSizeReg;
    sqInt fillReg;
    sqInt headerReg;
    sqInt instSpecReg;
    AbstractInstruction *jumpByteFormat;
    AbstractInstruction *jumpByteTooBig;
    AbstractInstruction *jumpDoubleByteFormat;
    AbstractInstruction *jumpDoubleBytePrepDone;
    AbstractInstruction *jumpDoubleWordFormat;
    AbstractInstruction *jumpDoubleWordPrepDone;
    AbstractInstruction *jumpDoubleWordTooBig;
    AbstractInstruction *jumpFailCuzFixed;
    AbstractInstruction *jumpHasSlots;
    AbstractInstruction *jumpLongPrepDone;
    AbstractInstruction *jumpLongTooBig;
    AbstractInstruction *jumpNElementsNonInt;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpNoSpaceBigObjects;
    AbstractInstruction *jumpOverflowHeader;
    AbstractInstruction *jumpShortTooBig;
    AbstractInstruction *jumpUnhashed;
    sqInt maxSlots;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant10;
    sqInt quickConstant11;
    sqInt quickConstant12;
    sqInt quickConstant13;
    sqInt quickConstant14;
    sqInt quickConstant15;
    sqInt quickConstant16;
    sqInt quickConstant17;
    sqInt quickConstant18;
    sqInt quickConstant19;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    sqInt quickConstant9;
    AbstractInstruction *skip;

	if (methodOrBlockNumArgs != 1) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));

	/* Assume there's an available scratch register on 64-bit machines.  This holds the saved numFixedFields and then the value to fill with */
	headerReg = SendNumArgsReg;
	fillReg = Extra0Reg;
	assert(fillReg > 0);

	/* Allow a max of 1 MB */
	instSpecReg = (byteSizeReg = ClassReg);

	/* get freeStart as early as possible so as not to wait later... */
	maxSlots = maxSlotsForNewSpaceAlloc();
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, Arg1Reg);
	genGetHashFieldNonImmOfinto(ReceiverResultReg, headerReg);
	/* begin JumpZero: */
	jumpUnhashed = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNElementsNonInt = genJumpNotSmallInteger(Arg0Reg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, ReceiverResultReg, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = (fixedFieldsFieldWidth()) + (numSmallIntegerTagBits());
	genoperandoperand(LogicalShiftRightCqR, quickConstant, instSpecReg);
	/* begin AndCq:R: */
	quickConstant1 = formatMask();
	genoperandoperand(AndCqR, quickConstant1, instSpecReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant2 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant2, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, fillReg);
	genConvertSmallIntegerToIntegerInReg(fillReg);
	/* begin CmpCq:R: */
	quickConstant3 = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant3, instSpecReg);
	/* begin JumpZero: */
	jumpByteFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant4, instSpecReg);
	/* begin JumpZero: */
	jumpDoubleByteFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = sixtyFourBitIndexableFormat();
	genoperandoperand(CmpCqR, quickConstant5, instSpecReg);
	/* begin JumpZero: */
	jumpDoubleWordFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant6 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant6, instSpecReg);
	/* begin JumpNonZero: */
	jumpFailCuzFixed = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin CmpCq:R: */
	
	(((usqInt)(maxSlots * 2) << 3) | 1);
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)(maxSlots * 2) << 3) | 1), Arg0Reg);
	/* begin JumpAbove: */
	jumpLongTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	
	BytesPerWord / 4;
	anInstruction1 = genoperandoperand(MoveCqR, BytesPerWord / 4, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	/* begin AndCq:R: */
	quickConstant7 = (BytesPerWord / 4) - 1;
	genoperandoperand(AndCqR, quickConstant7, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant8 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant8, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin AddCq:R: */
	quickConstant9 = (BytesPerWord / 4) - 1;
	genoperandoperand(AddCqR, quickConstant9, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, (shiftForWord()) - 2, instSpecReg);
	/* begin Jump: */
	jumpLongPrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpDoubleByteFormat, checkQuickConstantforInstruction((((usqInt)(maxSlots * 4) << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)(maxSlots * 4) << 3) | 1), Arg0Reg)));
	/* begin JumpAbove: */
	jumpShortTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	
	BytesPerWord / 2;
	anInstruction2 = genoperandoperand(MoveCqR, BytesPerWord / 2, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	/* begin AndCq:R: */
	quickConstant10 = (BytesPerWord / 2) - 1;
	genoperandoperand(AndCqR, quickConstant10, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant11 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant11, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin AddCq:R: */
	quickConstant12 = (BytesPerWord / 2) - 1;
	genoperandoperand(AddCqR, quickConstant12, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, (shiftForWord()) - 1, instSpecReg);
	/* begin Jump: */
	jumpDoubleBytePrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpDoubleWordFormat, checkQuickConstantforInstruction((((usqInt)maxSlots << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)maxSlots << 3) | 1), Arg0Reg)));
	/* begin JumpAbove: */
	jumpDoubleWordTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin Jump: */
	jumpDoubleWordPrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpByteFormat, checkQuickConstantforInstruction((((usqInt)(maxSlots * BytesPerWord) << 3) | 1), genoperandoperand(CmpCqR, (((usqInt)(maxSlots * BytesPerWord) << 3) | 1), Arg0Reg)));
	/* begin JumpAbove: */
	jumpByteTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	
	BytesPerWord;
	anInstruction3 = genoperandoperand(MoveCqR, BytesPerWord, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	/* begin AndCq:R: */
	
	BytesPerWord - 1;
	anInstruction4 = genoperandoperand(AndCqR, BytesPerWord - 1, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant13 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant13, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin AddCq:R: */
	
	BytesPerWord - 1;
	anInstruction5 = genoperandoperand(AddCqR, BytesPerWord - 1, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, shiftForWord(), instSpecReg);
	jmpTarget(jumpDoubleWordPrepDone, jmpTarget(jumpDoubleBytePrepDone, jmpTarget(jumpLongPrepDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	/* begin CmpCq:R: */
	quickConstant14 = numSlotsMask();
	genoperandoperand(CmpCqR, quickConstant14, instSpecReg);
	/* begin JumpAboveOrEqual: */
	jumpOverflowHeader = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant15 = numSlotsFullShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant15, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, byteSizeReg);
	/* begin JumpNonZero: */
	jumpHasSlots = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveCq:R: */
	
	BaseHeaderSize * 2;
	anInstruction6 = genoperandoperand(MoveCqR, BaseHeaderSize * 2, byteSizeReg);
	/* begin Jump: */
	skip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasSlots, checkQuickConstantforInstruction(BaseHeaderSize / BytesPerWord, genoperandoperand(AddCqR, BaseHeaderSize / BytesPerWord, byteSizeReg)));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	jmpTarget(skip, genoperandoperand(AddRR, Arg1Reg, byteSizeReg));
	/* begin CmpCq:R: */
	quickConstant16 = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant16, byteSizeReg);
	/* begin JumpAboveOrEqual: */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, byteSizeReg, address1);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, headerReg, 0, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOverflowHeader, checkQuickConstantforInstruction(0xFF, genoperandoperand(MoveCqR, 0xFF, TempReg)));
	/* begin LogicalShiftLeftCq:R: */
	quickConstant17 = numSlotsFullShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant17, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, instSpecReg, TempReg);
	/* begin AddCq:R: */
	quickConstant18 = (BaseHeaderSize * 2) / BytesPerWord;
	genoperandoperand(AddCqR, quickConstant18, byteSizeReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, byteSizeReg);
	/* begin CmpCq:R: */
	quickConstant19 = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant19, byteSizeReg);
	/* begin JumpAboveOrEqual: */
	jumpNoSpaceBigObjects = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveR:Aw: */
	address2 = freeStartAddress();
	genoperandoperand(MoveRAw, byteSizeReg, address2);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	/* begin MoveR:Mw:r: */
	
	BaseHeaderSize;
	anInstruction7 = genoperandoperandoperand(MoveRMwr, headerReg, BaseHeaderSize, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpShortTooBig, jmpTarget(jumpDoubleWordTooBig, jmpTarget(jumpNoSpaceBigObjects, jmpTarget(jumpNoSpace, jmpTarget(jumpUnhashed, jmpTarget(jumpFailCuzFixed, jmpTarget(jumpByteTooBig, jmpTarget(jumpLongTooBig, jmpTarget(jumpNElementsNonInt, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))))))));
	return 0;
}


/*	In the Pure version, mixed arithmetic with SmallInteger is forbidden */

	/* CogObjectRepresentationFor64BitSpur>>#genPureFloatArithmetic:preOpCheck:boxed: */
static sqInt NoDbgRegParms
genPureFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed)
{
    AbstractInstruction *doOp;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFailCheck;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;

	jumpFailCheck = ((AbstractInstruction *) 0);
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	/* begin Label */
	doOp = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (!(preOpCheckOrNil == null)) {
		jumpFailCheck = preOpCheckOrNil(DPFPReg0, DPFPReg1);
	}
	genoperandoperand(arithmeticOperator, DPFPReg1, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	if (!(preOpCheckOrNil == null)) {
		jmpTarget(jumpFailCheck, ((AbstractInstruction *) (((jumpFailAlloc->operands))[0])));
	}
	return 0;
}


/*	In the Pure version, mixed arithmetic with SmallInteger is forbidden */

	/* CogObjectRepresentationFor64BitSpur>>#genPureFloatComparison:invert:boxed: */
static sqInt NoDbgRegParms
genPureFloatComparisoninvertboxed(AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt invertComparison, sqInt rcvrBoxed)
{
    AbstractInstruction *compareFloat;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	if (invertComparison) {

		/* May need to invert for NaNs */
		/* begin CmpRd:Rd: */
		compareFloat = genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		/* begin CmpRd:Rd: */
		compareFloat = genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}

	/* FP jumps are a little weird */
	jumpCond = jumpFPOpcodeGenerator(0);
	if (shouldAnnotateObjectReference(falseObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, falseObject(), ReceiverResultReg), falseObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = falseObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, (shouldAnnotateObjectReference(trueObject())
		? annotateobjRef(genoperandoperand(MoveCwR, trueObject(), ReceiverResultReg), trueObject())
		: (/* begin MoveCq:R: */
			(quickConstant1 = trueObject()),
			genoperandoperand(MoveCqR, quickConstant1, ReceiverResultReg))));
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)compareFloat));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentationFor64BitSpur>>#genRemoveSmallIntegerTagsInScratchReg: */
static sqInt NoDbgRegParms
genRemoveSmallIntegerTagsInScratchReg(sqInt scratchReg)
{
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, scratchReg);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genShiftAwaySmallIntegerTagsInScratchReg: */
static sqInt NoDbgRegParms
genShiftAwaySmallIntegerTagsInScratchReg(sqInt scratchReg)
{
    sqInt quickConstant;

	/* begin ArithmeticShiftRightCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, scratchReg);
	return 0;
}


/*	Stack looks like
	return address */

	/* CogObjectRepresentationFor64BitSpur>>#genSmallIntegerComparison:orDoubleComparison:invert: */
static sqInt NoDbgRegParms
genSmallIntegerComparisonorDoubleComparisoninvert(sqInt jumpOpcode, AbstractInstruction * NoDbgRegParms (*jumpFPOpcodeGenerator)(void *), sqInt invertComparison)
{
    AbstractInstruction *compareIntFloat;
    AbstractInstruction *jumpAmbiguous;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotFloatAtAll;
    AbstractInstruction *jumpNotSmallFloat;
    AbstractInstruction *jumpTrue;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt r;
    AbstractInstruction *returnTrue;

	r = genSmallIntegerComparison(jumpOpcode);
	if (r < 0) {
		return r;
	}
#  if defined(DPFPReg0)

	/* Fall through on non-SmallInteger argument.  Argument may be a Float : let us check or fail */
	/* check for Small Float argument */
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	/* begin Label */
	compareIntFloat = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertSmallIntegerToIntegerInReg(ReceiverResultReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, ReceiverResultReg, DPFPReg0);
	/* begin CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);

	/* Case of non ambiguity, use compareFloat((double) intRcvr,floatArg) */
	jumpAmbiguous = gJumpFPEqual(0);
	if (invertComparison) {

		/* May need to invert for NaNs */
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}

	/* FP jumps are a little weird */
	jumpCond = jumpFPOpcodeGenerator(0);
	if (shouldAnnotateObjectReference(falseObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, falseObject(), ReceiverResultReg), falseObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = falseObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, (shouldAnnotateObjectReference(trueObject())
		? (returnTrue = annotateobjRef(genoperandoperand(MoveCwR, trueObject(), ReceiverResultReg), trueObject()))
		: (/* begin MoveCq:R: */
			(quickConstant1 = trueObject()),
			(returnTrue = genoperandoperand(MoveCqR, quickConstant1, ReceiverResultReg)))));
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpAmbiguous, genoperandoperand(ConvertRdR, DPFPReg1, Arg0Reg));
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpTrue = genConditionalBranchoperand(jumpOpcode, 0);
	if (shouldAnnotateObjectReference(falseObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, falseObject(), ReceiverResultReg), falseObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant2 = falseObject();
		genoperandoperand(MoveCqR, quickConstant2, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpTrue, returnTrue);
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpNotFloatAtAll = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)compareIntFloat));
	jmpTarget(jumpNotBoxedFloat, jmpTarget(jumpNotFloatAtAll, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
#  endif // defined(DPFPReg0)
	return CompletePrimitive;
}


/*	Get the literal count of a CompiledMethod into headerReg, plus one if
	requested. If inBytes is true, scale the count by the word size. Deal with
	the possibility of
	the method being cogged. */

	/* CogObjectRepresentationFor64BitSpur>>#getLiteralCountOf:plusOne:inBytes:into:scratch: */
static sqInt NoDbgRegParms
getLiteralCountOfplusOneinBytesintoscratch(sqInt methodReg, sqInt plusOne, sqInt inBytes, sqInt litCountReg, sqInt scratchReg)
{
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;

	genGetMethodHeaderOfintoscratch(methodReg, litCountReg, scratchReg);
	assert((1U << (numTagBits())) == BytesPerWord);
	if (inBytes) {
		/* begin AndCq:R: */
		quickConstant = ((sqInt)((usqInt)((alternateHeaderNumLiteralsMask())) << (numTagBits())));
		genoperandoperand(AndCqR, quickConstant, litCountReg);
	}
	else {
		/* begin LogicalShiftRightCq:R: */
		quickConstant1 = numTagBits();
		genoperandoperand(LogicalShiftRightCqR, quickConstant1, litCountReg);
		/* begin AndCq:R: */
		quickConstant2 = alternateHeaderNumLiteralsMask();
		genoperandoperand(AndCqR, quickConstant2, litCountReg);
	}
	if (plusOne) {
		/* begin AddCq:R: */
		quickConstant3 = (inBytes
			? LiteralStart * BytesPerWord
			: LiteralStart);
		genoperandoperand(AddCqR, quickConstant3, litCountReg);
	}
	return 0;
}


/*	Answer the relevant inline cache tag for an instance.
	c.f. getInlineCacheClassTagFrom:into: & inlineCacheTagForClass: */

	/* CogObjectRepresentationFor64BitSpur>>#inlineCacheTagForInstance: */
static sqInt NoDbgRegParms
inlineCacheTagForInstance(sqInt oop)
{
	return (isImmediate(oop)
		? oop & (tagMask())
		: classIndexOf(oop));
}

	/* CogObjectRepresentationFor64BitSpur>>#log2BytesPerWord */
static sqInt
log2BytesPerWord(void)
{
	return 3;
}


/*	Generate the routine that converts selector indices into selector objects.
	It is called from the send trampolines.
	If the selector index is negative, convert it into a positive index into
	the special selectors array and index that. Otherwise, index the current
	method. The routine uses Extra0Reg & Extra1Reg, which are available, since
	they are not live at point of send. */

	/* CogObjectRepresentationFor64BitSpur>>#maybeGenerateSelectorIndexDereferenceRoutine */
static void
maybeGenerateSelectorIndexDereferenceRoutine(void)
{
    sqInt address;
    sqInt byteOffset;
    AbstractInstruction *jumpFullBlock;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNotBlock;
    sqInt offset;
    sqInt offset1;
    sqInt quickConstant;
    sqInt quickConstant1;

	jumpFullBlock = ((AbstractInstruction *) 0);
	zeroOpcodeIndex();
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpLess: */
	jumpNegative = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, FoxMethod, FPReg, Extra0Reg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 2, ClassReg);
	/* begin TstCq:R: */
	genoperandoperand(TstCqR, MFMethodFlagIsBlockFlag, Extra0Reg);
	/* begin JumpZero: */
	jumpNotBlock = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin AndCq:R: */
	quickConstant = -(zoneAlignment());
	genoperandoperand(AndCqR, quickConstant, Extra0Reg);
	/* begin bitAndByteOffsetOfIsFullBlockBitInto: */
	byteOffset = BaseHeaderSize + 1;
	/* begin MoveMb:r:R: */
	genoperandoperandoperand(MoveMbrR, byteOffset, Extra0Reg, Extra1Reg);
	/* begin TstCq:R: */
	genoperandoperand(TstCqR, 16, Extra1Reg);
	/* begin JumpNonZero: */
	jumpFullBlock = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveM16:r:R: */
	genoperandoperandoperand(MoveM16rR, 0, Extra0Reg, Extra1Reg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, Extra1Reg, Extra0Reg);
	jmpTarget(jumpNotBlock, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jmpTarget(jumpFullBlock, ((AbstractInstruction *) (((jumpNotBlock->operands))[0])));
	/* begin AndCq:R: */
	quickConstant1 = -(zoneAlignment());
	genoperandoperand(AndCqR, quickConstant1, Extra0Reg);
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodObject);
	genoperandoperandoperand(MoveMwrR, offset, Extra0Reg, Extra1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, ClassReg, Extra1Reg, ClassReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNegative, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin NegateR: */
	genoperand(NegateR, ClassReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 1, ClassReg);
	/* begin MoveAw:R: */
	address = specialObjectsOopAddress();
	genoperandoperand(MoveAwR, address, Extra0Reg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, ClassReg);
	/* begin MoveMw:r:R: */
	offset1 = (SpecialSelectors + 1) * BytesPerWord;
	genoperandoperandoperand(MoveMwrR, offset1, Extra0Reg, Extra1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, ClassReg, Extra1Reg, ClassReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	ceDereferenceSelectorIndex = methodZoneBase();
	outputInstructionsForGeneratedRuntimeAt(ceDereferenceSelectorIndex);
	recordGeneratedRunTimeaddress("ceDereferenceSelectorIndex", ceDereferenceSelectorIndex);
	recordRunTimeObjectReferences();
}

	/* CogObjectRepresentationFor64BitSpur>>#numSmallIntegerBits */
static sqInt
numSmallIntegerBits(void)
{
	return 61;
}

	/* CogObjectRepresentationFor64BitSpur>>#numSmallIntegerTagBits */
static sqInt
numSmallIntegerTagBits(void)
{
	return 3;
}


/*	The three valid tag patterns are 1 (SmallInteger), 2 (Character) and 3
	(SmallFloat64). 
 */

	/* CogObjectRepresentationFor64BitSpur>>#validInlineCacheTag: */
static sqInt NoDbgRegParms
validInlineCacheTag(sqInt classIndexOrTagPattern)
{
	return ((classIndexOrTagPattern >= 1)
	 && (classIndexOrTagPattern <= 3))
	 || ((classAtIndex(classIndexOrTagPattern)) != null);
}

	/* CogObjectRepresentationForSpur>>#callStoreCheckTrampoline */
static void
callStoreCheckTrampoline(void)
{
    AbstractInstruction *abstractInstruction;

	/* begin annotateCall: */
	abstractInstruction = genoperand(Call, ceStoreCheckTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	return;
}

	/* CogObjectRepresentationForSpur>>#checkValidDerivedObjectReference: */
static sqInt NoDbgRegParms
checkValidDerivedObjectReference(sqInt bodyAddress)
{
	return (heapMapAtWord(pointerForOop(bodyAddress - BaseHeaderSize))) != 0;
}

	/* CogObjectRepresentationForSpur>>#checkValidOopReference: */
static sqInt NoDbgRegParms
checkValidOopReference(sqInt anOop)
{
	return (isImmediate(anOop))
	 || ((heapMapAtWord(pointerForOop(anOop))) != 0);
}

	/* CogObjectRepresentationForSpur>>#couldBeDerivedObject: */
static sqInt NoDbgRegParms
couldBeDerivedObject(sqInt bodyAddress)
{
	return oopisGreaterThanOrEqualTo(bodyAddress - BaseHeaderSize, startOfMemory());
}

	/* CogObjectRepresentationForSpur>>#couldBeObject: */
static sqInt NoDbgRegParms
couldBeObject(sqInt literal)
{
	return (isNonImmediate(literal))
	 && (oopisGreaterThanOrEqualTo(literal, startOfMemory()));
}


/*	Create a trampoline to answer the active context that will
	answer it if a frame is already married, and create it otherwise.
	Assume numArgs is in SendNumArgsReg and ClassReg is free. */

	/* CogObjectRepresentationForSpur>>#genActiveContextTrampolineLarge:inBlock:called: */
static usqInt NoDbgRegParms
genActiveContextTrampolineLargeinBlockcalled(sqInt isLarge, sqInt isInBlock, char *aString)
{
    usqInt startAddress;

	startAddress = methodZoneBase();
	zeroOpcodeIndex();
	genGetActiveContextLargeinBlock(isLarge, isInBlock);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(aString, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Check the remembered bit of the object in objReg; answer the jump taken if
	the bit is already set.
	Only need to fetch the byte containing it, which reduces the size of the
	mask constant.
 */

	/* CogObjectRepresentationForSpur>>#genCheckRememberedBitOf:scratch: */
static AbstractInstruction * NoDbgRegParms
genCheckRememberedBitOfscratch(sqInt objReg, sqInt scratchReg)
{
    sqInt mask;
    sqInt rememberedBitByteOffset;

	rememberedBitByteOffset = (rememberedBitShift()) / 8;
	mask = 1ULL << ((rememberedBitShift()) % 8);
	/* begin MoveMb:r:R: */
	genoperandoperandoperand(MoveMbrR, rememberedBitByteOffset, objReg, scratchReg);
	/* begin TstCq:R: */
	genoperandoperand(TstCqR, mask, scratchReg);
	/* begin JumpNonZero: */
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}

	/* CogObjectRepresentationForSpur>>#genConvertCharacterToCodeInReg: */
static sqInt NoDbgRegParms
genConvertCharacterToCodeInReg(sqInt reg)
{
    sqInt quickConstant;

	/* begin LogicalShiftRightCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(LogicalShiftRightCqR, quickConstant, reg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genConvertIntegerToCharacterInReg: */
static sqInt NoDbgRegParms
genConvertIntegerToCharacterInReg(sqInt reg)
{
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin LogicalShiftLeftCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, reg);
	/* begin AddCq:R: */
	quickConstant1 = characterTag();
	genoperandoperand(AddCqR, quickConstant1, reg);
	return 0;
}


/*	Create a closure with the given startpc, numArgs and numCopied
	within a context with ctxtNumArgs, large if isLargeCtxt that is in a
	block if isInBlock. If numCopied > 0 pop those values off the stack. */

	/* CogObjectRepresentationForSpur>>#genCreateClosureAt:numArgs:numCopied:contextNumArgs:large:inBlock: */
static sqInt NoDbgRegParms
genCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock)
{
    sqInt i;
    sqInt offset;

	genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(bcpc, numArgs, numCopied, ctxtNumArgs, isLargeCtxt, isInBlock);
	for (i = 1; i <= numCopied; i += 1) {
		/* begin PopR: */
		genoperand(PopR, TempReg);
		/* begin MoveR:Mw:r: */
		offset = (((numCopied - i) + ClosureFirstCopiedValueIndex) * BytesPerOop) + BaseHeaderSize;
		genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	}
	return 0;
}


/*	Create a full closure with the given values. */

	/* CogObjectRepresentationForSpur>>#genCreateFullClosure:numArgs:numCopied:ignoreContext:contextNumArgs:large:inBlock: */
static sqInt NoDbgRegParms
genCreateFullClosurenumArgsnumCopiedignoreContextcontextNumArgslargeinBlock(sqInt compiledBlock, sqInt numArgs, sqInt numCopied, sqInt ignoreContext, sqInt contextNumArgs, sqInt contextIsLarge, sqInt contextIsBlock)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    usqInt byteSize;
    usqLong header;
    sqInt numSlots;
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt quickConstant;
    sqInt quickConstant1;
    AbstractInstruction *skip;


	/* First get thisContext into ReceiverResultReg and thence in ClassReg. */
	if (ignoreContext) {
		if (shouldAnnotateObjectReference(nilObject())) {
			annotateobjRef(genoperandoperand(MoveCwR, nilObject(), ClassReg), nilObject());
		}
		else {
			/* begin MoveCq:R: */
			quickConstant1 = nilObject();
			genoperandoperand(MoveCqR, quickConstant1, ClassReg);
		}
	}
	else {
		genGetActiveContextNumArgslargeinBlock(contextNumArgs, contextIsLarge, contextIsBlock);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	}
	numSlots = FullClosureFirstCopiedValueIndex + numCopied;
	byteSize = smallObjectBytesForSlots(numSlots);
	assert(ClassFullBlockClosureCompactIndex != 0);
	header = headerForSlotsformatclassIndex(numSlots, indexablePointersFormat(), ClassFullBlockClosureCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, ReceiverResultReg);
	/* begin genStoreHeader:intoNewInstance:using: */
	
	genoperandoperand(MoveCqR, header, TempReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	genoperandoperandoperand(LoadEffectiveAddressMwrR, byteSize, ReceiverResultReg, TempReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, TempReg, address1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpBelow: */
	skip = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin MoveR:Mw:r: */
	offset = (ClosureOuterContextIndex * BytesPerOop) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, ClassReg, offset, ReceiverResultReg);
	/* begin genMoveConstant:R: */
	if (shouldAnnotateObjectReference(compiledBlock)) {
		annotateobjRef(checkLiteralforInstruction(compiledBlock, genoperandoperand(MoveCwR, compiledBlock, TempReg)), compiledBlock);
	}
	else {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, compiledBlock, TempReg);
	}
	/* begin MoveR:Mw:r: */
	offset1 = (ClosureStartPCIndex * BytesPerOop) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, TempReg, offset1, ReceiverResultReg);
	/* begin MoveCq:R: */
	
	(((usqInt)numArgs << 3) | 1);
	anInstruction = genoperandoperand(MoveCqR, (((usqInt)numArgs << 3) | 1), TempReg);
	/* begin MoveR:Mw:r: */
	offset2 = (ClosureNumArgsIndex * BytesPerOop) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, TempReg, offset2, ReceiverResultReg);
	return 0;
}


/*	Make sure that the object in reg is not forwarded. This routine assumes
	the object will
	never be forwarded to an immediate, as it is used to unforward literal
	variables (associations). 
	Use the fact that isForwardedObjectClassIndexPun is a power of two to save
	an instruction. */

	/* CogObjectRepresentationForSpur>>#genEnsureObjInRegNotForwarded:scratchReg: */
static sqInt NoDbgRegParms
genEnsureObjInRegNotForwardedscratchReg(sqInt reg, sqInt scratch)
{
    AbstractInstruction *loop;
    AbstractInstruction *ok;
    sqInt quickConstant;

	assert(reg != scratch);
	/* begin Label */
	loop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, reg, scratch);
	/* begin AndCq:R: */
	quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());
	genoperandoperand(AndCqR, quickConstant, scratch);
	/* begin JumpNonZero: */
	ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, reg, reg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)loop));
	jmpTarget(ok, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	Make sure that the oop in reg is not forwarded. 
	Use the fact that isForwardedObjectClassIndexPun is a power of two to save
	an instruction. */
/*	maybe a fixup or an instruction */
/*	maybe a fixup or an instruction */

	/* CogObjectRepresentationForSpur>>#genEnsureOopInRegNotForwarded:scratchReg:ifForwarder:ifNotForwarder: */
static sqInt NoDbgRegParms
genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(sqInt reg, sqInt scratch, void *fwdJumpTarget, void *nonFwdJumpTargetOrZero)
{
    AbstractInstruction *finished;
    AbstractInstruction *imm;
    AbstractInstruction *ok;
    sqInt quickConstant;

	assert(reg != scratch);

	/* notionally
	   self genGetClassIndexOfNonImm: reg into: scratch.
	   cogit CmpCq: objectMemory isForwardedObjectClassIndexPun R: TempReg.
	   but the following is an instruction shorter: */
	imm = genJumpImmediate(reg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, reg, scratch);
	/* begin AndCq:R: */
	quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());
	genoperandoperand(AndCqR, quickConstant, scratch);
	/* begin JumpNonZero: */
	ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, reg, reg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)fwdJumpTarget));
	if ((((usqInt)nonFwdJumpTargetOrZero)) == 0) {
		/* begin Label */
		finished = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	else {
		finished = nonFwdJumpTargetOrZero;
	}
	jmpTarget(imm, jmpTarget(ok, finished));
	return 0;
}


/*	Make sure that the oop in reg is not forwarded, updating the slot in
	objReg with the value.
 */

	/* CogObjectRepresentationForSpur>>#genEnsureOopInRegNotForwarded:scratchReg:updatingSlot:in: */
static sqInt NoDbgRegParms
genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(sqInt reg, sqInt scratch, sqInt index, sqInt objReg)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *imm;
    AbstractInstruction *loop;
    sqInt offset;
    AbstractInstruction *ok;
    sqInt quickConstant;


	/* Open-code
	   self genEnsureOopInRegNotForwarded: reg
	   scratchReg: scratch
	   updatingMw: index * objectMemory wordSize + objectMemory baseHeaderSize
	   r: objReg.
	   to avoid calling the store check unless the receiver is forwarded. */
	assert((reg != scratch)
	 && (objReg != scratch));
	/* begin Label */
	loop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* notionally
	   self genGetClassIndexOfNonImm: reg into: scratch.
	   cogit CmpCq: objectMemory isForwardedObjectClassIndexPun R: TempReg.
	   but the following is an instruction shorter: */
	imm = genJumpImmediate(reg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, reg, scratch);
	/* begin AndCq:R: */
	quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());
	genoperandoperand(AndCqR, quickConstant, scratch);
	/* begin JumpNonZero: */
	ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, reg, reg);
	/* begin MoveR:Mw:r: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, reg, offset, objReg);
	assert((reg == Arg0Reg)
	 && ((scratch == TempReg)
	 && (objReg == ReceiverResultReg)));
	if (needsFrame()) {
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceStoreCheckContextReceiverTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* begin saveAndRestoreLinkRegAround: */
		backEnd();
		/* begin CallRT: */
		
		abstractInstruction1 = genoperand(Call, ceStoreCheckContextReceiverTrampoline);
		(abstractInstruction1->annotation = IsRelativeCall);
	}
	/* begin Jump: */
	genoperand(Jump, ((sqInt)loop));
	jmpTarget(ok, jmpTarget(imm, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}


/*	Do the store check. Answer the argument for the benefit of the code
	generator; ReceiverResultReg may be caller-saved and hence smashed by this
	call. Answering
	it allows the code generator to reload ReceiverResultReg cheaply.
	In Spur the only thing we leave to the run-time is adding the receiver to
	the remembered set and setting its isRemembered bit. */

	/* CogObjectRepresentationForSpur>>#generateObjectRepresentationTrampolines */
static void
generateObjectRepresentationTrampolines(void)
{
    sqInt instVarIndex;
    AbstractInstruction *jumpSC;


#  if IMMUTABILITY
	for (instVarIndex = 0; instVarIndex < NumStoreTrampolines; instVarIndex += 1) {
		ceStoreTrampolines[instVarIndex] = (genStoreTrampolineCalledinstVarIndex(trampolineNamenumArgslimit("ceStoreTrampoline", instVarIndex, NumStoreTrampolines - 2), instVarIndex));
	}
#  endif // IMMUTABILITY
	/* begin genNewHashTrampoline:called: */
	ceNewHashTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNewHashOf, "ceNewHash", 1, ReceiverResultReg, null, null, null, /* begin emptyRegisterMask */ 0, 1, ReceiverResultReg, 0);
	/* begin genNewHashTrampoline:called: */
	ceInlineNewHashTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNewHashOf, "ceInlineNewHash", 1, ReceiverResultReg, null, null, null, ((CallerSavedRegisterMask | ((1U << ReceiverResultReg))) - ((1U << ReceiverResultReg))), 1, ReceiverResultReg, 0);
	/* begin genStoreCheckTrampoline */
	if (CheckRememberedInTrampoline) {
		zeroOpcodeIndex();
		jumpSC = genCheckRememberedBitOfscratch(ReceiverResultReg, ABIResultReg);
		assert(((jumpSC->opcode)) == JumpNonZero);
		(jumpSC->opcode = JumpZero);
		/* begin RetN: */
		genoperand(RetN, 0);
		jmpTarget(jumpSC, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	ceStoreCheckTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(remember, "ceStoreCheckTrampoline", 1, ReceiverResultReg, null, null, null, ((CallerSavedRegisterMask | ((1U << ReceiverResultReg))) - ((1U << ReceiverResultReg))), 1, (((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)
		? ReceiverResultReg
		: ABIResultReg), CheckRememberedInTrampoline);
	ceStoreCheckContextReceiverTrampoline = genStoreCheckContextReceiverTrampoline();
	/* begin genTrampolineFor:called:regsToSave: */
	ceScheduleScavengeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceScheduleScavenge, "ceScheduleScavengeTrampoline", 0, null, null, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
	ceSmallActiveContextInMethodTrampoline = genActiveContextTrampolineLargeinBlockcalled(0, 0, "ceSmallMethodContext");
	ceSmallActiveContextInBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(0, InVanillaBlock, "ceSmallBlockContext");
	ceSmallActiveContextInFullBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(0, InFullBlock, "ceSmallFullBlockContext");
	ceLargeActiveContextInMethodTrampoline = genActiveContextTrampolineLargeinBlockcalled(1, 0, "ceLargeMethodContext");
	ceLargeActiveContextInBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(1, InVanillaBlock, "ceLargeBlockContext");
	ceLargeActiveContextInFullBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(1, InFullBlock, "ceLargeFullBlockContext");
	generateLowcodeObjectTrampolines();
}


/*	Create a trampoline to answer the active context that will
	answer it if a frame is already married, and create it otherwise.
	Assume numArgs is in SendNumArgsReg and ClassReg is free. */

	/* CogObjectRepresentationForSpur>>#genGetActiveContextLarge:inBlock: */
static sqInt NoDbgRegParms
genGetActiveContextLargeinBlock(sqInt isLarge, sqInt isInBlock)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *continuation;
    AbstractInstruction *exit;
    usqLong header;
    AbstractInstruction *jumpNeedScavenge;
    AbstractInstruction *jumpSingle;
    AbstractInstruction *loopHead;
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt offset3;
    sqInt offset4;
    sqInt offset5;
    sqInt offset6;
    sqInt offset7;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt slotSize;

	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, FoxMethod, FPReg, ClassReg);
	/* begin TstCq:R: */
	genoperandoperand(TstCqR, MFMethodFlagHasContextFlag, ClassReg);
	/* begin JumpZero: */
	jumpSingle = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, FoxThisContext, FPReg, ReceiverResultReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpSingle, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin OrCq:R: */
	genoperandoperand(OrCqR, MFMethodFlagHasContextFlag, ClassReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, ClassReg, FoxMethod, FPReg);
	switch (isInBlock) {
	case InFullBlock:
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, 3, ClassReg);
		break;
	case InVanillaBlock:
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, 3, ClassReg);
		/* begin MoveM16:r:R: */
		genoperandoperandoperand(MoveM16rR, 0, ClassReg, TempReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, TempReg, ClassReg);
		break;
	case 0:
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, 1, ClassReg);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	slotSize = (isLarge
		? LargeContextSlots
		: SmallContextSlots);
	header = headerForSlotsformatclassIndex(slotSize, indexablePointersFormat(), ClassMethodContextCompactIndex);
	flag("endianness");
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, ReceiverResultReg);
	/* begin genStoreHeader:intoNewInstance:using: */
	
	genoperandoperand(MoveCqR, header, TempReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	offset = smallObjectBytesForSlots(slotSize);
	genoperandoperandoperand(LoadEffectiveAddressMwrR, offset, ReceiverResultReg, TempReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, TempReg, address1);
	/* begin CmpCq:R: */
	quickConstant1 = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant1, TempReg);
	/* begin JumpAboveOrEqual: */
	jumpNeedScavenge = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin gen:quickConstant:operand:operand: */
	continuation = genoperandoperandoperand(LoadEffectiveAddressMwrR, 1, FPReg, TempReg);
	/* begin MoveR:Mw:r: */
	offset1 = BaseHeaderSize + (SenderIndex * BytesPerOop);
	genoperandoperandoperand(MoveRMwr, TempReg, offset1, ReceiverResultReg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, FoxSavedFP, FPReg, TempReg);
	genSetSmallIntegerTagsIn(TempReg);
	/* begin MoveR:Mw:r: */
	offset2 = BaseHeaderSize + (InstructionPointerIndex * BytesPerOop);
	genoperandoperandoperand(MoveRMwr, TempReg, offset2, ReceiverResultReg);
	/* begin MoveMw:r:R: */
	offset3 = offsetof(CogMethod, methodObject);
	genoperandoperandoperand(MoveMwrR, offset3, ClassReg, TempReg);
	/* begin MoveR:Mw:r: */
	offset4 = BaseHeaderSize + (MethodIndex * BytesPerWord);
	genoperandoperandoperand(MoveRMwr, TempReg, offset4, ReceiverResultReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, ReceiverResultReg, FoxThisContext, FPReg);
	gSubRRR(SPReg, FPReg, TempReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant2 = log2BytesPerWord();
	genoperandoperand(LogicalShiftRightCqR, quickConstant2, TempReg);
	/* begin SubCq:R: */
	quickConstant3 = 4;
	genoperandoperand(SubCqR, quickConstant3, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, SendNumArgsReg, TempReg);
	genConvertIntegerToSmallIntegerInReg(TempReg);
	/* begin MoveR:Mw:r: */
	offset5 = BaseHeaderSize + (StackPointerIndex * BytesPerOop);
	genoperandoperandoperand(MoveRMwr, TempReg, offset5, ReceiverResultReg);
	if (isInBlock > 0) {
		/* begin LoadEffectiveAddressMw:r:R: */
		genoperandoperandoperand(LoadEffectiveAddressMwrR, 2, SendNumArgsReg, TempReg);
		/* begin MoveXwr:R:R: */
		genoperandoperandoperand(MoveXwrRR, TempReg, FPReg, TempReg);
	}
	else {
		if (shouldAnnotateObjectReference(nilObject())) {
			annotateobjRef(genoperandoperand(MoveCwR, nilObject(), TempReg), nilObject());
		}
		else {
			/* begin MoveCq:R: */
			quickConstant7 = nilObject();
			genoperandoperand(MoveCqR, quickConstant7, TempReg);
		}
	}
	/* begin MoveR:Mw:r: */
	offset6 = BaseHeaderSize + (ClosureIndex * BytesPerOop);
	genoperandoperandoperand(MoveRMwr, TempReg, offset6, ReceiverResultReg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, FoxMFReceiver, FPReg, TempReg);
	/* begin MoveR:Mw:r: */
	offset7 = BaseHeaderSize + (ReceiverIndex * BytesPerOop);
	genoperandoperandoperand(MoveRMwr, TempReg, offset7, ReceiverResultReg);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 1, ClassReg);
	/* begin CmpR:R: */
	assert(!((SendNumArgsReg == SPReg)));
	loopHead = genoperandoperand(CmpRR, SendNumArgsReg, ClassReg);
	/* begin JumpGreater: */
	exit = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, ClassReg, TempReg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 2, TempReg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, TempReg, FPReg, TempReg);
	/* begin AddCq:R: */
	quickConstant4 = ReceiverIndex + (BaseHeaderSize / BytesPerWord);
	genoperandoperand(AddCqR, quickConstant4, ClassReg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, ClassReg, ReceiverResultReg);
	/* begin SubCq:R: */
	quickConstant5 = (ReceiverIndex + (BaseHeaderSize / BytesPerWord)) - 1;
	genoperandoperand(SubCqR, quickConstant5, ClassReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)loopHead));
	jmpTarget(exit, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin MoveCq:R: */
	quickConstant = nilObject();
	genoperandoperand(MoveCqR, quickConstant, TempReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	genoperandoperandoperand(LoadEffectiveAddressMwrR, FoxMFReceiver, FPReg, ClassReg);
	/* begin AddCq:R: */
	quickConstant6 = (ReceiverIndex + 1) + (BaseHeaderSize / BytesPerWord);
	genoperandoperand(AddCqR, quickConstant6, SendNumArgsReg);
	/* begin SubCq:R: */
	
	BytesPerWord;
	anInstruction = genoperandoperand(SubCqR, BytesPerWord, ClassReg);
	loopHead = anInstruction;
	/* begin CmpR:R: */
	assert(!((ClassReg == SPReg)));
	genoperandoperand(CmpRR, ClassReg, SPReg);
	/* begin JumpAboveOrEqual: */
	exit = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, SendNumArgsReg, ReceiverResultReg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 1, SendNumArgsReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)loopHead));
	jmpTarget(exit, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNeedScavenge, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin saveAndRestoreLinkRegAround: */
	backEnd();
	CallRTregistersToBeSavedMask(ceScheduleScavengeTrampoline, ((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg));
	/* begin Jump: */
	genoperand(Jump, ((sqInt)continuation));
	return 0;
}


/*	Get the active context into ReceiverResultReg, creating it if necessary. */

	/* CogObjectRepresentationForSpur>>#genGetActiveContextNumArgs:large:inBlock: */
static sqInt NoDbgRegParms
genGetActiveContextNumArgslargeinBlock(sqInt numArgs, sqInt isLargeContext, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;
    sqInt routine;

	if (isLargeContext) {
		switch (isInBlock) {
		case 0:
			routine = ceLargeActiveContextInMethodTrampoline;
			break;

		case InVanillaBlock:
			routine = ceLargeActiveContextInBlockTrampoline;
			break;

		case InFullBlock:
			routine = ceLargeActiveContextInFullBlockTrampoline;
			break;

		default:
			error("Case not found and no otherwise clause");
			routine = -1;
		}
	}
	else {
		switch (isInBlock) {
		case 0:
			routine = ceSmallActiveContextInMethodTrampoline;
			break;

		case InVanillaBlock:
			routine = ceSmallActiveContextInBlockTrampoline;
			break;

		case InFullBlock:
			routine = ceSmallActiveContextInFullBlockTrampoline;
			break;

		default:
			error("Case not found and no otherwise clause");
			routine = -1;
		}
	}
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, numArgs, SendNumArgsReg);
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, routine);
	(abstractInstruction->annotation = IsRelativeCall);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genGetBits:ofFormatByteOf:into: */
static sqInt NoDbgRegParms
genGetBitsofFormatByteOfinto(sqInt mask, sqInt sourceReg, sqInt destReg)
{
	flag("endianness");
	/* begin MoveMb:r:R: */
	genoperandoperandoperand(MoveMbrR, 3, sourceReg, destReg);
	/* begin AndCq:R: */
	genoperandoperand(AndCqR, mask, destReg);
	return 0;
}


/*	Fetch the instance's class index into destReg. */

	/* CogObjectRepresentationForSpur>>#genGetClassIndexOfNonImm:into: */
static sqInt NoDbgRegParms
genGetClassIndexOfNonImminto(sqInt sourceReg, sqInt destReg)
{
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, sourceReg, destReg);
	/* begin AndCq:R: */
	quickConstant = classIndexMask();
	genoperandoperand(AndCqR, quickConstant, destReg);
	return 0;
}


/*	Fetch the class object whose index is in instReg into destReg.
	It is non-obvious, but the Cogit assumes loading a class does not involve
	a runtime call, so do not call classAtIndex: */

	/* CogObjectRepresentationForSpur>>#genGetClassObjectOfClassIndex:into:scratchReg: */
static sqInt NoDbgRegParms
genGetClassObjectOfClassIndexintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;

	assert(instReg != destReg);
	assert(instReg != scratchReg);
	assert(destReg != scratchReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instReg, scratchReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant1 = classTableMajorIndexShift();
	genoperandoperand(LogicalShiftRightCqR, quickConstant1, scratchReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), scratchReg);
	assert(!(shouldAnnotateObjectReference(classTableRootObj())));
	if (isWithinMwOffsetRange(backEnd(), (classTableRootObj()) + BaseHeaderSize)) {
		/* begin MoveMw:r:R: */
		offset = (classTableRootObj()) + BaseHeaderSize;
		genoperandoperandoperand(MoveMwrR, offset, scratchReg, destReg);
	}
	else {
		/* begin AddCq:R: */
		quickConstant = classTableRootObj();
		genoperandoperand(AddCqR, quickConstant, scratchReg);
		/* begin MoveMw:r:R: */
		
		BaseHeaderSize;
		anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, scratchReg, destReg);
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instReg, scratchReg);
	/* begin AndCq:R: */
	quickConstant2 = classTableMinorIndexMask();
	genoperandoperand(AndCqR, quickConstant2, scratchReg);
	/* begin AddCq:R: */
	quickConstant3 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant3, scratchReg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, scratchReg, destReg, destReg);
	return 0;
}


/*	Fetch the instance's class into destReg. If the instance is not the
	receiver and is forwarded, follow forwarding. */

	/* CogObjectRepresentationForSpur>>#genGetClassObjectOf:into:scratchReg:mayBeAForwarder: */
static sqInt NoDbgRegParms
genGetClassObjectOfintoscratchRegmayBeAForwarder(sqInt instReg, sqInt destReg, sqInt scratchReg, sqInt mayBeForwarder)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpIsImm;
    AbstractInstruction *jumpNotForwarded;
    AbstractInstruction *loop;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	if ((instReg == destReg)
	 || ((instReg == scratchReg)
	 || (destReg == scratchReg))) {
		return BadRegisterSet;
	}
	/* begin MoveR:R: */
	loop = genoperandoperand(MoveRR, instReg, scratchReg);
	/* begin AndCq:R: */
	quickConstant1 = tagMask();
	genoperandoperand(AndCqR, quickConstant1, scratchReg);
	/* begin JumpNonZero: */
	jumpIsImm = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	flag("endianness");
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, instReg, scratchReg);
	/* begin AndCq:R: */
	quickConstant2 = classIndexMask();
	genoperandoperand(AndCqR, quickConstant2, scratchReg);
	if (mayBeForwarder) {

		/* if it is forwarded... */
		/* begin CmpCq:R: */
		quickConstant = isForwardedObjectClassIndexPun();
		genoperandoperand(CmpCqR, quickConstant, scratchReg);
		/* begin JumpNonZero: */
		jumpNotForwarded = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveMw:r:R: */
		
		BaseHeaderSize;
		anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, instReg, instReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)loop));
		jmpTarget(jumpNotForwarded, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	jmpTarget(jumpIsImm, genoperandoperand(MoveRR, scratchReg, destReg));
	if (scratchReg == TempReg) {
		/* begin PushR: */
		genoperand(PushR, instReg);
		genGetClassObjectOfClassIndexintoscratchReg(destReg, instReg, TempReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, instReg, destReg);
		/* begin PopR: */
		genoperand(PopR, instReg);
	}
	else {
		genGetClassObjectOfClassIndexintoscratchReg(destReg, scratchReg, TempReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, scratchReg, destReg);
	}
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genGetClassTagOf:into:scratchReg: */
static AbstractInstruction * NoDbgRegParms
genGetClassTagOfintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
	return genGetInlineCacheClassTagFromintoforEntry(instReg, destReg, 1);
}


/*	Fetch the instance's class index into destReg. */

	/* CogObjectRepresentationForSpur>>#genGetCompactClassIndexNonImmOf:into: */
static sqInt NoDbgRegParms
genGetCompactClassIndexNonImmOfinto(sqInt instReg, sqInt destReg)
{
	return genGetClassIndexOfNonImminto(instReg, destReg);
}

	/* CogObjectRepresentationForSpur>>#genGetDoubleValueOf:into: */
static sqInt NoDbgRegParms
genGetDoubleValueOfinto(sqInt srcReg, sqInt destFPReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveM64:r:Rd: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveM64rRd, BaseHeaderSize, srcReg, destFPReg);
	return 0;
}


/*	Get the format field of the object in srcReg into destReg.
	srcReg may equal destReg. */

	/* CogObjectRepresentationForSpur>>#genGetFormatOf:into: */
static sqInt NoDbgRegParms
genGetFormatOfinto(sqInt srcReg, sqInt destReg)
{
	return genGetBitsofFormatByteOfinto(formatMask(), srcReg, destReg);
}


/*	Get the format of the object in sourceReg into destReg. If
	scratchRegOrNone is not NoReg, load at least the least significant 32-bits
	(64-bits in 64-bits) of the
	header word, which contains the format, into scratchRegOrNone. */

	/* CogObjectRepresentationForSpur>>#genGetFormatOf:into:leastSignificantHalfOfBaseHeaderIntoScratch: */
static sqInt NoDbgRegParms
genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(sqInt sourceReg, sqInt destReg, sqInt scratchRegOrNone)
{
    sqInt quickConstant;

	if (scratchRegOrNone == NoReg) {
		flag("endianness");
		/* begin MoveMb:r:R: */
		genoperandoperandoperand(MoveMbrR, 3, sourceReg, destReg);
	}
	else {
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, sourceReg, scratchRegOrNone);
		gLogicalShiftRightCqRR(formatShift(), scratchRegOrNone, destReg);
	}
	/* begin AndCq:R: */
	quickConstant = formatMask();
	genoperandoperand(AndCqR, quickConstant, destReg);
	return 0;
}


/*	Get the size in word-sized slots of the object in srcReg into destReg.
	srcReg may equal destReg. */

	/* CogObjectRepresentationForSpur>>#genGetNumSlotsOf:into: */
static sqInt NoDbgRegParms
genGetNumSlotsOfinto(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *jmp;
    sqInt quickConstant;

	assert(srcReg != destReg);
	genGetRawSlotSizeOfNonImminto(srcReg, destReg);
	/* begin CmpCq:R: */
	quickConstant = numSlotsMask();
	genoperandoperand(CmpCqR, quickConstant, destReg);
	/* begin JumpLess: */
	jmp = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genGetOverflowSlotsOfinto(srcReg, destReg);
	jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	The raw numSlots field is the most significant byte of the 64-bit header
	word. MoveMbrR zero-extends. */

	/* CogObjectRepresentationForSpur>>#genGetRawSlotSizeOfNonImm:into: */
static sqInt NoDbgRegParms
genGetRawSlotSizeOfNonImminto(sqInt sourceReg, sqInt destReg)
{
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, destReg);
	/* begin MoveMb:r:R: */
	genoperandoperandoperand(MoveMbrR, 7, sourceReg, destReg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genJumpImmediate: */
static AbstractInstruction * NoDbgRegParms
genJumpImmediate(sqInt aRegister)
{
    sqInt quickConstant;

	/* begin TstCq:R: */
	quickConstant = tagMask();
	genoperandoperand(TstCqR, quickConstant, aRegister);
	/* begin JumpNonZero: */
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}

	/* CogObjectRepresentationForSpur>>#genJumpImmutable:scratchReg: */
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms
genJumpImmutablescratchReg(sqInt sourceReg, sqInt scratchReg)
{
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, sourceReg, scratchReg);
	/* begin genJumpBaseHeaderImmutable: */
	
	quickConstant = immutableBitMask();
	genoperandoperand(TstCqR, quickConstant, scratchReg);
	/* begin JumpNonZero: */
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}
#endif /* IMMUTABILITY */

	/* CogObjectRepresentationForSpur>>#genJumpMutable:scratchReg: */
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms
genJumpMutablescratchReg(sqInt sourceReg, sqInt scratchReg)
{
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, sourceReg, scratchReg);
	/* begin genJumpBaseHeaderMutable: */
	
	quickConstant = immutableBitMask();
	genoperandoperand(TstCqR, quickConstant, scratchReg);
	/* begin JumpZero: */
	return genConditionalBranchoperand(JumpZero, ((sqInt)0));
}
#endif /* IMMUTABILITY */

	/* CogObjectRepresentationForSpur>>#genLcFirstFieldPointer: */
static void NoDbgRegParms
genLcFirstFieldPointer(sqInt objectReg)
{
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 8, objectReg);
	ssPushNativeRegister(objectReg);
}


/*	TODO: Retrieve the number of fixed fields. */

	/* CogObjectRepresentationForSpur>>#genLcFirstIndexableFieldPointer: */
static void NoDbgRegParms
genLcFirstIndexableFieldPointer(sqInt objectReg)
{
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 8, objectReg);
	ssPushNativeRegister(objectReg);
}


/*	Check for integer */

	/* CogObjectRepresentationForSpur>>#genLcIsBytes:to: */
static void NoDbgRegParms
genLcIsBytesto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *cont;
    AbstractInstruction *falseTarget;
    AbstractInstruction *isCompiledMethod;
    AbstractInstruction *isImmediate;
    AbstractInstruction *isNotBytes;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	/* begin AndCq:R: */
	quickConstant = tagMask();
	genoperandoperand(AndCqR, quickConstant, valueReg);
	/* begin JumpNonZero: */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetFormatOfinto(objectReg, valueReg);
	/* begin CmpCq:R: */
	quickConstant1 = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant1, valueReg);
	/* begin JumpLess: */
	isNotBytes = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant2, valueReg);
	/* begin JumpGreaterOrEqual: */
	isCompiledMethod = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 1, valueReg);
	/* begin Jump: */
	cont = genoperand(Jump, ((sqInt)0));
	/* begin Label */
	falseTarget = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isImmediate, falseTarget);
	jmpTarget(isNotBytes, falseTarget);
	jmpTarget(isCompiledMethod, falseTarget);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, valueReg);
	jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushNativeRegister(valueReg);
}


/*	TODO: Implement this one */

	/* CogObjectRepresentationForSpur>>#genLcIsFloatObject:to: */
static void NoDbgRegParms
genLcIsFloatObjectto(sqInt objectReg, sqInt valueReg)
{
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 1, valueReg);
	ssPushNativeRegister(valueReg);
}


/*	TODO: Implement this one */

	/* CogObjectRepresentationForSpur>>#genLcIsIndexable:to: */
static void NoDbgRegParms
genLcIsIndexableto(sqInt objectReg, sqInt valueReg)
{
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 1, valueReg);
	ssPushNativeRegister(valueReg);
}


/*	Check for the immediate case */

	/* CogObjectRepresentationForSpur>>#genLcIsIntegerObject:to: */
static void NoDbgRegParms
genLcIsIntegerObjectto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *cont;
    AbstractInstruction *falseResult;
    AbstractInstruction *isImmediate;
    AbstractInstruction *isLargeNegativeInteger;
    AbstractInstruction *isLargePositiveInteger;
    sqInt quickConstant;
    AbstractInstruction *trueResult;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	/* begin AndCq:R: */
	quickConstant = smallIntegerTag();
	genoperandoperand(AndCqR, quickConstant, valueReg);
	/* begin JumpNonZero: */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetClassIndexOfNonImminto(objectReg, TempReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassLargePositiveInteger, TempReg);
	/* begin JumpNonZero: */
	isLargePositiveInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassLargeNegativeInteger, TempReg);
	/* begin JumpNonZero: */
	isLargeNegativeInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, valueReg, valueReg);
	/* begin Jump: */
	falseResult = genoperand(Jump, ((sqInt)0));
	/* begin Label */
	trueResult = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isLargePositiveInteger, trueResult);
	jmpTarget(isLargeNegativeInteger, trueResult);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 1, valueReg);
	/* begin Label */
	cont = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(falseResult, cont);
	jmpTarget(isImmediate, cont);
	ssPushNativeRegister(valueReg);
}


/*	Check for immediate */

	/* CogObjectRepresentationForSpur>>#genLcIsPointers:to: */
static void NoDbgRegParms
genLcIsPointersto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *cont;
    AbstractInstruction *falseTarget;
    AbstractInstruction *isImmediate;
    AbstractInstruction *isNotPointers;
    sqInt quickConstant;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	/* begin AndCq:R: */
	quickConstant = tagMask();
	genoperandoperand(AndCqR, quickConstant, valueReg);
	/* begin JumpNonZero: */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetFormatOfinto(objectReg, valueReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 9, valueReg);
	/* begin JumpGreaterOrEqual: */
	isNotPointers = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 1, valueReg);
	/* begin Jump: */
	cont = genoperand(Jump, ((sqInt)0));
	/* begin Label */
	falseTarget = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isImmediate, falseTarget);
	jmpTarget(isNotPointers, falseTarget);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, valueReg);
	jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushNativeRegister(valueReg);
}


/*	Check for immediate */

	/* CogObjectRepresentationForSpur>>#genLcIsWordsOrBytes:to: */
static void NoDbgRegParms
genLcIsWordsOrBytesto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *cont;
    AbstractInstruction *falseTarget;
    AbstractInstruction *isCompiledMethod;
    AbstractInstruction *isImmediate;
    AbstractInstruction *isNotBits;
    sqInt quickConstant;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	/* begin AndCq:R: */
	quickConstant = tagMask();
	genoperandoperand(AndCqR, quickConstant, valueReg);
	/* begin JumpNonZero: */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetFormatOfinto(objectReg, valueReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 9, valueReg);
	/* begin JumpLess: */
	isNotBits = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 24, valueReg);
	/* begin JumpGreaterOrEqual: */
	isCompiledMethod = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 1, valueReg);
	/* begin Jump: */
	cont = genoperand(Jump, ((sqInt)0));
	/* begin Label */
	falseTarget = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isImmediate, falseTarget);
	jmpTarget(isNotBits, falseTarget);
	jmpTarget(isCompiledMethod, falseTarget);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, valueReg);
	jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushNativeRegister(valueReg);
}


/*	Check for immediate */

	/* CogObjectRepresentationForSpur>>#genLcIsWords:to: */
static void NoDbgRegParms
genLcIsWordsto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *cont;
    AbstractInstruction *falseTarget;
    AbstractInstruction *isAboveRange;
    AbstractInstruction *isBelowRange;
    AbstractInstruction *isImmediate;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant3;

	isAboveRange = ((AbstractInstruction *) 0);
	isBelowRange = ((AbstractInstruction *) 0);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	/* begin AndCq:R: */
	quickConstant3 = tagMask();
	genoperandoperand(AndCqR, quickConstant3, valueReg);
	/* begin JumpNonZero: */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetFormatOfinto(objectReg, valueReg);
	/* begin CmpCq:R: */
	quickConstant = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant, valueReg);
	/* begin JumpLess: */
	isBelowRange = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant1, valueReg);
	/* begin JumpGreaterOrEqual: */
	isAboveRange = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 1, valueReg);
	/* begin Jump: */
	cont = genoperand(Jump, ((sqInt)0));
	/* begin Label */
	falseTarget = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isImmediate, falseTarget);
	jmpTarget(isBelowRange, falseTarget);
	jmpTarget(isAboveRange, falseTarget);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, valueReg);
	jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushNativeRegister(valueReg);
}

	/* CogObjectRepresentationForSpur>>#genLcLoadObject:at: */
static void NoDbgRegParms
genLcLoadObjectat(sqInt object, sqInt fieldIndex)
{
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 8, object);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, fieldIndex, object, object);
	ssPushRegister(object);
}

	/* CogObjectRepresentationForSpur>>#genLcLoadObject:field: */
static void NoDbgRegParms
genLcLoadObjectfield(sqInt object, sqInt fieldIndex)
{
    sqInt offset;

	/* begin MoveMw:r:R: */
	offset = BaseHeaderSize + (BytesPerOop * fieldIndex);
	genoperandoperandoperand(MoveMwrR, offset, object, object);
	ssPushRegister(object);
}

	/* CogObjectRepresentationForSpur>>#genLcStore:object:at: */
static void NoDbgRegParms
genLcStoreobjectat(sqInt value, sqInt object, sqInt fieldIndex)
{
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 8, object);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, value, fieldIndex, object);
	return;
}

	/* CogObjectRepresentationForSpur>>#genLcStore:object:field: */
static void NoDbgRegParms
genLcStoreobjectfield(sqInt value, sqInt object, sqInt fieldIndex)
{
    sqInt offset;

	/* begin MoveR:Mw:r: */
	offset = BaseHeaderSize + (fieldIndex * BytesPerOop);
	genoperandoperandoperand(MoveRMwr, value, offset, object);
	return;
}


/*	Generate a call to code that allocates a new Array of size.
	The Array should be initialized with nils iff initialize is true.
	The size arg is passed in SendNumArgsReg, the result
	must come back in ReceiverResultReg. */

	/* CogObjectRepresentationForSpur>>#genNewArrayOfSize:initialized: */
static sqInt NoDbgRegParms
genNewArrayOfSizeinitialized(sqInt size, sqInt initialize)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    sqInt address1;
    sqInt constant;
    usqLong header;
    sqInt i;
    sqInt offset;
    sqInt offset1;
    sqInt quickConstant;
    AbstractInstruction *skip;

	assert(size < (numSlotsMask()));
	header = headerForSlotsformatclassIndex(size, arrayFormat(), ClassArrayCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, ReceiverResultReg);
	/* begin genStoreHeader:intoNewInstance:using: */
	
	genoperandoperand(MoveCqR, header, TempReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	if (initialize
	 && (size > 0)) {
		/* begin genMoveConstant:R: */
		constant = nilObject();
		if (shouldAnnotateObjectReference(constant)) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(MoveCwR, constant, TempReg)), constant);
		}
		else {
			/* begin MoveCq:R: */
			genoperandoperand(MoveCqR, constant, TempReg);
		}
		for (i = 0; i < size; i += 1) {
			/* begin MoveR:Mw:r: */
			offset = (i * BytesPerWord) + BaseHeaderSize;
			genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
		}
	}
	/* begin LoadEffectiveAddressMw:r:R: */
	offset1 = smallObjectBytesForSlots(size);
	genoperandoperandoperand(LoadEffectiveAddressMwrR, offset1, ReceiverResultReg, TempReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, TempReg, address1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpBelow: */
	skip = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	Create a closure with the given startpc, numArgs and numCopied
	within a context with ctxtNumArgs, large if isLargeCtxt that is in a
	block if isInBlock. Do /not/ initialize the copied values. */

	/* CogObjectRepresentationForSpur>>#genNoPopCreateClosureAt:numArgs:numCopied:contextNumArgs:large:inBlock: */
static sqInt NoDbgRegParms
genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    usqInt byteSize;
    usqLong header;
    sqInt numSlots;
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt quickConstant;
    AbstractInstruction *skip;


	/* First get thisContext into ReceiverResultRega and thence in ClassReg. */
	genGetActiveContextNumArgslargeinBlock(ctxtNumArgs, isLargeCtxt, isInBlock);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	numSlots = ClosureFirstCopiedValueIndex + numCopied;
	byteSize = smallObjectBytesForSlots(numSlots);
	header = headerForSlotsformatclassIndex(numSlots, indexablePointersFormat(), ClassBlockClosureCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, ReceiverResultReg);
	/* begin genStoreHeader:intoNewInstance:using: */
	
	genoperandoperand(MoveCqR, header, TempReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	genoperandoperandoperand(LoadEffectiveAddressMwrR, byteSize, ReceiverResultReg, TempReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, TempReg, address1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpBelow: */
	skip = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin MoveR:Mw:r: */
	offset = (ClosureOuterContextIndex * BytesPerOop) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, ClassReg, offset, ReceiverResultReg);
	/* begin MoveCq:R: */
	
	(((usqInt)bcpc << 3) | 1);
	anInstruction = genoperandoperand(MoveCqR, (((usqInt)bcpc << 3) | 1), TempReg);
	/* begin MoveR:Mw:r: */
	offset1 = (ClosureStartPCIndex * BytesPerOop) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, TempReg, offset1, ReceiverResultReg);
	/* begin MoveCq:R: */
	
	(((usqInt)numArgs << 3) | 1);
	anInstruction1 = genoperandoperand(MoveCqR, (((usqInt)numArgs << 3) | 1), TempReg);
	/* begin MoveR:Mw:r: */
	offset2 = (ClosureNumArgsIndex * BytesPerOop) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, TempReg, offset2, ReceiverResultReg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveAsCharacter */
static sqInt
genPrimitiveAsCharacter(void)
{
    AbstractInstruction *jumpNotInt;
    AbstractInstruction *jumpOutOfRange;
    sqInt reg;

	jumpNotInt = ((AbstractInstruction *) 0);
	if (methodOrBlockNumArgs == 0) {
		reg = ReceiverResultReg;
	}
	else {
		if (methodOrBlockNumArgs > 1) {
			return UnimplementedPrimitive;
		}
		reg = Arg0Reg;
		/* begin genLoadArgAtDepth:into: */
		assert(0 < (numRegArgs()));
		/* begin genJumpNotSmallInteger:scratchReg: */
		jumpNotInt = genJumpNotSmallInteger(reg);
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	jumpOutOfRange = jumpNotCharacterUnsignedValueInRegister(TempReg);
	genConvertSmallIntegerToCharacterInReg(reg);
	if (reg != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, reg, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOutOfRange, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (reg != ReceiverResultReg) {
		jmpTarget(jumpNotInt, ((AbstractInstruction *) (((jumpOutOfRange->operands))[0])));
	}
	return CompletePrimitive;
}


/*	Generate primitive 60, at: with unsigned access for pure bits classes. */

	/* CogObjectRepresentationForSpur>>#genPrimitiveAt */
static sqInt
genPrimitiveAt(void)
{
	return genPrimitiveAtSigned(0);
}


/*	Generate primitive 61, at:put: with unsigned access for pure bits classes. */

	/* CogObjectRepresentationForSpur>>#genPrimitiveAtPut */
static sqInt
genPrimitiveAtPut(void)
{
	return genPrimitiveAtPutSigned(0);
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveIdenticalOrNotIf: */
static sqInt NoDbgRegParms
genPrimitiveIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *comp;
    AbstractInstruction *jumpCmp;
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	comp = genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	if (orNot) {
		/* begin JumpZero: */
		jumpCmp = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(Arg0Reg, TempReg, comp, 0);
	}
	else {
		/* begin JumpNonZero: */
		jumpCmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	}
	if (shouldAnnotateObjectReference(trueObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, trueObject(), ReceiverResultReg), trueObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = trueObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (!orNot) {
		/* begin genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(Arg0Reg, TempReg, comp, 0);
	}
	if (shouldAnnotateObjectReference(falseObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, falseObject(), ReceiverResultReg), falseObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant1 = falseObject();
		genoperandoperand(MoveCqR, quickConstant1, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}


/*	Generate primitive 164, at: with signed access for pure bits classes. */

	/* CogObjectRepresentationForSpur>>#genPrimitiveIntegerAt */
static sqInt
genPrimitiveIntegerAt(void)
{
	return genPrimitiveAtSigned(1);
}


/*	Generate primitive 165, at:put: with signed access for pure bits classes. */

	/* CogObjectRepresentationForSpur>>#genPrimitiveIntegerAtPut */
static sqInt
genPrimitiveIntegerAtPut(void)
{
	return genPrimitiveAtPutSigned(1);
}


/*	<returnTypeC: #'AbstractInstruction *'> */

	/* CogObjectRepresentationForSpur>>#genPrimitiveMakePoint */
static sqInt
genPrimitiveMakePoint(void)
{
    sqInt address;
    sqInt address1;
    sqInt allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    usqLong newPointHeader;
    sqInt offset;
    sqInt quickConstant;
    sqInt resultReg;
    sqInt scratchReg;

	resultReg = ClassReg;

	/* <var: #jumpFail type: #'AbstractInstruction *'> */
	scratchReg = SendNumArgsReg;
	allocSize = BaseHeaderSize + (BytesPerWord * 2);
	newPointHeader = headerForSlotsformatclassIndex(2, nonIndexablePointerFormat(), ClassPointCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	genoperandoperand(MoveAwR, address, resultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratchReg);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	genoperandoperand(CmpCqR, quickConstant, scratchReg);
	/* begin JumpAboveOrEqual: */
	jumpFail = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	genoperandoperand(MoveRAw, scratchReg, address1);
	/* begin genStoreHeader:intoNewInstance:using: */
	
	genoperandoperand(MoveCqR, newPointHeader, scratchReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, scratchReg, 0, resultReg);
	/* begin MoveR:Mw:r: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, BaseHeaderSize, resultReg);
	/* begin MoveR:Mw:r: */
	offset = BaseHeaderSize + BytesPerWord;
	genoperandoperandoperand(MoveRMwr, Arg0Reg, offset, resultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, resultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveObjectAt */
static sqInt
genPrimitiveObjectAt(void)
{
    AbstractInstruction *anInstruction;
    sqInt headerReg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBounds;
    AbstractInstruction *jumpNotHeaderIndex;
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genGetMethodHeaderOfintoscratch(ReceiverResultReg, (headerReg = Arg1Reg), TempReg);
	/* begin CmpCq:R: */
	
	(((usqInt)1 << 3) | 1);
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)1 << 3) | 1), Arg0Reg);
	/* begin JumpNonZero: */
	jumpNotHeaderIndex = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, headerReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotHeaderIndex, gAndCqR((((usqInt)(alternateHeaderNumLiteralsMask()) << 3) | 1), headerReg));
	/* begin SubCq:R: */
	quickConstant = ((((usqInt)1 << 3) | 1)) - (smallIntegerTag());
	genoperandoperand(SubCqR, quickConstant, Arg0Reg);
	/* begin CmpR:R: */
	assert(!((headerReg == SPReg)));
	genoperandoperand(CmpRR, headerReg, Arg0Reg);
	/* begin JumpAbove: */
	jumpBounds = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin AddCq:R: */
	quickConstant1 = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());
	genoperandoperand(AddCqR, quickConstant1, Arg0Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg0Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpBounds, gAddCqR(((((usqInt)1 << 3) | 1)) - (smallIntegerTag()), Arg0Reg));
	jmpTarget(jumpBadIndex, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	c.f. StackInterpreter>>stSizeOf: lengthOf:baseHeader:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationForSpur>>#genPrimitiveSize */
static sqInt
genPrimitiveSize(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jump32BitLongsDone;
    AbstractInstruction *jump64BitLongsDone;
    AbstractInstruction *jumpArrayDone;
    AbstractInstruction *jumpBytesDone;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImm;
    AbstractInstruction *jumpIs32BitLongs;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsContext1;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpNotIndexable1;
    AbstractInstruction *jumpShortsDone;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;

	jumpImm = genJumpImmediate(ReceiverResultReg);
	/* begin genGetSizeOf:into:formatReg:scratchReg:abortJumpsInto: */
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, SendNumArgsReg, TempReg);
	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	quickConstant = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	/* begin JumpGreaterOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = arrayFormat();
	genoperandoperand(CmpCqR, quickConstant1, SendNumArgsReg);
	/* begin JumpZero: */
	jumpArrayDone = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin JumpLess: */
	jumpNotIndexable1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = weakArrayFormat();
	genoperandoperand(CmpCqR, quickConstant2, SendNumArgsReg);
	/* begin JumpLessOrEqual: */
	jumpHasFixedFields = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = firstShortFormat();
	genoperandoperand(CmpCqR, quickConstant3, SendNumArgsReg);
	/* begin JumpGreaterOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstLongFormat();
	genoperandoperand(CmpCqR, quickConstant4, SendNumArgsReg);
	/* begin JumpGreaterOrEqual: */
	jumpIs32BitLongs = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = sixtyFourBitIndexableFormat();
	genoperandoperand(CmpCqR, quickConstant5, SendNumArgsReg);
	/* begin JumpZero: */
	jump64BitLongsDone = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	jmpTarget(jumpNotIndexable1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin Jump: */
	jumpNotIndexable1 = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsBytes, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), ClassReg));
	/* begin AndCq:R: */
	
	BytesPerWord - 1;
	anInstruction = genoperandoperand(AndCqR, BytesPerWord - 1, SendNumArgsReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	/* begin Jump: */
	jumpBytesDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, ClassReg));
	/* begin AndCq:R: */
	quickConstant6 = (((usqInt)(BytesPerWord)) >> 1) - 1;
	genoperandoperand(AndCqR, quickConstant6, SendNumArgsReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	/* begin Jump: */
	jumpShortsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIs32BitLongs, gLogicalShiftLeftCqR((shiftForWord()) - 2, ClassReg));
	/* begin AndCq:R: */
	quickConstant7 = (((usqInt)(BytesPerWord)) >> 2) - 1;
	genoperandoperand(AndCqR, quickConstant7, SendNumArgsReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	/* begin Jump: */
	jump32BitLongsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasFixedFields, checkQuickConstantforInstruction(classIndexMask(), genoperandoperand(AndCqR, classIndexMask(), TempReg)));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, SendNumArgsReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	/* begin JumpZero: */
	jumpIsContext1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(SendNumArgsReg, Extra0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Extra0Reg, SendNumArgsReg);
	genConvertSmallIntegerToIntegerInReg(SendNumArgsReg);
	/* begin AndCq:R: */
	quickConstant8 = fixedFieldsOfClassFormatMask();
	genoperandoperand(AndCqR, quickConstant8, SendNumArgsReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jmpTarget(jumpArrayDone, jmpTarget(jump64BitLongsDone, jmpTarget(jump32BitLongsDone, jmpTarget(jumpShortsDone, jmpTarget(jumpBytesDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	jumpNotIndexable = jumpNotIndexable1;
	jumpIsContext = jumpIsContext1;
	genConvertIntegerInRegtoSmallIntegerInReg(ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpImm, jmpTarget(jumpNotIndexable, jmpTarget(jumpIsContext, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return CompletePrimitive;
}


/*	primitiveCompareWith: */

	/* CogObjectRepresentationForSpur>>#genPrimitiveStringCompareWith */
static sqInt
genPrimitiveStringCompareWith(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *instr;
    AbstractInstruction *jump;
    AbstractInstruction *jumpAbove;
    AbstractInstruction *jumpIncorrectFormat1;
    AbstractInstruction *jumpIncorrectFormat2;
    AbstractInstruction *jumpIncorrectFormat3;
    AbstractInstruction *jumpIncorrectFormat4;
    AbstractInstruction *jumpMidFailure;
    AbstractInstruction *jumpSuccess;
    sqInt minSizeReg;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt string1CharOrByteSizeReg;
    sqInt string1Reg;
    sqInt string2CharOrByteSizeReg;
    sqInt string2Reg;


	/* I redefine those name to ease program comprehension */
	string1Reg = ReceiverResultReg;
	string2Reg = Arg0Reg;
	string1CharOrByteSizeReg = Arg1Reg;
	string2CharOrByteSizeReg = ClassReg;

	/* Load arguments in reg */
	minSizeReg = SendNumArgsReg;
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genGetFormatOfinto(string1Reg, TempReg);
	/* begin CmpCq:R: */
	quickConstant = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpLess: */
	jumpIncorrectFormat1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant1, TempReg);
	/* begin JumpAboveOrEqual: */
	jumpIncorrectFormat2 = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	genGetNumSlotsOfinto(string1Reg, string1CharOrByteSizeReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), string1CharOrByteSizeReg);
	gAndCqRR(BytesPerWord - 1, TempReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, string1CharOrByteSizeReg);
	genGetFormatOfinto(string2Reg, TempReg);
	/* begin CmpCq:R: */
	quickConstant2 = firstByteFormat();
	genoperandoperand(CmpCqR, quickConstant2, TempReg);
	/* begin JumpLess: */
	jumpIncorrectFormat3 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant3, TempReg);
	/* begin JumpAboveOrEqual: */
	jumpIncorrectFormat4 = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	genGetNumSlotsOfinto(string2Reg, string2CharOrByteSizeReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), string2CharOrByteSizeReg);
	gAndCqRR(BytesPerWord - 1, TempReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, string2CharOrByteSizeReg);
	/* begin CmpR:R: */
	assert(!((string1CharOrByteSizeReg == SPReg)));
	genoperandoperand(CmpRR, string1CharOrByteSizeReg, string2CharOrByteSizeReg);
	/* begin JumpBelow: */
	jumpAbove = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, string1CharOrByteSizeReg, minSizeReg);
	/* begin Jump: */
	jump = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpAbove, genoperandoperand(MoveRR, string2CharOrByteSizeReg, minSizeReg));
	jmpTarget(jump, checkQuickConstantforInstruction(0, genoperandoperand(CmpCqR, 0, minSizeReg)));
	/* begin JumpZero: */
	jumpSuccess = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveCq:R: */
	
	BaseHeaderSize;
	anInstruction = genoperandoperand(MoveCqR, BaseHeaderSize, TempReg);
	/* begin AddCq:R: */
	
	BaseHeaderSize;
	anInstruction1 = genoperandoperand(AddCqR, BaseHeaderSize, minSizeReg);
	/* begin MoveXbr:R:R: */
	instr = genoperandoperandoperand(MoveXbrRR, TempReg, string1Reg, string1CharOrByteSizeReg);
	/* begin MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, TempReg, string2Reg, string2CharOrByteSizeReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, string2CharOrByteSizeReg, string1CharOrByteSizeReg);
	/* begin JumpNonZero: */
	jumpMidFailure = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, 1, TempReg);
	/* begin CmpR:R: */
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, minSizeReg);
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)instr));
	genGetNumBytesOfinto(string1Reg, string1CharOrByteSizeReg);
	genGetNumBytesOfinto(string2Reg, string2CharOrByteSizeReg);
	jmpTarget(jumpSuccess, genoperandoperand(SubRR, string2CharOrByteSizeReg, string1CharOrByteSizeReg));
	jmpTarget(jumpMidFailure, genoperandoperand(MoveRR, string1CharOrByteSizeReg, ReceiverResultReg));
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIncorrectFormat4, jmpTarget(jumpIncorrectFormat3, jmpTarget(jumpIncorrectFormat2, jmpTarget(jumpIncorrectFormat1, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	return CompletePrimitive;
}


/*	replaceFrom: start to: stop with: replacement startingAt: repStart. 
	
	The primitive in the JIT tries to deal with two pathological cases, copy
	of arrays and byteStrings,
	which often copies only a dozen of fields and where switching to the C
	runtime cost a lot.
	
	Based on heuristics on the method class, I generate a quick array path
	(typically for Array),
	a quick byteString path (typically for ByteString, ByteArray and
	LargeInteger) or no quick 
	path at all (Typically for Bitmap).
	
	The many tests to ensure that the primitive won't fail are not super
	optimised (multiple reloading
	or stack arguments in registers) but this is still good enough and worth
	it since we're avoiding 
	the Smalltalk to C stack switch. The tight copying loops are optimised. 
	
	It is possible to build a bigger version with the 2 different paths but I
	(Clement) believe this 
	is too big machine code wise to be worth it.
 */

	/* CogObjectRepresentationForSpur>>#genPrimitiveStringReplace */
static sqInt
genPrimitiveStringReplace(void)
{
    sqInt adjust;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt arrayReg;
    AbstractInstruction *instr;
    AbstractInstruction *jmpAlreadyRemembered;
    AbstractInstruction *jmpDestYoung;
    AbstractInstruction *jumpEmpty;
    AbstractInstruction *jumpImm;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpIncorrectFormat1;
    AbstractInstruction *jumpIncorrectFormat2;
    AbstractInstruction *jumpIncorrectFormat3;
    AbstractInstruction *jumpIncorrectFormat4;
    AbstractInstruction *jumpNotSmi1;
    AbstractInstruction *jumpNotSmi2;
    AbstractInstruction *jumpNotSmi3;
    AbstractInstruction *jumpOutOfBounds1;
    AbstractInstruction *jumpOutOfBounds2;
    AbstractInstruction *jumpOutOfBounds3;
    AbstractInstruction *jumpOutOfBounds4;
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt offset3;
    sqInt offset4;
    sqInt offset5;
    sqInt offset6;
    sqInt offset7;
    sqInt offset8;
    sqInt offset9;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt replReg;
    sqInt repStartReg;
    sqInt result;
    sqInt startReg;
    sqInt stopReg;
    sqInt wordConstant;


	/* Can I generate a quick path for this method ? */
	jmpAlreadyRemembered = ((AbstractInstruction *) 0);
	jumpImmutable = ((AbstractInstruction *) 0);
	jumpOutOfBounds3 = ((AbstractInstruction *) 0);
	jumpOutOfBounds4 = ((AbstractInstruction *) 0);
	if (!((maybeMethodClassOfseemsToBeInstantiating(methodObj, arrayFormat()))
		 || (maybeMethodClassOfseemsToBeInstantiating(methodObj, firstByteFormat())))) {
		return UnimplementedPrimitive;
	}
	arrayReg = ReceiverResultReg;
	startReg = Arg0Reg;
	stopReg = Arg1Reg;
	replReg = ClassReg;

	/* Load arguments in reg */
	repStartReg = SendNumArgsReg;
	/* begin genStackArgAt:into: */
	
	offset6 = (1) * BytesPerWord;
	genoperandoperandoperand(MoveMwrR, offset6, SPReg, repStartReg);
	/* begin genStackArgAt:into: */
	
	offset7 = (2) * BytesPerWord;
	genoperandoperandoperand(MoveMwrR, offset7, SPReg, replReg);
	/* begin genStackArgAt:into: */
	
	offset8 = (3) * BytesPerWord;
	genoperandoperandoperand(MoveMwrR, offset8, SPReg, stopReg);
	/* begin genStackArgAt:into: */
	
	offset9 = (4) * BytesPerWord;
	genoperandoperandoperand(MoveMwrR, offset9, SPReg, startReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSmi1 = genJumpNotSmallInteger(repStartReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSmi2 = genJumpNotSmallInteger(stopReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSmi3 = genJumpNotSmallInteger(startReg);

	/* if start>stop primitive success */
	jumpImm = genJumpImmediate(replReg);
	/* begin CmpR:R: */
	assert(!((startReg == SPReg)));
	genoperandoperand(CmpRR, startReg, stopReg);
	/* begin JumpLess: */
	jumpEmpty = genConditionalBranchoperand(JumpLess, ((sqInt)0));
#  if IMMUTABILITY
	jumpImmutable = genJumpImmutablescratchReg(ReceiverResultReg, TempReg);
#  endif
	/* begin CmpCq:R: */
	
	(((usqInt)0 << 3) | 1);
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)0 << 3) | 1), startReg);
	/* begin JumpLessOrEqual: */
	jumpOutOfBounds1 = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	
	(((usqInt)0 << 3) | 1);
	anInstruction1 = genoperandoperand(CmpCqR, (((usqInt)0 << 3) | 1), repStartReg);
	/* begin JumpLessOrEqual: */
	jumpOutOfBounds2 = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	if (maybeMethodClassOfseemsToBeInstantiating(methodObj, arrayFormat())) {

		/* Are they both array format ? */
		genGetFormatOfinto(arrayReg, TempReg);
		genGetFormatOfinto(replReg, startReg);
		/* begin CmpCq:R: */
		quickConstant = arrayFormat();
		genoperandoperand(CmpCqR, quickConstant, startReg);
		/* begin JumpNonZero: */
		jumpIncorrectFormat1 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin CmpCq:R: */
		quickConstant1 = arrayFormat();
		genoperandoperand(CmpCqR, quickConstant1, TempReg);
		/* begin JumpNonZero: */
		jumpIncorrectFormat2 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		genGetNumSlotsOfinto(arrayReg, TempReg);
		genConvertSmallIntegerToIntegerInReg(stopReg);
		/* begin CmpR:R: */
		assert(!((TempReg == SPReg)));
		genoperandoperand(CmpRR, TempReg, stopReg);
		/* begin JumpGreater: */
		jumpOutOfBounds3 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
		genGetNumSlotsOfinto(replReg, TempReg);
		/* begin genStackArgAt:into: */
		
		offset = (4) * BytesPerWord;
		genoperandoperandoperand(MoveMwrR, offset, SPReg, startReg);
		genConvertSmallIntegerToIntegerInReg(startReg);
		genConvertSmallIntegerToIntegerInReg(repStartReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, startReg, stopReg);
		/* begin AddR:R: */
		genoperandoperand(AddRR, repStartReg, stopReg);
		/* begin CmpR:R: */
		assert(!((TempReg == SPReg)));
		genoperandoperand(CmpRR, TempReg, stopReg);
		/* begin JumpGreater: */
		jumpOutOfBounds4 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
		/* begin MoveCw:R: */
		wordConstant = storeCheckBoundary();
		genoperandoperand(MoveCwR, wordConstant, TempReg);
		/* begin CmpR:R: */
		assert(!((TempReg == SPReg)));
		genoperandoperand(CmpRR, TempReg, arrayReg);
		/* begin JumpBelow: */
		jmpDestYoung = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
		if (!CheckRememberedInTrampoline) {
			jmpAlreadyRemembered = genCheckRememberedBitOfscratch(arrayReg, TempReg);
		}
		/* begin saveAndRestoreLinkRegAround: */
		backEnd();
		callStoreCheckTrampoline();
		jmpTarget(jmpDestYoung, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		if (!CheckRememberedInTrampoline) {
			jmpTarget(jmpAlreadyRemembered, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		}
		/* begin genStackArgAt:into: */
		
		offset1 = (3) * BytesPerWord;
		genoperandoperandoperand(MoveMwrR, offset1, SPReg, stopReg);
		genConvertSmallIntegerToIntegerInReg(stopReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, startReg, repStartReg);
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), repStartReg);
		/* begin AddR:R: */
		genoperandoperand(AddRR, repStartReg, replReg);
		adjust = (((usqInt)(BaseHeaderSize)) >> (shiftForWord())) - 1;
		if (adjust != 0) {
			/* begin AddCq:R: */
			genoperandoperand(AddCqR, adjust, startReg);
			/* begin AddCq:R: */
			genoperandoperand(AddCqR, adjust, stopReg);
		}
		/* begin MoveXwr:R:R: */
		instr = genoperandoperandoperand(MoveXwrRR, startReg, replReg, TempReg);
		/* begin MoveR:Xwr:R: */
		genoperandoperandoperand(MoveRXwrR, TempReg, startReg, arrayReg);
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 1, startReg);
		/* begin CmpR:R: */
		assert(!((startReg == SPReg)));
		genoperandoperand(CmpRR, startReg, stopReg);
		/* begin JumpAboveOrEqual: */
		genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)instr));
		jmpTarget(jumpEmpty, (methodOrBlockNumArgs <= (numRegArgs())
			? (/* begin RetN: */
				genoperand(RetN, 0))
			: (/* begin RetN: */
				genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord))));
		jmpTarget(jumpIncorrectFormat1, jmpTarget(jumpIncorrectFormat2, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	}
	if (maybeMethodClassOfseemsToBeInstantiating(methodObj, firstByteFormat())) {

		/* Are they both byte array format ? CompiledMethod excluded */
		genGetFormatOfinto(arrayReg, TempReg);
		genGetFormatOfinto(replReg, repStartReg);
		/* begin CmpCq:R: */
		quickConstant2 = firstByteFormat();
		genoperandoperand(CmpCqR, quickConstant2, repStartReg);
		/* begin JumpLess: */
		jumpIncorrectFormat1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
		/* begin CmpCq:R: */
		quickConstant3 = firstCompiledMethodFormat();
		genoperandoperand(CmpCqR, quickConstant3, repStartReg);
		/* begin JumpGreaterOrEqual: */
		jumpIncorrectFormat2 = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
		/* begin CmpCq:R: */
		quickConstant4 = firstByteFormat();
		genoperandoperand(CmpCqR, quickConstant4, TempReg);
		/* begin JumpLess: */
		jumpIncorrectFormat3 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
		/* begin CmpCq:R: */
		quickConstant5 = firstCompiledMethodFormat();
		genoperandoperand(CmpCqR, quickConstant5, TempReg);
		/* begin JumpGreaterOrEqual: */
		jumpIncorrectFormat4 = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
		genGetNumSlotsOfinto(arrayReg, startReg);
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), startReg);
		gAndCqRR(BytesPerWord - 1, TempReg, TempReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, TempReg, startReg);
		genConvertSmallIntegerToIntegerInReg(stopReg);
		/* begin CmpR:R: */
		assert(!((startReg == SPReg)));
		genoperandoperand(CmpRR, startReg, stopReg);
		/* begin JumpGreater: */
		jumpOutOfBounds3 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, repStartReg, TempReg);
		/* begin genStackArgAt:into: */
		
		offset2 = (1) * BytesPerWord;
		genoperandoperandoperand(MoveMwrR, offset2, SPReg, repStartReg);
		/* begin genStackArgAt:into: */
		
		offset3 = (4) * BytesPerWord;
		genoperandoperandoperand(MoveMwrR, offset3, SPReg, startReg);
		genConvertSmallIntegerToIntegerInReg(startReg);
		genConvertSmallIntegerToIntegerInReg(repStartReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, startReg, stopReg);
		/* begin AddR:R: */
		genoperandoperand(AddRR, repStartReg, stopReg);
		genGetNumSlotsOfinto(replReg, startReg);
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), startReg);
		gAndCqRR(BytesPerWord - 1, TempReg, TempReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, TempReg, startReg);
		/* begin CmpR:R: */
		assert(!((startReg == SPReg)));
		genoperandoperand(CmpRR, startReg, stopReg);
		/* begin JumpGreater: */
		jumpOutOfBounds4 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
		/* begin genStackArgAt:into: */
		
		offset4 = (4) * BytesPerWord;
		genoperandoperandoperand(MoveMwrR, offset4, SPReg, startReg);
		genConvertSmallIntegerToIntegerInReg(startReg);
		/* begin genStackArgAt:into: */
		
		offset5 = (3) * BytesPerWord;
		genoperandoperandoperand(MoveMwrR, offset5, SPReg, stopReg);
		genConvertSmallIntegerToIntegerInReg(stopReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, startReg, repStartReg);
		/* begin AddR:R: */
		genoperandoperand(AddRR, repStartReg, replReg);
		adjust = BaseHeaderSize - 1;
		if (adjust != 0) {
			/* begin AddCq:R: */
			genoperandoperand(AddCqR, adjust, startReg);
			/* begin AddCq:R: */
			genoperandoperand(AddCqR, adjust, stopReg);
		}
		/* begin MoveXbr:R:R: */
		instr = genoperandoperandoperand(MoveXbrRR, startReg, replReg, TempReg);
		/* begin MoveR:Xbr:R: */
		genoperandoperandoperand(MoveRXbrR, TempReg, startReg, arrayReg);
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 1, startReg);
		/* begin CmpR:R: */
		assert(!((startReg == SPReg)));
		genoperandoperand(CmpRR, startReg, stopReg);
		/* begin JumpAboveOrEqual: */
		genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)instr));
		jmpTarget(jumpEmpty, (methodOrBlockNumArgs <= (numRegArgs())
			? (/* begin RetN: */
				genoperand(RetN, 0))
			: (/* begin RetN: */
				genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord))));
		jmpTarget(jumpIncorrectFormat4, jmpTarget(jumpIncorrectFormat3, jmpTarget(jumpIncorrectFormat2, jmpTarget(jumpIncorrectFormat1, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	}
	if (((result = compileInterpreterPrimitive())) < 0) {
		return result;
	}
	jmpTarget(jumpImm, jmpTarget(jumpNotSmi1, jmpTarget(jumpNotSmi2, jmpTarget(jumpNotSmi3, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	jmpTarget(jumpOutOfBounds1, jmpTarget(jumpOutOfBounds2, jmpTarget(jumpOutOfBounds3, jmpTarget(jumpOutOfBounds4, ((AbstractInstruction *) (((jumpImm->operands))[0]))))));
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, ((AbstractInstruction *) (((jumpImm->operands))[0])));
#  endif
	return CompletePrimitive;
}

	/* CogObjectRepresentationForSpur>>#genSetSmallIntegerTagsIn: */
static sqInt NoDbgRegParms
genSetSmallIntegerTagsIn(sqInt scratchReg)
{
	/* begin OrCq:R: */
	genoperandoperand(OrCqR, 1, scratchReg);
	return 0;
}


/*	Create a trampoline to store-check the update of the receiver in a
	closure's outerContext in compileBlockFrameBuild:. */

	/* CogObjectRepresentationForSpur>>#genStoreCheckContextReceiverTrampoline */
static usqInt
genStoreCheckContextReceiverTrampoline(void)
{
    usqInt startAddress;

	startAddress = methodZoneBase();
	zeroOpcodeIndex();
	genStoreCheckReceiverRegvalueRegscratchReginFrame(ReceiverResultReg, Arg0Reg, TempReg, 0);
	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceStoreCheckContextReceiver", startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate the code for a store check of valueReg into destReg. */

	/* CogObjectRepresentationForSpur>>#genStoreCheckReceiverReg:valueReg:scratchReg:inFrame: */
static sqInt NoDbgRegParms
genStoreCheckReceiverRegvalueRegscratchReginFrame(sqInt destReg, sqInt valueReg, sqInt scratchReg, sqInt inFrame)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *jmpAlreadyRemembered;
    AbstractInstruction *jmpDestYoung;
    AbstractInstruction *jmpImmediate;
    AbstractInstruction *jmpSourceOld;
    sqInt wordConstant;


	/* Is value stored an immediate?  If so we're done */
	jmpAlreadyRemembered = ((AbstractInstruction *) 0);

	/* Get the old/new boundary in scratchReg */
	jmpImmediate = genJumpImmediate(valueReg);
	/* begin MoveCw:R: */
	wordConstant = storeCheckBoundary();
	genoperandoperand(MoveCwR, wordConstant, scratchReg);
	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, destReg);
	/* begin JumpBelow: */
	jmpDestYoung = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, valueReg);
	/* begin JumpAboveOrEqual: */
	jmpSourceOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	if (!CheckRememberedInTrampoline) {
		jmpAlreadyRemembered = genCheckRememberedBitOfscratch(destReg, scratchReg);
	}
	assert(destReg == ReceiverResultReg);
	/* begin evaluateTrampolineCallBlock:protectLinkRegIfNot: */
	if (inFrame) {
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceStoreCheckTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* begin saveAndRestoreLinkRegAround: */
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceStoreCheckTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	jmpTarget(jmpImmediate, jmpTarget(jmpDestYoung, jmpTarget(jmpSourceOld, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	if (!CheckRememberedInTrampoline) {
		jmpTarget(jmpAlreadyRemembered, ((AbstractInstruction *) (((jmpSourceOld->operands))[0])));
	}
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genStoreSourceReg:slotIndex:destReg:scratchReg:inFrame:needsStoreCheck: */
static sqInt NoDbgRegParms
genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt inFrame, sqInt needsStoreCheck)
{
    AbstractInstruction *abstractInstruction;
    sqInt offset;

	/* begin genTraceStores */
	if (traceStores > 0) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, TempReg);
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	/* begin MoveR:Mw:r: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	if (needsStoreCheck) {
		return genStoreCheckReceiverRegvalueRegscratchReginFrame(destReg, sourceReg, scratchReg, inFrame);
	}
	return 0;
}


/*	This method is used for unchecked stores in objects after their creation
	(typically, inlined creation of Array, closures and some temp vectors). 
	Currently there is no need to do the immutability check here
 */

	/* CogObjectRepresentationForSpur>>#genStoreSourceReg:slotIndex:intoNewObjectInDestReg: */
static sqInt NoDbgRegParms
genStoreSourceRegslotIndexintoNewObjectInDestReg(sqInt sourceReg, sqInt index, sqInt destReg)
{
    sqInt offset;

	/* begin MoveR:Mw:r: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	return 0;
}


/*	Convention:
	- RcvrResultReg holds the object mutated.
	If immutability failure:
	- TempReg holds the instance variable index mutated 
	if instVarIndex > numDedicatedStoreTrampoline
	- ClassReg holds the value to store
	Registers are not lived across this trampoline as the 
	immutability failure may need new stack frames. */

	/* CogObjectRepresentationForSpur>>#genStoreTrampolineCalled:instVarIndex: */
#if IMMUTABILITY
static usqInt NoDbgRegParms
genStoreTrampolineCalledinstVarIndex(char *trampolineName, sqInt instVarIndex)
{
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpImmutable1;
    AbstractInstruction *jumpRC;
    sqInt pushLinkReg;
    sqInt quickConstant;
    usqInt startAddress;

	startAddress = methodZoneBase();
	zeroOpcodeIndex();
	if (CheckRememberedInTrampoline) {
		/* begin genStoreTrampolineCheckingRememberedCalled:instVarIndex: */

		/* Store check */
		/* If on 64-bits and doing the remembered bit test here, we can combine the tests to fetch the header once. */
		jumpImmutable = genJumpImmutablescratchReg(ReceiverResultReg, SendNumArgsReg);
		/* begin TstCq:R: */
		quickConstant = 1U << (rememberedBitShift());
		genoperandoperand(TstCqR, quickConstant, SendNumArgsReg);
		/* begin JumpZero: */
		jumpRC = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin RetN: */
		genoperand(RetN, 0);
		jmpTarget(jumpRC, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(remember, 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, (((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)
			? ReceiverResultReg
			: ABIResultReg));
		jmpTarget(jumpImmutable, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceCannotAssignTowithIndexvalueToAssign, 3, ReceiverResultReg, (instVarIndex < (NumStoreTrampolines - 1)
			? (/* begin trampolineArgConstant: */
				assert(instVarIndex >= 0),
				-2 - instVarIndex)
			: TempReg), ClassReg, null, 0 /* emptyRegisterMask */, 1, NoReg);
	}
	else {
		/* begin genStoreTrampolineNotCheckingRememberedCalled:instVarIndex: */
		genSmalltalkToCStackSwitch((pushLinkReg = 0));

		/* Store check */
		jumpImmutable1 = genJumpImmutablescratchReg(ReceiverResultReg, SendNumArgsReg);
		compileCallFornumArgsargargargargresultRegregsToSave(remember, 1, ReceiverResultReg, null, null, null, (((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)
			? ReceiverResultReg
			: ABIResultReg), 0 /* emptyRegisterMask */);
		genLoadStackPointers(backEnd());
		genTrampolineReturn(pushLinkReg);
		jmpTarget(jumpImmutable1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileCallFornumArgsargargargargresultRegregsToSave(ceCannotAssignTowithIndexvalueToAssign, 3, ReceiverResultReg, (instVarIndex < (NumStoreTrampolines - 1)
			? (/* begin trampolineArgConstant: */
				assert(instVarIndex >= 0),
				-2 - instVarIndex)
			: TempReg), ClassReg, null, NoReg, 0 /* emptyRegisterMask */);
		genLoadStackPointers(backEnd());
		genTrampolineReturn(pushLinkReg);
	}
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}
#endif /* IMMUTABILITY */


/*	Store check code is duplicated to use a single trampoline */

	/* CogObjectRepresentationForSpur>>#genStoreWithImmutabilityAndStoreCheckSourceReg:slotIndex:destReg:scratchReg:needRestoreRcvr: */
#if IMMUTABILITY
static sqInt NoDbgRegParms
genStoreWithImmutabilityAndStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needRestoreRcvr)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction2;
    AbstractInstruction *abstractInstruction3;
    AbstractInstruction *immutableJump;
    AbstractInstruction *jmpAlreadyRemembered;
    AbstractInstruction *jmpDestYoung;
    AbstractInstruction *jmpImmediate;
    AbstractInstruction *jmpSourceOld;
    sqInt offset;
    sqInt wordConstant;

	jmpAlreadyRemembered = ((AbstractInstruction *) 0);
	immutableJump = genJumpImmutablescratchReg(destReg, scratchReg);
	/* begin genTraceStores */
	if (traceStores > 0) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, TempReg);
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	/* begin MoveR:Mw:r: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);

	/* Get the old/new boundary in scratchReg */
	jmpImmediate = genJumpImmediate(sourceReg);
	/* begin MoveCw:R: */
	wordConstant = storeCheckBoundary();
	genoperandoperand(MoveCwR, wordConstant, scratchReg);
	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, destReg);
	/* begin JumpBelow: */
	jmpDestYoung = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, sourceReg);
	/* begin JumpAboveOrEqual: */
	jmpSourceOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	if (!CheckRememberedInTrampoline) {
		jmpAlreadyRemembered = genCheckRememberedBitOfscratch(destReg, scratchReg);
	}
	jmpTarget(immutableJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin genStoreTrampolineCall: */
	assert(IMMUTABILITY);
	if (index >= (NumStoreTrampolines - 1)) {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, index, TempReg);
		/* begin CallRT: */
		
		abstractInstruction3 = genoperand(Call, ceStoreTrampolines[NumStoreTrampolines - 1]);
		(abstractInstruction3->annotation = IsRelativeCall);
	}
	else {
		/* begin CallRT: */
		
		abstractInstruction1 = genoperand(Call, ceStoreTrampolines[index]);
		(abstractInstruction1->annotation = IsRelativeCall);
	}
	/* begin annotateBytecode: */
	abstractInstruction2 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction2->annotation = HasBytecodePC);
	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	if (needRestoreRcvr) {
		/* begin putSelfInReceiverResultReg */
		storeToReg(simSelf(), ReceiverResultReg);
	}
	jmpTarget(jmpImmediate, jmpTarget(jmpDestYoung, jmpTarget(jmpSourceOld, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	if (!CheckRememberedInTrampoline) {
		jmpTarget(jmpAlreadyRemembered, ((AbstractInstruction *) (((jmpSourceOld->operands))[0])));
	}
	return 0;
}
#endif /* IMMUTABILITY */


/*	Gen an immutability check with no store check (e.g. assigning an immediate
	literal) 
 */
/*	imm check has its own trampoline */

	/* CogObjectRepresentationForSpur>>#genStoreWithImmutabilityButNoStoreCheckSourceReg:slotIndex:destReg:scratchReg:needRestoreRcvr: */
#if IMMUTABILITY
static sqInt NoDbgRegParms
genStoreWithImmutabilityButNoStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needRestoreRcvr)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction2;
    AbstractInstruction *abstractInstruction3;
    AbstractInstruction *immutabilityFailure;
    AbstractInstruction *mutableJump;
    sqInt offset;

	mutableJump = genJumpMutablescratchReg(destReg, scratchReg);
	/* begin genStoreTrampolineCall: */
	assert(IMMUTABILITY);
	if (index >= (NumStoreTrampolines - 1)) {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, index, TempReg);
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceStoreTrampolines[NumStoreTrampolines - 1]);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* begin CallRT: */
		
		abstractInstruction1 = genoperand(Call, ceStoreTrampolines[index]);
		(abstractInstruction1->annotation = IsRelativeCall);
	}
	/* begin annotateBytecode: */
	abstractInstruction2 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction2->annotation = HasBytecodePC);
	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	if (needRestoreRcvr) {
		/* begin putSelfInReceiverResultReg */
		storeToReg(simSelf(), ReceiverResultReg);
	}
	/* begin Jump: */
	immutabilityFailure = genoperand(Jump, ((sqInt)0));
	jmpTarget(mutableJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin genTraceStores */
	if (traceStores > 0) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, TempReg);
		/* begin CallRT: */
		
		abstractInstruction3 = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction3->annotation = IsRelativeCall);
	}
	/* begin MoveR:Mw:r: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	jmpTarget(immutabilityFailure, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}
#endif /* IMMUTABILITY */


/*	We know there is a frame as immutability check requires a frame */
/*	needRestoreRcvr has to be true to keep RcvrResultReg live with the
	receiver in it across the trampoline
 */
/*	Trampoline convention... */

	/* CogObjectRepresentationForSpur>>#genStoreWithImmutabilityCheckSourceReg:slotIndex:destReg:scratchReg:needsStoreCheck:needRestoreRcvr: */
#if IMMUTABILITY
static sqInt NoDbgRegParms
genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needsStoreCheck, sqInt needRestoreRcvr)
{
	assert(destReg == ReceiverResultReg);
	assert(scratchReg == TempReg);
	assert(sourceReg == ClassReg);
	if (needsStoreCheck) {
		genStoreWithImmutabilityAndStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sourceReg, index, destReg, scratchReg, needRestoreRcvr);
	}
	else {
		genStoreWithImmutabilityButNoStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sourceReg, index, destReg, scratchReg, needRestoreRcvr);
	}
	return 0;
}
#endif /* IMMUTABILITY */


/*	Make sure SendNumArgsReg and ClassReg are available in addition to
	ReceiverResultReg and TempReg in
	genGetActiveContextNumArgs:large:inBlock:. 
 */

	/* CogObjectRepresentationForSpur>>#getActiveContextAllocatesInMachineCode */
static sqInt
getActiveContextAllocatesInMachineCode(void)
{
	return 1;
}


/*	Since all cache tags in Spur are class indices none of
	them are young or have to be updated in a scavenge. */

	/* CogObjectRepresentationForSpur>>#inlineCacheTagIsYoung: */
static sqInt NoDbgRegParms
inlineCacheTagIsYoung(sqInt cacheTag)
{
	return 0;
}

	/* CogObjectRepresentationForSpur>>#jumpNotCharacterUnsignedValueInRegister: */
static AbstractInstruction * NoDbgRegParms
jumpNotCharacterUnsignedValueInRegister(sqInt reg)
{
    sqInt quickConstant;

	/* begin CmpCq:R: */
	quickConstant = (1U << (numCharacterBits())) - 1;
	genoperandoperand(CmpCqR, quickConstant, reg);
	/* begin JumpAbove: */
	return genConditionalBranchoperand(JumpAbove, ((sqInt)0));
}


/*	Mark and trace a literal in a machine code instruction preceding address
	in cogMethodOrNil.
	Answer if code was modified. */

	/* CogObjectRepresentationForSpur>>#markAndTraceLiteral:in:atpc: */
static sqInt NoDbgRegParms
markAndTraceLiteralinatpc(sqInt literal, CogMethod *cogMethodOrNil, usqInt address)
{
    sqInt objOop;

	if (!(couldBeObject(literal))) {
		return 0;
	}
	assert(addressCouldBeObj(literal));
	if (!(isForwarded(literal))) {
		markAndTrace(literal);
		return 0;
	}
	/* begin setCodeModified */
#  if DUAL_MAPPED_CODE_ZONE
	codeModified = 1;
#  else
	codeModified = 1;
#  endif
	objOop = followForwarded(literal);
	storeLiteralbeforeFollowingAddress(backEnd(), objOop, address);
	markAndTraceUpdatedLiteralin(objOop, cogMethodOrNil);
	return 1;
}


/*	Mark and trace a literal in a sqInt variable of cogMethod. */

	/* CogObjectRepresentationForSpur>>#markAndTraceLiteral:in:at: */
static void NoDbgRegParms
markAndTraceLiteralinat(sqInt literal, CogMethod *cogMethod, sqInt *address)
{
    sqInt objOop;

	if (!(couldBeObject(literal))) {
		return;
	}
	assert(addressCouldBeObj(literal));
	if (!(isForwarded(literal))) {
		markAndTrace(literal);
		return;
	}
	objOop = followForwarded(literal);
	address[0] = objOop;
	markAndTraceUpdatedLiteralin(objOop, cogMethod);
}


/*	Common code to mark a literal in cogMethod and add
	the cogMethod to youngReferrers if the literal is young. */

	/* CogObjectRepresentationForSpur>>#markAndTraceUpdatedLiteral:in: */
static void NoDbgRegParms
markAndTraceUpdatedLiteralin(sqInt objOop, CogMethod *cogMethodOrNil)
{
	if (isNonImmediate(objOop)) {
		if ((cogMethodOrNil != null)
		 && (isYoungObject(objOop))) {
			ensureInYoungReferrers(cogMethodOrNil);
		}
		markAndTrace(objOop);
	}
}


/*	If primIndex has an accessorDepth and fails, or it is external and fails
	with PrimErrNoMemory,
	call ceCheckAndMaybeRetryPrimitive if so If ceCheck.... answers true,
	retry the primitive. */

	/* CogObjectRepresentationForSpur>>#maybeCompileRetryOf:onPrimitiveFail:flags: */
static sqInt NoDbgRegParms
maybeCompileRetryOfonPrimitiveFailflags(void (*primitiveRoutine)(void), sqInt primIndex, sqInt flags)
{
    sqInt address;
    sqInt address1;
    sqInt address2;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmp;

	if ((accessorDepthForPrimitiveIndex(primIndex)) >= 0) {
		/* begin MoveAw:R: */
		address = primFailCodeAddress();
		genoperandoperand(MoveAwR, address, TempReg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, TempReg);
		/* begin JumpZero: */
		jmp = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	}
	else {
		if (PrimNumberExternalCall != primIndex) {
			return 0;
		}
		/* begin MoveAw:R: */
		address1 = primFailCodeAddress();
		genoperandoperand(MoveAwR, address1, TempReg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, PrimErrNoMemory, TempReg);
		/* begin JumpNonZero: */
		jmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	}
	if (!(((flags & PrimCallNeedsNewMethod) != 0))) {
		genLoadNewMethod();
	}
	/* begin MoveCw:R: */
	
	((sqInt)primitiveRoutine);
	anInstruction = genoperandoperand(MoveCwR, ((sqInt)primitiveRoutine), TempReg);
	/* begin MoveR:Aw: */
	address2 = primitiveFunctionPointerAddress();
	genoperandoperand(MoveRAw, TempReg, address2);
	compileCallFornumArgsargargargargresultRegregsToSave(ceCheckAndMaybeRetryPrimitive, 1, (assert(primIndex >= 0),
	-2 - primIndex), null, null, null, TempReg, 0 /* emptyRegisterMask */);
	jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	Generate a shift of the register containing the class tag in a method
	cache probe.
	c.f. SpurMemoryManager>>methodCacheHashOf:with: */

	/* CogObjectRepresentationForSpur>>#maybeShiftClassTagRegisterForMethodCacheProbe: */
static sqInt NoDbgRegParms
maybeShiftClassTagRegisterForMethodCacheProbe(sqInt classTagReg)
{
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 2, classTagReg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#numCharacterBits */
static sqInt
numCharacterBits(void)
{
	return 30;
}

	/* CogObjectRepresentationForSpur>>#remapObject: */
static sqInt NoDbgRegParms
remapObject(sqInt objOop)
{
	assert(addressCouldBeObj(objOop));
	return (shouldRemapObj(objOop)
		? remapObj(objOop)
		: objOop);
}

	/* CogObjectRepresentationForSpur>>#remapOop: */
static sqInt NoDbgRegParms
remapOop(sqInt objOop)
{
	return (shouldRemapOop(objOop)
		? remapObj(objOop)
		: objOop);
}


/*	Objects in newSpace or oldSpace except nil, true, false &
	classTableRootObj need to be annotated.
 */

	/* CogObjectRepresentationForSpur>>#shouldAnnotateObjectReference: */
static sqInt NoDbgRegParms
shouldAnnotateObjectReference(sqInt anOop)
{
	return (isNonImmediate(anOop))
	 && ((oopisGreaterThan(anOop, classTableRootObj()))
	 || (oopisLessThan(anOop, nilObject())));
}

	/* CogObjectRepresentationForSpur>>#slotOffsetOfInstVarIndex: */
static sqInt NoDbgRegParms
slotOffsetOfInstVarIndex(sqInt index)
{
	return (index * BytesPerWord) + BaseHeaderSize;
}

	/* CogSimStackEntry>>#ensureSpilledAt:from: */
static SimStackEntry * NoDbgRegParms
ensureSpilledAtfrom(SimStackEntry * self_in_ensureSpilledAtfrom, sqInt baseOffset, sqInt baseRegister)
{
    sqInt baseReg;
    sqInt constant;
    AbstractInstruction *inst;
    sqInt offset;
    sqInt reg;

	if ((self_in_ensureSpilledAtfrom->spilled)) {
		if (((self_in_ensureSpilledAtfrom->type)) == SSSpill) {
			assert(((((self_in_ensureSpilledAtfrom->offset)) == baseOffset)
			 && (((self_in_ensureSpilledAtfrom->registerr)) == baseRegister))
			 || (violatesEnsureSpilledSpillAssert()));
			return self_in_ensureSpilledAtfrom;
		}
	}
	assert(((self_in_ensureSpilledAtfrom->type)) != SSSpill);
	traceSpill(self_in_ensureSpilledAtfrom);
	if (((self_in_ensureSpilledAtfrom->type)) == SSConstant) {
		/* begin genPushConstant: */
		constant = (self_in_ensureSpilledAtfrom->constant);
		if (shouldAnnotateObjectReference(constant)) {
			inst = annotateobjRef(checkLiteralforInstruction(constant, genoperand(PushCw, constant)), constant);
		}
		else {
			/* begin PushCq: */
			inst = genoperand(PushCq, constant);
		}
	}
	else {
		if (((self_in_ensureSpilledAtfrom->type)) == SSBaseOffset) {
			/* begin MoveMw:r:R: */
			offset = (self_in_ensureSpilledAtfrom->offset);
			baseReg = (self_in_ensureSpilledAtfrom->registerr);
			genoperandoperandoperand(MoveMwrR, offset, baseReg, TempReg);
			/* begin PushR: */
			inst = genoperand(PushR, TempReg);
		}
		else {
			assert(((self_in_ensureSpilledAtfrom->type)) == SSRegister);
			/* begin PushR: */
			reg = (self_in_ensureSpilledAtfrom->registerr);
			inst = genoperand(PushR, reg);
		}
		(self_in_ensureSpilledAtfrom->type) = SSSpill;
		(self_in_ensureSpilledAtfrom->offset) = baseOffset;
		(self_in_ensureSpilledAtfrom->registerr) = baseRegister;
	}
	(self_in_ensureSpilledAtfrom->spilled) = 1;
	return 0;
}

	/* CogSimStackEntry>>#isSameEntryAs: */
static sqInt NoDbgRegParms
isSameEntryAs(SimStackEntry * self_in_isSameEntryAs, CogSimStackEntry *ssEntry)
{
	return (((self_in_isSameEntryAs->type)) == ((ssEntry->type)))
	 && ((((((self_in_isSameEntryAs->type)) == SSBaseOffset)
	 || (((self_in_isSameEntryAs->type)) == SSSpill))
	 && ((((self_in_isSameEntryAs->offset)) == ((ssEntry->offset)))
	 && (((self_in_isSameEntryAs->registerr)) == ((ssEntry->registerr)))))
	 || (((((self_in_isSameEntryAs->type)) == SSRegister)
	 && (((self_in_isSameEntryAs->registerr)) == ((ssEntry->registerr))))
	 || ((((self_in_isSameEntryAs->type)) == SSConstant)
	 && (((self_in_isSameEntryAs->constant)) == ((ssEntry->constant))))));
}


/*	Receiver is not a forwarder, except in blocks with no inst var access.
	For now we optimize only the case where receiver is accessed in a method. */

	/* CogSimStackEntry>>#mayBeAForwarder */
static sqInt NoDbgRegParms
mayBeAForwarder(SimStackEntry * self_in_mayBeAForwarder)
{
	if ((((self_in_mayBeAForwarder->type)) == SSRegister)
	 && (isNonForwarderReceiver((self_in_mayBeAForwarder->registerr)))) {
		return 0;
	}
	return ((self_in_mayBeAForwarder->type)) != SSConstant;
}

	/* CogSimStackEntry>>#popToReg: */
static void NoDbgRegParms
popToReg(SimStackEntry * self_in_popToReg, sqInt reg)
{
    sqInt baseReg;
    sqInt constant;
    sqInt offset;
    sqInt reg1;

	if ((self_in_popToReg->spilled)) {
		/* begin PopR: */
		genoperand(PopR, reg);
	}
	else {
		switch ((self_in_popToReg->type)) {
		case SSBaseOffset:
			/* begin MoveMw:r:R: */
			offset = (self_in_popToReg->offset);
			baseReg = (self_in_popToReg->registerr);
			genoperandoperandoperand(MoveMwrR, offset, baseReg, reg);
			break;
		case SSConstant:
			/* begin genMoveConstant:R: */
			constant = (self_in_popToReg->constant);
			if (shouldAnnotateObjectReference(constant)) {
				annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(MoveCwR, constant, reg)), constant);
			}
			else {
				/* begin MoveCq:R: */
				genoperandoperand(MoveCqR, constant, reg);
			}
			break;
		case SSRegister:
			if (reg != ((self_in_popToReg->registerr))) {
				/* begin MoveR:R: */
				reg1 = (self_in_popToReg->registerr);
				genoperandoperand(MoveRR, reg1, reg);
			}
			else {
				/* begin Label */
				genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
}


/*	Answer a bit mask for the receiver's register, if any. */

	/* CogSimStackEntry>>#registerMask */
static sqInt NoDbgRegParms
registerMask(SimStackEntry * self_in_registerMask)
{
    sqInt reg;

	return ((((self_in_registerMask->type)) == SSBaseOffset)
	 || (((self_in_registerMask->type)) == SSRegister)
		? (/* begin registerMaskFor: */
			(reg = (self_in_registerMask->registerr)),
			((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))
		: 0);
}

	/* CogSimStackEntry>>#registerMaskOrNone */
static sqInt NoDbgRegParms
registerMaskOrNone(SimStackEntry * self_in_registerMaskOrNone)
{
    sqInt reg;

	return (((self_in_registerMaskOrNone->type)) == SSRegister
		? (/* begin registerMaskFor: */
			(reg = (self_in_registerMaskOrNone->registerr)),
			((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))
		: 0);
}

	/* CogSimStackEntry>>#registerOrNone */
static sqInt NoDbgRegParms
registerOrNone(SimStackEntry * self_in_registerOrNone)
{
	return (((self_in_registerOrNone->type)) == SSRegister
		? (self_in_registerOrNone->registerr)
		: NoReg);
}

	/* CogSimStackEntry>>#storeToReg: */
static void NoDbgRegParms
storeToReg(SimStackEntry * self_in_storeToReg, sqInt reg)
{
    sqInt baseReg;
    sqInt constant;
    sqInt offset;
    sqInt reg1;

	switch ((self_in_storeToReg->type)) {
	case SSBaseOffset:
	case SSSpill:
		/* begin MoveMw:r:R: */
		offset = (self_in_storeToReg->offset);
		baseReg = (self_in_storeToReg->registerr);
		genoperandoperandoperand(MoveMwrR, offset, baseReg, reg);
		break;
	case SSConstant:
		/* begin genMoveConstant:R: */
		constant = (self_in_storeToReg->constant);
		if (shouldAnnotateObjectReference(constant)) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(MoveCwR, constant, reg)), constant);
		}
		else {
			/* begin MoveCq:R: */
			genoperandoperand(MoveCqR, constant, reg);
		}
		break;
	case SSRegister:
		if (reg != ((self_in_storeToReg->registerr))) {
			/* begin MoveR:R: */
			reg1 = (self_in_storeToReg->registerr);
			genoperandoperand(MoveRR, reg1, reg);
		}
		else {
			/* begin Label */
			genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		break;
	default:
		error("Case not found and no otherwise clause");
	}
}

	/* CogSimStackNativeEntry>>#ensureIsMarkedAsSpilled */
static void NoDbgRegParms
ensureIsMarkedAsSpilled(CogSimStackNativeEntry * self_in_ensureIsMarkedAsSpilled)
{
	if (!((self_in_ensureIsMarkedAsSpilled->spilled))) {
		switch ((self_in_ensureIsMarkedAsSpilled->type)) {
		case SSNativeRegister:
		case SSConstantInt32:
		case SSConstantNativePointer:
			(self_in_ensureIsMarkedAsSpilled->type) = SSSpillNative;
			break;
		case SSRegisterSingleFloat:
		case SSConstantFloat32:
			(self_in_ensureIsMarkedAsSpilled->type) = SSSpillFloat32;
			break;
		case SSRegisterDoubleFloat:
		case SSConstantFloat64:
			(self_in_ensureIsMarkedAsSpilled->type) = SSSpillFloat64;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	(self_in_ensureIsMarkedAsSpilled->spilled) = 1;
}

	/* CogSimStackNativeEntry>>#ensureSpilledSP:scratchRegister: */
static void NoDbgRegParms
ensureSpilledSPscratchRegister(CogSimStackNativeEntry * self_in_ensureSpilledSPscratchRegister, sqInt spRegister, sqInt scratchRegister)
{
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt offset3;
    sqInt offset4;
    sqInt offset5;
    sqInt offset6;
    sqInt offset7;
    sqInt offset8;
    sqInt quickConstant;
    sqInt sourceDPReg;
    sqInt sourceDPReg1;
    sqInt sourceReg;
    sqInt wordConstant;
    sqInt wordConstant1;
    sqInt wordConstant2;
    sqInt wordConstant3;
    sqInt wordConstant4;

	if (!((self_in_ensureSpilledSPscratchRegister->spilled))) {
		switch ((self_in_ensureSpilledSPscratchRegister->type)) {
		case SSNativeRegister:
			/* begin MoveR:Mw:r: */
			sourceReg = (self_in_ensureSpilledSPscratchRegister->registerr);
			offset = (-((self_in_ensureSpilledSPscratchRegister->offset))) - 1;
			genoperandoperandoperand(MoveRMwr, sourceReg, offset, spRegister);
			(self_in_ensureSpilledSPscratchRegister->type) = SSSpillNative;
			break;
		case SSRegisterSingleFloat:
			/* begin MoveRs:M32:r: */
			sourceDPReg = (self_in_ensureSpilledSPscratchRegister->registerr);
			offset1 = (-((self_in_ensureSpilledSPscratchRegister->offset))) - 1;
			genoperandoperandoperand(MoveRsM32r, sourceDPReg, offset1, spRegister);
			(self_in_ensureSpilledSPscratchRegister->type) = SSSpillFloat32;
			break;
		case SSRegisterDoubleFloat:
			/* begin MoveRd:M64:r: */
			sourceDPReg1 = (self_in_ensureSpilledSPscratchRegister->registerr);
			offset2 = (-((self_in_ensureSpilledSPscratchRegister->offset))) - 1;
			genoperandoperandoperand(MoveRdM64r, sourceDPReg1, offset2, spRegister);
			(self_in_ensureSpilledSPscratchRegister->type) = SSSpillFloat64;
			break;
		case SSConstantFloat32:
			/* begin MoveCw:R: */
			wordConstant = asIEEE32BitWord((self_in_ensureSpilledSPscratchRegister->constantFloat32));
			genoperandoperand(MoveCwR, wordConstant, scratchRegister);
			/* begin MoveR:M32:r: */
			offset3 = (-((self_in_ensureSpilledSPscratchRegister->offset))) - 1;
			genoperandoperandoperand(MoveRM32r, scratchRegister, offset3, spRegister);
			(self_in_ensureSpilledSPscratchRegister->type) = SSSpillFloat32;
			break;
		case SSConstantFloat64:
			if (BytesPerWord == 4) {
				/* begin MoveCw:R: */
				wordConstant1 = (asIEEE64BitWord((self_in_ensureSpilledSPscratchRegister->constantFloat64))) & 0xFFFFFFFFU;
				genoperandoperand(MoveCwR, wordConstant1, scratchRegister);
				/* begin MoveR:M32:r: */
				offset4 = (-((self_in_ensureSpilledSPscratchRegister->offset))) - 1;
				genoperandoperandoperand(MoveRM32r, scratchRegister, offset4, spRegister);
				/* begin MoveCw:R: */
				wordConstant2 = (((((sqLong) -32)) < 0) ? (((usqInt)((asIEEE64BitWord((self_in_ensureSpilledSPscratchRegister->constantFloat64))))) >> (-(((sqLong) -32)))) : (((sqInt)((usqInt)((asIEEE64BitWord((self_in_ensureSpilledSPscratchRegister->constantFloat64)))) << (((sqLong) -32))))));
				genoperandoperand(MoveCwR, wordConstant2, scratchRegister);
				/* begin MoveR:M32:r: */
				offset5 = ((-((self_in_ensureSpilledSPscratchRegister->offset))) - 1) + 4;
				genoperandoperandoperand(MoveRM32r, scratchRegister, offset5, spRegister);
			}
			else {
				/* begin MoveCw:R: */
				wordConstant3 = asIEEE64BitWord((self_in_ensureSpilledSPscratchRegister->constantFloat32));
				genoperandoperand(MoveCwR, wordConstant3, scratchRegister);
				/* begin MoveR:Mw:r: */
				offset6 = (-((self_in_ensureSpilledSPscratchRegister->offset))) - 1;
				genoperandoperandoperand(MoveRMwr, scratchRegister, offset6, spRegister);
			}
			(self_in_ensureSpilledSPscratchRegister->type) = SSSpillFloat64;
			break;
		case SSConstantInt32:
			/* begin MoveCq:R: */
			quickConstant = (self_in_ensureSpilledSPscratchRegister->constantInt32);
			genoperandoperand(MoveCqR, quickConstant, scratchRegister);
			/* begin MoveR:Mw:r: */
			offset7 = (-((self_in_ensureSpilledSPscratchRegister->offset))) - 1;
			genoperandoperandoperand(MoveRMwr, scratchRegister, offset7, spRegister);
			(self_in_ensureSpilledSPscratchRegister->type) = SSSpillNative;
			break;
		case SSConstantNativePointer:
			/* begin MoveCw:R: */
			wordConstant4 = (self_in_ensureSpilledSPscratchRegister->constantNativePointer);
			genoperandoperand(MoveCwR, wordConstant4, scratchRegister);
			/* begin MoveR:Mw:r: */
			offset8 = (-((self_in_ensureSpilledSPscratchRegister->offset))) - 1;
			genoperandoperandoperand(MoveRMwr, scratchRegister, offset8, spRegister);
			(self_in_ensureSpilledSPscratchRegister->type) = SSSpillNative;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	(self_in_ensureSpilledSPscratchRegister->spilled) = 1;
}


/*	Answer a bit mask for the receiver's register, if any. */

	/* CogSimStackNativeEntry>>#nativeFloatRegisterMask */
static sqInt NoDbgRegParms
nativeFloatRegisterMask(CogSimStackNativeEntry * self_in_nativeFloatRegisterMask)
{
    sqInt reg;

	return ((((self_in_nativeFloatRegisterMask->type)) == SSRegisterSingleFloat)
	 || (((self_in_nativeFloatRegisterMask->type)) == SSRegisterDoubleFloat)
		? (/* begin registerMaskFor: */
			(reg = (self_in_nativeFloatRegisterMask->registerr)),
			((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))
		: 0);
}

	/* CogSimStackNativeEntry>>#nativeFloatRegisterOrNone */
static sqInt NoDbgRegParms
nativeFloatRegisterOrNone(CogSimStackNativeEntry * self_in_nativeFloatRegisterOrNone)
{
	return ((((self_in_nativeFloatRegisterOrNone->type)) == SSRegisterSingleFloat)
	 || (((self_in_nativeFloatRegisterOrNone->type)) == SSRegisterDoubleFloat)
		? (self_in_nativeFloatRegisterOrNone->registerr)
		: NoReg);
}

	/* CogSimStackNativeEntry>>#nativePopToReg: */
static void NoDbgRegParms
nativePopToReg(CogSimStackNativeEntry * self_in_nativePopToReg, sqInt reg)
{
    float constantFloat32;
    double constantFloat64;
    sqInt dpreg1;
    sqInt dpreg11;
    AbstractInstruction *inst;
    AbstractInstruction *inst1;
    AbstractInstruction *inst11;
    AbstractInstruction *inst2;
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt offset3;
    sqInt quickConstant;
    sqInt reg1;
    sqInt wordConstant;
    sqInt wordConstant1;
    sqInt wordConstant2;

	if ((self_in_nativePopToReg->spilled)) {
		loadNativeFramePointerInto(TempReg);
		switch ((self_in_nativePopToReg->type)) {
		case SSSpillNative:
			/* begin MoveMw:r:R: */
			offset = (-((self_in_nativePopToReg->offset))) - 1;
			genoperandoperandoperand(MoveMwrR, offset, TempReg, reg);
			break;
		case SSSpillInt64:
			assert(BytesPerWord == 8);
			/* begin MoveMw:r:R: */
			offset1 = (-((self_in_nativePopToReg->offset))) - 1;
			genoperandoperandoperand(MoveMwrR, offset1, TempReg, reg);
			break;
		case SSSpillFloat32:
			/* begin MoveM32:r:Rs: */
			offset2 = (-((self_in_nativePopToReg->offset))) - 1;
			genoperandoperandoperand(MoveM32rRs, offset2, TempReg, reg);
			break;
		case SSSpillFloat64:
			/* begin MoveM64:r:Rd: */
			offset3 = (-((self_in_nativePopToReg->offset))) - 1;
			genoperandoperandoperand(MoveM64rRd, offset3, TempReg, reg);
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	else {
		switch ((self_in_nativePopToReg->type)) {
		case SSNativeRegister:
			if (reg != ((self_in_nativePopToReg->registerr))) {
				/* begin MoveR:R: */
				reg1 = (self_in_nativePopToReg->registerr);
				genoperandoperand(MoveRR, reg1, reg);
			}
			break;
		case SSRegisterSingleFloat:
			if (reg != ((self_in_nativePopToReg->registerr))) {
				/* begin MoveRs:Rs: */
				dpreg1 = (self_in_nativePopToReg->registerr);
				genoperandoperand(MoveRsRs, dpreg1, reg);
			}
			break;
		case SSRegisterDoubleFloat:
			if (reg != ((self_in_nativePopToReg->registerr))) {
				/* begin MoveRd:Rd: */
				dpreg11 = (self_in_nativePopToReg->registerr);
				genoperandoperand(MoveRdRd, dpreg11, reg);
			}
			break;
		case SSConstantInt32:
			/* begin MoveCq:R: */
			quickConstant = (self_in_nativePopToReg->constantInt32);
			genoperandoperand(MoveCqR, quickConstant, reg);
			break;
		case SSConstantNativePointer:
			/* begin MoveCw:R: */
			wordConstant = (self_in_nativePopToReg->constantNativePointer);
			genoperandoperand(MoveCwR, wordConstant, reg);
			break;
		case SSConstantFloat32:
			/* begin genMoveCf32:Rs: */
			constantFloat32 = (self_in_nativePopToReg->constantFloat32);
			/* begin PushCw: */
			wordConstant1 = asIEEE32BitWord(constantFloat32);
			inst = genoperand(PushCw, wordConstant1);
			/* begin genPopRs: */
			
			inst1 = genoperandoperandoperand(MoveM32rRs, 0, SPReg, reg);
			/* begin AddCq:R: */
			genoperandoperand(AddCqR, 8, SPReg);
			break;
		case SSConstantFloat64:
			/* begin genMoveCf64:Rd: */
			constantFloat64 = (self_in_nativePopToReg->constantFloat64);
			/* begin PushCw: */
			wordConstant2 = asIEEE64BitWord(constantFloat64);
			inst2 = genoperand(PushCw, wordConstant2);
			/* begin genPopRd: */
			
			inst11 = genoperandoperandoperand(MoveM64rRd, 0, SPReg, reg);
			/* begin AddCq:R: */
			genoperandoperand(AddCqR, 8, SPReg);
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
}

	/* CogSimStackNativeEntry>>#nativePopToReg:secondReg: */
static void NoDbgRegParms
nativePopToRegsecondReg(CogSimStackNativeEntry * self_in_nativePopToRegsecondReg, sqInt reg, sqInt secondReg)
{
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt reg1;
    sqInt reg11;
    sqInt reg12;

	assert(BytesPerWord == 4);
	if ((self_in_nativePopToRegsecondReg->spilled)) {
		/* begin PopR: */
		genoperand(PopR, reg);
		/* begin PopR: */
		genoperand(PopR, secondReg);
	}
	else {
		switch ((self_in_nativePopToRegsecondReg->type)) {
		case SSConstantInt64:
			/* begin MoveCq:R: */
			quickConstant = ((self_in_nativePopToRegsecondReg->constantInt64)) & 0xFFFFFFFFU;
			genoperandoperand(MoveCqR, quickConstant, reg);
			/* begin MoveCq:R: */
			quickConstant1 = (((usqLong)(((self_in_nativePopToRegsecondReg->constantInt64)))) >> 32) & 0xFFFFFFFFU;
			genoperandoperand(MoveCqR, quickConstant1, secondReg);
			break;
		case SSRegisterPair:
			/* begin Label */
			genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			if (reg != ((self_in_nativePopToRegsecondReg->registerr))) {
				if (((self_in_nativePopToRegsecondReg->registerSecond)) == reg) {
					/* begin MoveR:R: */
					reg1 = (self_in_nativePopToRegsecondReg->registerSecond);
					genoperandoperand(MoveRR, reg1, TempReg);
				}
				/* begin MoveR:R: */
				reg11 = (self_in_nativePopToRegsecondReg->registerr);
				genoperandoperand(MoveRR, reg11, reg);
			}
			if (((self_in_nativePopToRegsecondReg->registerSecond)) != secondReg) {
				if (((self_in_nativePopToRegsecondReg->registerSecond)) == reg) {
					/* begin MoveR:R: */
					genoperandoperand(MoveRR, TempReg, secondReg);
				}
				else {
					/* begin MoveR:R: */
					reg12 = (self_in_nativePopToRegsecondReg->registerSecond);
					genoperandoperand(MoveRR, reg12, secondReg);
				}
			}
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
}


/*	Answer a bit mask for the receiver's register, if any. */

	/* CogSimStackNativeEntry>>#nativeRegisterMask */
static sqInt NoDbgRegParms
nativeRegisterMask(CogSimStackNativeEntry * self_in_nativeRegisterMask)
{
    sqInt reg;

	return ((((((self_in_nativeRegisterMask->type)) == SSBaseOffset)
	 || (((self_in_nativeRegisterMask->type)) == SSNativeRegister))
	 || (((self_in_nativeRegisterMask->type)) == SSRegisterSingleFloat))
	 || (((self_in_nativeRegisterMask->type)) == SSRegisterDoubleFloat)
		? (/* begin registerMaskFor: */
			(reg = (self_in_nativeRegisterMask->registerr)),
			((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))
		: (((self_in_nativeRegisterMask->type)) == SSRegisterPair
				? (((((self_in_nativeRegisterMask->registerr)) < 0) ? (((usqInt)(1)) >> (-((self_in_nativeRegisterMask->registerr)))) : (1ULL << ((self_in_nativeRegisterMask->registerr))))) | (((((self_in_nativeRegisterMask->registerSecond)) < 0) ? (((usqInt)(1)) >> (-((self_in_nativeRegisterMask->registerSecond)))) : (1ULL << ((self_in_nativeRegisterMask->registerSecond)))))
				: 0));
}

	/* CogSimStackNativeEntry>>#nativeRegisterOrNone */
static sqInt NoDbgRegParms
nativeRegisterOrNone(CogSimStackNativeEntry * self_in_nativeRegisterOrNone)
{
	return ((((self_in_nativeRegisterOrNone->type)) == SSNativeRegister)
	 || (((self_in_nativeRegisterOrNone->type)) == SSRegisterPair)
		? (self_in_nativeRegisterOrNone->registerr)
		: NoReg);
}

	/* CogSimStackNativeEntry>>#nativeRegisterSecondOrNone */
static sqInt NoDbgRegParms
nativeRegisterSecondOrNone(CogSimStackNativeEntry * self_in_nativeRegisterSecondOrNone)
{
	return (((self_in_nativeRegisterSecondOrNone->type)) == SSRegisterPair
		? (self_in_nativeRegisterSecondOrNone->registerSecond)
		: NoReg);
}

	/* CogSimStackNativeEntry>>#nativeStackPopToReg: */
static void NoDbgRegParms
nativeStackPopToReg(CogSimStackNativeEntry * self_in_nativeStackPopToReg, sqInt reg)
{
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt offset3;

	assert((self_in_nativeStackPopToReg->spilled));
	switch ((self_in_nativeStackPopToReg->type)) {
	case SSSpillNative:
		/* begin MoveMw:r:R: */
		offset = -((self_in_nativeStackPopToReg->offset));
		genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
		break;
	case SSSpillInt64:
		assert(BytesPerWord == 8);
		/* begin MoveMw:r:R: */
		offset1 = -((self_in_nativeStackPopToReg->offset));
		genoperandoperandoperand(MoveMwrR, offset1, FPReg, reg);
		break;
	case SSSpillFloat32:
		/* begin MoveM32:r:Rs: */
		offset2 = -((self_in_nativeStackPopToReg->offset));
		genoperandoperandoperand(MoveM32rRs, offset2, FPReg, reg);
		break;
	case SSSpillFloat64:
		/* begin MoveM64:r:Rd: */
		offset3 = -((self_in_nativeStackPopToReg->offset));
		genoperandoperandoperand(MoveM64rRd, offset3, FPReg, reg);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
}

	/* CogSimStackNativeEntry>>#nativeStackPopToReg:secondReg: */
static void NoDbgRegParms
nativeStackPopToRegsecondReg(CogSimStackNativeEntry * self_in_nativeStackPopToRegsecondReg, sqInt reg, sqInt secondReg)
{
    sqInt offset;
    sqInt offset1;

	assert((self_in_nativeStackPopToRegsecondReg->spilled));
	switch ((self_in_nativeStackPopToRegsecondReg->type)) {
	case SSSpillInt64:
		/* begin MoveMw:r:R: */
		offset = (-((self_in_nativeStackPopToRegsecondReg->offset))) + 4;
		genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
		/* begin MoveMw:r:R: */
		offset1 = -((self_in_nativeStackPopToRegsecondReg->offset));
		genoperandoperandoperand(MoveMwrR, offset1, FPReg, secondReg);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
}

	/* CogSimStackNativeEntry>>#spillingNeedsScratchRegister */
static sqInt NoDbgRegParms
spillingNeedsScratchRegister(CogSimStackNativeEntry * self_in_spillingNeedsScratchRegister)
{
	if (!((self_in_spillingNeedsScratchRegister->spilled))) {
		switch ((self_in_spillingNeedsScratchRegister->type)) {
		case SSConstantInt32:
		case SSConstantInt64:
		case SSConstantFloat32:
		case SSConstantFloat64:
		case SSConstantNativePointer:
			return 1;

		default:
			return 0;

		}
	}
	return 0;
}

	/* CogSimStackNativeEntry>>#stackSpillSize */
static sqInt NoDbgRegParms
stackSpillSize(CogSimStackNativeEntry * self_in_stackSpillSize)
{
	switch ((self_in_stackSpillSize->type)) {
	case SSConstantInt64:
	case SSConstantFloat64:
	case SSRegisterDoubleFloat:
	case SSRegisterPair:
	case SSSpillFloat64:
	case SSSpillInt64:
		return 8;

	default:
		return BytesPerOop;

	}
	return 0;
}

	/* CogSSBytecodeFixup>>#isMergeFixup */
static sqInt NoDbgRegParms
isMergeFixup(BytecodeFixup * self_in_isMergeFixup)
{
	return (((usqInt)((self_in_isMergeFixup->targetInstruction)))) == NeedsMergeFixupFlag;
}


/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them.
	N.B. Do /not/ allocate TempReg. */
/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them.
	N.B. Do /not/ allocate TempReg. */

	/* CogX64Compiler>>#availableRegisterOrNoneFor: */
static sqInt NoDbgRegParms
availableRegisterOrNoneFor(AbstractInstruction * self_in_availableRegisterOrNoneFor, sqInt liveRegsMask)
{
	if (!(((liveRegsMask & ((1U << Extra5Reg))) != 0))) {
		return Extra5Reg;
	}
	if (!(((liveRegsMask & ((1U << Extra4Reg))) != 0))) {
		return Extra4Reg;
	}
	if (!(((liveRegsMask & ((1U << Extra3Reg))) != 0))) {
		return Extra3Reg;
	}
	if (!(((liveRegsMask & ((1U << Extra2Reg))) != 0))) {
		return Extra2Reg;
	}
	if (!(((liveRegsMask & ((1U << Extra1Reg))) != 0))) {
		return Extra1Reg;
	}
	if (!(((liveRegsMask & ((1U << Extra0Reg))) != 0))) {
		return Extra0Reg;
	}
	if (!(((liveRegsMask & ((1U << Arg1Reg))) != 0))) {
		return Arg1Reg;
	}
	if (!(((liveRegsMask & ((1U << Arg0Reg))) != 0))) {
		return Arg0Reg;
	}
	if (!(((liveRegsMask & ((1U << SendNumArgsReg))) != 0))) {
		return SendNumArgsReg;
	}
	if (!(((liveRegsMask & ((1U << ClassReg))) != 0))) {
		return ClassReg;
	}
	if (!(((liveRegsMask & ((1U << ReceiverResultReg))) != 0))) {
		return ReceiverResultReg;
	}
	return NoReg;
}

	/* CogX64Compiler>>#callFullInstructionByteSize */
static sqInt NoDbgRegParms
callFullInstructionByteSize(AbstractInstruction * self_in_callFullInstructionByteSize)
{
	return 12;
}


/*	Answer the address the full call immediately preceding
	callSiteReturnAddress will jump to.
 */

	/* CogX64Compiler>>#callFullTargetFromReturnAddress: */
static sqInt NoDbgRegParms
callFullTargetFromReturnAddress(AbstractInstruction * self_in_callFullTargetFromReturnAddress, sqInt callSiteReturnAddress)
{
	return unalignedLongAt((callSiteReturnAddress - 2) - 8);
}

	/* CogX64Compiler>>#callInstructionByteSize */
static sqInt NoDbgRegParms
callInstructionByteSize(AbstractInstruction * self_in_callInstructionByteSize)
{
	return 5;
}


/*	Answer the address the call immediately preceding callSiteReturnAddress
	will jump to.
 */

	/* CogX64Compiler>>#callTargetFromReturnAddress: */
static sqInt NoDbgRegParms
callTargetFromReturnAddress(AbstractInstruction * self_in_callTargetFromReturnAddress, sqInt callSiteReturnAddress)
{
    usqInt callDistance;

	callDistance = literal32BeforeFollowingAddress(self_in_callTargetFromReturnAddress, callSiteReturnAddress);
	return callSiteReturnAddress + (((int) callDistance));
}

	/* CogX64Compiler>>#cFloatResultToRd: */
static void NoDbgRegParms
cFloatResultToRd(AbstractInstruction * self_in_cFloatResultToRd, sqInt reg)
{
	if (XMM0L != reg) {
		/* begin MoveRd:Rd: */
		genoperandoperand(MoveRdRd, XMM0L, reg);
	}
}

	/* CogX64Compiler>>#cFloatResultToRs: */
static void NoDbgRegParms
cFloatResultToRs(AbstractInstruction * self_in_cFloatResultToRs, sqInt reg)
{
	if (XMM0L != reg) {
		/* begin MoveRs:Rs: */
		genoperandoperand(MoveRsRs, XMM0L, reg);
	}
}

	/* CogX64Compiler>>#cmpC32RTempByteSize */
static sqInt NoDbgRegParms
cmpC32RTempByteSize(AbstractInstruction * self_in_cmpC32RTempByteSize)
{
	return 5;
}


/*	Compute the maximum size for each opcode. This allows jump offsets to
	be determined, provided that all backward branches are long branches. */
/*	N.B. The ^N forms are to get around the bytecode compiler's long branch
	limits which are exceeded when each case jumps around the otherwise. */

	/* CogX64Compiler>>#computeMaximumSize */
static sqInt NoDbgRegParms
computeMaximumSize(AbstractInstruction * self_in_computeMaximumSize)
{
	switch ((self_in_computeMaximumSize->opcode)) {
	case Label:
		return 0;

	case AlignmentNops:
		return (((self_in_computeMaximumSize->operands))[0]) - 1;

	case Fill32:
	case IMULRR:
	case CMPXCHGRMr:
	case SETE:
	case BSR:
	case SignExtend8RR:
	case SignExtend16RR:
	case ZeroExtend8RR:
	case ZeroExtend16RR:
		return 4;

	case Nop:
	case LOCK:
	case REP:
	case CLD:
	case MOVSB:
	case Stop:
		return 1;

	case CDQ:
	case CPUID:
	case MOVSQ:
		return 2;

	case IDIVR:
	case LFENCE:
	case MFENCE:
	case SFENCE:
	case CallR:
	case JumpR:
	case AddRR:
	case AddcRR:
	case AndRR:
	case CmpRR:
	case OrRR:
	case XorRR:
	case SubRR:
	case SubbRR:
	case NegateR:
	case MoveRR:
	case SignExtend32RR:
		return 3;

	case XCHGRR:
		return (((((self_in_computeMaximumSize->operands))[0]) == RAX)
		 || ((((self_in_computeMaximumSize->operands))[1]) == RAX)
			? 2
			: 3);

	case MoveRAwNoVBR:
		return ((((self_in_computeMaximumSize->operands))[0]) == RAX
			? 10
			: (((((self_in_computeMaximumSize->operands))[0]) == RBP)
				 || ((((self_in_computeMaximumSize->operands))[0]) == RSP)
					? 13
					: 14));

	case CallFull:
		return 12;

	case Call:
	case ClzRR:
	case MoveRRd:
	case MoveRdR:
	case ConvertRRd:
	case ConvertRdR:
		return 5;

	case JumpFull:
		resolveJumpTarget(self_in_computeMaximumSize);
		return 12;

	case JumpLong:
	case Jump:
		resolveJumpTarget(self_in_computeMaximumSize);
		return 5;

	case JumpZero:
	case JumpNonZero:
	case JumpNegative:
	case JumpNonNegative:
	case JumpOverflow:
	case JumpNoOverflow:
	case JumpCarry:
	case JumpNoCarry:
	case JumpLess:
	case JumpGreaterOrEqual:
	case JumpGreater:
	case JumpLessOrEqual:
	case JumpBelow:
	case JumpAboveOrEqual:
	case JumpAbove:
	case JumpBelowOrEqual:
	case JumpLongZero:
	case JumpLongNonZero:
	case JumpFPEqual:
	case JumpFPNotEqual:
	case JumpFPLess:
	case JumpFPGreaterOrEqual:
	case JumpFPGreater:
	case JumpFPLessOrEqual:
	case JumpFPOrdered:
	case JumpFPUnordered:
		resolveJumpTarget(self_in_computeMaximumSize);
		return 6;

	case RetN:
		return ((((self_in_computeMaximumSize->operands))[0]) == 0
			? 1
			: 3);

	case AddCqR:
	case AddcCqR:
	case AndCqR:
	case CmpCqR:
	case OrCqR:
	case SubCqR:
	case SubbCqR:
	case TstCqR:
		/* begin computeSizeOfArithCqR */
		if (isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])) {
			return 4;
		}
		if (is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])) {
			return ((((self_in_computeMaximumSize->operands))[1]) == RAX
				? 6
				: 7);
		}
		return 13;

	case AddCwR:
	case AndCwR:
	case CmpCwR:
	case OrCwR:
	case SubCwR:
	case XorCwR:
		/* begin computeSizeOfArithCwR */
		return 13;

	case CmpC32R:
		return ((((self_in_computeMaximumSize->operands))[1]) <= 7
			? ((((self_in_computeMaximumSize->operands))[1]) == RAX
					? 5
					: 6)
			: 7);

	case LoadEffectiveAddressMwrR:
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? 4
	: 7)) + ((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP
	? 1
	: 0));

	case LogicalShiftLeftCqR:
	case LogicalShiftRightCqR:
	case ArithmeticShiftRightCqR:
	case RotateRightCqR:
	case RotateLeftCqR:
		return ((((self_in_computeMaximumSize->operands))[0]) == 1
			? 3
			: 4);

	case LogicalShiftLeftRR:
	case LogicalShiftRightRR:
	case ArithmeticShiftRightRR:
		return computeShiftRRSize(self_in_computeMaximumSize);

	case AddRdRd:
	case CmpRdRd:
	case SubRdRd:
	case MulRdRd:
	case DivRdRd:
	case XorRdRd:
	case AddRsRs:
	case SubRsRs:
	case MulRsRs:
	case DivRsRs:
	case MoveRdRd:
	case MoveRsRs:
	case ConvertRRs:
	case ConvertRsR:
	case ConvertRsRd:
	case ConvertRdRs:
		return 4 + ((((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[0]) > 7)
	? 1
	: 0));

	case SqrtRd:
	case SqrtRs:
		return 4 + (((((self_in_computeMaximumSize->operands))[0]) > 7
	? 1
	: 0));

	case CmpRsRs:
	case XorRsRs:
		return 3 + ((((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[0]) > 7)
	? 1
	: 0));

	case MoveCqR:
		return ((((self_in_computeMaximumSize->operands))[0]) == 0
			? 3
			: (is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
					? 7
					: 10));

	case MoveCwR:
		return (((addressIsInInstructions(((AbstractInstruction *) (((self_in_computeMaximumSize->operands))[0]))))
		 || ((((AbstractInstruction *) (((self_in_computeMaximumSize->operands))[0]))) == (methodLabel())))
		 || (((((usqInt)(((self_in_computeMaximumSize->operands))[0]))) >= ((methodLabel->address)))
		 && ((((usqInt)(((self_in_computeMaximumSize->operands))[0]))) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize)))))
			? 7
			: /* begin moveCwRByteSize */ 11);

	case MoveC32R:
		return 7;

	case MoveAwR:
		return (((((self_in_computeMaximumSize->operands))[0]) != null)
		 && (((((self_in_computeMaximumSize->operands))[0]) >= (varBaseAddress()))
		 && (((((self_in_computeMaximumSize->operands))[0]) - (varBaseAddress())) < (0x100000)))
			? (isQuick(self_in_computeMaximumSize, (((self_in_computeMaximumSize->operands))[0]) - (varBaseAddress()))
					? ((((((self_in_computeMaximumSize->operands))[0]) - (varBaseAddress())) == 0)
						 && (((((self_in_computeMaximumSize->operands))[1]) & 7) != RBP)
							? 3
							: 4)
					: 7)
			: ((((self_in_computeMaximumSize->operands))[1]) == RAX
					? 10
					: (((((self_in_computeMaximumSize->operands))[1]) == RBP)
						 || ((((self_in_computeMaximumSize->operands))[1]) == RSP)
							? 12
							: 14)));

	case MoveA32R:
		return ((((self_in_computeMaximumSize->operands))[1]) == RAX
			? 9
			: 13);

	case MoveRAw:
		return (((((self_in_computeMaximumSize->operands))[1]) != null)
		 && (((((self_in_computeMaximumSize->operands))[1]) >= (varBaseAddress()))
		 && (((((self_in_computeMaximumSize->operands))[1]) - (varBaseAddress())) < (0x100000)))
			? (isQuick(self_in_computeMaximumSize, (((self_in_computeMaximumSize->operands))[1]) - (varBaseAddress()))
					? ((((((self_in_computeMaximumSize->operands))[1]) - (varBaseAddress())) == 0)
						 && (((((self_in_computeMaximumSize->operands))[0]) & 7) != RBP)
							? 3
							: 4)
					: 7)
			: ((((self_in_computeMaximumSize->operands))[0]) == RAX
					? 10
					: (((((self_in_computeMaximumSize->operands))[0]) == RBP)
						 || ((((self_in_computeMaximumSize->operands))[0]) == RSP)
							? 13
							: 14)));

	case MoveRA32:
		return ((((self_in_computeMaximumSize->operands))[0]) == RAX
			? 9
			: 13);

	case MoveAbR:
		return (((((self_in_computeMaximumSize->operands))[0]) != null)
		 && (((((self_in_computeMaximumSize->operands))[0]) >= (varBaseAddress()))
		 && (((((self_in_computeMaximumSize->operands))[0]) - (varBaseAddress())) < (0x100000)))
			? (isQuick(self_in_computeMaximumSize, (((self_in_computeMaximumSize->operands))[0]) - (varBaseAddress()))
					? ((((((self_in_computeMaximumSize->operands))[0]) - (varBaseAddress())) == 0)
						 && (((((self_in_computeMaximumSize->operands))[1]) & 7) != RBP)
							? 3
							: 4)
					: 7)
			: ((((self_in_computeMaximumSize->operands))[1]) == RAX
					? 10
					: 14));

	case MoveRAb:
		return (((((self_in_computeMaximumSize->operands))[1]) != null)
		 && (((((self_in_computeMaximumSize->operands))[1]) >= (varBaseAddress()))
		 && (((((self_in_computeMaximumSize->operands))[1]) - (varBaseAddress())) < (0x100000)))
			? (isQuick(self_in_computeMaximumSize, (((self_in_computeMaximumSize->operands))[1]) - (varBaseAddress()))
					? ((((((self_in_computeMaximumSize->operands))[1]) - (varBaseAddress())) == 0)
						 && (((((self_in_computeMaximumSize->operands))[0]) & 7) != RBP)
							? 3
							: 4)
					: 7)
			: ((((self_in_computeMaximumSize->operands))[0]) == RAX
					? 10
					: 14));

	case MoveRMwr:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1]));
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? (((((self_in_computeMaximumSize->operands))[1]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[2]) & 7) != RBP)
			? 3
			: 4)
	: 7)) + ((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP
	? 1
	: 0));

	case MoveRM32r:
		return (((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? (((((self_in_computeMaximumSize->operands))[1]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[2]) & 6) != RSP)
			? 2
			: 3)
	: 6)) + (((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP)
 && ((((self_in_computeMaximumSize->operands))[1]) != 0)
	? 1
	: 0))) + ((((((self_in_computeMaximumSize->operands))[2]) > 7)
 || ((((self_in_computeMaximumSize->operands))[0]) > 7)
	? 1
	: 0));

	case MoveRsM32r:
	case MoveRdM64r:
		return (((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? (((((self_in_computeMaximumSize->operands))[1]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[2]) & 6) != RSP)
			? 4
			: 5)
	: 8)) + (((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP)
 && ((((self_in_computeMaximumSize->operands))[1]) != 0)
	? 1
	: 0))) + ((((((self_in_computeMaximumSize->operands))[2]) > 7)
 || ((((self_in_computeMaximumSize->operands))[0]) > 7)
	? 1
	: 0));

	case MoveMbrR:
	case MoveM8rR:
	case MoveMs8rR:
	case MoveMwrR:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0]));
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? (((((self_in_computeMaximumSize->operands))[0]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[1]) & 7) != RBP)
			? 3
			: 4)
	: 7)) + ((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP
	? 1
	: 0));

	case MoveRMbr:
	case MoveRM8r:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1]));
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? (((((self_in_computeMaximumSize->operands))[1]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[0]) & 7) != RBP)
			? 3
			: 4)
	: 7)) + ((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP
	? 1
	: 0));

	case MoveM16rR:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0]));
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? (((((self_in_computeMaximumSize->operands))[0]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[1]) & 7) != RBP)
			? 4
			: 5)
	: 8)) + ((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP
	? 1
	: 0));

	case MoveRM16r:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1]));
		return (((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? 4
	: 7)) + ((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP
	? 1
	: 0))) + ((((((self_in_computeMaximumSize->operands))[0]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7)
	? 1
	: 0));

	case MoveM32rR:
		return (((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? (((((self_in_computeMaximumSize->operands))[0]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[1]) & 6) != RSP)
			? 2
			: 3)
	: 6)) + (((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP)
 && ((((self_in_computeMaximumSize->operands))[0]) != 0)
	? 1
	: 0))) + ((((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7)
	? 1
	: 0));

	case MoveM32rRs:
	case MoveM64rRd:
		return (((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? (((((self_in_computeMaximumSize->operands))[0]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[1]) & 6) != RSP)
			? 4
			: 5)
	: 8)) + (((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP)
 && ((((self_in_computeMaximumSize->operands))[0]) != 0)
	? 1
	: 0))) + ((((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7)
	? 1
	: 0));

	case MoveXbrRR:
		assert((((self_in_computeMaximumSize->operands))[0]) != RSP);
		return (((((self_in_computeMaximumSize->operands))[1]) & 7) == RBP
			? 5
			: 4);

	case MoveRXbrR:
		assert((((self_in_computeMaximumSize->operands))[1]) != RSP);
		return ((((((self_in_computeMaximumSize->operands))[0]) > 3)
 || (((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7))
	? 4
	: 3)) + ((((((self_in_computeMaximumSize->operands))[2]) & 7) == RBP
	? 1
	: 0));

	case MoveXwrRR:
		assert((((self_in_computeMaximumSize->operands))[0]) != RSP);
		return (((((self_in_computeMaximumSize->operands))[1]) == RBP)
		 || ((((self_in_computeMaximumSize->operands))[1]) == R13)
			? 5
			: 4);

	case MoveRXwrR:
		assert((((self_in_computeMaximumSize->operands))[1]) != RSP);
		return (((((self_in_computeMaximumSize->operands))[2]) == RBP)
		 || ((((self_in_computeMaximumSize->operands))[2]) == R13)
			? 5
			: 4);

	case MoveX32rRR:
		assert((((self_in_computeMaximumSize->operands))[0]) != RSP);
		return ((((((self_in_computeMaximumSize->operands))[1]) == RBP)
 || ((((self_in_computeMaximumSize->operands))[1]) == R13)
	? 7
	: 6)) + ((((((self_in_computeMaximumSize->operands))[0]) > 7)
 || (((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7))
	? 1
	: 0));

	case MoveRX32rR:
		assert((((self_in_computeMaximumSize->operands))[1]) != RSP);
		return ((((((self_in_computeMaximumSize->operands))[2]) == RBP)
 || ((((self_in_computeMaximumSize->operands))[2]) == R13)
	? 4
	: 3)) + ((((((self_in_computeMaximumSize->operands))[0]) > 7)
 || (((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7))
	? 1
	: 0));

	case PopR:
	case PushR:
		return ((((self_in_computeMaximumSize->operands))[0]) < 8
			? 1
			: 2);

	case PushCq:
		return (isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
			? 2
			: (is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
					? 5
					: computeSizeOfPushCw(self_in_computeMaximumSize)));

	case PushCw:
		return computeSizeOfPushCw(self_in_computeMaximumSize);

	case PrefetchAw:
		return (((((self_in_computeMaximumSize->operands))[0]) != null)
		 && (((((self_in_computeMaximumSize->operands))[0]) >= (varBaseAddress()))
		 && (((((self_in_computeMaximumSize->operands))[0]) - (varBaseAddress())) < (0x100000)))
			? 7
			: 0);

	case ZeroExtend32RR:
		return 2 + ((((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[0]) > 7)
	? 1
	: 0));

	case MovePerfCnt64RL:
		
		/* it is easier to calculate the right value by concretizing.  We concretize twice, but so what? */
		return concretizeMovePerfCnt64RL(self_in_computeMaximumSize);

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}


/*	On the x86 the only instructions that shift by the value of a
	register require the shift count to be in %ecx. So we may
	have to use swap instructions to get the count into ecx. */

	/* CogX64Compiler>>#computeShiftRRSize */
static sqInt NoDbgRegParms
computeShiftRRSize(AbstractInstruction * self_in_computeShiftRRSize)
{
    usqInt shiftCountReg;

	shiftCountReg = ((self_in_computeShiftRRSize->operands))[0];
	return (shiftCountReg == RCX
		? 3
		: (shiftCountReg == RAX
				? 7
				: 9));
}

	/* CogX64Compiler>>#computeSizeOfPushCw */
static sqInt NoDbgRegParms
computeSizeOfPushCw(AbstractInstruction * self_in_computeSizeOfPushCw)
{
	return (((addressIsInInstructions(((AbstractInstruction *) (((self_in_computeSizeOfPushCw->operands))[0]))))
	 || ((((AbstractInstruction *) (((self_in_computeSizeOfPushCw->operands))[0]))) == (methodLabel())))
	 || (((((usqInt)(((self_in_computeSizeOfPushCw->operands))[0]))) >= ((methodLabel->address)))
	 && ((((usqInt)(((self_in_computeSizeOfPushCw->operands))[0]))) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize)))))
		? 9
		: /* begin pushCwByteSize */ 12);
}


/*	Will get inlined into concretizeAt: switch. */

	/* CogX64Compiler>>#concretizeArithCqRWithRO:raxOpcode: */
static sqInt NoDbgRegParms
concretizeArithCqRWithROraxOpcode(AbstractInstruction * self_in_concretizeArithCqRWithROraxOpcode, sqInt regOpcode, sqInt raxOpcode)
{
    usqInt reg;
    usqInt value;

	value = ((self_in_concretizeArithCqRWithROraxOpcode->operands))[0];
	reg = ((self_in_concretizeArithCqRWithROraxOpcode->operands))[1];
	((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[0] = (rexRxb(self_in_concretizeArithCqRWithROraxOpcode, 0, 0, reg));
	if (isQuick(self_in_concretizeArithCqRWithROraxOpcode, value)) {
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[1] = 131;
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[2] = (modRMRO(self_in_concretizeArithCqRWithROraxOpcode, ModReg, reg, regOpcode));
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[3] = (value & 0xFF);
		return 4;
	}
	if (is32BitSignedImmediate(self_in_concretizeArithCqRWithROraxOpcode, value)) {
		if (reg == RAX) {
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[1] = raxOpcode;
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[2] = (value & 0xFF);
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[3] = (((value) >> 8) & 0xFF);
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[4] = (((value) >> 16) & 0xFF);
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[5] = (((value) >> 24) & 0xFF);
			return 6;
		}
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[1] = 129;
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[2] = (modRMRO(self_in_concretizeArithCqRWithROraxOpcode, ModReg, reg, regOpcode));
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[3] = (value & 0xFF);
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[4] = (((value) >> 8) & 0xFF);
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[5] = (((value) >> 16) & 0xFF);
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[6] = (((value) >> 24) & 0xFF);
		return 7;
	}
	return concretizeArithCwR(self_in_concretizeArithCqRWithROraxOpcode, (raxOpcode == 61
		? 57
		: raxOpcode - 2));
}

	/* CogX64Compiler>>#concretizeFill32 */
static sqInt NoDbgRegParms
concretizeFill32(AbstractInstruction * self_in_concretizeFill32)
{
    usqIntptr_t word;

	word = ((self_in_concretizeFill32->operands))[0];
	((self_in_concretizeFill32->machineCode))[0] = (word & 0xFF);
	((self_in_concretizeFill32->machineCode))[1] = (((word) >> 8) & 0xFF);
	((self_in_concretizeFill32->machineCode))[2] = (((word) >> 16) & 0xFF);
	((self_in_concretizeFill32->machineCode))[3] = (((word) >> 24) & 0xFF);
	return 4;
}


/*	Generate code for
	0x0: 50					pushq	%rax
	0x1: 52					pushq	%rdx
	0x2: 0f 31				rdtsc
	0x4: 48 c1 e2 20		shlq	$0x20, %rdx
	0x8: 48 09 d0			orq		%rdx, %rax
	0xb: 48 89 f8			movq	%rdi, %rax
	0xe: 5a					popq	%rdx
	0xf: 58					popq	%rax
	et al */

	/* CogX64Compiler>>#concretizeMovePerfCnt64RL */
static sqInt NoDbgRegParms
concretizeMovePerfCnt64RL(AbstractInstruction * self_in_concretizeMovePerfCnt64RL)
{
    usqInt liveRegisterMask;
    sqInt offset;
    usqInt reg;

	reg = ((self_in_concretizeMovePerfCnt64RL->operands))[0];
	liveRegisterMask = ((self_in_concretizeMovePerfCnt64RL->operands))[1];
	offset = 0;
	if (((liveRegisterMask & ((1U << RAX))) != 0)) {
		((self_in_concretizeMovePerfCnt64RL->machineCode))[0] = 80;
		offset += 1;
	}
	if (((liveRegisterMask & ((1U << RDX))) != 0)) {
		((self_in_concretizeMovePerfCnt64RL->machineCode))[offset] = 82;
		offset += 1;
	}
	assert(!((reg == RDX)));
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset] = 15;
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 1] = 49;
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 2] = (rexRxb(self_in_concretizeMovePerfCnt64RL, 0, 0, RDX));
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 3] = 193;
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 4] = (modRMRO(self_in_concretizeMovePerfCnt64RL, ModReg, RDX, 4));
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 5] = 32;
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 6] = (rexRxb(self_in_concretizeMovePerfCnt64RL, RDX, 0, RAX));
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 7] = 11;
	((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 8] = (modRMRO(self_in_concretizeMovePerfCnt64RL, ModReg, RAX, RDX));
	offset += 9;
	if (reg != RAX) {
		((self_in_concretizeMovePerfCnt64RL->machineCode))[offset] = (rexRxb(self_in_concretizeMovePerfCnt64RL, RAX, 0, reg));
		((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 1] = 137;
		((self_in_concretizeMovePerfCnt64RL->machineCode))[offset + 2] = (modRMRO(self_in_concretizeMovePerfCnt64RL, ModReg, reg, RAX));
		offset += 3;
	}
	if (((liveRegisterMask & ((1U << RDX))) != 0)) {
		((self_in_concretizeMovePerfCnt64RL->machineCode))[offset] = 90;
		offset += 1;
	}
	if (((liveRegisterMask & ((1U << RAX))) != 0)) {
		((self_in_concretizeMovePerfCnt64RL->machineCode))[offset] = 88;
		offset += 1;
	}
	return offset;
}

	/* CogX64Compiler>>#concretizeMoveRX32rR */
static sqInt NoDbgRegParms
concretizeMoveRX32rR(AbstractInstruction * self_in_concretizeMoveRX32rR)
{
    usqInt base;
    usqInt index;
    sqInt offset;
    usqInt src;

	src = ((self_in_concretizeMoveRX32rR->operands))[0];
	index = ((self_in_concretizeMoveRX32rR->operands))[1];
	base = ((self_in_concretizeMoveRX32rR->operands))[2];
	if ((index > 7)
	 || ((base > 7)
	 || (src > 7))) {
		((self_in_concretizeMoveRX32rR->machineCode))[0] = (rexwrxb(self_in_concretizeMoveRX32rR, 0, src, index, base));
		offset = 1;
	}
	else {
		offset = 0;
	}
	if ((base & 7) != RBP) {
		((self_in_concretizeMoveRX32rR->machineCode))[offset] = 137;
		((self_in_concretizeMoveRX32rR->machineCode))[offset + 1] = (modRMRO(self_in_concretizeMoveRX32rR, ModRegInd, 4, src));
		((self_in_concretizeMoveRX32rR->machineCode))[offset + 2] = (sib(self_in_concretizeMoveRX32rR, SIB4, index, base));
		return offset + 3;
	}
	((self_in_concretizeMoveRX32rR->machineCode))[offset] = 137;
	((self_in_concretizeMoveRX32rR->machineCode))[offset + 1] = (modRMRO(self_in_concretizeMoveRX32rR, ModRegRegDisp8, 4, src));
	((self_in_concretizeMoveRX32rR->machineCode))[offset + 2] = (sib(self_in_concretizeMoveRX32rR, SIB4, index, base));
	((self_in_concretizeMoveRX32rR->machineCode))[offset + 3] = 0;
	return offset + 4;
}


/*	MoveX32rRR is expected to zero-extend, so explicitly zero the destination. */

	/* CogX64Compiler>>#concretizeMoveX32rRR */
static sqInt NoDbgRegParms
concretizeMoveX32rRR(AbstractInstruction * self_in_concretizeMoveX32rRR)
{
    usqInt base;
    usqInt dest;
    usqInt index;
    sqInt offset;

	index = ((self_in_concretizeMoveX32rRR->operands))[0];
	base = ((self_in_concretizeMoveX32rRR->operands))[1];
	dest = ((self_in_concretizeMoveX32rRR->operands))[2];
	((self_in_concretizeMoveX32rRR->machineCode))[0] = (rexRxb(self_in_concretizeMoveX32rRR, dest, 0, dest));
	((self_in_concretizeMoveX32rRR->machineCode))[1] = 49;
	((self_in_concretizeMoveX32rRR->machineCode))[2] = (modRMRO(self_in_concretizeMoveX32rRR, ModReg, dest, dest));
	if ((index > 7)
	 || ((base > 7)
	 || (dest > 7))) {
		((self_in_concretizeMoveX32rRR->machineCode))[3] = (rexwrxb(self_in_concretizeMoveX32rRR, 0, dest, index, base));
		offset = 1;
	}
	else {
		offset = 0;
	}
	if ((base & 7) != RBP) {
		((self_in_concretizeMoveX32rRR->machineCode))[offset + 3] = 139;
		((self_in_concretizeMoveX32rRR->machineCode))[offset + 4] = (modRMRO(self_in_concretizeMoveX32rRR, ModRegInd, 4, dest));
		((self_in_concretizeMoveX32rRR->machineCode))[offset + 5] = (sib(self_in_concretizeMoveX32rRR, SIB4, index, base));
		return offset + 6;
	}
	((self_in_concretizeMoveX32rRR->machineCode))[offset + 3] = 139;
	((self_in_concretizeMoveX32rRR->machineCode))[offset + 4] = (modRMRO(self_in_concretizeMoveX32rRR, ModRegRegDisp8, 4, dest));
	((self_in_concretizeMoveX32rRR->machineCode))[offset + 5] = (sib(self_in_concretizeMoveX32rRR, SIB4, index, base));
	((self_in_concretizeMoveX32rRR->machineCode))[offset + 6] = 0;
	return offset + 7;
}

	/* CogX64Compiler>>#concretizeOpRR: */
static sqInt NoDbgRegParms
concretizeOpRR(AbstractInstruction * self_in_concretizeOpRR, sqInt x64opcode)
{
    usqInt regLHS;
    usqInt regRHS;

	regLHS = ((self_in_concretizeOpRR->operands))[0];
	regRHS = ((self_in_concretizeOpRR->operands))[1];
	((self_in_concretizeOpRR->machineCode))[0] = (rexRxb(self_in_concretizeOpRR, regRHS, 0, regLHS));
	((self_in_concretizeOpRR->machineCode))[1] = x64opcode;
	((self_in_concretizeOpRR->machineCode))[2] = (modRMRO(self_in_concretizeOpRR, ModReg, regLHS, regRHS));
	return 3;
}


/*	We support only prefetches for addresses that are variables relative to
	VarBase 
 */

	/* CogX64Compiler>>#concretizePrefetchAw */
static sqInt NoDbgRegParms
concretizePrefetchAw(AbstractInstruction * self_in_concretizePrefetchAw)
{
    sqInt offset;
    usqInt operand;

	operand = ((self_in_concretizePrefetchAw->operands))[0];
	if (!((operand != null)
		 && ((operand >= (varBaseAddress()))
		 && ((operand - (varBaseAddress())) < (0x100000))))) {
		return 0;
	}
	offset = operand - (varBaseAddress());
	((self_in_concretizePrefetchAw->machineCode))[0] = 15;
	((self_in_concretizePrefetchAw->machineCode))[1] = 24;
	((self_in_concretizePrefetchAw->machineCode))[2] = 147;
	((self_in_concretizePrefetchAw->machineCode))[3] = (offset & 0xFF);
	((self_in_concretizePrefetchAw->machineCode))[4] = ((((usqInt)(offset)) >> 16) & 0xFF);
	((self_in_concretizePrefetchAw->machineCode))[5] = ((((usqInt)(offset)) >> 8) & 0xFF);
	((self_in_concretizePrefetchAw->machineCode))[6] = (((usqInt)(offset)) >> 24);
	return 7;
}


/*	CmpRR/MoveRR RHS LHS computes LHS - RHS, i.e. apparently reversed. You
	have to think subtract. */

	/* CogX64Compiler>>#concretizeReverseOpRR: */
static sqInt NoDbgRegParms
concretizeReverseOpRR(AbstractInstruction * self_in_concretizeReverseOpRR, sqInt x64opcode)
{
    usqInt regLHS;
    usqInt regRHS;

	regRHS = ((self_in_concretizeReverseOpRR->operands))[0];
	regLHS = ((self_in_concretizeReverseOpRR->operands))[1];
	((self_in_concretizeReverseOpRR->machineCode))[0] = (rexRxb(self_in_concretizeReverseOpRR, regRHS, 0, regLHS));
	((self_in_concretizeReverseOpRR->machineCode))[1] = x64opcode;
	((self_in_concretizeReverseOpRR->machineCode))[2] = (modRMRO(self_in_concretizeReverseOpRR, ModReg, regLHS, regRHS));
	return 3;
}

	/* CogX64Compiler>>#concretizeSet: */
static sqInt NoDbgRegParms
concretizeSet(AbstractInstruction * self_in_concretizeSet, sqInt conditionCode)
{
    usqInt reg;

	reg = ((self_in_concretizeSet->operands))[0];
	((self_in_concretizeSet->machineCode))[0] = ((reg >= R8
	? 68
	: 64));
	((self_in_concretizeSet->machineCode))[1] = 15;
	((self_in_concretizeSet->machineCode))[2] = (144 + conditionCode);
	((self_in_concretizeSet->machineCode))[3] = (modRMRO(self_in_concretizeSet, ModReg, reg & 7, 0));
	return 4;
}

	/* CogX64Compiler>>#concretizeXCHGRR */
static sqInt NoDbgRegParms
concretizeXCHGRR(AbstractInstruction * self_in_concretizeXCHGRR)
{
    usqInt r1;
    usqInt r2;

	r1 = ((self_in_concretizeXCHGRR->operands))[0];
	r2 = ((self_in_concretizeXCHGRR->operands))[1];
	if (r2 == RAX) {
		r2 = r1;
		r1 = RAX;
	}
	if (r1 == RAX) {
		((self_in_concretizeXCHGRR->machineCode))[0] = (rexRxb(self_in_concretizeXCHGRR, 0, 0, r2));
		((self_in_concretizeXCHGRR->machineCode))[1] = (144 + (r2 % 8));
		return 2;
	}
	((self_in_concretizeXCHGRR->machineCode))[0] = (rexRxb(self_in_concretizeXCHGRR, r1, 0, r2));
	((self_in_concretizeXCHGRR->machineCode))[1] = 135;
	((self_in_concretizeXCHGRR->machineCode))[2] = (modRMRO(self_in_concretizeXCHGRR, ModReg, r2, r1));
	return 3;
}


/*	Do a throw-away compilation to get at the cpuid info and initialize
	cpuidWord1 N.B. All of MSVC, gcc & clang have intrinsics for this, so if
	you have the energy
	by all means reimplement as an #if _MSC_VER...#elif __GNUC__ #else ...
	saga. 
 */

	/* CogX64Compiler>>#detectFeatures */
static void NoDbgRegParms
detectFeatures(AbstractInstruction * self_in_detectFeatures)
{
    usqIntptr_t (*cpuid)(void);
    sqInt fixupSize;
    sqInt opcodeSize;
    usqInt startAddress;

	startAddress = methodZoneBase();
	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 10;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	cpuid = ((usqIntptr_t (*)(void)) startAddress);
	/* begin PushR: */
	genoperand(PushR, RDX);
	/* begin PushR: */
	genoperand(PushR, RCX);
	/* begin PushR: */
	genoperand(PushR, RBX);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0x80000001U, RAX);
	gen(CPUID);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, RCX, RAX);
	/* begin PopR: */
	genoperand(PopR, RBX);
	/* begin PopR: */
	genoperand(PopR, RCX);
	/* begin PopR: */
	genoperand(PopR, RDX);
	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	/* begin resetMethodZoneBase: */
	methodZoneBase = startAddress;
	/* begin ensureExecutableCodeZone */
	setCpuidWord1(self_in_detectFeatures, cpuid());
}


/*	Attempt to generate concrete machine code for the instruction at address.
	This is the inner dispatch of concretizeAt: actualAddress which exists
	only to get around the branch size limits in the SqueakV3 (blue book
	derived) bytecode set. */

	/* CogX64Compiler>>#dispatchConcretize */
static sqInt NoDbgRegParms
dispatchConcretize(AbstractInstruction * self_in_dispatchConcretize)
{
    usqInt addressOperand;
    usqInt addressOperand1;
    usqInt addressOperand2;
    usqInt addressOperand3;
    usqInt addressOperand4;
    usqInt addressOperand5;
    usqInt base;
    usqInt base1;
    usqInt base2;
    usqInt base3;
    usqInt baseReg;
    usqInt baseReg1;
    AbstractInstruction *dependentChain;
    usqInt dest;
    usqInt dest1;
    usqInt dest2;
    usqInt destReg;
    usqInt destReg1;
    usqInt destReg10;
    usqInt destReg11;
    usqInt destReg12;
    usqInt destReg13;
    usqInt destReg14;
    usqInt destReg15;
    usqInt destReg16;
    usqInt destReg17;
    usqInt destReg18;
    usqInt destReg19;
    usqInt destReg2;
    usqInt destReg20;
    usqInt destReg21;
    usqInt destReg22;
    usqInt destReg23;
    usqInt destReg24;
    usqInt destReg25;
    usqInt destReg26;
    usqInt destReg27;
    usqInt destReg28;
    usqInt destReg29;
    usqInt destReg3;
    usqInt destReg30;
    usqInt destReg31;
    usqInt destReg32;
    usqInt destReg4;
    usqInt destReg5;
    usqInt destReg6;
    usqInt destReg7;
    usqInt destReg8;
    usqInt destReg9;
    usqInt distance;
    usqInt distance1;
    usqInt distance2;
    usqInt distance3;
    usqInt distance4;
    sqInt i;
    usqInt index;
    usqInt index1;
    usqInt index2;
    usqInt index3;
    AbstractInstruction *jumpTarget;
    AbstractInstruction *jumpTarget1;
    AbstractInstruction *jumpTarget10;
    AbstractInstruction *jumpTarget11;
    AbstractInstruction *jumpTarget110;
    AbstractInstruction *jumpTarget111;
    AbstractInstruction *jumpTarget1110;
    AbstractInstruction *jumpTarget1111;
    AbstractInstruction *jumpTarget1112;
    AbstractInstruction *jumpTarget1113;
    AbstractInstruction *jumpTarget1114;
    AbstractInstruction *jumpTarget1115;
    AbstractInstruction *jumpTarget1116;
    AbstractInstruction *jumpTarget112;
    AbstractInstruction *jumpTarget113;
    AbstractInstruction *jumpTarget114;
    AbstractInstruction *jumpTarget115;
    AbstractInstruction *jumpTarget116;
    AbstractInstruction *jumpTarget117;
    AbstractInstruction *jumpTarget118;
    AbstractInstruction *jumpTarget119;
    AbstractInstruction *jumpTarget12;
    AbstractInstruction *jumpTarget120;
    AbstractInstruction *jumpTarget121;
    AbstractInstruction *jumpTarget122;
    AbstractInstruction *jumpTarget123;
    AbstractInstruction *jumpTarget124;
    AbstractInstruction *jumpTarget125;
    AbstractInstruction *jumpTarget13;
    AbstractInstruction *jumpTarget14;
    AbstractInstruction *jumpTarget15;
    AbstractInstruction *jumpTarget16;
    AbstractInstruction *jumpTarget17;
    AbstractInstruction *jumpTarget18;
    AbstractInstruction *jumpTarget19;
    AbstractInstruction *jumpTarget2;
    AbstractInstruction *jumpTarget20;
    AbstractInstruction *jumpTarget21;
    AbstractInstruction *jumpTarget210;
    AbstractInstruction *jumpTarget211;
    AbstractInstruction *jumpTarget212;
    AbstractInstruction *jumpTarget213;
    AbstractInstruction *jumpTarget214;
    AbstractInstruction *jumpTarget215;
    AbstractInstruction *jumpTarget216;
    AbstractInstruction *jumpTarget22;
    AbstractInstruction *jumpTarget23;
    AbstractInstruction *jumpTarget24;
    AbstractInstruction *jumpTarget25;
    AbstractInstruction *jumpTarget26;
    AbstractInstruction *jumpTarget27;
    AbstractInstruction *jumpTarget28;
    AbstractInstruction *jumpTarget29;
    AbstractInstruction *jumpTarget3;
    AbstractInstruction *jumpTarget30;
    AbstractInstruction *jumpTarget31;
    AbstractInstruction *jumpTarget32;
    AbstractInstruction *jumpTarget33;
    AbstractInstruction *jumpTarget34;
    AbstractInstruction *jumpTarget35;
    AbstractInstruction *jumpTarget4;
    AbstractInstruction *jumpTarget5;
    AbstractInstruction *jumpTarget6;
    AbstractInstruction *jumpTarget7;
    AbstractInstruction *jumpTarget8;
    AbstractInstruction *jumpTarget9;
    usqInt maskReg;
    int offset;
    int offset1;
    usqInt offset10;
    usqInt offset11;
    usqInt offset110;
    usqInt offset111;
    sqInt offset112;
    sqInt offset113;
    sqInt offset114;
    sqInt offset115;
    sqInt offset116;
    sqInt offset117;
    sqInt offset118;
    sqInt offset119;
    usqInt offset12;
    sqInt offset120;
    sqInt offset121;
    sqInt offset122;
    sqInt offset123;
    sqInt offset124;
    sqInt offset125;
    sqInt offset126;
    sqInt offset127;
    usqInt offset13;
    usqInt offset14;
    usqInt offset15;
    usqInt offset16;
    usqInt offset17;
    usqInt offset18;
    usqInt offset19;
    int offset2;
    sqInt offset20;
    usqInt offset21;
    usqInt offset22;
    usqInt offset23;
    usqInt offset24;
    sqInt offset25;
    sqInt offset26;
    sqInt offset27;
    sqInt offset28;
    sqInt offset29;
    usqInt offset3;
    sqInt offset30;
    sqInt offset31;
    sqInt offset32;
    sqInt offset33;
    sqInt offset34;
    sqInt offset35;
    sqInt offset36;
    sqInt offset37;
    sqInt offset38;
    sqInt offset39;
    usqInt offset4;
    sqInt offset40;
    sqInt offset41;
    sqInt offset42;
    sqInt offset43;
    sqInt offset44;
    sqInt offset5;
    sqInt offset6;
    sqInt offset7;
    sqInt offset8;
    sqInt offset9;
    usqInt operand;
    usqInt operand1;
    usqInt reg;
    usqInt reg1;
    usqInt reg10;
    usqInt reg11;
    usqInt reg12;
    usqInt reg13;
    usqInt reg14;
    usqInt reg15;
    usqInt reg16;
    usqInt reg17;
    usqInt reg18;
    usqInt reg19;
    usqInt reg2;
    usqInt reg20;
    usqInt reg21;
    usqInt reg22;
    usqInt reg3;
    usqInt reg4;
    usqInt reg5;
    usqInt reg6;
    usqInt reg7;
    usqInt reg8;
    usqInt regLHS;
    usqInt regLHS1;
    usqInt regLHS10;
    usqInt regLHS11;
    usqInt regLHS2;
    usqInt regLHS3;
    usqInt regLHS4;
    usqInt regLHS5;
    usqInt regLHS6;
    usqInt regLHS7;
    usqInt regLHS8;
    usqInt regLHS9;
    usqInt regRHS;
    usqInt regRHS1;
    usqInt regRHS10;
    usqInt regRHS11;
    usqInt regRHS2;
    usqInt regRHS3;
    usqInt regRHS4;
    usqInt regRHS5;
    usqInt regRHS6;
    usqInt regRHS7;
    usqInt regRHS8;
    usqInt regRHS9;
    sqInt regToShift;
    sqInt regToShift1;
    usqInt reg9;
    usqInt save0;
    usqInt save01;
    usqInt save1;
    usqInt save11;
    usqInt save12;
    usqInt save13;
    sqInt savedSize;
    sqInt savedSize1;
    sqInt savedSize2;
    sqInt savedSize3;
    usqInt shiftCountReg;
    usqInt shiftCountReg1;
    sqInt skip;
    sqInt skip1;
    sqInt skip10;
    sqInt skip11;
    sqInt skip12;
    sqInt skip13;
    sqInt skip14;
    sqInt skip15;
    sqInt skip16;
    sqInt skip17;
    sqInt skip18;
    sqInt skip19;
    sqInt skip2;
    sqInt skip20;
    sqInt skip21;
    sqInt skip22;
    sqInt skip23;
    sqInt skip24;
    sqInt skip25;
    sqInt skip26;
    sqInt skip27;
    sqInt skip28;
    sqInt skip3;
    sqInt skip4;
    sqInt skip5;
    sqInt skip6;
    sqInt skip7;
    sqInt skip8;
    sqInt skip9;
    usqInt src;
    usqInt src1;
    usqInt srcReg;
    usqInt srcReg1;
    usqInt srcReg10;
    usqInt srcReg11;
    usqInt srcReg12;
    usqInt srcReg13;
    usqInt srcReg14;
    usqInt srcReg15;
    usqInt srcReg16;
    usqInt srcReg17;
    usqInt srcReg18;
    usqInt srcReg19;
    usqInt srcReg2;
    usqInt srcReg20;
    usqInt srcReg21;
    usqInt srcReg22;
    usqInt srcReg23;
    usqInt srcReg24;
    usqInt srcReg25;
    usqInt srcReg26;
    usqInt srcReg27;
    usqInt srcReg28;
    usqInt srcReg29;
    usqInt srcReg3;
    usqInt srcReg30;
    usqInt srcReg31;
    usqInt srcReg32;
    usqInt srcReg4;
    usqInt srcReg5;
    usqInt srcReg6;
    usqInt srcReg7;
    usqInt srcReg8;
    usqInt srcReg9;
    usqInt value;
    usqInt value1;
    usqInt value11;
    usqInt value2;
    usqInt value3;
    usqInt value4;
    usqInt value5;
    usqInt value6;
    usqIntptr_t word;

	if (((self_in_dispatchConcretize->opcode)) >= CPUID) {
		return dispatchConcretizeProcessorSpecific(self_in_dispatchConcretize);
	}
	switch ((self_in_dispatchConcretize->opcode)) {
	case Label:
		/* begin concretizeLabel */
		dependentChain = (self_in_dispatchConcretize->dependent);
		while (!(dependentChain == null)) {
			/* begin updateLabel: */
			assert((((dependentChain->opcode)) == MoveCwR)
			 || (((dependentChain->opcode)) == PushCw));
			((dependentChain->operands))[0] = (((self_in_dispatchConcretize->address)) + (((self_in_dispatchConcretize->operands))[1]));
			dependentChain = (dependentChain->dependent);
		}
		return 0;

	case AlignmentNops:
		/* begin concretizeAlignmentNops */
		for (i = 0; i < ((self_in_dispatchConcretize->machineCodeSize)); i += 1) {
			((self_in_dispatchConcretize->machineCode))[i] = 144;
		}
		return ((usqInt) ((self_in_dispatchConcretize->machineCodeSize)));

	case Fill32:
		/* begin concretizeFill32 */
		word = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = (word & 0xFF);
		((self_in_dispatchConcretize->machineCode))[1] = (((word) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = (((word) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = (((word) >> 24) & 0xFF);
		return 4;

	case Nop:
		/* begin concretizeNop */
		((self_in_dispatchConcretize->machineCode))[0] = 144;
		return 1;

	case Call:
		/* begin concretizeCall */
		assert((((self_in_dispatchConcretize->operands))[0]) != 0);
		offset = (((int) (((self_in_dispatchConcretize->operands))[0]))) - (((int) (((self_in_dispatchConcretize->address)) + 5)));
		((self_in_dispatchConcretize->machineCode))[0] = 232;
		((self_in_dispatchConcretize->machineCode))[1] = (offset & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((((usqInt)(offset)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset)) >> 24) & 0xFF);
		return 5;

	case CallR:
		/* begin concretizeCallR */
		reg = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg));
		((self_in_dispatchConcretize->machineCode))[1] = 0xFF;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg, 2));
		return 3;

	case CallFull:
		/* begin concretizeCallFull */
		operand = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = 72;
		((self_in_dispatchConcretize->machineCode))[1] = 184;
		((self_in_dispatchConcretize->machineCode))[2] = (operand & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = (((operand) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = (((operand) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((operand) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((operand) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((operand) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = (((operand) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = (((operand) >> 56) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[10] = 0xFF;
		((self_in_dispatchConcretize->machineCode))[11] = (modRMRO(self_in_dispatchConcretize, ModReg, RAX, 2));
		return 12;

	case JumpR:
		/* begin concretizeJumpR */
		reg1 = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg1));
		((self_in_dispatchConcretize->machineCode))[1] = 0xFF;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg1, 4));
		return 3;

	case JumpFull:
		/* begin concretizeJumpFull */
		operand1 = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = 72;
		((self_in_dispatchConcretize->machineCode))[1] = 184;
		((self_in_dispatchConcretize->machineCode))[2] = (operand1 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = (((operand1) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = (((operand1) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((operand1) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((operand1) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((operand1) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = (((operand1) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = (((operand1) >> 56) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[10] = 0xFF;
		((self_in_dispatchConcretize->machineCode))[11] = (modRMRO(self_in_dispatchConcretize, ModReg, RAX, 4));
		return 12;

	case JumpLong:
		/* begin concretizeJumpLong */
		jumpTarget = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		if ((addressIsInInstructions(jumpTarget))
		 || (jumpTarget == (methodLabel()))) {
			jumpTarget = ((AbstractInstruction *) ((jumpTarget->address)));
		}
		assert(jumpTarget != 0);
		offset1 = (((int) jumpTarget)) - (((int) (((self_in_dispatchConcretize->address)) + 5)));
		((self_in_dispatchConcretize->machineCode))[0] = 233;
		((self_in_dispatchConcretize->machineCode))[1] = (offset1 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((((usqInt)(offset1)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset1)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset1)) >> 24) & 0xFF);
		return 5;

	case JumpLongZero:
	case JumpZero:
	case JumpFPEqual:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget12 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget12);
		if ((addressIsInInstructions(jumpTarget12))
		 || (jumpTarget12 == (methodLabel()))) {
			jumpTarget12 = ((AbstractInstruction *) ((jumpTarget12->address)));
		}
		assert(jumpTarget12 != 0);
		jumpTarget3 = jumpTarget12;
		offset29 = (((sqLong) jumpTarget3)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset29)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (116);
			((self_in_dispatchConcretize->machineCode))[1] = (offset29 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget11 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget11);
		if ((addressIsInInstructions(jumpTarget11))
		 || (jumpTarget11 == (methodLabel()))) {
			jumpTarget11 = ((AbstractInstruction *) ((jumpTarget11->address)));
		}
		assert(jumpTarget11 != 0);
		jumpTarget2 = jumpTarget11;
		offset112 = (((sqLong) jumpTarget2)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (132);
		((self_in_dispatchConcretize->machineCode))[2] = (offset112 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset112)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset112)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset112)) >> 24) & 0xFF);
		return 6;

	case JumpLongNonZero:
	case JumpNonZero:
	case JumpFPNotEqual:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget13 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget13);
		if ((addressIsInInstructions(jumpTarget13))
		 || (jumpTarget13 == (methodLabel()))) {
			jumpTarget13 = ((AbstractInstruction *) ((jumpTarget13->address)));
		}
		assert(jumpTarget13 != 0);
		jumpTarget4 = jumpTarget13;
		offset30 = (((sqLong) jumpTarget4)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset30)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (117);
			((self_in_dispatchConcretize->machineCode))[1] = (offset30 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget111 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget111);
		if ((addressIsInInstructions(jumpTarget111))
		 || (jumpTarget111 == (methodLabel()))) {
			jumpTarget111 = ((AbstractInstruction *) ((jumpTarget111->address)));
		}
		assert(jumpTarget111 != 0);
		jumpTarget21 = jumpTarget111;
		offset113 = (((sqLong) jumpTarget21)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (133);
		((self_in_dispatchConcretize->machineCode))[2] = (offset113 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset113)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset113)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset113)) >> 24) & 0xFF);
		return 6;

	case Jump:
		/* begin concretizeJump */
		jumpTarget1 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1);
		if ((addressIsInInstructions(jumpTarget1))
		 || (jumpTarget1 == (methodLabel()))) {
			jumpTarget1 = ((AbstractInstruction *) ((jumpTarget1->address)));
		}
		assert(jumpTarget1 != 0);
		offset2 = (((int) jumpTarget1)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset2)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = 235;
			((self_in_dispatchConcretize->machineCode))[1] = (offset2 & 0xFF);
			return 2;
		}
		offset2 = (((int) jumpTarget1)) - (((int) (((self_in_dispatchConcretize->address)) + 5)));
		((self_in_dispatchConcretize->machineCode))[0] = 233;
		((self_in_dispatchConcretize->machineCode))[1] = (offset2 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((((usqInt)(offset2)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset2)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset2)) >> 24) & 0xFF);
		return 5;

	case JumpNegative:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget14 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget14);
		if ((addressIsInInstructions(jumpTarget14))
		 || (jumpTarget14 == (methodLabel()))) {
			jumpTarget14 = ((AbstractInstruction *) ((jumpTarget14->address)));
		}
		assert(jumpTarget14 != 0);
		jumpTarget5 = jumpTarget14;
		offset31 = (((sqLong) jumpTarget5)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset31)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (120);
			((self_in_dispatchConcretize->machineCode))[1] = (offset31 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget112 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget112);
		if ((addressIsInInstructions(jumpTarget112))
		 || (jumpTarget112 == (methodLabel()))) {
			jumpTarget112 = ((AbstractInstruction *) ((jumpTarget112->address)));
		}
		assert(jumpTarget112 != 0);
		jumpTarget22 = jumpTarget112;
		offset114 = (((sqLong) jumpTarget22)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (136);
		((self_in_dispatchConcretize->machineCode))[2] = (offset114 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset114)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset114)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset114)) >> 24) & 0xFF);
		return 6;

	case JumpNonNegative:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget15 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget15);
		if ((addressIsInInstructions(jumpTarget15))
		 || (jumpTarget15 == (methodLabel()))) {
			jumpTarget15 = ((AbstractInstruction *) ((jumpTarget15->address)));
		}
		assert(jumpTarget15 != 0);
		jumpTarget6 = jumpTarget15;
		offset32 = (((sqLong) jumpTarget6)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset32)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (121);
			((self_in_dispatchConcretize->machineCode))[1] = (offset32 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget113 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget113);
		if ((addressIsInInstructions(jumpTarget113))
		 || (jumpTarget113 == (methodLabel()))) {
			jumpTarget113 = ((AbstractInstruction *) ((jumpTarget113->address)));
		}
		assert(jumpTarget113 != 0);
		jumpTarget23 = jumpTarget113;
		offset115 = (((sqLong) jumpTarget23)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (137);
		((self_in_dispatchConcretize->machineCode))[2] = (offset115 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset115)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset115)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset115)) >> 24) & 0xFF);
		return 6;

	case JumpOverflow:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget16 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget16);
		if ((addressIsInInstructions(jumpTarget16))
		 || (jumpTarget16 == (methodLabel()))) {
			jumpTarget16 = ((AbstractInstruction *) ((jumpTarget16->address)));
		}
		assert(jumpTarget16 != 0);
		jumpTarget7 = jumpTarget16;
		offset33 = (((sqLong) jumpTarget7)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset33)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112);
			((self_in_dispatchConcretize->machineCode))[1] = (offset33 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget114 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget114);
		if ((addressIsInInstructions(jumpTarget114))
		 || (jumpTarget114 == (methodLabel()))) {
			jumpTarget114 = ((AbstractInstruction *) ((jumpTarget114->address)));
		}
		assert(jumpTarget114 != 0);
		jumpTarget24 = jumpTarget114;
		offset116 = (((sqLong) jumpTarget24)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128);
		((self_in_dispatchConcretize->machineCode))[2] = (offset116 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset116)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset116)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset116)) >> 24) & 0xFF);
		return 6;

	case JumpNoOverflow:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget17 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget17);
		if ((addressIsInInstructions(jumpTarget17))
		 || (jumpTarget17 == (methodLabel()))) {
			jumpTarget17 = ((AbstractInstruction *) ((jumpTarget17->address)));
		}
		assert(jumpTarget17 != 0);
		jumpTarget8 = jumpTarget17;
		offset34 = (((sqLong) jumpTarget8)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset34)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (113);
			((self_in_dispatchConcretize->machineCode))[1] = (offset34 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget115 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget115);
		if ((addressIsInInstructions(jumpTarget115))
		 || (jumpTarget115 == (methodLabel()))) {
			jumpTarget115 = ((AbstractInstruction *) ((jumpTarget115->address)));
		}
		assert(jumpTarget115 != 0);
		jumpTarget25 = jumpTarget115;
		offset117 = (((sqLong) jumpTarget25)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (129);
		((self_in_dispatchConcretize->machineCode))[2] = (offset117 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset117)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset117)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset117)) >> 24) & 0xFF);
		return 6;

	case JumpCarry:
	case JumpBelow:
	case JumpFPLess:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget18 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget18);
		if ((addressIsInInstructions(jumpTarget18))
		 || (jumpTarget18 == (methodLabel()))) {
			jumpTarget18 = ((AbstractInstruction *) ((jumpTarget18->address)));
		}
		assert(jumpTarget18 != 0);
		jumpTarget9 = jumpTarget18;
		offset35 = (((sqLong) jumpTarget9)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset35)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (114);
			((self_in_dispatchConcretize->machineCode))[1] = (offset35 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget116 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget116);
		if ((addressIsInInstructions(jumpTarget116))
		 || (jumpTarget116 == (methodLabel()))) {
			jumpTarget116 = ((AbstractInstruction *) ((jumpTarget116->address)));
		}
		assert(jumpTarget116 != 0);
		jumpTarget26 = jumpTarget116;
		offset118 = (((sqLong) jumpTarget26)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (130);
		((self_in_dispatchConcretize->machineCode))[2] = (offset118 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset118)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset118)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset118)) >> 24) & 0xFF);
		return 6;

	case JumpNoCarry:
	case JumpAboveOrEqual:
	case JumpFPGreaterOrEqual:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget19 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget19);
		if ((addressIsInInstructions(jumpTarget19))
		 || (jumpTarget19 == (methodLabel()))) {
			jumpTarget19 = ((AbstractInstruction *) ((jumpTarget19->address)));
		}
		assert(jumpTarget19 != 0);
		jumpTarget10 = jumpTarget19;
		offset36 = (((sqLong) jumpTarget10)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset36)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (115);
			((self_in_dispatchConcretize->machineCode))[1] = (offset36 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget117 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget117);
		if ((addressIsInInstructions(jumpTarget117))
		 || (jumpTarget117 == (methodLabel()))) {
			jumpTarget117 = ((AbstractInstruction *) ((jumpTarget117->address)));
		}
		assert(jumpTarget117 != 0);
		jumpTarget27 = jumpTarget117;
		offset119 = (((sqLong) jumpTarget27)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (131);
		((self_in_dispatchConcretize->machineCode))[2] = (offset119 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset119)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset119)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset119)) >> 24) & 0xFF);
		return 6;

	case JumpLess:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget110 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget110);
		if ((addressIsInInstructions(jumpTarget110))
		 || (jumpTarget110 == (methodLabel()))) {
			jumpTarget110 = ((AbstractInstruction *) ((jumpTarget110->address)));
		}
		assert(jumpTarget110 != 0);
		jumpTarget20 = jumpTarget110;
		offset37 = (((sqLong) jumpTarget20)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset37)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (0x7C);
			((self_in_dispatchConcretize->machineCode))[1] = (offset37 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget118 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget118);
		if ((addressIsInInstructions(jumpTarget118))
		 || (jumpTarget118 == (methodLabel()))) {
			jumpTarget118 = ((AbstractInstruction *) ((jumpTarget118->address)));
		}
		assert(jumpTarget118 != 0);
		jumpTarget28 = jumpTarget118;
		offset120 = (((sqLong) jumpTarget28)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (140);
		((self_in_dispatchConcretize->machineCode))[2] = (offset120 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset120)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset120)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset120)) >> 24) & 0xFF);
		return 6;

	case JumpGreaterOrEqual:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget119 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget119);
		if ((addressIsInInstructions(jumpTarget119))
		 || (jumpTarget119 == (methodLabel()))) {
			jumpTarget119 = ((AbstractInstruction *) ((jumpTarget119->address)));
		}
		assert(jumpTarget119 != 0);
		jumpTarget29 = jumpTarget119;
		offset38 = (((sqLong) jumpTarget29)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset38)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (125);
			((self_in_dispatchConcretize->machineCode))[1] = (offset38 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget1110 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1110);
		if ((addressIsInInstructions(jumpTarget1110))
		 || (jumpTarget1110 == (methodLabel()))) {
			jumpTarget1110 = ((AbstractInstruction *) ((jumpTarget1110->address)));
		}
		assert(jumpTarget1110 != 0);
		jumpTarget210 = jumpTarget1110;
		offset121 = (((sqLong) jumpTarget210)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (141);
		((self_in_dispatchConcretize->machineCode))[2] = (offset121 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset121)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset121)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset121)) >> 24) & 0xFF);
		return 6;

	case JumpGreater:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget120 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget120);
		if ((addressIsInInstructions(jumpTarget120))
		 || (jumpTarget120 == (methodLabel()))) {
			jumpTarget120 = ((AbstractInstruction *) ((jumpTarget120->address)));
		}
		assert(jumpTarget120 != 0);
		jumpTarget30 = jumpTarget120;
		offset39 = (((sqLong) jumpTarget30)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset39)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (0x7F);
			((self_in_dispatchConcretize->machineCode))[1] = (offset39 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget1111 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1111);
		if ((addressIsInInstructions(jumpTarget1111))
		 || (jumpTarget1111 == (methodLabel()))) {
			jumpTarget1111 = ((AbstractInstruction *) ((jumpTarget1111->address)));
		}
		assert(jumpTarget1111 != 0);
		jumpTarget211 = jumpTarget1111;
		offset122 = (((sqLong) jumpTarget211)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (143);
		((self_in_dispatchConcretize->machineCode))[2] = (offset122 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset122)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset122)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset122)) >> 24) & 0xFF);
		return 6;

	case JumpLessOrEqual:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget121 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget121);
		if ((addressIsInInstructions(jumpTarget121))
		 || (jumpTarget121 == (methodLabel()))) {
			jumpTarget121 = ((AbstractInstruction *) ((jumpTarget121->address)));
		}
		assert(jumpTarget121 != 0);
		jumpTarget31 = jumpTarget121;
		offset40 = (((sqLong) jumpTarget31)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset40)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (0x7E);
			((self_in_dispatchConcretize->machineCode))[1] = (offset40 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget1112 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1112);
		if ((addressIsInInstructions(jumpTarget1112))
		 || (jumpTarget1112 == (methodLabel()))) {
			jumpTarget1112 = ((AbstractInstruction *) ((jumpTarget1112->address)));
		}
		assert(jumpTarget1112 != 0);
		jumpTarget212 = jumpTarget1112;
		offset123 = (((sqLong) jumpTarget212)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (142);
		((self_in_dispatchConcretize->machineCode))[2] = (offset123 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset123)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset123)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset123)) >> 24) & 0xFF);
		return 6;

	case JumpAbove:
	case JumpFPGreater:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget122 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget122);
		if ((addressIsInInstructions(jumpTarget122))
		 || (jumpTarget122 == (methodLabel()))) {
			jumpTarget122 = ((AbstractInstruction *) ((jumpTarget122->address)));
		}
		assert(jumpTarget122 != 0);
		jumpTarget32 = jumpTarget122;
		offset41 = (((sqLong) jumpTarget32)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset41)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (119);
			((self_in_dispatchConcretize->machineCode))[1] = (offset41 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget1113 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1113);
		if ((addressIsInInstructions(jumpTarget1113))
		 || (jumpTarget1113 == (methodLabel()))) {
			jumpTarget1113 = ((AbstractInstruction *) ((jumpTarget1113->address)));
		}
		assert(jumpTarget1113 != 0);
		jumpTarget213 = jumpTarget1113;
		offset124 = (((sqLong) jumpTarget213)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (135);
		((self_in_dispatchConcretize->machineCode))[2] = (offset124 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset124)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset124)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset124)) >> 24) & 0xFF);
		return 6;

	case JumpBelowOrEqual:
	case JumpFPLessOrEqual:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget123 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget123);
		if ((addressIsInInstructions(jumpTarget123))
		 || (jumpTarget123 == (methodLabel()))) {
			jumpTarget123 = ((AbstractInstruction *) ((jumpTarget123->address)));
		}
		assert(jumpTarget123 != 0);
		jumpTarget33 = jumpTarget123;
		offset42 = (((sqLong) jumpTarget33)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset42)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (118);
			((self_in_dispatchConcretize->machineCode))[1] = (offset42 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget1114 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1114);
		if ((addressIsInInstructions(jumpTarget1114))
		 || (jumpTarget1114 == (methodLabel()))) {
			jumpTarget1114 = ((AbstractInstruction *) ((jumpTarget1114->address)));
		}
		assert(jumpTarget1114 != 0);
		jumpTarget214 = jumpTarget1114;
		offset125 = (((sqLong) jumpTarget214)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (134);
		((self_in_dispatchConcretize->machineCode))[2] = (offset125 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset125)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset125)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset125)) >> 24) & 0xFF);
		return 6;

	case JumpFPOrdered:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget124 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget124);
		if ((addressIsInInstructions(jumpTarget124))
		 || (jumpTarget124 == (methodLabel()))) {
			jumpTarget124 = ((AbstractInstruction *) ((jumpTarget124->address)));
		}
		assert(jumpTarget124 != 0);
		jumpTarget34 = jumpTarget124;
		offset43 = (((sqLong) jumpTarget34)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset43)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (123);
			((self_in_dispatchConcretize->machineCode))[1] = (offset43 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget1115 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1115);
		if ((addressIsInInstructions(jumpTarget1115))
		 || (jumpTarget1115 == (methodLabel()))) {
			jumpTarget1115 = ((AbstractInstruction *) ((jumpTarget1115->address)));
		}
		assert(jumpTarget1115 != 0);
		jumpTarget215 = jumpTarget1115;
		offset126 = (((sqLong) jumpTarget215)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (139);
		((self_in_dispatchConcretize->machineCode))[2] = (offset126 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset126)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset126)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset126)) >> 24) & 0xFF);
		return 6;

	case JumpFPUnordered:
		/* begin concretizeConditionalJump: */
		
		
		jumpTarget125 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget125);
		if ((addressIsInInstructions(jumpTarget125))
		 || (jumpTarget125 == (methodLabel()))) {
			jumpTarget125 = ((AbstractInstruction *) ((jumpTarget125->address)));
		}
		assert(jumpTarget125 != 0);
		jumpTarget35 = jumpTarget125;
		offset44 = (((sqLong) jumpTarget35)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset44)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (122);
			((self_in_dispatchConcretize->machineCode))[1] = (offset44 & 0xFF);
			return 2;
		}
		/* begin concretizeConditionalJumpLong: */
		
		
		jumpTarget1116 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1116);
		if ((addressIsInInstructions(jumpTarget1116))
		 || (jumpTarget1116 == (methodLabel()))) {
			jumpTarget1116 = ((AbstractInstruction *) ((jumpTarget1116->address)));
		}
		assert(jumpTarget1116 != 0);
		jumpTarget216 = jumpTarget1116;
		offset127 = (((sqLong) jumpTarget216)) - (((sqLong) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (138);
		((self_in_dispatchConcretize->machineCode))[2] = (offset127 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt)(offset127)) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset127)) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset127)) >> 24) & 0xFF);
		return 6;

	case RetN:
		/* begin concretizeRetN */
		offset3 = ((self_in_dispatchConcretize->operands))[0];
		if (offset3 == 0) {
			((self_in_dispatchConcretize->machineCode))[0] = 195;
			return 1;
		}
		((self_in_dispatchConcretize->machineCode))[0] = 194;
		((self_in_dispatchConcretize->machineCode))[1] = (offset3 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((offset3) >> 8);
		return 3;

	case Stop:
		/* begin concretizeStop */
		((self_in_dispatchConcretize->machineCode))[0] = 204;
		return 1;

	case AddCqR:
		return concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 0, 5);

	case AddcCqR:
		return concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 2, 20);

	case AddCwR:
		return concretizeArithCwR(self_in_dispatchConcretize, 3);

	case AddRR:
		return concretizeOpRR(self_in_dispatchConcretize, 3);

	case AddRsRs:
		/* begin concretizeSEEOpRsRs: */
		regRHS = ((self_in_dispatchConcretize->operands))[0];
		regLHS = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((regLHS <= 7)
		 && (regRHS <= 7)) {
			skip = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS, 0, regRHS));
		}
		((self_in_dispatchConcretize->machineCode))[skip + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip + 2] = 88;
		((self_in_dispatchConcretize->machineCode))[skip + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS, regLHS));
		return skip + 4;

	case AddRdRd:
		/* begin concretizeSEE2OpRdRd: */
		regRHS1 = ((self_in_dispatchConcretize->operands))[0];
		regLHS1 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		if ((regLHS1 <= 7)
		 && (regRHS1 <= 7)) {
			skip1 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip1 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS1, 0, regRHS1));
		}
		((self_in_dispatchConcretize->machineCode))[skip1 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip1 + 2] = 88;
		((self_in_dispatchConcretize->machineCode))[skip1 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS1, regLHS1));
		return skip1 + 4;

	case AndCqR:
		return concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 4, 37);

	case AndCwR:
		return concretizeArithCwR(self_in_dispatchConcretize, 35);

	case AndRR:
		return concretizeOpRR(self_in_dispatchConcretize, 35);

	case TstCqR:
		/* begin concretizeTstCqR */
		value = ((self_in_dispatchConcretize->operands))[0];
		reg2 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg2));
		if (isQuick(self_in_dispatchConcretize, value)) {
			((self_in_dispatchConcretize->machineCode))[1] = 246;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg2, 0));
			((self_in_dispatchConcretize->machineCode))[3] = (value & 0xFF);
			return 4;
		}
		if (is32BitSignedImmediate(self_in_dispatchConcretize, value)) {
			if (reg2 == RAX) {
				((self_in_dispatchConcretize->machineCode))[1] = 169;
				((self_in_dispatchConcretize->machineCode))[2] = (value & 0xFF);
				((self_in_dispatchConcretize->machineCode))[3] = (((value) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = (((value) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = (((value) >> 24) & 0xFF);
				return 6;
			}
			((self_in_dispatchConcretize->machineCode))[1] = 247;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg2, 0));
			((self_in_dispatchConcretize->machineCode))[3] = (value & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = (((value) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((value) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((value) >> 24) & 0xFF);
			return 7;
		}
		return concretizeArithCwR(self_in_dispatchConcretize, 133);

	case CmpCqR:
		return concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 7, 61);

	case CmpCwR:
		return concretizeArithCwR(self_in_dispatchConcretize, 57);

	case CmpC32R:
		/* begin concretizeCmpC32R */
		value1 = ((self_in_dispatchConcretize->operands))[0];
		reg3 = ((self_in_dispatchConcretize->operands))[1];
		if (reg3 == RAX) {
			((self_in_dispatchConcretize->machineCode))[0] = 61;
			skip2 = 0;
		}
		else {
			if (reg3 > 7) {
				((self_in_dispatchConcretize->machineCode))[0] = 65;
				skip2 = 2;
			}
			else {
				skip2 = 1;
			}
			((self_in_dispatchConcretize->machineCode))[skip2 - 1] = 129;
			((self_in_dispatchConcretize->machineCode))[skip2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg3, 7));
		}
		((self_in_dispatchConcretize->machineCode))[skip2 + 1] = (value1 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip2 + 2] = (((value1) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip2 + 3] = (((value1) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip2 + 4] = (((value1) >> 24) & 0xFF);
		return 5 + skip2;

	case CmpRR:
		return concretizeReverseOpRR(self_in_dispatchConcretize, 57);

	case CmpRdRd:
		/* begin concretizeCmpRdRd */
		regRHS2 = ((self_in_dispatchConcretize->operands))[0];
		regLHS2 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		if ((regLHS2 <= 7)
		 && (regRHS2 <= 7)) {
			skip3 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip3 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS2, 0, regRHS2));
		}
		((self_in_dispatchConcretize->machineCode))[skip3 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip3 + 2] = 46;
		((self_in_dispatchConcretize->machineCode))[skip3 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS2, regLHS2));
		return skip3 + 4;

	case CmpRsRs:
		/* begin concretizeCmpRsRs */
		regRHS3 = ((self_in_dispatchConcretize->operands))[0];
		regLHS3 = ((self_in_dispatchConcretize->operands))[1];
		if ((regLHS3 <= 7)
		 && (regRHS3 <= 7)) {
			skip4 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip4 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS3, 0, regRHS3));
		}
		((self_in_dispatchConcretize->machineCode))[skip4] = 15;
		((self_in_dispatchConcretize->machineCode))[skip4 + 1] = 46;
		((self_in_dispatchConcretize->machineCode))[skip4 + 2] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS3, regLHS3));
		return skip4 + 3;

	case DivRdRd:
		/* begin concretizeSEE2OpRdRd: */
		regRHS4 = ((self_in_dispatchConcretize->operands))[0];
		regLHS4 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		if ((regLHS4 <= 7)
		 && (regRHS4 <= 7)) {
			skip5 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip5 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS4, 0, regRHS4));
		}
		((self_in_dispatchConcretize->machineCode))[skip5 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip5 + 2] = 94;
		((self_in_dispatchConcretize->machineCode))[skip5 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS4, regLHS4));
		return skip5 + 4;

	case DivRsRs:
		/* begin concretizeSEEOpRsRs: */
		regRHS5 = ((self_in_dispatchConcretize->operands))[0];
		regLHS5 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((regLHS5 <= 7)
		 && (regRHS5 <= 7)) {
			skip6 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip6 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS5, 0, regRHS5));
		}
		((self_in_dispatchConcretize->machineCode))[skip6 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip6 + 2] = 94;
		((self_in_dispatchConcretize->machineCode))[skip6 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS5, regLHS5));
		return skip6 + 4;

	case MulRdRd:
		/* begin concretizeSEE2OpRdRd: */
		regRHS6 = ((self_in_dispatchConcretize->operands))[0];
		regLHS6 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		if ((regLHS6 <= 7)
		 && (regRHS6 <= 7)) {
			skip7 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip7 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS6, 0, regRHS6));
		}
		((self_in_dispatchConcretize->machineCode))[skip7 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip7 + 2] = 89;
		((self_in_dispatchConcretize->machineCode))[skip7 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS6, regLHS6));
		return skip7 + 4;

	case MulRsRs:
		/* begin concretizeSEEOpRsRs: */
		regRHS7 = ((self_in_dispatchConcretize->operands))[0];
		regLHS7 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((regLHS7 <= 7)
		 && (regRHS7 <= 7)) {
			skip8 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip8 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS7, 0, regRHS7));
		}
		((self_in_dispatchConcretize->machineCode))[skip8 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip8 + 2] = 89;
		((self_in_dispatchConcretize->machineCode))[skip8 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS7, regLHS7));
		return skip8 + 4;

	case OrCqR:
		return concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 1, 13);

	case OrCwR:
		return concretizeArithCwR(self_in_dispatchConcretize, 11);

	case OrRR:
		return concretizeOpRR(self_in_dispatchConcretize, 11);

	case SubCqR:
		return concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 5, 45);

	case SubbCqR:
		return concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 3, 29);

	case SubCwR:
		return concretizeArithCwR(self_in_dispatchConcretize, 43);

	case SubRR:
		return concretizeOpRR(self_in_dispatchConcretize, 43);

	case SubRdRd:
		/* begin concretizeSEE2OpRdRd: */
		regRHS8 = ((self_in_dispatchConcretize->operands))[0];
		regLHS8 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		if ((regLHS8 <= 7)
		 && (regRHS8 <= 7)) {
			skip9 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip9 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS8, 0, regRHS8));
		}
		((self_in_dispatchConcretize->machineCode))[skip9 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip9 + 2] = 92;
		((self_in_dispatchConcretize->machineCode))[skip9 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS8, regLHS8));
		return skip9 + 4;

	case SubRsRs:
		/* begin concretizeSEEOpRsRs: */
		regRHS9 = ((self_in_dispatchConcretize->operands))[0];
		regLHS9 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((regLHS9 <= 7)
		 && (regRHS9 <= 7)) {
			skip10 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip10 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS9, 0, regRHS9));
		}
		((self_in_dispatchConcretize->machineCode))[skip10 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip10 + 2] = 92;
		((self_in_dispatchConcretize->machineCode))[skip10 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS9, regLHS9));
		return skip10 + 4;

	case SqrtRd:
		/* begin concretizeSqrtRd */
		reg4 = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		if (reg4 <= 7) {
			skip11 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip11 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, reg4, 0, reg4));
		}
		((self_in_dispatchConcretize->machineCode))[skip11 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip11 + 2] = 81;
		((self_in_dispatchConcretize->machineCode))[skip11 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, reg4, reg4));
		return skip11 + 4;

	case SqrtRs:
		/* begin concretizeSqrtRs */
		reg5 = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if (reg5 <= 7) {
			skip12 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip12 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, reg5, 0, reg5));
		}
		((self_in_dispatchConcretize->machineCode))[skip12 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip12 + 2] = 81;
		((self_in_dispatchConcretize->machineCode))[skip12 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, reg5, reg5));
		return skip12 + 4;

	case XorCwR:
		return concretizeArithCwR(self_in_dispatchConcretize, 51);

	case XorRR:
		return concretizeOpRR(self_in_dispatchConcretize, 51);

	case XorRdRd:
		/* begin concretizeXorRdRd */
		regRHS10 = ((self_in_dispatchConcretize->operands))[0];
		regLHS10 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		if ((regLHS10 <= 7)
		 && (regRHS10 <= 7)) {
			skip13 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip13 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS10, 0, regRHS10));
		}
		((self_in_dispatchConcretize->machineCode))[skip13 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip13 + 2] = 87;
		((self_in_dispatchConcretize->machineCode))[skip13 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS10, regLHS10));
		return skip13 + 4;

	case XorRsRs:
		/* begin concretizeXorRsRs */
		regRHS11 = ((self_in_dispatchConcretize->operands))[0];
		regLHS11 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		if ((regLHS11 <= 7)
		 && (regRHS11 <= 7)) {
			skip14 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip14 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, regLHS11, 0, regRHS11));
		}
		((self_in_dispatchConcretize->machineCode))[skip14 + 1] = 87;
		((self_in_dispatchConcretize->machineCode))[skip14 + 2] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS11, regLHS11));
		return skip14 + 3;

	case NegateR:
		/* begin concretizeNegateR */
		reg6 = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg6));
		((self_in_dispatchConcretize->machineCode))[1] = 247;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg6, 3));
		return 3;

	case LoadEffectiveAddressMwrR:
		/* begin concretizeLoadEffectiveAddressMwrR */
		offset4 = ((self_in_dispatchConcretize->operands))[0];
		srcReg = ((self_in_dispatchConcretize->operands))[1];
		destReg = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg, 0, srcReg));
		((self_in_dispatchConcretize->machineCode))[1] = 141;
		if ((srcReg != RSP)
		 && (srcReg != R12)) {
			if (isQuick(self_in_dispatchConcretize, offset4)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg, destReg));
				((self_in_dispatchConcretize->machineCode))[3] = (offset4 & 0xFF);
				return 4;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg, destReg));
			((self_in_dispatchConcretize->machineCode))[3] = (offset4 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = (((offset4) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset4) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset4) >> 24) & 0xFF);
			return 7;
		}
		if (isQuick(self_in_dispatchConcretize, offset4)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg, destReg));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg));
			((self_in_dispatchConcretize->machineCode))[4] = (offset4 & 0xFF);
			return 5;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg, destReg));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg));
		((self_in_dispatchConcretize->machineCode))[4] = (offset4 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((offset4) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((offset4) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((offset4) >> 24) & 0xFF);
		return 8;

	case RotateLeftCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance >= 1) && (distance <= 0x3F)));
		reg7 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg7));
		if (distance == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg7, 0));
			return 3;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg7, 0));
		((self_in_dispatchConcretize->machineCode))[3] = distance;
		return 4;

	case RotateRightCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance1 = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance1 >= 1) && (distance1 <= 0x3F)));
		reg8 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg8));
		if (distance1 == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg8, 1));
			return 3;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg8, 1));
		((self_in_dispatchConcretize->machineCode))[3] = distance1;
		return 4;

	case ArithmeticShiftRightCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance2 = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance2 >= 1) && (distance2 <= 0x3F)));
		reg9 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg9));
		if (distance2 == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg9, 7));
			return 3;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg9, 7));
		((self_in_dispatchConcretize->machineCode))[3] = distance2;
		return 4;

	case LogicalShiftRightCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance3 = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance3 >= 1) && (distance3 <= 0x3F)));
		reg10 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg10));
		if (distance3 == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg10, 5));
			return 3;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg10, 5));
		((self_in_dispatchConcretize->machineCode))[3] = distance3;
		return 4;

	case LogicalShiftLeftCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance4 = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance4 >= 1) && (distance4 <= 0x3F)));
		reg11 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg11));
		if (distance4 == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg11, 4));
			return 3;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg11, 4));
		((self_in_dispatchConcretize->machineCode))[3] = distance4;
		return 4;

	case ArithmeticShiftRightRR:
		/* begin concretizeShiftRegRegOpcode: */
		shiftCountReg = ((self_in_dispatchConcretize->operands))[0];
		destReg1 = ((self_in_dispatchConcretize->operands))[1];
		if (shiftCountReg == RCX) {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, destReg1));
			((self_in_dispatchConcretize->machineCode))[1] = 211;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, destReg1, 7));
			return 3;
		}
		regToShift = (destReg1 == shiftCountReg
			? RCX
			: (destReg1 == RCX
					? shiftCountReg
					: destReg1));
		if (shiftCountReg == RAX) {
			((self_in_dispatchConcretize->machineCode))[0] = 72;
			((self_in_dispatchConcretize->machineCode))[1] = (144 + RCX);
			((self_in_dispatchConcretize->machineCode))[2] = (rexRxb(self_in_dispatchConcretize, 0, 0, regToShift));
			((self_in_dispatchConcretize->machineCode))[3] = 211;
			((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, regToShift, 7));
			((self_in_dispatchConcretize->machineCode))[5] = 72;
			((self_in_dispatchConcretize->machineCode))[6] = (144 + RCX);
			return 7;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, shiftCountReg, 0, RCX));
		((self_in_dispatchConcretize->machineCode))[1] = 135;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, RCX, shiftCountReg));
		((self_in_dispatchConcretize->machineCode))[3] = (rexRxb(self_in_dispatchConcretize, 0, 0, regToShift));
		((self_in_dispatchConcretize->machineCode))[4] = 211;
		((self_in_dispatchConcretize->machineCode))[5] = (modRMRO(self_in_dispatchConcretize, ModReg, regToShift, 7));
		((self_in_dispatchConcretize->machineCode))[6] = (rexRxb(self_in_dispatchConcretize, shiftCountReg, 0, RCX));
		((self_in_dispatchConcretize->machineCode))[7] = 135;
		((self_in_dispatchConcretize->machineCode))[8] = (modRMRO(self_in_dispatchConcretize, ModReg, RCX, shiftCountReg));
		return 9;

	case LogicalShiftLeftRR:
		/* begin concretizeShiftRegRegOpcode: */
		shiftCountReg1 = ((self_in_dispatchConcretize->operands))[0];
		destReg2 = ((self_in_dispatchConcretize->operands))[1];
		if (shiftCountReg1 == RCX) {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, destReg2));
			((self_in_dispatchConcretize->machineCode))[1] = 211;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, destReg2, 4));
			return 3;
		}
		regToShift1 = (destReg2 == shiftCountReg1
			? RCX
			: (destReg2 == RCX
					? shiftCountReg1
					: destReg2));
		if (shiftCountReg1 == RAX) {
			((self_in_dispatchConcretize->machineCode))[0] = 72;
			((self_in_dispatchConcretize->machineCode))[1] = (144 + RCX);
			((self_in_dispatchConcretize->machineCode))[2] = (rexRxb(self_in_dispatchConcretize, 0, 0, regToShift1));
			((self_in_dispatchConcretize->machineCode))[3] = 211;
			((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, regToShift1, 4));
			((self_in_dispatchConcretize->machineCode))[5] = 72;
			((self_in_dispatchConcretize->machineCode))[6] = (144 + RCX);
			return 7;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, shiftCountReg1, 0, RCX));
		((self_in_dispatchConcretize->machineCode))[1] = 135;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, RCX, shiftCountReg1));
		((self_in_dispatchConcretize->machineCode))[3] = (rexRxb(self_in_dispatchConcretize, 0, 0, regToShift1));
		((self_in_dispatchConcretize->machineCode))[4] = 211;
		((self_in_dispatchConcretize->machineCode))[5] = (modRMRO(self_in_dispatchConcretize, ModReg, regToShift1, 4));
		((self_in_dispatchConcretize->machineCode))[6] = (rexRxb(self_in_dispatchConcretize, shiftCountReg1, 0, RCX));
		((self_in_dispatchConcretize->machineCode))[7] = 135;
		((self_in_dispatchConcretize->machineCode))[8] = (modRMRO(self_in_dispatchConcretize, ModReg, RCX, shiftCountReg1));
		return 9;

	case ClzRR:
		/* begin concretizeClzRR */
		maskReg = ((self_in_dispatchConcretize->operands))[0];
		dest = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		((self_in_dispatchConcretize->machineCode))[1] = (rexwrxb(self_in_dispatchConcretize, 1, dest, 0, maskReg));
		((self_in_dispatchConcretize->machineCode))[2] = 15;
		((self_in_dispatchConcretize->machineCode))[3] = 189;
		((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, maskReg, dest));
		return 5;

	case MoveCqR:
		/* begin concretizeMoveCqR */
		value2 = ((self_in_dispatchConcretize->operands))[0];
		reg12 = ((self_in_dispatchConcretize->operands))[1];
		if (is32BitSignedImmediate(self_in_dispatchConcretize, value2)) {
			if (value2 == 0) {
				((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, reg12, 0, reg12));
				((self_in_dispatchConcretize->machineCode))[1] = 49;
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg12, reg12));
				return 3;
			}
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg12));
			((self_in_dispatchConcretize->machineCode))[1] = 199;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg12, 0));
			((self_in_dispatchConcretize->machineCode))[3] = (value2 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = (((value2) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((value2) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((value2) >> 24) & 0xFF);
			return 7;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg12));
		((self_in_dispatchConcretize->machineCode))[1] = (184 + (reg12 & 7));
		((self_in_dispatchConcretize->machineCode))[2] = (value2 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = (((value2) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = (((value2) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((value2) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((value2) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((value2) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = (((value2) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = (((value2) >> 56) & 0xFF);
		return 10;

	case MoveCwR:
		/* begin concretizeMoveCwR */
		value3 = ((self_in_dispatchConcretize->operands))[0];
		reg13 = ((self_in_dispatchConcretize->operands))[1];
		if ((addressIsInInstructions(((AbstractInstruction *) value3)))
		 || ((((AbstractInstruction *) value3)) == (methodLabel()))) {
			value3 = ((((AbstractInstruction *) value3))->address);
		}
		if (((((usqInt)value3)) >= ((methodLabel->address)))
		 && ((((usqInt)value3)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))) {
			offset5 = value3 - (((self_in_dispatchConcretize->address)) + 7);
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, reg13, 0, 0));
			((self_in_dispatchConcretize->machineCode))[1] = 141;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 5, reg13));
			((self_in_dispatchConcretize->machineCode))[3] = (offset5 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset5)) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset5)) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt)(offset5)) >> 24) & 0xFF);
			return 7;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg13));
		((self_in_dispatchConcretize->machineCode))[1] = (184 + (reg13 & 7));
		((self_in_dispatchConcretize->machineCode))[2] = (value3 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = (((value3) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = (((value3) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((value3) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((value3) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((value3) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = (((value3) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = (((value3) >> 56) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[10] = 144;
		return 11;

	case MoveC32R:
		/* begin concretizeMoveC32R */
		value4 = ((self_in_dispatchConcretize->operands))[0];
		reg14 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg14));
		((self_in_dispatchConcretize->machineCode))[1] = 199;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg14, 0));
		((self_in_dispatchConcretize->machineCode))[3] = (value4 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = (((value4) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((value4) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((value4) >> 24) & 0xFF);
		return 7;

	case MoveRR:
		return concretizeReverseOpRR(self_in_dispatchConcretize, 137);

	case MoveAwR:
		/* begin concretizeMoveAwR */
		addressOperand = ((self_in_dispatchConcretize->operands))[0];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand)))
		 || ((((AbstractInstruction *) addressOperand)) == (methodLabel()))) {
			addressOperand = ((((AbstractInstruction *) addressOperand))->address);
		}
		if ((addressOperand != null)
		 && ((addressOperand >= (varBaseAddress()))
		 && ((addressOperand - (varBaseAddress())) < (0x100000)))) {
			save0 = ((self_in_dispatchConcretize->operands))[0];
			save1 = ((self_in_dispatchConcretize->operands))[1];
			((self_in_dispatchConcretize->operands))[0] = (addressOperand - (varBaseAddress()));
			((self_in_dispatchConcretize->operands))[1] = RBX;
			((self_in_dispatchConcretize->operands))[2] = save1;
			/* begin concretizeMoveMwrR */
			offset11 = ((self_in_dispatchConcretize->operands))[0];
			srcReg1 = ((self_in_dispatchConcretize->operands))[1];
			destReg3 = ((self_in_dispatchConcretize->operands))[2];
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg3, 0, srcReg1));
			((self_in_dispatchConcretize->machineCode))[1] = 139;
			if ((srcReg1 != RSP)
			 && (srcReg1 != R12)) {
				if ((offset11 == 0)
				 && ((srcReg1 != RBP)
				 && (srcReg1 != R13))) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg1, destReg3));
					savedSize = 3;
					goto l1;
				}
				if (isQuick(self_in_dispatchConcretize, offset11)) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg1, destReg3));
					((self_in_dispatchConcretize->machineCode))[3] = (offset11 & 0xFF);
					savedSize = 4;
					goto l1;
				}
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg1, destReg3));
				((self_in_dispatchConcretize->machineCode))[3] = (offset11 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = (((offset11) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = (((offset11) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = (((offset11) >> 24) & 0xFF);
				savedSize = 7;
				goto l1;
			}
			if (offset11 == 0) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg1, destReg3));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg1));
				savedSize = 4;
				goto l1;
			}
			if (isQuick(self_in_dispatchConcretize, offset11)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg1, destReg3));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg1));
				((self_in_dispatchConcretize->machineCode))[4] = (offset11 & 0xFF);
				savedSize = 5;
				goto l1;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg1, destReg3));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg1));
			((self_in_dispatchConcretize->machineCode))[4] = (offset11 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset11) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset11) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = (((offset11) >> 24) & 0xFF);
			savedSize = 8;
	l1:	/* end concretizeMoveMwrR */;
			((self_in_dispatchConcretize->operands))[0] = save0;
			((self_in_dispatchConcretize->operands))[1] = save1;
			((self_in_dispatchConcretize->operands))[2] = 0;
			return savedSize;
		}

		/* If fetching RAX, fetch directly, otherwise, because of instruction encoding limitations, the register
		   _must_ be fetched through RAX.  If reg = RBP or RSP simply fetch directly, otherwise swap RAX with
		   the register before and after the fetch through RAX.  We avoid swapping before hand with RBP
		   and RSP because setting RSP to whatever the contents of RAX is can cause disastrous results if
		   an interrupt is delivered immediately after that point.  See mail threads beginning with
		   http://lists.squeakfoundation.org/pipermail/vm-dev/2019-September/031428.html
		   http://lists.squeakfoundation.org/pipermail/vm-dev/2019-October/031499.html */
		reg15 = ((self_in_dispatchConcretize->operands))[1];
		if ((reg15 == RAX)
		 || ((reg15 == RBP)
		 || (reg15 == RSP))) {
			offset6 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg15));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg15 % 8));
			offset6 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset6] = 72;
		((self_in_dispatchConcretize->machineCode))[1 + offset6] = 161;
		((self_in_dispatchConcretize->machineCode))[2 + offset6] = (addressOperand & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset6] = (((addressOperand) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset6] = (((addressOperand) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset6] = (((addressOperand) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset6] = (((addressOperand) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset6] = (((addressOperand) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset6] = (((addressOperand) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9 + offset6] = (((addressOperand) >> 56) & 0xFF);
		if (reg15 == RAX) {
			return 10;
		}
		if ((reg15 == RBP)
		 || (reg15 == RSP)) {
			((self_in_dispatchConcretize->machineCode))[10] = (rexRxb(self_in_dispatchConcretize, RAX, 0, reg15));
			((self_in_dispatchConcretize->machineCode))[11] = (144 + (reg15 % 8));
			return 12;
		}
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[13] = (((self_in_dispatchConcretize->machineCode))[1]);
		return 14;

	case MoveA32R:
		/* begin concretizeMoveA32R */
		addressOperand1 = ((self_in_dispatchConcretize->operands))[0];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand1)))
		 || ((((AbstractInstruction *) addressOperand1)) == (methodLabel()))) {
			addressOperand1 = ((((AbstractInstruction *) addressOperand1))->address);
		}
		reg16 = ((self_in_dispatchConcretize->operands))[1];
		if (reg16 == RAX) {
			offset7 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg16));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg16 % 8));
			offset7 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset7] = 161;
		((self_in_dispatchConcretize->machineCode))[1 + offset7] = (addressOperand1 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2 + offset7] = (((addressOperand1) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset7] = (((addressOperand1) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset7] = (((addressOperand1) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset7] = (((addressOperand1) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset7] = (((addressOperand1) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset7] = (((addressOperand1) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset7] = (((addressOperand1) >> 56) & 0xFF);
		if (reg16 == RAX) {
			return 9;
		}
		((self_in_dispatchConcretize->machineCode))[11] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[1]);
		return 13;

	case MoveRAw:
		/* begin concretizeMoveRAw */
		reg17 = ((self_in_dispatchConcretize->operands))[0];
		addressOperand2 = ((self_in_dispatchConcretize->operands))[1];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand2)))
		 || ((((AbstractInstruction *) addressOperand2)) == (methodLabel()))) {
			addressOperand2 = ((((AbstractInstruction *) addressOperand2))->address);
		}
		if ((addressOperand2 != null)
		 && ((addressOperand2 >= (varBaseAddress()))
		 && ((addressOperand2 - (varBaseAddress())) < (0x100000)))) {
			save11 = ((self_in_dispatchConcretize->operands))[1];
			((self_in_dispatchConcretize->operands))[1] = (addressOperand2 - (varBaseAddress()));
			((self_in_dispatchConcretize->operands))[2] = RBX;
			/* begin concretizeMoveRMwr */
			srcReg2 = ((self_in_dispatchConcretize->operands))[0];
			offset12 = ((self_in_dispatchConcretize->operands))[1];
			destReg4 = ((self_in_dispatchConcretize->operands))[2];
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, srcReg2, 0, destReg4));
			((self_in_dispatchConcretize->machineCode))[1] = 137;
			if ((destReg4 != RSP)
			 && (destReg4 != R12)) {
				if ((offset12 == 0)
				 && ((destReg4 != RBP)
				 && (destReg4 != R13))) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg4, srcReg2));
					savedSize1 = 3;
					goto l2;
				}
				if (isQuick(self_in_dispatchConcretize, offset12)) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg4, srcReg2));
					((self_in_dispatchConcretize->machineCode))[3] = (offset12 & 0xFF);
					savedSize1 = 4;
					goto l2;
				}
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg4, srcReg2));
				((self_in_dispatchConcretize->machineCode))[3] = (offset12 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = (((offset12) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = (((offset12) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = (((offset12) >> 24) & 0xFF);
				savedSize1 = 7;
				goto l2;
			}
			if (offset12 == 0) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg4, srcReg2));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg4));
				savedSize1 = 4;
				goto l2;
			}
			if (isQuick(self_in_dispatchConcretize, offset12)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg4, srcReg2));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg4));
				((self_in_dispatchConcretize->machineCode))[4] = (offset12 & 0xFF);
				savedSize1 = 5;
				goto l2;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg4, srcReg2));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg4));
			((self_in_dispatchConcretize->machineCode))[4] = (offset12 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset12) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset12) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = (((offset12) >> 24) & 0xFF);
			savedSize1 = 8;
	l2:	/* end concretizeMoveRMwr */;
			((self_in_dispatchConcretize->operands))[1] = save11;
			((self_in_dispatchConcretize->operands))[2] = 0;
			return savedSize1;
		}
		if ((reg17 == RAX)
		 || ((reg17 == RBP)
		 || (reg17 == RSP))) {
			offset8 = 0;
		}
		else {
			if ((reg17 == RBP)
			 || (reg17 == RSP)) {
				((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, reg17, 0, RAX));
				((self_in_dispatchConcretize->machineCode))[1] = 137;
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, RAX, reg17));
				offset8 = 3;
			}
			else {
				((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, RAX, 0, reg17));
				((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg17 % 8));
				offset8 = 2;
			}
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset8] = 72;
		((self_in_dispatchConcretize->machineCode))[1 + offset8] = 163;
		((self_in_dispatchConcretize->machineCode))[2 + offset8] = (addressOperand2 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset8] = (((addressOperand2) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset8] = (((addressOperand2) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset8] = (((addressOperand2) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset8] = (((addressOperand2) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset8] = (((addressOperand2) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset8] = (((addressOperand2) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9 + offset8] = (((addressOperand2) >> 56) & 0xFF);
		if (reg17 == RAX) {
			return 10;
		}
		if ((reg17 == RBP)
		 || (reg17 == RSP)) {
			return 13;
		}
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[13] = (((self_in_dispatchConcretize->machineCode))[1]);
		return 14;

	case MoveRA32:
		/* begin concretizeMoveRA32 */
		reg18 = ((self_in_dispatchConcretize->operands))[0];
		addressOperand3 = ((self_in_dispatchConcretize->operands))[1];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand3)))
		 || ((((AbstractInstruction *) addressOperand3)) == (methodLabel()))) {
			addressOperand3 = ((((AbstractInstruction *) addressOperand3))->address);
		}
		if (reg18 == RAX) {
			offset9 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg18));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg18 % 8));
			offset9 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset9] = 163;
		((self_in_dispatchConcretize->machineCode))[1 + offset9] = (addressOperand3 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2 + offset9] = (((addressOperand3) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset9] = (((addressOperand3) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset9] = (((addressOperand3) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset9] = (((addressOperand3) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset9] = (((addressOperand3) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset9] = (((addressOperand3) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset9] = (((addressOperand3) >> 56) & 0xFF);
		if (reg18 == RAX) {
			return 9;
		}
		((self_in_dispatchConcretize->machineCode))[11] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[1]);
		return 13;

	case MoveAbR:
		/* begin concretizeMoveAbR */
		addressOperand4 = ((self_in_dispatchConcretize->operands))[0];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand4)))
		 || ((((AbstractInstruction *) addressOperand4)) == (methodLabel()))) {
			addressOperand4 = ((((AbstractInstruction *) addressOperand4))->address);
		}
		if ((addressOperand4 != null)
		 && ((addressOperand4 >= (varBaseAddress()))
		 && ((addressOperand4 - (varBaseAddress())) < (0x100000)))) {
			save01 = ((self_in_dispatchConcretize->operands))[0];
			save12 = ((self_in_dispatchConcretize->operands))[1];
			((self_in_dispatchConcretize->operands))[0] = (addressOperand4 - (varBaseAddress()));
			((self_in_dispatchConcretize->operands))[1] = RBX;
			((self_in_dispatchConcretize->operands))[2] = save12;
			/* begin concretizeMoveMbrR */
			offset110 = ((self_in_dispatchConcretize->operands))[0];
			srcReg31 = ((self_in_dispatchConcretize->operands))[1];
			destReg32 = ((self_in_dispatchConcretize->operands))[2];
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg32, 0, srcReg31));
			((self_in_dispatchConcretize->machineCode))[1] = 138;
			if ((srcReg31 != RSP)
			 && (srcReg31 != R12)) {
				if ((offset110 == 0)
				 && ((srcReg31 != RBP)
				 && (srcReg31 != R13))) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg31, destReg32));
					savedSize2 = 3;
					goto l3;
				}
				if (isQuick(self_in_dispatchConcretize, offset110)) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg31, destReg32));
					((self_in_dispatchConcretize->machineCode))[3] = (offset110 & 0xFF);
					savedSize2 = 4;
					goto l3;
				}
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg31, destReg32));
				((self_in_dispatchConcretize->machineCode))[3] = (offset110 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = (((offset110) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = (((offset110) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = (((offset110) >> 24) & 0xFF);
				savedSize2 = 7;
				goto l3;
			}
			if (offset110 == 0) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg31, destReg32));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg31));
				savedSize2 = 4;
				goto l3;
			}
			if (isQuick(self_in_dispatchConcretize, offset110)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg31, destReg32));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg31));
				((self_in_dispatchConcretize->machineCode))[4] = (offset110 & 0xFF);
				savedSize2 = 5;
				goto l3;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg31, destReg32));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg31));
			((self_in_dispatchConcretize->machineCode))[4] = (offset110 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset110) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset110) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = (((offset110) >> 24) & 0xFF);
			savedSize2 = 8;
	l3:	/* end concretizeMoveMbrR */;
			((self_in_dispatchConcretize->operands))[0] = save01;
			((self_in_dispatchConcretize->operands))[1] = save12;
			((self_in_dispatchConcretize->operands))[2] = 0;
			return savedSize2;
		}
		reg21 = ((self_in_dispatchConcretize->operands))[1];
		if (reg21 == RAX) {
			offset26 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg21));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg21 % 8));
			offset26 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset26] = 72;
		((self_in_dispatchConcretize->machineCode))[1 + offset26] = 160;
		((self_in_dispatchConcretize->machineCode))[2 + offset26] = (addressOperand4 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset26] = (((addressOperand4) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset26] = (((addressOperand4) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset26] = (((addressOperand4) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset26] = (((addressOperand4) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset26] = (((addressOperand4) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset26] = (((addressOperand4) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9 + offset26] = (((addressOperand4) >> 56) & 0xFF);
		if (reg21 == RAX) {
			return 10;
		}
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[13] = (((self_in_dispatchConcretize->machineCode))[1]);
		return 14;

	case MoveRAb:
		/* begin concretizeMoveRAb */
		reg22 = ((self_in_dispatchConcretize->operands))[0];
		addressOperand5 = ((self_in_dispatchConcretize->operands))[1];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand5)))
		 || ((((AbstractInstruction *) addressOperand5)) == (methodLabel()))) {
			addressOperand5 = ((((AbstractInstruction *) addressOperand5))->address);
		}
		if ((addressOperand5 != null)
		 && ((addressOperand5 >= (varBaseAddress()))
		 && ((addressOperand5 - (varBaseAddress())) < (0x100000)))) {
			save13 = ((self_in_dispatchConcretize->operands))[1];
			((self_in_dispatchConcretize->operands))[1] = (addressOperand5 - (varBaseAddress()));
			((self_in_dispatchConcretize->operands))[2] = RBX;
			/* begin concretizeMoveRMbr */
			srcReg32 = ((self_in_dispatchConcretize->operands))[0];
			offset111 = ((self_in_dispatchConcretize->operands))[1];
			baseReg1 = ((self_in_dispatchConcretize->operands))[2];
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, srcReg32, 0, baseReg1));
			((self_in_dispatchConcretize->machineCode))[1] = 136;
			if ((baseReg1 != RSP)
			 && (baseReg1 != R12)) {
				if ((offset111 == 0)
				 && ((baseReg1 != RBP)
				 && (baseReg1 != R13))) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, baseReg1, srcReg32));
					savedSize3 = 3;
					goto l4;
				}
				if (isQuick(self_in_dispatchConcretize, offset111)) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, baseReg1, srcReg32));
					((self_in_dispatchConcretize->machineCode))[3] = (offset111 & 0xFF);
					savedSize3 = 4;
					goto l4;
				}
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, baseReg1, srcReg32));
				((self_in_dispatchConcretize->machineCode))[3] = (offset111 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = (((offset111) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = (((offset111) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = (((offset111) >> 24) & 0xFF);
				savedSize3 = 7;
				goto l4;
			}
			if (offset111 == 0) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, baseReg1, srcReg32));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg1));
				savedSize3 = 4;
				goto l4;
			}
			if (isQuick(self_in_dispatchConcretize, offset111)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, baseReg1, srcReg32));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg1));
				((self_in_dispatchConcretize->machineCode))[4] = (offset111 & 0xFF);
				savedSize3 = 5;
				goto l4;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, baseReg1, srcReg32));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg1));
			((self_in_dispatchConcretize->machineCode))[4] = (offset111 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset111) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset111) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = (((offset111) >> 24) & 0xFF);
			savedSize3 = 8;
	l4:	/* end concretizeMoveRMbr */;
			((self_in_dispatchConcretize->operands))[1] = save13;
			((self_in_dispatchConcretize->operands))[2] = 0;
			return savedSize3;
		}
		if (reg22 == RAX) {
			offset27 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg22));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg22 % 8));
			offset27 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset27] = 72;
		((self_in_dispatchConcretize->machineCode))[1 + offset27] = 162;
		((self_in_dispatchConcretize->machineCode))[2 + offset27] = (addressOperand5 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset27] = (((addressOperand5) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset27] = (((addressOperand5) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset27] = (((addressOperand5) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset27] = (((addressOperand5) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset27] = (((addressOperand5) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset27] = (((addressOperand5) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9 + offset27] = (((addressOperand5) >> 56) & 0xFF);
		if (reg22 == RAX) {
			return 10;
		}
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[13] = (((self_in_dispatchConcretize->machineCode))[1]);
		return 14;

	case MoveMbrR:
	case MoveM8rR:
		/* begin concretizeMoveMbrR */
		offset10 = ((self_in_dispatchConcretize->operands))[0];
		srcReg3 = ((self_in_dispatchConcretize->operands))[1];
		destReg5 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg5, 0, srcReg3));
		((self_in_dispatchConcretize->machineCode))[1] = 138;
		if ((srcReg3 != RSP)
		 && (srcReg3 != R12)) {
			if ((offset10 == 0)
			 && ((srcReg3 != RBP)
			 && (srcReg3 != R13))) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg3, destReg5));
				return 3;
			}
			if (isQuick(self_in_dispatchConcretize, offset10)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg3, destReg5));
				((self_in_dispatchConcretize->machineCode))[3] = (offset10 & 0xFF);
				return 4;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg3, destReg5));
			((self_in_dispatchConcretize->machineCode))[3] = (offset10 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = (((offset10) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset10) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset10) >> 24) & 0xFF);
			return 7;
		}
		if (offset10 == 0) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg3, destReg5));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg3));
			return 4;
		}
		if (isQuick(self_in_dispatchConcretize, offset10)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg3, destReg5));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg3));
			((self_in_dispatchConcretize->machineCode))[4] = (offset10 & 0xFF);
			return 5;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg3, destReg5));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg3));
		((self_in_dispatchConcretize->machineCode))[4] = (offset10 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((offset10) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((offset10) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((offset10) >> 24) & 0xFF);
		return 8;

	case MoveRMbr:
	case MoveRM8r:
		/* begin concretizeMoveRMbr */
		srcReg4 = ((self_in_dispatchConcretize->operands))[0];
		offset13 = ((self_in_dispatchConcretize->operands))[1];
		baseReg = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, srcReg4, 0, baseReg));
		((self_in_dispatchConcretize->machineCode))[1] = 136;
		if ((baseReg != RSP)
		 && (baseReg != R12)) {
			if ((offset13 == 0)
			 && ((baseReg != RBP)
			 && (baseReg != R13))) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, baseReg, srcReg4));
				return 3;
			}
			if (isQuick(self_in_dispatchConcretize, offset13)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, baseReg, srcReg4));
				((self_in_dispatchConcretize->machineCode))[3] = (offset13 & 0xFF);
				return 4;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, baseReg, srcReg4));
			((self_in_dispatchConcretize->machineCode))[3] = (offset13 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = (((offset13) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset13) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset13) >> 24) & 0xFF);
			return 7;
		}
		if (offset13 == 0) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, baseReg, srcReg4));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg));
			return 4;
		}
		if (isQuick(self_in_dispatchConcretize, offset13)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, baseReg, srcReg4));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg));
			((self_in_dispatchConcretize->machineCode))[4] = (offset13 & 0xFF);
			return 5;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, baseReg, srcReg4));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg));
		((self_in_dispatchConcretize->machineCode))[4] = (offset13 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((offset13) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((offset13) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((offset13) >> 24) & 0xFF);
		return 8;

	case MoveM16rR:
		/* begin concretizeMoveM16rR */
		offset14 = ((self_in_dispatchConcretize->operands))[0];
		srcReg5 = ((self_in_dispatchConcretize->operands))[1];
		destReg6 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg6, 0, srcReg5));
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 183;
		if ((srcReg5 != RSP)
		 && (srcReg5 != R12)) {
			if ((offset14 == 0)
			 && ((srcReg5 != RBP)
			 && (srcReg5 != R13))) {
				((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg5, destReg6));
				return 4;
			}
			if (isQuick(self_in_dispatchConcretize, offset14)) {
				((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg5, destReg6));
				((self_in_dispatchConcretize->machineCode))[4] = (offset14 & 0xFF);
				return 5;
			}
			((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg5, destReg6));
			((self_in_dispatchConcretize->machineCode))[4] = (offset14 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset14) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset14) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = (((offset14) >> 24) & 0xFF);
			return 8;
		}
		if ((offset14 == 0)
		 && ((srcReg5 != RBP)
		 && (srcReg5 != R13))) {
			((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg5, destReg6));
			((self_in_dispatchConcretize->machineCode))[4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg5));
			return 5;
		}
		if (isQuick(self_in_dispatchConcretize, offset14)) {
			((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg5, destReg6));
			((self_in_dispatchConcretize->machineCode))[4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg5));
			((self_in_dispatchConcretize->machineCode))[5] = (offset14 & 0xFF);
			return 6;
		}
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg5, destReg6));
		((self_in_dispatchConcretize->machineCode))[4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg5));
		((self_in_dispatchConcretize->machineCode))[5] = (offset14 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((offset14) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((offset14) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = (((offset14) >> 24) & 0xFF);
		return 9;

	case MoveRM16r:
		/* begin concretizeMoveRM16r */
		srcReg6 = ((self_in_dispatchConcretize->operands))[0];
		offset15 = ((self_in_dispatchConcretize->operands))[1];
		destReg7 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		if ((srcReg6 > 7)
		 || (destReg7 > 7)) {
			((self_in_dispatchConcretize->machineCode))[1] = (rexwrxb(self_in_dispatchConcretize, 0, srcReg6, 0, destReg7));
			skip15 = 1;
		}
		else {
			skip15 = 0;
		}
		if ((destReg7 & 7) != RSP) {
			if (isQuick(self_in_dispatchConcretize, offset15)) {
				((self_in_dispatchConcretize->machineCode))[skip15 + 1] = 137;
				((self_in_dispatchConcretize->machineCode))[skip15 + 2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg7, srcReg6));
				((self_in_dispatchConcretize->machineCode))[skip15 + 3] = (offset15 & 0xFF);
				return skip15 + 4;
			}
			((self_in_dispatchConcretize->machineCode))[skip15 + 1] = 137;
			((self_in_dispatchConcretize->machineCode))[skip15 + 2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg7, srcReg6));
			((self_in_dispatchConcretize->machineCode))[skip15 + 3] = (offset15 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[skip15 + 4] = (((offset15) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[skip15 + 5] = (((offset15) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[skip15 + 6] = (((offset15) >> 24) & 0xFF);
			return skip15 + 7;
		}
		if (isQuick(self_in_dispatchConcretize, offset15)) {
			((self_in_dispatchConcretize->machineCode))[skip15 + 1] = 137;
			((self_in_dispatchConcretize->machineCode))[skip15 + 2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg7, srcReg6));
			((self_in_dispatchConcretize->machineCode))[skip15 + 3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg7));
			((self_in_dispatchConcretize->machineCode))[skip15 + 4] = (offset15 & 0xFF);
			return skip15 + 5;
		}
		((self_in_dispatchConcretize->machineCode))[skip15 + 1] = 137;
		((self_in_dispatchConcretize->machineCode))[skip15 + 2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg7, srcReg6));
		((self_in_dispatchConcretize->machineCode))[skip15 + 3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg7));
		((self_in_dispatchConcretize->machineCode))[skip15 + 4] = (offset15 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip15 + 5] = (((offset15) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip15 + 6] = (((offset15) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip15 + 7] = (((offset15) >> 24) & 0xFF);
		return skip15 + 8;

	case MoveM32rR:
		/* begin concretizeMoveM32rR */
		offset16 = ((self_in_dispatchConcretize->operands))[0];
		srcReg7 = ((self_in_dispatchConcretize->operands))[1];
		destReg8 = ((self_in_dispatchConcretize->operands))[2];
		if ((srcReg7 <= 7)
		 && (destReg8 <= 7)) {
			skip16 = 0;
		}
		else {
			skip16 = 1;
			((self_in_dispatchConcretize->machineCode))[0] = (rexwrxb(self_in_dispatchConcretize, 0, destReg8, 0, srcReg7));
		}
		((self_in_dispatchConcretize->machineCode))[skip16] = 139;
		if (offset16 == 0) {
			if ((srcReg7 & 6) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip16 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg7, destReg8));
				return skip16 + 2;
			}
			if ((srcReg7 & 7) == RSP) {

				/* RBP & R13 fall through */
				((self_in_dispatchConcretize->machineCode))[skip16 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg7, destReg8));
				((self_in_dispatchConcretize->machineCode))[skip16 + 2] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg7));
				return skip16 + 3;
			}
		}
		if (isQuick(self_in_dispatchConcretize, offset16)) {
			if ((srcReg7 & 7) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip16 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg7, destReg8));
				((self_in_dispatchConcretize->machineCode))[skip16 + 2] = (offset16 & 0xFF);
				return skip16 + 3;
			}
			((self_in_dispatchConcretize->machineCode))[skip16 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg7, destReg8));
			((self_in_dispatchConcretize->machineCode))[skip16 + 2] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg7));
			((self_in_dispatchConcretize->machineCode))[skip16 + 3] = (offset16 & 0xFF);
			return skip16 + 4;
		}
		((self_in_dispatchConcretize->machineCode))[skip16 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg7, destReg8));
		if ((srcReg7 & 7) == RSP) {
			((self_in_dispatchConcretize->machineCode))[skip16 + 2] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg7));
			skip16 += 1;
		}
		((self_in_dispatchConcretize->machineCode))[skip16 + 2] = (offset16 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip16 + 3] = (((offset16) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip16 + 4] = (((offset16) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip16 + 5] = (((offset16) >> 24) & 0xFF);
		return skip16 + 6;

	case MoveM32rRs:
		/* begin concretizeMoveM32rRs */
		offset17 = ((self_in_dispatchConcretize->operands))[0];
		srcReg8 = ((self_in_dispatchConcretize->operands))[1];
		destReg9 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		if ((srcReg8 <= 7)
		 && (destReg9 <= 7)) {
			skip17 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip17 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, destReg9, 0, srcReg8));
		}
		((self_in_dispatchConcretize->machineCode))[skip17 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip17 + 2] = 110;
		if (offset17 == 0) {
			if ((srcReg8 & 6) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip17 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg8, destReg9));
				return skip17 + 4;
			}
			if ((srcReg8 & 7) == RSP) {

				/* RBP & R13 fall through */
				((self_in_dispatchConcretize->machineCode))[skip17 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg8, destReg9));
				((self_in_dispatchConcretize->machineCode))[skip17 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg8));
				return skip17 + 5;
			}
		}
		if (isQuick(self_in_dispatchConcretize, offset17)) {
			if ((srcReg8 & 7) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip17 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg8, destReg9));
				((self_in_dispatchConcretize->machineCode))[skip17 + 4] = (offset17 & 0xFF);
				return skip17 + 5;
			}
			((self_in_dispatchConcretize->machineCode))[skip17 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg8, destReg9));
			((self_in_dispatchConcretize->machineCode))[skip17 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg8));
			((self_in_dispatchConcretize->machineCode))[skip17 + 5] = (offset17 & 0xFF);
			return skip17 + 6;
		}
		((self_in_dispatchConcretize->machineCode))[skip17 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg8, destReg9));
		if ((srcReg8 & 7) == RSP) {
			((self_in_dispatchConcretize->machineCode))[skip17 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg8));
			skip17 += 1;
		}
		((self_in_dispatchConcretize->machineCode))[skip17 + 4] = (offset17 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip17 + 5] = (((offset17) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip17 + 6] = (((offset17) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip17 + 7] = (((offset17) >> 24) & 0xFF);
		return skip17 + 8;

	case MoveM64rRd:
		/* begin concretizeMoveM64rRd */
		offset18 = ((self_in_dispatchConcretize->operands))[0];
		srcReg9 = ((self_in_dispatchConcretize->operands))[1];
		destReg10 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((srcReg9 <= 7)
		 && (destReg10 <= 7)) {
			skip18 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip18 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, destReg10, 0, srcReg9));
		}
		((self_in_dispatchConcretize->machineCode))[skip18 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip18 + 2] = 0x7E;
		if (offset18 == 0) {
			if ((srcReg9 & 6) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip18 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg9, destReg10));
				return skip18 + 4;
			}
			if ((srcReg9 & 7) == RSP) {

				/* RBP & R13 fall through */
				((self_in_dispatchConcretize->machineCode))[skip18 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg9, destReg10));
				((self_in_dispatchConcretize->machineCode))[skip18 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg9));
				return skip18 + 5;
			}
		}
		if (isQuick(self_in_dispatchConcretize, offset18)) {
			if ((srcReg9 & 7) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip18 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg9, destReg10));
				((self_in_dispatchConcretize->machineCode))[skip18 + 4] = (offset18 & 0xFF);
				return skip18 + 5;
			}
			((self_in_dispatchConcretize->machineCode))[skip18 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg9, destReg10));
			((self_in_dispatchConcretize->machineCode))[skip18 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg9));
			((self_in_dispatchConcretize->machineCode))[skip18 + 5] = (offset18 & 0xFF);
			return skip18 + 6;
		}
		((self_in_dispatchConcretize->machineCode))[skip18 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg9, destReg10));
		if ((srcReg9 & 7) == RSP) {
			((self_in_dispatchConcretize->machineCode))[skip18 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg9));
			skip18 += 1;
		}
		((self_in_dispatchConcretize->machineCode))[skip18 + 4] = (offset18 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip18 + 5] = (((offset18) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip18 + 6] = (((offset18) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip18 + 7] = (((offset18) >> 24) & 0xFF);
		return skip18 + 8;

	case MoveMwrR:
		/* begin concretizeMoveMwrR */
		offset19 = ((self_in_dispatchConcretize->operands))[0];
		srcReg10 = ((self_in_dispatchConcretize->operands))[1];
		destReg11 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg11, 0, srcReg10));
		((self_in_dispatchConcretize->machineCode))[1] = 139;
		if ((srcReg10 != RSP)
		 && (srcReg10 != R12)) {
			if ((offset19 == 0)
			 && ((srcReg10 != RBP)
			 && (srcReg10 != R13))) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg10, destReg11));
				return 3;
			}
			if (isQuick(self_in_dispatchConcretize, offset19)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg10, destReg11));
				((self_in_dispatchConcretize->machineCode))[3] = (offset19 & 0xFF);
				return 4;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg10, destReg11));
			((self_in_dispatchConcretize->machineCode))[3] = (offset19 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = (((offset19) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset19) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset19) >> 24) & 0xFF);
			return 7;
		}
		if (offset19 == 0) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg10, destReg11));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg10));
			return 4;
		}
		if (isQuick(self_in_dispatchConcretize, offset19)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg10, destReg11));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg10));
			((self_in_dispatchConcretize->machineCode))[4] = (offset19 & 0xFF);
			return 5;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg10, destReg11));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg10));
		((self_in_dispatchConcretize->machineCode))[4] = (offset19 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((offset19) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((offset19) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((offset19) >> 24) & 0xFF);
		return 8;

	case MoveXbrRR:
		/* begin concretizeMoveXbrRR */
		index = ((self_in_dispatchConcretize->operands))[0];
		base = ((self_in_dispatchConcretize->operands))[1];
		dest1 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, dest1, index, base));
		((self_in_dispatchConcretize->machineCode))[1] = 138;
		if ((base != RBP)
		 && (base != R13)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 4, dest1));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, index, base));
			return 4;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, 4, dest1));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, index, base));
		((self_in_dispatchConcretize->machineCode))[4] = 0;
		return 5;

	case MoveRXbrR:
		/* begin concretizeMoveRXbrR */
		src = ((self_in_dispatchConcretize->operands))[0];
		index1 = ((self_in_dispatchConcretize->operands))[1];
		base1 = ((self_in_dispatchConcretize->operands))[2];
		offset20 = 0;
		if ((src > 3)
		 || ((base1 > 7)
		 || (index1 > 7))) {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, src, index1, base1));
			offset20 = 1;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset20] = 136;
		if ((base1 & 7) != RBP) {

			/* RBP,R13 */
			((self_in_dispatchConcretize->machineCode))[1 + offset20] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 4, src));
			((self_in_dispatchConcretize->machineCode))[2 + offset20] = (sib(self_in_dispatchConcretize, SIB1, index1, base1));
			return 3 + offset20;
		}
		((self_in_dispatchConcretize->machineCode))[1 + offset20] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, 4, src));
		((self_in_dispatchConcretize->machineCode))[2 + offset20] = (sib(self_in_dispatchConcretize, SIB1, index1, base1));
		((self_in_dispatchConcretize->machineCode))[3 + offset20] = 0;
		return 4 + offset20;

	case MoveXwrRR:
		/* begin concretizeMoveXwrRR */
		index2 = ((self_in_dispatchConcretize->operands))[0];
		base2 = ((self_in_dispatchConcretize->operands))[1];
		dest2 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, dest2, index2, base2));
		if ((base2 != RBP)
		 && (base2 != R13)) {
			((self_in_dispatchConcretize->machineCode))[1] = 139;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 4, dest2));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB8, index2, base2));
			return 4;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 139;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, 4, dest2));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB8, index2, base2));
		((self_in_dispatchConcretize->machineCode))[4] = 0;
		return 5;

	case MoveRXwrR:
		/* begin concretizeMoveRXwrR */
		src1 = ((self_in_dispatchConcretize->operands))[0];
		index3 = ((self_in_dispatchConcretize->operands))[1];
		base3 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, src1, index3, base3));
		if ((base3 != RBP)
		 && (base3 != R13)) {
			((self_in_dispatchConcretize->machineCode))[1] = 137;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 4, src1));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB8, index3, base3));
			return 4;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 137;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, 4, src1));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB8, index3, base3));
		((self_in_dispatchConcretize->machineCode))[4] = 0;
		return 5;

	case MoveX32rRR:
		return concretizeMoveX32rRR(self_in_dispatchConcretize);

	case MoveRX32rR:
		return concretizeMoveRX32rR(self_in_dispatchConcretize);

	case MoveRMwr:
		/* begin concretizeMoveRMwr */
		srcReg11 = ((self_in_dispatchConcretize->operands))[0];
		offset21 = ((self_in_dispatchConcretize->operands))[1];
		destReg12 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, srcReg11, 0, destReg12));
		((self_in_dispatchConcretize->machineCode))[1] = 137;
		if ((destReg12 != RSP)
		 && (destReg12 != R12)) {
			if ((offset21 == 0)
			 && ((destReg12 != RBP)
			 && (destReg12 != R13))) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg12, srcReg11));
				return 3;
			}
			if (isQuick(self_in_dispatchConcretize, offset21)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg12, srcReg11));
				((self_in_dispatchConcretize->machineCode))[3] = (offset21 & 0xFF);
				return 4;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg12, srcReg11));
			((self_in_dispatchConcretize->machineCode))[3] = (offset21 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = (((offset21) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = (((offset21) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = (((offset21) >> 24) & 0xFF);
			return 7;
		}
		if (offset21 == 0) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg12, srcReg11));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg12));
			return 4;
		}
		if (isQuick(self_in_dispatchConcretize, offset21)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg12, srcReg11));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg12));
			((self_in_dispatchConcretize->machineCode))[4] = (offset21 & 0xFF);
			return 5;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg12, srcReg11));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg12));
		((self_in_dispatchConcretize->machineCode))[4] = (offset21 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((offset21) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((offset21) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((offset21) >> 24) & 0xFF);
		return 8;

	case MoveRM32r:
		/* begin concretizeMoveRM32r */
		srcReg12 = ((self_in_dispatchConcretize->operands))[0];
		offset22 = ((self_in_dispatchConcretize->operands))[1];
		destReg13 = ((self_in_dispatchConcretize->operands))[2];
		if ((srcReg12 <= 7)
		 && (destReg13 <= 7)) {
			skip19 = 0;
		}
		else {
			skip19 = 1;
			((self_in_dispatchConcretize->machineCode))[0] = (rexwrxb(self_in_dispatchConcretize, 0, srcReg12, 0, destReg13));
		}
		((self_in_dispatchConcretize->machineCode))[skip19] = 137;
		if (offset22 == 0) {
			if ((destReg13 & 6) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip19 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg13, srcReg12));
				return skip19 + 2;
			}
			if ((destReg13 & 7) == RSP) {

				/* RBP & R13 fall through */
				((self_in_dispatchConcretize->machineCode))[skip19 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg13, srcReg12));
				((self_in_dispatchConcretize->machineCode))[skip19 + 2] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg13));
				return skip19 + 3;
			}
		}
		if (isQuick(self_in_dispatchConcretize, offset22)) {
			if ((destReg13 & 7) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip19 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg13, srcReg12));
				((self_in_dispatchConcretize->machineCode))[skip19 + 2] = (offset22 & 0xFF);
				return skip19 + 3;
			}
			((self_in_dispatchConcretize->machineCode))[skip19 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg13, srcReg12));
			((self_in_dispatchConcretize->machineCode))[skip19 + 2] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg13));
			((self_in_dispatchConcretize->machineCode))[skip19 + 3] = (offset22 & 0xFF);
			return skip19 + 4;
		}
		((self_in_dispatchConcretize->machineCode))[skip19 + 1] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg13, srcReg12));
		if ((destReg13 & 7) == RSP) {
			((self_in_dispatchConcretize->machineCode))[skip19 + 2] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg13));
			skip19 += 1;
		}
		((self_in_dispatchConcretize->machineCode))[skip19 + 2] = (offset22 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip19 + 3] = (((offset22) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip19 + 4] = (((offset22) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip19 + 5] = (((offset22) >> 24) & 0xFF);
		return skip19 + 6;

	case MoveRsM32r:
		/* begin concretizeMoveRsM32r */
		srcReg13 = ((self_in_dispatchConcretize->operands))[0];
		offset23 = ((self_in_dispatchConcretize->operands))[1];
		destReg14 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		if ((srcReg13 <= 7)
		 && (destReg14 <= 7)) {
			skip20 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip20 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, srcReg13, 0, destReg14));
		}
		((self_in_dispatchConcretize->machineCode))[skip20 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip20 + 2] = 0x7E;
		if (offset23 == 0) {
			if ((destReg14 & 6) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip20 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg14, srcReg13));
				return skip20 + 4;
			}
			if ((destReg14 & 7) == RSP) {

				/* RBP & R13 fall through */
				((self_in_dispatchConcretize->machineCode))[skip20 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg14, srcReg13));
				((self_in_dispatchConcretize->machineCode))[skip20 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg14));
				return skip20 + 5;
			}
		}
		if (isQuick(self_in_dispatchConcretize, offset23)) {
			if ((destReg14 & 7) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip20 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg14, srcReg13));
				((self_in_dispatchConcretize->machineCode))[skip20 + 4] = (offset23 & 0xFF);
				return skip20 + 5;
			}
			((self_in_dispatchConcretize->machineCode))[skip20 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg14, srcReg13));
			((self_in_dispatchConcretize->machineCode))[skip20 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg14));
			((self_in_dispatchConcretize->machineCode))[skip20 + 5] = (offset23 & 0xFF);
			return skip20 + 6;
		}
		((self_in_dispatchConcretize->machineCode))[skip20 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg14, srcReg13));
		if ((destReg14 & 7) == RSP) {
			((self_in_dispatchConcretize->machineCode))[skip20 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg14));
			skip20 += 1;
		}
		((self_in_dispatchConcretize->machineCode))[skip20 + 4] = (offset23 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip20 + 5] = (((offset23) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip20 + 6] = (((offset23) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip20 + 7] = (((offset23) >> 24) & 0xFF);
		return skip20 + 8;

	case MoveRdM64r:
		/* begin concretizeMoveRdM64r */
		srcReg14 = ((self_in_dispatchConcretize->operands))[0];
		offset24 = ((self_in_dispatchConcretize->operands))[1];
		destReg15 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		if ((srcReg14 <= 7)
		 && (destReg15 <= 7)) {
			skip21 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip21 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, srcReg14, 0, destReg15));
		}
		((self_in_dispatchConcretize->machineCode))[skip21 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip21 + 2] = 214;
		if (offset24 == 0) {
			if ((destReg15 & 6) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip21 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg15, srcReg14));
				return skip21 + 4;
			}
			if ((destReg15 & 7) == RSP) {

				/* RBP & R13 fall through */
				((self_in_dispatchConcretize->machineCode))[skip21 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg15, srcReg14));
				((self_in_dispatchConcretize->machineCode))[skip21 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg15));
				return skip21 + 5;
			}
		}
		if (isQuick(self_in_dispatchConcretize, offset24)) {
			if ((destReg15 & 7) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip21 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg15, srcReg14));
				((self_in_dispatchConcretize->machineCode))[skip21 + 4] = (offset24 & 0xFF);
				return skip21 + 5;
			}
			((self_in_dispatchConcretize->machineCode))[skip21 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg15, srcReg14));
			((self_in_dispatchConcretize->machineCode))[skip21 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg15));
			((self_in_dispatchConcretize->machineCode))[skip21 + 5] = (offset24 & 0xFF);
			return skip21 + 6;
		}
		((self_in_dispatchConcretize->machineCode))[skip21 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg15, srcReg14));
		if ((destReg15 & 7) == RSP) {
			((self_in_dispatchConcretize->machineCode))[skip21 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg15));
			skip21 += 1;
		}
		((self_in_dispatchConcretize->machineCode))[skip21 + 4] = (offset24 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip21 + 5] = (((offset24) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip21 + 6] = (((offset24) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip21 + 7] = (((offset24) >> 24) & 0xFF);
		return skip21 + 8;

	case MoveRdR:
		/* begin concretizeMoveRdR */
		srcReg15 = ((self_in_dispatchConcretize->operands))[0];
		destReg16 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		((self_in_dispatchConcretize->machineCode))[1] = (rexRxb(self_in_dispatchConcretize, srcReg15, 0, destReg16));
		((self_in_dispatchConcretize->machineCode))[2] = 15;
		((self_in_dispatchConcretize->machineCode))[3] = 0x7E;
		((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, destReg16, srcReg15));
		return 5;

	case MoveRRd:
		/* begin concretizeMoveRRd */
		srcReg16 = ((self_in_dispatchConcretize->operands))[0];
		destReg17 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		((self_in_dispatchConcretize->machineCode))[1] = (rexRxb(self_in_dispatchConcretize, destReg17, 0, srcReg16));
		((self_in_dispatchConcretize->machineCode))[2] = 15;
		((self_in_dispatchConcretize->machineCode))[3] = 110;
		((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg16, destReg17));
		return 5;

	case MoveRdRd:
		/* begin concretizeMoveRdRd */
		srcReg17 = ((self_in_dispatchConcretize->operands))[0];
		destReg18 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		if ((srcReg17 <= 7)
		 && (destReg18 <= 7)) {
			skip22 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip22 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, srcReg17, 0, destReg18));
		}
		((self_in_dispatchConcretize->machineCode))[skip22 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip22 + 2] = 17;
		((self_in_dispatchConcretize->machineCode))[skip22 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, destReg18, srcReg17));
		return skip22 + 4;

	case MoveRsRs:
		/* begin concretizeMoveRsRs */
		srcReg18 = ((self_in_dispatchConcretize->operands))[0];
		destReg19 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((srcReg18 <= 7)
		 && (destReg19 <= 7)) {
			skip23 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip23 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, srcReg18, 0, destReg19));
		}
		((self_in_dispatchConcretize->machineCode))[skip23 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip23 + 2] = 17;
		((self_in_dispatchConcretize->machineCode))[skip23 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, destReg19, srcReg18));
		return skip23 + 4;

	case PopR:
		/* begin concretizePopR */
		reg19 = ((self_in_dispatchConcretize->operands))[0];
		if (reg19 < 8) {
			((self_in_dispatchConcretize->machineCode))[0] = (88 + reg19);
			return 1;
		}
		((self_in_dispatchConcretize->machineCode))[0] = 65;
		((self_in_dispatchConcretize->machineCode))[1] = (88 + (reg19 - 8));
		return 2;

	case PushR:
		/* begin concretizePushR */
		reg20 = ((self_in_dispatchConcretize->operands))[0];
		if (reg20 < 8) {
			((self_in_dispatchConcretize->machineCode))[0] = (80 + reg20);
			return 1;
		}
		((self_in_dispatchConcretize->machineCode))[0] = 65;
		((self_in_dispatchConcretize->machineCode))[1] = (80 + (reg20 - 8));
		return 2;

	case PushCq:
		/* begin concretizePushCq */
		value6 = ((self_in_dispatchConcretize->operands))[0];
		if (isQuick(self_in_dispatchConcretize, value6)) {
			((self_in_dispatchConcretize->machineCode))[0] = 106;
			((self_in_dispatchConcretize->machineCode))[1] = (value6 & 0xFF);
			return 2;
		}
		if (is32BitSignedImmediate(self_in_dispatchConcretize, value6)) {
			((self_in_dispatchConcretize->machineCode))[0] = 104;
			((self_in_dispatchConcretize->machineCode))[1] = (value6 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[2] = (((value6) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[3] = (((value6) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = (((value6) >> 24) & 0xFF);
			return 5;
		}
		/* begin concretizePushCw */
		value11 = ((self_in_dispatchConcretize->operands))[0];
		if ((addressIsInInstructions(((AbstractInstruction *) value11)))
		 || ((((AbstractInstruction *) value11)) == (methodLabel()))) {
			value11 = ((((AbstractInstruction *) value11))->address);
		}
		if (((((usqInt)value11)) >= ((methodLabel->address)))
		 && ((((usqInt)value11)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))) {
			offset28 = value11 - (((self_in_dispatchConcretize->address)) + 7);
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, RISCTempReg, 0, 0));
			((self_in_dispatchConcretize->machineCode))[1] = 141;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 5, RISCTempReg));
			((self_in_dispatchConcretize->machineCode))[3] = (offset28 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset28)) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset28)) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt)(offset28)) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = 65;
			((self_in_dispatchConcretize->machineCode))[8] = (72 + RISCTempReg);
			return 9;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, RISCTempReg, 0, RISCTempReg));
		((self_in_dispatchConcretize->machineCode))[1] = (184 + (RISCTempReg & 7));
		((self_in_dispatchConcretize->machineCode))[2] = (value11 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = (((value11) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = (((value11) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((value11) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((value11) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((value11) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = (((value11) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = (((value11) >> 56) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[10] = 65;
		((self_in_dispatchConcretize->machineCode))[11] = (72 + RISCTempReg);
		assert((((self_in_dispatchConcretize->machineCode))[11]) < 144);
		return 12;

	case PushCw:
		/* begin concretizePushCw */
		value5 = ((self_in_dispatchConcretize->operands))[0];
		if ((addressIsInInstructions(((AbstractInstruction *) value5)))
		 || ((((AbstractInstruction *) value5)) == (methodLabel()))) {
			value5 = ((((AbstractInstruction *) value5))->address);
		}
		if (((((usqInt)value5)) >= ((methodLabel->address)))
		 && ((((usqInt)value5)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))) {
			offset25 = value5 - (((self_in_dispatchConcretize->address)) + 7);
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, RISCTempReg, 0, 0));
			((self_in_dispatchConcretize->machineCode))[1] = 141;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 5, RISCTempReg));
			((self_in_dispatchConcretize->machineCode))[3] = (offset25 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt)(offset25)) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt)(offset25)) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt)(offset25)) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = 65;
			((self_in_dispatchConcretize->machineCode))[8] = (72 + RISCTempReg);
			return 9;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, RISCTempReg, 0, RISCTempReg));
		((self_in_dispatchConcretize->machineCode))[1] = (184 + (RISCTempReg & 7));
		((self_in_dispatchConcretize->machineCode))[2] = (value5 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = (((value5) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = (((value5) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = (((value5) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = (((value5) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = (((value5) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = (((value5) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = (((value5) >> 56) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[10] = 65;
		((self_in_dispatchConcretize->machineCode))[11] = (72 + RISCTempReg);
		assert((((self_in_dispatchConcretize->machineCode))[11]) < 144);
		return 12;

	case PrefetchAw:
		return concretizePrefetchAw(self_in_dispatchConcretize);

	case ConvertRRd:
		/* begin concretizeConvertRRd */
		srcReg19 = ((self_in_dispatchConcretize->operands))[0];
		destReg20 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		((self_in_dispatchConcretize->machineCode))[1] = (rexRxb(self_in_dispatchConcretize, destReg20, 0, srcReg19));
		((self_in_dispatchConcretize->machineCode))[2] = 15;
		((self_in_dispatchConcretize->machineCode))[3] = 42;
		((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg19, destReg20));
		return 5;

	case ConvertRdR:
		/* begin concretizeConvertRdR */
		srcReg20 = ((self_in_dispatchConcretize->operands))[0];
		destReg21 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		((self_in_dispatchConcretize->machineCode))[1] = (rexRxb(self_in_dispatchConcretize, destReg21, 0, srcReg20));
		((self_in_dispatchConcretize->machineCode))[2] = 15;
		((self_in_dispatchConcretize->machineCode))[3] = 45;
		((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg20, destReg21));
		return 5;

	case ConvertRRs:
		/* begin concretizeConvertRRs */
		srcReg21 = ((self_in_dispatchConcretize->operands))[0];
		destReg22 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((srcReg21 <= 7)
		 && (destReg22 <= 7)) {
			skip24 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip24 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, destReg22, 0, srcReg21));
		}
		((self_in_dispatchConcretize->machineCode))[skip24 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip24 + 2] = 42;
		((self_in_dispatchConcretize->machineCode))[skip24 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg21, destReg22));
		return skip24 + 4;

	case ConvertRsR:
		/* begin concretizeConvertRsR */
		srcReg22 = ((self_in_dispatchConcretize->operands))[0];
		destReg23 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((srcReg22 <= 7)
		 && (destReg23 <= 7)) {
			skip25 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip25 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, destReg23, 0, srcReg22));
		}
		((self_in_dispatchConcretize->machineCode))[skip25 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip25 + 2] = 45;
		((self_in_dispatchConcretize->machineCode))[skip25 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg22, destReg23));
		return skip25 + 4;

	case ConvertRsRd:
		/* begin concretizeConvertRsRd */
		srcReg23 = ((self_in_dispatchConcretize->operands))[0];
		destReg24 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((srcReg23 <= 7)
		 && (destReg24 <= 7)) {
			skip26 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip26 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, destReg24, 0, srcReg23));
		}
		((self_in_dispatchConcretize->machineCode))[skip26 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip26 + 2] = 90;
		((self_in_dispatchConcretize->machineCode))[skip26 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg23, destReg24));
		return skip26 + 4;

	case ConvertRdRs:
		/* begin concretizeConvertRdRs */
		srcReg24 = ((self_in_dispatchConcretize->operands))[0];
		destReg25 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		if ((srcReg24 <= 7)
		 && (destReg25 <= 7)) {
			skip27 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip27 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, destReg25, 0, srcReg24));
		}
		((self_in_dispatchConcretize->machineCode))[skip27 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip27 + 2] = 90;
		((self_in_dispatchConcretize->machineCode))[skip27 + 3] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg24, destReg25));
		return skip27 + 4;

	case SignExtend8RR:
		/* begin concretizeSignExtend8RR */
		srcReg25 = ((self_in_dispatchConcretize->operands))[0];
		destReg26 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexwrxb(self_in_dispatchConcretize, 1, destReg26, 0, srcReg25));
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 190;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg25, destReg26));
		return 4;

	case SignExtend16RR:
		/* begin concretizeSignExtend16RR */
		srcReg26 = ((self_in_dispatchConcretize->operands))[0];
		destReg27 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexwrxb(self_in_dispatchConcretize, 1, destReg27, 0, srcReg26));
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 191;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg26, destReg27));
		return 4;

	case SignExtend32RR:
		/* begin concretizeSignExtend32RR */
		srcReg27 = ((self_in_dispatchConcretize->operands))[0];
		destReg28 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexwrxb(self_in_dispatchConcretize, 1, destReg28, 0, srcReg27));
		((self_in_dispatchConcretize->machineCode))[1] = 99;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg27, destReg28));
		return 3;

	case ZeroExtend8RR:
		/* begin concretizeZeroExtend8RR */
		srcReg28 = ((self_in_dispatchConcretize->operands))[0];
		destReg29 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexwrxb(self_in_dispatchConcretize, 1, destReg29, 0, srcReg28));
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 182;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg28, destReg29));
		return 4;

	case ZeroExtend16RR:
		/* begin concretizeZeroExtend16RR */
		srcReg29 = ((self_in_dispatchConcretize->operands))[0];
		destReg30 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexwrxb(self_in_dispatchConcretize, 1, destReg30, 0, srcReg29));
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 183;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg29, destReg30));
		return 4;

	case ZeroExtend32RR:
		/* begin concretizeZeroExtend32RR */
		srcReg30 = ((self_in_dispatchConcretize->operands))[0];
		destReg31 = ((self_in_dispatchConcretize->operands))[1];
		if ((srcReg30 <= 7)
		 && (destReg31 <= 7)) {
			skip28 = 0;
		}
		else {
			skip28 = 1;
			((self_in_dispatchConcretize->machineCode))[0] = (rexwrxb(self_in_dispatchConcretize, 0, destReg31, 0, srcReg30));
		}
		((self_in_dispatchConcretize->machineCode))[skip28] = 139;
		((self_in_dispatchConcretize->machineCode))[skip28 + 1] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg30, destReg31));
		return skip28 + 2;

	case MovePerfCnt64RL:
		return concretizeMovePerfCnt64RL(self_in_dispatchConcretize);

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}


/*	Attempt to generate concrete machine code for the instruction at address.
	This is part of the inner dispatch of concretizeAt: actualAddress which
	exists only
	to get around the number of literals limits in the SqueakV3 (blue book
	derived) bytecode set. */

	/* CogX64Compiler>>#dispatchConcretizeProcessorSpecific */
static sqInt NoDbgRegParms
dispatchConcretizeProcessorSpecific(AbstractInstruction * self_in_dispatchConcretizeProcessorSpecific)
{
    usqInt addressOperand;
    usqInt addressReg;
    usqInt dest;
    usqInt maskReg;
    sqInt offset;
    usqInt reg;
    usqInt reg1;
    usqInt reg2;
    usqInt regDivisor;
    usqInt valueReg;

	switch ((self_in_dispatchConcretizeProcessorSpecific->opcode)) {
	case CPUID:
		/* begin concretizeCPUID */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = 15;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 162;
		return 2;

	case CDQ:
		/* begin concretizeCDQ */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = 72;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 153;
		return 2;

	case IDIVR:
		/* begin concretizeIDIVR */
		regDivisor = ((self_in_dispatchConcretizeProcessorSpecific->operands))[0];
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = (rexRxb(self_in_dispatchConcretizeProcessorSpecific, 0, 0, regDivisor));
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 247;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[2] = (modRMRO(self_in_dispatchConcretizeProcessorSpecific, ModReg, regDivisor, 7));
		return 3;

	case IMULRR:
		/* begin concretizeMulRR */
		reg1 = ((self_in_dispatchConcretizeProcessorSpecific->operands))[0];
		reg2 = ((self_in_dispatchConcretizeProcessorSpecific->operands))[1];
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = (rexRxb(self_in_dispatchConcretizeProcessorSpecific, reg2, 0, reg1));
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 15;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[2] = 175;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[3] = (modRMRO(self_in_dispatchConcretizeProcessorSpecific, ModReg, reg1, reg2));
		return 4;

	case XCHGRR:
		return concretizeXCHGRR(self_in_dispatchConcretizeProcessorSpecific);

	case REP:
		/* begin concretizeREP */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = 243;
		return 1;

	case CLD:
		/* begin concretizeCLD */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = 0xFC;
		return 1;

	case MOVSB:
		/* begin concretizeMOVSB */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = 164;
		return 1;

	case MOVSQ:
		/* begin concretizeMOVSQ */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = (rexwrxb(self_in_dispatchConcretizeProcessorSpecific, 1, 0, 0, 0));
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 165;
		return 2;

	case BSR:
		/* begin concretizeBSR */
		maskReg = ((self_in_dispatchConcretizeProcessorSpecific->operands))[0];
		dest = ((self_in_dispatchConcretizeProcessorSpecific->operands))[1];
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = (rexwrxb(self_in_dispatchConcretizeProcessorSpecific, 1, dest, 0, maskReg));
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 15;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[2] = 189;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[3] = (modRMRO(self_in_dispatchConcretizeProcessorSpecific, ModReg, maskReg, dest));
		return 4;

	case MFENCE:
		/* begin concretizeFENCE: */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = 15;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 174;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[2] = (modRMRO(self_in_dispatchConcretizeProcessorSpecific, ModReg, 0, 6));
		return 3;

	case SFENCE:
		/* begin concretizeFENCE: */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = 15;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 174;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[2] = (modRMRO(self_in_dispatchConcretizeProcessorSpecific, ModReg, 0, 7));
		return 3;

	case LOCK:
		/* begin concretizeLOCK */
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = 240;
		return 1;

	case MoveRAwNoVBR:
		/* begin concretizeMoveRAwNoVBR */
		reg = ((self_in_dispatchConcretizeProcessorSpecific->operands))[0];
		addressOperand = ((self_in_dispatchConcretizeProcessorSpecific->operands))[1];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand)))
		 || ((((AbstractInstruction *) addressOperand)) == (methodLabel()))) {
			addressOperand = ((((AbstractInstruction *) addressOperand))->address);
		}
		if ((reg == RAX)
		 || ((reg == RBP)
		 || (reg == RSP))) {
			offset = 0;
		}
		else {
			if ((reg == RBP)
			 || (reg == RSP)) {
				((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = (rexRxb(self_in_dispatchConcretizeProcessorSpecific, reg, 0, RAX));
				((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 137;
				((self_in_dispatchConcretizeProcessorSpecific->machineCode))[2] = (modRMRO(self_in_dispatchConcretizeProcessorSpecific, ModReg, RAX, reg));
				offset = 3;
			}
			else {
				((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = (rexRxb(self_in_dispatchConcretizeProcessorSpecific, RAX, 0, reg));
				((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = (144 + (reg % 8));
				offset = 2;
			}
		}
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0 + offset] = 72;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1 + offset] = 163;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[2 + offset] = (addressOperand & 0xFF);
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[3 + offset] = (((addressOperand) >> 8) & 0xFF);
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[4 + offset] = (((addressOperand) >> 16) & 0xFF);
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[5 + offset] = (((addressOperand) >> 24) & 0xFF);
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[6 + offset] = (((addressOperand) >> 32) & 0xFF);
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[7 + offset] = (((addressOperand) >> 40) & 0xFF);
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[8 + offset] = (((addressOperand) >> 48) & 0xFF);
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[9 + offset] = (((addressOperand) >> 56) & 0xFF);
		if (reg == RAX) {
			return 10;
		}
		if ((reg == RBP)
		 || (reg == RSP)) {
			return 13;
		}
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[12] = (((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0]);
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[13] = (((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1]);
		return 14;

	case CMPXCHGRMr:
		/* begin concretizeCMPXCHGRMr */
		valueReg = ((self_in_dispatchConcretizeProcessorSpecific->operands))[0];
		addressReg = ((self_in_dispatchConcretizeProcessorSpecific->operands))[1];
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[0] = (rexRxb(self_in_dispatchConcretizeProcessorSpecific, valueReg, 0, addressReg));
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[1] = 15;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[2] = 177;
		((self_in_dispatchConcretizeProcessorSpecific->machineCode))[3] = (modRMRO(self_in_dispatchConcretizeProcessorSpecific, ModRegInd, addressReg, valueReg));
		return 4;

	case SETE:
		return concretizeSet(self_in_dispatchConcretizeProcessorSpecific, 4);

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}

	/* CogX64Compiler>>#fullCallsAreRelative */
static sqInt NoDbgRegParms
fullCallsAreRelative(AbstractInstruction * self_in_fullCallsAreRelative)
{
	return 0;
}

	/* CogX64Compiler>>#genDivR:R:Quo:Rem: */
static AbstractInstruction * NoDbgRegParms
genDivRRQuoRem(AbstractInstruction * self_in_genDivRRQuoRem, sqInt abstractRegDivisor, sqInt abstractRegDividend, sqInt abstractRegQuotient, sqInt abstractRegRemainder)
{
    sqInt rDividend;
    sqInt rDivisor;
    sqInt reg;
    sqInt rQuotient;
    sqInt rRemainder;
    sqInt rUnused;
    sqInt saveRestoreEAX;
    sqInt saveRestoreEDX;
    sqInt saveRestoreExchanged;

	assert(abstractRegDividend != abstractRegDivisor);
	assert(abstractRegQuotient != abstractRegRemainder);
	rDividend = abstractRegDividend;
	rDivisor = abstractRegDivisor;
	rQuotient = abstractRegQuotient;

	/* IDIV r does a signed divide of RDX:RAX by r, RAX := Quotient, RDX := Remainder.
	   Since we must sign extend the dividend into RDX we must substitute another register if RDX is an input. */
	rRemainder = abstractRegRemainder;
	if ((rDividend == RDX)
	 || (rDivisor == RDX)) {

		/* Slang, sigh... */
		rUnused = RAX;
		while (rUnused <= RDI) {
			if ((rUnused != RSP)
			 && ((rUnused != RBP)
			 && ((rUnused != RDX)
			 && ((rUnused != rDividend)
			 && ((rUnused != rDivisor)
			 && ((rUnused != rQuotient)
			 && (rUnused != rRemainder))))))) {
				/* begin PushR: */
				genoperand(PushR, rUnused);
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RDX, rUnused);
				if (rDividend == RDX) {
					genDivRRQuoRem(self_in_genDivRRQuoRem, rDivisor, rUnused, rQuotient, rRemainder);
				}
				else {
					genDivRRQuoRem(self_in_genDivRRQuoRem, rUnused, rDividend, rQuotient, rRemainder);
				}
				/* begin PopR: */
				genoperand(PopR, rUnused);
				return self_in_genDivRRQuoRem;
			}
			rUnused += 1;
		}
		error("couldn't find unused register in genDivR:R:Quo:Rem:");
	}
	if ((saveRestoreEAX = (rQuotient != RAX)
	 && (rRemainder != RAX))) {
		/* begin PushR: */
		genoperand(PushR, RAX);
	}
	if ((saveRestoreEDX = (rQuotient != RDX)
	 && (rRemainder != RDX))) {
		/* begin PushR: */
		genoperand(PushR, RDX);
	}
	saveRestoreExchanged = -1;
	if (rDividend != RAX) {
		if (rDivisor == RAX) {
			if (((rDividend != rQuotient)
			 && (rDividend != rRemainder))
			 && ((rDividend != RDX)
			 || (!saveRestoreEDX))) {
				/* begin PushR: */
				reg = (saveRestoreExchanged = rDividend);
				genoperand(PushR, reg);
			}
			genoperandoperand(XCHGRR, rDivisor, rDividend);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, rDividend, RAX);
		}
	}
	gen(CDQ);
	genoperand(IDIVR, (rDivisor == RAX
		? rDividend
		: rDivisor));
	if ((rQuotient == RDX)
	 && (rRemainder == RAX)) {
		genoperandoperand(XCHGRR, rQuotient, rRemainder);
	}
	else {
		if (rQuotient == RDX) {
			if (rRemainder != RDX) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RDX, rRemainder);
			}
			if (rQuotient != RAX) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RAX, rQuotient);
			}
		}
		else {
			if (rQuotient != RAX) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RAX, rQuotient);
			}
			if (rRemainder != RDX) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RDX, rRemainder);
			}
		}
	}
	if (saveRestoreExchanged >= 0) {
		/* begin PopR: */
		genoperand(PopR, saveRestoreExchanged);
	}
	if (saveRestoreEDX) {
		/* begin PopR: */
		genoperand(PopR, RDX);
	}
	if (saveRestoreEAX) {
		/* begin PopR: */
		genoperand(PopR, RAX);
	}
	return 0;
}


/*	Get the abstract registers for ECX, EDI and ESI */

	/* CogX64Compiler>>#genMemCopy:to:constantSize: */
static void NoDbgRegParms
genMemCopytoconstantSize(AbstractInstruction * self_in_genMemCopytoconstantSize, sqInt originalSourceReg, sqInt originalDestReg, sqInt size)
{
    sqInt countReg;
    sqInt destReg;
    AbstractInstruction *inst;
    sqInt numbytes;
    sqInt numwords;
    sqInt sourceReg;

	sourceReg = RSI;
	destReg = RDI;

	/* Put the source in ESI and the dest in EDI */
	countReg = RCX;
	/* begin Label */
	inst = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (originalSourceReg != sourceReg) {
		if (originalDestReg == sourceReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, originalDestReg, TempReg);
		}
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, originalSourceReg, sourceReg);
	}
	if (originalDestReg != destReg) {
		if (originalDestReg == sourceReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, TempReg, destReg);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, originalDestReg, destReg);
		}
	}
	gen(CLD);
	numbytes = size & 7;
	if (numbytes > 0) {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, numbytes, countReg);
		gen(REP);
		gen(MOVSB);
	}
	numwords = size / 8;
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, numwords, countReg);
	gen(REP);
	gen(MOVSQ);
}


/*	Get the abstract registers for ECX, EDI and ESI */

	/* CogX64Compiler>>#genMemCopy:to:size: */
static void NoDbgRegParms
genMemCopytosize(AbstractInstruction * self_in_genMemCopytosize, sqInt originalSourceReg, sqInt originalDestReg, sqInt originalSize)
{
    sqInt countReg;
    sqInt destReg;
    AbstractInstruction *inst;
    sqInt size;
    sqInt sourceReg;
    sqInt spilledSize;

	sourceReg = RSI;
	destReg = RDI;

	/* TODO: Avoid spilling */
	countReg = RCX;
	spilledSize = 0;
	if ((originalSize == sourceReg)
	 || (originalSize == destReg)) {
		/* begin PushR: */
		genoperand(PushR, originalSize);
		spilledSize = 1;
	}
	/* begin Label */
	inst = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (originalSourceReg != sourceReg) {
		if (originalDestReg == sourceReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, originalDestReg, TempReg);
		}
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, originalSourceReg, sourceReg);
	}
	if (originalDestReg != destReg) {
		if (originalDestReg == sourceReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, TempReg, destReg);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, originalDestReg, destReg);
		}
	}
	if (spilledSize) {
		/* begin PopR: */
		genoperand(PopR, TempReg);
		size = TempReg;
	}
	else {
		if (originalSize == countReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, originalSize, TempReg);
			size = TempReg;
		}
		else {
			size = originalSize;
		}
	}
	gen(CLD);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, size, countReg);
	/* begin AndCq:R: */
	genoperandoperand(AndCqR, 7, countReg);
	gen(REP);
	gen(MOVSB);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, size, countReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 3, countReg);
	gen(REP);
	gen(MOVSQ);
}

	/* CogX64Compiler>>#genMulR:R: */
static AbstractInstruction * NoDbgRegParms
genMulRR(AbstractInstruction * self_in_genMulRR, sqInt regSource, sqInt regDest)
{
	return genoperandoperand(IMULRR, regSource, regDest);
}


/*	Ensure that the register args are pushed before the outer and
	inner retpcs at an entry miss for arity <= self numRegArgs. The
	outer retpc is that of a call at a send site. The inner is the call
	from a method or PIC abort/miss to the trampoline. */
/*	This won't be as clumsy on a RISC. But putting the receiver and
	args above the return address means the CoInterpreter has a
	single machine-code frame format which saves us a lot of work. */
/*	Iff there are register args convert
	base	->	outerRetpc		(send site retpc)
	sp		->	innerRetpc		(PIC abort/miss retpc)
	to
	base	->	receiver
	(arg0)
	(arg1)
	outerRetpc
	sp		->	innerRetpc		(PIC abort/miss retpc) */

	/* CogX64Compiler>>#genPushRegisterArgsForAbortMissNumArgs: */
static AbstractInstruction * NoDbgRegParms
genPushRegisterArgsForAbortMissNumArgs(AbstractInstruction * self_in_genPushRegisterArgsForAbortMissNumArgs, sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;

	if (numArgs <= (numRegArgs())) {
		assert((numRegArgs()) <= 2);
		if (numArgs == 0) {
			/* begin MoveMw:r:R: */
			genoperandoperandoperand(MoveMwrR, 0, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveMw:r:R: */
			
			BytesPerWord * 2;
			anInstruction = genoperandoperandoperand(MoveMwrR, BytesPerWord * 2, SPReg, TempReg);
			/* begin MoveR:Mw:r: */
			
			BytesPerWord;
			anInstruction1 = genoperandoperandoperand(MoveRMwr, TempReg, BytesPerWord, SPReg);
			/* begin MoveR:Mw:r: */
			
			2 * BytesPerWord;
			anInstruction2 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 2 * BytesPerWord, SPReg);
			return self_in_genPushRegisterArgsForAbortMissNumArgs;
		}
		if (numArgs == 1) {
			/* begin MoveMw:r:R: */
			
			BytesPerWord;
			anInstruction3 = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveMw:r:R: */
			
			BytesPerWord;
			anInstruction4 = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveR:Mw:r: */
			
			3 * BytesPerWord;
			anInstruction5 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 3 * BytesPerWord, SPReg);
			/* begin MoveR:Mw:r: */
			
			2 * BytesPerWord;
			anInstruction6 = genoperandoperandoperand(MoveRMwr, Arg0Reg, 2 * BytesPerWord, SPReg);
			return self_in_genPushRegisterArgsForAbortMissNumArgs;
		}
		if (numArgs == 2) {
			/* begin PushR: */
			genoperand(PushR, Arg1Reg);
			/* begin MoveMw:r:R: */
			
			BytesPerWord * 2;
			anInstruction7 = genoperandoperandoperand(MoveMwrR, BytesPerWord * 2, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveMw:r:R: */
			
			BytesPerWord * 2;
			anInstruction8 = genoperandoperandoperand(MoveMwrR, BytesPerWord * 2, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveR:Mw:r: */
			
			4 * BytesPerWord;
			anInstruction9 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 4 * BytesPerWord, SPReg);
			/* begin MoveR:Mw:r: */
			
			3 * BytesPerWord;
			anInstruction10 = genoperandoperandoperand(MoveRMwr, Arg0Reg, 3 * BytesPerWord, SPReg);
			return self_in_genPushRegisterArgsForAbortMissNumArgs;
		}
	}
	return 0;
}


/*	Ensure that the register args are pushed before the retpc for arity <=
	self numRegArgs. This
	isn't as clumsy on a RISC. But putting the receiver and args above the
	return address
	means the CoInterpreter has a single machine-code frame format which saves
	us a lot of work.
	N.B. Take great care to /not/ smash TempReg, which is used in directed
	send marshalling.
	We could use XCHG to swap the ReceiverResultReg and top-of-stack return
	address, pushing the
	the ret pc (now in ReceiverResultReg) later, but XCHG is very slow. We can
	use SendNumArgsReg
	because it is only live in sends of arity >= (NumSendTrampolines - 1). */

	/* CogX64Compiler>>#genPushRegisterArgsForNumArgs:scratchReg: */
static void NoDbgRegParms
genPushRegisterArgsForNumArgsscratchReg(AbstractInstruction * self_in_genPushRegisterArgsForNumArgsscratchReg, sqInt numArgs, sqInt scratchReg)
{
	assert((numRegArgs()) < (NumSendTrampolines - 1));
	if (numArgs <= (numRegArgs())) {
		assert((numRegArgs()) <= 2);
		
		/* a.k.a.
		   cogit gen: XCHGMwrR operand: 0 operand: SPReg operand: ReceiverResultReg.
		   but XCHG is slow. */
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, SPReg, scratchReg);
		/* begin MoveR:Mw:r: */
		genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 0, SPReg);
		if (numArgs > 0) {
			/* begin PushR: */
			genoperand(PushR, Arg0Reg);
			if (numArgs > 1) {
				/* begin PushR: */
				genoperand(PushR, Arg1Reg);
			}
		}
		/* begin PushR: */
		genoperand(PushR, scratchReg);
	}
}


/*	This is a no-op on x64 SysV since the ABI passes up to 6 args in registers
	and trampolines currently observe a limit of 4.
	But the WIN64 ABI always reserve shadow space for saving up to 4 parameter
	registers (even if less than 4 args).
 */

	/* CogX64Compiler>>#genRemoveNArgsFromStack: */
static sqInt NoDbgRegParms
genRemoveNArgsFromStack(AbstractInstruction * self_in_genRemoveNArgsFromStack, sqInt n)
{
	assert(n <= 4);
	return 0;
}


/*	Restore the registers in regMask as saved by genSaveRegs:. */

	/* CogX64Compiler>>#genRestoreRegs: */
static sqInt NoDbgRegParms
genRestoreRegs(AbstractInstruction * self_in_genRestoreRegs, sqInt regMask)
{
    sqInt reg;

	assert(!((((regMask & (registerMaskForand(RSP, RBP))) != 0))));
	for (reg = RAX; reg <= R15; reg += 1) {
		if (((regMask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))) != 0)) {
			/* begin PopR: */
			genoperand(PopR, reg);
		}
	}
	return 0;
}


/*	Save the registers in regMask for a call into the C run-time from a
	trampoline. 
 */

	/* CogX64Compiler>>#genSaveRegs: */
static sqInt NoDbgRegParms
genSaveRegs(AbstractInstruction * self_in_genSaveRegs, sqInt regMask)
{
    sqInt reg;

	assert(((R15 - RAX) + 1) == 16);
	assert(!((((regMask & (registerMaskForand(RSP, RBP))) != 0))));
	for (reg = R15; reg >= RAX; reg += -1) {
		if (((regMask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))) != 0)) {
			/* begin PushR: */
			genoperand(PushR, reg);
		}
	}
	return 0;
}

	/* CogX64Compiler>>#genSubstituteReturnAddress: */
static AbstractInstruction * NoDbgRegParms
genSubstituteReturnAddress(AbstractInstruction * self_in_genSubstituteReturnAddress, sqInt retpc)
{
	/* begin gen:literal: */
	return genoperand(PushCw, retpc);
}

	/* CogX64Compiler>>#genSwapR:R:Scratch: */
static AbstractInstruction * NoDbgRegParms
genSwapRRScratch(AbstractInstruction * self_in_genSwapRRScratch, sqInt regA, sqInt regB, sqInt regTmp)
{
	return genoperandoperand(XCHGRR, regA, regB);
}


/*	Answer if the processor has a dedicated callee-saved register to point to
	the base of commonly-accessed variables. */

	/* CogX64Compiler>>#hasVarBaseRegister */
static sqInt NoDbgRegParms
hasVarBaseRegister(AbstractInstruction * self_in_hasVarBaseRegister)
{
	return 1;
}


/*	Answer the instruction size at pc. This is used in method disassembly
	to decode the jumps in block dispatch to discover where block methods
	occur within a larger method. This is very far from a full decode. */

	/* CogX64Compiler>>#instructionSizeAt: */
static sqInt NoDbgRegParms
instructionSizeAt(AbstractInstruction * self_in_instructionSizeAt, sqInt pc)
{
    sqInt op;

	op = byteAt(pc);
	if ((op & 0xF8) == 72) {
		return 1 + (instructionSizeAt(self_in_instructionSizeAt, pc + 1));
	}
	switch (op) {
	case 15:
		return twoByteInstructionSizeAt(self_in_instructionSizeAt, pc);

	case 61:
	case 233:
		return 5;

	case 112:
	case 113:
	case 114:
	case 115:
	case 116:
	case 117:
	case 118:
	case 119:
	case 120:
	case 121:
	case 122:
	case 123:
	case 0x7C:
	case 125:
	case 0x7E:
	case 0x7F:
	case 137:
	case 235:
		return 2;

	case 131:
		return sizeImmediateGroup1at(self_in_instructionSizeAt, op, pc);

	case 139:
		return sizeHasModrmat(self_in_instructionSizeAt, op, pc);

	case 144:
	case 204:
		return 1;

	default:
		error("Case not found and no otherwise clause");
		return -1;
	}
}


/*	Top 32 bits all the same as the bottom 32 bits' sign bit implies we can
	use a sign-extended 4 byte offset.
 */

	/* CogX64Compiler>>#is32BitSignedImmediate: */
static sqInt NoDbgRegParms
is32BitSignedImmediate(AbstractInstruction * self_in_is32BitSignedImmediate, sqInt a64BitUnsignedOperand)
{
	return (((int) a64BitUnsignedOperand)) == (((sqLong) a64BitUnsignedOperand));
}


/*	Assuming mcpc is a send return pc answer if the instruction before it is a
	call (not a CallFull).
 */

	/* CogX64Compiler>>#isCallPrecedingReturnPC: */
static sqInt NoDbgRegParms
isCallPrecedingReturnPC(AbstractInstruction * self_in_isCallPrecedingReturnPC, sqInt mcpc)
{
	return (byteAt(mcpc - 5)) == 232;
}

	/* CogX64Compiler>>#isJumpAt: */
static sqInt NoDbgRegParms
isJumpAt(AbstractInstruction * self_in_isJumpAt, sqInt pc)
{
    sqInt op;

	op = byteAt(pc);
	return (((op >= 112) && (op <= 0x7F)))
	 || ((op == 233)
	 || ((op == 235)
	 || (((op == 15)
	 && ((((byteAt(pc + 1)) >= 128) && ((byteAt(pc + 1)) <= 143))))
	 || ((op == 72)
	 && (((byteAt(pc + 1)) == 161)
	 && (((byteAt(pc + 10)) == 0xFF)
	 && ((byteAt(pc + 11)) == 224)))))));
}

	/* CogX64Compiler>>#isQuick: */
static sqInt NoDbgRegParms
isQuick(AbstractInstruction * self_in_isQuick, usqIntptr_t operand)
{
	return (((((sqLong) operand)) >= -128) && ((((sqLong) operand)) <= 0x7F));
}


/*	Answer if an address can be accessed using the offset in a MoveMw:r:R: or
	similar instruction.
	We assume this is true for 32-bit processors and expect 64-bit processors
	to answer false
	for values in the interpreter or the object memory. Restrict our use of
	offsets to reference
	addresses within the method zone, rather than checking for a 32-bit
	offset, so as to keep the
	simulator and real VM in sync. */

	/* CogX64Compiler>>#isWithinMwOffsetRange: */
static sqInt NoDbgRegParms
isWithinMwOffsetRange(AbstractInstruction * self_in_isWithinMwOffsetRange, sqInt anAddress)
{
	return ((((usqInt)anAddress)) >= codeBase)
	 && ((((usqInt)anAddress)) < limitAddress);
}


/*	Set the target of a jump instruction. These all have the target in the
	first operand. */
/*	Set the target of a jump instruction. These all have the target in the
	first operand.
	Override to cope with JumpFPNotEqual where because of IEEE NaN conformance
	and the behaviour of COMISD/UCOMISD we generate two jumps to the same
	target.  */

	/* CogX64Compiler>>#jmpTarget: */
static AbstractInstruction * NoDbgRegParms
jmpTarget(AbstractInstruction * self_in_jmpTarget, AbstractInstruction *anAbstractInstruction)
{
    AbstractInstruction *aDependent;

	aDependent = (self_in_jmpTarget->dependent);
	while (aDependent != null) {
		jmpTarget(aDependent, anAbstractInstruction);
		aDependent = (aDependent->dependent);
	}
	((self_in_jmpTarget->operands))[0] = (((usqInt)anAbstractInstruction));
	return anAbstractInstruction;
}


/*	Branch/Call ranges. Jump[Cond] can be generated as short as possible.
	Call/Jump[Cond]Long must be generated
	in the same number of bytes irrespective of displacement since their
	targets may be updated, but they need only
	span 16Mb, the maximum size of the code zone. This allows e.g. ARM to use
	single-word call and jump instructions
	for most calls and jumps. CallFull/JumpFull must also be generated in the
	same number of bytes irrespective of
	displacement for the same reason, but they must be able to span the full
	(32-bit or 64-bit) address space because
	they are used to call code in the C runtime, which may be distant from the
	code zone
 */

	/* CogX64Compiler>>#jumpLongByteSize */
static sqInt NoDbgRegParms
jumpLongByteSize(AbstractInstruction * self_in_jumpLongByteSize)
{
	return 5;
}

	/* CogX64Compiler>>#jumpLongConditionalByteSize */
static sqInt NoDbgRegParms
jumpLongConditionalByteSize(AbstractInstruction * self_in_jumpLongConditionalByteSize)
{
	return 6;
}


/*	Answer the target address for the long jump immediately preceding mcpc */

	/* CogX64Compiler>>#jumpLongTargetBeforeFollowingAddress: */
static sqInt NoDbgRegParms
jumpLongTargetBeforeFollowingAddress(AbstractInstruction * self_in_jumpLongTargetBeforeFollowingAddress, sqInt mcpc)
{
	return callTargetFromReturnAddress(self_in_jumpLongTargetBeforeFollowingAddress, mcpc);
}

	/* CogX64Compiler>>#jumpTargetPCAt: */
static usqInt NoDbgRegParms
jumpTargetPCAt(AbstractInstruction * self_in_jumpTargetPCAt, sqInt pc)
{
    sqInt byte;
    sqInt offset;
    sqInt size;

	size = instructionSizeAt(self_in_jumpTargetPCAt, pc);
	if (size == 2) {
		byte = byteAt(pc + 1);
		offset = ((byte & 128) == 0
			? byte
			: byte - 0x100);
	}
	else {
		byte = byteAt((pc + size) - 1);
		offset = ((byte & 128) == 0
			? byte
			: byte - 0x100);
		offset = (((sqInt)((usqInt)(offset) << 8))) + (byteAt((pc + size) - 2));
		offset = (((sqInt)((usqInt)(offset) << 8))) + (byteAt((pc + size) - 3));
		offset = (((sqInt)((usqInt)(offset) << 8))) + (byteAt((pc + size) - 4));
	}
	return (pc + size) + offset;
}


/*	Answer the delta from the stack pointer after a call to the stack pointer
	immediately prior to the call. This is used to compute the stack pointer
	immediately prior to a call from within a leaf routine, which in turn is
	used to capture the c stack pointer to use in trampolines back into the C
	run-time.  */

	/* CogX64Compiler>>#leafCallStackPointerDelta */
static sqInt NoDbgRegParms
leafCallStackPointerDelta(AbstractInstruction * self_in_leafCallStackPointerDelta)
{
	return 8;
}


/*	Answer a literal loaded before the inline cache tag load for the return
	address of a send.
 */

	/* CogX64Compiler>>#literalBeforeInlineCacheTagAt: */
static sqInt NoDbgRegParms
literalBeforeInlineCacheTagAt(AbstractInstruction * self_in_literalBeforeInlineCacheTagAt, sqInt callSiteReturnAddress)
{
	return literalBeforeFollowingAddress(self_in_literalBeforeInlineCacheTagAt, callSiteReturnAddress - 12);
}


/*	Answer the byte size of a MoveCwR opcode's corresponding machine code
	when the argument is a PIC. This is for the self-reference at the end of a
	closed PIC: leaq 0xffffffffffffff2b(%rip), %rcx : 48 8D 0D 2B FF FF FF */

	/* CogX64Compiler>>#loadPICLiteralByteSize */
static sqInt NoDbgRegParms
loadPICLiteralByteSize(AbstractInstruction * self_in_loadPICLiteralByteSize)
{
	return 7;
}

	/* CogX64Compiler>>#machineCodeAt: */
static usqInt NoDbgRegParms
machineCodeAt(AbstractInstruction * self_in_machineCodeAt, sqInt anOffset)
{
	return ((self_in_machineCodeAt->machineCode))[anOffset];
}


/*	Answer the maximum number of bytes of machine code generated for any
	abstract instruction.
	e.g. xchg %rdx, %rax; movq $0x12345678ABCDEF0, %(rax); xchg %rdx, %rax =>
	48 92 48 A3 F0 DE BC 9A 78 56 34 12 48 92
 */

	/* CogX64Compiler>>#machineCodeBytes */
static sqInt NoDbgRegParms
machineCodeBytes(AbstractInstruction * self_in_machineCodeBytes)
{
	return 14;
}


/*	See ModR/M byte & opcode syntax
	In addition to the notation shown above in 'Mnemonic Syntax' on page 43,
	the following notation indicates the size and type of operands in the
	syntax of an instruction opcode:
	/digit	Indicates that the ModRM byte specifies only one register or memory
	(r/m) operand.
	The digit is specified by the ModRM reg field and is used as an
	instruction-opcode extension.
	Valid digit values range from 0 to 7.
	/r		Indicates that the ModRM byte specifies both a register operand and a
	reg/mem (register or memory) operand. */

	/* CogX64Compiler>>#mod:RM:RO: */
static sqInt NoDbgRegParms
modRMRO(AbstractInstruction * self_in_modRMRO, sqInt mod, sqInt regMode, sqInt regOpcode)
{
	return ((((sqInt)((usqInt)(mod) << 6))) + (((sqInt)((usqInt)((regOpcode & 7)) << 3)))) + (regMode & 7);
}

	/* CogX64Compiler>>#numIntRegArgs */
static sqInt NoDbgRegParms
numIntRegArgs(AbstractInstruction * self_in_numIntRegArgs)
{
	return 6;
}

	/* CogX64Compiler>>#padIfPossibleWithStopsFrom:to: */
static void NoDbgRegParms
padIfPossibleWithStopsFromto(AbstractInstruction * self_in_padIfPossibleWithStopsFromto, sqInt startAddr, sqInt endAddr)
{
	stopsFromto(self_in_padIfPossibleWithStopsFromto, startAddr, endAddr);
}


/*	Temporary register used for fetching the instruction pointer. This should
	not be used for passing parameters in a standard ABI */

	/* CogX64Compiler>>#registerToSaveIP */
static sqInt NoDbgRegParms
registerToSaveIP(AbstractInstruction * self_in_registerToSaveIP)
{
	return R15;
}

	/* CogX64Compiler>>#relocateCallBeforeReturnPC:by: */
static void NoDbgRegParms
relocateCallBeforeReturnPCby(AbstractInstruction * self_in_relocateCallBeforeReturnPCby, sqInt retpc, sqInt delta)
{
    sqInt distance;

	if (delta != 0) {
		distance = (((((sqInt)((usqInt)((byteAt(retpc - 1))) << 24))) + (((sqInt)((usqInt)((byteAt(retpc - 2))) << 16)))) + (((sqInt)((usqInt)((byteAt(retpc - 3))) << 8)))) + (byteAt(retpc - 4));
		distance += delta;
		byteAtput(retpc - 1, (((usqInt)(distance)) >> 24) & 0xFF);
		byteAtput(retpc - 2, (((usqInt)(distance)) >> 16) & 0xFF);
		byteAtput(retpc - 3, (((usqInt)(distance)) >> 8) & 0xFF);
		byteAtput(retpc - 4, distance & 0xFF);
	}
}


/*	We generate the method address using pc-relative addressing.
	Simply check that rip-relative addressing is being used. c.f.
	concretizeMoveCwR */

	/* CogX64Compiler>>#relocateMethodReferenceBeforeAddress:by: */
static void NoDbgRegParms
relocateMethodReferenceBeforeAddressby(AbstractInstruction * self_in_relocateMethodReferenceBeforeAddressby, sqInt pc, sqInt delta)
{
	assert((((byteAt(pc - 6)) == 141)
	 && (((byteAt(pc - 5)) | (modRMRO(self_in_relocateMethodReferenceBeforeAddressby, 0, 0, 7))) == (modRMRO(self_in_relocateMethodReferenceBeforeAddressby, ModRegInd, 5, 7))))
	 || (((byteAt(pc - 8)) == 141)
	 && (((byteAt(pc - 7)) | (modRMRO(self_in_relocateMethodReferenceBeforeAddressby, 0, 0, 7))) == (modRMRO(self_in_relocateMethodReferenceBeforeAddressby, ModRegInd, 5, 7)))));
}


/*	Rewrite a call instruction to call a different target. This variant is
	used to link PICs
	in ceSendMiss et al, and to rewrite cached primitive calls. Answer the
	extent of
	the code change which is used to compute the range of the icache to flush. */
/*	self cCode: ''
	inSmalltalk: [cogit disassembleFrom: callSiteReturnAddress - 10 to:
	callSiteReturnAddress - 1]. */

	/* CogX64Compiler>>#rewriteCallAt:target: */
static sqInt NoDbgRegParms
rewriteCallAttarget(AbstractInstruction * self_in_rewriteCallAttarget, usqInt callSiteReturnAddress, usqInt callTargetAddress)
{
    usqInt callDistance;

	callDistance = ((usqInt) (int)(callTargetAddress - callSiteReturnAddress));
	byteAtput(callSiteReturnAddress - 1, ((callDistance) >> 24) & 0xFF);
	byteAtput(callSiteReturnAddress - 2, ((callDistance) >> 16) & 0xFF);
	byteAtput(callSiteReturnAddress - 3, ((callDistance) >> 8) & 0xFF);
	byteAtput(callSiteReturnAddress - 4, callDistance & 0xFF);
	assert((callTargetFromReturnAddress(self_in_rewriteCallAttarget, callSiteReturnAddress)) == callTargetAddress);
	return 5;
}


/*	Rewrite a CallFull instruction to call a different target. This variant is
	used to rewrite cached primitive calls.
	Answer the extent of the code change which is used to compute the range of
	the icache to flush.
	On x64 this is a rewrite of
	movq #64bits, %rax : 48 A1 b0 b1 b2 b3 b4 b5 b6 b7
	jmp %rax : FF E0 */

	/* CogX64Compiler>>#rewriteCallFullAt:target: */
static sqInt NoDbgRegParms
rewriteCallFullAttarget(AbstractInstruction * self_in_rewriteCallFullAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	assert((byteAt(callSiteReturnAddress - 12)) == 72);
	unalignedLongAtput(callSiteReturnAddress - 10, callTargetAddress);
	assert((((usqInt) (callFullTargetFromReturnAddress(self_in_rewriteCallFullAttarget, callSiteReturnAddress)))) == callTargetAddress);
	return 12;
}


/*	Rewrite the short jump instruction to jump to a new cpic case target. */
/*	prevent type inference for avoiding warning on abs */

	/* CogX64Compiler>>#rewriteCPICJumpAt:target: */
static void NoDbgRegParms
rewriteCPICJumpAttarget(AbstractInstruction * self_in_rewriteCPICJumpAttarget, usqInt addressFollowingJump, usqInt jumpTargetAddr)
{
    sqInt callDistance;

	callDistance = jumpTargetAddr - addressFollowingJump;
	assert((SQABS(callDistance)) < 128);
	byteAtput(addressFollowingJump - 1, callDistance & 0xFF);
}


/*	Rewrite an inline cache to call a different target for a new tag. This
	variant is used
	to link unlinked sends in ceSend:to:numArgs: et al. Answer the extent of
	the code
	change which is used to compute the range of the icache to flush.
	N.B. On 64-bit platforms the inline cache tag is only 32-bits wide, hence
	this code
	is identical to that for the IA32. */
/*	self cCode: ''
	inSmalltalk: [cogit disassembleFrom: callSiteReturnAddress - 12 to:
	callSiteReturnAddress - 1]. */

	/* CogX64Compiler>>#rewriteInlineCacheAt:tag:target: */
static sqInt NoDbgRegParms
rewriteInlineCacheAttagtarget(AbstractInstruction * self_in_rewriteInlineCacheAttagtarget, usqInt callSiteReturnAddress, sqInt cacheTag, usqInt callTargetAddress)
{
    usqInt callDistance;

	callDistance = ((usqInt) (int)(callTargetAddress - callSiteReturnAddress));
	byteAtput(callSiteReturnAddress - 1, ((callDistance) >> 24) & 0xFF);
	byteAtput(callSiteReturnAddress - 2, ((callDistance) >> 16) & 0xFF);
	byteAtput(callSiteReturnAddress - 3, ((callDistance) >> 8) & 0xFF);
	byteAtput(callSiteReturnAddress - 4, callDistance & 0xFF);
	byteAtput(callSiteReturnAddress - 6, (((usqInt)(cacheTag)) >> 24) & 0xFF);
	byteAtput(callSiteReturnAddress - 7, (((usqInt)(cacheTag)) >> 16) & 0xFF);
	byteAtput(callSiteReturnAddress - 8, (((usqInt)(cacheTag)) >> 8) & 0xFF);
	byteAtput(callSiteReturnAddress - 9, cacheTag & 0xFF);
	assert((callTargetFromReturnAddress(self_in_rewriteInlineCacheAttagtarget, callSiteReturnAddress)) == callTargetAddress);
	return 12;
}


/*	Rewrite an inline cache with a new tag. This variant is used
	by the garbage collector. */

	/* CogX64Compiler>>#rewriteInlineCacheTag:at: */
static void NoDbgRegParms
rewriteInlineCacheTagat(AbstractInstruction * self_in_rewriteInlineCacheTagat, sqInt cacheTag, sqInt callSiteReturnAddress)
{
	unalignedLong32Atput(self_in_rewriteInlineCacheTagat, callSiteReturnAddress - 9, cacheTag);
}


/*	Rewrite a JumpFull instruction to jump to a different target. This variant
	is used to rewrite cached primitive calls.
	Answer the extent of the code change which is used to compute the range of
	the icache to flush.
	On x64 this is a rewrite of
	movq #64bits, %rax : 48 A1 b0 b1 b2 b3 b4 b5 b6 b7
	jmp %rax : FF E0 */

	/* CogX64Compiler>>#rewriteJumpFullAt:target: */
static sqInt NoDbgRegParms
rewriteJumpFullAttarget(AbstractInstruction * self_in_rewriteJumpFullAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteCallFullAttarget(self_in_rewriteJumpFullAttarget, callSiteReturnAddress, callTargetAddress);
}


/*	<0-15> */
/*	<0-15> */
/*	<0-15> */

	/* CogX64Compiler>>#rexR:x:b: */
static sqInt NoDbgRegParms
rexRxb(AbstractInstruction * self_in_rexRxb, sqInt reg, sqInt sibReg, sqInt fieldReg)
{
	return rexwrxb(self_in_rexRxb, 1, reg, sibReg, fieldReg);
}


/*	<Boolean> */
/*	<0-15> */
/*	<0-15> */
/*	<0-15> */
/*	Given width64, the R register, sib register, and modrm/sib/reg field
	register, answer the correctly encoded REX prefix byte.
	See AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and
	System Instructions, Table 1-11 */

	/* CogX64Compiler>>#rexw:r:x:b: */
static sqInt NoDbgRegParms
rexwrxb(AbstractInstruction * self_in_rexwrxb, sqInt width64, sqInt reg, sqInt sibReg, sqInt fieldReg)
{
    sqInt regBits;

	regBits = ((((usqInt)((reg & 8))) >> 1) + (((usqInt)((sibReg & 8))) >> 2)) + (((usqInt)(fieldReg)) >> 3);
	return ((width64
	? 72
	: 64)) + regBits;
}


/*	to save Slang from having to be a real compiler (it can't inline switches
	that return)
 */
/*	Answer if the receiver's opcode sets the condition codes correctly for the
	given conditional jump opcode.
 */

	/* CogX64Compiler>>#setsConditionCodesFor: */
static sqInt NoDbgRegParms
setsConditionCodesFor(AbstractInstruction * self_in_setsConditionCodesFor, sqInt aConditionalJumpOpcode)
{
	switch ((self_in_setsConditionCodesFor->opcode)) {
	case ArithmeticShiftRightCqR:
	case ArithmeticShiftRightRR:
	case LogicalShiftLeftCqR:
	case LogicalShiftLeftRR:
		/* begin shiftSetsConditionCodesFor: */
		return ((aConditionalJumpOpcode >= JumpZero) && (aConditionalJumpOpcode <= JumpNonNegative));

	case LogicalShiftRightCqR:
		return 0;

	case XorRR:
		return 1;

	case ClzRR:
		return (aConditionalJumpOpcode == JumpZero)
		 || ((aConditionalJumpOpcode == JumpNonZero)
		 || ((aConditionalJumpOpcode == JumpCarry)
		 || (aConditionalJumpOpcode == JumpNoCarry)));

	default:
		haltmsg("unhandled opcode in setsConditionCodesFor:");
		return 0;;
	}
}

	/* CogX64Compiler>>#sizeHasModrm:at: */
static sqInt NoDbgRegParms
sizeHasModrmat(AbstractInstruction * self_in_sizeHasModrmat, sqInt op, sqInt pc)
{
    sqInt mod;
    sqInt modrm;
    sqInt rm;
    sqInt ro;

	modrm = byteAt(pc + 1);
	mod = ((usqInt)(modrm)) >> 6;
	ro = (((usqInt)(modrm)) >> 3) & 7;
	rm = modrm & 7;
	if (mod == 3) {
		return 2;
	}
	if (rm != 4) {

		/* no SIB byte */
		switch (mod) {
		case 0:
			return (rm == 5
				? 6
				: 3);

		case 1:
			return 3;

		case 2:
			return 6;

		default:
			error("Case not found and no otherwise clause");
			return -1;
		}
	}
	haltmsg("fall through in sizeHasModrm:at:");
	return 0;
}


/*	see [1] p A-7, p A-13 */

	/* CogX64Compiler>>#sizeImmediateGroup1:at: */
static sqInt NoDbgRegParms
sizeImmediateGroup1at(AbstractInstruction * self_in_sizeImmediateGroup1at, sqInt op, sqInt pc)
{
    sqInt mod;
    sqInt modrm;
    sqInt rm;
    sqInt ro;

	modrm = byteAt(pc + 1);
	mod = ((usqInt)(modrm)) >> 6;
	ro = (((usqInt)(modrm)) >> 3) & 7;
	rm = modrm & 7;
	switch (ro) {
	case 7:
		return (op == 129
			? 6
			: 3);

	default:
		error("Case not found and no otherwise clause");
		return -1;
	}
}

	/* CogX64Compiler>>#stopsFrom:to: */
static void NoDbgRegParms
stopsFromto(AbstractInstruction * self_in_stopsFromto, sqInt startAddr, sqInt endAddr)
{
	memset(((void *)startAddr), 204 /* stop */, (endAddr - startAddr) + 1);
}


/*	Rewrite the 32-bit literal in the instruction immediately preceding
	followingAddress. 
 */

	/* CogX64Compiler>>#storeLiteral32:beforeFollowingAddress: */
static void NoDbgRegParms
storeLiteral32beforeFollowingAddress(AbstractInstruction * self_in_storeLiteral32beforeFollowingAddress, sqInt literal, sqInt followingAddress)
{
	byteAtput(followingAddress - 1, (((usqInt)(literal)) >> 24) & 0xFF);
	byteAtput(followingAddress - 2, (((usqInt)(literal)) >> 16) & 0xFF);
	byteAtput(followingAddress - 3, (((usqInt)(literal)) >> 8) & 0xFF);
	byteAtput(followingAddress - 4, literal & 0xFF);
}

	/* CogX64Compiler>>#s:i:b: */
static sqInt NoDbgRegParms
sib(AbstractInstruction * self_in_sib, sqInt scale, sqInt indexReg, sqInt baseReg)
{
	return ((((sqInt)((usqInt)(scale) << 6))) + (((sqInt)((usqInt)((indexReg & 7)) << 3)))) + (baseReg & 7);
}

	/* CogX64Compiler>>#twoByteInstructionSizeAt: */
static sqInt NoDbgRegParms
twoByteInstructionSizeAt(AbstractInstruction * self_in_twoByteInstructionSizeAt, sqInt pc)
{
    sqInt op;

	op = byteAt(pc + 1);
	switch (op & 240) {
	case 128:
		
		/* long conditional jumps */
		return 6;

	default:
		error("Case not found and no otherwise clause");
		return -1;
	}
}


/*	Answer if Call and JumpLong are relative and hence need to take the
	caller's relocation delta into account during code compaction, rather than
	just the
	callee's delta. */

	/* CogX64Compiler>>#zoneCallsAreRelative */
static sqInt NoDbgRegParms
zoneCallsAreRelative(AbstractInstruction * self_in_zoneCallsAreRelative)
{
	return 1;
}

	/* SimpleStackBasedCogit>>#cogMethodHasExternalPrim: */
sqInt
cogMethodHasExternalPrim(CogMethod *aCogMethod)
{
    sqInt primIndex;

	primIndex = primitiveIndexOfMethodheader((aCogMethod->methodObject), (aCogMethod->methodHeader));
	return (primIndex == PrimNumberExternalCall)
	 || (primIndex == PrimNumberFFICall);
}

	/* SimpleStackBasedCogit>>#cogMethodHasMachineCodePrim: */
sqInt
cogMethodHasMachineCodePrim(CogMethod *aCogMethod)
{
    sqInt primIndex;

	primIndex = primitiveIndexOfMethodheader((aCogMethod->methodObject), (aCogMethod->methodHeader));
	return (((primIndex >= 1) && (primIndex <= MaxCompiledPrimitiveIndex)))
	 && ((((primitiveGeneratorTable[primIndex]).primitiveGenerator)) != null);
}


/*	Compile the jump instruction(s) at the end of the method that dispatch to
	each block body.
 */

	/* SimpleStackBasedCogit>>#compileBlockDispatch */
static sqInt
compileBlockDispatch(void)
{
    AbstractInstruction *jumpSkip;

	assert(blockCount > 0);
	/* begin MoveCq:R: */
	blockEntryNoContextSwitch = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
	/* begin Jump: */
	jumpSkip = genoperand(Jump, ((sqInt)0));
	/* begin MoveR:R: */
	blockEntryLabel = genoperandoperand(MoveRR, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jumpSkip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (blockCount > 1) {
		genLoadSlotsourceRegdestReg(ClosureStartPCIndex, ReceiverResultReg, TempReg);
	}
	compileBlockDispatchFromto(0, blockCount - 1);
	return 0;
}


/*	After pushing the temporaries but before the stack limit check a primitive
	method needs to fetch the error code, if any. If the primitive has failed,
	call the trampoline
	that will assign it to the last temp. */

	/* SimpleStackBasedCogit>>#compileGetErrorCode */
static void
compileGetErrorCode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    AbstractInstruction *jmpNoError;

	/* begin MoveAw:R: */
	address = primFailCodeAddress();
	genoperandoperand(MoveAwR, address, TempReg);
	flag("ask concrete code gen if move sets condition codes?");
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, TempReg);
	/* begin JumpZero: */
	jmpNoError = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), ClassReg))));
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceReapAndResetErrorCodeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(jmpNoError, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
}

	/* SimpleStackBasedCogit>>#compileInterpreterPrimitive */
static sqInt
compileInterpreterPrimitive(void)
{
    sqInt flags;
    void (*primitiveRoutine)(void);

	flags = 0;
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, (&flags));
	if (((flags & PrimCallOnSmalltalkStack) != 0)) {
		return compileOnStackExternalPrimitiveflags(primitiveRoutine, flags);
	}
	return compileInterpreterPrimitiveflags(primitiveRoutine, flags);
}


/*	Compile a call to an interpreter primitive. Call the C routine with the
	usual stack-switching dance, test the primFailCode and then either
	return on success or continue to the method body. */

	/* SimpleStackBasedCogit>>#compileInterpreterPrimitive:flags: */
static sqInt NoDbgRegParms
compileInterpreterPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags)
{
    sqInt address1;
    sqInt address3;
    sqInt address5;
    sqInt address6;
    sqInt address7;
    sqInt address8;
    sqInt address9;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *continueAfterProfileSample;
    AbstractInstruction *jmp;
    AbstractInstruction *jump;
    AbstractInstruction *jumpToTakeSample;
    sqInt liveRegisterMask;
    sqInt offset;
    sqInt offset1;
    sqInt operand;
    sqInt reg;
    AbstractInstruction *skip;

	jumpToTakeSample = ((AbstractInstruction *) 0);
	assert(!((registerisInMask(VarBaseReg, ABICallerSavedRegisterMask))));
	genExternalizePointersForPrimitiveCall();
	/* begin genLoadCStackPointersForPrimCall */
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	if (recordPrimTraceForMethod(methodObj)) {
		genFastPrimTraceUsingand(ClassReg, SendNumArgsReg);
	}
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, TempReg);
	/* begin MoveR:Aw: */
	address6 = primFailCodeAddress();
	genoperandoperand(MoveRAw, TempReg, address6);
	if (methodOrBlockNumArgs != 0) {
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, methodOrBlockNumArgs, TempReg);
	}
	/* begin MoveR:Aw: */
	address7 = argumentCountAddress();
	genoperandoperand(MoveRAw, TempReg, address7);
	if (((flags & PrimCallNeedsNewMethod) != 0)) {
		genLoadNewMethod();
	}
	/* begin PrefetchAw: */
	address8 = primFailCodeAddress();
	genoperand(PrefetchAw, address8);
	if (((flags & PrimCallMayEndureCodeCompaction) != 0)) {

		/* The ceActivateFailingPrimitiveMethod: machinery can't handle framelessness. */
		needsFrame = 1;
		/* begin genMarshallNArgs:arg:arg:arg:arg: */
		assert(0 <= 4);
		/* begin gen:literal: */
		operand = (((flags & PrimCallCollectsProfileSamples) != 0)
			? cePrimReturnEnterCogCodeProfiling
			: cePrimReturnEnterCogCode);
		genoperand(PushCw, operand);
		/* begin JumpFullRT: */
		/* begin JumpFull: */
		
		((sqInt)(((sqInt)primitiveRoutine)));
		anInstruction1 = genoperand(JumpFull, ((sqInt)(((sqInt)primitiveRoutine))));
		return 0;
	}
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	assert(0 <= 4);
	/* begin CallFullRT: */
	/* begin CallFull: */
	
	((sqInt)primitiveRoutine);
	anInstruction3 = genoperand(CallFull, ((sqInt)primitiveRoutine));
	/* begin genRemoveNArgsFromStack: */
	assert(0 <= 4);
	maybeCompileRetryOfonPrimitiveFailflags(primitiveRoutine, primitiveIndex, flags);
	genLoadStackPointersForPrimCall(backEnd, ClassReg);
	/* begin MoveAw:R: */
	address1 = instructionPointerAddress();
	genoperandoperand(MoveAwR, address1, ClassReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, ClassReg, 0, SPReg);
	/* begin MoveAw:R: */
	address9 = primFailCodeAddress();
	genoperandoperand(MoveAwR, address9, TempReg);
	flag("ask concrete code gen if move sets condition codes?");
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, TempReg);
	/* begin JumpNonZero: */
	jmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (((flags & PrimCallCollectsProfileSamples) != 0)) {
		/* begin genCheckForProfileTimerTick: */
		liveRegisterMask = (0);
		/* begin preferredRegisterForMovePerfCnt64RL */
		reg = RAX;
		/* begin MoveAw:R: */
		address3 = nextProfileTickAddress();
		genoperandoperand(MoveAwR, address3, Arg1Reg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, Arg1Reg);
		/* begin JumpZero: */
		skip = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		gMovePerfCnt64RL(reg, liveRegisterMask);
		/* begin CmpR:R: */
		assert(!((Arg1Reg == SPReg)));
		genoperandoperand(CmpRR, Arg1Reg, reg);
		/* begin JumpAboveOrEqual: */
		jump = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jumpToTakeSample = jump;
		goto l27;
	l27:	/* end genCheckForProfileTimerTick: */;
	}
	/* begin MoveMw:r:R: */
	offset = BytesPerWord;
	continueAfterProfileSample = genoperandoperandoperand(MoveMwrR, offset, SPReg, ReceiverResultReg);
	/* begin RetN: */
	genoperand(RetN, BytesPerWord);
	if (((flags & PrimCallCollectsProfileSamples) != 0)) {
		jmpTarget(jumpToTakeSample, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		genTakeProfileSample();
		genLoadStackPointerForPrimCall(backEnd, ClassReg);
		/* begin MoveAw:R: */
		address5 = instructionPointerAddress();
		genoperandoperand(MoveAwR, address5, ClassReg);
		/* begin MoveR:Mw:r: */
		genoperandoperandoperand(MoveRMwr, ClassReg, 0, SPReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)continueAfterProfileSample));
	}
	jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin MoveMw:r:R: */
	offset1 = BytesPerWord * (methodOrBlockNumArgs + (1));
	genoperandoperandoperand(MoveMwrR, offset1, SPReg, ReceiverResultReg);
	return 0;
}


/*	Compile a fast call of a C primitive using the current stack page,
	avoiding the stack switch except on failure.
	This convention still uses stackPointer and argumentCount to access
	operands. Push all operands to the stack,
	assign stackPointer, argumentCount, and zero primFailCode. Make the call
	(saving a LinkReg if required).
	Test for failure and return. On failure on Spur, if there is an accessor
	depth, assign framePointer and newMethod,
	do the stack switch, call checkForAndFollowForwardedPrimitiveState, and
	loop back if forwarders are found.
	Fall through to frame build. */

	/* SimpleStackBasedCogit>>#compileOnStackExternalPrimitive:flags: */
static sqInt NoDbgRegParms
compileOnStackExternalPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction2;
    sqInt address;
    sqInt address10;
    sqInt address11;
    sqInt address3;
    sqInt address4;
    sqInt address5;
    sqInt address7;
    sqInt address8;
    sqInt address9;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    sqInt calleeSavedRegisterMask;
    AbstractInstruction *continueAfterProfileSample;
    AbstractInstruction *jmpFail;
    AbstractInstruction *jump;
    AbstractInstruction *jumpToTakeSample;
    sqInt liveRegisterMask;
    sqInt offset;
    sqInt reg;
    sqInt retpcOffset;
    AbstractInstruction *retry;
    AbstractInstruction *skip;
    AbstractInstruction *skip1;
    sqInt spRegSaveRegister;

	jumpToTakeSample = ((AbstractInstruction *) 0);
	assert(((flags & PrimCallOnSmalltalkStack) != 0));
	assert(!((registerisInMask(VarBaseReg, ABICallerSavedRegisterMask))));
	if (recordFastCCallPrimTraceForMethod(methodObj)) {
		genFastPrimTraceUsingand(ClassReg, SendNumArgsReg);
	}
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, TempReg);
	/* begin MoveR:Aw: */
	address8 = primFailCodeAddress();
	genoperandoperand(MoveRAw, TempReg, address8);
	if (methodOrBlockNumArgs != 0) {
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, methodOrBlockNumArgs, TempReg);
	}
	/* begin MoveR:Aw: */
	address9 = argumentCountAddress();
	genoperandoperand(MoveRAw, TempReg, address9);
	genExternalizeStackPointerForFastPrimitiveCall();
	calleeSavedRegisterMask = ((ABICalleeSavedRegisterMask | ((1U << ClassReg))) - ((1U << ClassReg)));
	spRegSaveRegister = NoReg;
	/* begin Label */
	retry = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (((flags & PrimCallOnSmalltalkStackAlign2x) != 0)) {
		gAndCqRR((-1 - (((BytesPerWord * 2) - 1))), SPReg, NativeSPReg);
	}
	else {
			}
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	assert(0 <= 4);
	if (((!(flags & PrimCallIsExternalCall)))
	 && (is32BitSignedImmediate(backEnd, maximumDistanceFromCodeZone(((sqInt)primitiveRoutine))))) {
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ((sqInt)primitiveRoutine));
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* begin CallFullRT: */
		/* begin CallFull: */
		
		((sqInt)primitiveRoutine);
		anInstruction1 = genoperand(CallFull, ((sqInt)primitiveRoutine));
	}
	/* begin genRemoveNArgsFromStack: */
	assert(0 <= 4);
	/* begin MoveAw:R: */
	address10 = primFailCodeAddress();
	genoperandoperand(MoveAwR, address10, TempReg);
	if (spRegSaveRegister != NoReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, spRegSaveRegister, SPReg);
	}
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, TempReg);
	/* begin JumpNonZero: */
	jmpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (((flags & PrimCallCollectsProfileSamples) != 0)) {
		/* begin genCheckForProfileTimerTick: */
		liveRegisterMask = (0);
		/* begin preferredRegisterForMovePerfCnt64RL */
		reg = RAX;
		/* begin MoveAw:R: */
		address = nextProfileTickAddress();
		genoperandoperand(MoveAwR, address, Arg1Reg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, Arg1Reg);
		/* begin JumpZero: */
		skip1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		gMovePerfCnt64RL(reg, liveRegisterMask);
		/* begin CmpR:R: */
		assert(!((Arg1Reg == SPReg)));
		genoperandoperand(CmpRR, Arg1Reg, reg);
		/* begin JumpAboveOrEqual: */
		jump = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		jmpTarget(skip1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jumpToTakeSample = jump;
		goto l19;
	l19:	/* end genCheckForProfileTimerTick: */;
	}
	/* begin MoveAw:R: */
	address11 = stackPointerAddress();
	continueAfterProfileSample = genoperandoperand(MoveAwR, address11, TempReg);
	
	/* The original retpc is (argumentCount + 1) words below stackPointer. */
	retpcOffset = -((methodOrBlockNumArgs + 1) * BytesPerWord);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, retpcOffset, TempReg, ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, SPReg);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, TempReg, ReceiverResultReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, ClassReg, 0, TempReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	if (((flags & PrimCallCollectsProfileSamples) != 0)) {
		jmpTarget(jumpToTakeSample, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		genTakeProfileSample();
		/* begin Jump: */
		genoperand(Jump, ((sqInt)continueAfterProfileSample));
	}
	jmpTarget(jmpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if ((accessorDepthForPrimitiveMethod(methodObj)) >= 0) {

		/* Given that following primitive state to the accessor depth is recursive, we're asking for
		   trouble if we run the fixup on the Smalltalk stack page.  Run it on the full C stack instead.
		   This won't be a performance issue since primitive failure should be very rare. */
		/* begin MoveR:Aw: */
		address3 = framePointerAddress();
		genoperandoperand(MoveRAw, FPReg, address3);
		/* begin MoveCw:R: */
		
		((sqInt)primitiveRoutine);
		anInstruction4 = genoperandoperand(MoveCwR, ((sqInt)primitiveRoutine), TempReg);
		/* begin MoveR:Aw: */
		address4 = primitiveFunctionPointerAddress();
		genoperandoperand(MoveRAw, TempReg, address4);
		genLoadNewMethod();
		/* begin genLoadCStackPointersForPrimCall */
		if (cFramePointerInUse) {
			genLoadCStackPointers(backEnd);
		}
		else {
			genLoadCStackPointer(backEnd);
		}
		/* begin genMarshallNArgs:arg:arg:arg:arg: */
		assert(0 <= 4);
		if (is32BitSignedImmediate(backEnd, maximumDistanceFromCodeZone(((usqIntptr_t)checkForAndFollowForwardedPrimitiveState)))) {
			/* begin CallRT: */
			
			abstractInstruction2 = genoperand(Call, ((usqIntptr_t)checkForAndFollowForwardedPrimitiveState));
			(abstractInstruction2->annotation = IsRelativeCall);
		}
		else {
			/* begin CallFullRT: */
			/* begin CallFull: */
			
			((usqIntptr_t)checkForAndFollowForwardedPrimitiveState);
			anInstruction3 = genoperand(CallFull, ((usqIntptr_t)checkForAndFollowForwardedPrimitiveState));
		}
		genLoadStackPointersForPrimCall(backEnd, ClassReg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, ABIResultReg);
		/* begin JumpZero: */
		skip = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, TempReg);
		/* begin MoveR:Aw: */
		address5 = primFailCodeAddress();
		genoperandoperand(MoveRAw, TempReg, address5);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)retry));
		jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	else {

		/* must reload SPReg to undo any alignment change, */
		if (((flags & PrimCallOnSmalltalkStackAlign2x) != 0)) {
			
			/* remember to include return address; use scratch to avoid an interrupt overwriting retpc */
			/* begin MoveAw:R: */
			address7 = stackPointerAddress();
			genoperandoperand(MoveAwR, address7, TempReg);
			/* begin SubCq:R: */
			
			BytesPerWord;
			anInstruction5 = genoperandoperand(SubCqR, BytesPerWord, TempReg);
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, TempReg, SPReg);
		}
	}
	if (((ABICallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)) {
		/* begin MoveMw:r:R: */
		offset = (methodOrBlockNumArgs + (1)) * BytesPerWord;
		genoperandoperandoperand(MoveMwrR, offset, SPReg, ReceiverResultReg);
	}
	return 0;
}


/*	Compile one method cache probe in an OpenPIC's lookup of selector.
	Answer the jump taken if the selector probe fails.
	The class tag of the receiver must be in SendNumArgsReg. ClassReg and
	TempReg are used as scratch registers.
	On a hit, the offset of the entry is in ClassReg. */

	/* SimpleStackBasedCogit>>#compileOpenPICMethodCacheProbeFor:withShift:baseRegOrNone: */
static AbstractInstruction * NoDbgRegParms
compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selector, sqInt shift, sqInt baseRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt offset1;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	maybeShiftClassTagRegisterForMethodCacheProbe(ClassReg);
	annotateobjRef(checkLiteralforInstruction(selector, genoperandoperand(XorCwR, selector, ClassReg)), selector);
	assert(shift <= (shiftForWord()));
	if (shift < (shiftForWord())) {
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - shift, ClassReg);
	}
	/* begin AndCq:R: */
	
	((sqInt)((usqInt)(MethodCacheMask) << (shiftForWord())));
	anInstruction2 = genoperandoperand(AndCqR, ((sqInt)((usqInt)(MethodCacheMask) << (shiftForWord()))), ClassReg);
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset = (methodCacheAddress()) + (((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord()))));
		genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	}
	else {
		/* begin AddR:R: */
		genoperandoperand(AddRR, baseRegOrNone, ClassReg);
		/* begin MoveMw:r:R: */
		
		((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord())));
		anInstruction = genoperandoperandoperand(MoveMwrR, ((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord()))), ClassReg, TempReg);
	}
	annotateobjRef(checkLiteralforInstruction(selector, genoperandoperand(CmpCwR, selector, TempReg)), selector);
	/* begin JumpNonZero: */
	jumpSelectorMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset1 = (methodCacheAddress()) + (((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord()))));
		genoperandoperandoperand(MoveMwrR, offset1, ClassReg, TempReg);
	}
	else {
		/* begin MoveMw:r:R: */
		
		((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord())));
		anInstruction1 = genoperandoperandoperand(MoveMwrR, ((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord()))), ClassReg, TempReg);
	}
	/* begin CmpR:R: */
	assert(!((SendNumArgsReg == SPReg)));
	genoperandoperand(CmpRR, SendNumArgsReg, TempReg);
	return jumpSelectorMiss;
}


/*	Compile the code for an open PIC. Perform a probe of the first-level
	method lookup cache followed by a call of ceSendFromInLineCacheMiss: if
	the probe fails. */

	/* SimpleStackBasedCogit>>#compileOpenPIC:numArgs: */
static void NoDbgRegParms
compileOpenPICnumArgs(sqInt selector, sqInt numArgs)
{
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt quickConstant;
    sqInt reg;

	/* begin preenMethodLabel */
	((methodLabel->operands))[1] = 0;
	compilePICAbort(numArgs);
	entry = genGetClassTagOfintoscratchReg(ReceiverResultReg, SendNumArgsReg, TempReg);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	if (!(((((usqInt)(methodCacheAddress()))) >= codeBase)
		 && ((((usqInt)(methodCacheAddress()))) < limitAddress))) {
		/* begin MoveCq:R: */
		quickConstant = methodCacheAddress();
		reg = (cacheBaseReg = Extra0Reg);
		genoperandoperand(MoveCqR, quickConstant, reg);
	}
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 0, cacheBaseReg);
	/* begin JumpNonZero: */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = (cacheBaseReg == NoReg
		? (methodCacheAddress()) + (((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))))
		: ((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))));
	itsAHit = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	jmpTarget(jumpBCMethod, picInterpretAbort);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	/* begin JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 1, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 2, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	genSmalltalkToCStackSwitch(1);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), SendNumArgsReg))));
	compileCallFornumArgsargargargargresultRegregsToSave(ceSendFromInLineCacheMiss, 1, SendNumArgsReg, null, null, null, NoReg, 0 /* emptyRegisterMask */);
}


/*	Compile one method cache probe in a perform: primitive's lookup of
	selector. Answer the jump taken if the selector probe fails. */

	/* SimpleStackBasedCogit>>#compilePerformMethodCacheProbeFor:withShift:baseRegOrNone: */
static AbstractInstruction * NoDbgRegParms
compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selectorReg, sqInt shift, sqInt baseRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt offset1;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	maybeShiftClassTagRegisterForMethodCacheProbe(ClassReg);
	/* begin XorR:R: */
	genoperandoperand(XorRR, selectorReg, ClassReg);
	assert(shift <= (shiftForWord()));
	if (shift < (shiftForWord())) {
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - shift, ClassReg);
	}
	/* begin AndCq:R: */
	
	((sqInt)((usqInt)(MethodCacheMask) << (shiftForWord())));
	anInstruction2 = genoperandoperand(AndCqR, ((sqInt)((usqInt)(MethodCacheMask) << (shiftForWord()))), ClassReg);
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset = (methodCacheAddress()) + (((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord()))));
		genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	}
	else {
		/* begin AddR:R: */
		genoperandoperand(AddRR, baseRegOrNone, ClassReg);
		/* begin MoveMw:r:R: */
		
		((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord())));
		anInstruction = genoperandoperandoperand(MoveMwrR, ((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord()))), ClassReg, TempReg);
	}
	/* begin CmpR:R: */
	assert(!((selectorReg == SPReg)));
	genoperandoperand(CmpRR, selectorReg, TempReg);
	/* begin JumpNonZero: */
	jumpSelectorMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset1 = (methodCacheAddress()) + (((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord()))));
		genoperandoperandoperand(MoveMwrR, offset1, ClassReg, TempReg);
	}
	else {
		/* begin MoveMw:r:R: */
		
		((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord())));
		anInstruction1 = genoperandoperandoperand(MoveMwrR, ((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord()))), ClassReg, TempReg);
	}
	/* begin CmpR:R: */
	assert(!((SendNumArgsReg == SPReg)));
	genoperandoperand(CmpRR, SendNumArgsReg, TempReg);
	return jumpSelectorMiss;
}


/*	Compile a primitive. If possible, performance-critical primitives will
	be generated by their own routines (primitiveGenerator). Otherwise,
	if there is a primitive at all, we call the C routine with the usual
	stack-switching dance, test the primFailCode and then either return
	on success or continue to the method body. */

	/* SimpleStackBasedCogit>>#compilePrimitive */
static sqInt
compilePrimitive(void)
{
    sqInt code;
    sqInt flags;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpNotSmallInteger;
    sqInt opcodeIndexAtPrimitive;
    PrimitiveDescriptor *primitiveDescriptor;
    void (*primitiveRoutine)(void);
    sqInt reg;

	flags = 0;
	if (primitiveIndex == 0) {
		return 0;
	}
	if ((((primitiveDescriptor = primitiveGeneratorOrNil())) != null)
	 && ((((primitiveDescriptor->primitiveGenerator)) != null)
	 && ((((primitiveDescriptor->primNumArgs)) < 0)
	 || (((primitiveDescriptor->primNumArgs)) == methodOrBlockNumArgs)))) {

		/* Note opcodeIndex so that any arg load instructions
		   for unimplemented primitives can be discarded. */
		opcodeIndexAtPrimitive = opcodeIndex;
		code = ((primitiveDescriptor->primitiveGenerator))();
		if ((code < 0)
		 && (code != UnimplementedPrimitive)) {

			/* Generator failed, so no point continuing... */
			return code;
		}
		if (code == UnfailingPrimitive) {
			return 0;
		}
		if ((code == CompletePrimitive)
		 && (!(((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
		 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))))) {
			return 0;
		}
		if (code == UnimplementedPrimitive) {
			opcodeIndex = opcodeIndexAtPrimitive;
		}
	}
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, (&flags));
	if ((primitiveRoutine == 0)
	 || (primitiveRoutine == (((void (*)(void)) primitiveFail)))) {
		return genFastPrimFail();
	}
	if ((primitiveRoutine == (((void (*)(void)) primitiveHighResClock)))
	 && (methodOrBlockNumArgs == 0)) {
		/* begin genPrimitiveHighResClock64 */
		/* begin preferredRegisterForMovePerfCnt64RL */
		backEnd();
		reg = RAX;
		assert(registerisNotInMask(reg, registerMaskForandandand(ReceiverResultReg, Arg1Reg, Extra0Reg, Extra1Reg)));
		gMovePerfCnt64RL(reg, (0));
		gLogicalShiftRightCqRR((numSmallIntegerBits()) - 1, reg, Arg1Reg);
		if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
			/* begin CmpCq:R: */
			genoperandoperand(CmpCqR, 0, Arg1Reg);
		}
		/* begin JumpNonZero: */
		jumpNotSmallInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		genConvertIntegerInRegtoSmallIntegerInReg(reg, ReceiverResultReg);
		/* begin genPrimReturn */
		if (methodOrBlockNumArgs <= (numRegArgs())) {
			/* begin RetN: */
			genoperand(RetN, 0);
		}
		else {
			/* begin RetN: */
			genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
		}
		jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jumpFailAlloc = genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(reg, ReceiverResultReg, Extra0Reg, Extra1Reg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
		/* begin genPrimReturn */
		if (methodOrBlockNumArgs <= (numRegArgs())) {
			/* begin RetN: */
			genoperand(RetN, 0);
		}
		else {
			/* begin RetN: */
			genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
		}
		jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		code = 0;
	l7:	/* end genPrimitiveHighResClock64 */;
		if (code != UnimplementedPrimitive) {
			return code;
		}
	}
	if (((flags & PrimCallOnSmalltalkStack) != 0)) {
		return compileOnStackExternalPrimitiveflags(primitiveRoutine, flags);
	}
	return compileInterpreterPrimitiveflags(primitiveRoutine, flags);
}

	/* SimpleStackBasedCogit>>#extendedPushBytecode */
static sqInt
extendedPushBytecode(void)
{
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		return genPushReceiverVariable(variableIndex);
	}
	if (variableType == 1) {
		return genPushTemporaryVariable(variableIndex);
	}
	if (variableType == 2) {
		return genPushLiteralIndex(variableIndex);
	}
	return genPushLiteralVariable(variableIndex);
}

	/* SimpleStackBasedCogit>>#extendedStoreAndPopBytecode */
static sqInt
extendedStoreAndPopBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		/* begin genStorePop:ReceiverVariable: */
		return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, variableIndex, ((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
	}
	if (variableType == 1) {
		genStorePopTemporaryVariable(1, variableIndex);
#    if IMMUTABILITY
		/* begin annotateBytecode: */
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction->annotation = HasBytecodePC);
#    endif // IMMUTABILITY
		return 0;
	}
	if (variableType == 3) {
		/* begin genStorePop:LiteralVariable: */
		return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(1, variableIndex, ((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
	}
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#extendedStoreBytecode */
static sqInt
extendedStoreBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		/* begin genStorePop:ReceiverVariable: */
		return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(0, variableIndex, ((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
	}
	if (variableType == 1) {
		genStorePopTemporaryVariable(0, variableIndex);
#    if IMMUTABILITY
		/* begin annotateBytecode: */
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction->annotation = HasBytecodePC);
#    endif // IMMUTABILITY
		return 0;
	}
	if (variableType == 3) {
		/* begin genStorePop:LiteralVariable: */
		return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(0, variableIndex, ((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
	}
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#frameOffsetOfNativeFrameMark */
static sqInt
frameOffsetOfNativeFrameMark(void)
{
	return FoxMFReceiver - BytesPerWord;
}

	/* SimpleStackBasedCogit>>#frameOffsetOfNativeFramePointer */
static sqInt
frameOffsetOfNativeFramePointer(void)
{
	return FoxMFReceiver - (BytesPerWord * 3);
}

	/* SimpleStackBasedCogit>>#frameOffsetOfNativeStackPointer */
static sqInt
frameOffsetOfNativeStackPointer(void)
{
	return FoxMFReceiver - (BytesPerWord * 4);
}

	/* SimpleStackBasedCogit>>#frameOffsetOfPreviousNativeStackPointer */
static sqInt
frameOffsetOfPreviousNativeStackPointer(void)
{
	return FoxMFReceiver - (BytesPerWord * 2);
}

	/* SimpleStackBasedCogit>>#frameOffsetOfTemporary: */
static sqInt NoDbgRegParms
frameOffsetOfTemporary(sqInt index)
{
	return (index < methodOrBlockNumArgs
		? FoxCallerSavedIP + ((methodOrBlockNumArgs - index) * BytesPerWord)
		: (FoxMFReceiver - BytesPerWord) + ((methodOrBlockNumArgs - index) * BytesPerWord));
}


/*	Implemented with SistaCogit only */

	/* SimpleStackBasedCogit>>#genCallMappedInlinedPrimitive */
static sqInt
genCallMappedInlinedPrimitive(void)
{
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#genDoubleFailIfZeroArgRcvr:arg: */
static AbstractInstruction * NoDbgRegParms
genDoubleFailIfZeroArgRcvrarg(int rcvrReg, int argReg)
{
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, TempReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, TempReg, DPFPReg2);
	/* begin CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg2, argReg);
	return gJumpFPEqual(0);
}


/*	Can use any of the first 32 literals for the selector and pass up to 7
	arguments. 
 */

	/* SimpleStackBasedCogit>>#genExtendedSendBytecode */
static sqInt
genExtendedSendBytecode(void)
{
	return genSendnumArgs(byte1 & 0x1F, ((usqInt)(byte1)) >> 5);
}

	/* SimpleStackBasedCogit>>#genExtendedSuperBytecode */
static sqInt
genExtendedSuperBytecode(void)
{
	return genSendSupernumArgs(byte1 & 0x1F, ((usqInt)(byte1)) >> 5);
}


/*	244		11110100	i i i i i i i i	Pop and Jump 0n False i i i i i i i i (+
	Extend B * 256, where Extend B >= 0)
 */

	/* SimpleStackBasedCogit>>#genExtJumpIfFalse */
static sqInt
genExtJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = byte1 + (((sqInt)((usqInt)(extB) << 8)));
	assert(distance == (v4LongForwardBranchDistance(generatorAt(byte0), bytecodePC, ((extA != 0
	? 1
	: 0)) + ((extB != 0
	? 1
	: 0)), methodObj)));
	extB = 0;
	numExtB = 0;
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}


/*	243		11110011	i i i i i i i i	Pop and Jump 0n True i i i i i i i i (+
	Extend B * 256, where Extend B >= 0)
 */

	/* SimpleStackBasedCogit>>#genExtJumpIfTrue */
static sqInt
genExtJumpIfTrue(void)
{
    sqInt distance;
    sqInt target;

	distance = byte1 + (((sqInt)((usqInt)(extB) << 8)));
	assert(distance == (v4LongForwardBranchDistance(generatorAt(byte0), bytecodePC, ((extA != 0
	? 1
	: 0)) + ((extB != 0
	? 1
	: 0)), methodObj)));
	extB = 0;
	numExtB = 0;
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(trueObject(), target);
}


/*	NewspeakV4: 221		11011101		Nop */
/*	SistaV1:		 91		01011011'		Nop */

	/* SimpleStackBasedCogit>>#genExtNopBytecode */
static sqInt
genExtNopBytecode(void)
{
	extA = (numExtB = (extB = 0));
	return 0;
}


/*	SistaV1:		233		11101001	iiiiiiii		Push Character #iiiiiiii (+ Extend A *
	256) 
 */

	/* SimpleStackBasedCogit>>#genExtPushCharacterBytecode */
static sqInt
genExtPushCharacterBytecode(void)
{
    sqInt literal;
    sqInt value;

	value = byte1 + (((sqInt)((usqInt)(extA) << 8)));
	extA = 0;
	/* begin genPushLiteral: */
	literal = characterObjectOf(value);
	return ssPushConstant(literal);
}


/*	NewsqueakV4:	229		11100101	iiiiiiii	Push Integer #iiiiiiii (+ Extend B *
	256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
	SistaV1:		232		11101000	iiiiiiii	Push Integer #iiiiiiii (+ Extend B * 256,
	where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
 */

	/* SimpleStackBasedCogit>>#genExtPushIntegerBytecode */
static sqInt
genExtPushIntegerBytecode(void)
{
    sqInt value;

	value = byte1 + (((sqInt)((usqInt)(extB) << 8)));
	extB = 0;
	numExtB = 0;
	/* begin genPushLiteral: */
	return ssPushConstant((((usqInt)value << 3) | 1));
}


/*	228		11100100	i i i i i i i i	Push Literal #iiiiiiii (+ Extend A * 256) */

	/* SimpleStackBasedCogit>>#genExtPushLiteralBytecode */
static sqInt
genExtPushLiteralBytecode(void)
{
    sqInt index;

	index = byte1 + (((sqInt)((usqInt)(extA) << 8)));
	extA = 0;
	return genPushLiteralIndex(index);
}


/*	227		11100011	i i i i i i i i	Push Literal Variable #iiiiiiii (+ Extend A
	* 256)
 */

	/* SimpleStackBasedCogit>>#genExtPushLiteralVariableBytecode */
static sqInt
genExtPushLiteralVariableBytecode(void)
{
    sqInt index;

	index = byte1 + (((sqInt)((usqInt)(extA) << 8)));
	extA = 0;
	return genPushLiteralVariable(index);
}


/*	SistaV1: *	82			01010010			Push thisContext, (then Extend B = 1 => push
	thisProcess) 
 */

	/* SimpleStackBasedCogit>>#genExtPushPseudoVariable */
static sqInt
genExtPushPseudoVariable(void)
{
    sqInt ext;

	ext = extB;
	extB = 0;
	numExtB = 0;
	switch (ext) {
	case 0:
		return genPushActiveContextBytecode();

	default:
		/* begin unknownBytecode */
		return EncounteredUnknownBytecode;

	}
	return 0;
}


/*	226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A
	* 256)
 */

	/* SimpleStackBasedCogit>>#genExtPushReceiverVariableBytecode */
static sqInt
genExtPushReceiverVariableBytecode(void)
{
    sqInt index;

	index = byte1 + (((sqInt)((usqInt)(extA) << 8)));
	extA = 0;
	return ((mclassCouldBeContext())
	 && (isReadMediatedContextInstVarIndex(index))
		? genPushMaybeContextReceiverVariable(index)
		: genPushReceiverVariable(index));
}


/*	238		11101110	i i i i i j j j	Send Literal Selector #iiiii (+ Extend A *
	32) with jjj (+ Extend B * 8) Arguments
 */

	/* SimpleStackBasedCogit>>#genExtSendBytecode */
static sqInt
genExtSendBytecode(void)
{
    sqInt litIndex;
    sqInt nArgs;

	litIndex = (((usqInt)(byte1)) >> 3) + (((sqInt)((usqInt)(extA) << 5)));
	extA = 0;
	nArgs = (byte1 & 7) + (((sqInt)((usqInt)(extB) << 3)));
	extB = 0;
	numExtB = 0;
	return genSendnumArgs(litIndex, nArgs);
}


/*	239		11101111	i i i i i j j j	Send To Superclass Literal Selector #iiiii
	(+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
 */

	/* SimpleStackBasedCogit>>#genExtSendSuperBytecode */
static sqInt
genExtSendSuperBytecode(void)
{
    int isDirected;
    sqInt litIndex;
    sqInt nArgs;

	if ((isDirected = extB >= 64)) {
		extB = extB & 0x3F;
	}
	litIndex = (((usqInt)(byte1)) >> 3) + (((sqInt)((usqInt)(extA) << 5)));
	extA = 0;
	nArgs = (byte1 & 7) + (((sqInt)((usqInt)(extB) << 3)));
	extB = 0;
	numExtB = 0;
	return (isDirected
		? genSendDirectedSupernumArgs(litIndex, nArgs)
		: genSendSupernumArgs(litIndex, nArgs));
}


/*	236		11101100	i i i i i i i i	Pop and Store Literal Variable #iiiiiiii (+
	Extend A * 256)
 */

	/* SimpleStackBasedCogit>>#genExtStoreAndPopLiteralVariableBytecode */
static sqInt
genExtStoreAndPopLiteralVariableBytecode(void)
{
    sqInt index;

	index = byte1 + (((sqInt)((usqInt)(extA) << 8)));
	extA = 0;
	/* begin genStorePop:LiteralVariable: */
	return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(1, index, ((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
}


/*	235		11101011	i i i i i i i i	Pop and Store Receiver Variable #iiiiiii (+
	Extend A * 256)
 */

	/* SimpleStackBasedCogit>>#genExtStoreAndPopReceiverVariableBytecode */
static sqInt
genExtStoreAndPopReceiverVariableBytecode(void)
{
    sqInt index;

	index = byte1 + (((sqInt)((usqInt)(extA) << 8)));
	extA = 0;
	return ((mclassCouldBeContext())
	 && (isWriteMediatedContextInstVarIndex(index))
		? (/* begin genStorePop:MaybeContextReceiverVariable: */
			genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, index, ((((ssTop())->type)) != SSConstant)
				 || ((isNonImmediate(((ssTop())->constant)))
				 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1))
		: (/* begin genStorePop:ReceiverVariable: */
			genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, index, ((((ssTop())->type)) != SSConstant)
				 || ((isNonImmediate(((ssTop())->constant)))
				 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1)));
}


/*	233		11101001	i i i i i i i i	Store Literal Variable #iiiiiiii (+ Extend A
	* 256)
 */

	/* SimpleStackBasedCogit>>#genExtStoreLiteralVariableBytecode */
static sqInt
genExtStoreLiteralVariableBytecode(void)
{
    sqInt index;

	index = byte1 + (((sqInt)((usqInt)(extA) << 8)));
	extA = 0;
	/* begin genStorePop:LiteralVariable: */
	return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(0, index, ((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
}


/*	232		11101000	i i i i i i i i	Store Receiver Variable #iiiiiii (+ Extend A
	* 256)
 */

	/* SimpleStackBasedCogit>>#genExtStoreReceiverVariableBytecode */
static sqInt
genExtStoreReceiverVariableBytecode(void)
{
    sqInt index;

	index = byte1 + (((sqInt)((usqInt)(extA) << 8)));
	extA = 0;
	return ((mclassCouldBeContext())
	 && (isWriteMediatedContextInstVarIndex(index))
		? (/* begin genStorePop:MaybeContextReceiverVariable: */
			genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(0, index, ((((ssTop())->type)) != SSConstant)
				 || ((isNonImmediate(((ssTop())->constant)))
				 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1))
		: (/* begin genStorePop:ReceiverVariable: */
			genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(0, index, ((((ssTop())->type)) != SSConstant)
				 || ((isNonImmediate(((ssTop())->constant)))
				 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1)));
}


/*	242		11110010	i i i i i i i i	Jump i i i i i i i i (+ Extend B * 256,
	where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
 */

	/* SimpleStackBasedCogit>>#genExtUnconditionalJump */
static sqInt
genExtUnconditionalJump(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt distance;
    sqInt target;

	distance = byte1 + (((sqInt)((usqInt)(extB) << 8)));
	assert(distance == (v4LongBranchDistance(generatorAt(byte0), bytecodePC, ((extA != 0
	? 1
	: 0)) + ((extB != 0
	? 1
	: 0)), methodObj)));
	extB = 0;
	numExtB = 0;
	target = (distance + 2) + bytecodePC;
	if (distance < 0) {
		return genJumpBackTo(target);
	}
	genJumpTo(target);
	/* begin annotateBytecode: */
	abstractInstruction = lastOpcode();
	(abstractInstruction->annotation = HasBytecodePC);
	return 0;
}

	/* SimpleStackBasedCogit>>#genFastPrimFail */
static sqInt
genFastPrimFail(void)
{
	primitiveIndex = 0;
	return UnfailingPrimitive;
}


/*	Support for compileInterpreterPrimitive. Generate inline code
	so as to record the primitive trace as fast as possible. */

	/* SimpleStackBasedCogit>>#genFastPrimTraceUsing:and: */
static void NoDbgRegParms
genFastPrimTraceUsingand(sqInt r1, sqInt r2)
{
    sqInt address;
    sqInt address1;
    sqInt offset;
    sqInt wordConstant;

	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, r2);
	/* begin MoveAb:R: */
	address = primTraceLogIndexAddress();
	genoperandoperand(MoveAbR, address, r2);
	/* begin LoadEffectiveAddressMw:r:R: */
	genoperandoperandoperand(LoadEffectiveAddressMwrR, 1, r2, r1);
	/* begin MoveR:Ab: */
	address1 = primTraceLogIndexAddress();
	genoperandoperand(MoveRAb, r1, address1);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), r1))));
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodObject);
	genoperandoperandoperand(MoveMwrR, offset, r1, TempReg);
	/* begin MoveCw:R: */
	wordConstant = ((sqInt)(primTraceLogAddress()));
	genoperandoperand(MoveCwR, wordConstant, r1);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, r2, r1);
	return;
}

	/* SimpleStackBasedCogit>>#genLoadNewMethod */
static void
genLoadNewMethod(void)
{
    sqInt address;
    sqInt address3;
    sqInt offset;

	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), ClassReg))));
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodObject);
	genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	/* begin MoveR:Aw: */
	address3 = newMethodAddress();
	genoperandoperand(MoveRAw, TempReg, address3);
#  if LRPCheck
	if (checkingLongRunningPrimitives()) {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, TempReg);
		/* begin MoveR:Aw: */
		address = longRunningPrimitiveStopUsecsAddress();
		genoperandoperand(MoveRAw, TempReg, address);
	}
#  endif // LRPCheck
}

	/* SimpleStackBasedCogit>>#genLongJumpIfFalse */
static sqInt
genLongJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = v3LongForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}

	/* SimpleStackBasedCogit>>#genLongJumpIfTrue */
static sqInt
genLongJumpIfTrue(void)
{
    sqInt distance;
    sqInt target;

	distance = v3LongForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(trueObject(), target);
}


/*	230		11100110	i i i i i i i i	Push Temporary Variable #iiiiiiii */

	/* SimpleStackBasedCogit>>#genLongPushTemporaryVariableBytecode */
static sqInt
genLongPushTemporaryVariableBytecode(void)
{
	return genPushTemporaryVariable(byte1);
}


/*	237		11101101	i i i i i i i i	Pop and Store Temporary Variable #iiiiiiii */

	/* SimpleStackBasedCogit>>#genLongStoreAndPopTemporaryVariableBytecode */
static sqInt
genLongStoreAndPopTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(1, byte1);
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */

	/* SimpleStackBasedCogit>>#genLongStoreTemporaryVariableBytecode */
static sqInt
genLongStoreTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(0, byte1);
}

	/* SimpleStackBasedCogit>>#genLongUnconditionalBackwardJump */
static sqInt
genLongUnconditionalBackwardJump(void)
{
    sqInt distance;

	distance = v3LongBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	assert(distance < 0);
	return genJumpBackTo((distance + 2) + bytecodePC);
}

	/* SimpleStackBasedCogit>>#genLongUnconditionalForwardJump */
static sqInt
genLongUnconditionalForwardJump(void)
{
    sqInt distance;
    sqInt targetpc;

	distance = v3LongBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	assert(distance >= 0);
	targetpc = (distance + 2) + bytecodePC;
	return genJumpTo(targetpc);
}


/*	Compile the code for a probe of the first-level method cache for a perform
	primitive. The selector is assumed to be in Arg0Reg. Defer to
	adjustArgumentsForPerform: to
	adjust the arguments before the jump to the method. */
/*	N.B. Can't assume TempReg already contains the tag because a method can
	of course be invoked via the unchecked entry-point, e.g. as does perform:. */

	/* SimpleStackBasedCogit>>#genLookupForPerformNumArgs: */
static sqInt NoDbgRegParms
genLookupForPerformNumArgs(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBadNumArgs;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpInterpret;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt quickConstant;
    sqInt reg;

	genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, SendNumArgsReg, 0);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	if (!(((((usqInt)(methodCacheAddress()))) >= codeBase)
		 && ((((usqInt)(methodCacheAddress()))) < limitAddress))) {
		/* begin MoveCq:R: */
		quickConstant = methodCacheAddress();
		reg = (cacheBaseReg = Extra0Reg);
		genoperandoperand(MoveCqR, quickConstant, reg);
	}
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 0, cacheBaseReg);
	/* begin JumpNonZero: */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = (cacheBaseReg == NoReg
		? (methodCacheAddress()) + (((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))))
		: ((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))));
	itsAHit = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);

	/* check the argument count; if it's wrong fall back on the interpreter primitive. */
	jumpInterpret = genJumpImmediate(ClassReg);
	/* begin genLoadcmNumArgsOf:into: */
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, SendNumArgsReg);
	/* begin MoveMb:r:R: */
	
	BytesPerWord;
	anInstruction = genoperandoperandoperand(MoveMbrR, BytesPerWord, ClassReg, SendNumArgsReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, numArgs, SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpBadNumArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	adjustArgumentsForPerform(numArgs);
	/* begin JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 1, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 2, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpInterpret, jmpTarget(jumpBadNumArgs, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return 0;
}

	/* SimpleStackBasedCogit>>#genMustBeBooleanTrampolineFor:called: */
static usqInt NoDbgRegParms
genMustBeBooleanTrampolineForcalled(sqInt boolean, char *trampolineName)
{
	zeroOpcodeIndex();
	assert(!(shouldAnnotateObjectReference(boolean)));
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, boolean, TempReg);
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceSendMustBeBoolean, trampolineName, 1, TempReg, null, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 1);
}


/*	Implement 28-bit hashMultiply for SmallInteger and LargePositiveInteger
	receivers. 
 */

	/* SimpleStackBasedCogit>>#genPrimitiveHashMultiply */
static sqInt
genPrimitiveHashMultiply(void)
{
    AbstractInstruction *jmpFailImm;
    AbstractInstruction *jmpFailNotPositiveLargeInt;

	if (mclassIsSmallInteger()) {
		genConvertSmallIntegerToIntegerInReg(ReceiverResultReg);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, HashMultiplyConstant, TempReg);
		/* begin MulR:R: */
		genMulRR(backEnd, TempReg, ReceiverResultReg);
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, HashMultiplyMask, ReceiverResultReg);
		genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
		/* begin RetN: */
		genoperand(RetN, 0);
		return CompletePrimitive;
	}
	jmpFailImm = genJumpImmediate(ReceiverResultReg);
	genGetCompactClassIndexNonImmOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, ClassLargePositiveIntegerCompactIndex, ClassReg);
	/* begin JumpNonZero: */
	jmpFailNotPositiveLargeInt = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, ReceiverResultReg, ReceiverResultReg);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, HashMultiplyConstant, TempReg);
	/* begin MulR:R: */
	genMulRR(backEnd, TempReg, ReceiverResultReg);
	/* begin AndCq:R: */
	genoperandoperand(AndCqR, HashMultiplyMask, ReceiverResultReg);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jmpFailImm, jmpTarget(jmpFailNotPositiveLargeInt, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	Generate the substitute return code for an external or FFI primitive call.
	On success simply return, extracting numArgs from newMethod.
	On primitive failure call ceActivateFailingPrimitiveMethod: newMethod. */

	/* SimpleStackBasedCogit>>#genPrimReturnEnterCogCodeEnilopmart: */
static void NoDbgRegParms
genPrimReturnEnterCogCodeEnilopmart(sqInt profiling)
{
    sqInt address;
    sqInt address5;
    sqInt address6;
    sqInt address7;
    sqInt address8;
    AbstractInstruction *anInstruction;
    AbstractInstruction *continuePostSample;
    AbstractInstruction *jmpFail;
    AbstractInstruction *jmpSample;
    AbstractInstruction *jump;
    sqInt liveRegisterMask;
    sqInt quickConstant;
    sqInt quickConstant4;
    sqInt reg;
    sqInt reg1;
    sqInt regOrConst0;
    AbstractInstruction *skip;

	continuePostSample = ((AbstractInstruction *) 0);
	jmpSample = ((AbstractInstruction *) 0);
	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	/* begin MoveAw:R: */
	address6 = primFailCodeAddress();
	genoperandoperand(MoveAwR, address6, TempReg);
	flag("ask concrete code gen if move sets condition codes?");
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, TempReg);
	/* begin JumpNonZero: */
	jmpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (profiling) {
		/* begin genCheckForProfileTimerTick: */
		liveRegisterMask = (0);
		/* begin preferredRegisterForMovePerfCnt64RL */
		reg = RAX;
		/* begin MoveAw:R: */
		address = nextProfileTickAddress();
		genoperandoperand(MoveAwR, address, Arg1Reg);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, Arg1Reg);
		/* begin JumpZero: */
		skip = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		gMovePerfCnt64RL(reg, liveRegisterMask);
		/* begin CmpR:R: */
		assert(!((Arg1Reg == SPReg)));
		genoperandoperand(CmpRR, Arg1Reg, reg);
		/* begin JumpAboveOrEqual: */
		jump = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jmpSample = jump;
		goto l14;
	l14:	/* end genCheckForProfileTimerTick: */;
		/* begin Label */
		continuePostSample = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	/* begin MoveAw:R: */
	address5 = instructionPointerAddress();
	genoperandoperand(MoveAwR, address5, ClassReg);
	genLoadStackPointers(backEnd);
	/* begin MoveMw:r:R: */
	genoperandoperandoperand(MoveMwrR, 0, SPReg, ReceiverResultReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, ClassReg, 0, SPReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jmpFail, checkLiteralforInstruction(newMethodAddress(), genoperandoperand(MoveAwR, newMethodAddress(), SendNumArgsReg)));
	/* begin MoveAw:R: */
	address7 = cStackPointerAddress();
	genoperandoperand(MoveAwR, address7, SPReg);
	compileCallFornumArgsargargargargresultRegregsToSave(ceActivateFailingPrimitiveMethod, 1, SendNumArgsReg, null, null, null, NoReg, 0 /* emptyRegisterMask */);
	/* begin MoveAw:R: */
	address8 = instructionPointerAddress();
	reg1 = ClassReg;
	genoperandoperand(MoveAwR, address8, reg1);
	genLoadStackPointers(backEnd);
	/* begin MoveMw:r:R: */
	
	BytesPerWord;
	anInstruction = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, ReceiverResultReg);
	/* begin PushR: */
	genoperand(PushR, ClassReg);
	/* begin RetN: */
	genoperand(RetN, BytesPerWord);
	if (profiling) {

		/* Call ceTakeProfileSample: to record sample and then continue.  newMethod
		   should be up-to-date.  Need to save and restore the link reg around this call. */
		jmpTarget(jmpSample, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin genMarshallNArgs:arg:arg:arg:arg: */
		assert(null >= 0);
		regOrConst0 = -2 - null;
		assert(1 <= 4);
		if (regOrConst0 < NoReg) {
			/* begin MoveCq:R: */
			quickConstant4 = -2 - regOrConst0;
			genoperandoperand(MoveCqR, quickConstant4, CArg0Reg);
		}
		else {
			if (regOrConst0 != CArg0Reg) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, regOrConst0, CArg0Reg);
			}
		}
		
		/* begin CallFullRT: */
		/* begin CallFull: */
		genoperand(CallFull, ((usqInt)ceTakeProfileSample));
		/* begin genRemoveNArgsFromStack: */
		assert(1 <= 4);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)continuePostSample));
	}
}

	/* SimpleStackBasedCogit>>#genPushConstantFalseBytecode */
static sqInt
genPushConstantFalseBytecode(void)
{
    sqInt literal;

	/* begin genPushLiteral: */
	literal = falseObject();
	return ssPushConstant(literal);
}

	/* SimpleStackBasedCogit>>#genPushConstantNilBytecode */
static sqInt
genPushConstantNilBytecode(void)
{
    sqInt literal;

	/* begin genPushLiteral: */
	literal = nilObject();
	return ssPushConstant(literal);
}


/*	79			01001111		Push 1 */

	/* SimpleStackBasedCogit>>#genPushConstantOneBytecode */
static sqInt
genPushConstantOneBytecode(void)
{
	/* begin genPushLiteral: */
	return ssPushConstant((((usqInt)1 << 3) | 1));
}

	/* SimpleStackBasedCogit>>#genPushConstantTrueBytecode */
static sqInt
genPushConstantTrueBytecode(void)
{
    sqInt literal;

	/* begin genPushLiteral: */
	literal = trueObject();
	return ssPushConstant(literal);
}


/*	78			01001110		Push 0 */

	/* SimpleStackBasedCogit>>#genPushConstantZeroBytecode */
static sqInt
genPushConstantZeroBytecode(void)
{
	/* begin genPushLiteral: */
	return ssPushConstant((((usqInt)0 << 3) | 1));
}

	/* SimpleStackBasedCogit>>#genPushLiteralConstantBytecode */
static sqInt
genPushLiteralConstantBytecode(void)
{
	return genPushLiteralIndex(byte0 & 0x1F);
}


/*	16-31		0001 i i i i		Push Literal Variable #iiii */

	/* SimpleStackBasedCogit>>#genPushLiteralVariable16CasesBytecode */
static sqInt
genPushLiteralVariable16CasesBytecode(void)
{
	return genPushLiteralVariable(byte0 & 15);
}

	/* SimpleStackBasedCogit>>#genPushLiteralVariableBytecode */
static sqInt
genPushLiteralVariableBytecode(void)
{
	return genPushLiteralVariable(byte0 & 0x1F);
}

	/* SimpleStackBasedCogit>>#genPushQuickIntegerConstantBytecode */
static sqInt
genPushQuickIntegerConstantBytecode(void)
{
	/* begin genPushLiteral: */
	return ssPushConstant((((usqInt)(byte0 - 117) << 3) | 1));
}

	/* SimpleStackBasedCogit>>#genPushReceiverVariableBytecode */
static sqInt
genPushReceiverVariableBytecode(void)
{
	return genPushReceiverVariable(byte0 & 15);
}

	/* SimpleStackBasedCogit>>#genPushTemporaryVariableBytecode */
static sqInt
genPushTemporaryVariableBytecode(void)
{
	return genPushTemporaryVariable(byte0 & 15);
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnConst */
sqInt
genQuickReturnConst(void)
{
    sqInt constant;

	constant = quickPrimitiveConstantFor(primitiveIndex);
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(genoperandoperand(MoveCwR, constant, ReceiverResultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, constant, ReceiverResultReg);
	}
	genUpArrowReturn();
	return UnfailingPrimitive;
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnInstVar */
sqInt
genQuickReturnInstVar(void)
{
    sqInt index;

	index = quickPrimitiveInstVarIndexFor(primitiveIndex);
	genLoadSlotsourceRegdestReg(index, ReceiverResultReg, ReceiverResultReg);
	genUpArrowReturn();
	return UnfailingPrimitive;
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnSelf */
sqInt
genQuickReturnSelf(void)
{
	genUpArrowReturn();
	return UnfailingPrimitive;
}

	/* SimpleStackBasedCogit>>#genReturnFalse */
static sqInt
genReturnFalse(void)
{
    sqInt quickConstant;

	if (shouldAnnotateObjectReference(falseObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, falseObject(), ReceiverResultReg), falseObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = falseObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	return genUpArrowReturn();
}

	/* SimpleStackBasedCogit>>#genReturnNil */
static sqInt
genReturnNil(void)
{
    sqInt quickConstant;

	if (shouldAnnotateObjectReference(nilObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, nilObject(), ReceiverResultReg), nilObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = nilObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	return genUpArrowReturn();
}

	/* SimpleStackBasedCogit>>#genReturnNilFromBlock */
static sqInt
genReturnNilFromBlock(void)
{
    sqInt quickConstant;

	assert(inBlock > 0);
	if (shouldAnnotateObjectReference(nilObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, nilObject(), ReceiverResultReg), nilObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = nilObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	return genBlockReturn();
}

	/* SimpleStackBasedCogit>>#genReturnTrue */
static sqInt
genReturnTrue(void)
{
    sqInt quickConstant;

	if (shouldAnnotateObjectReference(trueObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, trueObject(), ReceiverResultReg), trueObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = trueObject();
		genoperandoperand(MoveCqR, quickConstant, ReceiverResultReg);
	}
	return genUpArrowReturn();
}


/*	Can use any of the first 64 literals for the selector and pass up to 3
	arguments. 
 */

	/* SimpleStackBasedCogit>>#genSecondExtendedSendBytecode */
static sqInt
genSecondExtendedSendBytecode(void)
{
	return genSendnumArgs(byte1 & 0x3F, ((usqInt)(byte1)) >> 6);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector0ArgsBytecode */
static sqInt
genSendLiteralSelector0ArgsBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 0);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector1ArgBytecode */
static sqInt
genSendLiteralSelector1ArgBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 1);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector2ArgsBytecode */
static sqInt
genSendLiteralSelector2ArgsBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 2);
}

	/* SimpleStackBasedCogit>>#genShortJumpIfFalse */
static sqInt
genShortJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}

	/* SimpleStackBasedCogit>>#genShortJumpIfTrue */
static sqInt
genShortJumpIfTrue(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpIfto(trueObject(), target);
}

	/* SimpleStackBasedCogit>>#genShortUnconditionalJump */
static sqInt
genShortUnconditionalJump(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpTo(target);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorEqualsEquals */
static sqInt
genSpecialSelectorEqualsEquals(void)
{
	return genInlinedIdenticalOrNotIf(0);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorNotEqualsEquals */
static sqInt
genSpecialSelectorNotEqualsEquals(void)
{
	return genInlinedIdenticalOrNotIf(1);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorSend */
static sqInt
genSpecialSelectorSend(void)
{
    sqInt index;
    sqInt numArgs;

	index = byte0 - ((bytecodeSetOffset == 0x100
		? AltFirstSpecialSelector + 0x100
		: FirstSpecialSelector));
	numArgs = specialSelectorNumArgs(index);
	return genSendnumArgs((-index) - 1, numArgs);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopReceiverVariableBytecode */
static sqInt
genStoreAndPopReceiverVariableBytecode(void)
{
	return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, byte0 & 7, ((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopRemoteTempLongBytecode */
static sqInt
genStoreAndPopRemoteTempLongBytecode(void)
{
	return genStorePopRemoteTempAtneedsStoreCheck(1, byte1, byte2, ((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (shouldAnnotateObjectReference(((ssTop())->constant)))));
}

	/* SimpleStackBasedCogit>>#genStoreAndPopTemporaryVariableBytecode */
static sqInt
genStoreAndPopTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(1, byte0 & 7);
}

	/* SimpleStackBasedCogit>>#genStoreRemoteTempLongBytecode */
static sqInt
genStoreRemoteTempLongBytecode(void)
{
	return genStorePopRemoteTempAtneedsStoreCheck(0, byte1, byte2, ((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (shouldAnnotateObjectReference(((ssTop())->constant)))));
}

	/* SimpleStackBasedCogit>>#genTakeProfileSample */
static void
genTakeProfileSample(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction1;

	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), ClassReg))));
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	assert(1 <= 4);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, CArg0Reg);
	
	if (is32BitSignedImmediate(backEnd, maximumDistanceFromCodeZone(((sqInt)ceTakeProfileSample)))) {
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ((usqIntptr_t)ceTakeProfileSample));
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* begin CallFullRT: */
		/* begin CallFull: */
		
		((usqIntptr_t)ceTakeProfileSample);
		anInstruction1 = genoperand(CallFull, ((usqIntptr_t)ceTakeProfileSample));
	}
	/* begin genRemoveNArgsFromStack: */
	assert(1 <= 4);
	}


/*	SistaV1: *	217		Trap */

	/* SimpleStackBasedCogit>>#genUnconditionalTrapBytecode */
static sqInt
genUnconditionalTrapBytecode(void)
{
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#loadNativeArgumentAddress:to: */
static void NoDbgRegParms
loadNativeArgumentAddressto(sqInt baseOffset, sqInt reg)
{
    sqInt offset;

	/* begin MoveMw:r:R: */
	offset = frameOffsetOfPreviousNativeStackPointer();
	genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, baseOffset - 1, reg);
	return;
}

	/* SimpleStackBasedCogit>>#loadNativeFramePointerInto: */
static void NoDbgRegParms
loadNativeFramePointerInto(sqInt reg)
{
    sqInt offset;

	/* begin MoveMw:r:R: */
	offset = frameOffsetOfNativeFramePointer();
	genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
	return;
}

	/* SimpleStackBasedCogit>>#loadNativeLocalAddress:to: */
static void NoDbgRegParms
loadNativeLocalAddressto(sqInt baseOffset, sqInt reg)
{
    sqInt offset;

	/* begin MoveMw:r:R: */
	offset = frameOffsetOfNativeFramePointer();
	genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, baseOffset - 1, reg);
	return;
}


/*	Collect the branch and send data for cogMethod, storing it into arrayObj. */

	/* SimpleStackBasedCogit>>#mapPCDataFor:into: */
sqInt
mapPCDataForinto(CogMethod *cogMethod, sqInt arrayObj)
{
    sqInt aMethodHeader;
    sqInt aMethodHeader1;
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    sqInt errCode;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    usqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt startbcpc;
    sqInt targetPC;

	latestContinuation = 0;
	introspectionDataIndex = 0;
	introspectionData = arrayObj;
	if (((cogMethod->stackCheckOffset)) == 0) {
		assert(introspectionDataIndex == 0);
		if ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock)) {
			storePointerUncheckedofObjectwithValue(0, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(1, introspectionData, (((usqInt)cbNoSwitchEntryOffset << 3) | 1));
			storePointerUncheckedofObjectwithValue(2, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(3, introspectionData, (((usqInt)cbEntryOffset << 3) | 1));
		}
		else {
			storePointerUncheckedofObjectwithValue(0, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(1, introspectionData, (((usqInt)cmEntryOffset << 3) | 1));
			storePointerUncheckedofObjectwithValue(2, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(3, introspectionData, (((usqInt)cmNoCheckEntryOffset << 3) | 1));
		}
		return 4;
	}
	/* begin mapFor:bcpc:performUntil:arg: */
	startbcpc = startPCOfMethod((cogMethod->methodObject));
	assert((((((CogBlockMethod *) cogMethod))->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)(((CogBlockMethod *) cogMethod)))) + (((((CogBlockMethod *) cogMethod))->stackCheckOffset));
	result = pcDataForAnnotationMcpcBcpcMethod(null, (0 + (((sqInt)((usqInt)(HasBytecodePC) << 1)))), (((char *) mcpc)), startbcpc, (((void *)cogMethod)));
	if (result != 0) {
		errCode = result;
		goto l11;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if ((((((CogBlockMethod *) cogMethod))->cmType)) >= CMMethod) {
		/* begin cmIsFullBlock */
		isInBlock = ((((CogBlockMethod *) cogMethod))->cpicHasMNUCaseOrCMIsFullBlock);
		homeMethod = ((CogMethod *) (((CogBlockMethod *) cogMethod)));
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		/* begin mapStartFor: */
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader = (homeMethod->methodHeader);
		bsOffset = (headerIndicatesAlternateBytecodeSet(aMethodHeader)
						? 0x100
						: 0);
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == (((((CogBlockMethod *) cogMethod))->startpc)));
		homeMethod = cmHomeMethod(((CogBlockMethod *) cogMethod));
		map = findMapLocationForMcpcinMethod((((usqInt)(((CogBlockMethod *) cogMethod)))) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - ((headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
		? AltBlockCreationBytecodeSize
		: BlockCreationBytecodeSize));
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader1 = (homeMethod->methodHeader);
		bsOffset = (headerIndicatesAlternateBytecodeSet(aMethodHeader1)
						? 0x100
						: 0);
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		/* begin nextBytecodePCFor:at:exts:in: */
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj))
	: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	enumeratingCogMethod = homeMethod;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask);
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							errCode = 0;
							goto l11;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							errCode = 0;
							goto l11;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					/* begin nextBytecodePCFor:at:exts:in: */
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj))
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && ((assert(((descriptor->spanFunction)) != null),
				(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = pcDataForAnnotationMcpcBcpcMethod(descriptor, ((isBackwardBranch
	? (((sqInt)((usqInt)(annotation) << 1))) + 1
	: ((sqInt)((usqInt)(annotation) << 1)))), (((char *) mcpc)), ((isBackwardBranch
	? bcpc - (2 * nExts)
	: bcpc)), (((void *)cogMethod)));
				if (result != 0) {
					errCode = result;
					goto l11;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((sqInt)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift)));
			}
		}
		map -= 1;
	}
	errCode = 0;
	l11:	/* end mapFor:bcpc:performUntil:arg: */;
	if (errCode != 0) {
		assert(errCode == PrimErrNoMemory);
		return -1;
	}
	if (((cogMethod->blockEntryOffset)) != 0) {
		errCode = blockDispatchTargetsForperformarg(cogMethod, pcDataForBlockEntryMethod, ((sqInt)cogMethod));
		if (errCode != 0) {
			assert(errCode == PrimErrNoMemory);
			return -1;
		}
	}
	return introspectionDataIndex;
}

	/* SimpleStackBasedCogit>>#numSpecialSelectors */
static sqInt
numSpecialSelectors(void)
{
	return (bytecodeSetOffset == 0x100
				? AltNumSpecialSelectors
				: NumSpecialSelectors);
}


/*	Collect the branch and send data for the block method starting at
	blockEntryMcpc, storing it into picData.
 */

	/* SimpleStackBasedCogit>>#pcDataForBlockEntry:Method: */
static usqInt NoDbgRegParms
pcDataForBlockEntryMethod(sqInt blockEntryMcpc, sqInt cogMethod)
{
	storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, nilObject());
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)(blockEntryMcpc - blockNoContextSwitchOffset) << 3) | 1));
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 2, introspectionData, nilObject());
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 3, introspectionData, (((usqInt)blockEntryMcpc << 3) | 1));
	introspectionDataIndex += 4;
	return 0;
}

	/* SimpleStackBasedCogit>>#pcDataFor:Annotation:Mcpc:Bcpc:Method: */
static sqInt NoDbgRegParms
pcDataForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg)
{
    sqInt actualBcpc;
    sqInt actualMcpc;

	if (!descriptor) {

		/* this is the stackCheck offset */
		assert(introspectionDataIndex == 0);
		if (((((CogMethod *) cogMethodArg))->cpicHasMNUCaseOrCMIsFullBlock)) {
			storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)cbNoSwitchEntryOffset << 3) | 1));
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 2, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 3, introspectionData, (((usqInt)cbEntryOffset << 3) | 1));
		}
		else {
			storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)cmEntryOffset << 3) | 1));
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 2, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 3, introspectionData, (((usqInt)cmNoCheckEntryOffset << 3) | 1));
		}
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 4, introspectionData, (((usqInt)(bcpc + 1) << 3) | 1));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 5, introspectionData, (((((((CogMethod *) cogMethodArg))->stackCheckOffset)) << 3) | 1));
		introspectionDataIndex += 6;
		return 0;
	}
	if ((((usqInt)(isBackwardBranchAndAnnotation)) >> 1) >= HasBytecodePC) {
		actualBcpc = (((isBackwardBranchAndAnnotation & 1) != 0)
			? bcpc + 1
			: (bcpc + ((descriptor->numBytes))) + 1);
		actualMcpc = (((usqInt)mcpc)) - (((usqInt)cogMethodArg));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, (((usqInt)actualBcpc << 3) | 1));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)actualMcpc << 3) | 1));
		introspectionDataIndex += 2;
	}
	return 0;
}


/*	If there is a generator for the current primitive then answer it;
	otherwise answer nil. */

	/* SimpleStackBasedCogit>>#primitiveGeneratorOrNil */
static PrimitiveDescriptor *
primitiveGeneratorOrNil(void)
{
    PrimitiveDescriptor *primitiveDescriptor;

	if (isQuickPrimitiveIndex(primitiveIndex)) {

		/* an unused one */
		primitiveDescriptor = (&(primitiveGeneratorTable[0]));
		(primitiveDescriptor->primitiveGenerator = quickPrimitiveGeneratorFor(primitiveIndex));
		return primitiveDescriptor;
	}
	if (((primitiveIndex >= 1) && (primitiveIndex <= MaxCompiledPrimitiveIndex))) {
		return (&(primitiveGeneratorTable[primitiveIndex]));
	}
	return null;
}

	/* SimpleStackBasedCogit>>#register:isInMask: */
static sqInt NoDbgRegParms
registerisInMask(sqInt reg, sqInt mask)
{
	return ((mask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))) != 0);
}

	/* SimpleStackBasedCogit>>#register:isNotInMask: */
static sqInt NoDbgRegParms
registerisNotInMask(sqInt reg, sqInt mask)
{
	return (!(mask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))));
}

	/* SimpleStackBasedCogit>>#v3:Block:Code:Size: */
static sqInt NoDbgRegParms
v3BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts <= 0);
	return (((sqInt)((usqInt)((fetchByteofObject(pc + 2, aMethodObj))) << 8))) + (fetchByteofObject(pc + 3, aMethodObj));
}


/*	Answer the distance of a two byte forward long jump. */

	/* SimpleStackBasedCogit>>#v3:LongForward:Branch:Distance: */
static sqInt NoDbgRegParms
v3LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return (((sqInt)((usqInt)(((fetchByteofObject(pc, aMethodObj)) & 3)) << 8))) + (fetchByteofObject(pc + 1, aMethodObj));
}


/*	Answer the distance of a two byte forward long jump. */

	/* SimpleStackBasedCogit>>#v3:Long:Branch:Distance: */
static sqInt NoDbgRegParms
v3LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return (((sqInt)((usqInt)((((fetchByteofObject(pc, aMethodObj)) & 7) - 4)) << 8))) + (fetchByteofObject(pc + 1, aMethodObj));
}


/*	N.B. This serves for both BlueBook/V3 and V4 short jumps. */

	/* SimpleStackBasedCogit>>#v3:ShortForward:Branch:Distance: */
static sqInt NoDbgRegParms
v3ShortForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return ((fetchByteofObject(pc, aMethodObj)) & 7) + 1;
}


/*	253		11111101 eei i i kkk	jjjjjjjj		Push Closure Num Copied iii (+ Ext A
	// 16 * 8) Num Args kkk (+ Ext A \\ 16 * 8) BlockSize jjjjjjjj (+ Ext B *
	256). ee = num extensions
 */

	/* SimpleStackBasedCogit>>#v4:Block:Code:Size: */
static sqInt NoDbgRegParms
v4BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
    sqInt byte;
    sqInt byteOne;
    sqInt extAValue;
    sqInt extBValue;
    sqInt extBValue1;
    sqInt extByte;
    sqInt pc1;


	/* If nExts < 0 it isn't known and we rely on the number of extensions encoded in the eeiiikkk byte. */
	byteOne = fetchByteofObject(pc + 1, aMethodObj);
	assert((nExts < 0)
	 || (nExts == (((usqInt)(byteOne)) >> 6)));
	/* begin parseV4Exts:priorTo:in:into: */
	extAValue = (extBValue1 = 0);
	pc1 = (pc - (((usqInt)(byteOne)) >> 6)) - (((usqInt)(byteOne)) >> 6);
	while (pc1 < pc) {
		byte = fetchByteofObject(pc1, aMethodObj);
		pc1 += 1;
		extByte = fetchByteofObject(pc1, aMethodObj);
		pc1 += 1;
		assert((byte == 224)
		 || (byte == 225));
		if (byte == 224) {
			extAValue = ((((sqInt)((usqInt)(extAValue) << 8)))) + extByte;
		}
		else {
			extBValue1 = ((extBValue1 == 0)
			 && (extByte > 0x7F)
				? extByte - 0x100
				: ((((sqInt)((usqInt)(extBValue1) << 8)))) + extByte);
		}
	}
	extBValue = extBValue1;
	return (fetchByteofObject(pc + 2, aMethodObj)) + (((sqInt)((usqInt)(extBValue) << 8)));
}


/*	242		11110010	i i i i i i i i	Jump i i i i i i i i (+ Extend B * 256,
	where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
 */
/*	243		11110011	i i i i i i i i	Pop and Jump 0n True i i i i i i i i (+
	Extend A * 256)
 */
/*	244		11110100	i i i i i i i i	Pop and Jump 0n False i i i i i i i i (+
	Extend A * 256)
 */

	/* SimpleStackBasedCogit>>#v4:LongForward:Branch:Distance: */
static sqInt NoDbgRegParms
v4LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
    sqInt byte;
    sqInt extAValue;
    sqInt extBValue;
    sqInt extBValue1;
    sqInt extByte;
    sqInt pc1;

	assert(nExts >= 0);
	/* begin parseV4Exts:priorTo:in:into: */
	extAValue = (extBValue1 = 0);
	pc1 = (pc - nExts) - nExts;
	while (pc1 < pc) {
		byte = fetchByteofObject(pc1, aMethodObj);
		pc1 += 1;
		extByte = fetchByteofObject(pc1, aMethodObj);
		pc1 += 1;
		assert((byte == 224)
		 || (byte == 225));
		if (byte == 224) {
			extAValue = ((((sqInt)((usqInt)(extAValue) << 8)))) + extByte;
		}
		else {
			extBValue1 = ((extBValue1 == 0)
			 && (extByte > 0x7F)
				? extByte - 0x100
				: ((((sqInt)((usqInt)(extBValue1) << 8)))) + extByte);
		}
	}
	extBValue = extBValue1;
	return (fetchByteofObject(pc + 1, aMethodObj)) + (((sqInt)((usqInt)(extBValue) << 8)));
}


/*	242		11110010	i i i i i i i i	Jump i i i i i i i i (+ Extend B * 256,
	where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
 */

	/* SimpleStackBasedCogit>>#v4:Long:Branch:Distance: */
static sqInt NoDbgRegParms
v4LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
    sqInt byte;
    sqInt extAValue;
    sqInt extBValue;
    sqInt extBValue1;
    sqInt extByte;
    sqInt pc1;

	assert(nExts >= 0);
	/* begin parseV4Exts:priorTo:in:into: */
	extAValue = (extBValue1 = 0);
	pc1 = (pc - nExts) - nExts;
	while (pc1 < pc) {
		byte = fetchByteofObject(pc1, aMethodObj);
		pc1 += 1;
		extByte = fetchByteofObject(pc1, aMethodObj);
		pc1 += 1;
		assert((byte == 224)
		 || (byte == 225));
		if (byte == 224) {
			extAValue = ((((sqInt)((usqInt)(extAValue) << 8)))) + extByte;
		}
		else {
			extBValue1 = ((extBValue1 == 0)
			 && (extByte > 0x7F)
				? extByte - 0x100
				: ((((sqInt)((usqInt)(extBValue1) << 8)))) + extByte);
		}
	}
	extBValue = extBValue1;
	return (fetchByteofObject(pc + 1, aMethodObj)) + (((sqInt)((usqInt)(extBValue) << 8)));
}

	/* SistaMethodZone>>#getCogCodeZoneThreshold */
double
getCogCodeZoneThreshold(void)
{
	return thresholdRatio;
}

	/* SistaMethodZone>>#setCogCodeZoneThreshold: */
sqInt
setCogCodeZoneThreshold(double ratio)
{
	if (!((ratio >= 0.1)
		 && (ratio <= 1.0))) {
		return PrimErrBadArgument;
	}
	thresholdRatio = ratio;
	/* begin computeAllocationThreshold */
	allocationThreshold = ((((((usqInt)((limitAddress - baseAddress) * thresholdRatio))) + ((zoneAlignment()) - 1)) & ~7)) + baseAddress;
	return 0;
}


/*	Add a blockStart for an embedded block. For a binary tree walk block
	dispatch blocks must be compiled in pc/depth-first order but are scanned
	in breadth-first
	order, so do an insertion sort (which of course is really a bubble sort
	because we
	have to move everything higher to make room). */

	/* StackToRegisterMappingCogit>>#addBlockStartAt:numArgs:numCopied:span: */
static BlockStart * NoDbgRegParms
addBlockStartAtnumArgsnumCopiedspan(sqInt bytecodepc, sqInt numArgs, sqInt numCopied, sqInt span)
{
    BlockStart *blockStart;
    sqInt i;
    sqInt j;


	/* Transcript ensureCr; nextPutAll: 'addBlockStartAt: '; print: bytecodepc; cr; flush. */
	if (blockCount > 0) {
		i = blockCount - 1;
		while (1) {

			/* check for repeat addition during recompilation due to initialNil miscount. */
			blockStart = (&(blockStarts[i]));
			if (((blockStart->startpc)) == bytecodepc) {
				return blockStart;
			}
			if (!((((blockStart->startpc)) > bytecodepc)
			 && (i > 0))) break;
			i -= 1;
		}
		for (j = blockCount; j >= (i + 1); j += -1) {
			blockStarts[j] = (blockStarts[j - 1]);
		}
		blockStart = (&(blockStarts[i + 1]));
	}
	else {
		blockStart = (&(blockStarts[blockCount]));
	}
	blockCount += 1;
	(blockStart->startpc = bytecodepc);
	(blockStart->numArgs = numArgs);
	(blockStart->numCopied = numCopied);
	(blockStart->numInitialNils = 0);
	(blockStart->stackCheckLabel = null);
	(blockStart->hasInstVarRef = 0);
	(blockStart->span = span);
	return blockStart;
}


/*	e.g.	Receiver				Receiver	or	Receiver				Receiver	(RISC)
	Selector/Arg0	=>		Arg1			Selector/Arg0	=>		Arg1
	Arg1					Arg2			Arg1					Arg2
	Arg2					Arg3			Arg2			sp->	Arg3
	Arg3			sp->	retpc	sp->	Arg3
	sp->	retpc */
/*	Generate code to adjust the possibly stacked arguments immediately
	before jumping to a method looked up by a perform primitive. */

	/* StackToRegisterMappingCogit>>#adjustArgumentsForPerform: */
static void NoDbgRegParms
adjustArgumentsForPerform(sqInt numArgs)
{
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction6;
    sqInt index;
    sqInt offset1;
    sqInt quickConstant1;

	assert((numRegArgs()) <= 2);
	assert(numArgs >= 1);
	if (numArgs <= (numRegArgs())) {
		if (numArgs == 2) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, Arg1Reg, Arg0Reg);
		}
		return;
	}
	if (((numRegArgs()) + 1) == numArgs) {
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, SPReg, TempReg);
		/* begin MoveMw:r:R: */
		
		BytesPerWord;
		anInstruction1 = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, Arg1Reg);
		/* begin MoveMw:r:R: */
		
		BytesPerWord * 2;
		anInstruction2 = genoperandoperandoperand(MoveMwrR, BytesPerWord * 2, SPReg, Arg0Reg);
		/* begin AddCq:R: */
		quickConstant1 = (numArgs + 1) * BytesPerWord;
		genoperandoperand(AddCqR, quickConstant1, SPReg);
		/* begin MoveR:Mw:r: */
		genoperandoperandoperand(MoveRMwr, TempReg, 0, SPReg);
		return;
	}
	for (index = (numArgs - 1); index >= 1; index += -1) {
		/* begin MoveMw:r:R: */
		
		index * BytesPerWord;
		anInstruction6 = genoperandoperandoperand(MoveMwrR, index * BytesPerWord, SPReg, TempReg);
		/* begin MoveR:Mw:r: */
		offset1 = (index + 1) * BytesPerWord;
		genoperandoperandoperand(MoveRMwr, TempReg, offset1, SPReg);
	}
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin MoveR:Mw:r: */
	genoperandoperandoperand(MoveRMwr, TempReg, 0, SPReg);
}


/*	if there's a free register, use it */

	/* StackToRegisterMappingCogit>>#allocateFloatRegNotConflictingWith: */
static sqInt NoDbgRegParms
allocateFloatRegNotConflictingWith(sqInt regMask)
{
    sqInt reg;

	reg = availableFloatRegisterOrNoneFor(backEnd, (liveFloatRegisters()) | regMask);
	if (reg == NoReg) {

		/* No free register, choose one that does not conflict with regMask */
		reg = freeAnyFloatRegNotConflictingWith(regMask);
	}
	return reg;
}


/*	If the stack entry is already in a register not conflicting with regMask,
	answers it,
	else allocate a new register not conflicting with reg mask
 */

	/* StackToRegisterMappingCogit>>#allocateRegForStackEntryAt:notConflictingWith: */
static sqInt NoDbgRegParms
allocateRegForStackEntryAtnotConflictingWith(sqInt index, sqInt regMask)
{
    sqInt mask;
    CogSimStackEntry *stackEntry;

	stackEntry = ssValue(index);
	mask = registerMaskOrNone(stackEntry);
	if ((mask != 0)
	 && ((!(mask & regMask)))) {
		flag("TODO");
		return registerOrNone(stackEntry);
	}
	return allocateRegNotConflictingWith(regMask);
}


/*	if there's a free register, use it */

	/* StackToRegisterMappingCogit>>#allocateRegNotConflictingWith: */
static sqInt NoDbgRegParms
allocateRegNotConflictingWith(sqInt regMask)
{
    sqInt reg;

	reg = availableRegisterOrNoneFor(backEnd, (liveRegisters()) | regMask);
	if (reg == NoReg) {

		/* No free register, choose one that does not conflict with regMask */
		reg = freeAnyRegNotConflictingWith(regMask);
	}
	if (reg == ReceiverResultReg) {

		/* If we've allocated RcvrResultReg, it's not live anymore */
		voidReceiverResultRegContainsSelf();
	}
	return reg;
}

	/* StackToRegisterMappingCogit>>#anyReferencesToRegister:inTopNItems: */
static sqInt NoDbgRegParms
anyReferencesToRegisterinTopNItems(sqInt reg, sqInt n)
{
    sqInt i;
    sqInt regMask;

	/* begin registerMaskFor: */
	regMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
	for (i = simStackPtr; i >= ((simStackPtr - n) + 1); i += -1) {
		if ((((registerMask(simStackAt(i))) & regMask) != 0)) {
			return 1;
		}
	}
	return 0;
}


/*	Store the smalltalk pointers */

	/* StackToRegisterMappingCogit>>#beginHighLevelCall: */
static void NoDbgRegParms
beginHighLevelCall(sqInt alignment)
{
    sqInt actualAlignment;
    sqInt i;
    sqInt index;
    sqInt mask;
    sqInt offset;

	/* begin ssFlushAll */
	
	index = simStackPtr;
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= index) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = index + 1;
	}
	voidReceiverResultRegContainsSelf();
	genSaveStackPointers(backEnd);
	genLoadCStackPointer(backEnd);
	/* begin MoveMw:r:R: */
	offset = frameOffsetOfNativeFramePointer();
	genoperandoperandoperand(MoveMwrR, offset, FPReg, FPReg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, FPReg);
	actualAlignment = ((alignment < BytesPerWord) ? BytesPerWord : alignment);
	if (actualAlignment > BytesPerWord) {
		mask = -actualAlignment;
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, mask, SPReg);
	}
	currentCallCleanUpSize = 0;
}


/*	This is a static version of ceCallCogCodePopReceiverArg0Regs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* StackToRegisterMappingCogit>>#callCogCodePopReceiverArg0Regs */
void
callCogCodePopReceiverArg0Regs(void)
{
	realCECallCogCodePopReceiverArg0Regs();
}


/*	This is a static version of ceCallCogCodePopReceiverArg1Arg0Regs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* StackToRegisterMappingCogit>>#callCogCodePopReceiverArg1Arg0Regs */
void
callCogCodePopReceiverArg1Arg0Regs(void)
{
	realCECallCogCodePopReceiverArg1Arg0Regs();
}

	/* StackToRegisterMappingCogit>>#callSwitchToCStack */
static sqInt
callSwitchToCStack(void)
{
    sqInt address;

	/* begin MoveAw:R: */
	address = cFramePointerAddress();
	genoperandoperand(MoveAwR, address, FPReg);
	return 0;
}


/*	Restore the link register */

	/* StackToRegisterMappingCogit>>#callSwitchToSmalltalkStack */
static void
callSwitchToSmalltalkStack(void)
{
    sqInt quickConstant;

	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	genLoadStackPointers(backEnd);
}


/*	Loop over bytecodes, dispatching to the generator for each bytecode,
	handling fixups in due course.
 */

	/* StackToRegisterMappingCogit>>#compileAbstractInstructionsFrom:through: */
static sqInt NoDbgRegParms
compileAbstractInstructionsFromthrough(sqInt start, sqInt end)
{
    BytecodeDescriptor *descriptor;
    BytecodeFixup *fixup;
    sqInt nExts;
    sqInt nextOpcodeIndex;
    sqInt result;

	traceSimStack();
	bytecodePC = start;
	nExts = (result = 0);
	descriptor = null;
	deadCode = 0;
	while (1) {
		maybeHaltIfDebugPC();
		mergeWithFixupIfRequired((fixup = fixupAt(bytecodePC)));
		descriptor = loadBytesAndGetDescriptor();
		nextOpcodeIndex = opcodeIndex;
		result = (deadCode
			? mapDeadDescriptorIfNeeded(descriptor)
			: ((descriptor->generator))());
		if (result == 0) {
			/* begin assertExtsAreConsumed: */
			if (!((descriptor->isExtension))) {
				assert((extA == 0)
				 && ((extB == 0)
				 && (numExtB == 0)));
			}
		}
		traceDescriptor(descriptor);
		traceSimStack();
		/* begin patchFixupTargetIfNeeded:nextOpcodeIndex: */
		if ((((((usqInt)((fixup->targetInstruction)))) >= NeedsNonMergeFixupFlag) && ((((usqInt)((fixup->targetInstruction)))) <= NeedsMergeFixupFlag))) {

			/* There is a fixup for this bytecode.  It must point to the first generated
			   instruction for this bytecode.  If there isn't one we need to add a label. */
			if (opcodeIndex == nextOpcodeIndex) {
				/* begin Label */
				genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			(fixup->targetInstruction = abstractInstructionAt(nextOpcodeIndex));
		}
		/* begin maybeDumpLiterals: */
		if (((isBranch(descriptor))
		 && (!(((descriptor->isBranchTrue))
		 || ((descriptor->isBranchFalse)))))
		 || ((descriptor->isReturn))) {
			/* begin dumpLiterals: */
			!(((isBranch(descriptor))
			 && (!(((descriptor->isBranchTrue))
			 || ((descriptor->isBranchFalse)))))
			 || ((descriptor->isReturn)));
		}
		bytecodePC = (bytecodePC + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, bytecodePC, nExts, methodObj))
	: 0));
		if (!((result == 0)
		 && (bytecodePC <= end))) break;
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
	}
	/* begin checkEnoughOpcodes */
	if (opcodeIndex > numAbstractOpcodes) {
		error("Cog JIT internal error. Too many abstract opcodes.  Num opcodes heuristic is too optimistic.");
	}
	return result;
}

	/* StackToRegisterMappingCogit>>#compileBlockBodies */
static sqInt
compileBlockBodies(void)
{
    BlockStart *blockStart;
    sqInt compiledBlocksCount;
    sqInt initialCounterIndex;
    sqInt initialOpcodeIndex;
    sqInt initialStackPtr;
    sqInt (* const pushNilSizeFunction)(sqInt,sqInt) = squeakV3orSistaV1PushNilSizenumInitialNils;
    sqInt result;
    sqInt savedNeedsFrame;
    sqInt savedNumArgs;
    sqInt savedNumTemps;

	assert(blockCount > 0);
	savedNeedsFrame = needsFrame;
	savedNumArgs = methodOrBlockNumArgs;
	savedNumTemps = methodOrBlockNumTemps;
	inBlock = InVanillaBlock;
	compiledBlocksCount = 0;
	while (compiledBlocksCount < blockCount) {
		compilationPass = 1;
		blockStart = blockStartAt(compiledBlocksCount);
		if (((result = scanBlock(blockStart))) < 0) {
			return result;
		}
		initialOpcodeIndex = opcodeIndex;
		/* begin maybeCounterIndex */
		initialCounterIndex = 0;
		while (1) {
			compileBlockEntry(blockStart);
			initialStackPtr = simStackPtr;
			if (((result = compileAbstractInstructionsFromthrough(((blockStart->startpc)) + (pushNilSizeFunction(methodObj, ((blockStart->numInitialNils)))), (((blockStart->startpc)) + ((blockStart->span))) - 1))) < 0) {
				return result;
			}
			if (initialStackPtr == simStackPtr) break;
			assert((initialStackPtr > simStackPtr)
			 || (deadCode));

			/* for asserts */
			compilationPass += 1;
			(blockStart->numInitialNils = (((blockStart->numInitialNils)) + simStackPtr) - initialStackPtr);
			(((blockStart->fakeHeader))->dependent = null);
			reinitializeFixupsFromthrough(((blockStart->startpc)) + ((blockStart->numInitialNils)), (((blockStart->startpc)) + ((blockStart->span))) - 1);
			bzero(abstractOpcodes + initialOpcodeIndex,
									(opcodeIndex - initialOpcodeIndex) * sizeof(AbstractInstruction));
			opcodeIndex = initialOpcodeIndex;
					}
		compiledBlocksCount += 1;
	}
	needsFrame = savedNeedsFrame;
	methodOrBlockNumArgs = savedNumArgs;
	methodOrBlockNumTemps = savedNumTemps;
	return 0;
}


/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. closure (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	Avoid use of SendNumArgsReg which is the flag determining whether
	context switch is allowed on stack-overflow. */
/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. Override to push the register receiver and
	register arguments, if any, and to correctly
	initialize the explicitly nilled/pushed temp entries (they are /not/ of
	type constant nil). */

	/* StackToRegisterMappingCogit>>#compileBlockFrameBuild: */
static void NoDbgRegParms
compileBlockFrameBuild(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction * cascade0;
    sqInt constant;
    sqInt constant1;
    sqInt i;
    sqInt ign;
    sqInt quickConstant;

	/* begin annotateBytecode: */
	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction->annotation = HasBytecodePC);
	/* begin PushR: */
	genoperand(PushR, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	cascade0 = (blockStart->fakeHeader);
	addDependent(cascade0, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)((blockStart->fakeHeader))), genoperand(PushCw, ((sqInt)((blockStart->fakeHeader)))))));
	/* begin setLabelOffset: */
	((cascade0->operands))[1] = MFMethodFlagIsBlockFlag;
	/* begin genPushConstant: */
	constant1 = nilObject();
	if (shouldAnnotateObjectReference(constant1)) {
		annotateobjRef(checkLiteralforInstruction(constant1, genoperand(PushCw, constant1)), constant1);
	}
	else {
		/* begin PushCq: */
		genoperand(PushCq, constant1);
	}
	if ((blockStart->hasInstVarRef)) {

		/* Use ReceiverResultReg for Context to agree with store check trampoline */
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ClassReg, ReceiverResultReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, ReceiverResultReg, Arg0Reg);
		genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, ReceiverIndex, ReceiverResultReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	}
	else {
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ClassReg, Arg0Reg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, Arg0Reg, ReceiverResultReg);
	}
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = 0; i < ((blockStart->numCopied)); i += 1) {
		genLoadSlotsourceRegdestReg(i + ClosureFirstCopiedValueIndex, ClassReg, TempReg);
		/* begin PushR: */
		genoperand(PushR, TempReg);
	}
	(blockStart->stackCheckLabel = compileStackOverflowCheck(1));
	methodOrBlockNumTemps = (((blockStart->numArgs)) + ((blockStart->numCopied))) + ((blockStart->numInitialNils));
	initSimStackForFramefulMethod((blockStart->startpc));
	if (((blockStart->numInitialNils)) > 0) {
		if (((blockStart->numInitialNils)) > 1) {
			if (shouldAnnotateObjectReference(nilObject())) {
				annotateobjRef(genoperandoperand(MoveCwR, nilObject(), TempReg), nilObject());
			}
			else {
				/* begin MoveCq:R: */
				quickConstant = nilObject();
				genoperandoperand(MoveCqR, quickConstant, TempReg);
			}
			for (ign = 1; ign <= ((blockStart->numInitialNils)); ign += 1) {
				/* begin PushR: */
				genoperand(PushR, TempReg);
			}
		}
		else {
			/* begin genPushConstant: */
			constant = nilObject();
			if (shouldAnnotateObjectReference(constant)) {
				annotateobjRef(checkLiteralforInstruction(constant, genoperand(PushCw, constant)), constant);
			}
			else {
				/* begin PushCq: */
				genoperand(PushCq, constant);
			}
		}
	}
}


/*	Make sure ReceiverResultReg holds the receiver, loaded from the closure,
	which is what is initially in ReceiverResultReg. We must annotate the
	first instruction in vanilla blocks so that
	findMethodForStartBcpc:inHomeMethod: can function. We need two annotations
	because the first is a fiducial. */
/*	Make sure ReceiverResultReg holds the receiver, loaded from
	the closure, which is what is initially in ReceiverResultReg */

	/* StackToRegisterMappingCogit>>#compileBlockFramelessEntry: */
static void NoDbgRegParms
compileBlockFramelessEntry(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;

	methodOrBlockNumTemps = (((blockStart->numArgs)) + ((blockStart->numCopied))) + ((blockStart->numInitialNils));
	initSimStackForFramelessBlock((blockStart->startpc));
	if (!(((blockStart->entryLabel)) == null)) {
		/* begin annotateBytecode: */
		abstractInstruction = (blockStart->entryLabel);
		(abstractInstruction->annotation = HasBytecodePC);
	}
	if ((blockStart->hasInstVarRef)) {

		/* Use ReceiverResultReg for Context to agree with store check trampoline */
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, ReceiverResultReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, ReceiverResultReg, Arg0Reg);
		genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, ReceiverIndex, ReceiverResultReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	}
	else {
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, TempReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, TempReg, ReceiverResultReg);
	}
}

	/* StackToRegisterMappingCogit>>#compileCogFullBlockMethod: */
static CogMethod * NoDbgRegParms
compileCogFullBlockMethod(sqInt numCopied)
{
    sqInt allocBytes;
    sqInt fixupBytes;
    sqInt numBlocks;
    sqInt numBytecodes;
    sqInt numberOfAbstractOpcodes;
    sqInt numCleanBlocks;
    sqInt opcodeBytes;
    sqInt result;

	methodOrBlockNumTemps = tempCountOf(methodObj);
	setHasMovableLiteral(0);
	setHasYoungReferent(isYoungObject(methodObj));
	methodOrBlockNumArgs = argumentCountOf(methodObj);
	inBlock = InFullBlock;
	maxLitIndex = -1;
	assert((primitiveIndexOf(methodObj)) == 0);

	/* initial estimate.  Actual endPC is determined in scanMethod. */
	initialPC = startPCOfMethod(methodObj);
	endPC = numBytesOf(methodObj);
	numBytecodes = (endPC - initialPC) + 1;
	primitiveIndex = 0;
	/* begin allocateOpcodes:bytecodes:ifFail: */
	numberOfAbstractOpcodes = (numBytecodes + 10) * 10 /* estimateOfAbstractOpcodesPerBytecodes */;
	numAbstractOpcodes = numberOfAbstractOpcodes;
	opcodeBytes = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupBytes = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;

	/* Document the fact that the MaxStackAllocSize ensures that the number of abstract
	   opcodes fits in a 16 bit integer (e.g. CogBytecodeFixup's instructionIndex). */
	allocBytes = opcodeBytes + fixupBytes;
	assert((((sizeof(CogAbstractInstruction)) + (sizeof(CogBytecodeFixup))) * 0xC000) > MaxStackAllocSize);
	if (allocBytes > MaxStackAllocSize) {
		return ((CogMethod *) MethodTooBig);
		goto l2;
	}
	abstractOpcodes = alloca(allocBytes);
	bzero(abstractOpcodes, allocBytes);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeBytes));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	l2:	/* end allocateOpcodes:bytecodes:ifFail: */;
	flag("TODO");
	if (((numBlocks = scanMethod())) < 0) {
		return ((CogMethod *) numBlocks);
	}
	assert(numBlocks == 0);
	numCleanBlocks = scanForCleanBlocks();
	assert(numCleanBlocks == 0);
	allocateBlockStarts(numBlocks + numCleanBlocks);
	blockCount = 0;
	if (numCleanBlocks > 0) {
		addCleanBlockStarts();
	}
	if (!(maybeAllocAndInitIRCs())) {

		/* Inaccurate error code, but it'll do.  This will likely never fail. */
		return ((CogMethod *) InsufficientCodeSpace);
	}
	blockEntryLabel = null;
	(methodLabel->dependent = null);
	if (((result = compileEntireFullBlockMethod(numCopied))) < 0) {
		return ((CogMethod *) result);
	}
	return generateCogFullBlock();
}

	/* StackToRegisterMappingCogit>>#compileCogMethod: */
static CogMethod * NoDbgRegParms
compileCogMethod(sqInt selector)
{
    sqInt allocBytes;
    int extra;
    sqInt fixupBytes;
    sqInt numBlocks;
    sqInt numBytecodes;
    sqInt numberOfAbstractOpcodes;
    sqInt numCleanBlocks;
    sqInt opcodeBytes;
    sqInt result;

	methodOrBlockNumTemps = tempCountOf(methodObj);
	setHasMovableLiteral(0);
	setHasYoungReferent((isYoungObject(methodObj))
	 || (isYoung(selector)));
	methodOrBlockNumArgs = argumentCountOf(methodObj);
	inBlock = 0;
	maxLitIndex = -1;
	extra = ((((primitiveIndex = primitiveIndexOf(methodObj))) > 0)
	 && (!(isQuickPrimitiveIndex(primitiveIndex)))
		? 30
		: 10);

	/* initial estimate.  Actual endPC is determined in scanMethod. */
	initialPC = startPCOfMethod(methodObj);
	endPC = (isQuickPrimitiveIndex(primitiveIndex)
		? initialPC - 1
		: numBytesOf(methodObj));
	numBytecodes = (endPC - initialPC) + 1;
	/* begin allocateOpcodes:bytecodes:ifFail: */
	numberOfAbstractOpcodes = (numBytecodes + extra) * 10 /* estimateOfAbstractOpcodesPerBytecodes */;
	numAbstractOpcodes = numberOfAbstractOpcodes;
	opcodeBytes = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupBytes = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;

	/* Document the fact that the MaxStackAllocSize ensures that the number of abstract
	   opcodes fits in a 16 bit integer (e.g. CogBytecodeFixup's instructionIndex). */
	allocBytes = opcodeBytes + fixupBytes;
	assert((((sizeof(CogAbstractInstruction)) + (sizeof(CogBytecodeFixup))) * 0xC000) > MaxStackAllocSize);
	if (allocBytes > MaxStackAllocSize) {
		return ((CogMethod *) MethodTooBig);
		goto l2;
	}
	abstractOpcodes = alloca(allocBytes);
	bzero(abstractOpcodes, allocBytes);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeBytes));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* begin resetLiterals */
	labelCounter = 0;
	l2:	/* end allocateOpcodes:bytecodes:ifFail: */;
	if (((numBlocks = scanMethod())) < 0) {
		return ((CogMethod *) numBlocks);
	}
	numCleanBlocks = scanForCleanBlocks();
	if (methodFoundInvalidPostScan()) {
		return ((CogMethod *) ShouldNotJIT);
	}
	allocateBlockStarts(numBlocks + numCleanBlocks);
	blockCount = 0;
	if (numCleanBlocks > 0) {
		addCleanBlockStarts();
	}
	if (!(maybeAllocAndInitIRCs())) {

		/* Inaccurate error code, but it'll do.  This will likely never fail. */
		return ((CogMethod *) InsufficientCodeSpace);
	}
	blockEntryLabel = null;
	(methodLabel->dependent = null);
	if (((result = compileEntireMethod())) < 0) {
		return ((CogMethod *) result);
	}
	return generateCogMethod(selector);
}


/*	Compile the abstract instructions for the entire method, including blocks. */
/*	Compile the abstract instructions for the entire method, including blocks. */

	/* StackToRegisterMappingCogit>>#compileEntireMethod */
static sqInt
compileEntireMethod(void)
{
    sqInt result;

	regArgsHaveBeenPushed = 0;
	/* begin preenMethodLabel */
	((methodLabel->operands))[1] = 0;
	compileAbort();
	compileEntry();
	if (((result = compilePrimitive())) < 0) {
		return result;
	}
	compileFrameBuild();
	if (((result = compileMethodBody())) < 0) {
		return result;
	}
	if (blockCount == 0) {
		return 0;
	}
	if (((result = compileBlockBodies())) < 0) {
		return result;
	}
	return compileBlockDispatch();
}


/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. receiver (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	If there is a primitive and an error code the Nth temp is the error code.
	Ensure SendNumArgsReg is set early on (incidentally to nilObj) because
	it is the flag determining whether context switch is allowed on
	stack-overflow.  */
/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. Override to push the register receiver and
	register arguments, if any. */

	/* StackToRegisterMappingCogit>>#compileFrameBuild */
static void
compileFrameBuild(void)
{
    sqInt i;
    sqInt iLimiT;
    sqInt quickConstant;


#  if IMMUTABILITY
	if (useTwoPaths) {
		compileTwoPathFrameBuild();
		return;
	}
#  endif
	if (!needsFrame) {
		if (useTwoPaths) {
			compileTwoPathFramelessInit();
		}
		initSimStackForFramelessMethod(initialPC);
		return;
	}
	assert(!(useTwoPaths));
	genPushRegisterArgs();
	if (!needsFrame) {
		return;
	}
	/* begin PushR: */
	genoperand(PushR, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperand(PushCw, ((sqInt)methodLabel)))));
	if (shouldAnnotateObjectReference(nilObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, nilObject(), SendNumArgsReg), nilObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = nilObject();
		genoperandoperand(MoveCqR, quickConstant, SendNumArgsReg);
	}
	/* begin PushR: */
	genoperand(PushR, SendNumArgsReg);
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = (methodOrBlockNumArgs + 1), iLimiT = (temporaryCountOfMethodHeader(methodHeader)); i <= iLimiT; i += 1) {
		/* begin PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	if (((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))) {
		compileGetErrorCode();
	}
	stackCheckLabel = compileStackOverflowCheck(canContextSwitchIfActivatingheader(methodObj, methodHeader));
	initSimStackForFramefulMethod(initialPC);
}


/*	Make sure ReceiverResultReg holds the receiver, loaded from the closure,
	which is what is initially in ReceiverResultReg.  */
/*	Make sure ReceiverResultReg holds the receiver, loaded from
	the closure, which is what is initially in ReceiverResultReg */

	/* StackToRegisterMappingCogit>>#compileFullBlockFramelessEntry: */
static void NoDbgRegParms
compileFullBlockFramelessEntry(sqInt numCopied)
{
	initSimStackForFramelessBlock(initialPC);
	flag("TODO");
	genLoadSlotsourceRegdestReg(FullClosureReceiverIndex, ReceiverResultReg, Arg0Reg);
	genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, FullClosureReceiverIndex, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	return;
}


/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. closure (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	Avoid use of SendNumArgsReg which is the flag determining whether
	context switch is allowed on stack-overflow. */

	/* StackToRegisterMappingCogit>>#compileFullBlockMethodFrameBuild: */
static void NoDbgRegParms
compileFullBlockMethodFrameBuild(sqInt numCopied)
{
    sqInt i;
    sqInt iLimiT;
    sqInt quickConstant;

	if (useTwoPaths) {

		/* method with only inst var store, we compile only slow path for now */
		useTwoPaths = 0;
#    if IMMUTABILITY
		needsFrame = 1;
#    endif
	}
	if (!needsFrame) {

		/* it is OK for numCopied to be non-zero provided that the block does not actually use the copied values.
		   There are some blocks like this, e.g. that simply reference copied values to mark them as used for Slang.
		   See e.g. CroquetPlugin>>#primitiveGatherEntropy which contains the block [bufPtr. bufSize. false],
		   which the bytecode compiler optimizes to [false]. */
		compileFullBlockFramelessEntry(numCopied);
		initSimStackForFramelessBlock(initialPC);
		return;
	}
	if (!needsFrame) {
		return;
	}
	/* begin PushR: */
	genoperand(PushR, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperand(PushCw, ((sqInt)methodLabel)))));
	/* begin setLabelOffset: */
	(((((AbstractInstruction *) methodLabel))->operands))[1] = MFMethodFlagIsBlockFlag;
	if (shouldAnnotateObjectReference(nilObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, nilObject(), SendNumArgsReg), nilObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant = nilObject();
		genoperandoperand(MoveCqR, quickConstant, SendNumArgsReg);
	}
	/* begin PushR: */
	genoperand(PushR, SendNumArgsReg);
	flag("TODO");
	genLoadSlotsourceRegdestReg(FullClosureReceiverIndex, ClassReg, Arg0Reg);
	genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, FullClosureReceiverIndex, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = 0; i < numCopied; i += 1) {
		genLoadSlotsourceRegdestReg(i + FullClosureFirstCopiedValueIndex, ClassReg, TempReg);
		/* begin PushR: */
		genoperand(PushR, TempReg);
	}
	for (i = ((methodOrBlockNumArgs + numCopied) + 1), iLimiT = (temporaryCountOfMethodHeader(methodHeader)); i <= iLimiT; i += 1) {
		/* begin PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	stackCheckLabel = compileStackOverflowCheck(1);
	initSimStackForFramefulMethod(initialPC);
}


/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. receiver (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	If there is a primitive and an error code the Nth temp is the error code.
	Ensure SendNumArgsReg is set early on (incidentally to nilObj) because
	it is the flag determining whether context switch is allowed on
	stack-overflow.  */
/*	We are in a method where the frame is needed *only* for instance variable
	store, typically a setter method.
	This case has 20% overhead with Immutability compared to setter without
	immutability because of the stack
	frame creation. We compile two path, one where the object is immutable,
	one where it isn't. At the beginning 
	of the frame build, we take one path or the other depending on the
	receiver mutability.
	
	Note: this specific case happens only where there are only instance
	variabel stores. We could do something
	similar for literal variable stores, but we don't as it's too uncommon.
 */

	/* StackToRegisterMappingCogit>>#compileTwoPathFrameBuild */
#if IMMUTABILITY
static void
compileTwoPathFrameBuild(void)
{
    sqInt i;
    sqInt iLimiT;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpOld;
    sqInt quickConstant;
    sqInt quickConstant1;

	assert(useTwoPaths);
	assert(blockCount == 0);
	jumpImmutable = genJumpImmutablescratchReg(ReceiverResultReg, TempReg);
	/* begin genJumpInOldSpace: */
	
	/* N.B. FLAGS := destReg - scratchReg */
	/* begin CmpCq:R: */
	quickConstant = storeCheckBoundary();
	genoperandoperand(CmpCqR, quickConstant, ReceiverResultReg);
	/* begin JumpAboveOrEqual: */
	jumpOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	assert(!needsFrame);
	initSimStackForFramelessMethod(initialPC);
	/* begin compileMethodBody */
	if (endPC < initialPC) {
		goto l7;
	}
	compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
	l7:	/* end compileMethodBody */;

	/* reset because it impacts inst var store compilation */
	useTwoPaths = 0;
	needsFrame = 1;
	jmpTarget(jumpOld, jmpTarget(jumpImmutable, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genPushRegisterArgs();
	if (!needsFrame) {
		return;
	}
	/* begin PushR: */
	genoperand(PushR, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperand(PushCw, ((sqInt)methodLabel)))));
	if (shouldAnnotateObjectReference(nilObject())) {
		annotateobjRef(genoperandoperand(MoveCwR, nilObject(), SendNumArgsReg), nilObject());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant1 = nilObject();
		genoperandoperand(MoveCqR, quickConstant1, SendNumArgsReg);
	}
	/* begin PushR: */
	genoperand(PushR, SendNumArgsReg);
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = (methodOrBlockNumArgs + 1), iLimiT = (temporaryCountOfMethodHeader(methodHeader)); i <= iLimiT; i += 1) {
		/* begin PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	if (((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))) {
		compileGetErrorCode();
	}
	stackCheckLabel = compileStackOverflowCheck(canContextSwitchIfActivatingheader(methodObj, methodHeader));
	initSimStackForFramefulMethod(initialPC);
}
#endif /* IMMUTABILITY */


/*	We are in a frameless method with at least two inst var stores. We compile
	two paths,
	one where the object is in new space, and one where it isn't. At the
	beginning 
	of the method, we take one path or the other depending on the receiver
	being in newSpace.
 */

	/* StackToRegisterMappingCogit>>#compileTwoPathFramelessInit */
static void
compileTwoPathFramelessInit(void)
{
    AbstractInstruction *jumpOld;
    sqInt quickConstant;

	assert(!(IMMUTABILITY));
	assert(!(needsFrame));
	assert(useTwoPaths);
	/* begin genJumpInOldSpace: */
	
	/* N.B. FLAGS := destReg - scratchReg */
	/* begin CmpCq:R: */
	quickConstant = storeCheckBoundary();
	genoperandoperand(CmpCqR, quickConstant, ReceiverResultReg);
	/* begin JumpAboveOrEqual: */
	jumpOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	initSimStackForFramelessMethod(initialPC);
	/* begin compileMethodBody */
	if (endPC < initialPC) {
		goto l4;
	}
	compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
	l4:	/* end compileMethodBody */;

	/* reset because it impacts inst var store compilation */
	useTwoPaths = 0;
	jmpTarget(jumpOld, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
}

	/* StackToRegisterMappingCogit>>#cPICMissTrampolineFor: */
static sqInt NoDbgRegParms
cPICMissTrampolineFor(sqInt numArgs)
{
	return picMissTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}


/*	Replaces the Blue Book double-extended send [132], in which the first byte
	was wasted on 8 bits of argument count. 
	Here we use 3 bits for the operation sub-type (opType), and the remaining
	5 bits for argument count where needed. 
	The last byte give access to 256 instVars or literals. 
	See also secondExtendedSendBytecode
 */

	/* StackToRegisterMappingCogit>>#doubleExtendedDoAnythingBytecode */
static sqInt
doubleExtendedDoAnythingBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction2;
    sqInt opType;

	opType = ((usqInt)(byte1)) >> 5;
	if (opType == 0) {
		return genSendnumArgs(byte2, byte1 & 0x1F);
	}
	if (opType == 1) {
		return genSendSupernumArgs(byte2, byte1 & 0x1F);
	}
	switch (opType) {
	case 2:
		if (isReadMediatedContextInstVarIndex(byte2)) {
			genPushMaybeContextReceiverVariable(byte2);
		}
		else {
			genPushReceiverVariable(byte2);
			/* begin annotateInstructionForBytecode */
			
			if (prevInstIsPCAnnotated()) {
				/* begin Nop */
				abstractInstruction = gen(Nop);
			}
			else {
				abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			(abstractInstruction->annotation = HasBytecodePC);
			return 0;
		}
		break;
	case 3:
		genPushLiteralIndex(byte2);
		/* begin annotateInstructionForBytecode */
		
		if (prevInstIsPCAnnotated()) {
			/* begin Nop */
			abstractInstruction1 = gen(Nop);
		}
		else {
			abstractInstruction1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		(abstractInstruction1->annotation = HasBytecodePC);
		return 0;

	case 4:
		genPushLiteralVariable(byte2);
		break;
	case 7:
		/* begin genStorePop:LiteralVariable: */
		genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(0, byte2, ((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
#    if IMMUTABILITY

		/* genStorePop:LiteralVariable: annotates; don't annotate twice */
		return 0;
#    endif
		break;
	default:
		
		/* 5 & 6 */
		if (isWriteMediatedContextInstVarIndex(byte2)) {
			/* begin genStorePop:MaybeContextReceiverVariable: */
			genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(opType == 6, byte2, ((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
		}
		else {
			/* begin genStorePop:ReceiverVariable: */
			genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(opType == 6, byte2, ((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (shouldAnnotateObjectReference(((ssTop())->constant)))), 1);
		}
#    if IMMUTABILITY

		/* genStorePop:...ReceiverVariable: annotate; don't annotate twice */
		return 0;
#    endif
;
	}
	assert(needsFrame);
	assert(!(prevInstIsPCAnnotated()));
	/* begin annotateBytecode: */
	abstractInstruction2 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction2->annotation = HasBytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#duplicateTopBytecode */
static sqInt
duplicateTopBytecode(void)
{
    SimStackEntry desc;

	/* begin ssTopDescriptor */
	desc = simStack[simStackPtr];
	return ssPushDesc(desc);
}

	/* StackToRegisterMappingCogit>>#endHighLevelCallWithCleanup */
static void
endHighLevelCallWithCleanup(void)
{
	if (currentCallCleanUpSize > 0) {
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, currentCallCleanUpSize, SPReg);
	}
	callSwitchToSmalltalkStack();
}

	/* StackToRegisterMappingCogit>>#endHighLevelCallWithoutCleanup */
static void
endHighLevelCallWithoutCleanup(void)
{
	callSwitchToSmalltalkStack();
}


/*	Make sure there's a flagged fixup at the target pc in fixups.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#ensureFixupAt: */
static BytecodeFixup * NoDbgRegParms
ensureFixupAt(sqInt targetPC)
{
    BytecodeFixup *fixup;

	/* begin fixupAt: */
	fixup = fixupAtIndex(targetPC - initialPC);
	traceFixupmerge(fixup, 1);
	if ((((usqInt)((fixup->targetInstruction)))) <= NeedsNonMergeFixupFlag) {

		/* convert a non-merge into a merge */
		/* begin becomeMergeFixup */
		(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);
		(fixup->simStackPtr = simStackPtr);
		(fixup->simNativeStackPtr = simNativeStackPtr);
		(fixup->simNativeStackSize = simNativeStackSize);
	}
	else {
		if ((fixup->isTargetOfBackwardBranch)) {

			/* this is the target of a backward branch and
			   so doesn't have a simStackPtr assigned yet. */
			(fixup->simStackPtr = simStackPtr);
			(fixup->simNativeStackPtr = simNativeStackPtr);
			(fixup->simNativeStackSize = simNativeStackSize);
		}
		else {
			assert(((fixup->simStackPtr)) == simStackPtr);
			assert(((fixup->simNativeStackPtr)) == simNativeStackPtr);
			assert(((fixup->simNativeStackSize)) == simNativeStackSize);
		}
	}
	return fixup;
}


/*	Make sure there's a flagged fixup at the target pc in fixups.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#ensureNonMergeFixupAt: */
static BytecodeFixup * NoDbgRegParms
ensureNonMergeFixupAt(sqInt targetPC)
{
    BytecodeFixup *fixup;

	/* begin fixupAt: */
	fixup = fixupAtIndex(targetPC - initialPC);
	traceFixupmerge(fixup, 1);
	if (((fixup->targetInstruction)) == 0) {
		/* begin becomeNonMergeFixup */
		(fixup->targetInstruction) = ((AbstractInstruction *) NeedsNonMergeFixupFlag);
	}
	return fixup;
}

	/* StackToRegisterMappingCogit>>#ensureReceiverResultRegContainsSelf */
static void
ensureReceiverResultRegContainsSelf(void)
{
	if (needsFrame) {
		if (!((((simSelf())->liveRegister)) == ReceiverResultReg)) {
			/* begin ssAllocateRequiredReg: */
			ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
			/* begin putSelfInReceiverResultReg */
			storeToReg(simSelf(), ReceiverResultReg);
			((simSelf())->liveRegister = ReceiverResultReg);
		}
	}
	else {
		assert(((((simSelf())->type)) == SSRegister)
		 && (((((simSelf())->registerr)) == ReceiverResultReg)
		 && (receiverIsInReceiverResultReg())));
	}
}

	/* StackToRegisterMappingCogit>>#evaluate:at: */
static void NoDbgRegParms
evaluateat(BytecodeDescriptor *descriptor, sqInt pc)
{
	byte0 = fetchByteofObject(pc, methodObj);
	assert(descriptor == (generatorAt(bytecodeSetOffset + byte0)));
	loadSubsequentBytesForDescriptorat(descriptor, pc);
	((descriptor->generator))();
}


/*	Attempt to follow a branch to a pc. Handle branches to unconditional jumps
	and branches to push: aBoolean; conditional branch pairs. If the branch
	cannot be
	followed answer targetBytecodePC. It is not possible to follow jumps to
	conditional branches because the stack changes depth. That following is
	left to the genJumpIf:to:
	clients. */

	/* StackToRegisterMappingCogit>>#eventualTargetOf: */
static sqInt NoDbgRegParms
eventualTargetOf(sqInt targetBytecodePC)
{
    sqInt cond;
    sqInt currentTarget;
    BytecodeDescriptor *descriptor;
    sqInt nExts;
    sqInt nextPC;
    sqInt span;

	cond = 0;
	nextPC = (currentTarget = targetBytecodePC);
	while (1) {
		nExts = 0;
		while (1) {
			/* begin generatorForPC: */
			descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC, methodObj)));
			if ((descriptor->isReturn)) {
				return currentTarget;
			}
			if (!((descriptor->isExtension))) break;
			nExts += 1;
			nextPC += (descriptor->numBytes);
		}
		if ((isBranch(descriptor))
		 && (!(((descriptor->isBranchTrue))
		 || ((descriptor->isBranchFalse))))) {
			/* begin spanFor:at:exts:in: */
			span = ((descriptor->spanFunction))(descriptor, nextPC, nExts, methodObj);
			if (span < 0) {

				/* Do *not* follow backward branches; these are interrupt points and should not be elided. */
				return currentTarget;
			}
			nextPC = (nextPC + ((descriptor->numBytes))) + span;
		}
		else {
			if (((descriptor->generator)) == genPushConstantTrueBytecode) {
				cond = 1;
			}
			else {
				if (((descriptor->generator)) == genPushConstantFalseBytecode) {
					cond = 0;
				}
				else {
					return currentTarget;
				}
			}
			if (((fixupAt(nextPC))->isTargetOfBackwardBranch)) {
				return currentTarget;
			}
			nextPC = eventualTargetOf(nextPC + ((descriptor->numBytes)));
			nExts = 0;
			while (1) {
				/* begin generatorForPC: */
				descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC, methodObj)));
				if ((descriptor->isReturn)) {
					return currentTarget;
				}
				if (!((descriptor->isExtension))) break;
				nExts += 1;
				nextPC += (descriptor->numBytes);
			}
			if (!(isBranch(descriptor))) {
				return currentTarget;
			}
			if ((isBranch(descriptor))
			 && (!(((descriptor->isBranchTrue))
			 || ((descriptor->isBranchFalse))))) {
				return currentTarget;
			}
			nextPC = (cond == ((descriptor->isBranchTrue))
				? (nextPC + ((descriptor->numBytes))) + (((descriptor->spanFunction))(descriptor, nextPC, nExts, methodObj))
				: nextPC + ((descriptor->numBytes)));
		}
		currentTarget = nextPC;
	}
	return 0;
}


/*	Spill the closest register on stack not conflicting with regMask. 
	Assertion Failure if regMask has already all the registers */

	/* StackToRegisterMappingCogit>>#freeAnyFloatRegNotConflictingWith: */
static sqInt NoDbgRegParms
freeAnyFloatRegNotConflictingWith(sqInt regMask)
{
    CogSimStackEntry *desc;
    sqInt index;
    sqInt reg;

	assert(needsFrame);
	reg = NoReg;
	index = ((simSpillBase < 0) ? 0 : simSpillBase);
	index = ((simNativeSpillBase < 0) ? 0 : simNativeSpillBase);
	while ((reg == NoReg)
	 && (index < simNativeStackPtr)) {
		desc = simNativeStackAt(index);
		if ((((desc->type)) == SSRegisterSingleFloat)
		 || (((desc->type)) == SSRegisterDoubleFloat)) {
			if (!(((regMask & (((((desc->registerr)) < 0) ? (((usqInt)(1)) >> (-((desc->registerr)))) : (1ULL << ((desc->registerr)))))) != 0))) {
				reg = (desc->registerr);
			}
		}
		index += 1;
	}
	assert(!((reg == NoReg)));
	ssAllocateRequiredFloatReg(reg);
	return reg;
}


/*	Spill the closest register on stack not conflicting with regMask. 
	Assertion Failure if regMask has already all the registers */

	/* StackToRegisterMappingCogit>>#freeAnyRegNotConflictingWith: */
static sqInt NoDbgRegParms
freeAnyRegNotConflictingWith(sqInt regMask)
{
    CogSimStackEntry *desc;
    sqInt index;
    sqInt reg;

	assert(needsFrame);
	reg = NoReg;
	index = ((simSpillBase < 0) ? 0 : simSpillBase);
	while ((reg == NoReg)
	 && (index < simStackPtr)) {
		desc = simStackAt(index);
		if (((desc->type)) == SSRegister) {
			if (!(((regMask & (((((desc->registerr)) < 0) ? (((usqInt)(1)) >> (-((desc->registerr)))) : (1ULL << ((desc->registerr)))))) != 0))) {
				reg = (desc->registerr);
			}
		}
		index += 1;
	}
	assert(!((reg == NoReg)));
	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)), simStackPtr, simNativeStackPtr);
	return reg;
}


/*	Return from block, assuming result already loaded into ReceiverResultReg. */
/*	Return from block, assuming result already loaded into ReceiverResultReg. */

	/* StackToRegisterMappingCogit>>#genBlockReturn */
static sqInt
genBlockReturn(void)
{
	if (needsFrame) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, FPReg, SPReg);
		/* begin PopR: */
		genoperand(PopR, FPReg);
			}
	/* begin RetN: */
	genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);

	/* can't fall through */
	deadCode = 1;
	return 0;
}


/*	Generate special versions of the ceCallCogCodePopReceiverAndClassRegs
	enilopmart that also pop register args from the stack to undo the pushing
	of register args in the abort/miss trampolines. */

	/* StackToRegisterMappingCogit>>#genCallPICEnilopmartNumArgs: */
static void (*genCallPICEnilopmartNumArgs(sqInt numArgs))(void)
{
    sqInt endAddress;
    usqInt enilopmart;
    sqInt quickConstant;
    sqInt reg;
    sqInt size;

	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	genLoadStackPointers(backEnd);
	/* begin PopR: */
	genoperand(PopR, ClassReg);
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin PopR: */
	reg = SendNumArgsReg;
	genoperand(PopR, reg);
	if (numArgs > 0) {
		if (numArgs > 1) {
			/* begin PopR: */
			genoperand(PopR, Arg1Reg);
			assert((numRegArgs()) == 2);
		}
		/* begin PopR: */
		genoperand(PopR, Arg0Reg);
	}
	/* begin PopR: */
	genoperand(PopR, ReceiverResultReg);
	/* begin PushR: */
	genoperand(PushR, SendNumArgsReg);
	/* begin JumpR: */
	genoperand(JumpR, TempReg);
	computeMaximumSizes();
	size = generateInstructionsAt(methodZoneBase);
	endAddress = outputInstructionsAt(methodZoneBase);
	assert((methodZoneBase + size) == endAddress);
	enilopmart = methodZoneBase;
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	recordGeneratedRunTimeaddress(trampolineNamenumRegArgs("ceCallPIC", numArgs), enilopmart);
	return ((void (*)(void)) enilopmart);
}


/*	SistaV1:	**	248	(2)	11111000 iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii
	+ (jjjjj * 256) 
	m=1 means inlined primitive, no hard return after execution. 
	ss defines the unsafe operation set used to encode the operations. 
	(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations,
	other numbers are as yet used).
	See SistaCogit genCallPrimitiveBytecode, EncoderForSistaV1's class comment
	and StackInterpreter>>#callPrimitiveBytecode for more information. */

	/* StackToRegisterMappingCogit>>#genCallPrimitiveBytecode */
static sqInt
genCallPrimitiveBytecode(void)
{
    sqInt prim;
    sqInt primSet;

	if (byte2 < 128) {
		return (bytecodePC == initialPC
			? 0
			: EncounteredUnknownBytecode);
	}
	prim = (((sqInt)((usqInt)((byte2 - 128)) << 8))) + byte1;
	primSet = (((usqInt)(prim)) >> 13) & 3;
	prim = prim & 0x1FFF;
	if (primSet == 1) {
		if (prim < 1000) {
			return genLowcodeNullaryInlinePrimitive(prim);
		}
		if (prim < 2000) {
			return genLowcodeUnaryInlinePrimitive(prim - 1000);
		}
		if (prim < 3000) {
			return genLowcodeBinaryInlinePrimitive(prim - 2000);
		}
		if (prim < 4000) {
			return genLowcodeTrinaryInlinePrimitive(prim - 3000);
		}
	}
	return EncounteredUnknownBytecode;
}


/*	Override to push the register receiver and register arguments, if any. */

	/* StackToRegisterMappingCogit>>#genExternalizePointersForPrimitiveCall */
static sqInt
genExternalizePointersForPrimitiveCall(void)
{
    sqInt address1;

	genPushRegisterArgs();
	
	/* Set coInterpreter stackPointer to the topmost argument, skipping the return address. */
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin MoveR:Aw: */
	address1 = instructionPointerAddress();
	genoperandoperand(MoveRAw, TempReg, address1);
	return genSaveStackPointers(backEnd);
}


/*	Override to push the register receiver and register arguments, if any. */

	/* StackToRegisterMappingCogit>>#genExternalizeStackPointerForFastPrimitiveCall */
static AbstractInstruction *
genExternalizeStackPointerForFastPrimitiveCall(void)
{
    sqInt address1;

	genPushRegisterArgs();
	return (gAddCqRR(BytesPerWord, SPReg, TempReg),
	/* begin MoveR:Aw: */
	(address1 = stackPointerAddress()),
	genoperandoperand(MoveRAw, TempReg, address1));
}


/*	Block compilation. At this point in the method create the block. Note its
	start and defer generating code for it until after the method and any
	other preceding
	blocks. The block's actual code will be compiled later. */
/*	253		11111101 eei i i kkk	jjjjjjjj		Push Closure Num Copied iii (+ Ext A
	// 16 * 8) Num Args kkk (+ Ext A \\ 16 * 8) BlockSize jjjjjjjj (+ Ext B *
	256). ee = num extensions
 */

	/* StackToRegisterMappingCogit>>#genExtPushClosureBytecode */
static sqInt
genExtPushClosureBytecode(void)
{
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt reg;
    sqInt startpc;

	assert(needsFrame);
	startpc = bytecodePC + (((generatorAt(byte0))->numBytes));
	addBlockStartAtnumArgsnumCopiedspan(startpc, (numArgs = (byte1 & 7) + ((extA % 16) * 8)), (numCopied = ((((usqInt)(byte1)) >> 3) & 7) + ((extA / 16) * 8)), byte2 + (((sqInt)((usqInt)(extB) << 8))));
	extA = (numExtB = (extB = 0));
	/* begin genInlineClosure:numArgs:numCopied: */
	assert(getActiveContextAllocatesInMachineCode());
	voidReceiverResultRegContainsSelf();
	/* begin ssAllocateCallReg:and:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg)), simStackPtr, simNativeStackPtr);
	genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(startpc + 1, numArgs, numCopied, methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	for (i = 1; i <= numCopied; i += 1) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
		genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, (ClosureFirstCopiedValueIndex + numCopied) - i, ReceiverResultReg);
	}
	ssPushRegister(ReceiverResultReg);
	return 0;
}


/*	Full Block creation compilation. The block's actual code will be compiled
	separatedly. 
 */
/*	*	255		11111111	xxxxxxxx	siyyyyyy	push Closure Compiled block literal
	index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1
	ignoreOuterContext: i = 1
 */

	/* StackToRegisterMappingCogit>>#genExtPushFullClosureBytecode */
static sqInt
genExtPushFullClosureBytecode(void)
{
    sqInt compiledBlock;
    sqInt i;
    int ignoreContext;
    sqInt numCopied;
    int receiverIsOnStack;
    sqInt reg;

	assert(needsFrame);
	compiledBlock = getLiteral(byte1 + (((sqInt)((usqInt)(extA) << 8))));
	extA = 0;
	numCopied = byte2 & (0x3F);
	receiverIsOnStack = ((byte2 & (128)) != 0);
	ignoreContext = ((byte2 & (64)) != 0);
	voidReceiverResultRegContainsSelf();
	/* begin ssAllocateCallReg:and:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg)), simStackPtr, simNativeStackPtr);
	genCreateFullClosurenumArgsnumCopiedignoreContextcontextNumArgslargeinBlock(compiledBlock, argumentCountOf(compiledBlock), numCopied, ignoreContext, methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	for (i = 1; i <= numCopied; i += 1) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
		genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, (FullClosureFirstCopiedValueIndex + numCopied) - i, ReceiverResultReg);
	}
	if (receiverIsOnStack) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
	}
	else {
		storeToReg(simSelf(), (reg = TempReg));
	}
	genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, FullClosureReceiverIndex, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
	return 0;
}


/*	Enilopmarts transfer control from C into machine code (backwards
	trampolines). 
 */
/*	Enilopmarts transfer control from C into machine code (backwards
	trampolines). Override to add version for generic and PIC-specific entry
	with reg args. */

	/* StackToRegisterMappingCogit>>#generateEnilopmarts */
static void
generateEnilopmarts(void)
{

#  if Debug
	/* begin genEnilopmartFor:forCall:called: */
	realCEEnterCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 0, "realCEEnterCogCodePopReceiverReg");
	ceEnterCogCodePopReceiverReg = enterCogCodePopReceiver;
	/* begin genEnilopmartFor:forCall:called: */
	realCECallCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 1, "realCECallCogCodePopReceiverReg");
	ceCallCogCodePopReceiverReg = callCogCodePopReceiver;
	/* begin genEnilopmartFor:and:forCall:called: */
	realCECallCogCodePopReceiverAndClassRegs = genEnilopmartForandandforCallcalled(ReceiverResultReg, ClassReg, NoReg, 1, "realCECallCogCodePopReceiverAndClassRegs");
	ceCallCogCodePopReceiverAndClassRegs = callCogCodePopReceiverAndClassRegs;
#  else // Debug
	/* begin genEnilopmartFor:forCall:called: */
	ceEnterCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 0, "ceEnterCogCodePopReceiverReg");
	/* begin genEnilopmartFor:forCall:called: */
	ceCallCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 1, "ceCallCogCodePopReceiverReg");
	/* begin genEnilopmartFor:and:forCall:called: */
	ceCallCogCodePopReceiverAndClassRegs = genEnilopmartForandandforCallcalled(ReceiverResultReg, ClassReg, NoReg, 1, "ceCallCogCodePopReceiverAndClassRegs");
#  endif // Debug
	genPrimReturnEnterCogCodeEnilopmart(0);
	cePrimReturnEnterCogCode = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(cePrimReturnEnterCogCode);
	recordGeneratedRunTimeaddress("cePrimReturnEnterCogCode", cePrimReturnEnterCogCode);
	genPrimReturnEnterCogCodeEnilopmart(1);
	cePrimReturnEnterCogCodeProfiling = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(cePrimReturnEnterCogCodeProfiling);
	recordGeneratedRunTimeaddress("cePrimReturnEnterCogCodeProfiling", cePrimReturnEnterCogCodeProfiling);
#  if Debug
	/* begin genEnilopmartFor:and:forCall:called: */
	realCECallCogCodePopReceiverArg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, NoReg, 1, "realCECallCogCodePopReceiverArg0Regs");
	ceCallCogCodePopReceiverArg0Regs = callCogCodePopReceiverArg0Regs;
	realCECallCogCodePopReceiverArg1Arg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, Arg1Reg, 1, "realCECallCogCodePopReceiverArg1Arg0Regs");
	ceCallCogCodePopReceiverArg1Arg0Regs = callCogCodePopReceiverArg1Arg0Regs;
#  else // Debug
	/* begin genEnilopmartFor:and:forCall:called: */
	ceCallCogCodePopReceiverArg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, NoReg, 1, "ceCallCogCodePopReceiverArg0Regs");
	ceCallCogCodePopReceiverArg1Arg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, Arg1Reg, 1, "ceCallCogCodePopReceiverArg1Arg0Regs");
#  endif // Debug
	ceCall0ArgsPIC = genCallPICEnilopmartNumArgs(0);
	ceCall1ArgsPIC = genCallPICEnilopmartNumArgs(1);
	ceCall2ArgsPIC = genCallPICEnilopmartNumArgs(2);
	assert((numRegArgs()) == 2);
}


/*	Size pc-dependent instructions and assign eventual addresses to all
	instructions. Answer the size of the code.
	Compute forward branches based on virtual address (abstract code starts at
	0), assuming that any branches branched over are long.
	Compute backward branches based on actual address.
	Reuse the fixups array to record the pc-dependent instructions that need
	to have
	their code generation postponed until after the others.
	
	Override to add handling for null branches (branches to the immediately
	following instruction) occasioned by StackToRegisterMapping's following of
	jumps.  */

	/* StackToRegisterMappingCogit>>#generateInstructionsAt: */
static sqInt NoDbgRegParms
generateInstructionsAt(sqInt eventualAbsoluteAddress)
{
    sqInt absoluteAddress;
    AbstractInstruction *abstractInstruction;
    BytecodeFixup *fixup;
    sqInt i;
    sqInt j;
    sqInt pcDependentIndex;

	absoluteAddress = eventualAbsoluteAddress;
	pcDependentIndex = 0;
	for (i = 0; i < opcodeIndex; i += 1) {

		/* N.B. if you want to break in resizing, break here, note the instruction index, back up to the
		   sender, restart, and step into computeMaximumSizes, breaking at this instruction's index. */
		abstractInstruction = abstractInstructionAt(i);
		maybeBreakGeneratingFromto(absoluteAddress, absoluteAddress + ((abstractInstruction->maxSize)));
		if (isPCDependent(abstractInstruction)) {
			sizePCDependentInstructionAt(abstractInstruction, absoluteAddress);
			if ((isJump(abstractInstruction))
			 && ((((i + 1) < opcodeIndex)
			 && ((((AbstractInstruction *) (((abstractInstruction->operands))[0]))) == (abstractInstructionAt(i + 1))))
			 || (((i + 2) < opcodeIndex)
			 && (((((AbstractInstruction *) (((abstractInstruction->operands))[0]))) == (abstractInstructionAt(i + 2)))
			 && ((((abstractInstructionAt(i + 1))->opcode)) == Nop))))) {
				(abstractInstruction->opcode = Nop);
				concretizeAt(abstractInstruction, absoluteAddress);
			}
			else {
				fixup = fixupAtIndex(pcDependentIndex);
				pcDependentIndex += 1;
				(fixup->instructionIndex = i);
			}
			absoluteAddress += (abstractInstruction->machineCodeSize);
		}
		else {

			/* N.B. if you want to break in resizing, break here, note the instruction index, back up to the
			   sender, restart, and step into computeMaximumSizes, breaking at this instruction's index. */
			absoluteAddress = concretizeAt(abstractInstruction, absoluteAddress);
			assert(((abstractInstruction->machineCodeSize)) == ((abstractInstruction->maxSize)));
		}
	}
	for (j = 0; j < pcDependentIndex; j += 1) {
		fixup = fixupAtIndex(j);
		abstractInstruction = abstractInstructionAt((fixup->instructionIndex));
		maybeBreakGeneratingFromto((abstractInstruction->address), (((abstractInstruction->address)) + ((abstractInstruction->maxSize))) - 1);
		concretizeAt(abstractInstruction, (abstractInstruction->address));
	}
	return absoluteAddress - eventualAbsoluteAddress;
}


/*	Generate the run-time entries for the various method and PIC entry misses
	and aborts.
	Read the class-side method trampolines for documentation on the various
	trampolines 
 */

	/* StackToRegisterMappingCogit>>#generateMissAbortTrampolines */
static void
generateMissAbortTrampolines(void)
{
    sqInt numArgs;
    sqInt numArgsLimiT;

	for (numArgs = 0, numArgsLimiT = ((numRegArgs()) + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		methodAbortTrampolines[numArgs] = (genMethodAbortTrampolineFor(numArgs));
	}
	for (numArgs = 0, numArgsLimiT = ((numRegArgs()) + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		picAbortTrampolines[numArgs] = (genPICAbortTrampolineFor(numArgs));
	}
	for (numArgs = 0, numArgsLimiT = ((numRegArgs()) + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		picMissTrampolines[numArgs] = (genPICMissTrampolineFor(numArgs));
	}
	/* begin genTrampolineFor:called:arg: */
	ceReapAndResetErrorCodeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceReapAndResetErrorCodeFor, "ceReapAndResetErrorCodeTrampoline", 1, ClassReg, null, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 0);
}


/*	Override to generate code to push the register arg(s) for <= numRegArg
	arity sends.
 */

	/* StackToRegisterMappingCogit>>#generateSendTrampolines */
static void
generateSendTrampolines(void)
{
    sqInt numArgs;

	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		ordinarySendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(ceSendsupertonumArgs, numArgs, trampolineNamenumArgs("ceSend", numArgs), ClassReg, (assert(0 >= 0),
-2 - 0), ReceiverResultReg, (numArgs <= (NumSendTrampolines - 2)
	? (/* begin trampolineArgConstant: */
		assert(numArgs >= 0),
		-2 - numArgs)
	: SendNumArgsReg)));
	}
	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		directedSuperSendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(ceSendabovetonumArgs, numArgs, trampolineNamenumArgs("ceDirectedSuperSend", numArgs), ClassReg, TempReg, ReceiverResultReg, (numArgs <= (NumSendTrampolines - 2)
	? (/* begin trampolineArgConstant: */
		assert(numArgs >= 0),
		-2 - numArgs)
	: SendNumArgsReg)));
		directedSuperBindingSendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(ceSendaboveClassBindingtonumArgs, numArgs, trampolineNamenumArgs("ceDirectedSuperBindingSend", numArgs), ClassReg, TempReg, ReceiverResultReg, (numArgs <= (NumSendTrampolines - 2)
	? (/* begin trampolineArgConstant: */
		assert(numArgs >= 0),
		-2 - numArgs)
	: SendNumArgsReg)));
	}
	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		superSendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(ceSendsupertonumArgs, numArgs, trampolineNamenumArgs("ceSuperSend", numArgs), ClassReg, (assert(1 >= 0),
-2 - 1), ReceiverResultReg, (numArgs <= (NumSendTrampolines - 2)
	? (/* begin trampolineArgConstant: */
		assert(numArgs >= 0),
		-2 - numArgs)
	: SendNumArgsReg)));
	}
	firstSend = ordinarySendTrampolines[0];
	lastSend = superSendTrampolines[NumSendTrampolines - 1];
}


/*	Generate trampolines for tracing. In the simulator we can save a lot of
	time and avoid noise instructions in the lastNInstructions log by
	short-cutting these
	trampolines, but we need them in the real vm. */

	/* StackToRegisterMappingCogit>>#generateTracingTrampolines */
static void
generateTracingTrampolines(void)
{
	/* begin genTrampolineFor:called:arg:regsToSave: */
	ceTraceLinkedSendTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceLinkedSend, "ceTraceLinkedSendTrampoline", 1, ReceiverResultReg, null, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
	/* begin genTrampolineFor:called:regsToSave: */
	ceTraceBlockActivationTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceBlockActivation, "ceTraceBlockActivationTrampoline", 0, null, null, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
	/* begin genTrampolineFor:called:arg:arg:regsToSave: */
	ceTraceStoreTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceStoreOfinto, "ceTraceStoreTrampoline", 2, TempReg, ReceiverResultReg, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
}

	/* StackToRegisterMappingCogit>>#genForwardersInlinedIdenticalOrNotIf: */
static sqInt NoDbgRegParms
genForwardersInlinedIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *anInstruction;
    sqInt argConstant;
    sqInt argNeedsReg;
    sqInt argReg;
    sqInt argReg1;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt constant;
    sqInt constant1;
    BytecodeFixup *fixup;
    sqInt i;
    sqInt index;
    void *jumpTarget;
    void *jumpTarget1;
    AbstractInstruction *label;
    sqInt nExts;
    sqInt nextPC;
    sqInt nextPC1;
    sqInt postBranchPC;
    sqInt postBranchPC1;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrConstant;
    sqInt rcvrNeedsReg;
    sqInt rcvrReg;
    sqInt rcvrReg1;
    sqInt reg;
    sqInt rNext1;
    sqInt rTop1;
    CogSimStackEntry *simStackEntry;
    CogSimStackEntry *simStackEntry1;
    sqInt targetBytecodePC;
    sqInt targetBytecodePC1;
    sqInt topRegistersMask;
    sqInt unforwardArg;
    sqInt unforwardRcvr;

	unforwardRcvr = mayBeAForwarder(ssValue(1));
	unforwardArg = mayBeAForwarder(ssTop());
	if ((!unforwardRcvr)
	 && (!unforwardArg)) {
		return genVanillaInlinedIdenticalOrNotIf(orNot);
	}
	assert(unforwardArg
	 || (unforwardRcvr));
	/* begin isUnannotatableConstant: */
	simStackEntry = ssValue(1);
	rcvrConstant = (((simStackEntry->type)) == SSConstant)
	 && ((isImmediate((simStackEntry->constant)))
	 || (!(shouldAnnotateObjectReference((simStackEntry->constant)))));
	/* begin isUnannotatableConstant: */
	simStackEntry1 = ssTop();
	argConstant = (((simStackEntry1->type)) == SSConstant)
	 && ((isImmediate((simStackEntry1->constant)))
	 || (!(shouldAnnotateObjectReference((simStackEntry1->constant)))));
	/* begin extractMaybeBranchDescriptorInto: */
	primDescriptor = generatorAt(byte0);
	nextPC1 = bytecodePC + ((primDescriptor->numBytes));
	nExts = 0;
	while (1) {
		while (1) {
			/* begin generatorForPC: */
			branchDescriptor1 = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC1, methodObj)));
			if (!((branchDescriptor1->isExtension))) break;
			nExts += 1;
			nextPC1 += (branchDescriptor1->numBytes);
		}
		/* begin isUnconditionalBranch */
		if (!((isBranch(branchDescriptor1))
		 && (!(((branchDescriptor1->isBranchTrue))
		 || ((branchDescriptor1->isBranchFalse)))))) break;
		nextPC1 = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
	}
	targetBytecodePC1 = (postBranchPC1 = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC1 = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
		postBranchPC1 = eventualTargetOf(nextPC1 + ((branchDescriptor1->numBytes)));
	}
	else {
		nextPC1 = bytecodePC + ((primDescriptor->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPC1;
	postBranchPC = postBranchPC1;
	targetBytecodePC = targetBytecodePC1;
	/* begin allocateEqualsEqualsRegistersArgNeedsReg:rcvrNeedsReg:into: */
	argNeedsReg = !argConstant;
	rcvrNeedsReg = !rcvrConstant;
	assert(argNeedsReg
	 || (rcvrNeedsReg));
	argReg1 = (rcvrReg1 = NoReg);
	if (argNeedsReg) {
		if (rcvrNeedsReg) {
			/* begin allocateRegForStackTopTwoEntriesInto: */
			topRegistersMask = 0;
			rTop1 = (rNext1 = NoReg);
			if ((registerOrNone(ssTop())) != NoReg) {
				rTop1 = registerOrNone(ssTop());
			}
			if ((registerOrNone(ssValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg = (rNext1 = registerOrNone(ssValue(1)));
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
			if (rTop1 == NoReg) {
				rTop1 = allocateRegNotConflictingWith(topRegistersMask);
			}
			if (rNext1 == NoReg) {
				rNext1 = allocateRegNotConflictingWith(((rTop1 < 0) ? (((usqInt)(1)) >> (-rTop1)) : (1ULL << rTop1)));
			}
			assert(!(((rTop1 == NoReg)
 || (rNext1 == NoReg))));
			argReg1 = rTop1;
			rcvrReg1 = rNext1;
			popToReg(ssTop(), argReg1);
			popToReg(ssValue(1), rcvrReg1);
		}
		else {
			/* begin allocateRegForStackEntryAt: */
			argReg1 = allocateRegForStackEntryAtnotConflictingWith(0, 0);
			popToReg(ssTop(), argReg1);
			if (((ssValue(1))->spilled)) {
				/* begin AddCq:R: */
				
				BytesPerWord;
				anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
			}
		}
	}
	else {
		assert(rcvrNeedsReg);
		assert(!((((ssTop())->spilled))));
		/* begin allocateRegForStackEntryAt: */
		rcvrReg1 = allocateRegForStackEntryAtnotConflictingWith(1, 0);
		popToReg(ssValue(1), rcvrReg1);
	}
	assert(!((argNeedsReg
 && (argReg1 == NoReg))));
	assert(!((rcvrNeedsReg
 && (rcvrReg1 == NoReg))));
	rcvrReg = rcvrReg1;
	argReg = argReg1;
	if (!(((branchDescriptor->isBranchTrue))
		 || ((branchDescriptor->isBranchFalse)))) {
		return genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(argConstant, rcvrConstant, argReg, rcvrReg, orNot);
	}
	/* begin ssFlushTo: */
	index = simStackPtr - 2;
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= index) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = index + 1;
	}
	/* begin Label */
	label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin genCmpArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	assert((argReg != NoReg)
	 || (rcvrReg != NoReg));
	if (argConstant) {
		/* begin genCmpConstant:R: */
		constant = ((ssTop())->constant);
		if (shouldAnnotateObjectReference(constant)) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, rcvrReg)), constant);
		}
		else {
			/* begin CmpCq:R: */
			genoperandoperand(CmpCqR, constant, rcvrReg);
		}
	}
	else {
		if (rcvrConstant) {
			/* begin genCmpConstant:R: */
			constant1 = ((ssValue(1))->constant);
			if (shouldAnnotateObjectReference(constant1)) {
				annotateobjRef(checkLiteralforInstruction(constant1, genoperandoperand(CmpCwR, constant1, argReg)), constant1);
			}
			else {
				/* begin CmpCq:R: */
				genoperandoperand(CmpCqR, constant1, argReg);
			}
		}
		else {
			/* begin CmpR:R: */
			assert(!((argReg == SPReg)));
			genoperandoperand(CmpRR, argReg, rcvrReg);
		}
	}
	ssPop(2);
	if ((((fixupAt(nextPC))->targetInstruction)) == 0) {

		/* The next instruction is dead.  we can skip it. */
		deadCode = 1;
		ensureFixupAt(targetBytecodePC);
		ensureFixupAt(postBranchPC);
	}
	else {
		assert(!(deadCode));
	}
	if (orNot == ((branchDescriptor->isBranchTrue))) {

		/* a == b ifFalse: ... or a ~~ b ifTrue: ... jump on equal to post-branch pc */
		fixup = ensureNonMergeFixupAt(targetBytecodePC);
		/* begin JumpZero: */
		jumpTarget = ensureNonMergeFixupAt(postBranchPC);
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
	}
	else {

		/* orNot is true for ~~ */
		/* a == b ifTrue: ... or a ~~ b ifFalse: ... jump on equal to target pc */
		fixup = ensureNonMergeFixupAt(postBranchPC);
		/* begin JumpZero: */
		jumpTarget1 = ensureNonMergeFixupAt(targetBytecodePC);
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget1));
	}
	if (unforwardArg
	 && (unforwardRcvr)) {
		/* begin genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(argReg, TempReg, label, 0);
	}
	genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder((unforwardRcvr
		? rcvrReg
		: argReg), TempReg, label, fixup);
	if (!deadCode) {
		ssPushConstant(trueObject());
	}
	return 0;
}


/*	Generates the machine code for #== in the case where the instruction is
	not followed by a branch
 */

	/* StackToRegisterMappingCogit>>#genIdenticalNoBranchArgIsConstant:rcvrIsConstant:argReg:rcvrReg:orNotIf: */
static sqInt NoDbgRegParms
genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(sqInt argIsConstant, sqInt rcvrIsConstant, sqInt argReg, sqInt rcvrRegOrNone, sqInt orNot)
{
    sqInt constant;
    sqInt constant1;
    AbstractInstruction *jumpEqual;
    AbstractInstruction *jumpNotEqual;
    AbstractInstruction *label;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt resultReg;

	/* begin Label */
	label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin genCmpArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	assert((argReg != NoReg)
	 || (rcvrRegOrNone != NoReg));
	if (argIsConstant) {
		/* begin genCmpConstant:R: */
		constant = ((ssTop())->constant);
		if (shouldAnnotateObjectReference(constant)) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, rcvrRegOrNone)), constant);
		}
		else {
			/* begin CmpCq:R: */
			genoperandoperand(CmpCqR, constant, rcvrRegOrNone);
		}
	}
	else {
		if (rcvrIsConstant) {
			/* begin genCmpConstant:R: */
			constant1 = ((ssValue(1))->constant);
			if (shouldAnnotateObjectReference(constant1)) {
				annotateobjRef(checkLiteralforInstruction(constant1, genoperandoperand(CmpCwR, constant1, argReg)), constant1);
			}
			else {
				/* begin CmpCq:R: */
				genoperandoperand(CmpCqR, constant1, argReg);
			}
		}
		else {
			/* begin CmpR:R: */
			assert(!((argReg == SPReg)));
			genoperandoperand(CmpRR, argReg, rcvrRegOrNone);
		}
	}
	ssPop(2);
	resultReg = (rcvrRegOrNone == NoReg
		? argReg
		: rcvrRegOrNone);
	/* begin JumpZero: */
	jumpEqual = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	if (!argIsConstant) {
		/* begin genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(argReg, TempReg, label, 0);
	}
	if (!rcvrIsConstant) {
		/* begin genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(rcvrRegOrNone, TempReg, label, 0);
	}
	if (orNot) {
		if (shouldAnnotateObjectReference(trueObject())) {
			annotateobjRef(genoperandoperand(MoveCwR, trueObject(), resultReg), trueObject());
		}
		else {
			/* begin MoveCq:R: */
			quickConstant = trueObject();
			genoperandoperand(MoveCqR, quickConstant, resultReg);
		}
	}
	else {
		if (shouldAnnotateObjectReference(falseObject())) {
			annotateobjRef(genoperandoperand(MoveCwR, falseObject(), resultReg), falseObject());
		}
		else {
			/* begin MoveCq:R: */
			quickConstant1 = falseObject();
			genoperandoperand(MoveCqR, quickConstant1, resultReg);
		}
	}
	/* begin Jump: */
	jumpNotEqual = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpEqual, (orNot
		? (shouldAnnotateObjectReference(falseObject())
				? annotateobjRef(genoperandoperand(MoveCwR, falseObject(), resultReg), falseObject())
				: (/* begin MoveCq:R: */
					(quickConstant2 = falseObject()),
					genoperandoperand(MoveCqR, quickConstant2, resultReg)))
		: (shouldAnnotateObjectReference(trueObject())
				? annotateobjRef(genoperandoperand(MoveCwR, trueObject(), resultReg), trueObject())
				: (/* begin MoveCq:R: */
					(quickConstant3 = trueObject()),
					genoperandoperand(MoveCqR, quickConstant3, resultReg)))));
	jmpTarget(jumpNotEqual, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushRegister(resultReg);
	return 0;
}


/*	Decompose code generation for #== into a common constant-folding version,
	followed by a double dispatch through the objectRepresentation to a
	version that doesn't deal with forwarders and a version that does. */

	/* StackToRegisterMappingCogit>>#genInlinedIdenticalOrNotIf: */
static sqInt NoDbgRegParms
genInlinedIdenticalOrNotIf(sqInt orNot)
{
    BytecodeDescriptor *primDescriptor;
    sqInt result;

	primDescriptor = generatorAt(byte0);
	if ((isUnannotatableConstant(ssTop()))
	 && (isUnannotatableConstant(ssValue(1)))) {
		assert(!((primDescriptor->isMapped)));
		result = ((orNot
			? (((ssTop())->constant)) != (((ssValue(1))->constant))
			: (((ssTop())->constant)) == (((ssValue(1))->constant)))
			? trueObject()
			: falseObject());
		ssPop(2);
		return ssPushConstant(result);
	}
	/* begin genInlinedIdenticalOrNotIfGuts: */
	return genForwardersInlinedIdenticalOrNotIf(orNot);
}

	/* StackToRegisterMappingCogit>>#genJumpBackTo: */
static sqInt NoDbgRegParms
genJumpBackTo(sqInt targetBytecodePC)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    sqInt address;
    sqInt i;
    sqInt index;
    void *jumpTarget;
    void *jumpTarget1;

	/* begin ssFlushTo: */
	index = simStackPtr;
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= index) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = index + 1;
	}

	/* can't fall through */
	deadCode = 1;
	/* begin MoveAw:R: */
	address = stackLimitAddress();
	genoperandoperand(MoveAwR, address, TempReg);
	/* begin CmpR:R: */
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, SPReg);
	/* begin JumpAboveOrEqual: */
	
	jumpTarget = fixupAtIndex(targetBytecodePC - initialPC);
	genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)jumpTarget));
	/* begin CallRT: */
	
	abstractInstruction = genoperand(Call, ceCheckForInterruptTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin annotateBytecode: */
	abstractInstruction1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction1->annotation = HasBytecodePC);
	/* begin Jump: */
	
	jumpTarget1 = fixupAtIndex(targetBytecodePC - initialPC);
	genoperand(Jump, ((sqInt)jumpTarget1));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genJumpIf:to: */
static sqInt NoDbgRegParms
genJumpIfto(sqInt boolean, sqInt targetBytecodePC)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    CogSimStackEntry *desc;
    sqInt eventualTarget;
    BytecodeFixup *fixup;
    sqInt i;
    sqInt index;
    void *jumpTarget;
    AbstractInstruction *ok;
    sqInt quickConstant;

	eventualTarget = eventualTargetOf(targetBytecodePC);
	/* begin ssFlushTo: */
	index = simStackPtr - 1;
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= index) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = index + 1;
	}
	desc = ssTop();
	ssPop(1);
	if ((((desc->type)) == SSConstant)
	 && ((((desc->constant)) == (trueObject()))
	 || (((desc->constant)) == (falseObject())))) {

		/* Must arrange there's a fixup at the target whether it is jumped to or
		   not so that the simStackPtr can be kept correct. */

		/* Must annotate the bytecode for correct pc mapping. */
		fixup = ensureFixupAt(eventualTarget);
		/* begin annotateBytecode: */
		if (((desc->constant)) == boolean) {
			/* begin Jump: */
			abstractInstruction = genoperand(Jump, ((sqInt)fixup));
		}
		else {
			if (prevInstIsPCAnnotated()) {
				/* begin Nop */
				abstractInstruction = gen(Nop);
			}
			else {
				/* begin Label */
				abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
		}
		(abstractInstruction->annotation = HasBytecodePC);
		extA = 0;
		return 0;
	}
	popToReg(desc, TempReg);
	assert((objectAfter(falseObject())) == (trueObject()));
	/* begin genSubConstant:R: */
	if (shouldAnnotateObjectReference(boolean)) {
		annotateobjRef(checkLiteralforInstruction(boolean, genoperandoperand(SubCwR, boolean, TempReg)), TempReg);
	}
	else {
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, boolean, TempReg);
	}
	/* begin JumpZero: */
	jumpTarget = ensureFixupAt(eventualTarget);
	genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
	if (((extA & 1) != 0)) {
		extA = 0;
		/* begin annotateBytecode: */
		abstractInstruction1 = lastOpcode();
		(abstractInstruction1->annotation = HasBytecodePC);
		return 0;
	}
	extA = 0;
	/* begin CmpCq:R: */
	quickConstant = (boolean == (falseObject())
		? (trueObject()) - (falseObject())
		: (falseObject()) - (trueObject()));
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpZero: */
	ok = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genCallMustBeBooleanFor(boolean);
	jmpTarget(ok, annotateBytecode(genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genJumpTo: */
static sqInt NoDbgRegParms
genJumpTo(sqInt targetBytecodePC)
{
    sqInt eventualTarget;
    BytecodeFixup *fixup;
    BytecodeDescriptor *generator;
    sqInt i;
    sqInt i1;

	eventualTarget = eventualTargetOf(targetBytecodePC);
	if ((eventualTarget > bytecodePC)
	 && (((simStackPtr >= methodOrBlockNumArgs)
	 && (stackEntryIsBoolean(ssTop())))
	 && ((((generator = generatorForPC(eventualTarget))->isBranchTrue))
	 || (((generator = generatorForPC(eventualTarget))->isBranchFalse))))) {
		eventualTarget = (eventualTarget + ((generator->numBytes))) + ((((generator->isBranchTrue)) == ((((ssTop())->constant)) == (trueObject()))
	? (/* begin spanFor:at:exts:in: */
		((generator->spanFunction))(generator, eventualTarget, 0, methodObj))
	: 0));
		ssPop(1);
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		fixup = ensureFixupAt(eventualTarget);
		ssPop(-1);
	}
	else {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i1 <= simStackPtr; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		fixup = ensureFixupAt(eventualTarget);
	}

	/* can't fall through */
	deadCode = 1;
	/* begin Jump: */
	genoperand(Jump, ((sqInt)fixup));
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeBinaryInlinePrimitive: */
static sqInt NoDbgRegParms
genLowcodeBinaryInlinePrimitive(sqInt prim)
{
    sqInt frResult;
    sqInt frResult1;
    sqInt i11;
    sqInt i110;
    sqInt i111;
    sqInt i1110;
    sqInt i1111;
    sqInt i112;
    sqInt i114;
    sqInt i115;
    sqInt i116;
    sqInt i117;
    sqInt i118;
    sqInt i12;
    sqInt i120;
    sqInt i121;
    sqInt i122;
    sqInt i124;
    sqInt i125;
    sqInt i13;
    sqInt i14;
    sqInt i15;
    sqInt i16;
    sqInt i17;
    sqInt i18;
    sqInt i19;
    sqInt i21;
    sqInt i210;
    sqInt i211;
    sqInt i213;
    sqInt i28;
    sqInt i41;
    sqInt i42;
    sqInt index11;
    sqInt index110;
    sqInt index111;
    sqInt index1110;
    sqInt index1111;
    sqInt index112;
    sqInt index113;
    sqInt index115;
    sqInt index116;
    sqInt index117;
    sqInt index118;
    sqInt index12;
    sqInt index120;
    sqInt index121;
    sqInt index122;
    sqInt index124;
    sqInt index125;
    sqInt index13;
    sqInt index14;
    sqInt index15;
    sqInt index16;
    sqInt index17;
    sqInt index18;
    sqInt index19;
    sqInt index21;
    sqInt index210;
    sqInt index212;
    sqInt index27;
    sqInt index29;
    sqInt index41;
    sqInt index42;
    sqInt object;
    sqInt object1;
    sqInt object10;
    sqInt object11;
    sqInt object12;
    sqInt object13;
    sqInt object14;
    sqInt object15;
    sqInt object16;
    sqInt object17;
    sqInt object18;
    sqInt object19;
    sqInt object2;
    sqInt object20;
    sqInt object21;
    sqInt object22;
    sqInt object23;
    sqInt object3;
    sqInt object4;
    sqInt object5;
    sqInt object6;
    sqInt object7;
    sqInt object8;
    sqInt object9;
    sqInt pointer;
    sqInt rOopTop1;
    sqInt rOopTop10;
    sqInt rOopTop11;
    sqInt rOopTop110;
    sqInt rOopTop111;
    sqInt rOopTop12;
    sqInt rOopTop13;
    sqInt rOopTop15;
    sqInt rOopTop16;
    sqInt rOopTop17;
    sqInt rOopTop18;
    sqInt rOopTop2;
    sqInt rOopTop20;
    sqInt rOopTop21;
    sqInt rOopTop22;
    sqInt rOopTop24;
    sqInt rOopTop25;
    sqInt rOopTop3;
    sqInt rOopTop4;
    sqInt rOopTop5;
    sqInt rOopTop6;
    sqInt rOopTop7;
    sqInt rOopTop8;
    sqInt rOopTop9;
    sqInt rResult1;
    sqInt rResult10;
    sqInt rResult12;
    sqInt rResult14;
    sqInt rResult15;
    sqInt rResult16;
    sqInt rResult18;
    sqInt rResult3;
    sqInt rResult4;
    sqInt rResult5;
    sqInt rResult6;
    sqInt rResult7;
    sqInt rResult8;
    sqInt rResult9;
    sqInt value;
    sqInt value1;
    sqInt value10;
    sqInt value11;
    sqInt value12;
    sqInt value13;
    sqInt value14;
    sqInt value2;
    sqInt value3;
    sqInt value4;
    sqInt value5;
    sqInt value6;
    sqInt value7;
    sqInt value8;
    sqInt value9;

	switch (prim) {
	case 0:
		/* begin genLowcodeByteSizeOf */
		
		rOopTop2 = NoReg;
		rResult3 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop2 = registerOrNone(ssTop());
			index12 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i12 = index12; i12 <= (simStackPtr); i12 += 1) {
				if ((registerOrNone(simStackAt(index12))) == rOopTop2) {
					goto l10;
				}
			}
	l10:	;
			rOopTop2 = NoReg;
	l9:	;
		}
		if (rOopTop2 == NoReg) {
			rOopTop2 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult3 = allocateRegNotConflictingWith(((rOopTop2 < 0) ? (((usqInt)(1)) >> (-rOopTop2)) : (1ULL << rOopTop2)));
		assert(!(((rOopTop2 == NoReg)
 || (rResult3 == NoReg))));
		object1 = rOopTop2;
		value1 = rResult3;
		popToReg(ssTop(), object1);
		ssPop(1);
		/* begin ssFlushAll */
		
		index21 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index21) {
			for (i21 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index21) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index21)); i21 <= index21; i21 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i21), frameOffsetOfTemporary(i21 - 1), FPReg);
			}
			simSpillBase = index21 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcByteSizeOfto(object1, value1);
		return 0;

	case 1:
		/* begin genLowcodeFirstFieldPointer */
		
		rOopTop3 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop3 = registerOrNone(ssTop());
			index13 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i13 = index13; i13 <= (simStackPtr); i13 += 1) {
				if ((registerOrNone(simStackAt(index13))) == rOopTop3) {
					goto l13;
				}
			}
	l13:	;
			rOopTop3 = NoReg;
	l12:	;
		}
		if (rOopTop3 == NoReg) {
			rOopTop3 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop3 == NoReg)));
		object2 = rOopTop3;
		popToReg(ssTop(), object2);
		ssPop(1);
		genLcFirstFieldPointer(object2);
		return 0;

	case 2:
		/* begin genLowcodeFirstIndexableFieldPointer */
		
		rOopTop4 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop4 = registerOrNone(ssTop());
			index14 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i14 = index14; i14 <= (simStackPtr); i14 += 1) {
				if ((registerOrNone(simStackAt(index14))) == rOopTop4) {
					goto l16;
				}
			}
	l16:	;
			rOopTop4 = NoReg;
	l15:	;
		}
		if (rOopTop4 == NoReg) {
			rOopTop4 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop4 == NoReg)));
		object3 = rOopTop4;
		popToReg(ssTop(), object3);
		ssPop(1);
		genLcFirstIndexableFieldPointer(object3);
		return 0;

	case 3:
		/* begin genLowcodeIsBytes */
		
		rOopTop5 = NoReg;
		rResult4 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop5 = registerOrNone(ssTop());
			index15 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i15 = index15; i15 <= (simStackPtr); i15 += 1) {
				if ((registerOrNone(simStackAt(index15))) == rOopTop5) {
					goto l19;
				}
			}
	l19:	;
			rOopTop5 = NoReg;
	l18:	;
		}
		if (rOopTop5 == NoReg) {
			rOopTop5 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult4 = allocateRegNotConflictingWith(((rOopTop5 < 0) ? (((usqInt)(1)) >> (-rOopTop5)) : (1ULL << rOopTop5)));
		assert(!(((rOopTop5 == NoReg)
 || (rResult4 == NoReg))));
		object4 = rOopTop5;
		value2 = rResult4;
		popToReg(ssTop(), object4);
		ssPop(1);
		genLcIsBytesto(object4, value2);
		return 0;

	case 4:
		/* begin genLowcodeIsFloatObject */
		
		rOopTop6 = NoReg;
		rResult5 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop6 = registerOrNone(ssTop());
			index16 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i16 = index16; i16 <= (simStackPtr); i16 += 1) {
				if ((registerOrNone(simStackAt(index16))) == rOopTop6) {
					goto l22;
				}
			}
	l22:	;
			rOopTop6 = NoReg;
	l21:	;
		}
		if (rOopTop6 == NoReg) {
			rOopTop6 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult5 = allocateRegNotConflictingWith(((rOopTop6 < 0) ? (((usqInt)(1)) >> (-rOopTop6)) : (1ULL << rOopTop6)));
		assert(!(((rOopTop6 == NoReg)
 || (rResult5 == NoReg))));
		object5 = rOopTop6;
		value3 = rResult5;
		popToReg(ssTop(), object5);
		ssPop(1);
		genLcIsFloatObjectto(object5, value3);
		return 0;

	case 5:
		/* begin genLowcodeIsIndexable */
		
		rOopTop7 = NoReg;
		rResult6 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop7 = registerOrNone(ssTop());
			index17 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i17 = index17; i17 <= (simStackPtr); i17 += 1) {
				if ((registerOrNone(simStackAt(index17))) == rOopTop7) {
					goto l25;
				}
			}
	l25:	;
			rOopTop7 = NoReg;
	l24:	;
		}
		if (rOopTop7 == NoReg) {
			rOopTop7 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult6 = allocateRegNotConflictingWith(((rOopTop7 < 0) ? (((usqInt)(1)) >> (-rOopTop7)) : (1ULL << rOopTop7)));
		assert(!(((rOopTop7 == NoReg)
 || (rResult6 == NoReg))));
		object6 = rOopTop7;
		value4 = rResult6;
		popToReg(ssTop(), object6);
		ssPop(1);
		genLcIsIndexableto(object6, value4);
		return 0;

	case 6:
		/* begin genLowcodeIsIntegerObject */
		
		rOopTop8 = NoReg;
		rResult7 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop8 = registerOrNone(ssTop());
			index18 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i18 = index18; i18 <= (simStackPtr); i18 += 1) {
				if ((registerOrNone(simStackAt(index18))) == rOopTop8) {
					goto l28;
				}
			}
	l28:	;
			rOopTop8 = NoReg;
	l27:	;
		}
		if (rOopTop8 == NoReg) {
			rOopTop8 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult7 = allocateRegNotConflictingWith(((rOopTop8 < 0) ? (((usqInt)(1)) >> (-rOopTop8)) : (1ULL << rOopTop8)));
		assert(!(((rOopTop8 == NoReg)
 || (rResult7 == NoReg))));
		object7 = rOopTop8;
		value5 = rResult7;
		popToReg(ssTop(), object7);
		ssPop(1);
		genLcIsIntegerObjectto(object7, value5);
		return 0;

	case 7:
		/* begin genLowcodeIsPointers */
		
		rOopTop9 = NoReg;
		rResult8 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop9 = registerOrNone(ssTop());
			index19 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i19 = index19; i19 <= (simStackPtr); i19 += 1) {
				if ((registerOrNone(simStackAt(index19))) == rOopTop9) {
					goto l31;
				}
			}
	l31:	;
			rOopTop9 = NoReg;
	l30:	;
		}
		if (rOopTop9 == NoReg) {
			rOopTop9 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult8 = allocateRegNotConflictingWith(((rOopTop9 < 0) ? (((usqInt)(1)) >> (-rOopTop9)) : (1ULL << rOopTop9)));
		assert(!(((rOopTop9 == NoReg)
 || (rResult8 == NoReg))));
		object8 = rOopTop9;
		value6 = rResult8;
		popToReg(ssTop(), object8);
		ssPop(1);
		genLcIsPointersto(object8, value6);
		return 0;

	case 8:
		/* begin genLowcodeIsWords */
		
		rOopTop10 = NoReg;
		rResult9 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop10 = registerOrNone(ssTop());
			index110 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i110 = index110; i110 <= (simStackPtr); i110 += 1) {
				if ((registerOrNone(simStackAt(index110))) == rOopTop10) {
					goto l34;
				}
			}
	l34:	;
			rOopTop10 = NoReg;
	l33:	;
		}
		if (rOopTop10 == NoReg) {
			rOopTop10 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult9 = allocateRegNotConflictingWith(((rOopTop10 < 0) ? (((usqInt)(1)) >> (-rOopTop10)) : (1ULL << rOopTop10)));
		assert(!(((rOopTop10 == NoReg)
 || (rResult9 == NoReg))));
		object9 = rOopTop10;
		value7 = rResult9;
		popToReg(ssTop(), object9);
		ssPop(1);
		genLcIsWordsto(object9, value7);
		return 0;

	case 9:
		/* begin genLowcodeIsWordsOrBytes */
		
		rOopTop11 = NoReg;
		rResult10 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop11 = registerOrNone(ssTop());
			index111 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i111 = index111; i111 <= (simStackPtr); i111 += 1) {
				if ((registerOrNone(simStackAt(index111))) == rOopTop11) {
					goto l37;
				}
			}
	l37:	;
			rOopTop11 = NoReg;
	l36:	;
		}
		if (rOopTop11 == NoReg) {
			rOopTop11 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult10 = allocateRegNotConflictingWith(((rOopTop11 < 0) ? (((usqInt)(1)) >> (-rOopTop11)) : (1ULL << rOopTop11)));
		assert(!(((rOopTop11 == NoReg)
 || (rResult10 == NoReg))));
		object10 = rOopTop11;
		value8 = rResult10;
		popToReg(ssTop(), object10);
		ssPop(1);
		genLcIsWordsOrBytesto(object10, value8);
		return 0;

	case 10:
		/* begin genLowcodeOopSmallIntegerToInt32 */
		
		rOopTop12 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop12 = registerOrNone(ssTop());
			index112 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i112 = index112; i112 <= (simStackPtr); i112 += 1) {
				if ((registerOrNone(simStackAt(index112))) == rOopTop12) {
					goto l40;
				}
			}
	l40:	;
			rOopTop12 = NoReg;
	l39:	;
		}
		if (rOopTop12 == NoReg) {
			rOopTop12 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop12 == NoReg)));
		object11 = rOopTop12;
		popToReg(ssTop(), object11);
		ssPop(1);
		genConvertSmallIntegerToIntegerInReg(object11);
		ssPushNativeRegister(object11);
		return 0;

	case 11:
		/* begin genLowcodeOopSmallIntegerToInt64 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop13 = NoReg;
		rResult12 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop13 = registerOrNone(ssTop());
			index113 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i114 = index113; i114 <= (simStackPtr); i114 += 1) {
				if ((registerOrNone(simStackAt(index113))) == rOopTop13) {
					goto l47;
				}
			}
	l47:	;
			rOopTop13 = NoReg;
	l43:	;
		}
		if (rOopTop13 == NoReg) {
			rOopTop13 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult12 = allocateRegNotConflictingWith(((rOopTop13 < 0) ? (((usqInt)(1)) >> (-rOopTop13)) : (1ULL << rOopTop13)));
		assert(!(((rOopTop13 == NoReg)
 || (rResult12 == NoReg))));
		object12 = rOopTop13;
		value9 = rResult12;
		popToReg(ssTop(), object12);
		ssPop(1);
		genConvertSmallIntegerToIntegerInReg(object12);
		ssPushNativeRegister(object12);
		return 0;

	case 12:
		/* begin genLowcodeOopToBoolean32 */
		
		rOopTop15 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop15 = registerOrNone(ssTop());
			index115 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i115 = index115; i115 <= (simStackPtr); i115 += 1) {
				if ((registerOrNone(simStackAt(index115))) == rOopTop15) {
					goto l50;
				}
			}
	l50:	;
			rOopTop15 = NoReg;
	l49:	;
		}
		if (rOopTop15 == NoReg) {
			rOopTop15 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop15 == NoReg)));
		object13 = rOopTop15;
		popToReg(ssTop(), object13);
		ssPop(1);
		annotateobjRef(checkLiteralforInstruction(falseObject(), genoperandoperand(SubCwR, falseObject(), object13)), falseObject());
		ssPushNativeRegister(object13);
		return 0;

	case 13:
		/* begin genLowcodeOopToBoolean64 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop1 = NoReg;
		rResult1 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop1 = registerOrNone(ssTop());
			index11 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i11 = index11; i11 <= (simStackPtr); i11 += 1) {
				if ((registerOrNone(simStackAt(index11))) == rOopTop1) {
					goto l6;
				}
			}
	l6:	;
			rOopTop1 = NoReg;
	l5:	;
		}
		if (rOopTop1 == NoReg) {
			rOopTop1 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult1 = allocateRegNotConflictingWith(((rOopTop1 < 0) ? (((usqInt)(1)) >> (-rOopTop1)) : (1ULL << rOopTop1)));
		assert(!(((rOopTop1 == NoReg)
 || (rResult1 == NoReg))));
		object = rOopTop1;
		value = rResult1;
		popToReg(ssTop(), object);
		ssPop(1);
		annotateobjRef(checkLiteralforInstruction(falseObject(), genoperandoperand(SubCwR, falseObject(), object)), falseObject());
		ssPushNativeRegister(object);
		return 0;

	case 14:
		/* begin genLowcodeOopToFloat32 */
		
		rOopTop16 = NoReg;
		frResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop16 = registerOrNone(ssTop());
			index116 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i116 = index116; i116 <= (simStackPtr); i116 += 1) {
				if ((registerOrNone(simStackAt(index116))) == rOopTop16) {
					goto l53;
				}
			}
	l53:	;
			rOopTop16 = NoReg;
	l52:	;
		}
		if (rOopTop16 == NoReg) {
			rOopTop16 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rOopTop16 == NoReg)
 || (frResult == NoReg))));
		object14 = rOopTop16;
		value10 = frResult;
		popToReg(ssTop(), object14);
		ssPop(1);
		/* begin ssFlushAll */
		
		index27 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index27) {
			for (i28 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index27) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index27)); i28 <= index27; i28 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i28), frameOffsetOfTemporary(i28 - 1), FPReg);
			}
			simSpillBase = index27 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOoptoFloat32(object14, value10);
		return 0;

	case 15:
		/* begin genLowcodeOopToFloat64 */
		
		rOopTop17 = NoReg;
		frResult1 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop17 = registerOrNone(ssTop());
			index117 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i117 = index117; i117 <= (simStackPtr); i117 += 1) {
				if ((registerOrNone(simStackAt(index117))) == rOopTop17) {
					goto l56;
				}
			}
	l56:	;
			rOopTop17 = NoReg;
	l55:	;
		}
		if (rOopTop17 == NoReg) {
			rOopTop17 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult1 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rOopTop17 == NoReg)
 || (frResult1 == NoReg))));
		object15 = rOopTop17;
		value11 = frResult1;
		popToReg(ssTop(), object15);
		ssPop(1);
		/* begin ssFlushAll */
		
		index29 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index29) {
			for (i210 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index29) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index29)); i210 <= index29; i210 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i210), frameOffsetOfTemporary(i210 - 1), FPReg);
			}
			simSpillBase = index29 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOoptoFloat64(object15, value11);
		return 0;

	case 16:
		/* begin genLowcodeOopToInt32 */
		
		rOopTop18 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop18 = registerOrNone(ssTop());
			index118 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i118 = index118; i118 <= (simStackPtr); i118 += 1) {
				if ((registerOrNone(simStackAt(index118))) == rOopTop18) {
					goto l59;
				}
			}
	l59:	;
			rOopTop18 = NoReg;
	l58:	;
		}
		if (rOopTop18 == NoReg) {
			rOopTop18 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop18 == NoReg)));
		object16 = rOopTop18;
		popToReg(ssTop(), object16);
		ssPop(1);
		/* begin ssFlushAll */
		
		index210 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index210) {
			for (i211 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index210) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index210)); i211 <= index210; i211 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i211), frameOffsetOfTemporary(i211 - 1), FPReg);
			}
			simSpillBase = index210 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOopToInt32(object16);
		return 0;

	case 17:
		/* begin genLowcodeOopToInt64 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop110 = NoReg;
		rResult14 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop110 = registerOrNone(ssTop());
			index1110 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i1110 = index1110; i1110 <= (simStackPtr); i1110 += 1) {
				if ((registerOrNone(simStackAt(index1110))) == rOopTop110) {
					goto l60;
				}
			}
	l60:	;
			rOopTop110 = NoReg;
	l64:	;
		}
		if (rOopTop110 == NoReg) {
			rOopTop110 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult14 = allocateRegNotConflictingWith(((rOopTop110 < 0) ? (((usqInt)(1)) >> (-rOopTop110)) : (1ULL << rOopTop110)));
		assert(!(((rOopTop110 == NoReg)
 || (rResult14 == NoReg))));
		object17 = rOopTop110;
		value12 = rResult14;
		popToReg(ssTop(), object17);
		ssPop(1);
		/* begin ssFlushAll */
		
		index41 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index41) {
			for (i41 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index41) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index41)); i41 <= index41; i41 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i41), frameOffsetOfTemporary(i41 - 1), FPReg);
			}
			simSpillBase = index41 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOopToInt64(object17);
		return 0;

	case 18:
		/* begin genLowcodeOopToPointer */
		
		rOopTop20 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop20 = registerOrNone(ssTop());
			index120 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i120 = index120; i120 <= (simStackPtr); i120 += 1) {
				if ((registerOrNone(simStackAt(index120))) == rOopTop20) {
					goto l68;
				}
			}
	l68:	;
			rOopTop20 = NoReg;
	l67:	;
		}
		if (rOopTop20 == NoReg) {
			rOopTop20 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop20 == NoReg)));
		object18 = rOopTop20;
		popToReg(ssTop(), object18);
		ssPop(1);
		genLcOopToPointer(object18);
		return 0;

	case 19:
		/* begin genLowcodeOopToPointerReinterpret */
		
		rOopTop21 = NoReg;
		rResult15 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop21 = registerOrNone(ssTop());
			index121 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i121 = index121; i121 <= (simStackPtr); i121 += 1) {
				if ((registerOrNone(simStackAt(index121))) == rOopTop21) {
					goto l71;
				}
			}
	l71:	;
			rOopTop21 = NoReg;
	l70:	;
		}
		if (rOopTop21 == NoReg) {
			rOopTop21 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult15 = allocateRegNotConflictingWith(((rOopTop21 < 0) ? (((usqInt)(1)) >> (-rOopTop21)) : (1ULL << rOopTop21)));
		assert(!(((rOopTop21 == NoReg)
 || (rResult15 == NoReg))));
		object19 = rOopTop21;
		pointer = rResult15;
		popToReg(ssTop(), object19);
		ssPop(1);
		ssPushNativeRegister(object19);
		return 0;

	case 20:
		/* begin genLowcodeOopToUInt32 */
		
		rOopTop22 = NoReg;
		rResult16 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop22 = registerOrNone(ssTop());
			index122 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i122 = index122; i122 <= (simStackPtr); i122 += 1) {
				if ((registerOrNone(simStackAt(index122))) == rOopTop22) {
					goto l74;
				}
			}
	l74:	;
			rOopTop22 = NoReg;
	l73:	;
		}
		if (rOopTop22 == NoReg) {
			rOopTop22 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult16 = allocateRegNotConflictingWith(((rOopTop22 < 0) ? (((usqInt)(1)) >> (-rOopTop22)) : (1ULL << rOopTop22)));
		assert(!(((rOopTop22 == NoReg)
 || (rResult16 == NoReg))));
		object20 = rOopTop22;
		value13 = rResult16;
		popToReg(ssTop(), object20);
		ssPop(1);
		/* begin ssFlushAll */
		
		index212 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index212) {
			for (i213 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index212) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index212)); i213 <= index212; i213 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i213), frameOffsetOfTemporary(i213 - 1), FPReg);
			}
			simSpillBase = index212 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOopToUInt32(object20);
		return 0;

	case 21:
		/* begin genLowcodeOopToUInt64 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop111 = NoReg;
		rResult18 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop111 = registerOrNone(ssTop());
			index1111 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i1111 = index1111; i1111 <= (simStackPtr); i1111 += 1) {
				if ((registerOrNone(simStackAt(index1111))) == rOopTop111) {
					goto l75;
				}
			}
	l75:	;
			rOopTop111 = NoReg;
	l79:	;
		}
		if (rOopTop111 == NoReg) {
			rOopTop111 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult18 = allocateRegNotConflictingWith(((rOopTop111 < 0) ? (((usqInt)(1)) >> (-rOopTop111)) : (1ULL << rOopTop111)));
		assert(!(((rOopTop111 == NoReg)
 || (rResult18 == NoReg))));
		object21 = rOopTop111;
		value14 = rResult18;
		popToReg(ssTop(), object21);
		ssPop(1);
		/* begin ssFlushAll */
		
		index42 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index42) {
			for (i42 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index42) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index42)); i42 <= index42; i42 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i42), frameOffsetOfTemporary(i42 - 1), FPReg);
			}
			simSpillBase = index42 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOopToUInt64(object21);
		return 0;

	case 22:
		/* begin genLowcodePin */
		
		rOopTop24 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop24 = registerOrNone(ssTop());
			index124 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i124 = index124; i124 <= (simStackPtr); i124 += 1) {
				if ((registerOrNone(simStackAt(index124))) == rOopTop24) {
					goto l83;
				}
			}
	l83:	;
			rOopTop24 = NoReg;
	l82:	;
		}
		if (rOopTop24 == NoReg) {
			rOopTop24 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop24 == NoReg)));
		object22 = rOopTop24;
		popToReg(ssTop(), object22);
		ssPop(1);
		abort();
		return 0;

	case 23:
		/* begin genLowcodeUnpin */
		
		rOopTop25 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop25 = registerOrNone(ssTop());
			index125 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i125 = index125; i125 <= (simStackPtr); i125 += 1) {
				if ((registerOrNone(simStackAt(index125))) == rOopTop25) {
					goto l86;
				}
			}
	l86:	;
			rOopTop25 = NoReg;
	l85:	;
		}
		if (rOopTop25 == NoReg) {
			rOopTop25 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop25 == NoReg)));
		object23 = rOopTop25;
		popToReg(ssTop(), object23);
		ssPop(1);
		abort();
		return 0;

	default:
		return EncounteredUnknownBytecode;

	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeNullaryInlinePrimitive: */
static sqInt NoDbgRegParms
genLowcodeNullaryInlinePrimitive(sqInt prim)
{
    AbstractInstruction *cont;
    AbstractInstruction *cont1;
    sqInt floatValue;
    sqInt frTop;
    sqInt frTop1;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i12;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt index;
    sqInt index1;
    sqInt index11;
    sqInt index12;
    sqInt index2;
    sqInt index3;
    sqInt index4;
    AbstractInstruction *inst;
    AbstractInstruction *inst1;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt pointer;
    sqInt pointer1;
    sqInt pointerClassLiteral;
    sqInt rResult;
    sqInt rResult1;
    sqInt rResult3;
    sqInt rResult4;
    sqInt rResult5;
    sqInt rTop;
    sqInt rTop1;
    sqInt rTop3;
    sqInt rTop4;
    sqInt rTop5;
    sqInt rTop6;
    sqInt rTop7;
    sqInt rTop8;
    sqInt rTop9;
    sqInt singleFloatValue;
    AbstractInstruction *trueJump;
    AbstractInstruction *trueJump1;
    sqInt value;
    sqInt value1;
    sqInt value2;
    sqInt value3;
    sqInt value4;
    sqInt value5;
    sqInt value6;
    sqInt wordConstant;
    sqInt wordConstant1;

	switch (prim) {
	case 0:
		/* begin genLowcodeBoolean32ToOop */
		
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		object = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, value);
		/* begin JumpNonZero: */
		trueJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		annotateobjRef(checkLiteralforInstruction(falseObject(), genoperandoperand(MoveCwR, falseObject(), value)), falseObject());
		/* begin Jump: */
		cont = genoperand(Jump, ((sqInt)0));
		/* begin MoveCw:R: */
		wordConstant = trueObject();
		inst = genoperandoperand(MoveCwR, wordConstant, value);
		jmpTarget(trueJump, inst);
		annotateobjRef(inst, trueObject());
		jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushRegister(value);
		return 0;

	case 1:
		/* begin genLowcodeBoolean64ToOop */
		/* begin allocateRegistersForLowcodeIntegerResultOop: */
		rTop1 = NoReg;
		rResult1 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop1 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop1 == NoReg) {
			rTop1 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult1 = allocateRegNotConflictingWith(((rTop1 < 0) ? (((usqInt)(1)) >> (-rTop1)) : (1ULL << rTop1)));
		assert(!(((rTop1 == NoReg)
 || (rResult1 == NoReg))));
		value1 = rTop1;
		object1 = rResult1;
		nativePopToReg(ssNativeTop(), value1);
		ssNativePop(1);
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, 0, value1);
		/* begin JumpNonZero: */
		trueJump1 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		annotateobjRef(checkLiteralforInstruction(falseObject(), genoperandoperand(MoveCwR, falseObject(), value1)), falseObject());
		/* begin Jump: */
		cont1 = genoperand(Jump, ((sqInt)0));
		/* begin MoveCw:R: */
		wordConstant1 = trueObject();
		inst1 = genoperandoperand(MoveCwR, wordConstant1, value1);
		jmpTarget(trueJump1, inst1);
		annotateobjRef(inst1, trueObject());
		jmpTarget(cont1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushRegister(value1);
		return 0;

	case 2:
		/* begin genLowcodeFloat32ToOop */
		
		frTop = NoReg;

		/* Float argument */
		rResult3 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult3 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult3 == NoReg))));
		singleFloatValue = frTop;
		object2 = rResult3;
		nativePopToReg(ssNativeTop(), singleFloatValue);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = index + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcFloat32toOop(singleFloatValue, object2);
		return 0;

	case 3:
		/* begin genLowcodeFloat64ToOop */
		
		frTop1 = NoReg;

		/* Float argument */
		rResult4 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop1 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop1 == NoReg) {
			frTop1 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult4 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop1 == NoReg)
 || (rResult4 == NoReg))));
		floatValue = frTop1;
		object3 = rResult4;
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index1 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index1) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index1) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index1)); i1 <= index1; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = index1 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcFloat64toOop(floatValue, object3);
		return 0;

	case 4:
		/* begin genLowcodeInt32ToOop */
		
		rTop3 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop3 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop3 == NoReg) {
			rTop3 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop3 == NoReg)));
		value2 = rTop3;
		nativePopToReg(ssNativeTop(), value2);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index2 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index2) {
			for (i2 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index2) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index2)); i2 <= index2; i2 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i2), frameOffsetOfTemporary(i2 - 1), FPReg);
			}
			simSpillBase = index2 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInt32ToOop(value2);
		return 0;

	case 5:
		/* begin genLowcodeInt64ToOop */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop8 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop8 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop8 == NoReg) {
			rTop8 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop8 == NoReg)));
		value5 = rTop8;
		nativePopToReg(ssNativeTop(), value5);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index11 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index11) {
			for (i11 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index11) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index11)); i11 <= index11; i11 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i11), frameOffsetOfTemporary(i11 - 1), FPReg);
			}
			simSpillBase = index11 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInt64ToOop(value5);
		return 0;

	case 6:
		/* begin genLowcodePointerToOop */
		pointerClassLiteral = getLiteral(extA);
		/* begin allocateRegistersForLowcodeInteger: */
		rTop4 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop4 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop4 == NoReg) {
			rTop4 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop4 == NoReg)));
		pointer = rTop4;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index3 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index3) {
			for (i3 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index3) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index3)); i3 <= index3; i3 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i3), frameOffsetOfTemporary(i3 - 1), FPReg);
			}
			simSpillBase = index3 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcPointerToOopclass(pointer, pointerClassLiteral);
		extA = 0;
		return 0;

	case 7:
		/* begin genLowcodePointerToOopReinterprer */
		
		rTop5 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop5 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop5 == NoReg) {
			rTop5 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop5 == NoReg)));
		pointer1 = rTop5;
		nativePopToReg(ssNativeTop(), pointer1);
		ssNativePop(1);
		ssPushRegister(pointer1);
		return 0;

	case 8:
		/* begin genLowcodeSmallInt32ToOop */
		
		rTop6 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop6 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop6 == NoReg) {
			rTop6 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop6 == NoReg)));
		value3 = rTop6;
		nativePopToReg(ssNativeTop(), value3);
		ssNativePop(1);
		genConvertIntegerToSmallIntegerInReg(value3);
		ssPushRegister(value3);
		return 0;

	case 9:
		/* begin genLowcodeUint32ToOop */
		
		rTop7 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop7 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop7 == NoReg) {
			rTop7 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop7 == NoReg)));
		value4 = rTop7;
		nativePopToReg(ssNativeTop(), value4);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index4 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index4) {
			for (i4 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index4) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index4)); i4 <= index4; i4 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i4), frameOffsetOfTemporary(i4 - 1), FPReg);
			}
			simSpillBase = index4 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcUInt32ToOop(value4);
		return 0;

	case 10:
		/* begin genLowcodeUint64ToOop */
		/* begin allocateRegistersForLowcodeIntegerResultOop: */
		rTop9 = NoReg;
		rResult5 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop9 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop9 == NoReg) {
			rTop9 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult5 = allocateRegNotConflictingWith(((rTop9 < 0) ? (((usqInt)(1)) >> (-rTop9)) : (1ULL << rTop9)));
		assert(!(((rTop9 == NoReg)
 || (rResult5 == NoReg))));
		value6 = rTop9;
		object4 = rResult5;
		nativePopToReg(ssNativeTop(), value6);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index12 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index12) {
			for (i12 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index12) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index12)); i12 <= index12; i12 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i12), frameOffsetOfTemporary(i12 - 1), FPReg);
			}
			simSpillBase = index12 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcUInt64ToOop(value6);
		return 0;

	default:
		return EncounteredUnknownBytecode;

	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeTrinaryInlinePrimitive: */
static sqInt NoDbgRegParms
genLowcodeTrinaryInlinePrimitive(sqInt prim)
{
    AbstractInstruction *contJump;
    AbstractInstruction *contJump1;
    AbstractInstruction *falseJump;
    AbstractInstruction *falseJump1;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt first;
    sqInt first1;
    sqInt i1;
    sqInt i11;
    sqInt i12;
    sqInt index1;
    sqInt index11;
    sqInt index12;
    sqInt object;
    sqInt object1;
    sqInt oopTopRegisterMask;
    sqInt oopTopRegisterMask1;
    sqInt oopTopRegisterMask2;
    sqInt oopTopRegisterMask3;
    sqInt rOopNext;
    sqInt rOopNext1;
    sqInt rOopNext2;
    sqInt rOopNext3;
    sqInt rOopTop;
    sqInt rOopTop1;
    sqInt rOopTop2;
    sqInt rOopTop3;
    sqInt rResult;
    sqInt rTop;
    sqInt second;
    sqInt second1;
    sqInt topRegisterMask;
    sqInt value;
    sqInt value1;
    sqInt value2;

	switch (prim) {
	case 0:
		/* begin genLowcodeOopEqual */
		
		rOopTop = (rOopNext = NoReg);
		rResult = NoReg;
		oopTopRegisterMask = 0;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());
			index1 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i1 = index1; i1 <= (simStackPtr); i1 += 1) {
				if ((registerOrNone(simStackAt(index1))) == rOopTop) {
					goto l7;
				}
			}
	l7:	;
			rOopTop = NoReg;
	l10:	;
		}
		if ((registerOrNone(ssValue(1))) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopNext = registerOrNone(ssValue(1));
			index1 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i1 = index1; i1 < simStackPtr; i1 += 1) {
				if ((registerOrNone(simStackAt(index1))) == rOopNext) {
					goto l6;
				}
			}
	l6:	;
			rOopNext = NoReg;
	l9:	;
			if (rOopNext != NoReg) {
				/* begin registerMaskFor: */
				oopTopRegisterMask = ((rOopNext < 0) ? (((usqInt)(1)) >> (-rOopNext)) : (1ULL << rOopNext));
			}
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(oopTopRegisterMask);
		}
		if (rOopNext == NoReg) {
			rOopNext = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		}
		rResult = allocateRegNotConflictingWith((1ULL << rOopTop) | (1ULL << rOopNext));
		assert(!(((rOopTop == NoReg)
 || ((rOopNext == NoReg)
 || (rResult == NoReg)))));
		second = rOopTop;
		first = rOopNext;
		value = rResult;
		popToReg(ssTop(), second);
		ssPop(1);
		popToReg(ssTop(), first);
		ssPop(1);
		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);
		/* begin JumpNonZero: */
		falseJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first);
		/* begin Jump: */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first);
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 1:
		/* begin genLowcodeOopNotEqual */
		
		rOopTop1 = (rOopNext1 = NoReg);
		oopTopRegisterMask1 = 0;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop1 = registerOrNone(ssTop());
			index11 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i11 = index11; i11 <= (simStackPtr); i11 += 1) {
				if ((registerOrNone(simStackAt(index11))) == rOopTop1) {
					goto l13;
				}
			}
	l13:	;
			rOopTop1 = NoReg;
	l18:	;
		}
		if ((registerOrNone(ssValue(1))) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopNext1 = registerOrNone(ssValue(1));
			index11 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i11 = index11; i11 < simStackPtr; i11 += 1) {
				if ((registerOrNone(simStackAt(index11))) == rOopNext1) {
					goto l19;
				}
			}
	l19:	;
			rOopNext1 = NoReg;
	l20:	;
			if (rOopNext1 != NoReg) {
				/* begin registerMaskFor: */
				oopTopRegisterMask1 = ((rOopNext1 < 0) ? (((usqInt)(1)) >> (-rOopNext1)) : (1ULL << rOopNext1));
			}
		}
		if (rOopTop1 == NoReg) {
			rOopTop1 = allocateRegNotConflictingWith(oopTopRegisterMask1);
		}
		if (rOopNext1 == NoReg) {
			rOopNext1 = allocateRegNotConflictingWith(((rOopTop1 < 0) ? (((usqInt)(1)) >> (-rOopTop1)) : (1ULL << rOopTop1)));
		}
		assert(!(((rOopTop1 == NoReg)
 || (rOopNext1 == NoReg))));
		second1 = rOopTop1;
		first1 = rOopNext1;
		popToReg(ssTop(), second1);
		ssPop(1);
		popToReg(ssTop(), first1);
		ssPop(1);
		/* begin CmpR:R: */
		assert(!((second1 == SPReg)));
		genoperandoperand(CmpRR, second1, first1);
		/* begin JumpZero: */
		falseJump1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first1);
		/* begin Jump: */
		contJump1 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first1);
		jmpTarget(contJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first1);
		return 0;

	case 2:
		/* begin genLowcodeStoreObjectField */
		fieldIndex = extA;
		/* begin allocateRegistersForLowcodeOop2: */
		rOopTop2 = (rOopNext2 = NoReg);
		oopTopRegisterMask2 = 0;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop2 = registerOrNone(ssTop());
			index12 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i12 = index12; i12 <= (simStackPtr); i12 += 1) {
				if ((registerOrNone(simStackAt(index12))) == rOopTop2) {
					goto l24;
				}
			}
	l24:	;
			rOopTop2 = NoReg;
	l28:	;
		}
		if ((registerOrNone(ssValue(1))) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopNext2 = registerOrNone(ssValue(1));
			index12 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i12 = index12; i12 < simStackPtr; i12 += 1) {
				if ((registerOrNone(simStackAt(index12))) == rOopNext2) {
					goto l23;
				}
			}
	l23:	;
			rOopNext2 = NoReg;
	l27:	;
			if (rOopNext2 != NoReg) {
				/* begin registerMaskFor: */
				oopTopRegisterMask2 = ((rOopNext2 < 0) ? (((usqInt)(1)) >> (-rOopNext2)) : (1ULL << rOopNext2));
			}
		}
		if (rOopTop2 == NoReg) {
			rOopTop2 = allocateRegNotConflictingWith(oopTopRegisterMask2);
		}
		if (rOopNext2 == NoReg) {
			rOopNext2 = allocateRegNotConflictingWith(((rOopTop2 < 0) ? (((usqInt)(1)) >> (-rOopTop2)) : (1ULL << rOopTop2)));
		}
		assert(!(((rOopTop2 == NoReg)
 || (rOopNext2 == NoReg))));
		value1 = rOopTop2;
		object = rOopNext2;
		popToReg(ssTop(), value1);
		ssPop(1);
		popToReg(ssTop(), object);
		ssPop(1);
		genLcStoreobjectfield(value1, object, fieldIndex);
		extA = 0;
		return 0;

	case 3:
		/* begin genLowcodeStoreObjectFieldAt */
		
		rTop = (rOopTop3 = (rOopNext3 = NoReg));
		oopTopRegisterMask3 = (topRegisterMask = 0);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			/* begin registerMaskFor: */
			oopTopRegisterMask3 = ((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop));
		}
		if ((registerOrNone(ssTop())) != NoReg) {
			rOopTop3 = registerOrNone(ssTop());
			/* begin registerMaskFor: */
			topRegisterMask = ((rOopTop3 < 0) ? (((usqInt)(1)) >> (-rOopTop3)) : (1ULL << rOopTop3));
		}
		if ((registerOrNone(ssValue(1))) != NoReg) {
			rOopNext3 = registerOrNone(ssValue(1));
			topRegisterMask = topRegisterMask | (((rOopNext3 < 0) ? (((usqInt)(1)) >> (-rOopNext3)) : (1ULL << rOopNext3)));
			oopTopRegisterMask3 = oopTopRegisterMask3 | (((rOopNext3 < 0) ? (((usqInt)(1)) >> (-rOopNext3)) : (1ULL << rOopNext3)));
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegisterMask);
		}
		if (rOopTop3 == NoReg) {
			rOopTop3 = allocateRegNotConflictingWith(oopTopRegisterMask3);
		}
		if (rOopNext3 == NoReg) {
			rOopNext3 = allocateRegNotConflictingWith((1ULL << rTop) | (1ULL << rOopTop3));
		}
		assert(!(((rTop == NoReg)
 || ((rOopTop3 == NoReg)
 || (rOopNext3 == NoReg)))));
		fieldIndex1 = rTop;
		value2 = rOopTop3;
		object1 = rOopNext3;
		popToReg(ssTop(), value2);
		ssPop(1);
		nativePopToReg(ssNativeTop(), fieldIndex1);
		ssNativePop(1);
		popToReg(ssTop(), object1);
		ssPop(1);
		genLcStoreobjectat(value2, object1, fieldIndex1);
		return 0;

	default:
		return EncounteredUnknownBytecode;

	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive2: */
static sqInt NoDbgRegParms
genLowcodeUnaryInlinePrimitive2(sqInt prim)
{
    AbstractInstruction *abstractInstruction;
    sqInt baseOffset;
    sqInt baseOffset1;
    sqInt baseOffset10;
    sqInt baseOffset11;
    sqInt baseOffset12;
    sqInt baseOffset13;
    sqInt baseOffset14;
    sqInt baseOffset15;
    sqInt baseOffset16;
    sqInt baseOffset17;
    sqInt baseOffset18;
    sqInt baseOffset19;
    sqInt baseOffset2;
    sqInt baseOffset20;
    sqInt baseOffset21;
    sqInt baseOffset22;
    sqInt baseOffset23;
    sqInt baseOffset3;
    sqInt baseOffset4;
    sqInt baseOffset5;
    sqInt baseOffset6;
    sqInt baseOffset7;
    sqInt baseOffset8;
    sqInt baseOffset9;
    sqInt classOop;
    sqInt classOop1;
    sqInt classOop2;
    AbstractInstruction *contJump;
    AbstractInstruction *contJump1;
    AbstractInstruction *contJump2;
    AbstractInstruction *contJump3;
    AbstractInstruction *contJump4;
    AbstractInstruction *contJump5;
    AbstractInstruction *contJump6;
    AbstractInstruction *contJump7;
    sqInt doubleValue;
    sqInt doubleValue1;
    AbstractInstruction *falseJump;
    AbstractInstruction *falseJump1;
    AbstractInstruction *falseJump2;
    AbstractInstruction *falseJump3;
    AbstractInstruction *falseJump4;
    AbstractInstruction *falseJump5;
    AbstractInstruction *falseJump6;
    AbstractInstruction *falseJump7;
    sqInt fieldIndex;
    sqInt first;
    sqInt first1;
    sqInt first10;
    sqInt first11;
    sqInt first2;
    sqInt first3;
    sqInt first4;
    sqInt first5;
    sqInt first6;
    sqInt first7;
    sqInt first8;
    sqInt first9;
    sqInt floatValue;
    sqInt floatValue1;
    sqInt floatValue2;
    sqInt floatValue3;
    sqInt floatValue4;
    sqInt floatValue5;
    sqInt floatValue6;
    sqInt frResult;
    sqInt frResult1;
    sqInt frResult2;
    sqInt frResult3;
    sqInt frResult4;
    sqInt frResult5;
    sqInt frResult6;
    sqInt frResult7;
    sqInt frResult8;
    sqInt frResult9;
    sqInt frTop;
    sqInt frTop1;
    sqInt frTop2;
    sqInt frTop3;
    sqInt frTop4;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i12;
    sqInt i2;
    sqInt i21;
    sqInt index;
    sqInt index1;
    sqInt index11;
    sqInt index12;
    sqInt index2;
    sqInt index21;
    sqInt indexableSize;
    sqInt indexableSize1;
    sqInt int32Result;
    sqInt int64Result;
    sqInt int64Result1;
    sqInt int64Result2;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt pointer;
    sqInt pointer1;
    sqInt pointer2;
    sqInt pointer3;
    sqInt pointer4;
    sqInt pointer5;
    sqInt pointer6;
    sqInt pointer7;
    sqInt pointer8;
    sqInt pointerResult;
    sqInt pointerResult1;
    sqInt reg;
    sqInt reg1;
    sqInt reg10;
    sqInt reg11;
    sqInt reg13;
    sqInt reg14;
    sqInt reg2;
    sqInt reg3;
    sqInt reg4;
    sqInt reg5;
    sqInt reg6;
    sqInt reg7;
    sqInt reg8;
    sqInt reg9;
    sqInt result;
    sqInt result1;
    sqInt result2;
    sqInt result3;
    sqInt result4;
    sqInt rNext;
    sqInt rNext1;
    sqInt rNext10;
    sqInt rNext12;
    sqInt rNext15;
    sqInt rNext16;
    sqInt rNext2;
    sqInt rNext3;
    sqInt rNext4;
    sqInt rNext5;
    sqInt rNext6;
    sqInt rNext7;
    sqInt rNext8;
    sqInt rNext9;
    sqInt rOopResult;
    sqInt rOopTop;
    sqInt rOopTop1;
    sqInt rOopTop2;
    sqInt rOopTop3;
    sqInt rResult;
    sqInt rResult1;
    sqInt rResult10;
    sqInt rResult11;
    sqInt rResult12;
    sqInt rResult13;
    sqInt rResult15;
    sqInt rResult16;
    sqInt rResult17;
    sqInt rResult18;
    sqInt rResult20;
    sqInt rResult24;
    sqInt rResult25;
    sqInt rResult26;
    sqInt rResult27;
    sqInt rResult28;
    sqInt rResult29;
    sqInt rResult30;
    sqInt rResult31;
    sqInt rResult32;
    sqInt rResult33;
    sqInt rResult34;
    sqInt rResult35;
    sqInt rResult36;
    sqInt rResult37;
    sqInt rResult38;
    sqInt rResult39;
    sqInt rResult4;
    sqInt rResult40;
    sqInt rResult41;
    sqInt rResult5;
    sqInt rResult6;
    sqInt rResult8;
    sqInt rResult9;
    sqInt rTop;
    sqInt rTop1;
    sqInt rTop10;
    sqInt rTop11;
    sqInt rTop13;
    sqInt rTop14;
    sqInt rTop15;
    sqInt rTop16;
    sqInt rTop17;
    sqInt rTop19;
    sqInt rTop2;
    sqInt rTop20;
    sqInt rTop21;
    sqInt rTop22;
    sqInt rTop23;
    sqInt rTop24;
    sqInt rTop25;
    sqInt rTop26;
    sqInt rTop27;
    sqInt rTop28;
    sqInt rTop29;
    sqInt rTop3;
    sqInt rTop30;
    sqInt rTop4;
    sqInt rTop5;
    sqInt rTop6;
    sqInt rTop7;
    sqInt rTop8;
    sqInt rTop9;
    sqInt second;
    sqInt second1;
    sqInt second10;
    sqInt second11;
    sqInt second2;
    sqInt second3;
    sqInt second4;
    sqInt second5;
    sqInt second6;
    sqInt second7;
    sqInt second8;
    sqInt second9;
    sqInt shiftAmount;
    sqInt shiftAmount1;
    sqInt topRegisterMask;
    sqInt topRegisterMask1;
    sqInt topRegistersMask;
    sqInt topRegistersMask1;
    sqInt topRegistersMask10;
    sqInt topRegistersMask11;
    sqInt topRegistersMask12;
    sqInt topRegistersMask14;
    sqInt topRegistersMask15;
    sqInt topRegistersMask2;
    sqInt topRegistersMask3;
    sqInt topRegistersMask4;
    sqInt topRegistersMask5;
    sqInt topRegistersMask6;
    sqInt topRegistersMask7;
    sqInt topRegistersMask8;
    sqInt topRegistersMask9;
    sqInt value;
    sqInt value1;
    sqInt value10;
    sqInt value11;
    sqInt value12;
    sqInt value13;
    sqInt value14;
    sqInt value15;
    sqInt value16;
    sqInt value17;
    sqInt value18;
    sqInt value19;
    sqInt value2;
    sqInt value20;
    sqInt value21;
    sqInt value22;
    sqInt value23;
    sqInt value24;
    sqInt value25;
    sqInt value26;
    sqInt value27;
    sqInt value28;
    sqInt value29;
    sqInt value3;
    sqInt value30;
    sqInt value31;
    sqInt value32;
    sqInt value33;
    sqInt value4;
    sqInt value5;
    sqInt value6;
    sqInt value7;
    sqInt value8;
    sqInt value9;

	switch (prim) {
	case 60:
		/* begin genLowcodeFloat64ToFloat32 */
		
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		floatValue2 = frTop;
		nativePopToReg(ssNativeTop(), floatValue2);
		ssNativePop(1);
		/* begin ConvertRd:Rs: */
		genoperandoperand(ConvertRdRs, floatValue2, floatValue2);
		ssPushNativeRegisterSingleFloat(floatValue2);
		return 0;

	case 61:
		/* begin genLowcodeFloat64ToInt32 */
		
		frTop1 = NoReg;

		/* Float argument */
		rResult24 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop1 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop1 == NoReg) {
			frTop1 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult24 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop1 == NoReg)
 || (rResult24 == NoReg))));
		floatValue3 = frTop1;
		int32Result = rResult24;
		nativePopToReg(ssNativeTop(), floatValue3);
		ssNativePop(1);
		/* begin ConvertRd:R: */
		genoperandoperand(ConvertRdR, floatValue3, int32Result);
		ssPushNativeRegister(int32Result);
		return 0;

	case 0x3E:
		/* begin genLowcodeFloat64ToInt64 */
		
		frTop2 = NoReg;

		/* Float argument */
		rResult25 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop2 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop2 == NoReg) {
			frTop2 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult25 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop2 == NoReg)
 || (rResult25 == NoReg))));
		floatValue4 = frTop2;
		int64Result = rResult25;
		nativePopToReg(ssNativeTop(), floatValue4);
		ssNativePop(1);
		abort();
		return 0;

	case 0x3F:
		/* begin genLowcodeFloat64ToUInt32 */
		
		frTop3 = NoReg;

		/* Float argument */
		rResult26 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop3 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop3 == NoReg) {
			frTop3 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult26 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop3 == NoReg)
 || (rResult26 == NoReg))));
		floatValue5 = frTop3;
		int64Result1 = rResult26;
		nativePopToReg(ssNativeTop(), floatValue5);
		ssNativePop(1);
		/* begin ConvertRd:R: */
		genoperandoperand(ConvertRdR, floatValue5, int64Result1);
		ssPushNativeRegister(int64Result1);
		return 0;

	case 64:
		/* begin genLowcodeFloat64ToUInt64 */
		
		frTop4 = NoReg;

		/* Float argument */
		rResult27 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop4 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop4 == NoReg) {
			frTop4 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult27 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop4 == NoReg)
 || (rResult27 == NoReg))));
		floatValue6 = frTop4;
		int64Result2 = rResult27;
		nativePopToReg(ssNativeTop(), floatValue6);
		ssNativePop(1);
		abort();
		return 0;

	case 65:
		/* begin genLowcodeFree */
		
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		pointer2 = rTop;
		nativePopToReg(ssNativeTop(), pointer2);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = index + 1;
		}
		voidReceiverResultRegContainsSelf();
		if (pointer2 != ReceiverResultReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, pointer2, ReceiverResultReg);
		}
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceFreeTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		return 0;

	case 66:
		/* begin genLowcodeInstantiateIndexable32Oop */
		
		rTop1 = (rOopTop = NoReg);
		rOopResult = NoReg;
		topRegisterMask = 0;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop1 = nativeRegisterOrNone(ssNativeTop());
		}
		if ((registerOrNone(ssTop())) != NoReg) {
			rOopTop = registerOrNone(ssTop());
			/* begin registerMaskFor: */
			topRegisterMask = ((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop));
		}
		if (rTop1 == NoReg) {
			rTop1 = allocateRegNotConflictingWith(topRegisterMask);
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(((rTop1 < 0) ? (((usqInt)(1)) >> (-rTop1)) : (1ULL << rTop1)));
		}
		rOopResult = allocateRegNotConflictingWith((1ULL << rTop1) | (1ULL << rOopTop));
		assert(!(((rTop1 == NoReg)
 || ((rOopTop == NoReg)
 || (rOopResult == NoReg)))));
		indexableSize = rTop1;
		classOop = rOopTop;
		object = rOopResult;
		nativePopToReg(ssNativeTop(), indexableSize);
		ssNativePop(1);
		popToReg(ssTop(), classOop);
		ssPop(1);
		/* begin ssFlushAll */
		
		index1 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index1) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index1) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index1)); i1 <= index1; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = index1 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInstantiateOopindexableSize(classOop, indexableSize);
		return 0;

	case 67:
		/* begin genLowcodeInstantiateIndexableOop */
		indexableSize1 = extA;
		/* begin allocateRegistersForLowcodeOopResultOop: */
		rOopTop1 = NoReg;
		rResult28 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop1 = registerOrNone(ssTop());
			index11 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i11 = index11; i11 <= (simStackPtr); i11 += 1) {
				if ((registerOrNone(simStackAt(index11))) == rOopTop1) {
					goto l66;
				}
			}
	l66:	;
			rOopTop1 = NoReg;
	l65:	;
		}
		if (rOopTop1 == NoReg) {
			rOopTop1 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult28 = allocateRegNotConflictingWith(((rOopTop1 < 0) ? (((usqInt)(1)) >> (-rOopTop1)) : (1ULL << rOopTop1)));
		assert(!(((rOopTop1 == NoReg)
 || (rResult28 == NoReg))));
		classOop1 = rOopTop1;
		object1 = rResult28;
		popToReg(ssTop(), classOop1);
		ssPop(1);
		/* begin ssFlushAll */
		
		index2 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index2) {
			for (i2 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index2) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index2)); i2 <= index2; i2 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i2), frameOffsetOfTemporary(i2 - 1), FPReg);
			}
			simSpillBase = index2 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInstantiateOopconstantIndexableSize(classOop1, indexableSize1);
		extA = 0;
		return 0;

	case 68:
		/* begin genLowcodeInstantiateOop */
		
		rOopTop2 = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop2 = registerOrNone(ssTop());
			index12 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i12 = index12; i12 <= (simStackPtr); i12 += 1) {
				if ((registerOrNone(simStackAt(index12))) == rOopTop2) {
					goto l69;
				}
			}
	l69:	;
			rOopTop2 = NoReg;
	l68:	;
		}
		if (rOopTop2 == NoReg) {
			rOopTop2 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop2 == NoReg)));
		classOop2 = rOopTop2;
		popToReg(ssTop(), classOop2);
		ssPop(1);
		/* begin ssFlushAll */
		
		index21 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index21) {
			for (i21 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index21) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index21)); i21 <= index21; i21 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i21), frameOffsetOfTemporary(i21 - 1), FPReg);
			}
			simSpillBase = index21 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInstantiateOop(classOop2);
		return 0;

	case 69:
		/* begin genLowcodeInt32Equal */
		
		topRegistersMask1 = 0;
		rTop2 = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop2 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask1 = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop2 == NoReg) {
			rTop2 = allocateRegNotConflictingWith(topRegistersMask1);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop2 < 0) ? (((usqInt)(1)) >> (-rTop2)) : (1ULL << rTop2)));
		}
		assert(!(((rTop2 == NoReg)
 || (rNext == NoReg))));
		second = rTop2;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);
		/* begin JumpNonZero: */
		falseJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first);
		/* begin Jump: */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first);
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 70:
		/* begin genLowcodeInt32Great */
		
		topRegistersMask2 = 0;
		rTop3 = (rNext1 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop3 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext1 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext1 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg1 = (rNext1 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask2 = ((reg1 < 0) ? (((usqInt)(1)) >> (-reg1)) : (1ULL << reg1));
			}
		}
		if (rTop3 == NoReg) {
			rTop3 = allocateRegNotConflictingWith(topRegistersMask2);
		}
		if (rNext1 == NoReg) {
			rNext1 = allocateRegNotConflictingWith(((rTop3 < 0) ? (((usqInt)(1)) >> (-rTop3)) : (1ULL << rTop3)));
		}
		assert(!(((rTop3 == NoReg)
 || (rNext1 == NoReg))));
		second1 = rTop3;
		first1 = rNext1;
		nativePopToReg(ssNativeTop(), second1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first1);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second1 == SPReg)));
		genoperandoperand(CmpRR, second1, first1);
		/* begin JumpLessOrEqual: */
		falseJump1 = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first1);
		/* begin Jump: */
		contJump1 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first1);
		jmpTarget(contJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first1);
		return 0;

	case 71:
		/* begin genLowcodeInt32GreatEqual */
		
		topRegistersMask3 = 0;
		rTop4 = (rNext2 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop4 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext2 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext2 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg2 = (rNext2 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask3 = ((reg2 < 0) ? (((usqInt)(1)) >> (-reg2)) : (1ULL << reg2));
			}
		}
		if (rTop4 == NoReg) {
			rTop4 = allocateRegNotConflictingWith(topRegistersMask3);
		}
		if (rNext2 == NoReg) {
			rNext2 = allocateRegNotConflictingWith(((rTop4 < 0) ? (((usqInt)(1)) >> (-rTop4)) : (1ULL << rTop4)));
		}
		assert(!(((rTop4 == NoReg)
 || (rNext2 == NoReg))));
		second2 = rTop4;
		first2 = rNext2;
		nativePopToReg(ssNativeTop(), second2);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first2);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second2 == SPReg)));
		genoperandoperand(CmpRR, second2, first2);
		/* begin JumpLess: */
		falseJump2 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first2);
		/* begin Jump: */
		contJump2 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump2, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first2);
		jmpTarget(contJump2, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first2);
		return 0;

	case 72:
		/* begin genLowcodeInt32Less */
		
		topRegistersMask4 = 0;
		rTop5 = (rNext3 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop5 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext3 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext3 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg3 = (rNext3 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask4 = ((reg3 < 0) ? (((usqInt)(1)) >> (-reg3)) : (1ULL << reg3));
			}
		}
		if (rTop5 == NoReg) {
			rTop5 = allocateRegNotConflictingWith(topRegistersMask4);
		}
		if (rNext3 == NoReg) {
			rNext3 = allocateRegNotConflictingWith(((rTop5 < 0) ? (((usqInt)(1)) >> (-rTop5)) : (1ULL << rTop5)));
		}
		assert(!(((rTop5 == NoReg)
 || (rNext3 == NoReg))));
		second3 = rTop5;
		first3 = rNext3;
		nativePopToReg(ssNativeTop(), second3);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first3);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second3 == SPReg)));
		genoperandoperand(CmpRR, second3, first3);
		/* begin JumpGreaterOrEqual: */
		falseJump3 = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first3);
		/* begin Jump: */
		contJump3 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump3, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first3);
		jmpTarget(contJump3, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first3);
		return 0;

	case 73:
		/* begin genLowcodeInt32LessEqual */
		
		topRegistersMask5 = 0;
		rTop6 = (rNext4 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop6 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext4 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext4 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg4 = (rNext4 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask5 = ((reg4 < 0) ? (((usqInt)(1)) >> (-reg4)) : (1ULL << reg4));
			}
		}
		if (rTop6 == NoReg) {
			rTop6 = allocateRegNotConflictingWith(topRegistersMask5);
		}
		if (rNext4 == NoReg) {
			rNext4 = allocateRegNotConflictingWith(((rTop6 < 0) ? (((usqInt)(1)) >> (-rTop6)) : (1ULL << rTop6)));
		}
		assert(!(((rTop6 == NoReg)
 || (rNext4 == NoReg))));
		second4 = rTop6;
		first4 = rNext4;
		nativePopToReg(ssNativeTop(), second4);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first4);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second4 == SPReg)));
		genoperandoperand(CmpRR, second4, first4);
		/* begin JumpGreater: */
		falseJump4 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first4);
		/* begin Jump: */
		contJump4 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump4, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first4);
		jmpTarget(contJump4, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first4);
		return 0;

	case 74:
		/* begin genLowcodeInt32NotEqual */
		
		topRegistersMask6 = 0;
		rTop7 = (rNext5 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop7 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext5 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext5 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg5 = (rNext5 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask6 = ((reg5 < 0) ? (((usqInt)(1)) >> (-reg5)) : (1ULL << reg5));
			}
		}
		if (rTop7 == NoReg) {
			rTop7 = allocateRegNotConflictingWith(topRegistersMask6);
		}
		if (rNext5 == NoReg) {
			rNext5 = allocateRegNotConflictingWith(((rTop7 < 0) ? (((usqInt)(1)) >> (-rTop7)) : (1ULL << rTop7)));
		}
		assert(!(((rTop7 == NoReg)
 || (rNext5 == NoReg))));
		second5 = rTop7;
		first5 = rNext5;
		nativePopToReg(ssNativeTop(), second5);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first5);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second5 == SPReg)));
		genoperandoperand(CmpRR, second5, first5);
		/* begin JumpZero: */
		falseJump5 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first5);
		/* begin Jump: */
		contJump5 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump5, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first5);
		jmpTarget(contJump5, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first5);
		return 0;

	case 75:
		/* begin genLowcodeInt32ToFloat32 */
		
		rTop8 = NoReg;
		frResult4 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop8 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop8 == NoReg) {
			rTop8 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult4 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop8 == NoReg)
 || (frResult4 == NoReg))));
		value12 = rTop8;
		result = frResult4;
		nativePopToReg(ssNativeTop(), value12);
		ssNativePop(1);
		/* begin ConvertR:Rs: */
		genoperandoperand(ConvertRRs, value12, result);
		ssPushNativeRegisterSingleFloat(result);
		return 0;

	case 76:
		/* begin genLowcodeInt32ToFloat64 */
		
		rTop9 = NoReg;
		frResult5 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop9 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop9 == NoReg) {
			rTop9 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult5 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop9 == NoReg)
 || (frResult5 == NoReg))));
		value13 = rTop9;
		result1 = frResult5;
		nativePopToReg(ssNativeTop(), value13);
		ssNativePop(1);
		/* begin ConvertR:Rd: */
		genoperandoperand(ConvertRRd, value13, result1);
		ssPushNativeRegisterDoubleFloat(result1);
		return 0;

	case 77:
		/* begin genLowcodeInt32ToPointer */
		
		rTop10 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop10 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop10 == NoReg) {
			rTop10 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop10 == NoReg)));
		value14 = rTop10;
		nativePopToReg(ssNativeTop(), value14);
		ssNativePop(1);
		ssPushNativeRegister(value14);
		return 0;

	case 78:
		/* begin genLowcodeInt64Equal */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask7 = 0;
		rTop11 = (rNext6 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop11 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext6 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext6 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg6 = (rNext6 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask7 = ((reg6 < 0) ? (((usqInt)(1)) >> (-reg6)) : (1ULL << reg6));
			}
		}
		if (rTop11 == NoReg) {
			rTop11 = allocateRegNotConflictingWith(topRegistersMask7);
		}
		if (rNext6 == NoReg) {
			rNext6 = allocateRegNotConflictingWith(((rTop11 < 0) ? (((usqInt)(1)) >> (-rTop11)) : (1ULL << rTop11)));
		}
		assert(!(((rTop11 == NoReg)
 || (rNext6 == NoReg))));
		second6 = rTop11;
		first6 = rNext6;
		nativePopToReg(ssNativeTop(), second6);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first6);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second6 == SPReg)));
		genoperandoperand(CmpRR, second6, first6);
		/* begin JumpNonZero: */
		falseJump6 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first6);
		/* begin Jump: */
		contJump6 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump6, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first6);
		jmpTarget(contJump6, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first6);
		return 0;

	case 79:
		/* begin genLowcodeInt64Great */
		
		topRegistersMask8 = 0;
		rTop13 = (rNext7 = NoReg);
		rResult29 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop13 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext7 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext7 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg7 = (rNext7 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask8 = ((reg7 < 0) ? (((usqInt)(1)) >> (-reg7)) : (1ULL << reg7));
			}
		}
		if (rTop13 == NoReg) {
			rTop13 = allocateRegNotConflictingWith(topRegistersMask8);
		}
		if (rNext7 == NoReg) {
			rNext7 = allocateRegNotConflictingWith(((rTop13 < 0) ? (((usqInt)(1)) >> (-rTop13)) : (1ULL << rTop13)));
		}
		assert(!(((rTop13 == NoReg)
 || (rNext7 == NoReg))));
		rResult29 = allocateFloatRegNotConflictingWith((1ULL << rTop13) | (1ULL << rNext7));
		assert(!((rResult29 == NoReg)));
		second7 = rTop13;
		first7 = rNext7;
		value15 = rResult29;
		nativePopToReg(ssNativeTop(), second7);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first7);
		ssNativePop(1);
		abort();
		return 0;

	case 80:
		/* begin genLowcodeInt64GreatEqual */
		
		topRegistersMask9 = 0;
		rTop14 = (rNext8 = NoReg);
		rResult30 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop14 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext8 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext8 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg8 = (rNext8 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask9 = ((reg8 < 0) ? (((usqInt)(1)) >> (-reg8)) : (1ULL << reg8));
			}
		}
		if (rTop14 == NoReg) {
			rTop14 = allocateRegNotConflictingWith(topRegistersMask9);
		}
		if (rNext8 == NoReg) {
			rNext8 = allocateRegNotConflictingWith(((rTop14 < 0) ? (((usqInt)(1)) >> (-rTop14)) : (1ULL << rTop14)));
		}
		assert(!(((rTop14 == NoReg)
 || (rNext8 == NoReg))));
		rResult30 = allocateFloatRegNotConflictingWith((1ULL << rTop14) | (1ULL << rNext8));
		assert(!((rResult30 == NoReg)));
		second8 = rTop14;
		first8 = rNext8;
		value16 = rResult30;
		nativePopToReg(ssNativeTop(), second8);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first8);
		ssNativePop(1);
		abort();
		return 0;

	case 81:
		/* begin genLowcodeInt64Less */
		
		topRegistersMask10 = 0;
		rTop15 = (rNext9 = NoReg);
		rResult31 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop15 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext9 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext9 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg9 = (rNext9 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask10 = ((reg9 < 0) ? (((usqInt)(1)) >> (-reg9)) : (1ULL << reg9));
			}
		}
		if (rTop15 == NoReg) {
			rTop15 = allocateRegNotConflictingWith(topRegistersMask10);
		}
		if (rNext9 == NoReg) {
			rNext9 = allocateRegNotConflictingWith(((rTop15 < 0) ? (((usqInt)(1)) >> (-rTop15)) : (1ULL << rTop15)));
		}
		assert(!(((rTop15 == NoReg)
 || (rNext9 == NoReg))));
		rResult31 = allocateFloatRegNotConflictingWith((1ULL << rTop15) | (1ULL << rNext9));
		assert(!((rResult31 == NoReg)));
		second9 = rTop15;
		first9 = rNext9;
		value17 = rResult31;
		nativePopToReg(ssNativeTop(), second9);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first9);
		ssNativePop(1);
		abort();
		return 0;

	case 82:
		/* begin genLowcodeInt64LessEqual */
		
		topRegistersMask11 = 0;
		rTop16 = (rNext10 = NoReg);
		rResult32 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop16 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext10 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext10 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg10 = (rNext10 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask11 = ((reg10 < 0) ? (((usqInt)(1)) >> (-reg10)) : (1ULL << reg10));
			}
		}
		if (rTop16 == NoReg) {
			rTop16 = allocateRegNotConflictingWith(topRegistersMask11);
		}
		if (rNext10 == NoReg) {
			rNext10 = allocateRegNotConflictingWith(((rTop16 < 0) ? (((usqInt)(1)) >> (-rTop16)) : (1ULL << rTop16)));
		}
		assert(!(((rTop16 == NoReg)
 || (rNext10 == NoReg))));
		rResult32 = allocateFloatRegNotConflictingWith((1ULL << rTop16) | (1ULL << rNext10));
		assert(!((rResult32 == NoReg)));
		second10 = rTop16;
		first10 = rNext10;
		value18 = rResult32;
		nativePopToReg(ssNativeTop(), second10);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first10);
		ssNativePop(1);
		abort();
		return 0;

	case 83:
		/* begin genLowcodeInt64NotEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask12 = 0;
		rTop17 = (rNext12 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop17 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext12 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext12 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg11 = (rNext12 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask12 = ((reg11 < 0) ? (((usqInt)(1)) >> (-reg11)) : (1ULL << reg11));
			}
		}
		if (rTop17 == NoReg) {
			rTop17 = allocateRegNotConflictingWith(topRegistersMask12);
		}
		if (rNext12 == NoReg) {
			rNext12 = allocateRegNotConflictingWith(((rTop17 < 0) ? (((usqInt)(1)) >> (-rTop17)) : (1ULL << rTop17)));
		}
		assert(!(((rTop17 == NoReg)
 || (rNext12 == NoReg))));
		second11 = rTop17;
		first11 = rNext12;
		nativePopToReg(ssNativeTop(), second11);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first11);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second11 == SPReg)));
		genoperandoperand(CmpRR, second11, first11);
		/* begin JumpZero: */
		falseJump7 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first11);
		/* begin Jump: */
		contJump7 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump7, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first11);
		jmpTarget(contJump7, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first11);
		return 0;

	case 84:
		/* begin genLowcodeInt64ToFloat32 */
		
		rTop19 = NoReg;
		frResult6 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop19 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop19 == NoReg) {
			rTop19 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult6 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop19 == NoReg)
 || (frResult6 == NoReg))));
		value19 = rTop19;
		result2 = frResult6;
		nativePopToReg(ssNativeTop(), value19);
		ssNativePop(1);
		abort();
		return 0;

	case 85:
		/* begin genLowcodeInt64ToFloat64 */
		
		rTop20 = NoReg;
		frResult7 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop20 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop20 == NoReg) {
			rTop20 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult7 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop20 == NoReg)
 || (frResult7 == NoReg))));
		value20 = rTop20;
		result3 = frResult7;
		nativePopToReg(ssNativeTop(), value20);
		ssNativePop(1);
		abort();
		return 0;

	case 86:
		/* begin genLowcodeInt64ToPointer */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop21 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop21 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop21 == NoReg) {
			rTop21 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop21 == NoReg)));
		value21 = rTop21;
		nativePopToReg(ssNativeTop(), value21);
		ssNativePop(1);
		ssPushNativeRegister(value21);
		return 0;

	case 87:
		/* begin genLowcodeLeftShift32 */
		
		topRegistersMask14 = 0;
		rTop22 = (rNext15 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop22 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext15 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext15 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg13 = (rNext15 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask14 = ((reg13 < 0) ? (((usqInt)(1)) >> (-reg13)) : (1ULL << reg13));
			}
		}
		if (rTop22 == NoReg) {
			rTop22 = allocateRegNotConflictingWith(topRegistersMask14);
		}
		if (rNext15 == NoReg) {
			rNext15 = allocateRegNotConflictingWith(((rTop22 < 0) ? (((usqInt)(1)) >> (-rTop22)) : (1ULL << rTop22)));
		}
		assert(!(((rTop22 == NoReg)
 || (rNext15 == NoReg))));
		shiftAmount = rTop22;
		value22 = rNext15;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value22);
		ssNativePop(1);
		/* begin LogicalShiftLeftR:R: */
		genoperandoperand(LogicalShiftLeftRR, shiftAmount, value22);
		ssPushNativeRegister(value22);
		return 0;

	case 88:
		/* begin genLowcodeLeftShift64 */
		
		topRegistersMask15 = 0;
		rTop23 = (rNext16 = NoReg);
		rResult33 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop23 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext16 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext16 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg14 = (rNext16 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask15 = ((reg14 < 0) ? (((usqInt)(1)) >> (-reg14)) : (1ULL << reg14));
			}
		}
		if (rTop23 == NoReg) {
			rTop23 = allocateRegNotConflictingWith(topRegistersMask15);
		}
		if (rNext16 == NoReg) {
			rNext16 = allocateRegNotConflictingWith(((rTop23 < 0) ? (((usqInt)(1)) >> (-rTop23)) : (1ULL << rTop23)));
		}
		assert(!(((rTop23 == NoReg)
 || (rNext16 == NoReg))));
		rResult33 = allocateFloatRegNotConflictingWith((1ULL << rTop23) | (1ULL << rNext16));
		assert(!((rResult33 == NoReg)));
		shiftAmount1 = rTop23;
		value23 = rNext16;
		result4 = rResult33;
		nativePopToReg(ssNativeTop(), shiftAmount1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value23);
		ssNativePop(1);
		abort();
		return 0;

	case 89:
		/* begin genLowcodeLoadArgumentAddress */
		baseOffset = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		pointer = rResult;
		loadNativeArgumentAddressto(baseOffset, pointer);
		ssPushNativeRegister(pointer);
		extA = 0;
		return 0;

	case 90:
		/* begin genLowcodeLoadArgumentFloat32 */
		baseOffset1 = extA;
		/* begin allocateRegistersForLowcodeResultFloat: */

		/* Float result */
		frResult = NoReg;
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((frResult == NoReg)));
		floatValue = frResult;
		loadNativeArgumentAddressto(baseOffset1, TempReg);
		/* begin MoveM32:r:Rs: */
		genoperandoperandoperand(MoveM32rRs, 0, TempReg, floatValue);
		ssPushNativeRegisterSingleFloat(floatValue);
		extA = 0;
		return 0;

	case 91:
		/* begin genLowcodeLoadArgumentFloat64 */
		baseOffset2 = extA;
		/* begin allocateRegistersForLowcodeResultFloat: */

		/* Float result */
		frResult1 = NoReg;
		frResult1 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((frResult1 == NoReg)));
		doubleValue = frResult1;
		loadNativeArgumentAddressto(baseOffset2, TempReg);
		/* begin MoveM64:r:Rd: */
		genoperandoperandoperand(MoveM64rRd, 0, TempReg, doubleValue);
		ssPushNativeRegisterDoubleFloat(doubleValue);
		extA = 0;
		return 0;

	case 92:
		/* begin genLowcodeLoadArgumentInt16 */
		baseOffset20 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult34 = NoReg;
		rResult34 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult34 == NoReg)));
		value24 = rResult34;
		loadNativeArgumentAddressto(baseOffset20, TempReg);
		/* begin MoveM16:r:R: */
		genoperandoperandoperand(MoveM16rR, 0, TempReg, value24);
		/* begin SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value24, value24);
		goto l173;
	l173:	/* end SignExtend16R:R: */;
		ssPushNativeRegister(value24);
		extA = 0;
		return 0;

	case 93:
		/* begin genLowcodeLoadArgumentInt32 */
		baseOffset3 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult1 = NoReg;
		rResult1 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult1 == NoReg)));
		value = rResult1;
		loadNativeArgumentAddressto(baseOffset3, TempReg);
		/* begin MoveM32:r:R: */
		genoperandoperandoperand(MoveM32rR, 0, TempReg, value);
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 94:
		/* begin genLowcodeLoadArgumentInt64 */
		baseOffset4 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult11 = NoReg;
		rResult11 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult11 == NoReg)));
		value1 = rResult11;
		loadNativeArgumentAddressto(baseOffset4, TempReg);
		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, TempReg, value1);
		ssPushNativeRegister(value1);
		extA = 0;
		return 0;

	case 95:
		/* begin genLowcodeLoadArgumentInt8 */
		baseOffset21 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult35 = NoReg;
		rResult35 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult35 == NoReg)));
		value25 = rResult35;
		loadNativeArgumentAddressto(baseOffset21, TempReg);
		/* begin MoveM8:r:R: */
		genoperandoperandoperand(MoveM8rR, 0, TempReg, value25);
		/* begin SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, value25, value25);
		goto l180;
	l180:	/* end SignExtend8R:R: */;
		ssPushNativeRegister(value25);
		extA = 0;
		return 0;

	case 96:
		/* begin genLowcodeLoadArgumentPointer */
		baseOffset5 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult4 = NoReg;
		rResult4 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult4 == NoReg)));
		pointerResult = rResult4;
		loadNativeArgumentAddressto(baseOffset5, TempReg);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, TempReg, pointerResult);
		ssPushNativeRegister(pointerResult);
		extA = 0;
		return 0;

	case 97:
		/* begin genLowcodeLoadArgumentUInt16 */
		baseOffset6 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult5 = NoReg;
		rResult5 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult5 == NoReg)));
		value2 = rResult5;
		loadNativeArgumentAddressto(baseOffset6, TempReg);
		/* begin MoveM16:r:R: */
		genoperandoperandoperand(MoveM16rR, 0, TempReg, value2);
		ssPushNativeRegister(value2);
		extA = 0;
		return 0;

	case 98:
		/* begin genLowcodeLoadArgumentUInt32 */
		baseOffset7 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult6 = NoReg;
		rResult6 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult6 == NoReg)));
		value3 = rResult6;
		loadNativeArgumentAddressto(baseOffset7, TempReg);
		/* begin MoveM32:r:R: */
		genoperandoperandoperand(MoveM32rR, 0, TempReg, value3);
		ssPushNativeRegister(value3);
		extA = 0;
		return 0;

	case 99:
		/* begin genLowcodeLoadArgumentUInt64 */
		baseOffset8 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult12 = NoReg;
		rResult12 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult12 == NoReg)));
		value4 = rResult12;
		loadNativeArgumentAddressto(baseOffset8, TempReg);
		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, TempReg, value4);
		ssPushNativeRegister(value4);
		extA = 0;
		return 0;

	case 100:
		/* begin genLowcodeLoadArgumentUInt8 */
		baseOffset9 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult8 = NoReg;
		rResult8 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult8 == NoReg)));
		value5 = rResult8;
		loadNativeArgumentAddressto(baseOffset9, TempReg);
		/* begin MoveM8:r:R: */
		genoperandoperandoperand(MoveM8rR, 0, TempReg, value5);
		ssPushNativeRegister(value5);
		extA = 0;
		return 0;

	case 101:
		/* begin genLowcodeLoadFloat32FromMemory */
		
		rTop24 = NoReg;
		frResult8 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop24 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop24 == NoReg) {
			rTop24 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult8 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop24 == NoReg)
 || (frResult8 == NoReg))));
		pointer3 = rTop24;
		value26 = frResult8;
		nativePopToReg(ssNativeTop(), pointer3);
		ssNativePop(1);
		/* begin MoveM32:r:Rs: */
		genoperandoperandoperand(MoveM32rRs, 0, pointer3, value26);
		ssPushNativeRegisterSingleFloat(value26);
		return 0;

	case 102:
		/* begin genLowcodeLoadFloat64FromMemory */
		
		rTop25 = NoReg;
		frResult9 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop25 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop25 == NoReg) {
			rTop25 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult9 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop25 == NoReg)
 || (frResult9 == NoReg))));
		pointer4 = rTop25;
		value27 = frResult9;
		nativePopToReg(ssNativeTop(), pointer4);
		ssNativePop(1);
		/* begin MoveM64:r:Rd: */
		genoperandoperandoperand(MoveM64rRd, 0, pointer4, value27);
		ssPushNativeRegisterDoubleFloat(value27);
		return 0;

	case 103:
		/* begin genLowcodeLoadInt16FromMemory */
		
		rTop26 = NoReg;
		rResult36 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop26 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop26 == NoReg) {
			rTop26 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult36 = allocateRegNotConflictingWith(((rTop26 < 0) ? (((usqInt)(1)) >> (-rTop26)) : (1ULL << rTop26)));
		assert(!(((rTop26 == NoReg)
 || (rResult36 == NoReg))));
		pointer5 = rTop26;
		value28 = rResult36;
		nativePopToReg(ssNativeTop(), pointer5);
		ssNativePop(1);
		/* begin MoveM16:r:R: */
		genoperandoperandoperand(MoveM16rR, 0, pointer5, value28);
		/* begin SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value28, value28);
		goto l191;
	l191:	/* end SignExtend16R:R: */;
		ssPushNativeRegister(value28);
		return 0;

	case 104:
		/* begin genLowcodeLoadInt32FromMemory */
		
		rTop27 = NoReg;
		rResult37 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop27 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop27 == NoReg) {
			rTop27 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult37 = allocateRegNotConflictingWith(((rTop27 < 0) ? (((usqInt)(1)) >> (-rTop27)) : (1ULL << rTop27)));
		assert(!(((rTop27 == NoReg)
 || (rResult37 == NoReg))));
		pointer6 = rTop27;
		value29 = rResult37;
		nativePopToReg(ssNativeTop(), pointer6);
		ssNativePop(1);
		/* begin MoveM32:r:R: */
		genoperandoperandoperand(MoveM32rR, 0, pointer6, value29);
		ssPushNativeRegister(value29);
		return 0;

	case 105:
		/* begin genLowcodeLoadInt64FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop28 = NoReg;
		rResult38 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop28 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop28 == NoReg) {
			rTop28 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult38 = allocateRegNotConflictingWith(((rTop28 < 0) ? (((usqInt)(1)) >> (-rTop28)) : (1ULL << rTop28)));
		assert(!(((rTop28 == NoReg)
 || (rResult38 == NoReg))));
		pointer7 = rTop28;
		value30 = rResult38;
		nativePopToReg(ssNativeTop(), pointer7);
		ssNativePop(1);
		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, pointer7, value30);
		ssPushNativeRegister(value30);
		return 0;

	case 106:
		/* begin genLowcodeLoadInt8FromMemory */
		
		rTop29 = NoReg;
		rResult39 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop29 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop29 == NoReg) {
			rTop29 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult39 = allocateRegNotConflictingWith(((rTop29 < 0) ? (((usqInt)(1)) >> (-rTop29)) : (1ULL << rTop29)));
		assert(!(((rTop29 == NoReg)
 || (rResult39 == NoReg))));
		pointer8 = rTop29;
		value31 = rResult39;
		nativePopToReg(ssNativeTop(), pointer8);
		ssNativePop(1);
		/* begin MoveM8:r:R: */
		genoperandoperandoperand(MoveM8rR, 0, pointer8, value31);
		/* begin SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, value31, value31);
		goto l205;
	l205:	/* end SignExtend8R:R: */;
		ssPushNativeRegister(value31);
		return 0;

	case 107:
		/* begin genLowcodeLoadLocalAddress */
		baseOffset10 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult9 = NoReg;
		rResult9 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult9 == NoReg)));
		pointer1 = rResult9;
		loadNativeLocalAddressto(baseOffset10, pointer1);
		ssPushNativeRegister(pointer1);
		extA = 0;
		return 0;

	case 108:
		/* begin genLowcodeLoadLocalFloat32 */
		baseOffset11 = extA;
		/* begin allocateRegistersForLowcodeResultFloat: */

		/* Float result */
		frResult2 = NoReg;
		frResult2 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((frResult2 == NoReg)));
		floatValue1 = frResult2;
		loadNativeLocalAddressto(baseOffset11, TempReg);
		/* begin MoveM32:r:Rs: */
		genoperandoperandoperand(MoveM32rRs, 0, TempReg, floatValue1);
		ssPushNativeRegisterSingleFloat(floatValue1);
		extA = 0;
		return 0;

	case 109:
		/* begin genLowcodeLoadLocalFloat64 */
		baseOffset12 = extA;
		/* begin allocateRegistersForLowcodeResultFloat: */

		/* Float result */
		frResult3 = NoReg;
		frResult3 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((frResult3 == NoReg)));
		doubleValue1 = frResult3;
		loadNativeLocalAddressto(baseOffset12, TempReg);
		/* begin MoveM64:r:Rd: */
		genoperandoperandoperand(MoveM64rRd, 0, TempReg, doubleValue1);
		ssPushNativeRegisterDoubleFloat(doubleValue1);
		extA = 0;
		return 0;

	case 110:
		/* begin genLowcodeLoadLocalInt16 */
		baseOffset22 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult40 = NoReg;
		rResult40 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult40 == NoReg)));
		value32 = rResult40;
		loadNativeLocalAddressto(baseOffset22, TempReg);
		/* begin MoveM16:r:R: */
		genoperandoperandoperand(MoveM16rR, 0, TempReg, value32);
		/* begin SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value32, value32);
		goto l212;
	l212:	/* end SignExtend16R:R: */;
		ssPushNativeRegister(value32);
		extA = 0;
		return 0;

	case 111:
		/* begin genLowcodeLoadLocalInt32 */
		baseOffset13 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult10 = NoReg;
		rResult10 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult10 == NoReg)));
		value6 = rResult10;
		loadNativeLocalAddressto(baseOffset13, TempReg);
		/* begin MoveM32:r:R: */
		genoperandoperandoperand(MoveM32rR, 0, TempReg, value6);
		ssPushNativeRegister(value6);
		extA = 0;
		return 0;

	case 112:
		/* begin genLowcodeLoadLocalInt64 */
		baseOffset14 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult13 = NoReg;
		rResult13 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult13 == NoReg)));
		value7 = rResult13;
		loadNativeLocalAddressto(baseOffset14, TempReg);
		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, TempReg, value7);
		ssPushNativeRegister(value7);
		extA = 0;
		return 0;

	case 113:
		/* begin genLowcodeLoadLocalInt8 */
		baseOffset23 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult41 = NoReg;
		rResult41 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult41 == NoReg)));
		value33 = rResult41;
		loadNativeLocalAddressto(baseOffset23, TempReg);
		/* begin MoveM8:r:R: */
		genoperandoperandoperand(MoveM8rR, 0, TempReg, value33);
		/* begin SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, value33, value33);
		goto l219;
	l219:	/* end SignExtend8R:R: */;
		ssPushNativeRegister(value33);
		extA = 0;
		return 0;

	case 114:
		/* begin genLowcodeLoadLocalPointer */
		baseOffset15 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult15 = NoReg;
		rResult15 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult15 == NoReg)));
		pointerResult1 = rResult15;
		loadNativeLocalAddressto(baseOffset15, TempReg);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, TempReg, pointerResult1);
		ssPushNativeRegister(pointerResult1);
		extA = 0;
		return 0;

	case 115:
		/* begin genLowcodeLoadLocalUInt16 */
		baseOffset16 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult16 = NoReg;
		rResult16 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult16 == NoReg)));
		value8 = rResult16;
		loadNativeLocalAddressto(baseOffset16, TempReg);
		/* begin MoveM16:r:R: */
		genoperandoperandoperand(MoveM16rR, 0, TempReg, value8);
		ssPushNativeRegister(value8);
		extA = 0;
		return 0;

	case 116:
		/* begin genLowcodeLoadLocalUInt32 */
		baseOffset17 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult17 = NoReg;
		rResult17 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult17 == NoReg)));
		value9 = rResult17;
		loadNativeLocalAddressto(baseOffset17, TempReg);
		/* begin MoveM32:r:R: */
		genoperandoperandoperand(MoveM32rR, 0, TempReg, value9);
		ssPushNativeRegister(value9);
		extA = 0;
		return 0;

	case 117:
		/* begin genLowcodeLoadLocalUInt64 */
		baseOffset18 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult18 = NoReg;
		rResult18 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult18 == NoReg)));
		value10 = rResult18;
		loadNativeLocalAddressto(baseOffset18, TempReg);
		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, TempReg, value10);
		ssPushNativeRegister(value10);
		extA = 0;
		return 0;

	case 118:
		/* begin genLowcodeLoadLocalUInt8 */
		baseOffset19 = extA;
		/* begin allocateRegistersForLowcodeResultInteger: */

		/* Float result */
		rResult20 = NoReg;
		rResult20 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult20 == NoReg)));
		value11 = rResult20;
		loadNativeLocalAddressto(baseOffset19, TempReg);
		/* begin MoveM8:r:R: */
		genoperandoperandoperand(MoveM8rR, 0, TempReg, value11);
		ssPushNativeRegister(value11);
		extA = 0;
		return 0;

	case 119:
		/* begin genLowcodeLoadObjectAt */
		
		rTop30 = (rOopTop3 = NoReg);
		topRegisterMask1 = 0;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop30 = nativeRegisterOrNone(ssNativeTop());
		}
		if ((registerOrNone(ssTop())) != NoReg) {
			rOopTop3 = registerOrNone(ssTop());
			/* begin registerMaskFor: */
			topRegisterMask1 = ((rOopTop3 < 0) ? (((usqInt)(1)) >> (-rOopTop3)) : (1ULL << rOopTop3));
		}
		if (rTop30 == NoReg) {
			rTop30 = allocateRegNotConflictingWith(topRegisterMask1);
		}
		if (rOopTop3 == NoReg) {
			rOopTop3 = allocateRegNotConflictingWith(((rTop30 < 0) ? (((usqInt)(1)) >> (-rTop30)) : (1ULL << rTop30)));
		}
		assert(!(((rTop30 == NoReg)
 || (rOopTop3 == NoReg))));
		fieldIndex = rTop30;
		object2 = rOopTop3;
		nativePopToReg(ssNativeTop(), fieldIndex);
		ssNativePop(1);
		popToReg(ssTop(), object2);
		ssPop(1);
		genLcLoadObjectat(object2, fieldIndex);
		return 0;

	default:
		return genLowcodeUnaryInlinePrimitive3(prim);

	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive3: */
static sqInt NoDbgRegParms
genLowcodeUnaryInlinePrimitive3(sqInt prim)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction11;
    AbstractInstruction *abstractInstruction12;
    AbstractInstruction *abstractInstruction2;
    AbstractInstruction *abstractInstruction3;
    sqInt address;
    sqInt address1;
    sqInt alignedSize;
    sqInt base;
    sqInt base1;
    sqInt base2;
    sqInt constant;
    sqInt constant1;
    AbstractInstruction *contJump;
    AbstractInstruction *contJump1;
    sqInt dest;
    sqInt dest1;
    sqInt dest2;
    AbstractInstruction *falseJump;
    AbstractInstruction *falseJump1;
    sqInt fieldIndex;
    sqInt first;
    sqInt first1;
    sqInt first2;
    sqInt first3;
    sqInt first4;
    sqInt first5;
    sqInt frTop;
    sqInt frTop1;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    sqInt i4;
    sqInt i5;
    sqInt i6;
    sqInt i7;
    sqInt index1;
    sqInt index11;
    sqInt index2;
    sqInt index4;
    sqInt index5;
    sqInt index6;
    sqInt index7;
    sqInt nativeValueIndex;
    sqInt nativeValueIndex1;
    sqInt nextRegisterMask;
    sqInt nextRegisterMask1;
    sqInt object;
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt offset3;
    sqInt offset4;
    sqInt offset5;
    sqInt offset6;
    sqInt pointer;
    sqInt pointer1;
    sqInt pointer2;
    sqInt pointer3;
    sqInt pointer4;
    sqInt pointer5;
    sqInt pointer6;
    sqInt pointer7;
    sqInt pointer8;
    sqInt pointerResult;
    sqInt pointerValue9;
    sqInt quickConstant;
    sqInt reg1;
    sqInt reg10;
    sqInt reg11;
    sqInt reg2;
    sqInt reg3;
    sqInt reg6;
    sqInt reg7;
    sqInt reg8;
    sqInt registerID;
    sqInt registerID1;
    sqInt registerID2;
    sqInt registerID3;
    sqInt registerID4;
    sqInt reg9;
    sqInt result;
    sqInt result1;
    sqInt result2;
    sqInt rNext1;
    sqInt rNext10;
    sqInt rNext11;
    sqInt rNext13;
    sqInt rNext14;
    sqInt rNext15;
    sqInt rNext2;
    sqInt rNext3;
    sqInt rNext4;
    sqInt rNext5;
    sqInt rNext8;
    sqInt rNextNext;
    sqInt rNextNext1;
    sqInt rOopTop;
    sqInt rResult;
    sqInt rResult1;
    sqInt rResult2;
    sqInt rResult3;
    sqInt rResult4;
    sqInt rResult5;
    sqInt rResult6;
    sqInt rResult7;
    sqInt rResult8;
    sqInt rResult9;
    sqInt rTop;
    sqInt rTop1;
    sqInt rTop10;
    sqInt rTop110;
    sqInt rTop111;
    sqInt rTop13;
    sqInt rTop14;
    sqInt rTop16;
    sqInt rTop17;
    sqInt rTop19;
    sqInt rTop2;
    sqInt rTop20;
    sqInt rTop22;
    sqInt rTop23;
    sqInt rTop25;
    sqInt rTop26;
    sqInt rTop27;
    sqInt rTop28;
    sqInt rTop29;
    sqInt rTop3;
    sqInt rTop30;
    sqInt rTop31;
    sqInt rTop4;
    sqInt rTop5;
    sqInt rTop6;
    sqInt rTop7;
    sqInt rTop8;
    sqInt rTop9;
    sqInt second;
    sqInt second1;
    sqInt second2;
    sqInt second3;
    sqInt second4;
    sqInt second5;
    sqInt size;
    sqInt size1;
    sqInt size2;
    sqInt size3;
    sqInt size4;
    sqInt size5;
    sqInt sizeLow1;
    sqInt source;
    sqInt source1;
    sqInt source2;
    sqInt topRegistersMask1;
    sqInt topRegistersMask10;
    sqInt topRegistersMask11;
    sqInt topRegistersMask12;
    sqInt topRegistersMask13;
    sqInt topRegistersMask2;
    sqInt topRegistersMask3;
    sqInt topRegistersMask6;
    sqInt topRegistersMask7;
    sqInt topRegistersMask8;
    sqInt topRegistersMask9;
    sqInt value;
    sqInt value1;
    sqInt value10;
    sqInt value11;
    sqInt value2;
    sqInt value3;
    sqInt value4;
    sqInt value5;
    sqInt value6;
    sqInt value7;
    sqInt value8;
    sqInt value9;

	sizeLow1 = 0;
	switch (prim) {
	case 120:
		/* begin genLowcodeLoadObjectField */
		fieldIndex = extA;
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {

			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());
			index1 = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i1 = index1; i1 <= (simStackPtr); i1 += 1) {
				if ((registerOrNone(simStackAt(index1))) == rOopTop) {
					goto l22;
				}
			}
	l22:	;
			rOopTop = NoReg;
	l21:	;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcLoadObjectfield(object, fieldIndex);
		extA = 0;
		return 0;

	case 121:
		/* begin genLowcodeLoadPointerFromMemory */
		
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		pointerResult = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, pointer, pointerResult);
		ssPushNativeRegister(pointerResult);
		return 0;

	case 122:
		/* begin genLowcodeLoadUInt16FromMemory */
		
		rTop1 = NoReg;
		rResult1 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop1 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop1 == NoReg) {
			rTop1 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult1 = allocateRegNotConflictingWith(((rTop1 < 0) ? (((usqInt)(1)) >> (-rTop1)) : (1ULL << rTop1)));
		assert(!(((rTop1 == NoReg)
 || (rResult1 == NoReg))));
		pointer1 = rTop1;
		value = rResult1;
		nativePopToReg(ssNativeTop(), pointer1);
		ssNativePop(1);
		/* begin MoveM16:r:R: */
		genoperandoperandoperand(MoveM16rR, 0, pointer1, value);
		ssPushNativeRegister(value);
		return 0;

	case 123:
		/* begin genLowcodeLoadUInt32FromMemory */
		
		rTop2 = NoReg;
		rResult2 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop2 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop2 == NoReg) {
			rTop2 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult2 = allocateRegNotConflictingWith(((rTop2 < 0) ? (((usqInt)(1)) >> (-rTop2)) : (1ULL << rTop2)));
		assert(!(((rTop2 == NoReg)
 || (rResult2 == NoReg))));
		pointer2 = rTop2;
		value1 = rResult2;
		nativePopToReg(ssNativeTop(), pointer2);
		ssNativePop(1);
		/* begin MoveM32:r:R: */
		genoperandoperandoperand(MoveM32rR, 0, pointer2, value1);
		ssPushNativeRegister(value1);
		return 0;

	case 0x7C:
		/* begin genLowcodeLoadUInt64FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop3 = NoReg;
		rResult3 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop3 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop3 == NoReg) {
			rTop3 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult3 = allocateRegNotConflictingWith(((rTop3 < 0) ? (((usqInt)(1)) >> (-rTop3)) : (1ULL << rTop3)));
		assert(!(((rTop3 == NoReg)
 || (rResult3 == NoReg))));
		pointer3 = rTop3;
		value2 = rResult3;
		nativePopToReg(ssNativeTop(), pointer3);
		ssNativePop(1);
		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		/* begin MoveMw:r:R: */
		genoperandoperandoperand(MoveMwrR, 0, pointer3, value2);
		ssPushNativeRegister(value2);
		return 0;

	case 125:
		/* begin genLowcodeLoadUInt8FromMemory */
		
		rTop4 = NoReg;
		rResult4 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop4 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop4 == NoReg) {
			rTop4 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult4 = allocateRegNotConflictingWith(((rTop4 < 0) ? (((usqInt)(1)) >> (-rTop4)) : (1ULL << rTop4)));
		assert(!(((rTop4 == NoReg)
 || (rResult4 == NoReg))));
		pointer4 = rTop4;
		value3 = rResult4;
		nativePopToReg(ssNativeTop(), pointer4);
		ssNativePop(1);
		/* begin MoveM8:r:R: */
		genoperandoperandoperand(MoveM8rR, 0, pointer4, value3);
		ssPushNativeRegister(value3);
		return 0;

	case 0x7E:
		/* begin genLowcodeLocalFrameSize */
		size = extA;
		assert(needsFrame);

		/* Align the size to 16 bytes. */
		hasNativeFrame = 1;

		/* Mark the stack frame */
		alignedSize = (size + 15) & -16;
		annotateobjRef(gMoveCwR(splObj(LowcodeContextMark), TempReg), splObj(LowcodeContextMark));
		/* begin MoveR:Mw:r: */
		offset = frameOffsetOfNativeFrameMark();
		genoperandoperandoperand(MoveRMwr, TempReg, offset, FPReg);
		/* begin MoveAw:R: */
		address = nativeStackPointerAddress();
		genoperandoperand(MoveAwR, address, TempReg);
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, 1, TempReg);
		/* begin MoveR:Mw:r: */
		offset1 = frameOffsetOfPreviousNativeStackPointer();
		genoperandoperandoperand(MoveRMwr, TempReg, offset1, FPReg);
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, alignedSize, TempReg);
		/* begin MoveR:Mw:r: */
		offset2 = frameOffsetOfNativeFramePointer();
		genoperandoperandoperand(MoveRMwr, TempReg, offset2, FPReg);
		/* begin MoveR:Mw:r: */
		offset3 = frameOffsetOfNativeStackPointer();
		genoperandoperandoperand(MoveRMwr, TempReg, offset3, FPReg);
		/* begin SubCq:R: */
		quickConstant = 1 + (defaultNativeStackFrameSize());
		genoperandoperand(SubCqR, quickConstant, TempReg);
		/* begin MoveR:Aw: */
		address1 = nativeStackPointerAddress();
		genoperandoperand(MoveRAw, TempReg, address1);
		extA = 0;
		return 0;

	case 0x7F:
		/* begin genLowcodeLockRegisters */
		
		
		index7 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index7) {
			for (i7 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index7) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index7)); i7 <= index7; i7 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i7), frameOffsetOfTemporary(i7 - 1), FPReg);
			}
			simSpillBase = index7 + 1;
		}
		voidReceiverResultRegContainsSelf();
		return 0;

	case 128:
		/* begin genLowcodeLockVM */
		abort();
		return 0;

	case 129:
		/* begin genLowcodeMalloc32 */
		
		rTop5 = NoReg;
		rResult5 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop5 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop5 == NoReg) {
			rTop5 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult5 = allocateRegNotConflictingWith(((rTop5 < 0) ? (((usqInt)(1)) >> (-rTop5)) : (1ULL << rTop5)));
		assert(!(((rTop5 == NoReg)
 || (rResult5 == NoReg))));
		size1 = rTop5;
		pointer5 = rResult5;
		nativePopToReg(ssNativeTop(), size1);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index2 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index2) {
			for (i2 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index2) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index2)); i2 <= index2; i2 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i2), frameOffsetOfTemporary(i2 - 1), FPReg);
			}
			simSpillBase = index2 + 1;
		}
		voidReceiverResultRegContainsSelf();
		if (size1 != ReceiverResultReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, size1, ReceiverResultReg);
		}
		/* begin CallRT: */
		
		abstractInstruction3 = genoperand(Call, ceMallocTrampoline);
		(abstractInstruction3->annotation = IsRelativeCall);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, TempReg, pointer5);
		ssPushNativeRegister(pointer5);
		return 0;

	case 130:
		/* begin genLowcodeMalloc64 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop6 = NoReg;
		rResult6 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop6 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop6 == NoReg) {
			rTop6 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult6 = allocateRegNotConflictingWith(((rTop6 < 0) ? (((usqInt)(1)) >> (-rTop6)) : (1ULL << rTop6)));
		assert(!(((rTop6 == NoReg)
 || (rResult6 == NoReg))));
		size2 = rTop6;
		pointer6 = rResult6;
		nativePopToReg(ssNativeTop(), size2);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index11 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index11) {
			for (i11 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index11) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index11)); i11 <= index11; i11 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i11), frameOffsetOfTemporary(i11 - 1), FPReg);
			}
			simSpillBase = index11 + 1;
		}
		voidReceiverResultRegContainsSelf();
		if (size2 != ReceiverResultReg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, size2, ReceiverResultReg);
		}
		/* begin CallRT: */
		
		abstractInstruction12 = genoperand(Call, ceMallocTrampoline);
		(abstractInstruction12->annotation = IsRelativeCall);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, TempReg, pointer6);
		ssPushNativeRegister(pointer6);
		return 0;

	case 131:
		/* begin genLowcodeMemcpy32 */
		
		rTop7 = (rNext1 = (rNextNext = NoReg));
		nativeValueIndex = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop7 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext1 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext1 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNext1 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
					rNextNext = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex));
				}
				nativeValueIndex += 1;
			}
		}
		if (rNextNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
			}
		}
		if (rTop7 == NoReg) {
			nextRegisterMask = 0;
			if (rNext1 != NoReg) {
				/* begin registerMaskFor: */
				nextRegisterMask = ((rNext1 < 0) ? (((usqInt)(1)) >> (-rNext1)) : (1ULL << rNext1));
			}
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			rTop7 = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNext1 == NoReg) {
			/* begin registerMaskFor: */
			nextRegisterMask = ((rTop7 < 0) ? (((usqInt)(1)) >> (-rTop7)) : (1ULL << rTop7));
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			rNext1 = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNextNext == NoReg) {
			/* begin registerMaskFor:and: */
			nextRegisterMask = (1ULL << rTop7) | (1ULL << rNext1);
			rNextNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		assert(!(((rTop7 == NoReg)
 || ((rNext1 == NoReg)
 || (rNextNext == NoReg)))));
		size3 = rTop7;
		source = rNext1;
		dest = rNextNext;
		nativePopToReg(ssNativeTop(), size3);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), source);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), dest);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index4 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index4) {
			for (i4 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index4) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index4)); i4 <= index4; i4 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i4), frameOffsetOfTemporary(i4 - 1), FPReg);
			}
			simSpillBase = index4 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genMemCopytosize(backEnd, source, dest, size3);
		return 0;

	case 132:
		/* begin genLowcodeMemcpy64 */
		
		rTop8 = (rNext2 = (rNextNext1 = NoReg));
		nativeValueIndex1 = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop8 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext2 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext2 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex1))) != NoReg) {
				rNext2 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex1));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex1))) != NoReg) {
					rNextNext1 = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex1));
				}
				nativeValueIndex1 += 1;
			}
		}
		if (rNextNext1 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex1))) != NoReg) {
				rNextNext1 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex1));
			}
		}
		if (rTop8 == NoReg) {
			nextRegisterMask1 = 0;
			if (rNext2 != NoReg) {
				/* begin registerMaskFor: */
				nextRegisterMask1 = ((rNext2 < 0) ? (((usqInt)(1)) >> (-rNext2)) : (1ULL << rNext2));
			}
			if (rNextNext1 != NoReg) {
				nextRegisterMask1 = nextRegisterMask1 | (((rNextNext1 < 0) ? (((usqInt)(1)) >> (-rNextNext1)) : (1ULL << rNextNext1)));
			}
			rTop8 = allocateRegNotConflictingWith(nextRegisterMask1);
		}
		if (rNext2 == NoReg) {
			/* begin registerMaskFor: */
			nextRegisterMask1 = ((rTop8 < 0) ? (((usqInt)(1)) >> (-rTop8)) : (1ULL << rTop8));
			if (rNextNext1 != NoReg) {
				nextRegisterMask1 = nextRegisterMask1 | (((rNextNext1 < 0) ? (((usqInt)(1)) >> (-rNextNext1)) : (1ULL << rNextNext1)));
			}
			rNext2 = allocateRegNotConflictingWith(nextRegisterMask1);
		}
		if (rNextNext1 == NoReg) {
			/* begin registerMaskFor:and: */
			nextRegisterMask1 = (1ULL << rTop8) | (1ULL << rNext2);
			rNextNext1 = allocateRegNotConflictingWith(nextRegisterMask1);
		}
		assert(!(((rTop8 == NoReg)
 || ((rNext2 == NoReg)
 || (rNextNext1 == NoReg)))));
		size4 = rTop8;
		source1 = rNext2;
		dest1 = rNextNext1;
		nativePopToReg(ssNativeTop(), size4);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), source1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), dest1);
		ssNativePop(1);
		/* begin ssFlushAll */
		
		index5 = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index5) {
			for (i5 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index5) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index5)); i5 <= index5; i5 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i5), frameOffsetOfTemporary(i5 - 1), FPReg);
			}
			simSpillBase = index5 + 1;
		}
		voidReceiverResultRegContainsSelf();
		genMemCopytosize(backEnd, source1, dest1, sizeLow1);
		return 0;

	case 133:
		/* begin genLowcodeMemcpyFixed */
		size5 = extA;
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask1 = 0;
		rTop9 = (rNext3 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop9 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext3 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext3 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg1 = (rNext3 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask1 = ((reg1 < 0) ? (((usqInt)(1)) >> (-reg1)) : (1ULL << reg1));
			}
		}
		if (rTop9 == NoReg) {
			rTop9 = allocateRegNotConflictingWith(topRegistersMask1);
		}
		if (rNext3 == NoReg) {
			rNext3 = allocateRegNotConflictingWith(((rTop9 < 0) ? (((usqInt)(1)) >> (-rTop9)) : (1ULL << rTop9)));
		}
		assert(!(((rTop9 == NoReg)
 || (rNext3 == NoReg))));
		source2 = rTop9;
		dest2 = rNext3;
		nativePopToReg(ssNativeTop(), source2);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), dest2);
		ssNativePop(1);
		if (size5 == BytesPerWord) {
			/* begin MoveMw:r:R: */
			genoperandoperandoperand(MoveMwrR, 0, source2, TempReg);
			/* begin MoveR:Mw:r: */
			genoperandoperandoperand(MoveRMwr, TempReg, 0, dest2);
		}
		else {
			/* begin ssFlushAll */
			
			index6 = simStackPtr;
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= index6) {
				for (i6 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index6) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index6)); i6 <= index6; i6 += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i6), frameOffsetOfTemporary(i6 - 1), FPReg);
				}
				simSpillBase = index6 + 1;
			}
			voidReceiverResultRegContainsSelf();
			genMemCopytoconstantSize(backEnd, source2, dest2, size5);
		}
		extA = 0;
		return 0;

	case 134:
		/* begin genLowcodeMoveFloat32ToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += BytesPerWord;
		extA = 0;
		return 0;

	case 135:
		/* begin genLowcodeMoveFloat64ToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += 8;
		extA = 0;
		return 0;

	case 136:
		/* begin genLowcodeMoveInt32ToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += BytesPerWord;
		extA = 0;
		return 0;

	case 137:
		/* begin genLowcodeMoveInt64ToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += 8;
		extA = 0;
		return 0;

	case 138:
		/* begin genLowcodeMovePointerToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += BytesPerWord;
		extA = 0;
		return 0;

	case 139:
		/* begin genLowcodeMul32 */
		
		topRegistersMask2 = 0;
		rTop10 = (rNext4 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop10 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext4 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext4 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg2 = (rNext4 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask2 = ((reg2 < 0) ? (((usqInt)(1)) >> (-reg2)) : (1ULL << reg2));
			}
		}
		if (rTop10 == NoReg) {
			rTop10 = allocateRegNotConflictingWith(topRegistersMask2);
		}
		if (rNext4 == NoReg) {
			rNext4 = allocateRegNotConflictingWith(((rTop10 < 0) ? (((usqInt)(1)) >> (-rTop10)) : (1ULL << rTop10)));
		}
		assert(!(((rTop10 == NoReg)
 || (rNext4 == NoReg))));
		second = rTop10;
		first = rNext4;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		/* begin MulR:R: */
		genMulRR(backEnd, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 140:
		/* begin genLowcodeMul64 */
		
		topRegistersMask3 = 0;
		rTop13 = (rNext5 = NoReg);
		rResult7 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop13 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext5 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext5 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg3 = (rNext5 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask3 = ((reg3 < 0) ? (((usqInt)(1)) >> (-reg3)) : (1ULL << reg3));
			}
		}
		if (rTop13 == NoReg) {
			rTop13 = allocateRegNotConflictingWith(topRegistersMask3);
		}
		if (rNext5 == NoReg) {
			rNext5 = allocateRegNotConflictingWith(((rTop13 < 0) ? (((usqInt)(1)) >> (-rTop13)) : (1ULL << rTop13)));
		}
		assert(!(((rTop13 == NoReg)
 || (rNext5 == NoReg))));
		rResult7 = allocateFloatRegNotConflictingWith((1ULL << rTop13) | (1ULL << rNext5));
		assert(!((rResult7 == NoReg)));
		second1 = rTop13;
		first1 = rNext5;
		result = rResult7;
		nativePopToReg(ssNativeTop(), second1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first1);
		ssNativePop(1);
		abort();
		return 0;

	case 141:
		/* begin genLowcodeNeg32 */
		
		rTop14 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop14 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop14 == NoReg) {
			rTop14 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop14 == NoReg)));
		value4 = rTop14;
		nativePopToReg(ssNativeTop(), value4);
		ssNativePop(1);
		/* begin NegateR: */
		genoperand(NegateR, value4);
		ssPushNativeRegister(value4);
		return 0;

	case 142:
		/* begin genLowcodeNeg64 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop16 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop16 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop16 == NoReg) {
			rTop16 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop16 == NoReg)));
		value5 = rTop16;
		nativePopToReg(ssNativeTop(), value5);
		ssNativePop(1);
		/* begin NegateR: */
		genoperand(NegateR, value5);
		ssPushNativeRegister(value5);
		return 0;

	case 143:
		/* begin genLowcodeNot32 */
		
		rTop17 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop17 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop17 == NoReg) {
			rTop17 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop17 == NoReg)));
		value6 = rTop17;
		nativePopToReg(ssNativeTop(), value6);
		ssNativePop(1);
		/* begin NotR: */
		genoperand(NotR, value6);
		ssPushNativeRegister(value6);
		return 0;

	case 144:
		/* begin genLowcodeNot64 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop19 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop19 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop19 == NoReg) {
			rTop19 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop19 == NoReg)));
		value7 = rTop19;
		nativePopToReg(ssNativeTop(), value7);
		ssNativePop(1);
		/* begin NotR: */
		genoperand(NotR, value7);
		ssPushNativeRegister(value7);
		return 0;

	case 145:
		/* begin genLowcodeOr32 */
		
		topRegistersMask6 = 0;
		rTop20 = (rNext8 = NoReg);
		rResult8 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop20 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext8 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext8 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg6 = (rNext8 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask6 = ((reg6 < 0) ? (((usqInt)(1)) >> (-reg6)) : (1ULL << reg6));
			}
		}
		if (rTop20 == NoReg) {
			rTop20 = allocateRegNotConflictingWith(topRegistersMask6);
		}
		if (rNext8 == NoReg) {
			rNext8 = allocateRegNotConflictingWith(((rTop20 < 0) ? (((usqInt)(1)) >> (-rTop20)) : (1ULL << rTop20)));
		}
		assert(!(((rTop20 == NoReg)
 || (rNext8 == NoReg))));
		rResult8 = allocateFloatRegNotConflictingWith((1ULL << rTop20) | (1ULL << rNext8));
		assert(!((rResult8 == NoReg)));
		second2 = rTop20;
		first2 = rNext8;
		result1 = rResult8;
		nativePopToReg(ssNativeTop(), second2);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first2);
		ssNativePop(1);
		/* begin OrR:R: */
		genoperandoperand(OrRR, second2, first2);
		ssPushNativeRegister(first2);
		return 0;

	case 146:
		/* begin genLowcodeOr64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask7 = 0;
		rTop110 = (rNext11 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop110 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext11 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext11 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg7 = (rNext11 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask7 = ((reg7 < 0) ? (((usqInt)(1)) >> (-reg7)) : (1ULL << reg7));
			}
		}
		if (rTop110 == NoReg) {
			rTop110 = allocateRegNotConflictingWith(topRegistersMask7);
		}
		if (rNext11 == NoReg) {
			rNext11 = allocateRegNotConflictingWith(((rTop110 < 0) ? (((usqInt)(1)) >> (-rTop110)) : (1ULL << rTop110)));
		}
		assert(!(((rTop110 == NoReg)
 || (rNext11 == NoReg))));
		second3 = rTop110;
		first3 = rNext11;
		nativePopToReg(ssNativeTop(), second3);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first3);
		ssNativePop(1);
		/* begin OrR:R: */
		genoperandoperand(OrRR, second3, first3);
		ssPushNativeRegister(first3);
		return 0;

	case 147:
		/* begin genLowcodePerformCallout */
		callSwitchToCStack();
		/* begin MoveCw:R: */
		genoperandoperand(MoveCwR, extA, TempReg);
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceFFICalloutTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		/* begin annotateBytecode: */
		abstractInstruction1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction1->annotation = HasBytecodePC);
		extA = 0;
		return 0;

	case 148:
		/* begin genLowcodePerformCalloutIndirect */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);
		callSwitchToCStack();
		/* begin CallRT: */
		
		abstractInstruction2 = genoperand(Call, ceFFICalloutTrampoline);
		(abstractInstruction2->annotation = IsRelativeCall);
		/* begin annotateBytecode: */
		abstractInstruction11 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction11->annotation = HasBytecodePC);
		return 0;

	case 149:
		/* begin genLowcodePushCalloutResultFloat32 */
		cFloatResultToRs(backEnd, DPFPReg0);
		ssPushNativeRegisterSingleFloat(DPFPReg0);
		return 0;

	case 150:
		/* begin genLowcodePushCalloutResultFloat64 */
		cFloatResultToRd(backEnd, DPFPReg0);
		ssPushNativeRegisterDoubleFloat(DPFPReg0);
		return 0;

	case 151:
		/* begin genLowcodePushCalloutResultInt32 */
		
		genoperandoperand(MoveRR, ABIResultReg, ReceiverResultReg);
		ssPushNativeRegister(ReceiverResultReg);
		return 0;

	case 152:
		/* begin genLowcodePushCalloutResultInt64 */
		
		genoperandoperand(MoveRR, ABIResultReg, ReceiverResultReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ABIResultReg, ReceiverResultReg);
		ssPushNativeRegister(ReceiverResultReg);
		return 0;

	case 153:
		/* begin genLowcodePushCalloutResultPointer */
		
		genoperandoperand(MoveRR, ABIResultReg, ReceiverResultReg);
		ssPushNativeRegister(ReceiverResultReg);
		return 0;

	case 161:
		/* begin genLowcodePlaftormCode */
		abort();
		return 0;

	case 162:
		/* begin genLowcodePointerAddConstantOffset */
		offset4 = extB;
		/* begin allocateRegistersForLowcodeInteger: */
		rTop22 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop22 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop22 == NoReg) {
			rTop22 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop22 == NoReg)));
		base = rTop22;
		nativePopToReg(ssNativeTop(), base);
		ssNativePop(1);
		/* begin AddCq:R: */
		genoperandoperand(AddCqR, offset4, base);
		ssPushNativeRegister(base);
		extB = 0;
		numExtB = 0;
		return 0;

	case 163:
		/* begin genLowcodePointerAddOffset32 */
		
		topRegistersMask8 = 0;
		rTop23 = (rNext10 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop23 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext10 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext10 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg8 = (rNext10 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask8 = ((reg8 < 0) ? (((usqInt)(1)) >> (-reg8)) : (1ULL << reg8));
			}
		}
		if (rTop23 == NoReg) {
			rTop23 = allocateRegNotConflictingWith(topRegistersMask8);
		}
		if (rNext10 == NoReg) {
			rNext10 = allocateRegNotConflictingWith(((rTop23 < 0) ? (((usqInt)(1)) >> (-rTop23)) : (1ULL << rTop23)));
		}
		assert(!(((rTop23 == NoReg)
 || (rNext10 == NoReg))));
		offset5 = rTop23;
		base1 = rNext10;
		nativePopToReg(ssNativeTop(), offset5);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), base1);
		ssNativePop(1);
		/* begin AddR:R: */
		genoperandoperand(AddRR, offset5, base1);
		ssPushNativeRegister(base1);
		return 0;

	case 164:
		/* begin genLowcodePointerAddOffset64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask9 = 0;
		rTop111 = (rNext13 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop111 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext13 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext13 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg9 = (rNext13 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask9 = ((reg9 < 0) ? (((usqInt)(1)) >> (-reg9)) : (1ULL << reg9));
			}
		}
		if (rTop111 == NoReg) {
			rTop111 = allocateRegNotConflictingWith(topRegistersMask9);
		}
		if (rNext13 == NoReg) {
			rNext13 = allocateRegNotConflictingWith(((rTop111 < 0) ? (((usqInt)(1)) >> (-rTop111)) : (1ULL << rTop111)));
		}
		assert(!(((rTop111 == NoReg)
 || (rNext13 == NoReg))));
		offset6 = rTop111;
		base2 = rNext13;
		nativePopToReg(ssNativeTop(), offset6);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), base2);
		ssNativePop(1);
		/* begin AddR:R: */
		genoperandoperand(AddRR, offset6, base2);
		ssPushNativeRegister(base2);
		return 0;

	case 165:
		/* begin genLowcodePointerEqual */
		
		topRegistersMask10 = 0;
		rTop25 = (rNext14 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop25 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext14 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext14 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg10 = (rNext14 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask10 = ((reg10 < 0) ? (((usqInt)(1)) >> (-reg10)) : (1ULL << reg10));
			}
		}
		if (rTop25 == NoReg) {
			rTop25 = allocateRegNotConflictingWith(topRegistersMask10);
		}
		if (rNext14 == NoReg) {
			rNext14 = allocateRegNotConflictingWith(((rTop25 < 0) ? (((usqInt)(1)) >> (-rTop25)) : (1ULL << rTop25)));
		}
		assert(!(((rTop25 == NoReg)
 || (rNext14 == NoReg))));
		second4 = rTop25;
		first4 = rNext14;
		nativePopToReg(ssNativeTop(), second4);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first4);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second4 == SPReg)));
		genoperandoperand(CmpRR, second4, first4);
		/* begin JumpNonZero: */
		falseJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first4);
		/* begin Jump: */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first4);
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first4);
		return 0;

	case 166:
		/* begin genLowcodePointerNotEqual */
		
		topRegistersMask11 = 0;
		rTop26 = (rNext15 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop26 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext15 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext15 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg11 = (rNext15 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask11 = ((reg11 < 0) ? (((usqInt)(1)) >> (-reg11)) : (1ULL << reg11));
			}
		}
		if (rTop26 == NoReg) {
			rTop26 = allocateRegNotConflictingWith(topRegistersMask11);
		}
		if (rNext15 == NoReg) {
			rNext15 = allocateRegNotConflictingWith(((rTop26 < 0) ? (((usqInt)(1)) >> (-rTop26)) : (1ULL << rTop26)));
		}
		assert(!(((rTop26 == NoReg)
 || (rNext15 == NoReg))));
		second5 = rTop26;
		first5 = rNext15;
		nativePopToReg(ssNativeTop(), second5);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first5);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second5 == SPReg)));
		genoperandoperand(CmpRR, second5, first5);
		/* begin JumpZero: */
		falseJump1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first5);
		/* begin Jump: */
		contJump1 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first5);
		jmpTarget(contJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first5);
		return 0;

	case 167:
		/* begin genLowcodePointerToInt32 */
		
		rTop27 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop27 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop27 == NoReg) {
			rTop27 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop27 == NoReg)));
		pointer7 = rTop27;
		nativePopToReg(ssNativeTop(), pointer7);
		ssNativePop(1);
		ssPushNativeRegister(pointer7);
		return 0;

	case 168:
		/* begin genLowcodePointerToInt64 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop28 = NoReg;
		rResult9 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop28 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop28 == NoReg) {
			rTop28 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult9 = allocateRegNotConflictingWith(((rTop28 < 0) ? (((usqInt)(1)) >> (-rTop28)) : (1ULL << rTop28)));
		assert(!(((rTop28 == NoReg)
 || (rResult9 == NoReg))));
		pointer8 = rTop28;
		result2 = rResult9;
		nativePopToReg(ssNativeTop(), pointer8);
		ssNativePop(1);
		ssPushNativeRegister(pointer8);
		return 0;

	case 169:
		/* begin genLowcodePopFloat32 */
		
		topRegistersMask12 = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask12);
		}
		assert(!((frTop == NoReg)));
		value8 = frTop;
		nativePopToReg(ssNativeTop(), value8);
		ssNativePop(1);
		return 0;

	case 170:
		/* begin genLowcodePopFloat64 */
		
		topRegistersMask13 = 0;
		frTop1 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop1 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop1 == NoReg) {
			frTop1 = allocateFloatRegNotConflictingWith(topRegistersMask13);
		}
		assert(!((frTop1 == NoReg)));
		value9 = frTop1;
		nativePopToReg(ssNativeTop(), value9);
		ssNativePop(1);
		return 0;

	case 171:
		/* begin genLowcodePopInt32 */
		
		rTop29 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop29 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop29 == NoReg) {
			rTop29 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop29 == NoReg)));
		value10 = rTop29;
		nativePopToReg(ssNativeTop(), value10);
		ssNativePop(1);
		return 0;

	case 172:
		/* begin genLowcodePopInt64 */
		
		rTop30 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop30 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop30 == NoReg) {
			rTop30 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop30 == NoReg)));
		value11 = rTop30;
		nativePopToReg(ssNativeTop(), value11);
		ssNativePop(1);
		return 0;

	case 173:
		/* begin genLowcodePopMultipleNative */
		ssPopNativeSize(extA);
		extA = 0;
		return 0;

	case 174:
		/* begin genLowcodePopPointer */
		
		rTop31 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop31 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop31 == NoReg) {
			rTop31 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop31 == NoReg)));
		pointerValue9 = rTop31;
		nativePopToReg(ssNativeTop(), pointerValue9);
		ssNativePop(1);
		return 0;

	case 175:
		/* begin genLowcodePushConstantUInt32 */
		constant = extA;
		ssPushNativeConstantInt32(constant);
		extA = 0;
		return 0;

	case 176:
		/* begin genLowcodePushConstantUInt64 */
		constant1 = extA;
		ssPushNativeConstantInt64(constant1);
		extA = 0;
		return 0;

	case 177:
		/* begin genLowcodePushNullPointer */
		ssPushNativeConstantPointer(0);
		return 0;

	case 178:
		/* begin genLowcodePushOne32 */
		ssPushNativeConstantInt32(1);
		return 0;

	case 179:
		/* begin genLowcodePushOne64 */
		ssPushNativeConstantInt64(1);
		return 0;

	case 180:
		/* begin genLowcodePushOneFloat32 */
		ssPushNativeConstantFloat32(1.0);
		return 0;

	case 181:
		/* begin genLowcodePushOneFloat64 */
		ssPushNativeConstantFloat64(1.0);
		return 0;

	case 182:
		/* begin genLowcodePushPhysicalFloat32 */
		registerID = extA;
		abort();
		extA = 0;
		return 0;

	case 183:
		/* begin genLowcodePushPhysicalFloat64 */
		registerID1 = extA;
		abort();
		extA = 0;
		return 0;

	case 184:
		/* begin genLowcodePushPhysicalInt32 */
		registerID2 = extA;
		abort();
		extA = 0;
		return 0;

	case 185:
		/* begin genLowcodePushPhysicalInt64 */
		registerID3 = extA;
		abort();
		extA = 0;
		return 0;

	case 186:
		/* begin genLowcodePushPhysicalPointer */
		registerID4 = extA;
		abort();
		extA = 0;
		return 0;

	default:
		return genLowcodeUnaryInlinePrimitive4(prim);

	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive4: */
static sqInt NoDbgRegParms
genLowcodeUnaryInlinePrimitive4(sqInt prim)
{
    sqInt baseOffset;
    sqInt baseOffset1;
    sqInt baseOffset2;
    sqInt baseOffset3;
    sqInt baseOffset4;
    sqInt baseOffset5;
    sqInt baseOffset6;
    AbstractInstruction *contJump;
    AbstractInstruction *contJump1;
    AbstractInstruction *contJump2;
    AbstractInstruction *contJump3;
    sqInt doubleValue;
    AbstractInstruction *falseJump;
    AbstractInstruction *falseJump1;
    AbstractInstruction *falseJump2;
    AbstractInstruction *falseJump3;
    sqInt first1;
    sqInt first10;
    sqInt first13;
    sqInt first14;
    sqInt first15;
    sqInt first16;
    sqInt first17;
    sqInt first18;
    sqInt first19;
    sqInt first2;
    sqInt first20;
    sqInt first21;
    sqInt first22;
    sqInt first23;
    sqInt first24;
    sqInt first25;
    sqInt first26;
    sqInt first7;
    sqInt first8;
    sqInt first9;
    sqInt floatValue;
    sqInt frResult;
    sqInt frResult1;
    sqInt frResult2;
    sqInt frResult3;
    sqInt frTop;
    sqInt frTop1;
    sqInt frTop2;
    sqInt frTop3;
    sqInt memoryPointer;
    sqInt pointer;
    sqInt pointer1;
    sqInt pointer2;
    sqInt pointer3;
    sqInt pointer4;
    sqInt pointer5;
    sqInt pointerValue6;
    sqInt pointerValue7;
    sqInt reg;
    sqInt reg1;
    sqInt reg11;
    sqInt reg12;
    sqInt reg13;
    sqInt reg17;
    sqInt reg18;
    sqInt reg19;
    sqInt reg2;
    sqInt reg20;
    sqInt reg21;
    sqInt reg22;
    sqInt reg23;
    sqInt reg24;
    sqInt reg25;
    sqInt reg26;
    sqInt reg27;
    sqInt reg28;
    sqInt reg29;
    sqInt reg3;
    sqInt reg30;
    sqInt reg31;
    sqInt reg32;
    sqInt reg6;
    sqInt reg7;
    sqInt reg8;
    sqInt reg9;
    sqInt result;
    sqInt result1;
    sqInt result10;
    sqInt result11;
    sqInt result2;
    sqInt result3;
    sqInt result4;
    sqInt result5;
    sqInt result6;
    sqInt result7;
    sqInt result8;
    sqInt result9;
    sqInt rNext;
    sqInt rNext1;
    sqInt rNext11;
    sqInt rNext110;
    sqInt rNext12;
    sqInt rNext13;
    sqInt rNext15;
    sqInt rNext19;
    sqInt rNext2;
    sqInt rNext20;
    sqInt rNext21;
    sqInt rNext22;
    sqInt rNext23;
    sqInt rNext24;
    sqInt rNext25;
    sqInt rNext26;
    sqInt rNext27;
    sqInt rNext28;
    sqInt rNext29;
    sqInt rNext3;
    sqInt rNext30;
    sqInt rNext31;
    sqInt rNext32;
    sqInt rNext33;
    sqInt rNext6;
    sqInt rNext7;
    sqInt rNext9;
    sqInt rResult1;
    sqInt rResult10;
    sqInt rResult13;
    sqInt rResult14;
    sqInt rResult15;
    sqInt rResult3;
    sqInt rResult4;
    sqInt rResult5;
    sqInt rResult6;
    sqInt rResult7;
    sqInt rResult8;
    sqInt rResult9;
    sqInt rTop1;
    sqInt rTop10;
    sqInt rTop111;
    sqInt rTop115;
    sqInt rTop12;
    sqInt rTop14;
    sqInt rTop15;
    sqInt rTop16;
    sqInt rTop17;
    sqInt rTop18;
    sqInt rTop2;
    sqInt rTop20;
    sqInt rTop21;
    sqInt rTop22;
    sqInt rTop23;
    sqInt rTop24;
    sqInt rTop25;
    sqInt rTop27;
    sqInt rTop28;
    sqInt rTop29;
    sqInt rTop3;
    sqInt rTop30;
    sqInt rTop31;
    sqInt rTop32;
    sqInt rTop33;
    sqInt rTop34;
    sqInt rTop35;
    sqInt rTop36;
    sqInt rTop37;
    sqInt rTop38;
    sqInt rTop39;
    sqInt rTop4;
    sqInt rTop40;
    sqInt rTop41;
    sqInt rTop42;
    sqInt rTop43;
    sqInt rTop44;
    sqInt rTop45;
    sqInt rTop46;
    sqInt rTop47;
    sqInt rTop48;
    sqInt rTop49;
    sqInt rTop5;
    sqInt rTop50;
    sqInt rTop52;
    sqInt rTop53;
    sqInt rTop54;
    sqInt rTop6;
    sqInt rTop7;
    sqInt rTop8;
    sqInt rTop9;
    sqInt second;
    sqInt second1;
    sqInt second10;
    sqInt second11;
    sqInt second12;
    sqInt second13;
    sqInt second14;
    sqInt second15;
    sqInt second16;
    sqInt second17;
    sqInt second18;
    sqInt second19;
    sqInt second2;
    sqInt second3;
    sqInt second4;
    sqInt second5;
    sqInt second6;
    sqInt second7;
    sqInt second8;
    sqInt second9;
    sqInt shiftAmount;
    sqInt shiftAmount1;
    sqInt topRegistersMask;
    sqInt topRegistersMask1;
    sqInt topRegistersMask10;
    sqInt topRegistersMask11;
    sqInt topRegistersMask13;
    sqInt topRegistersMask14;
    sqInt topRegistersMask15;
    sqInt topRegistersMask19;
    sqInt topRegistersMask2;
    sqInt topRegistersMask20;
    sqInt topRegistersMask21;
    sqInt topRegistersMask22;
    sqInt topRegistersMask23;
    sqInt topRegistersMask24;
    sqInt topRegistersMask25;
    sqInt topRegistersMask26;
    sqInt topRegistersMask27;
    sqInt topRegistersMask28;
    sqInt topRegistersMask29;
    sqInt topRegistersMask3;
    sqInt topRegistersMask30;
    sqInt topRegistersMask31;
    sqInt topRegistersMask32;
    sqInt topRegistersMask33;
    sqInt topRegistersMask34;
    sqInt topRegistersMask6;
    sqInt topRegistersMask7;
    sqInt topRegistersMask8;
    sqInt topRegistersMask9;
    sqInt value;
    sqInt value1;
    sqInt value10;
    sqInt value11;
    sqInt value12;
    sqInt value13;
    sqInt value14;
    sqInt value15;
    sqInt value16;
    sqInt value17;
    sqInt value18;
    sqInt value19;
    sqInt value2;
    sqInt value20;
    sqInt value21;
    sqInt value22;
    sqInt value23;
    sqInt value24;
    sqInt value25;
    sqInt value26;
    sqInt value27;
    sqInt value28;
    sqInt value29;
    sqInt value3;
    sqInt value30;
    sqInt value31;
    sqInt value32;
    sqInt value4;
    sqInt value5;
    sqInt value6;
    sqInt value7;
    sqInt value8;
    sqInt value9;

	switch (prim) {
	case 187:
		/* begin genLowcodePushSessionIdentifier */
		ssPushNativeConstantInt32(getThisSessionID());
		return 0;

	case 188:
		/* begin genLowcodePushZero32 */
		ssPushNativeConstantInt32(0);
		return 0;

	case 189:
		/* begin genLowcodePushZero64 */
		ssPushNativeConstantInt64(0);
		return 0;

	case 190:
		/* begin genLowcodePushZeroFloat32 */
		ssPushNativeConstantFloat32(0.0);
		return 0;

	case 191:
		/* begin genLowcodePushZeroFloat64 */
		ssPushNativeConstantFloat64(0.0);
		return 0;

	case 192:
		/* begin genLowcodeRem32 */
		
		topRegistersMask = 0;
		rTop4 = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop4 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop4 == NoReg) {
			rTop4 = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop4 < 0) ? (((usqInt)(1)) >> (-rTop4)) : (1ULL << rTop4)));
		}
		assert(!(((rTop4 == NoReg)
 || (rNext == NoReg))));
		second = rTop4;
		first1 = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first1);
		ssNativePop(1);
		gDivRRQuoRem(second, first1, second, first1);
		ssPushNativeRegister(first1);
		return 0;

	case 193:
		/* begin genLowcodeRem64 */
		
		topRegistersMask1 = 0;
		rTop5 = (rNext1 = NoReg);
		rResult3 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop5 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext1 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext1 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg1 = (rNext1 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask1 = ((reg1 < 0) ? (((usqInt)(1)) >> (-reg1)) : (1ULL << reg1));
			}
		}
		if (rTop5 == NoReg) {
			rTop5 = allocateRegNotConflictingWith(topRegistersMask1);
		}
		if (rNext1 == NoReg) {
			rNext1 = allocateRegNotConflictingWith(((rTop5 < 0) ? (((usqInt)(1)) >> (-rTop5)) : (1ULL << rTop5)));
		}
		assert(!(((rTop5 == NoReg)
 || (rNext1 == NoReg))));
		rResult3 = allocateFloatRegNotConflictingWith((1ULL << rTop5) | (1ULL << rNext1));
		assert(!((rResult3 == NoReg)));
		second1 = rTop5;
		first2 = rNext1;
		result1 = rResult3;
		nativePopToReg(ssNativeTop(), second1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first2);
		ssNativePop(1);
		abort();
		return 0;

	case 194:
		/* begin genLowcodeRightShift32 */
		
		topRegistersMask2 = 0;
		rTop6 = (rNext2 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop6 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext2 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext2 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg2 = (rNext2 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask2 = ((reg2 < 0) ? (((usqInt)(1)) >> (-reg2)) : (1ULL << reg2));
			}
		}
		if (rTop6 == NoReg) {
			rTop6 = allocateRegNotConflictingWith(topRegistersMask2);
		}
		if (rNext2 == NoReg) {
			rNext2 = allocateRegNotConflictingWith(((rTop6 < 0) ? (((usqInt)(1)) >> (-rTop6)) : (1ULL << rTop6)));
		}
		assert(!(((rTop6 == NoReg)
 || (rNext2 == NoReg))));
		shiftAmount = rTop6;
		value3 = rNext2;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value3);
		ssNativePop(1);
		/* begin LogicalShiftRightR:R: */
		genoperandoperand(LogicalShiftRightRR, shiftAmount, value3);
		ssPushNativeRegister(value3);
		return 0;

	case 195:
		/* begin genLowcodeRightShift64 */
		
		topRegistersMask3 = 0;
		rTop7 = (rNext3 = NoReg);
		rResult4 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop7 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext3 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext3 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg3 = (rNext3 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask3 = ((reg3 < 0) ? (((usqInt)(1)) >> (-reg3)) : (1ULL << reg3));
			}
		}
		if (rTop7 == NoReg) {
			rTop7 = allocateRegNotConflictingWith(topRegistersMask3);
		}
		if (rNext3 == NoReg) {
			rNext3 = allocateRegNotConflictingWith(((rTop7 < 0) ? (((usqInt)(1)) >> (-rTop7)) : (1ULL << rTop7)));
		}
		assert(!(((rTop7 == NoReg)
 || (rNext3 == NoReg))));
		rResult4 = allocateFloatRegNotConflictingWith((1ULL << rTop7) | (1ULL << rNext3));
		assert(!((rResult4 == NoReg)));
		shiftAmount1 = rTop7;
		value4 = rNext3;
		result2 = rResult4;
		nativePopToReg(ssNativeTop(), shiftAmount1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value4);
		ssNativePop(1);
		abort();
		return 0;

	case 196:
		/* begin genLowcodeSignExtend32From16 */
		
		rTop8 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop8 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop8 == NoReg) {
			rTop8 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop8 == NoReg)));
		value5 = rTop8;
		nativePopToReg(ssNativeTop(), value5);
		ssNativePop(1);
		/* begin SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value5, value5);
		goto l31;
	l31:	/* end SignExtend16R:R: */;
		ssPushNativeRegister(value5);
		return 0;

	case 197:
		/* begin genLowcodeSignExtend32From8 */
		
		rTop9 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop9 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop9 == NoReg) {
			rTop9 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop9 == NoReg)));
		value6 = rTop9;
		nativePopToReg(ssNativeTop(), value6);
		ssNativePop(1);
		/* begin SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, value6, value6);
		goto l37;
	l37:	/* end SignExtend8R:R: */;
		ssPushNativeRegister(value6);
		return 0;

	case 198:
		/* begin genLowcodeSignExtend64From16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop10 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop10 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop10 == NoReg) {
			rTop10 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop10 == NoReg)));
		value7 = rTop10;
		nativePopToReg(ssNativeTop(), value7);
		ssNativePop(1);
		/* begin SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value7, value7);
		goto l48;
	l48:	/* end SignExtend16R:R: */;
		ssPushNativeRegister(value7);
		return 0;

	case 199:
		/* begin genLowcodeSignExtend64From32 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop1 = NoReg;
		rResult1 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop1 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop1 == NoReg) {
			rTop1 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult1 = allocateRegNotConflictingWith(((rTop1 < 0) ? (((usqInt)(1)) >> (-rTop1)) : (1ULL << rTop1)));
		assert(!(((rTop1 == NoReg)
 || (rResult1 == NoReg))));
		value = rTop1;
		result = rResult1;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		/* begin SignExtend32R:R: */
		genoperandoperand(SignExtend32RR, value, value);
		goto l12;
	l12:	/* end SignExtend32R:R: */;
		ssPushNativeRegister(value);
		return 0;

	case 200:
		/* begin genLowcodeSignExtend64From8 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop12 = NoReg;
		rResult5 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop12 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop12 == NoReg) {
			rTop12 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult5 = allocateRegNotConflictingWith(((rTop12 < 0) ? (((usqInt)(1)) >> (-rTop12)) : (1ULL << rTop12)));
		assert(!(((rTop12 == NoReg)
 || (rResult5 == NoReg))));
		value8 = rTop12;
		result3 = rResult5;
		nativePopToReg(ssNativeTop(), value8);
		ssNativePop(1);
		/* begin ZeroExtend16R:R: */
		genoperandoperand(ZeroExtend16RR, value8, value8);
	l65:	/* end ZeroExtend16R:R: */;
		ssPushNativeRegister(value8);
		return 0;

	case 201:
		/* begin genLowcodeStoreFloat32ToMemory */
		

		/* Integer registers */
		frTop = (rTop14 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop14 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop14 == NoReg) {
			rTop14 = allocateRegNotConflictingWith(0);
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeValue(1));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0);
		}
		assert(!(((frTop == NoReg)
 || (rTop14 == NoReg))));
		floatValue = frTop;
		pointer = rTop14;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);
		/* begin MoveRs:M32:r: */
		genoperandoperandoperand(MoveRsM32r, floatValue, 0, pointer);
		return 0;

	case 202:
		/* begin genLowcodeStoreFloat64ToMemory */
		

		/* Integer registers */
		frTop1 = (rTop15 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop15 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop15 == NoReg) {
			rTop15 = allocateRegNotConflictingWith(0);
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			frTop1 = nativeFloatRegisterOrNone(ssNativeValue(1));
		}
		if (frTop1 == NoReg) {
			frTop1 = allocateFloatRegNotConflictingWith(0);
		}
		assert(!(((frTop1 == NoReg)
 || (rTop15 == NoReg))));
		doubleValue = frTop1;
		pointer1 = rTop15;
		nativePopToReg(ssNativeTop(), pointer1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), doubleValue);
		ssNativePop(1);
		/* begin MoveRd:M64:r: */
		genoperandoperandoperand(MoveRdM64r, doubleValue, 0, pointer1);
		return 0;

	case 203:
		/* begin genLowcodeStoreInt16ToMemory */
		
		topRegistersMask6 = 0;
		rTop16 = (rNext6 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop16 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext6 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext6 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg6 = (rNext6 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask6 = ((reg6 < 0) ? (((usqInt)(1)) >> (-reg6)) : (1ULL << reg6));
			}
		}
		if (rTop16 == NoReg) {
			rTop16 = allocateRegNotConflictingWith(topRegistersMask6);
		}
		if (rNext6 == NoReg) {
			rNext6 = allocateRegNotConflictingWith(((rTop16 < 0) ? (((usqInt)(1)) >> (-rTop16)) : (1ULL << rTop16)));
		}
		assert(!(((rTop16 == NoReg)
 || (rNext6 == NoReg))));
		pointer2 = rTop16;
		value9 = rNext6;
		nativePopToReg(ssNativeTop(), pointer2);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value9);
		ssNativePop(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value9, TempReg);
		/* begin MoveR:M16:r: */
		genoperandoperandoperand(MoveRM16r, TempReg, 0, pointer2);
		return 0;

	case 204:
		/* begin genLowcodeStoreInt32ToMemory */
		
		topRegistersMask7 = 0;
		rTop17 = (rNext7 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop17 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext7 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext7 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg7 = (rNext7 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask7 = ((reg7 < 0) ? (((usqInt)(1)) >> (-reg7)) : (1ULL << reg7));
			}
		}
		if (rTop17 == NoReg) {
			rTop17 = allocateRegNotConflictingWith(topRegistersMask7);
		}
		if (rNext7 == NoReg) {
			rNext7 = allocateRegNotConflictingWith(((rTop17 < 0) ? (((usqInt)(1)) >> (-rTop17)) : (1ULL << rTop17)));
		}
		assert(!(((rTop17 == NoReg)
 || (rNext7 == NoReg))));
		pointer3 = rTop17;
		value10 = rNext7;
		nativePopToReg(ssNativeTop(), pointer3);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value10);
		ssNativePop(1);
		/* begin MoveR:M32:r: */
		genoperandoperandoperand(MoveRM32r, value10, 0, pointer3);
		return 0;

	case 205:
		/* begin genLowcodeStoreInt64ToMemory */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask8 = 0;
		rTop18 = (rNext11 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop18 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext11 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext11 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg8 = (rNext11 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask8 = ((reg8 < 0) ? (((usqInt)(1)) >> (-reg8)) : (1ULL << reg8));
			}
		}
		if (rTop18 == NoReg) {
			rTop18 = allocateRegNotConflictingWith(topRegistersMask8);
		}
		if (rNext11 == NoReg) {
			rNext11 = allocateRegNotConflictingWith(((rTop18 < 0) ? (((usqInt)(1)) >> (-rTop18)) : (1ULL << rTop18)));
		}
		assert(!(((rTop18 == NoReg)
 || (rNext11 == NoReg))));
		pointer4 = rTop18;
		value11 = rNext11;
		nativePopToReg(ssNativeTop(), pointer4);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value11);
		ssNativePop(1);
		/* begin MoveR:M64:r: */
		assert(BytesPerWord == 8);
		/* begin MoveR:Mw:r: */
		genoperandoperandoperand(MoveRMwr, value11, 0, pointer4);
		return 0;

	case 206:
		/* begin genLowcodeStoreInt8ToMemory */
		
		topRegistersMask9 = 0;
		rTop20 = (rNext9 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop20 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext9 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext9 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg9 = (rNext9 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask9 = ((reg9 < 0) ? (((usqInt)(1)) >> (-reg9)) : (1ULL << reg9));
			}
		}
		if (rTop20 == NoReg) {
			rTop20 = allocateRegNotConflictingWith(topRegistersMask9);
		}
		if (rNext9 == NoReg) {
			rNext9 = allocateRegNotConflictingWith(((rTop20 < 0) ? (((usqInt)(1)) >> (-rTop20)) : (1ULL << rTop20)));
		}
		assert(!(((rTop20 == NoReg)
 || (rNext9 == NoReg))));
		pointer5 = rTop20;
		value12 = rNext9;
		nativePopToReg(ssNativeTop(), pointer5);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value12);
		ssNativePop(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value12, TempReg);
		/* begin MoveR:M8:r: */
		genoperandoperandoperand(MoveRM8r, TempReg, 0, pointer5);
		return 0;

	case 207:
		/* begin genLowcodeStoreLocalFloat32 */
		baseOffset2 = extA;
		/* begin allocateRegistersForLowcodeFloat: */
		topRegistersMask10 = 0;
		frTop2 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop2 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop2 == NoReg) {
			frTop2 = allocateFloatRegNotConflictingWith(topRegistersMask10);
		}
		assert(!((frTop2 == NoReg)));
		value13 = frTop2;
		nativePopToReg(ssNativeTop(), value13);
		ssNativePop(1);
		loadNativeLocalAddressto(baseOffset2, TempReg);
		/* begin MoveRs:M32:r: */
		genoperandoperandoperand(MoveRsM32r, value13, 0, TempReg);
		extA = 0;
		return 0;

	case 208:
		/* begin genLowcodeStoreLocalFloat64 */
		baseOffset3 = extA;
		/* begin allocateRegistersForLowcodeFloat: */
		topRegistersMask11 = 0;
		frTop3 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop3 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop3 == NoReg) {
			frTop3 = allocateFloatRegNotConflictingWith(topRegistersMask11);
		}
		assert(!((frTop3 == NoReg)));
		value14 = frTop3;
		nativePopToReg(ssNativeTop(), value14);
		ssNativePop(1);
		loadNativeLocalAddressto(baseOffset3, TempReg);
		/* begin MoveRd:M64:r: */
		genoperandoperandoperand(MoveRdM64r, value14, 0, TempReg);
		extA = 0;
		return 0;

	case 209:
		/* begin genLowcodeStoreLocalInt16 */
		baseOffset = extA;
		/* begin allocateRegistersForLowcodeInteger: */
		rTop2 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop2 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop2 == NoReg) {
			rTop2 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop2 == NoReg)));
		value1 = rTop2;
		nativePopToReg(ssNativeTop(), value1);
		ssNativePop(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value1, TempReg);
		loadNativeLocalAddressto(baseOffset, value1);
		/* begin MoveR:M16:r: */
		genoperandoperandoperand(MoveRM16r, TempReg, 0, value1);
		extA = 0;
		return 0;

	case 210:
		/* begin genLowcodeStoreLocalInt32 */
		baseOffset4 = extA;
		/* begin allocateRegistersForLowcodeInteger: */
		rTop21 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop21 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop21 == NoReg) {
			rTop21 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop21 == NoReg)));
		value15 = rTop21;
		nativePopToReg(ssNativeTop(), value15);
		ssNativePop(1);
		loadNativeLocalAddressto(baseOffset4, TempReg);
		/* begin MoveR:M32:r: */
		genoperandoperandoperand(MoveRM32r, value15, 0, TempReg);
		extA = 0;
		return 0;

	case 211:
		/* begin genLowcodeStoreLocalInt64 */
		baseOffset5 = extA;
		/* begin allocateRegistersForLowcodeInteger: */
		rTop22 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop22 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop22 == NoReg) {
			rTop22 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop22 == NoReg)));
		value16 = rTop22;
		nativePopToReg(ssNativeTop(), value16);
		ssNativePop(1);
		/* begin MoveR:M64:r: */
		assert(BytesPerWord == 8);
		/* begin MoveR:Mw:r: */
		genoperandoperandoperand(MoveRMwr, value16, 0, TempReg);
		extA = 0;
		return 0;

	case 212:
		/* begin genLowcodeStoreLocalInt8 */
		baseOffset1 = extA;
		/* begin allocateRegistersForLowcodeInteger: */
		rTop3 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop3 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop3 == NoReg) {
			rTop3 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop3 == NoReg)));
		value2 = rTop3;
		nativePopToReg(ssNativeTop(), value2);
		ssNativePop(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value2, TempReg);
		loadNativeLocalAddressto(baseOffset1, value2);
		/* begin MoveR:M8:r: */
		genoperandoperandoperand(MoveRM8r, TempReg, 0, value2);
		extA = 0;
		return 0;

	case 213:
		/* begin genLowcodeStoreLocalPointer */
		baseOffset6 = extA;
		/* begin allocateRegistersForLowcodeInteger: */
		rTop23 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop23 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop23 == NoReg) {
			rTop23 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop23 == NoReg)));
		pointerValue6 = rTop23;
		nativePopToReg(ssNativeTop(), pointerValue6);
		ssNativePop(1);
		loadNativeLocalAddressto(baseOffset6, TempReg);
		/* begin MoveR:Mw:r: */
		genoperandoperandoperand(MoveRMwr, pointerValue6, 0, TempReg);
		extA = 0;
		return 0;

	case 214:
		/* begin genLowcodeStorePointerToMemory */
		
		topRegistersMask13 = 0;
		rTop24 = (rNext12 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop24 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext12 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext12 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg11 = (rNext12 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask13 = ((reg11 < 0) ? (((usqInt)(1)) >> (-reg11)) : (1ULL << reg11));
			}
		}
		if (rTop24 == NoReg) {
			rTop24 = allocateRegNotConflictingWith(topRegistersMask13);
		}
		if (rNext12 == NoReg) {
			rNext12 = allocateRegNotConflictingWith(((rTop24 < 0) ? (((usqInt)(1)) >> (-rTop24)) : (1ULL << rTop24)));
		}
		assert(!(((rTop24 == NoReg)
 || (rNext12 == NoReg))));
		memoryPointer = rTop24;
		pointerValue7 = rNext12;
		nativePopToReg(ssNativeTop(), memoryPointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), pointerValue7);
		ssNativePop(1);
		/* begin MoveR:Mw:r: */
		genoperandoperandoperand(MoveRMwr, pointerValue7, 0, memoryPointer);
		return 0;

	case 215:
		/* begin genLowcodeSub32 */
		
		topRegistersMask14 = 0;
		rTop25 = (rNext13 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop25 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext13 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext13 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg12 = (rNext13 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask14 = ((reg12 < 0) ? (((usqInt)(1)) >> (-reg12)) : (1ULL << reg12));
			}
		}
		if (rTop25 == NoReg) {
			rTop25 = allocateRegNotConflictingWith(topRegistersMask14);
		}
		if (rNext13 == NoReg) {
			rNext13 = allocateRegNotConflictingWith(((rTop25 < 0) ? (((usqInt)(1)) >> (-rTop25)) : (1ULL << rTop25)));
		}
		assert(!(((rTop25 == NoReg)
 || (rNext13 == NoReg))));
		second2 = rTop25;
		first7 = rNext13;
		nativePopToReg(ssNativeTop(), second2);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first7);
		ssNativePop(1);
		/* begin SubR:R: */
		genoperandoperand(SubRR, second2, first7);
		ssPushNativeRegister(first7);
		return 0;

	case 216:
		/* begin genLowcodeSub64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask15 = 0;
		rTop111 = (rNext15 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop111 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext15 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext15 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg13 = (rNext15 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask15 = ((reg13 < 0) ? (((usqInt)(1)) >> (-reg13)) : (1ULL << reg13));
			}
		}
		if (rTop111 == NoReg) {
			rTop111 = allocateRegNotConflictingWith(topRegistersMask15);
		}
		if (rNext15 == NoReg) {
			rNext15 = allocateRegNotConflictingWith(((rTop111 < 0) ? (((usqInt)(1)) >> (-rTop111)) : (1ULL << rTop111)));
		}
		assert(!(((rTop111 == NoReg)
 || (rNext15 == NoReg))));
		second3 = rTop111;
		first8 = rNext15;
		nativePopToReg(ssNativeTop(), second3);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first8);
		ssNativePop(1);
		/* begin SubR:R: */
		genoperandoperand(SubRR, second3, first8);
		ssPushNativeRegister(first8);
		return 0;

	case 217:
		/* begin genLowcodeTruncate32To16 */
		
		rTop27 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop27 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop27 == NoReg) {
			rTop27 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop27 == NoReg)));
		value17 = rTop27;
		nativePopToReg(ssNativeTop(), value17);
		ssNativePop(1);
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, 0xFFFF, value17);
		ssPushNativeRegister(value17);
		return 0;

	case 218:
		/* begin genLowcodeTruncate32To8 */
		
		rTop28 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop28 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop28 == NoReg) {
			rTop28 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop28 == NoReg)));
		value18 = rTop28;
		nativePopToReg(ssNativeTop(), value18);
		ssNativePop(1);
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, 0xFF, value18);
		ssPushNativeRegister(value18);
		return 0;

	case 219:
		/* begin genLowcodeTruncate64To16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop29 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop29 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop29 == NoReg) {
			rTop29 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop29 == NoReg)));
		value19 = rTop29;
		nativePopToReg(ssNativeTop(), value19);
		ssNativePop(1);
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, 0xFFFF, value19);
		ssPushNativeRegister(value19);
		return 0;

	case 220:
		/* begin genLowcodeTruncate64To32 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop30 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop30 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop30 == NoReg) {
			rTop30 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop30 == NoReg)));
		value20 = rTop30;
		nativePopToReg(ssNativeTop(), value20);
		ssNativePop(1);
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, 0xFFFFFFFFU, value20);
		ssPushNativeRegister(value20);
		return 0;

	case 221:
		/* begin genLowcodeTruncate64To8 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop31 = NoReg;
		rResult6 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop31 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop31 == NoReg) {
			rTop31 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult6 = allocateRegNotConflictingWith(((rTop31 < 0) ? (((usqInt)(1)) >> (-rTop31)) : (1ULL << rTop31)));
		assert(!(((rTop31 == NoReg)
 || (rResult6 == NoReg))));
		value21 = rTop31;
		result4 = rResult6;
		nativePopToReg(ssNativeTop(), value21);
		ssNativePop(1);
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, 0xFF, value21);
		ssPushNativeRegister(value21);
		return 0;

	case 222:
		/* begin genLowcodeUdiv32 */
		
		topRegistersMask19 = 0;
		rTop32 = (rNext19 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop32 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext19 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext19 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg17 = (rNext19 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask19 = ((reg17 < 0) ? (((usqInt)(1)) >> (-reg17)) : (1ULL << reg17));
			}
		}
		if (rTop32 == NoReg) {
			rTop32 = allocateRegNotConflictingWith(topRegistersMask19);
		}
		if (rNext19 == NoReg) {
			rNext19 = allocateRegNotConflictingWith(((rTop32 < 0) ? (((usqInt)(1)) >> (-rTop32)) : (1ULL << rTop32)));
		}
		assert(!(((rTop32 == NoReg)
 || (rNext19 == NoReg))));
		second4 = rTop32;
		first9 = rNext19;
		nativePopToReg(ssNativeTop(), second4);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first9);
		ssNativePop(1);
		gDivRRQuoRem(second4, first9, first9, second4);
		ssPushNativeRegister(first9);
		return 0;

	case 223:
		/* begin genLowcodeUdiv64 */
		
		topRegistersMask20 = 0;
		rTop33 = (rNext20 = NoReg);
		rResult7 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop33 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext20 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext20 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg18 = (rNext20 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask20 = ((reg18 < 0) ? (((usqInt)(1)) >> (-reg18)) : (1ULL << reg18));
			}
		}
		if (rTop33 == NoReg) {
			rTop33 = allocateRegNotConflictingWith(topRegistersMask20);
		}
		if (rNext20 == NoReg) {
			rNext20 = allocateRegNotConflictingWith(((rTop33 < 0) ? (((usqInt)(1)) >> (-rTop33)) : (1ULL << rTop33)));
		}
		assert(!(((rTop33 == NoReg)
 || (rNext20 == NoReg))));
		rResult7 = allocateFloatRegNotConflictingWith((1ULL << rTop33) | (1ULL << rNext20));
		assert(!((rResult7 == NoReg)));
		second5 = rTop33;
		first10 = rNext20;
		result5 = rResult7;
		nativePopToReg(ssNativeTop(), second5);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first10);
		ssNativePop(1);
		abort();
		return 0;

	case 224:
		/* begin genLowcodeUint32Great */
		
		topRegistersMask21 = 0;
		rTop34 = (rNext21 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop34 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext21 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext21 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg19 = (rNext21 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask21 = ((reg19 < 0) ? (((usqInt)(1)) >> (-reg19)) : (1ULL << reg19));
			}
		}
		if (rTop34 == NoReg) {
			rTop34 = allocateRegNotConflictingWith(topRegistersMask21);
		}
		if (rNext21 == NoReg) {
			rNext21 = allocateRegNotConflictingWith(((rTop34 < 0) ? (((usqInt)(1)) >> (-rTop34)) : (1ULL << rTop34)));
		}
		assert(!(((rTop34 == NoReg)
 || (rNext21 == NoReg))));
		second6 = rTop34;
		first13 = rNext21;
		nativePopToReg(ssNativeTop(), second6);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first13);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second6 == SPReg)));
		genoperandoperand(CmpRR, second6, first13);
		/* begin JumpBelowOrEqual: */
		falseJump = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first13);
		/* begin Jump: */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first13);
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first13);
		return 0;

	case 225:
		/* begin genLowcodeUint32GreatEqual */
		
		topRegistersMask22 = 0;
		rTop35 = (rNext22 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop35 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext22 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext22 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg20 = (rNext22 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask22 = ((reg20 < 0) ? (((usqInt)(1)) >> (-reg20)) : (1ULL << reg20));
			}
		}
		if (rTop35 == NoReg) {
			rTop35 = allocateRegNotConflictingWith(topRegistersMask22);
		}
		if (rNext22 == NoReg) {
			rNext22 = allocateRegNotConflictingWith(((rTop35 < 0) ? (((usqInt)(1)) >> (-rTop35)) : (1ULL << rTop35)));
		}
		assert(!(((rTop35 == NoReg)
 || (rNext22 == NoReg))));
		second7 = rTop35;
		first14 = rNext22;
		nativePopToReg(ssNativeTop(), second7);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first14);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second7 == SPReg)));
		genoperandoperand(CmpRR, second7, first14);
		/* begin JumpBelow: */
		falseJump1 = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first14);
		/* begin Jump: */
		contJump1 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first14);
		jmpTarget(contJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first14);
		return 0;

	case 226:
		/* begin genLowcodeUint32Less */
		
		topRegistersMask23 = 0;
		rTop36 = (rNext23 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop36 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext23 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext23 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg21 = (rNext23 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask23 = ((reg21 < 0) ? (((usqInt)(1)) >> (-reg21)) : (1ULL << reg21));
			}
		}
		if (rTop36 == NoReg) {
			rTop36 = allocateRegNotConflictingWith(topRegistersMask23);
		}
		if (rNext23 == NoReg) {
			rNext23 = allocateRegNotConflictingWith(((rTop36 < 0) ? (((usqInt)(1)) >> (-rTop36)) : (1ULL << rTop36)));
		}
		assert(!(((rTop36 == NoReg)
 || (rNext23 == NoReg))));
		second8 = rTop36;
		first15 = rNext23;
		nativePopToReg(ssNativeTop(), second8);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first15);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second8 == SPReg)));
		genoperandoperand(CmpRR, second8, first15);
		/* begin JumpAboveOrEqual: */
		falseJump2 = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first15);
		/* begin Jump: */
		contJump2 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump2, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first15);
		jmpTarget(contJump2, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first15);
		return 0;

	case 227:
		/* begin genLowcodeUint32LessEqual */
		
		topRegistersMask24 = 0;
		rTop37 = (rNext24 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop37 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext24 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext24 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg22 = (rNext24 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask24 = ((reg22 < 0) ? (((usqInt)(1)) >> (-reg22)) : (1ULL << reg22));
			}
		}
		if (rTop37 == NoReg) {
			rTop37 = allocateRegNotConflictingWith(topRegistersMask24);
		}
		if (rNext24 == NoReg) {
			rNext24 = allocateRegNotConflictingWith(((rTop37 < 0) ? (((usqInt)(1)) >> (-rTop37)) : (1ULL << rTop37)));
		}
		assert(!(((rTop37 == NoReg)
 || (rNext24 == NoReg))));
		second9 = rTop37;
		first16 = rNext24;
		nativePopToReg(ssNativeTop(), second9);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first16);
		ssNativePop(1);
		/* begin CmpR:R: */
		assert(!((second9 == SPReg)));
		genoperandoperand(CmpRR, second9, first16);
		/* begin JumpAbove: */
		falseJump3 = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, first16);
		/* begin Jump: */
		contJump3 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump3, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, first16);
		jmpTarget(contJump3, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first16);
		return 0;

	case 228:
		/* begin genLowcodeUint32ToFloat32 */
		
		rTop38 = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop38 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop38 == NoReg) {
			rTop38 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop38 == NoReg)
 || (frResult == NoReg))));
		value22 = rTop38;
		result6 = frResult;
		nativePopToReg(ssNativeTop(), value22);
		ssNativePop(1);
		/* begin ConvertR:Rs: */
		genoperandoperand(ConvertRRs, value22, result6);
		ssPushNativeRegisterSingleFloat(result6);
		return 0;

	case 229:
		/* begin genLowcodeUint32ToFloat64 */
		
		rTop39 = NoReg;
		frResult1 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop39 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop39 == NoReg) {
			rTop39 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult1 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop39 == NoReg)
 || (frResult1 == NoReg))));
		value23 = rTop39;
		result7 = frResult1;
		nativePopToReg(ssNativeTop(), value23);
		ssNativePop(1);
		/* begin ConvertR:Rd: */
		genoperandoperand(ConvertRRd, value23, result7);
		ssPushNativeRegisterDoubleFloat(result7);
		return 0;

	case 230:
		/* begin genLowcodeUint64Great */
		
		topRegistersMask25 = 0;
		rTop40 = (rNext25 = NoReg);
		rResult8 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop40 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext25 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext25 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg23 = (rNext25 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask25 = ((reg23 < 0) ? (((usqInt)(1)) >> (-reg23)) : (1ULL << reg23));
			}
		}
		if (rTop40 == NoReg) {
			rTop40 = allocateRegNotConflictingWith(topRegistersMask25);
		}
		if (rNext25 == NoReg) {
			rNext25 = allocateRegNotConflictingWith(((rTop40 < 0) ? (((usqInt)(1)) >> (-rTop40)) : (1ULL << rTop40)));
		}
		assert(!(((rTop40 == NoReg)
 || (rNext25 == NoReg))));
		rResult8 = allocateFloatRegNotConflictingWith((1ULL << rTop40) | (1ULL << rNext25));
		assert(!((rResult8 == NoReg)));
		second10 = rTop40;
		first17 = rNext25;
		value24 = rResult8;
		nativePopToReg(ssNativeTop(), second10);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first17);
		ssNativePop(1);
		abort();
		return 0;

	case 231:
		/* begin genLowcodeUint64GreatEqual */
		
		topRegistersMask26 = 0;
		rTop41 = (rNext26 = NoReg);
		rResult9 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop41 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext26 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext26 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg24 = (rNext26 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask26 = ((reg24 < 0) ? (((usqInt)(1)) >> (-reg24)) : (1ULL << reg24));
			}
		}
		if (rTop41 == NoReg) {
			rTop41 = allocateRegNotConflictingWith(topRegistersMask26);
		}
		if (rNext26 == NoReg) {
			rNext26 = allocateRegNotConflictingWith(((rTop41 < 0) ? (((usqInt)(1)) >> (-rTop41)) : (1ULL << rTop41)));
		}
		assert(!(((rTop41 == NoReg)
 || (rNext26 == NoReg))));
		rResult9 = allocateFloatRegNotConflictingWith((1ULL << rTop41) | (1ULL << rNext26));
		assert(!((rResult9 == NoReg)));
		second11 = rTop41;
		first18 = rNext26;
		value25 = rResult9;
		nativePopToReg(ssNativeTop(), second11);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first18);
		ssNativePop(1);
		abort();
		return 0;

	case 232:
		/* begin genLowcodeUint64Less */
		
		topRegistersMask27 = 0;
		rTop42 = (rNext27 = NoReg);
		rResult10 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop42 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext27 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext27 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg25 = (rNext27 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask27 = ((reg25 < 0) ? (((usqInt)(1)) >> (-reg25)) : (1ULL << reg25));
			}
		}
		if (rTop42 == NoReg) {
			rTop42 = allocateRegNotConflictingWith(topRegistersMask27);
		}
		if (rNext27 == NoReg) {
			rNext27 = allocateRegNotConflictingWith(((rTop42 < 0) ? (((usqInt)(1)) >> (-rTop42)) : (1ULL << rTop42)));
		}
		assert(!(((rTop42 == NoReg)
 || (rNext27 == NoReg))));
		rResult10 = allocateFloatRegNotConflictingWith((1ULL << rTop42) | (1ULL << rNext27));
		assert(!((rResult10 == NoReg)));
		second12 = rTop42;
		first19 = rNext27;
		value26 = rResult10;
		nativePopToReg(ssNativeTop(), second12);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first19);
		ssNativePop(1);
		abort();
		return 0;

	case 233:
		/* begin genLowcodeUint64LessEqual */
		
		topRegistersMask28 = 0;
		rTop43 = (rNext28 = NoReg);
		rResult13 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop43 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext28 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext28 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg26 = (rNext28 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask28 = ((reg26 < 0) ? (((usqInt)(1)) >> (-reg26)) : (1ULL << reg26));
			}
		}
		if (rTop43 == NoReg) {
			rTop43 = allocateRegNotConflictingWith(topRegistersMask28);
		}
		if (rNext28 == NoReg) {
			rNext28 = allocateRegNotConflictingWith(((rTop43 < 0) ? (((usqInt)(1)) >> (-rTop43)) : (1ULL << rTop43)));
		}
		assert(!(((rTop43 == NoReg)
 || (rNext28 == NoReg))));
		rResult13 = allocateFloatRegNotConflictingWith((1ULL << rTop43) | (1ULL << rNext28));
		assert(!((rResult13 == NoReg)));
		second13 = rTop43;
		first20 = rNext28;
		value27 = rResult13;
		nativePopToReg(ssNativeTop(), second13);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first20);
		ssNativePop(1);
		abort();
		return 0;

	case 234:
		/* begin genLowcodeUint64ToFloat32 */
		
		rTop44 = NoReg;
		frResult2 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop44 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop44 == NoReg) {
			rTop44 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult2 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop44 == NoReg)
 || (frResult2 == NoReg))));
		value28 = rTop44;
		result8 = frResult2;
		nativePopToReg(ssNativeTop(), value28);
		ssNativePop(1);
		abort();
		return 0;

	case 235:
		/* begin genLowcodeUint64ToFloat64 */
		
		rTop45 = NoReg;
		frResult3 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop45 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop45 == NoReg) {
			rTop45 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult3 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop45 == NoReg)
 || (frResult3 == NoReg))));
		value29 = rTop45;
		result9 = frResult3;
		nativePopToReg(ssNativeTop(), value29);
		ssNativePop(1);
		abort();
		return 0;

	case 236:
		/* begin genLowcodeUmul32 */
		
		topRegistersMask29 = 0;
		rTop46 = (rNext29 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop46 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext29 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext29 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg27 = (rNext29 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask29 = ((reg27 < 0) ? (((usqInt)(1)) >> (-reg27)) : (1ULL << reg27));
			}
		}
		if (rTop46 == NoReg) {
			rTop46 = allocateRegNotConflictingWith(topRegistersMask29);
		}
		if (rNext29 == NoReg) {
			rNext29 = allocateRegNotConflictingWith(((rTop46 < 0) ? (((usqInt)(1)) >> (-rTop46)) : (1ULL << rTop46)));
		}
		assert(!(((rTop46 == NoReg)
 || (rNext29 == NoReg))));
		second14 = rTop46;
		first21 = rNext29;
		nativePopToReg(ssNativeTop(), second14);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first21);
		ssNativePop(1);
		/* begin MulR:R: */
		genMulRR(backEnd, second14, first21);
		ssPushNativeRegister(first21);
		return 0;

	case 237:
		/* begin genLowcodeUmul64 */
		
		topRegistersMask30 = 0;
		rTop47 = (rNext30 = NoReg);
		rResult14 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop47 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext30 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext30 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg28 = (rNext30 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask30 = ((reg28 < 0) ? (((usqInt)(1)) >> (-reg28)) : (1ULL << reg28));
			}
		}
		if (rTop47 == NoReg) {
			rTop47 = allocateRegNotConflictingWith(topRegistersMask30);
		}
		if (rNext30 == NoReg) {
			rNext30 = allocateRegNotConflictingWith(((rTop47 < 0) ? (((usqInt)(1)) >> (-rTop47)) : (1ULL << rTop47)));
		}
		assert(!(((rTop47 == NoReg)
 || (rNext30 == NoReg))));
		rResult14 = allocateFloatRegNotConflictingWith((1ULL << rTop47) | (1ULL << rNext30));
		assert(!((rResult14 == NoReg)));
		second15 = rTop47;
		first22 = rNext30;
		result10 = rResult14;
		nativePopToReg(ssNativeTop(), second15);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first22);
		ssNativePop(1);
		abort();
		return 0;

	case 238:
		/* begin genLowcodeUnlockRegisters */
		return 0;

	case 239:
		/* begin genLowcodeUnlockVM */
		abort();
		return 0;

	case 240:
		/* begin genLowcodeUrem32 */
		
		topRegistersMask31 = 0;
		rTop48 = (rNext31 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop48 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext31 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext31 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg29 = (rNext31 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask31 = ((reg29 < 0) ? (((usqInt)(1)) >> (-reg29)) : (1ULL << reg29));
			}
		}
		if (rTop48 == NoReg) {
			rTop48 = allocateRegNotConflictingWith(topRegistersMask31);
		}
		if (rNext31 == NoReg) {
			rNext31 = allocateRegNotConflictingWith(((rTop48 < 0) ? (((usqInt)(1)) >> (-rTop48)) : (1ULL << rTop48)));
		}
		assert(!(((rTop48 == NoReg)
 || (rNext31 == NoReg))));
		second16 = rTop48;
		first23 = rNext31;
		nativePopToReg(ssNativeTop(), second16);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first23);
		ssNativePop(1);
		gDivRRQuoRem(second16, first23, second16, first23);
		ssPushNativeRegister(first23);
		return 0;

	case 241:
		/* begin genLowcodeUrem64 */
		
		topRegistersMask32 = 0;
		rTop49 = (rNext32 = NoReg);
		rResult15 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop49 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext32 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext32 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg30 = (rNext32 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask32 = ((reg30 < 0) ? (((usqInt)(1)) >> (-reg30)) : (1ULL << reg30));
			}
		}
		if (rTop49 == NoReg) {
			rTop49 = allocateRegNotConflictingWith(topRegistersMask32);
		}
		if (rNext32 == NoReg) {
			rNext32 = allocateRegNotConflictingWith(((rTop49 < 0) ? (((usqInt)(1)) >> (-rTop49)) : (1ULL << rTop49)));
		}
		assert(!(((rTop49 == NoReg)
 || (rNext32 == NoReg))));
		rResult15 = allocateFloatRegNotConflictingWith((1ULL << rTop49) | (1ULL << rNext32));
		assert(!((rResult15 == NoReg)));
		second17 = rTop49;
		first24 = rNext32;
		result11 = rResult15;
		nativePopToReg(ssNativeTop(), second17);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first24);
		ssNativePop(1);
		abort();
		return 0;

	case 242:
		/* begin genLowcodeXor32 */
		
		topRegistersMask33 = 0;
		rTop50 = (rNext33 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop50 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext33 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext33 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg31 = (rNext33 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask33 = ((reg31 < 0) ? (((usqInt)(1)) >> (-reg31)) : (1ULL << reg31));
			}
		}
		if (rTop50 == NoReg) {
			rTop50 = allocateRegNotConflictingWith(topRegistersMask33);
		}
		if (rNext33 == NoReg) {
			rNext33 = allocateRegNotConflictingWith(((rTop50 < 0) ? (((usqInt)(1)) >> (-rTop50)) : (1ULL << rTop50)));
		}
		assert(!(((rTop50 == NoReg)
 || (rNext33 == NoReg))));
		second18 = rTop50;
		first25 = rNext33;
		nativePopToReg(ssNativeTop(), second18);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first25);
		ssNativePop(1);
		/* begin XorR:R: */
		genoperandoperand(XorRR, second18, first25);
		ssPushNativeRegister(first25);
		return 0;

	case 243:
		/* begin genLowcodeXor64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask34 = 0;
		rTop115 = (rNext110 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop115 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext110 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext110 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg32 = (rNext110 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask34 = ((reg32 < 0) ? (((usqInt)(1)) >> (-reg32)) : (1ULL << reg32));
			}
		}
		if (rTop115 == NoReg) {
			rTop115 = allocateRegNotConflictingWith(topRegistersMask34);
		}
		if (rNext110 == NoReg) {
			rNext110 = allocateRegNotConflictingWith(((rTop115 < 0) ? (((usqInt)(1)) >> (-rTop115)) : (1ULL << rTop115)));
		}
		assert(!(((rTop115 == NoReg)
 || (rNext110 == NoReg))));
		second19 = rTop115;
		first26 = rNext110;
		nativePopToReg(ssNativeTop(), second19);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first26);
		ssNativePop(1);
		/* begin XorR:R: */
		genoperandoperand(XorRR, second19, first26);
		ssPushNativeRegister(first26);
		return 0;

	case 244:
		/* begin genLowcodeZeroExtend32From16 */
		
		rTop52 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop52 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop52 == NoReg) {
			rTop52 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop52 == NoReg)));
		value30 = rTop52;
		nativePopToReg(ssNativeTop(), value30);
		ssNativePop(1);
		/* begin ZeroExtend16R:R: */
		genoperandoperand(ZeroExtend16RR, value30, value30);
	l217:	/* end ZeroExtend16R:R: */;
		ssPushNativeRegister(value30);
		return 0;

	case 245:
		/* begin genLowcodeZeroExtend32From8 */
		
		rTop53 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop53 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop53 == NoReg) {
			rTop53 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop53 == NoReg)));
		value31 = rTop53;
		nativePopToReg(ssNativeTop(), value31);
		ssNativePop(1);
		/* begin ZeroExtend8R:R: */
		genoperandoperand(ZeroExtend8RR, value31, value31);
	l223:	/* end ZeroExtend8R:R: */;
		ssPushNativeRegister(value31);
		return 0;

	case 246:
		/* begin genLowcodeZeroExtend64From16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop54 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop54 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop54 == NoReg) {
			rTop54 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop54 == NoReg)));
		value32 = rTop54;
		nativePopToReg(ssNativeTop(), value32);
		ssNativePop(1);
		/* begin ZeroExtend16R:R: */
		genoperandoperand(ZeroExtend16RR, value32, value32);
	l231:	/* end ZeroExtend16R:R: */;
		ssPushNativeRegister(value32);
		return 0;

	default:
		return genLowcodeUnaryInlinePrimitive5(prim);

	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive5: */
static sqInt NoDbgRegParms
genLowcodeUnaryInlinePrimitive5(sqInt prim)
{
    sqInt result;
    sqInt rResult;
    sqInt rTop;
    sqInt rTop2;
    sqInt value;
    sqInt value1;

	switch (prim) {
	case 247:
		/* begin genLowcodeZeroExtend64From32 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		/* begin ZeroExtend32R:R: */
		genoperandoperand(ZeroExtend32RR, value, value);
	l8:	/* end ZeroExtend32R:R: */;
		ssPushNativeRegister(value);
		return 0;

	case 0xF8:
		/* begin genLowcodeZeroExtend64From8 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop2 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop2 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop2 == NoReg) {
			rTop2 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop2 == NoReg)));
		value1 = rTop2;
		nativePopToReg(ssNativeTop(), value1);
		ssNativePop(1);
		/* begin ZeroExtend8R:R: */
		genoperandoperand(ZeroExtend8RR, value1, value1);
	l12:	/* end ZeroExtend8R:R: */;
		ssPushNativeRegister(value1);
		return 0;

	default:
		return EncounteredUnknownBytecode;

	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive: */
static sqInt NoDbgRegParms
genLowcodeUnaryInlinePrimitive(sqInt prim)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    sqInt address1;
    sqInt alignment;
    AbstractInstruction *anInstruction;
    sqInt base;
    sqInt base1;
    sqInt check;
    AbstractInstruction *contJump;
    AbstractInstruction *contJump1;
    AbstractInstruction *contJump10;
    AbstractInstruction *contJump11;
    AbstractInstruction *contJump2;
    AbstractInstruction *contJump3;
    AbstractInstruction *contJump4;
    AbstractInstruction *contJump5;
    AbstractInstruction *contJump6;
    AbstractInstruction *contJump7;
    AbstractInstruction *contJump8;
    AbstractInstruction *contJump9;
    sqInt dup2;
    sqInt dup21;
    sqInt dup22;
    sqInt dup23;
    sqInt dup24;
    sqInt expectedSession;
    AbstractInstruction *falseJump;
    AbstractInstruction *falseJump1;
    AbstractInstruction *falseJump10;
    AbstractInstruction *falseJump11;
    AbstractInstruction *falseJump2;
    AbstractInstruction *falseJump3;
    AbstractInstruction *falseJump4;
    AbstractInstruction *falseJump5;
    AbstractInstruction *falseJump6;
    AbstractInstruction *falseJump7;
    AbstractInstruction *falseJump8;
    AbstractInstruction *falseJump9;
    sqInt first;
    sqInt first1;
    sqInt first10;
    sqInt first11;
    sqInt first12;
    sqInt first13;
    sqInt first14;
    sqInt first15;
    sqInt first16;
    sqInt first17;
    sqInt first18;
    sqInt first19;
    sqInt first2;
    sqInt first20;
    sqInt first21;
    sqInt first22;
    sqInt first23;
    sqInt first24;
    sqInt first25;
    sqInt first3;
    sqInt first4;
    sqInt first5;
    sqInt first6;
    sqInt first7;
    sqInt first8;
    sqInt first9;
    sqInt frNext;
    sqInt frNext1;
    sqInt frNext10;
    sqInt frNext11;
    sqInt frNext2;
    sqInt frNext3;
    sqInt frNext4;
    sqInt frNext5;
    sqInt frNext6;
    sqInt frNext7;
    sqInt frNext8;
    sqInt frNext9;
    sqInt frResult;
    sqInt frResult1;
    sqInt frResult2;
    sqInt frResult3;
    sqInt frTop;
    sqInt frTop1;
    sqInt frTop10;
    sqInt frTop11;
    sqInt frTop12;
    sqInt frTop13;
    sqInt frTop14;
    sqInt frTop15;
    sqInt frTop16;
    sqInt frTop17;
    sqInt frTop18;
    sqInt frTop19;
    sqInt frTop2;
    sqInt frTop20;
    sqInt frTop21;
    sqInt frTop22;
    sqInt frTop3;
    sqInt frTop4;
    sqInt frTop5;
    sqInt frTop6;
    sqInt frTop7;
    sqInt frTop8;
    sqInt frTop9;
    sqInt function;
    sqInt index;
    sqInt index1;
    sqInt nativeValueIndex2;
    sqInt nativeValueIndex3;
    sqInt nativeValueIndex4;
    sqInt newValue;
    sqInt nextRegisterMask2;
    sqInt nextRegisterMask3;
    sqInt nextRegisterMask4;
    sqInt offset;
    sqInt offset1;
    sqInt oldValue;
    sqInt pointerValue;
    sqInt reg;
    sqInt reg1;
    sqInt reg10;
    sqInt reg11;
    sqInt reg12;
    sqInt reg13;
    sqInt reg14;
    sqInt reg15;
    sqInt reg16;
    sqInt reg17;
    sqInt reg18;
    sqInt reg19;
    sqInt reg20;
    sqInt reg21;
    sqInt reg22;
    sqInt reg23;
    sqInt reg24;
    sqInt reg25;
    sqInt reg26;
    sqInt reg27;
    sqInt reg28;
    sqInt reg29;
    sqInt reg3;
    sqInt reg4;
    sqInt reg5;
    sqInt reg6;
    sqInt reg7;
    sqInt reg8;
    sqInt registerID;
    sqInt result;
    sqInt result1;
    sqInt result2;
    sqInt result3;
    sqInt result4;
    sqInt result5;
    sqInt result6;
    sqInt result7;
    sqInt result8;
    sqInt rNext;
    sqInt rNext1;
    sqInt rNext10;
    sqInt rNext11;
    sqInt rNext13;
    sqInt rNext14;
    sqInt rNext15;
    sqInt rNext16;
    sqInt rNext17;
    sqInt rNext18;
    sqInt rNext19;
    sqInt rNext20;
    sqInt rNext21;
    sqInt rNext22;
    sqInt rNext4;
    sqInt rNext6;
    sqInt rNext7;
    sqInt rNext8;
    sqInt rNextNext2;
    sqInt rNextNext3;
    sqInt rNextNext4;
    sqInt rNextNextNext2;
    sqInt rNextNextNext3;
    sqInt rNext9;
    sqInt rResult;
    sqInt rResult1;
    sqInt rResult10;
    sqInt rResult12;
    sqInt rResult13;
    sqInt rResult14;
    sqInt rResult15;
    sqInt rResult16;
    sqInt rResult17;
    sqInt rResult18;
    sqInt rResult19;
    sqInt rResult2;
    sqInt rResult20;
    sqInt rResult22;
    sqInt rResult23;
    sqInt rResult24;
    sqInt rResult3;
    sqInt rResult4;
    sqInt rResult5;
    sqInt rResult6;
    sqInt rResult7;
    sqInt rResult8;
    sqInt rResult9;
    sqInt rTop;
    sqInt rTop1;
    sqInt rTop10;
    sqInt rTop11;
    sqInt rTop13;
    sqInt rTop14;
    sqInt rTop15;
    sqInt rTop17;
    sqInt rTop18;
    sqInt rTop19;
    sqInt rTop20;
    sqInt rTop21;
    sqInt rTop22;
    sqInt rTop23;
    sqInt rTop24;
    sqInt rTop25;
    sqInt rTop26;
    sqInt rTop27;
    sqInt rTop3;
    sqInt rTop4;
    sqInt rTop6;
    sqInt rTop7;
    sqInt rTop8;
    sqInt rTop9;
    sqInt scale;
    sqInt scale1;
    sqInt second;
    sqInt second1;
    sqInt second10;
    sqInt second11;
    sqInt second12;
    sqInt second13;
    sqInt second14;
    sqInt second15;
    sqInt second16;
    sqInt second17;
    sqInt second18;
    sqInt second19;
    sqInt second2;
    sqInt second20;
    sqInt second21;
    sqInt second22;
    sqInt second23;
    sqInt second24;
    sqInt second25;
    sqInt second3;
    sqInt second4;
    sqInt second5;
    sqInt second6;
    sqInt second7;
    sqInt second8;
    sqInt second9;
    sqInt shiftAmount;
    sqInt shiftAmount1;
    sqInt singleFloatValue;
    sqInt size;
    sqInt size1;
    sqInt topRegistersMask;
    sqInt topRegistersMask1;
    sqInt topRegistersMask10;
    sqInt topRegistersMask11;
    sqInt topRegistersMask12;
    sqInt topRegistersMask13;
    sqInt topRegistersMask14;
    sqInt topRegistersMask15;
    sqInt topRegistersMask16;
    sqInt topRegistersMask17;
    sqInt topRegistersMask18;
    sqInt topRegistersMask19;
    sqInt topRegistersMask20;
    sqInt topRegistersMask21;
    sqInt topRegistersMask22;
    sqInt topRegistersMask23;
    sqInt topRegistersMask24;
    sqInt topRegistersMask25;
    sqInt topRegistersMask26;
    sqInt topRegistersMask27;
    sqInt topRegistersMask28;
    sqInt topRegistersMask29;
    sqInt topRegistersMask3;
    sqInt topRegistersMask30;
    sqInt topRegistersMask31;
    sqInt topRegistersMask32;
    sqInt topRegistersMask4;
    sqInt topRegistersMask5;
    sqInt topRegistersMask6;
    sqInt topRegistersMask7;
    sqInt topRegistersMask8;
    sqInt value;
    sqInt value1;
    sqInt value10;
    sqInt value11;
    sqInt value12;
    sqInt value13;
    sqInt value14;
    sqInt value15;
    sqInt value16;
    sqInt value17;
    sqInt value18;
    sqInt value19;
    sqInt value2;
    sqInt value20;
    sqInt value21;
    sqInt value22;
    sqInt value23;
    sqInt value24;
    sqInt value25;
    sqInt value26;
    sqInt value3;
    sqInt value4;
    sqInt value5;
    sqInt value6;
    sqInt value7;
    sqInt value8;
    sqInt value9;

	switch (prim) {
	case 0:
		/* begin genLowcodeAdd32 */
		
		topRegistersMask = 0;
		rTop1 = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop1 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop1 == NoReg) {
			rTop1 = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop1 < 0) ? (((usqInt)(1)) >> (-rTop1)) : (1ULL << rTop1)));
		}
		assert(!(((rTop1 == NoReg)
 || (rNext == NoReg))));
		second = rTop1;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		/* begin AddR:R: */
		genoperandoperand(AddRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 1:
		/* begin genLowcodeAdd64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask1 = 0;
		rTop11 = (rNext1 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop11 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext1 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext1 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg1 = (rNext1 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask1 = ((reg1 < 0) ? (((usqInt)(1)) >> (-reg1)) : (1ULL << reg1));
			}
		}
		if (rTop11 == NoReg) {
			rTop11 = allocateRegNotConflictingWith(topRegistersMask1);
		}
		if (rNext1 == NoReg) {
			rNext1 = allocateRegNotConflictingWith(((rTop11 < 0) ? (((usqInt)(1)) >> (-rTop11)) : (1ULL << rTop11)));
		}
		assert(!(((rTop11 == NoReg)
 || (rNext1 == NoReg))));
		second1 = rTop11;
		first1 = rNext1;
		nativePopToReg(ssNativeTop(), second1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first1);
		ssNativePop(1);
		/* begin AddR:R: */
		genoperandoperand(AddRR, second1, first1);
		ssPushNativeRegister(first1);
		return 0;

	case 2:
		/* begin genLowcodeAlloca32 */
		
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		size = rTop;
		nativePopToReg(ssNativeTop(), size);
		ssNativePop(1);
		/* begin MoveAw:R: */
		address = nativeStackPointerAddress();
		genoperandoperand(MoveAwR, address, TempReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, size, TempReg);
		/* begin AndCq:R: */
		genoperandoperand(AndCqR, -16, TempReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, TempReg, size);
		/* begin MoveR:Aw: */
		address1 = nativeStackPointerAddress();
		genoperandoperand(MoveRAw, size, address1);
		ssPushNativeRegister(size);
		return 0;

	case 3:
		/* begin genLowcodeAlloca64 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop3 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop3 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop3 == NoReg) {
			rTop3 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop3 == NoReg)));
		size1 = rTop3;
		nativePopToReg(ssNativeTop(), size1);
		ssNativePop(1);
		/* begin SubR:R: */
		genoperandoperand(SubRR, size1, SPReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, SPReg, size1);
		ssPushNativeRegister(size1);
		return 0;

	case 4:
		/* begin genLowcodeAnd32 */
		
		topRegistersMask3 = 0;
		rTop4 = (rNext4 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop4 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext4 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext4 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg3 = (rNext4 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask3 = ((reg3 < 0) ? (((usqInt)(1)) >> (-reg3)) : (1ULL << reg3));
			}
		}
		if (rTop4 == NoReg) {
			rTop4 = allocateRegNotConflictingWith(topRegistersMask3);
		}
		if (rNext4 == NoReg) {
			rNext4 = allocateRegNotConflictingWith(((rTop4 < 0) ? (((usqInt)(1)) >> (-rTop4)) : (1ULL << rTop4)));
		}
		assert(!(((rTop4 == NoReg)
 || (rNext4 == NoReg))));
		second2 = rTop4;
		first2 = rNext4;
		nativePopToReg(ssNativeTop(), second2);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first2);
		ssNativePop(1);
		/* begin AndR:R: */
		genoperandoperand(AndRR, second2, first2);
		ssPushNativeRegister(first2);
		return 0;

	case 5:
		/* begin genLowcodeAnd64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask4 = 0;
		rTop13 = (rNext11 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop13 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext11 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext11 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg4 = (rNext11 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask4 = ((reg4 < 0) ? (((usqInt)(1)) >> (-reg4)) : (1ULL << reg4));
			}
		}
		if (rTop13 == NoReg) {
			rTop13 = allocateRegNotConflictingWith(topRegistersMask4);
		}
		if (rNext11 == NoReg) {
			rNext11 = allocateRegNotConflictingWith(((rTop13 < 0) ? (((usqInt)(1)) >> (-rTop13)) : (1ULL << rTop13)));
		}
		assert(!(((rTop13 == NoReg)
 || (rNext11 == NoReg))));
		second3 = rTop13;
		first3 = rNext11;
		nativePopToReg(ssNativeTop(), second3);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first3);
		ssNativePop(1);
		/* begin AndR:R: */
		genoperandoperand(AndRR, second3, first3);
		ssPushNativeRegister(first3);
		return 0;

	case 6:
		/* begin genLowcodeArithmeticRightShift32 */
		
		topRegistersMask5 = 0;
		rTop6 = (rNext6 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop6 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext6 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext6 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg5 = (rNext6 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask5 = ((reg5 < 0) ? (((usqInt)(1)) >> (-reg5)) : (1ULL << reg5));
			}
		}
		if (rTop6 == NoReg) {
			rTop6 = allocateRegNotConflictingWith(topRegistersMask5);
		}
		if (rNext6 == NoReg) {
			rNext6 = allocateRegNotConflictingWith(((rTop6 < 0) ? (((usqInt)(1)) >> (-rTop6)) : (1ULL << rTop6)));
		}
		assert(!(((rTop6 == NoReg)
 || (rNext6 == NoReg))));
		shiftAmount = rTop6;
		value = rNext6;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		/* begin ArithmeticShiftRightR:R: */
		genoperandoperand(ArithmeticShiftRightRR, shiftAmount, value);
		ssPushNativeRegister(value);
		return 0;

	case 7:
		/* begin genLowcodeArithmeticRightShift64 */
		
		topRegistersMask6 = 0;
		rTop7 = (rNext7 = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop7 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext7 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext7 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg6 = (rNext7 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask6 = ((reg6 < 0) ? (((usqInt)(1)) >> (-reg6)) : (1ULL << reg6));
			}
		}
		if (rTop7 == NoReg) {
			rTop7 = allocateRegNotConflictingWith(topRegistersMask6);
		}
		if (rNext7 == NoReg) {
			rNext7 = allocateRegNotConflictingWith(((rTop7 < 0) ? (((usqInt)(1)) >> (-rTop7)) : (1ULL << rTop7)));
		}
		assert(!(((rTop7 == NoReg)
 || (rNext7 == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop7) | (1ULL << rNext7));
		assert(!((rResult == NoReg)));
		shiftAmount1 = rTop7;
		value1 = rNext7;
		result = rResult;
		nativePopToReg(ssNativeTop(), shiftAmount1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value1);
		ssNativePop(1);
		abort();
		return 0;

	case 8:
		/* begin genLowcodeBeginCall */
		alignment = extA;
		beginHighLevelCall(alignment);
		extA = 0;
		return 0;

	case 9:
		/* begin genLowcodeCallArgumentFloat32 */
		nativeStackPopToReg(ssNativeTop(), DPFPReg0);
		ssNativePop(1);
		/* begin MoveRs:M32:r: */
		
		-BytesPerWord;
		anInstruction = genoperandoperandoperand(MoveRsM32r, DPFPReg0, -BytesPerWord, SPReg);
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, BytesPerWord, SPReg);
		currentCallCleanUpSize += BytesPerWord;
		return 0;

	case 10:
		/* begin genLowcodeCallArgumentFloat64 */
		nativeStackPopToReg(ssNativeTop(), DPFPReg0);
		ssNativePop(1);
		/* begin MoveRd:M64:r: */
		genoperandoperandoperand(MoveRdM64r, DPFPReg0, -8, SPReg);
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, 8, SPReg);
		currentCallCleanUpSize += 8;
		return 0;

	case 11:
		/* begin genLowcodeCallArgumentInt32 */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);
		/* begin PushR: */
		genoperand(PushR, TempReg);
		currentCallCleanUpSize += BytesPerWord;
		return 0;

	case 12:
		/* begin genLowcodeCallArgumentInt64 */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);
		/* begin PushR: */
		genoperand(PushR, TempReg);
		currentCallCleanUpSize += BytesPerWord;
		return 0;

	case 13:
		/* begin genLowcodeCallArgumentPointer */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);
		/* begin PushR: */
		genoperand(PushR, TempReg);
		currentCallCleanUpSize += BytesPerWord;
		return 0;

	case 14:
		/* begin genLowcodeCallArgumentSpace */
		
		genoperandoperand(SubCqR, extA, SPReg);
		currentCallCleanUpSize += extA;
		extA = 0;
		return 0;

	case 15:
		/* begin genLowcodeCallArgumentStructure */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, extA, SPReg);

		/* Copy the structure */
		currentCallCleanUpSize += extA;
		genMemCopytoconstantSize(backEnd, TempReg, SPReg, extA);
		extA = 0;
		return 0;

	case 16:
		/* begin genLowcodeCallInstruction */
		function = extA;
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, function);
		(abstractInstruction->annotation = IsRelativeCall);
		extA = 0;
		return 0;

	case 17:
		/* begin genLowcodeCallPhysical */
		registerID = extA;
		/* begin CallR: */
		genoperand(CallR, registerID);
		extA = 0;
		return 0;

	case 18:
		/* begin genLowcodeCheckSessionIdentifier */
		expectedSession = extA;
		ssPushNativeConstantInt32((expectedSession == (getThisSessionID())
			? 1
			: 0));
		extA = 0;
		return 0;

	case 19:
		/* begin genLowcodeCompareAndSwap32 */
		
		rTop8 = (rNext8 = (rNextNext2 = NoReg));
		nativeValueIndex2 = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop8 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext8 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext8 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex2))) != NoReg) {
				rNext8 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex2));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex2))) != NoReg) {
					rNextNext2 = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex2));
				}
				nativeValueIndex2 += 1;
			}
		}
		if (rNextNext2 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex2))) != NoReg) {
				rNextNext2 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex2));
			}
		}
		if (rTop8 == NoReg) {
			nextRegisterMask2 = 0;
			if (rNext8 != NoReg) {
				/* begin registerMaskFor: */
				nextRegisterMask2 = ((rNext8 < 0) ? (((usqInt)(1)) >> (-rNext8)) : (1ULL << rNext8));
			}
			if (rNextNext2 != NoReg) {
				nextRegisterMask2 = nextRegisterMask2 | (((rNextNext2 < 0) ? (((usqInt)(1)) >> (-rNextNext2)) : (1ULL << rNextNext2)));
			}
			rTop8 = allocateRegNotConflictingWith(nextRegisterMask2);
		}
		if (rNext8 == NoReg) {
			/* begin registerMaskFor: */
			nextRegisterMask2 = ((rTop8 < 0) ? (((usqInt)(1)) >> (-rTop8)) : (1ULL << rTop8));
			if (rNextNext2 != NoReg) {
				nextRegisterMask2 = nextRegisterMask2 | (((rNextNext2 < 0) ? (((usqInt)(1)) >> (-rNextNext2)) : (1ULL << rNextNext2)));
			}
			rNext8 = allocateRegNotConflictingWith(nextRegisterMask2);
		}
		if (rNextNext2 == NoReg) {
			/* begin registerMaskFor:and: */
			nextRegisterMask2 = (1ULL << rTop8) | (1ULL << rNext8);
			rNextNext2 = allocateRegNotConflictingWith(nextRegisterMask2);
		}
		assert(!(((rTop8 == NoReg)
 || ((rNext8 == NoReg)
 || (rNextNext2 == NoReg)))));
		rResult1 = allocateRegNotConflictingWith(((1ULL << rTop8) | (1ULL << rNext8)) | (1ULL << rNextNext2));
		assert(!((rResult1 == NoReg)));
		newValue = rTop8;
		oldValue = rNext8;
		check = rNextNext2;
		value2 = rResult1;
		nativePopToReg(ssNativeTop(), newValue);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), oldValue);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), check);
		ssNativePop(1);
		abort();
		return 0;

	case 20:
		/* begin genLowcodeDiv32 */
		
		topRegistersMask7 = 0;
		rTop9 = (rNext9 = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop9 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext9 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext9 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg7 = (rNext9 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask7 = ((reg7 < 0) ? (((usqInt)(1)) >> (-reg7)) : (1ULL << reg7));
			}
		}
		if (rTop9 == NoReg) {
			rTop9 = allocateRegNotConflictingWith(topRegistersMask7);
		}
		if (rNext9 == NoReg) {
			rNext9 = allocateRegNotConflictingWith(((rTop9 < 0) ? (((usqInt)(1)) >> (-rTop9)) : (1ULL << rTop9)));
		}
		assert(!(((rTop9 == NoReg)
 || (rNext9 == NoReg))));
		second4 = rTop9;
		first4 = rNext9;
		nativePopToReg(ssNativeTop(), second4);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first4);
		ssNativePop(1);
		gDivRRQuoRem(second4, first4, first4, second4);
		ssPushNativeRegister(first4);
		return 0;

	case 21:
		/* begin genLowcodeDiv64 */
		
		topRegistersMask8 = 0;
		rTop10 = (rNext10 = NoReg);
		rResult2 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop10 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext10 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext10 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg8 = (rNext10 = nativeRegisterOrNone(ssNativeValue(1)));
				topRegistersMask8 = ((reg8 < 0) ? (((usqInt)(1)) >> (-reg8)) : (1ULL << reg8));
			}
		}
		if (rTop10 == NoReg) {
			rTop10 = allocateRegNotConflictingWith(topRegistersMask8);
		}
		if (rNext10 == NoReg) {
			rNext10 = allocateRegNotConflictingWith(((rTop10 < 0) ? (((usqInt)(1)) >> (-rTop10)) : (1ULL << rTop10)));
		}
		assert(!(((rTop10 == NoReg)
 || (rNext10 == NoReg))));
		rResult2 = allocateFloatRegNotConflictingWith((1ULL << rTop10) | (1ULL << rNext10));
		assert(!((rResult2 == NoReg)));
		second5 = rTop10;
		first5 = rNext10;
		result1 = rResult2;
		nativePopToReg(ssNativeTop(), second5);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first5);
		ssNativePop(1);
		abort();
		return 0;

	case 22:
		/* begin genLowcodeDuplicateFloat32 */
		
		frTop = NoReg;

		/* Float argument */
		frResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		assert(!(((frTop == NoReg)
 || (frResult == NoReg))));
		value3 = frTop;
		dup2 = frResult;
		nativePopToReg(ssNativeTop(), value3);
		ssNativePop(1);
		/* begin MoveRs:Rs: */
		genoperandoperand(MoveRsRs, value3, dup2);
		ssPushNativeRegisterSingleFloat(value3);
		ssPushNativeRegisterSingleFloat(dup2);
		return 0;

	case 23:
		/* begin genLowcodeDuplicateFloat64 */
		
		frTop1 = NoReg;

		/* Float argument */
		frResult1 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop1 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop1 == NoReg) {
			frTop1 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult1 = allocateFloatRegNotConflictingWith(((frTop1 < 0) ? (((usqInt)(1)) >> (-frTop1)) : (1ULL << frTop1)));
		assert(!(((frTop1 == NoReg)
 || (frResult1 == NoReg))));
		value4 = frTop1;
		dup21 = frResult1;
		nativePopToReg(ssNativeTop(), value4);
		ssNativePop(1);
		/* begin MoveRd:Rd: */
		genoperandoperand(MoveRdRd, value4, dup21);
		ssPushNativeRegisterDoubleFloat(value4);
		ssPushNativeRegisterDoubleFloat(dup21);
		return 0;

	case 24:
		/* begin genLowcodeDuplicateInt32 */
		
		rTop14 = NoReg;
		rResult3 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop14 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop14 == NoReg) {
			rTop14 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult3 = allocateRegNotConflictingWith(((rTop14 < 0) ? (((usqInt)(1)) >> (-rTop14)) : (1ULL << rTop14)));
		assert(!(((rTop14 == NoReg)
 || (rResult3 == NoReg))));
		value5 = rTop14;
		dup22 = rResult3;
		nativePopToReg(ssNativeTop(), value5);
		ssNativePop(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value5, dup22);
		ssPushNativeRegister(value5);
		ssPushNativeRegister(dup22);
		return 0;

	case 25:
		/* begin genLowcodeDuplicateInt64 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop15 = NoReg;
		rResult4 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop15 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop15 == NoReg) {
			rTop15 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult4 = allocateRegNotConflictingWith(((rTop15 < 0) ? (((usqInt)(1)) >> (-rTop15)) : (1ULL << rTop15)));
		assert(!(((rTop15 == NoReg)
 || (rResult4 == NoReg))));
		value6 = rTop15;
		dup23 = rResult4;
		nativePopToReg(ssNativeTop(), value6);
		ssNativePop(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, value6, dup23);
		ssPushNativeRegister(value6);
		ssPushNativeRegister(dup23);
		return 0;

	case 26:
		/* begin genLowcodeDuplicatePointer */
		
		rTop17 = NoReg;
		rResult5 = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop17 = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop17 == NoReg) {
			rTop17 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult5 = allocateRegNotConflictingWith(((rTop17 < 0) ? (((usqInt)(1)) >> (-rTop17)) : (1ULL << rTop17)));
		assert(!(((rTop17 == NoReg)
 || (rResult5 == NoReg))));
		pointerValue = rTop17;
		dup24 = rResult5;
		nativePopToReg(ssNativeTop(), pointerValue);
		ssNativePop(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, pointerValue, dup24);
		ssPushNativeRegister(pointerValue);
		ssPushNativeRegister(dup24);
		return 0;

	case 27:
		/* begin genLowcodeEffectiveAddress32 */
		
		rTop18 = (rNext13 = (rNextNext3 = (rNextNextNext2 = NoReg)));
		nativeValueIndex3 = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop18 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext13 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext13 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex3))) != NoReg) {
				rNext13 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex3));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex3))) != NoReg) {
					rNextNext3 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex3));
				}
				nativeValueIndex3 += 1;
			}
		}
		if (rNextNext3 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex3))) != NoReg) {
				rNextNext3 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex3));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex3))) != NoReg) {
					rNextNextNext2 = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex3));
				}
				nativeValueIndex3 += 1;
			}
		}
		if (rNextNextNext2 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex3))) != NoReg) {
				rNextNextNext2 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex3));
				nativeValueIndex3 += 1;
			}
		}
		if (rTop18 == NoReg) {
			nextRegisterMask3 = 0;
			if (rNext13 != NoReg) {
				/* begin registerMaskFor: */
				nextRegisterMask3 = ((rNext13 < 0) ? (((usqInt)(1)) >> (-rNext13)) : (1ULL << rNext13));
			}
			if (rNextNext3 != NoReg) {
				nextRegisterMask3 = nextRegisterMask3 | (((rNextNext3 < 0) ? (((usqInt)(1)) >> (-rNextNext3)) : (1ULL << rNextNext3)));
			}
			if (rNextNextNext2 != NoReg) {
				nextRegisterMask3 = nextRegisterMask3 | (((rNextNextNext2 < 0) ? (((usqInt)(1)) >> (-rNextNextNext2)) : (1ULL << rNextNextNext2)));
			}
			rTop18 = allocateRegNotConflictingWith(nextRegisterMask3);
		}
		if (rNext13 == NoReg) {
			/* begin registerMaskFor: */
			nextRegisterMask3 = ((rTop18 < 0) ? (((usqInt)(1)) >> (-rTop18)) : (1ULL << rTop18));
			if (rNextNext3 != NoReg) {
				nextRegisterMask3 = nextRegisterMask3 | (((rNextNext3 < 0) ? (((usqInt)(1)) >> (-rNextNext3)) : (1ULL << rNextNext3)));
			}
			if (rNextNextNext2 != NoReg) {
				nextRegisterMask3 = nextRegisterMask3 | (((rNextNextNext2 < 0) ? (((usqInt)(1)) >> (-rNextNextNext2)) : (1ULL << rNextNextNext2)));
			}
			rNext13 = allocateRegNotConflictingWith(nextRegisterMask3);
		}
		if (rNextNext3 == NoReg) {
			/* begin registerMaskFor:and: */
			nextRegisterMask3 = (1ULL << rTop18) | (1ULL << rNext13);
			if (rNextNextNext2 != NoReg) {
				nextRegisterMask3 = nextRegisterMask3 | (((rNextNextNext2 < 0) ? (((usqInt)(1)) >> (-rNextNextNext2)) : (1ULL << rNextNextNext2)));
			}
			rNextNext3 = allocateRegNotConflictingWith(nextRegisterMask3);
		}
		if (rNextNextNext2 == NoReg) {
			/* begin registerMaskFor:and:and: */
			nextRegisterMask3 = ((1ULL << rTop18) | (1ULL << rNext13)) | (1ULL << rNextNext3);
			rNextNextNext2 = allocateRegNotConflictingWith(nextRegisterMask3);
		}
		assert(!(((rTop18 == NoReg)
 || ((rNext13 == NoReg)
 || ((rNextNext3 == NoReg)
 || (rNextNextNext2 == NoReg))))));
		offset = rTop18;
		scale = rNext13;
		index = rNextNext3;
		base = rNextNextNext2;
		nativePopToReg(ssNativeTop(), offset);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), scale);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), index);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), base);
		ssNativePop(1);
		/* begin MulR:R: */
		genMulRR(backEnd, scale, index);
		/* begin AddR:R: */
		genoperandoperand(AddRR, index, base);
		/* begin AddR:R: */
		genoperandoperand(AddRR, offset, base);
		ssPushNativeRegister(base);
		return 0;

	case 28:
		/* begin genLowcodeEffectiveAddress64 */
		
		rTop19 = (rNext14 = (rNextNext4 = (rNextNextNext3 = NoReg)));
		rResult6 = NoReg;
		nativeValueIndex4 = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop19 = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext14 = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext14 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex4))) != NoReg) {
				rNext14 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex4));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex4))) != NoReg) {
					rNextNext4 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex4));
				}
				nativeValueIndex4 += 1;
			}
		}
		if (rNextNext4 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex4))) != NoReg) {
				rNextNext4 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex4));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex4))) != NoReg) {
					rNextNextNext3 = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex4));
				}
				nativeValueIndex4 += 1;
			}
		}
		if (rNextNextNext3 == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex4))) != NoReg) {
				rNextNextNext3 = nativeRegisterOrNone(ssNativeValue(nativeValueIndex4));
				nativeValueIndex4 += 1;
			}
		}
		if (rTop19 == NoReg) {
			nextRegisterMask4 = 0;
			if (rNext14 != NoReg) {
				/* begin registerMaskFor: */
				nextRegisterMask4 = ((rNext14 < 0) ? (((usqInt)(1)) >> (-rNext14)) : (1ULL << rNext14));
			}
			if (rNextNext4 != NoReg) {
				nextRegisterMask4 = nextRegisterMask4 | (((rNextNext4 < 0) ? (((usqInt)(1)) >> (-rNextNext4)) : (1ULL << rNextNext4)));
			}
			if (rNextNextNext3 != NoReg) {
				nextRegisterMask4 = nextRegisterMask4 | (((rNextNextNext3 < 0) ? (((usqInt)(1)) >> (-rNextNextNext3)) : (1ULL << rNextNextNext3)));
			}
			rTop19 = allocateRegNotConflictingWith(nextRegisterMask4);
		}
		if (rNext14 == NoReg) {
			/* begin registerMaskFor: */
			nextRegisterMask4 = ((rTop19 < 0) ? (((usqInt)(1)) >> (-rTop19)) : (1ULL << rTop19));
			if (rNextNext4 != NoReg) {
				nextRegisterMask4 = nextRegisterMask4 | (((rNextNext4 < 0) ? (((usqInt)(1)) >> (-rNextNext4)) : (1ULL << rNextNext4)));
			}
			if (rNextNextNext3 != NoReg) {
				nextRegisterMask4 = nextRegisterMask4 | (((rNextNextNext3 < 0) ? (((usqInt)(1)) >> (-rNextNextNext3)) : (1ULL << rNextNextNext3)));
			}
			rNext14 = allocateRegNotConflictingWith(nextRegisterMask4);
		}
		if (rNextNext4 == NoReg) {
			/* begin registerMaskFor:and: */
			nextRegisterMask4 = (1ULL << rTop19) | (1ULL << rNext14);
			if (rNextNextNext3 != NoReg) {
				nextRegisterMask4 = nextRegisterMask4 | (((rNextNextNext3 < 0) ? (((usqInt)(1)) >> (-rNextNextNext3)) : (1ULL << rNextNextNext3)));
			}
			rNextNext4 = allocateRegNotConflictingWith(nextRegisterMask4);
		}
		if (rNextNextNext3 == NoReg) {
			/* begin registerMaskFor:and:and: */
			nextRegisterMask4 = ((1ULL << rTop19) | (1ULL << rNext14)) | (1ULL << rNextNext4);
			rNextNextNext3 = allocateRegNotConflictingWith(nextRegisterMask4);
		}
		assert(!(((rTop19 == NoReg)
 || ((rNext14 == NoReg)
 || ((rNextNext4 == NoReg)
 || (rNextNextNext3 == NoReg))))));
		rResult6 = allocateRegNotConflictingWith((((1ULL << rTop19) | (1ULL << rNext14)) | (1ULL << rNextNext4)) | (1ULL << rNextNextNext3));
		offset1 = rTop19;
		scale1 = rNext14;
		index1 = rNextNext4;
		base1 = rNextNextNext3;
		result2 = rResult6;
		nativePopToReg(ssNativeTop(), offset1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), scale1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), index1);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), base1);
		ssNativePop(1);
		abort();
		return 0;

	case 29:
		/* begin genLowcodeEndCall */
		endHighLevelCallWithCleanup();
		return 0;

	case 30:
		/* begin genLowcodeEndCallNoCleanup */
		endHighLevelCallWithoutCleanup();
		return 0;

	case 0x1F:
		/* begin genLowcodeFloat32Add */
		
		topRegistersMask10 = 0;
		rTop20 = (rNext15 = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop20 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg10 = (rNext15 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask10 = ((reg10 < 0) ? (((usqInt)(1)) >> (-reg10)) : (1ULL << reg10));
		}
		if (rTop20 == NoReg) {
			rTop20 = allocateFloatRegNotConflictingWith(topRegistersMask10);
		}
		if (rNext15 == NoReg) {
			rNext15 = allocateFloatRegNotConflictingWith(((rTop20 < 0) ? (((usqInt)(1)) >> (-rTop20)) : (1ULL << rTop20)));
		}
		assert(!(((rTop20 == NoReg)
 || (rNext15 == NoReg))));
		second6 = rTop20;
		first6 = rNext15;
		nativePopToReg(ssNativeTop(), second6);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first6);
		ssNativePop(1);
		/* begin AddRs:Rs: */
		genoperandoperand(AddRsRs, second6, first6);
		ssPushNativeRegisterSingleFloat(first6);
		return 0;

	case 32:
		/* begin genLowcodeFloat32Div */
		
		topRegistersMask11 = 0;
		rTop21 = (rNext16 = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop21 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg11 = (rNext16 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask11 = ((reg11 < 0) ? (((usqInt)(1)) >> (-reg11)) : (1ULL << reg11));
		}
		if (rTop21 == NoReg) {
			rTop21 = allocateFloatRegNotConflictingWith(topRegistersMask11);
		}
		if (rNext16 == NoReg) {
			rNext16 = allocateFloatRegNotConflictingWith(((rTop21 < 0) ? (((usqInt)(1)) >> (-rTop21)) : (1ULL << rTop21)));
		}
		assert(!(((rTop21 == NoReg)
 || (rNext16 == NoReg))));
		second7 = rTop21;
		first7 = rNext16;
		nativePopToReg(ssNativeTop(), second7);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first7);
		ssNativePop(1);
		/* begin DivRs:Rs: */
		genoperandoperand(DivRsRs, second7, first7);
		ssPushNativeRegisterSingleFloat(first7);
		return 0;

	case 33:
		/* begin genLowcodeFloat32Equal */
		
		topRegistersMask12 = 0;
		frTop2 = (frNext = NoReg);
		rResult7 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop2 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg12 = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask12 = ((reg12 < 0) ? (((usqInt)(1)) >> (-reg12)) : (1ULL << reg12));
		}
		if (frTop2 == NoReg) {
			frTop2 = allocateFloatRegNotConflictingWith(topRegistersMask12);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop2 < 0) ? (((usqInt)(1)) >> (-frTop2)) : (1ULL << frTop2)));
		}
		rResult7 = allocateRegNotConflictingWith(0);
		assert(!(((frTop2 == NoReg)
 || ((frNext == NoReg)
 || (rResult7 == NoReg)))));
		second8 = frTop2;
		first8 = frNext;
		value7 = rResult7;
		nativePopToReg(ssNativeTop(), second8);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first8);
		ssNativePop(1);
		/* begin CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second8, first8);

		/* True result */
		falseJump = gJumpFPNotEqual(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value7);
		/* begin Jump: */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value7);
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value7);
		return 0;

	case 34:
		/* begin genLowcodeFloat32Great */
		
		topRegistersMask13 = 0;
		frTop3 = (frNext1 = NoReg);
		rResult8 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop3 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg13 = (frNext1 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask13 = ((reg13 < 0) ? (((usqInt)(1)) >> (-reg13)) : (1ULL << reg13));
		}
		if (frTop3 == NoReg) {
			frTop3 = allocateFloatRegNotConflictingWith(topRegistersMask13);
		}
		if (frNext1 == NoReg) {
			frNext1 = allocateFloatRegNotConflictingWith(((frTop3 < 0) ? (((usqInt)(1)) >> (-frTop3)) : (1ULL << frTop3)));
		}
		rResult8 = allocateRegNotConflictingWith(0);
		assert(!(((frTop3 == NoReg)
 || ((frNext1 == NoReg)
 || (rResult8 == NoReg)))));
		second9 = frTop3;
		first9 = frNext1;
		value8 = rResult8;
		nativePopToReg(ssNativeTop(), second9);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first9);
		ssNativePop(1);
		/* begin CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second9, first9);

		/* True result */
		falseJump1 = gJumpFPLessOrEqual(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value8);
		/* begin Jump: */
		contJump1 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value8);
		jmpTarget(contJump1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value8);
		return 0;

	case 35:
		/* begin genLowcodeFloat32GreatEqual */
		
		topRegistersMask14 = 0;
		frTop4 = (frNext2 = NoReg);
		rResult9 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop4 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg14 = (frNext2 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask14 = ((reg14 < 0) ? (((usqInt)(1)) >> (-reg14)) : (1ULL << reg14));
		}
		if (frTop4 == NoReg) {
			frTop4 = allocateFloatRegNotConflictingWith(topRegistersMask14);
		}
		if (frNext2 == NoReg) {
			frNext2 = allocateFloatRegNotConflictingWith(((frTop4 < 0) ? (((usqInt)(1)) >> (-frTop4)) : (1ULL << frTop4)));
		}
		rResult9 = allocateRegNotConflictingWith(0);
		assert(!(((frTop4 == NoReg)
 || ((frNext2 == NoReg)
 || (rResult9 == NoReg)))));
		second10 = frTop4;
		first10 = frNext2;
		value9 = rResult9;
		nativePopToReg(ssNativeTop(), second10);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first10);
		ssNativePop(1);
		/* begin CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second10, first10);

		/* True result */
		falseJump2 = gJumpFPLess(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value9);
		/* begin Jump: */
		contJump2 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump2, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value9);
		jmpTarget(contJump2, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value9);
		return 0;

	case 36:
		/* begin genLowcodeFloat32Less */
		
		topRegistersMask15 = 0;
		frTop5 = (frNext3 = NoReg);
		rResult10 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop5 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg15 = (frNext3 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask15 = ((reg15 < 0) ? (((usqInt)(1)) >> (-reg15)) : (1ULL << reg15));
		}
		if (frTop5 == NoReg) {
			frTop5 = allocateFloatRegNotConflictingWith(topRegistersMask15);
		}
		if (frNext3 == NoReg) {
			frNext3 = allocateFloatRegNotConflictingWith(((frTop5 < 0) ? (((usqInt)(1)) >> (-frTop5)) : (1ULL << frTop5)));
		}
		rResult10 = allocateRegNotConflictingWith(0);
		assert(!(((frTop5 == NoReg)
 || ((frNext3 == NoReg)
 || (rResult10 == NoReg)))));
		second11 = frTop5;
		first11 = frNext3;
		value10 = rResult10;
		nativePopToReg(ssNativeTop(), second11);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first11);
		ssNativePop(1);
		/* begin CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second11, first11);

		/* True result */
		falseJump3 = gJumpFPGreaterOrEqual(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value10);
		/* begin Jump: */
		contJump3 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump3, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value10);
		jmpTarget(contJump3, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value10);
		return 0;

	case 37:
		/* begin genLowcodeFloat32LessEqual */
		
		topRegistersMask16 = 0;
		frTop6 = (frNext4 = NoReg);
		rResult12 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop6 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg16 = (frNext4 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask16 = ((reg16 < 0) ? (((usqInt)(1)) >> (-reg16)) : (1ULL << reg16));
		}
		if (frTop6 == NoReg) {
			frTop6 = allocateFloatRegNotConflictingWith(topRegistersMask16);
		}
		if (frNext4 == NoReg) {
			frNext4 = allocateFloatRegNotConflictingWith(((frTop6 < 0) ? (((usqInt)(1)) >> (-frTop6)) : (1ULL << frTop6)));
		}
		rResult12 = allocateRegNotConflictingWith(0);
		assert(!(((frTop6 == NoReg)
 || ((frNext4 == NoReg)
 || (rResult12 == NoReg)))));
		second12 = frTop6;
		first12 = frNext4;
		value11 = rResult12;
		nativePopToReg(ssNativeTop(), second12);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first12);
		ssNativePop(1);
		/* begin CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second12, first12);

		/* True result */
		falseJump4 = gJumpFPGreater(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value11);
		/* begin Jump: */
		contJump4 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump4, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value11);
		jmpTarget(contJump4, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value11);
		return 0;

	case 38:
		/* begin genLowcodeFloat32Mul */
		
		topRegistersMask17 = 0;
		rTop22 = (rNext17 = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop22 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg17 = (rNext17 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask17 = ((reg17 < 0) ? (((usqInt)(1)) >> (-reg17)) : (1ULL << reg17));
		}
		if (rTop22 == NoReg) {
			rTop22 = allocateFloatRegNotConflictingWith(topRegistersMask17);
		}
		if (rNext17 == NoReg) {
			rNext17 = allocateFloatRegNotConflictingWith(((rTop22 < 0) ? (((usqInt)(1)) >> (-rTop22)) : (1ULL << rTop22)));
		}
		assert(!(((rTop22 == NoReg)
 || (rNext17 == NoReg))));
		second13 = rTop22;
		first13 = rNext17;
		nativePopToReg(ssNativeTop(), second13);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first13);
		ssNativePop(1);
		/* begin MulRs:Rs: */
		genoperandoperand(MulRsRs, second13, first13);
		ssPushNativeRegisterSingleFloat(first13);
		return 0;

	case 39:
		/* begin genLowcodeFloat32Neg */
		
		frTop7 = NoReg;

		/* Float argument */
		frResult2 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop7 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop7 == NoReg) {
			frTop7 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult2 = allocateFloatRegNotConflictingWith(((frTop7 < 0) ? (((usqInt)(1)) >> (-frTop7)) : (1ULL << frTop7)));
		assert(!(((frTop7 == NoReg)
 || (frResult2 == NoReg))));
		value12 = frTop7;
		result3 = frResult2;
		nativePopToReg(ssNativeTop(), value12);
		ssNativePop(1);
		/* begin XorRs:Rs: */
		genoperandoperand(XorRsRs, result3, result3);
		/* begin SubRs:Rs: */
		genoperandoperand(SubRsRs, value12, result3);
		ssPushNativeRegisterSingleFloat(result3);
		return 0;

	case 40:
		/* begin genLowcodeFloat32NotEqual */
		
		topRegistersMask18 = 0;
		frTop8 = (frNext5 = NoReg);
		rResult13 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop8 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg18 = (frNext5 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask18 = ((reg18 < 0) ? (((usqInt)(1)) >> (-reg18)) : (1ULL << reg18));
		}
		if (frTop8 == NoReg) {
			frTop8 = allocateFloatRegNotConflictingWith(topRegistersMask18);
		}
		if (frNext5 == NoReg) {
			frNext5 = allocateFloatRegNotConflictingWith(((frTop8 < 0) ? (((usqInt)(1)) >> (-frTop8)) : (1ULL << frTop8)));
		}
		rResult13 = allocateRegNotConflictingWith(0);
		assert(!(((frTop8 == NoReg)
 || ((frNext5 == NoReg)
 || (rResult13 == NoReg)))));
		second14 = frTop8;
		first14 = frNext5;
		value13 = rResult13;
		nativePopToReg(ssNativeTop(), second14);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first14);
		ssNativePop(1);
		/* begin CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second14, first14);

		/* True result */
		falseJump5 = gJumpFPEqual(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value13);
		/* begin Jump: */
		contJump5 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump5, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value13);
		jmpTarget(contJump5, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value13);
		return 0;

	case 41:
		/* begin genLowcodeFloat32Sqrt */
		
		topRegistersMask19 = 0;
		frTop9 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop9 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop9 == NoReg) {
			frTop9 = allocateFloatRegNotConflictingWith(topRegistersMask19);
		}
		assert(!((frTop9 == NoReg)));
		value14 = frTop9;
		nativePopToReg(ssNativeTop(), value14);
		ssNativePop(1);
		/* begin SqrtRs: */
		genoperand(SqrtRs, value14);
		ssPushNativeRegisterSingleFloat(value14);
		return 0;

	case 42:
		/* begin genLowcodeFloat32Sub */
		
		topRegistersMask20 = 0;
		rTop23 = (rNext18 = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop23 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg19 = (rNext18 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask20 = ((reg19 < 0) ? (((usqInt)(1)) >> (-reg19)) : (1ULL << reg19));
		}
		if (rTop23 == NoReg) {
			rTop23 = allocateFloatRegNotConflictingWith(topRegistersMask20);
		}
		if (rNext18 == NoReg) {
			rNext18 = allocateFloatRegNotConflictingWith(((rTop23 < 0) ? (((usqInt)(1)) >> (-rTop23)) : (1ULL << rTop23)));
		}
		assert(!(((rTop23 == NoReg)
 || (rNext18 == NoReg))));
		second15 = rTop23;
		first15 = rNext18;
		nativePopToReg(ssNativeTop(), second15);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first15);
		ssNativePop(1);
		/* begin SubRs:Rs: */
		genoperandoperand(SubRsRs, second15, first15);
		ssPushNativeRegisterSingleFloat(first15);
		return 0;

	case 43:
		/* begin genLowcodeFloat32ToFloat64 */
		
		topRegistersMask21 = 0;
		frTop10 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop10 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop10 == NoReg) {
			frTop10 = allocateFloatRegNotConflictingWith(topRegistersMask21);
		}
		assert(!((frTop10 == NoReg)));
		singleFloatValue = frTop10;
		nativePopToReg(ssNativeTop(), singleFloatValue);
		ssNativePop(1);
		/* begin ConvertRs:Rd: */
		genoperandoperand(ConvertRsRd, singleFloatValue, singleFloatValue);
		ssPushNativeRegisterDoubleFloat(singleFloatValue);
		return 0;

	case 44:
		/* begin genLowcodeFloat32ToInt32 */
		
		frTop11 = NoReg;

		/* Float argument */
		rResult14 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop11 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop11 == NoReg) {
			frTop11 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult14 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop11 == NoReg)
 || (rResult14 == NoReg))));
		value15 = frTop11;
		result4 = rResult14;
		nativePopToReg(ssNativeTop(), value15);
		ssNativePop(1);
		/* begin ConvertRs:R: */
		genoperandoperand(ConvertRsR, value15, result4);
		ssPushNativeRegister(result4);
		return 0;

	case 45:
		/* begin genLowcodeFloat32ToInt64 */
		
		frTop12 = NoReg;

		/* Float argument */
		rResult15 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop12 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop12 == NoReg) {
			frTop12 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult15 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop12 == NoReg)
 || (rResult15 == NoReg))));
		value16 = frTop12;
		result5 = rResult15;
		nativePopToReg(ssNativeTop(), value16);
		ssNativePop(1);
		abort();
		return 0;

	case 46:
		/* begin genLowcodeFloat32ToUInt32 */
		
		frTop13 = NoReg;

		/* Float argument */
		rResult16 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop13 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop13 == NoReg) {
			frTop13 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult16 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop13 == NoReg)
 || (rResult16 == NoReg))));
		value17 = frTop13;
		result6 = rResult16;
		nativePopToReg(ssNativeTop(), value17);
		ssNativePop(1);
		/* begin ConvertRs:R: */
		genoperandoperand(ConvertRsR, value17, result6);
		ssPushNativeRegister(result6);
		return 0;

	case 47:
		/* begin genLowcodeFloat32ToUInt64 */
		
		frTop14 = NoReg;

		/* Float argument */
		rResult17 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop14 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop14 == NoReg) {
			frTop14 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult17 = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop14 == NoReg)
 || (rResult17 == NoReg))));
		value18 = frTop14;
		result7 = rResult17;
		nativePopToReg(ssNativeTop(), value18);
		ssNativePop(1);
		abort();
		return 0;

	case 48:
		/* begin genLowcodeFloat64Add */
		
		topRegistersMask22 = 0;
		rTop24 = (rNext19 = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop24 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg20 = (rNext19 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask22 = ((reg20 < 0) ? (((usqInt)(1)) >> (-reg20)) : (1ULL << reg20));
		}
		if (rTop24 == NoReg) {
			rTop24 = allocateFloatRegNotConflictingWith(topRegistersMask22);
		}
		if (rNext19 == NoReg) {
			rNext19 = allocateFloatRegNotConflictingWith(((rTop24 < 0) ? (((usqInt)(1)) >> (-rTop24)) : (1ULL << rTop24)));
		}
		assert(!(((rTop24 == NoReg)
 || (rNext19 == NoReg))));
		second16 = rTop24;
		first16 = rNext19;
		nativePopToReg(ssNativeTop(), second16);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first16);
		ssNativePop(1);
		/* begin AddRd:Rd: */
		genoperandoperand(AddRdRd, second16, first16);
		ssPushNativeRegisterDoubleFloat(first16);
		return 0;

	case 49:
		/* begin genLowcodeFloat64Div */
		
		topRegistersMask23 = 0;
		rTop25 = (rNext20 = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop25 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg21 = (rNext20 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask23 = ((reg21 < 0) ? (((usqInt)(1)) >> (-reg21)) : (1ULL << reg21));
		}
		if (rTop25 == NoReg) {
			rTop25 = allocateFloatRegNotConflictingWith(topRegistersMask23);
		}
		if (rNext20 == NoReg) {
			rNext20 = allocateFloatRegNotConflictingWith(((rTop25 < 0) ? (((usqInt)(1)) >> (-rTop25)) : (1ULL << rTop25)));
		}
		assert(!(((rTop25 == NoReg)
 || (rNext20 == NoReg))));
		second17 = rTop25;
		first17 = rNext20;
		nativePopToReg(ssNativeTop(), second17);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first17);
		ssNativePop(1);
		/* begin DivRd:Rd: */
		genoperandoperand(DivRdRd, second17, first17);
		ssPushNativeRegisterDoubleFloat(first17);
		return 0;

	case 50:
		/* begin genLowcodeFloat64Equal */
		
		topRegistersMask24 = 0;
		frTop15 = (frNext6 = NoReg);
		rResult18 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop15 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg22 = (frNext6 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask24 = ((reg22 < 0) ? (((usqInt)(1)) >> (-reg22)) : (1ULL << reg22));
		}
		if (frTop15 == NoReg) {
			frTop15 = allocateFloatRegNotConflictingWith(topRegistersMask24);
		}
		if (frNext6 == NoReg) {
			frNext6 = allocateFloatRegNotConflictingWith(((frTop15 < 0) ? (((usqInt)(1)) >> (-frTop15)) : (1ULL << frTop15)));
		}
		rResult18 = allocateRegNotConflictingWith(0);
		assert(!(((frTop15 == NoReg)
 || ((frNext6 == NoReg)
 || (rResult18 == NoReg)))));
		second18 = frTop15;
		first18 = frNext6;
		value19 = rResult18;
		nativePopToReg(ssNativeTop(), second18);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first18);
		ssNativePop(1);
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second18, first18);

		/* True result */
		falseJump6 = gJumpFPNotEqual(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value19);
		/* begin Jump: */
		contJump6 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump6, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value19);
		jmpTarget(contJump6, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value19);
		return 0;

	case 51:
		/* begin genLowcodeFloat64Great */
		
		topRegistersMask25 = 0;
		frTop16 = (frNext7 = NoReg);
		rResult19 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop16 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg23 = (frNext7 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask25 = ((reg23 < 0) ? (((usqInt)(1)) >> (-reg23)) : (1ULL << reg23));
		}
		if (frTop16 == NoReg) {
			frTop16 = allocateFloatRegNotConflictingWith(topRegistersMask25);
		}
		if (frNext7 == NoReg) {
			frNext7 = allocateFloatRegNotConflictingWith(((frTop16 < 0) ? (((usqInt)(1)) >> (-frTop16)) : (1ULL << frTop16)));
		}
		rResult19 = allocateRegNotConflictingWith(0);
		assert(!(((frTop16 == NoReg)
 || ((frNext7 == NoReg)
 || (rResult19 == NoReg)))));
		second19 = frTop16;
		first19 = frNext7;
		value20 = rResult19;
		nativePopToReg(ssNativeTop(), second19);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first19);
		ssNativePop(1);
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second19, first19);

		/* True result */
		falseJump7 = gJumpFPLessOrEqual(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value20);
		/* begin Jump: */
		contJump7 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump7, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value20);
		jmpTarget(contJump7, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value20);
		return 0;

	case 52:
		/* begin genLowcodeFloat64GreatEqual */
		
		topRegistersMask26 = 0;
		frTop17 = (frNext8 = NoReg);
		rResult20 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop17 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg24 = (frNext8 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask26 = ((reg24 < 0) ? (((usqInt)(1)) >> (-reg24)) : (1ULL << reg24));
		}
		if (frTop17 == NoReg) {
			frTop17 = allocateFloatRegNotConflictingWith(topRegistersMask26);
		}
		if (frNext8 == NoReg) {
			frNext8 = allocateFloatRegNotConflictingWith(((frTop17 < 0) ? (((usqInt)(1)) >> (-frTop17)) : (1ULL << frTop17)));
		}
		rResult20 = allocateRegNotConflictingWith(0);
		assert(!(((frTop17 == NoReg)
 || ((frNext8 == NoReg)
 || (rResult20 == NoReg)))));
		second20 = frTop17;
		first20 = frNext8;
		value21 = rResult20;
		nativePopToReg(ssNativeTop(), second20);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first20);
		ssNativePop(1);
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second20, first20);

		/* True result */
		falseJump8 = gJumpFPLess(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value21);
		/* begin Jump: */
		contJump8 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump8, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value21);
		jmpTarget(contJump8, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value21);
		return 0;

	case 53:
		/* begin genLowcodeFloat64Less */
		
		topRegistersMask27 = 0;
		frTop18 = (frNext9 = NoReg);
		rResult22 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop18 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg25 = (frNext9 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask27 = ((reg25 < 0) ? (((usqInt)(1)) >> (-reg25)) : (1ULL << reg25));
		}
		if (frTop18 == NoReg) {
			frTop18 = allocateFloatRegNotConflictingWith(topRegistersMask27);
		}
		if (frNext9 == NoReg) {
			frNext9 = allocateFloatRegNotConflictingWith(((frTop18 < 0) ? (((usqInt)(1)) >> (-frTop18)) : (1ULL << frTop18)));
		}
		rResult22 = allocateRegNotConflictingWith(0);
		assert(!(((frTop18 == NoReg)
 || ((frNext9 == NoReg)
 || (rResult22 == NoReg)))));
		second21 = frTop18;
		first21 = frNext9;
		value22 = rResult22;
		nativePopToReg(ssNativeTop(), second21);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first21);
		ssNativePop(1);
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second21, first21);

		/* True result */
		falseJump9 = gJumpFPGreaterOrEqual(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value22);
		/* begin Jump: */
		contJump9 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump9, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value22);
		jmpTarget(contJump9, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value22);
		return 0;

	case 54:
		/* begin genLowcodeFloat64LessEqual */
		
		topRegistersMask28 = 0;
		frTop19 = (frNext10 = NoReg);
		rResult23 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop19 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg26 = (frNext10 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask28 = ((reg26 < 0) ? (((usqInt)(1)) >> (-reg26)) : (1ULL << reg26));
		}
		if (frTop19 == NoReg) {
			frTop19 = allocateFloatRegNotConflictingWith(topRegistersMask28);
		}
		if (frNext10 == NoReg) {
			frNext10 = allocateFloatRegNotConflictingWith(((frTop19 < 0) ? (((usqInt)(1)) >> (-frTop19)) : (1ULL << frTop19)));
		}
		rResult23 = allocateRegNotConflictingWith(0);
		assert(!(((frTop19 == NoReg)
 || ((frNext10 == NoReg)
 || (rResult23 == NoReg)))));
		second22 = frTop19;
		first22 = frNext10;
		value23 = rResult23;
		nativePopToReg(ssNativeTop(), second22);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first22);
		ssNativePop(1);
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second22, first22);

		/* True result */
		falseJump10 = gJumpFPGreater(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value23);
		/* begin Jump: */
		contJump10 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump10, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value23);
		jmpTarget(contJump10, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value23);
		return 0;

	case 55:
		/* begin genLowcodeFloat64Mul */
		
		topRegistersMask29 = 0;
		rTop26 = (rNext21 = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop26 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg27 = (rNext21 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask29 = ((reg27 < 0) ? (((usqInt)(1)) >> (-reg27)) : (1ULL << reg27));
		}
		if (rTop26 == NoReg) {
			rTop26 = allocateFloatRegNotConflictingWith(topRegistersMask29);
		}
		if (rNext21 == NoReg) {
			rNext21 = allocateFloatRegNotConflictingWith(((rTop26 < 0) ? (((usqInt)(1)) >> (-rTop26)) : (1ULL << rTop26)));
		}
		assert(!(((rTop26 == NoReg)
 || (rNext21 == NoReg))));
		second23 = rTop26;
		first23 = rNext21;
		nativePopToReg(ssNativeTop(), second23);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first23);
		ssNativePop(1);
		/* begin MulRd:Rd: */
		genoperandoperand(MulRdRd, second23, first23);
		ssPushNativeRegisterDoubleFloat(first23);
		return 0;

	case 56:
		/* begin genLowcodeFloat64Neg */
		
		frTop20 = NoReg;

		/* Float argument */
		frResult3 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop20 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop20 == NoReg) {
			frTop20 = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult3 = allocateFloatRegNotConflictingWith(((frTop20 < 0) ? (((usqInt)(1)) >> (-frTop20)) : (1ULL << frTop20)));
		assert(!(((frTop20 == NoReg)
 || (frResult3 == NoReg))));
		value24 = frTop20;
		result8 = frResult3;
		nativePopToReg(ssNativeTop(), value24);
		ssNativePop(1);
		/* begin XorRd:Rd: */
		genoperandoperand(XorRdRd, result8, result8);
		/* begin SubRd:Rd: */
		genoperandoperand(SubRdRd, value24, result8);
		ssPushNativeRegisterDoubleFloat(result8);
		return 0;

	case 57:
		/* begin genLowcodeFloat64NotEqual */
		
		topRegistersMask30 = 0;
		frTop21 = (frNext11 = NoReg);
		rResult24 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop21 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg28 = (frNext11 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask30 = ((reg28 < 0) ? (((usqInt)(1)) >> (-reg28)) : (1ULL << reg28));
		}
		if (frTop21 == NoReg) {
			frTop21 = allocateFloatRegNotConflictingWith(topRegistersMask30);
		}
		if (frNext11 == NoReg) {
			frNext11 = allocateFloatRegNotConflictingWith(((frTop21 < 0) ? (((usqInt)(1)) >> (-frTop21)) : (1ULL << frTop21)));
		}
		rResult24 = allocateRegNotConflictingWith(0);
		assert(!(((frTop21 == NoReg)
 || ((frNext11 == NoReg)
 || (rResult24 == NoReg)))));
		second24 = frTop21;
		first24 = frNext11;
		value25 = rResult24;
		nativePopToReg(ssNativeTop(), second24);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first24);
		ssNativePop(1);
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second24, first24);

		/* True result */
		falseJump11 = gJumpFPEqual(0);
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 1, value25);
		/* begin Jump: */
		contJump11 = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump11, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, 0, value25);
		jmpTarget(contJump11, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value25);
		return 0;

	case 58:
		/* begin genLowcodeFloat64Sqrt */
		
		topRegistersMask31 = 0;
		frTop22 = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop22 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop22 == NoReg) {
			frTop22 = allocateFloatRegNotConflictingWith(topRegistersMask31);
		}
		assert(!((frTop22 == NoReg)));
		value26 = frTop22;
		nativePopToReg(ssNativeTop(), value26);
		ssNativePop(1);
		/* begin SqrtRd: */
		genoperand(SqrtRd, value26);
		ssPushNativeRegisterDoubleFloat(value26);
		return 0;

	case 59:
		/* begin genLowcodeFloat64Sub */
		
		topRegistersMask32 = 0;
		rTop27 = (rNext22 = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop27 = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			/* begin registerMaskFor: */
			reg29 = (rNext22 = nativeFloatRegisterOrNone(ssNativeValue(1)));
			topRegistersMask32 = ((reg29 < 0) ? (((usqInt)(1)) >> (-reg29)) : (1ULL << reg29));
		}
		if (rTop27 == NoReg) {
			rTop27 = allocateFloatRegNotConflictingWith(topRegistersMask32);
		}
		if (rNext22 == NoReg) {
			rNext22 = allocateFloatRegNotConflictingWith(((rTop27 < 0) ? (((usqInt)(1)) >> (-rTop27)) : (1ULL << rTop27)));
		}
		assert(!(((rTop27 == NoReg)
 || (rNext22 == NoReg))));
		second25 = rTop27;
		first25 = rNext22;
		nativePopToReg(ssNativeTop(), second25);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first25);
		ssNativePop(1);
		/* begin SubRd:Rd: */
		genoperandoperand(SubRdRd, second25, first25);
		ssPushNativeRegisterDoubleFloat(first25);
		return 0;

	default:
		return genLowcodeUnaryInlinePrimitive2(prim);

	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#genMarshalledSend:numArgs:sendTable: */
static sqInt NoDbgRegParms
genMarshalledSendnumArgssendTable(sqInt selectorIndex, sqInt numArgs, sqInt *sendTable)
{
    sqInt annotation;
    AbstractInstruction *instruction;

	assert(needsFrame);
	/* begin annotationForSendTable: */
	if (sendTable == ordinarySendTrampolines) {
		annotation = IsSendCall;
		goto l3;
	}
	if (sendTable == directedSuperSendTrampolines) {
		annotation = IsDirectedSuperSend;
		goto l3;
	}
	if (sendTable == directedSuperBindingSendTrampolines) {
		annotation = IsDirectedSuperBindingSend;
		goto l3;
	}
	assert(sendTable == superSendTrampolines);
	annotation = IsSuperSend;
	l3:	/* end annotationForSendTable: */;
	if ((annotation == IsSuperSend)
	 || (((annotation >= IsDirectedSuperSend) && (annotation <= IsDirectedSuperBindingSend)))) {
		/* begin genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		instruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(ReceiverResultReg, TempReg, instruction, 0);
	}
	if (numArgs >= (NumSendTrampolines - 1)) {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, numArgs, SendNumArgsReg);
	}
	if (((annotation >= IsDirectedSuperSend) && (annotation <= IsDirectedSuperBindingSend))) {
		/* begin genMoveConstant:R: */
		if (shouldAnnotateObjectReference(tempOop)) {
			annotateobjRef(checkLiteralforInstruction(tempOop, genoperandoperand(MoveCwR, tempOop, TempReg)), tempOop);
		}
		else {
			/* begin MoveCq:R: */
			genoperandoperand(MoveCqR, tempOop, TempReg);
		}
	}
	genLoadInlineCacheWithSelector(selectorIndex);
	((genoperand(Call, sendTable[((numArgs < (NumSendTrampolines - 1)) ? numArgs : (NumSendTrampolines - 1))]))->annotation = annotation);
	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	return ssPushRegister(ReceiverResultReg);
}


/*	Generate the abort for a method. This abort performs either a call of
	ceSICMiss: to handle a single-in-line cache miss or a call of
	ceStackOverflow: to handle a
	stack overflow. It distinguishes the two by testing ResultReceiverReg. If
	the register is zero then this is a stack-overflow because a) the receiver
	has already
	been pushed and so can be set to zero before calling the abort, and b) the
	receiver must always contain an object (and hence be non-zero) on SIC
	miss.  */

	/* StackToRegisterMappingCogit>>#genMethodAbortTrampolineFor: */
static usqInt NoDbgRegParms
genMethodAbortTrampolineFor(sqInt numArgs)
{
    AbstractInstruction *jumpSICMiss;

	zeroOpcodeIndex();
	/* begin CmpCq:R: */
	genoperandoperand(CmpCqR, 0, ReceiverResultReg);
	/* begin JumpNonZero: */
	jumpSICMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceStackOverflow, 1, SendNumArgsReg, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg);
	jmpTarget(jumpSICMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genPushRegisterArgsForAbortMissNumArgs(backEnd, numArgs);
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceSICMiss, trampolineNamenumRegArgs("ceMethodAbort", numArgs), 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 1);
}


/*	Generate the abort for a PIC. This abort performs either a call of
	ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged
	target or a call of ceMNUFromPICMNUMethod:receiver: to handle an
	MNU dispatch in a closed PIC. It distinguishes the two by testing
	ClassReg. If the register is zero then this is an MNU. */

	/* StackToRegisterMappingCogit>>#genPICAbortTrampolineFor: */
static usqInt NoDbgRegParms
genPICAbortTrampolineFor(sqInt numArgs)
{
	zeroOpcodeIndex();
	genPushRegisterArgsForAbortMissNumArgs(backEnd, numArgs);
	return genInnerPICAbortTrampoline(trampolineNamenumRegArgs("cePICAbort", numArgs));
}

	/* StackToRegisterMappingCogit>>#genPICMissTrampolineFor: */
static usqInt NoDbgRegParms
genPICMissTrampolineFor(sqInt numArgs)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCPICMissreceiver, trampolineNamenumRegArgs("cePICMiss", numArgs), 2, ClassReg, ReceiverResultReg, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 1);
	return startAddress;
}

	/* StackToRegisterMappingCogit>>#genPopStackBytecode */
static sqInt
genPopStackBytecode(void)
{
    AbstractInstruction *anInstruction;

	if (((ssTop())->spilled)) {
		/* begin AddCq:R: */
		
		BytesPerWord;
		anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
	}
	ssPop(1);
	return 0;
}


/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive. */
/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive.
	Override to push the register args first. */

	/* StackToRegisterMappingCogit>>#genPrimitiveClosureValue */
static sqInt
genPrimitiveClosureValue(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpFail1;
    AbstractInstruction *jumpFail2;
    AbstractInstruction *jumpFail3;
    AbstractInstruction *jumpFail4;
    AbstractInstruction *jumpFailNArgs;
    sqInt offset;
    void (*primitiveRoutine)(void);
    sqInt quickConstant;
    sqInt result;

	genPushRegisterArgs();
	genLoadSlotsourceRegdestReg(ClosureNumArgsIndex, ReceiverResultReg, TempReg);
	/* begin CmpCq:R: */
	
	(((usqInt)methodOrBlockNumArgs << 3) | 1);
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)methodOrBlockNumArgs << 3) | 1), TempReg);
	/* begin JumpNonZero: */
	jumpFailNArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, ClassReg);
	jumpFail1 = genJumpImmediate(ClassReg);
	genGetCompactClassIndexNonImmOfinto(ClassReg, TempReg);
	genCmpClassMethodContextCompactIndexR(TempReg);
	/* begin JumpNonZero: */
	jumpFail2 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(MethodIndex, ClassReg, SendNumArgsReg);
	jumpFail3 = genJumpImmediate(SendNumArgsReg);
	genGetFormatOfinto(SendNumArgsReg, TempReg);
	/* begin CmpCq:R: */
	quickConstant = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpLess: */
	jumpFail4 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	/* begin MoveM16:r:R: */
	offset = offsetof(CogMethod, blockEntryOffset);
	genoperandoperandoperand(MoveM16rR, offset, ClassReg, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, ClassReg, TempReg);
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, null);
	if (primitiveRoutine == primitiveClosureValueNoContextSwitch) {
		if (blockNoContextSwitchOffset == null) {
			return NotFullyInitialized;
		}
		/* begin SubCq:R: */
		genoperandoperand(SubCqR, blockNoContextSwitchOffset, TempReg);
	}
	/* begin JumpR: */
	genoperand(JumpR, TempReg);
	jmpTarget(jumpBCMethod, jmpTarget(jumpFail1, jmpTarget(jumpFail2, jmpTarget(jumpFail3, jmpTarget(jumpFail4, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	if (((result = compileInterpreterPrimitiveflags(primitiveRoutine, primitivePropertyFlagsnumArgs(primitiveIndex, methodOrBlockNumArgs)))) < 0) {
		return result;
	}
	jmpTarget(jumpFailNArgs, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive. */
/*	Override to push the register args first. */

	/* StackToRegisterMappingCogit>>#genPrimitiveFullClosureValue */
static sqInt
genPrimitiveFullClosureValue(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpFail4;
    AbstractInstruction *jumpFailImmediateMethod;
    AbstractInstruction *jumpFailNArgs;
    void (*primitiveRoutine)(void);
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt result;

	genPushRegisterArgs();
	genLoadSlotsourceRegdestReg(ClosureNumArgsIndex, ReceiverResultReg, TempReg);
	/* begin CmpCq:R: */
	
	(((usqInt)methodOrBlockNumArgs << 3) | 1);
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)methodOrBlockNumArgs << 3) | 1), TempReg);
	/* begin JumpNonZero: */
	jumpFailNArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(FullClosureCompiledBlockIndex, ReceiverResultReg, SendNumArgsReg);
	jumpFailImmediateMethod = genJumpImmediate(SendNumArgsReg);
	genGetFormatOfinto(SendNumArgsReg, TempReg);
	/* begin CmpCq:R: */
	quickConstant = firstCompiledMethodFormat();
	genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpLess: */
	jumpFail4 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, null);
	/* begin AddCq:R: */
	quickConstant1 = (primitiveRoutine == primitiveFullClosureValueNoContextSwitch
		? fullBlockNoContextSwitchEntryOffset()
		: fullBlockEntryOffset());
	genoperandoperand(AddCqR, quickConstant1, ClassReg);
	/* begin JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpBCMethod, jmpTarget(jumpFailImmediateMethod, jmpTarget(jumpFail4, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	if (((result = compileInterpreterPrimitiveflags(primitiveRoutine, primitivePropertyFlagsnumArgs(primitiveIndex, methodOrBlockNumArgs)))) < 0) {
		return result;
	}
	jmpTarget(jumpFailNArgs, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	Generate an in-line perform primitive. The lookup code requires the
	selector to be in Arg0Reg.
	adjustArgumentsForPerform: adjusts the arguments once
	genLookupForPerformNumArgs: has generated the code for the lookup. */

	/* StackToRegisterMappingCogit>>#genPrimitivePerform */
static sqInt
genPrimitivePerform(void)
{
    sqInt offset;

	if (methodOrBlockNumArgs > (numRegArgs())) {
		/* begin MoveMw:r:R: */
		offset = (methodOrBlockNumArgs) * BytesPerWord;
		genoperandoperandoperand(MoveMwrR, offset, SPReg, Arg0Reg);
	}
	return genLookupForPerformNumArgs(methodOrBlockNumArgs);
}


/*	Generate an in-line perform:withArguments: primitive. The lookup code
	requires the selector to be in Arg0Reg
	and the array to be in Arg1Reg. The primitive will only handle cases 0 to
	numRegArgs. Is it worth it you ask?
	Here are arguemnt count requencies for a short run of Croquet/Virtend
	which show that even for V3, with only
	one rtegister arg, it very much is (but we wimp out on V3 cuz of the
	complexity of checking the Array):
	[0] = 253743		52.5%
	[1] = 116117		24%/76.5%
	[2] = 99876		20.7%/97.2%
	[3] = 12837		2.7%/99.9%
	[4] = 209
	[5] = 84
	[6] = 2
	[7] = 313
	[8] = 0
	[9] = 0
	[10] = 0
	[11] = 1
	[12] = 0
	[13] = 0
	[14] = 0
	[15] = 0 */

	/* StackToRegisterMappingCogit>>#genPrimitivePerformWithArguments */
static sqInt
genPrimitivePerformWithArguments(void)
{
    AbstractInstruction *anInstruction;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBadNumArgs1;
    AbstractInstruction *jumpBadNumArgs2;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpImmArray;
    AbstractInstruction *jumpInterpret;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt reg;

	/* begin genLookupForPerformWithArguments */
	jumpImmArray = genJumpImmediate(Arg1Reg);
	genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, SendNumArgsReg, 0);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	if (!(((((usqInt)(methodCacheAddress()))) >= codeBase)
		 && ((((usqInt)(methodCacheAddress()))) < limitAddress))) {
		/* begin MoveCq:R: */
		quickConstant = methodCacheAddress();
		reg = (cacheBaseReg = Extra0Reg);
		genoperandoperand(MoveCqR, quickConstant, reg);
	}
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 0, cacheBaseReg);
	/* begin JumpNonZero: */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = (cacheBaseReg == NoReg
		? (methodCacheAddress()) + (((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))))
		: ((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))));
	itsAHit = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);

	/* check the argument count; if it's wrong fall back on the interpreter primitive. */
	jumpInterpret = genJumpImmediate(ClassReg);
	/* begin genLoadcmNumArgsOf:into: */
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, 0, SendNumArgsReg);
	/* begin MoveMb:r:R: */
	
	BytesPerWord;
	anInstruction = genoperandoperandoperand(MoveMbrR, BytesPerWord, ClassReg, SendNumArgsReg);
	genGetRawSlotSizeOfNonImminto(Arg1Reg, TempReg);
	/* begin CmpR:R: */
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpBadNumArgs1 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = numRegArgs();
	genoperandoperand(CmpCqR, quickConstant1, SendNumArgsReg);
	/* begin JumpGreater: */
	jumpBadNumArgs2 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	genFetchRegArgsForPerformWithArguments(TempReg);
	/* begin AddCq:R: */
	genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	/* begin JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 1, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 2, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpImmArray, jmpTarget(jumpSelectorMiss, jmpTarget(jumpInterpret, jmpTarget(jumpBadNumArgs1, jmpTarget(jumpBadNumArgs2, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genPushActiveContextBytecode */
static sqInt
genPushActiveContextBytecode(void)
{
	assert(needsFrame);
	voidReceiverResultRegContainsSelf();
	/* begin ssAllocateCallReg:and:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg)), simStackPtr, simNativeStackPtr);
	genGetActiveContextNumArgslargeinBlock(methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	return ssPushRegister(ReceiverResultReg);
}


/*	Block compilation. At this point in the method create the block. Note its
	start and defer generating code for it until after the method and any
	other preceding
	blocks. The block's actual code will be compiled later. */
/*	143 10001111 llllkkkk jjjjjjjj iiiiiiii	Push Closure Num Copied llll Num
	Args kkkk BlockSize jjjjjjjjiiiiiiii */

	/* StackToRegisterMappingCogit>>#genPushClosureCopyCopiedValuesBytecode */
static sqInt
genPushClosureCopyCopiedValuesBytecode(void)
{
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt reg;
    sqInt startpc;

	assert(needsFrame);
	startpc = bytecodePC + (((generatorAt(byte0))->numBytes));
	addBlockStartAtnumArgsnumCopiedspan(startpc, (numArgs = byte1 & 15), (numCopied = ((usqInt)(byte1)) >> 4), (((sqInt)((usqInt)(byte2) << 8))) + byte3);
	/* begin genInlineClosure:numArgs:numCopied: */
	assert(getActiveContextAllocatesInMachineCode());
	voidReceiverResultRegContainsSelf();
	/* begin ssAllocateCallReg:and:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg)), simStackPtr, simNativeStackPtr);
	genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(startpc + 1, numArgs, numCopied, methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	for (i = 1; i <= numCopied; i += 1) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
		genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, (ClosureFirstCopiedValueIndex + numCopied) - i, ReceiverResultReg);
	}
	ssPushRegister(ReceiverResultReg);
	return 0;
}


/*	<SmallInteger> */
/*	Override to avoid the BytecodeSetHasDirectedSuperSend check, which is
	unnecessary here given the simulation stack. */

	/* StackToRegisterMappingCogit>>#genPushLiteralIndex: */
static sqInt NoDbgRegParms
genPushLiteralIndex(sqInt literalIndex)
{
    sqInt literal;

	literal = getLiteral(literalIndex);
	/* begin genPushLiteral: */
	return ssPushConstant(literal);
}

	/* StackToRegisterMappingCogit>>#genPushLiteralVariable: */
static sqInt NoDbgRegParms
genPushLiteralVariable(sqInt literalIndex)
{
    sqInt association;
    sqInt bcpc;
    BytecodeDescriptor *descriptor1;
    sqInt eA;
    sqInt eB;
    sqInt freeReg;
    sqInt savedB0;
    sqInt savedB1;
    sqInt savedB2;
    sqInt savedB3;
    sqInt savedEA;
    sqInt savedEB;
    sqInt savedNEB;


	/* If followed by a directed super send bytecode, avoid generating any code yet.
	   The association will be passed to the directed send trampoline in a register
	   and fully dereferenced only when first linked.  It will be ignored in later sends. */
	association = getLiteral(literalIndex);
	assert(!(directedSendUsesBinding));
	/* begin nextDescriptorExtensionsAndNextPCInto: */
	descriptor1 = generatorAt(byte0);
	savedB0 = byte0;
	savedB1 = byte1;
	savedB2 = byte2;
	savedB3 = byte3;
	savedEA = extA;
	savedEB = extB;
	savedNEB = numExtB;
	bcpc = bytecodePC + ((descriptor1->numBytes));
	do {
		if (bcpc > endPC) {
			goto l2;
		}
		byte0 = (fetchByteofObject(bcpc, methodObj)) + bytecodeSetOffset;
		descriptor1 = generatorAt(byte0);
		loadSubsequentBytesForDescriptorat(descriptor1, bcpc);
		if (!((descriptor1->isExtension))) {
			eA = extA;
			eB = extB;
			extA = savedEA;
			extB = savedEB;
			numExtB = savedNEB;
			byte0 = savedB0;
			byte1 = savedB1;
			byte2 = savedB2;
			byte3 = savedB3;
			if ((descriptor1 != null)
			 && ((((descriptor1->generator)) == genExtSendSuperBytecode)
			 && (eB >= 64))) {
				ssPushConstant(association);
				directedSendUsesBinding = 1;
				return 0;
			}
			goto l2;
		}
		((descriptor1->generator))();
		bcpc += (descriptor1->numBytes);
	} while(1);
	l2:	/* end nextDescriptorExtensionsAndNextPCInto: */;

	/* N.B. Do _not_ use ReceiverResultReg to avoid overwriting receiver in assignment in frameless methods. */
	/* So far descriptors are not rich enough to describe the entire dereference so generate the register
	   load but don't push the result.  There is an order-of-evaluation issue if we defer the dereference. */
	freeReg = allocateRegNotConflictingWith(0);
	/* begin genMoveConstant:R: */
	if (shouldAnnotateObjectReference(association)) {
		annotateobjRef(checkLiteralforInstruction(association, genoperandoperand(MoveCwR, association, TempReg)), association);
	}
	else {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, association, TempReg);
	}
	genLoadSlotsourceRegdestReg(ValueIndex, TempReg, freeReg);
	ssPushRegister(freeReg);
	return 0;
}

	/* StackToRegisterMappingCogit>>#genPushMaybeContextReceiverVariable: */
static sqInt NoDbgRegParms
genPushMaybeContextReceiverVariable(sqInt slotIndex)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *jmpDone;
    AbstractInstruction *jmpSingle;

	/* begin ssAllocateCallReg:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg)) | ((1U << SendNumArgsReg))), simStackPtr, simNativeStackPtr);
	ensureReceiverResultRegContainsSelf();
	/* begin genPushMaybeContextSlotIndex: */
	assert(needsFrame);
	if (((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)) {

		/* We have no way of reloading ReceiverResultReg since we need the inst var value as the result. */
		voidReceiverResultRegContainsSelf();
	}
	if (slotIndex == InstructionPointerIndex) {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceFetchContextInstVarTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		return ssPushRegister(SendNumArgsReg);
	}
	genLoadSlotsourceRegdestReg(SenderIndex, ReceiverResultReg, TempReg);
	/* begin genJumpNotSmallIntegerInScratchReg: */
	jmpSingle = genJumpNotSmallInteger(TempReg);
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
	/* begin CallRT: */
	
	abstractInstruction1 = genoperand(Call, ceFetchContextInstVarTrampoline);
	(abstractInstruction1->annotation = IsRelativeCall);
	/* begin Jump: */
	jmpDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jmpSingle, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genLoadSlotsourceRegdestReg(slotIndex, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jmpDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return ssPushRegister(SendNumArgsReg);
}

	/* StackToRegisterMappingCogit>>#genPushNewArrayBytecode */
static sqInt
genPushNewArrayBytecode(void)
{
    sqInt i;
    sqInt i1;
    int popValues;
    sqInt size;

	assert(needsFrame);
	voidReceiverResultRegContainsSelf();
	if ((popValues = byte1 > 0x7F)) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i1 <= simStackPtr; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
	}
	else {
		/* begin ssAllocateCallReg:and: */
		ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << SendNumArgsReg)) | ((1U << ReceiverResultReg))), simStackPtr, simNativeStackPtr);
	}
	size = byte1 & 0x7F;
	if (!popValues) {
		if (tryCollapseTempVectorInitializationOfSize(size)) {
			return 0;
		}
	}
	genNewArrayOfSizeinitialized(size, !popValues);
	if (popValues) {
		for (i = (size - 1); i >= 0; i += -1) {
			/* begin PopR: */
			genoperand(PopR, TempReg);
			genStoreSourceRegslotIndexintoNewObjectInDestReg(TempReg, i, ReceiverResultReg);
		}
		ssPop(size);
	}
	return ssPushRegister(ReceiverResultReg);
}

	/* StackToRegisterMappingCogit>>#genPushReceiverBytecode */
static sqInt
genPushReceiverBytecode(void)
{
	if ((((simSelf())->liveRegister)) == ReceiverResultReg) {
		return ssPushRegister(ReceiverResultReg);
	}
	return ssPushDesc(ssSelfDescriptor());
}

	/* StackToRegisterMappingCogit>>#genPushReceiverVariable: */
static sqInt NoDbgRegParms
genPushReceiverVariable(sqInt index)
{
	ensureReceiverResultRegContainsSelf();
	return ssPushBaseoffset(ReceiverResultReg, slotOffsetOfInstVarIndex(index));
}


/*	Ensure that the register args are pushed before the retpc for methods with
	arity <= self numRegArgs.
 */
/*	This isn't as clumsy on a RISC. But putting the receiver and
	args above the return address means the CoInterpreter has a
	single machine-code frame format which saves us a lot of work. */

	/* StackToRegisterMappingCogit>>#genPushRegisterArgs */
static void
genPushRegisterArgs(void)
{
	if (!(regArgsHaveBeenPushed
		 || (methodOrBlockNumArgs > (numRegArgs())))) {
		genPushRegisterArgsForNumArgsscratchReg(backEnd, methodOrBlockNumArgs, SendNumArgsReg);
		regArgsHaveBeenPushed = 1;
	}
}

	/* StackToRegisterMappingCogit>>#genPushRemoteTempLongBytecode */
static sqInt
genPushRemoteTempLongBytecode(void)
{
    sqInt offset;
    sqInt regMask;
    sqInt remoteTempReg;
    sqInt tempVectReg;

	tempVectReg = allocateRegNotConflictingWith(0);
	/* begin MoveMw:r:R: */
	offset = frameOffsetOfTemporary(byte2);
	genoperandoperandoperand(MoveMwrR, offset, FPReg, tempVectReg);
	/* begin availableRegOrNoneNotConflictingWith: */
	regMask = ((tempVectReg < 0) ? (((usqInt)(1)) >> (-tempVectReg)) : (1ULL << tempVectReg));
	remoteTempReg = availableRegisterOrNoneFor(backEnd, (liveRegisters()) | regMask);
	if (remoteTempReg == NoReg) {
		remoteTempReg = tempVectReg;
	}
	genLoadSlotsourceRegdestReg(byte1, tempVectReg, remoteTempReg);
	return ssPushRegister(remoteTempReg);
}


/*	If a frameless method (not a block), only argument temps can be accessed.
	This is assured by the use of needsFrameIfMod16GENumArgs: in pushTemp. */

	/* StackToRegisterMappingCogit>>#genPushTemporaryVariable: */
static sqInt NoDbgRegParms
genPushTemporaryVariable(sqInt index)
{
	assert((inBlock > 0)
	 || (needsFrame
	 || (index < methodOrBlockNumArgs)));
	return ssPushDesc(simStack[index + 1]);
}


/*	In a frameless method ReceiverResultReg already contains self.
	In a frameful method, ReceiverResultReg /may/ contain self. */

	/* StackToRegisterMappingCogit>>#genReturnReceiver */
static sqInt
genReturnReceiver(void)
{
	if (needsFrame) {
		if (!((((simSelf())->liveRegister)) == ReceiverResultReg)) {
			/* begin putSelfInReceiverResultReg */
			storeToReg(simSelf(), ReceiverResultReg);
		}
	}
	return genUpArrowReturn();
}

	/* StackToRegisterMappingCogit>>#genReturnTopFromBlock */
static sqInt
genReturnTopFromBlock(void)
{
	assert(inBlock > 0);
	popToReg(ssTop(), ReceiverResultReg);
	ssPop(1);
	return genBlockReturn();
}

	/* StackToRegisterMappingCogit>>#genReturnTopFromMethod */
static sqInt
genReturnTopFromMethod(void)
{
	popToReg(ssTop(), ReceiverResultReg);
	ssPop(1);
	return genUpArrowReturn();
}

	/* StackToRegisterMappingCogit>>#genSendDirectedSuper:numArgs: */
static sqInt NoDbgRegParms
genSendDirectedSupernumArgs(sqInt selectorIndex, sqInt numArgs)
{
    sqInt result;

	assert((((ssTop())->type)) == SSConstant);
	tempOop = ((ssTop())->constant);
	ssPop(1);
	marshallSendArguments(numArgs);
	result = genMarshalledSendnumArgssendTable(selectorIndex, numArgs, (directedSendUsesBinding
		? directedSuperBindingSendTrampolines
		: directedSuperSendTrampolines));
	directedSendUsesBinding = 0;
	return result;
}

	/* StackToRegisterMappingCogit>>#genSendSuper:numArgs: */
static sqInt NoDbgRegParms
genSendSupernumArgs(sqInt selectorIndex, sqInt numArgs)
{
	marshallSendArguments(numArgs);
	return genMarshalledSendnumArgssendTable(selectorIndex, numArgs, superSendTrampolines);
}


/*	Generate a trampoline with four arguments.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* StackToRegisterMappingCogit>>#genSendTrampolineFor:numArgs:called:arg:arg:arg:arg: */
static usqInt NoDbgRegParms
genSendTrampolineFornumArgscalledargargargarg(void *aRoutine, sqInt numArgs, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3)
{
    sqInt routine;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	/* begin selectorIndexDereferenceRoutine */
	routine = ceDereferenceSelectorIndex;
	if (!(routine == null)) {

		/* Explicitly save LinkReg via ExtraReg2; it's presumably faster than pushing/popping */
		/* begin Call: */
		genoperand(Call, routine);
			}
	genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 4, regOrConst0, regOrConst1, regOrConst2, regOrConst3, 0 /* emptyRegisterMask */, 1, NoReg, 1);
	return startAddress;
}

	/* StackToRegisterMappingCogit>>#genSend:numArgs: */
static sqInt NoDbgRegParms
genSendnumArgs(sqInt selectorIndex, sqInt numArgs)
{
	marshallSendArguments(numArgs);
	return genMarshalledSendnumArgssendTable(selectorIndex, numArgs, ordinarySendTrampolines);
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorArithmetic */
static sqInt
genSpecialSelectorArithmetic(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt argInt;
    int argIsConst;
    sqInt argIsInt;
    sqInt i;
    sqInt index;
    sqInt index1;
    AbstractInstruction *jumpContinue;
    AbstractInstruction *jumpNotSmallInts;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrInt;
    int rcvrIsConst;
    sqInt rcvrIsInt;
    sqInt result;

	primDescriptor = generatorAt(byte0);
	argIsInt = ((argIsConst = (((ssTop())->type)) == SSConstant))
	 && ((((((argInt = ((ssTop())->constant)))) & 7) == 1));
	rcvrIsInt = (((rcvrIsConst = (((ssValue(1))->type)) == SSConstant))
	 && ((((((rcvrInt = ((ssValue(1))->constant)))) & 7) == 1)))
	 || ((mclassIsSmallInteger())
	 && (isSameEntryAs(ssValue(1), simSelf())));
	if (argIsInt
	 && (rcvrIsInt
	 && (rcvrIsConst))) {
		rcvrInt = (rcvrInt >> 3);
		argInt = (argInt >> 3);
		switch ((primDescriptor->opcode)) {
		case AddRR:
			result = rcvrInt + argInt;
			break;
		case SubRR:
			result = rcvrInt - argInt;
			break;
		case AndRR:
			result = rcvrInt & argInt;
			break;
		case OrRR:
			result = rcvrInt | argInt;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		if (isIntegerValue(result)) {

			/* Must annotate the bytecode for correct pc mapping. */
			return (ssPop(2),
				ssPushAnnotatedConstant((((usqInt)result << 3) | 1)));
		}
		return genSpecialSelectorSend();
	}
	if ((rcvrIsConst
	 && (!rcvrIsInt))
	 || (argIsConst
	 && (!argIsInt))) {
		return genSpecialSelectorSend();
	}
	if (!(argIsInt
		 || (rcvrIsInt))) {
		return genSpecialSelectorSend();
	}
	if (argIsInt) {
		/* begin ssFlushTo: */
		index1 = simStackPtr - 2;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index1) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index1) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index1)); i <= index1; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = index1 + 1;
		}
		popToReg(ssValue(1), ReceiverResultReg);
		ssPop(2);
	}
	else {
		marshallSendArguments(1);
	}
	jumpNotSmallInts = (!(rcvrIsInt
 && (argIsInt))
		? (argIsInt
				? genJumpNotSmallInteger(ReceiverResultReg)
				: (rcvrIsInt
						? genJumpNotSmallInteger(Arg0Reg)
						: (/* begin genJumpNotSmallIntegersIn:and:scratch: */
							genoperandoperand(MoveRR, ReceiverResultReg, TempReg),
							/* begin AndR:R: */
							genoperandoperand(AndRR, Arg0Reg, TempReg),
							/* begin genJumpNotSmallIntegerInScratchReg: */
							genJumpNotSmallInteger(TempReg))))
		: 0);
	switch ((primDescriptor->opcode)) {
	case AddRR:
		if (argIsInt) {
			/* begin AddCq:R: */
			genoperandoperand(AddCqR, argInt - ConstZero, ReceiverResultReg);
			/* begin JumpNoOverflow: */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			/* begin SubCq:R: */
			genoperandoperand(SubCqR, argInt - ConstZero, ReceiverResultReg);
		}
		else {
			genRemoveSmallIntegerTagsInScratchReg(ReceiverResultReg);
			/* begin AddR:R: */
			genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
			/* begin JumpNoOverflow: */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			if (rcvrIsInt
			 && (rcvrIsConst)) {
				/* begin MoveCq:R: */
				genoperandoperand(MoveCqR, rcvrInt, ReceiverResultReg);
			}
			else {
				/* begin SubR:R: */
				genoperandoperand(SubRR, Arg0Reg, ReceiverResultReg);
				genSetSmallIntegerTagsIn(ReceiverResultReg);
			}
		}
		break;
	case SubRR:
		if (argIsInt) {
			/* begin SubCq:R: */
			genoperandoperand(SubCqR, argInt - ConstZero, ReceiverResultReg);
			/* begin JumpNoOverflow: */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			/* begin AddCq:R: */
			genoperandoperand(AddCqR, argInt - ConstZero, ReceiverResultReg);
		}
		else {
			genRemoveSmallIntegerTagsInScratchReg(Arg0Reg);
			/* begin SubR:R: */
			genoperandoperand(SubRR, Arg0Reg, ReceiverResultReg);
			/* begin JumpNoOverflow: */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			/* begin AddR:R: */
			genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
			genSetSmallIntegerTagsIn(Arg0Reg);
		}
		break;
	case AndRR:
		if (argIsInt) {
			/* begin AndCq:R: */
			genoperandoperand(AndCqR, argInt, ReceiverResultReg);
		}
		else {
			/* begin AndR:R: */
			genoperandoperand(AndRR, Arg0Reg, ReceiverResultReg);
		}
		jumpContinue = (!(jumpNotSmallInts == null)
			? (/* begin Jump: */
				genoperand(Jump, ((sqInt)0)))
			: 0);
		break;
	case OrRR:
		if (argIsInt) {
			/* begin OrCq:R: */
			genoperandoperand(OrCqR, argInt, ReceiverResultReg);
		}
		else {
			/* begin OrR:R: */
			genoperandoperand(OrRR, Arg0Reg, ReceiverResultReg);
		}
		jumpContinue = (!(jumpNotSmallInts == null)
			? (/* begin Jump: */
				genoperand(Jump, ((sqInt)0)))
			: 0);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	if (jumpNotSmallInts == null) {
		if (!jumpContinue) {

			/* overflow cannot happen */
			/* begin annotateInstructionForBytecode */
			
			if (prevInstIsPCAnnotated()) {
				/* begin Nop */
				abstractInstruction = gen(Nop);
			}
			else {
				abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			(abstractInstruction->annotation = HasBytecodePC);
			ssPushRegister(ReceiverResultReg);
			return 0;
		}
	}
	else {
		jmpTarget(jumpNotSmallInts, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	if (argIsInt) {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, argInt, Arg0Reg);
	}
	index = byte0 - ((bytecodeSetOffset == 0x100
		? AltFirstSpecialSelector + 0x100
		: FirstSpecialSelector));
	genMarshalledSendnumArgssendTable((-index) - 1, 1, ordinarySendTrampolines);
	jmpTarget(jumpContinue, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorClass */
static sqInt
genSpecialSelectorClass(void)
{
    sqInt requiredReg1;
    sqInt topReg;

	topReg = registerOrNone(ssTop());
	ssPop(1);
	if ((topReg == NoReg)
	 || (topReg == ClassReg)) {
		/* begin ssAllocateRequiredReg:and: */
		requiredReg1 = (topReg = SendNumArgsReg);
		ssAllocateRequiredRegMaskupThroughupThroughNative((((requiredReg1 < 0) ? (((usqInt)(1)) >> (-requiredReg1)) : (1ULL << requiredReg1))) | ((1U << ClassReg)), simStackPtr, simNativeStackPtr);
	}
	else {
		/* begin ssAllocateRequiredReg: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr, simNativeStackPtr);
	}
	ssPush(1);
	popToReg(ssTop(), topReg);
	genGetClassObjectOfintoscratchRegmayBeAForwarder(topReg, ClassReg, TempReg, mayBeAForwarder(ssTop()));
	return (ssPop(1),
		ssPushRegister(ClassReg));
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorComparison */
static sqInt
genSpecialSelectorComparison(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt argInt;
    sqInt argIsIntConst;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt i;
    sqInt index;
    sqInt index1;
    sqInt inlineCAB;
    AbstractInstruction *jumpNotSmallInts;
    void *jumpTarget;
    sqInt nExts;
    sqInt nextPC;
    sqInt nextPC1;
    sqInt postBranchPC;
    sqInt postBranchPC1;
    BytecodeDescriptor *primDescriptor;
    BytecodeDescriptor *primDescriptor1;
    int rcvrIsConst;
    sqInt rcvrIsInt;
    sqInt targetBytecodePC;
    sqInt targetPC;

	/* begin ssFlushTo: */
	index1 = simStackPtr - 2;
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= index1) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index1) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index1)); i <= index1; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = index1 + 1;
	}
	primDescriptor = generatorAt(byte0);
	argIsIntConst = ((((ssTop())->type)) == SSConstant)
	 && ((((((argInt = ((ssTop())->constant)))) & 7) == 1));
	rcvrIsInt = (((rcvrIsConst = (((ssValue(1))->type)) == SSConstant))
	 && (((((((ssValue(1))->constant))) & 7) == 1)))
	 || ((mclassIsSmallInteger())
	 && (isSameEntryAs(ssValue(1), simSelf())));
	if (argIsIntConst
	 && (rcvrIsInt
	 && (rcvrIsConst))) {
		return genStaticallyResolvedSpecialSelectorComparison();
	}
	/* begin extractMaybeBranchDescriptorInto: */
	primDescriptor1 = generatorAt(byte0);
	nextPC1 = bytecodePC + ((primDescriptor1->numBytes));
	nExts = 0;
	while (1) {
		while (1) {
			/* begin generatorForPC: */
			branchDescriptor1 = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC1, methodObj)));
			if (!((branchDescriptor1->isExtension))) break;
			nExts += 1;
			nextPC1 += (branchDescriptor1->numBytes);
		}
		/* begin isUnconditionalBranch */
		if (!((isBranch(branchDescriptor1))
		 && (!(((branchDescriptor1->isBranchTrue))
		 || ((branchDescriptor1->isBranchFalse)))))) break;
		nextPC1 = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
	}
	targetBytecodePC = (postBranchPC1 = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
		postBranchPC1 = eventualTargetOf(nextPC1 + ((branchDescriptor1->numBytes)));
	}
	else {
		nextPC1 = bytecodePC + ((primDescriptor1->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPC1;
	postBranchPC = postBranchPC1;
	targetPC = targetBytecodePC;

	/* Further, only interested in inlining = and ~= if there's a SmallInteger constant involved.
	   The relational operators successfully statically predict SmallIntegers; the equality operators do not. */
	inlineCAB = ((branchDescriptor->isBranchTrue))
	 || ((branchDescriptor->isBranchFalse));
	if (inlineCAB
	 && ((((primDescriptor->opcode)) == JumpZero)
	 || (((primDescriptor->opcode)) == JumpNonZero))) {
		inlineCAB = argIsIntConst
		 || (rcvrIsInt);
	}
	if (!inlineCAB) {
		return genSpecialSelectorSend();
	}
	if (argIsIntConst) {
		popToReg(ssValue(1), ReceiverResultReg);
		ssPop(2);
	}
	else {
		marshallSendArguments(1);
	}
	jumpNotSmallInts = (!(rcvrIsInt
 && (argIsIntConst))
		? (argIsIntConst
				? genJumpNotSmallInteger(ReceiverResultReg)
				: (rcvrIsInt
						? genJumpNotSmallInteger(Arg0Reg)
						: (/* begin genJumpNotSmallIntegersIn:and:scratch: */
							genoperandoperand(MoveRR, ReceiverResultReg, TempReg),
							/* begin AndR:R: */
							genoperandoperand(AndRR, Arg0Reg, TempReg),
							/* begin genJumpNotSmallIntegerInScratchReg: */
							genJumpNotSmallInteger(TempReg))))
		: 0);
	if (argIsIntConst) {
		/* begin CmpCq:R: */
		genoperandoperand(CmpCqR, argInt, ReceiverResultReg);
	}
	else {
		/* begin CmpR:R: */
		assert(!((Arg0Reg == SPReg)));
		genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	}
	genConditionalBranchoperand(((branchDescriptor->isBranchTrue)
		? (primDescriptor->opcode)
		: inverseBranchFor((primDescriptor->opcode))), ((usqInt)(ensureNonMergeFixupAt(targetPC))));
	/* begin Jump: */
	jumpTarget = ensureNonMergeFixupAt(postBranchPC);
	genoperand(Jump, ((sqInt)jumpTarget));
	if (!jumpNotSmallInts) {
		/* begin annotateInstructionForBytecode */
		
		if (prevInstIsPCAnnotated()) {
			/* begin Nop */
			abstractInstruction = gen(Nop);
		}
		else {
			abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		(abstractInstruction->annotation = HasBytecodePC);
		ensureFixupAt(postBranchPC);
		ensureFixupAt(targetPC);
		deadCode = 1;
		return 0;
	}
	jmpTarget(jumpNotSmallInts, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (argIsIntConst) {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, argInt, Arg0Reg);
	}
	index = byte0 - ((bytecodeSetOffset == 0x100
		? AltFirstSpecialSelector + 0x100
		: FirstSpecialSelector));
	return genMarshalledSendnumArgssendTable((-index) - 1, 1, ordinarySendTrampolines);
}


/*	Assumes both operands are ints */

	/* StackToRegisterMappingCogit>>#genStaticallyResolvedSpecialSelectorComparison */
static sqInt
genStaticallyResolvedSpecialSelectorComparison(void)
{
    sqInt argInt;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrInt;
    int result;

	primDescriptor = generatorAt(byte0);
	argInt = ((ssTop())->constant);
	rcvrInt = ((ssValue(1))->constant);
	switch ((primDescriptor->opcode)) {
	case JumpLess:
		result = rcvrInt < argInt;
		break;
	case JumpLessOrEqual:
		result = rcvrInt <= argInt;
		break;
	case JumpGreater:
		result = rcvrInt > argInt;
		break;
	case JumpGreaterOrEqual:
		result = rcvrInt >= argInt;
		break;
	case JumpZero:
		result = rcvrInt == argInt;
		break;
	case JumpNonZero:
		result = rcvrInt != argInt;
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	ssPop(2);
	return ssPushAnnotatedConstant((result
		? trueObject()
		: falseObject()));
}


/*	We need a frame because the association has to be in ReceiverResultReg for
	the various trampolines
	and ReceiverResultReg holds only the receiver in frameless methods.
 */

	/* StackToRegisterMappingCogit>>#genStorePop:LiteralVariable:needsStoreCheck:needsImmutabilityCheck: */
static sqInt NoDbgRegParms
genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt litVarIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    sqInt association;
    sqInt i;
    sqInt index;
    sqInt topReg;

	assert(needsFrame);
	/* begin genLoadLiteralVariable:in: */
	association = getLiteral(litVarIndex);
	voidReceiverResultRegContainsSelf();
	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
	/* begin genMoveConstant:R: */
	if (shouldAnnotateObjectReference(association)) {
		annotateobjRef(checkLiteralforInstruction(association, genoperandoperand(MoveCwR, association, ReceiverResultReg)), association);
	}
	else {
		/* begin MoveCq:R: */
		genoperandoperand(MoveCqR, association, ReceiverResultReg);
	}
	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
#  if IMMUTABILITY
	if (needsImmCheck) {
		/* begin ssAllocateRequiredReg:upThrough: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr - 1, simNativeStackPtr);
		ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
		/* begin ssFlushTo: */
		index = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = index + 1;
		}
		return genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(ClassReg, ValueIndex, ReceiverResultReg, TempReg, needsStoreCheck, 0);
	}
#  endif // IMMUTABILITY
	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, ValueIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheck);
}


/*	The reason we need a frame here is that assigning to an inst var of a
	context may
	involve wholesale reorganization of stack pages, and the only way to
	preserve the
	execution state of an activation in that case is if it has a frame. */

	/* StackToRegisterMappingCogit>>#genStorePop:MaybeContextReceiverVariable:needsStoreCheck:needsImmutabilityCheck: */
static sqInt NoDbgRegParms
genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction2;
    AbstractInstruction *abstractInstruction3;
    sqInt i;
    AbstractInstruction *immutabilityFailure;
    AbstractInstruction *mutableJump;

	immutabilityFailure = ((AbstractInstruction *) 0);
	assert(needsFrame);
	ssFlushUpThroughReceiverVariable(slotIndex);
	ensureReceiverResultRegContainsSelf();
	/* begin genGenericStorePop:MaybeContextSlotIndex:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
	assert(needsFrame);
#  if IMMUTABILITY
	if (needsImmCheck) {
		mutableJump = genJumpMutablescratchReg(ReceiverResultReg, TempReg);
		/* begin genStoreTrampolineCall: */
		assert(IMMUTABILITY);
		if (slotIndex >= (NumStoreTrampolines - 1)) {
			/* begin MoveCq:R: */
			genoperandoperand(MoveCqR, slotIndex, TempReg);
			/* begin CallRT: */
			
			abstractInstruction = genoperand(Call, ceStoreTrampolines[NumStoreTrampolines - 1]);
			(abstractInstruction->annotation = IsRelativeCall);
		}
		else {
			/* begin CallRT: */
			
			abstractInstruction1 = genoperand(Call, ceStoreTrampolines[slotIndex]);
			(abstractInstruction1->annotation = IsRelativeCall);
		}
		/* begin annotateBytecode: */
		abstractInstruction2 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction2->annotation = HasBytecodePC);
		/* begin putSelfInReceiverResultReg */
		storeToReg(simSelf(), ReceiverResultReg);
		/* begin Jump: */
		immutabilityFailure = genoperand(Jump, ((sqInt)0));
		jmpTarget(mutableJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
#  endif // IMMUTABILITY
	ssPop(1);
	/* begin ssAllocateCallReg:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ClassReg)) | ((1U << SendNumArgsReg))), simStackPtr, simNativeStackPtr);
	ssPush(1);
	genLoadSlotsourceRegdestReg(SenderIndex, ReceiverResultReg, TempReg);
	ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= simStackPtr) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = simStackPtr + 1;
	}
	/* begin MoveCq:R: */
	genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
	/* begin CallRT: */
	
	abstractInstruction3 = genoperand(Call, ceStoreContextInstVarTrampoline);
	(abstractInstruction3->annotation = IsRelativeCall);
#  if IMMUTABILITY
	if (needsImmCheck) {
		jmpTarget(immutabilityFailure, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
#  endif
	return 0;
}

	/* StackToRegisterMappingCogit>>#genStorePop:ReceiverVariable:needsStoreCheck:needsImmutabilityCheck: */
static sqInt NoDbgRegParms
genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    sqInt i;
    sqInt index;
    sqInt needsImmCheck1;
    sqInt needsStoreCheck1;
    sqInt topReg;

	ssFlushUpThroughReceiverVariable(slotIndex);
	ensureReceiverResultRegContainsSelf();
	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
	needsStoreCheck1 = (!useTwoPaths)
	 && (needsStoreCheck);
	needsImmCheck1 = needsImmCheck
	 && (!useTwoPaths);
#  if IMMUTABILITY
	if (needsImmCheck1) {
		/* begin ssAllocateRequiredReg:upThrough: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr - 1, simNativeStackPtr);
		ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
		/* begin ssFlushTo: */
		index = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = index + 1;
		}
		return genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(ClassReg, slotIndex, ReceiverResultReg, TempReg, needsStoreCheck1, 1);
	}
#  endif // IMMUTABILITY
	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, slotIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheck1);
}


/*	The only reason we assert needsFrame here is that in a frameless method
	ReceiverResultReg must and does contain only self, but the ceStoreCheck
	trampoline expects the target of the store to be in ReceiverResultReg. So
	in a frameless method we would have a conflict between the receiver and
	the temote temp store, unless we we smart enough to realise that
	ReceiverResultReg was unused after the literal variable store, unlikely
	given that methods return self by default. */

	/* StackToRegisterMappingCogit>>#genStorePop:RemoteTemp:At:needsStoreCheck: */
static sqInt NoDbgRegParms
genStorePopRemoteTempAtneedsStoreCheck(sqInt popBoolean, sqInt slotIndex, sqInt remoteTempIndex, sqInt needsStoreCheck)
{
    sqInt offset;
    sqInt topReg;

	assert(needsFrame);
	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
	voidReceiverResultRegContainsSelf();
	/* begin MoveMw:r:R: */
	offset = frameOffsetOfTemporary(remoteTempIndex);
	genoperandoperandoperand(MoveMwrR, offset, FPReg, ReceiverResultReg);
	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, slotIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheck);
}

	/* StackToRegisterMappingCogit>>#genStorePop:TemporaryVariable: */
static sqInt NoDbgRegParms
genStorePopTemporaryVariable(sqInt popBoolean, sqInt tempIndex)
{
    sqInt offset;
    sqInt reg;

	ssFlushUpThroughTemporaryVariable(tempIndex);
	reg = ssStorePoptoPreferredReg(popBoolean, TempReg);
	/* begin MoveR:Mw:r: */
	offset = frameOffsetOfTemporary(tempIndex);
	genoperandoperandoperand(MoveRMwr, reg, offset, FPReg);
	((simStackAt(tempIndex + 1))->bcptr = bytecodePC);
	return 0;
}


/*	Generate a method return from within a method or a block.
	Frameless method activation looks like
	CISCs (x86):
	receiver
	args
	sp->	ret pc.
	RISCs (ARM):
	receiver
	args
	ret pc in LR.
	A fully framed activation is described in CoInterpreter
	class>initializeFrameIndices. Return pops receiver and arguments off the
	stack. Callee pushes the result. */

	/* StackToRegisterMappingCogit>>#genUpArrowReturn */
static sqInt
genUpArrowReturn(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    sqInt i;
    sqInt offset;


	/* can't fall through */
	deadCode = 1;
	if (inBlock > 0) {
		assert(needsFrame);
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		/* begin CallRT: */
		
		abstractInstruction = genoperand(Call, ceNonLocalReturnTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		/* begin annotateBytecode: */
		abstractInstruction1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction1->annotation = HasBytecodePC);
		return 0;
	}
	if (
#  if IMMUTABILITY
		needsFrame
			 && (!useTwoPaths)
#  else
		needsFrame
#  endif
		) {
		if (hasNativeFrame) {
			leaveNativeFrame();
		}
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, FPReg, SPReg);
		/* begin PopR: */
		genoperand(PopR, FPReg);
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	else {
		/* begin RetN: */
		offset = ((methodOrBlockNumArgs > (numRegArgs()))
		 || (regArgsHaveBeenPushed)
			? (methodOrBlockNumArgs + 1) * BytesPerWord
			: 0);
		genoperand(RetN, offset);
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#genVanillaInlinedIdenticalOrNotIf: */
static sqInt NoDbgRegParms
genVanillaInlinedIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *anInstruction;
    int argIsConstant;
    sqInt argNeedsReg;
    sqInt argReg;
    sqInt argReg1;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt constant;
    sqInt constant1;
    sqInt i;
    sqInt index;
    void *jumpTarget;
    void *jumpTarget1;
    void *jumpTarget2;
    void *jumpTarget3;
    sqInt nExts;
    sqInt nextPC;
    sqInt nextPC1;
    sqInt postBranchPC;
    sqInt postBranchPC1;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrIsConstant;
    sqInt rcvrNeedsReg;
    sqInt rcvrReg;
    sqInt rcvrReg1;
    sqInt reg;
    sqInt rNext1;
    sqInt rTop1;
    sqInt targetBytecodePC;
    sqInt targetPC;
    sqInt topRegistersMask;

	/* begin extractMaybeBranchDescriptorInto: */
	primDescriptor = generatorAt(byte0);
	nextPC1 = bytecodePC + ((primDescriptor->numBytes));
	nExts = 0;
	while (1) {
		while (1) {
			/* begin generatorForPC: */
			branchDescriptor1 = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC1, methodObj)));
			if (!((branchDescriptor1->isExtension))) break;
			nExts += 1;
			nextPC1 += (branchDescriptor1->numBytes);
		}
		/* begin isUnconditionalBranch */
		if (!((isBranch(branchDescriptor1))
		 && (!(((branchDescriptor1->isBranchTrue))
		 || ((branchDescriptor1->isBranchFalse)))))) break;
		nextPC1 = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
	}
	targetBytecodePC = (postBranchPC1 = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
		postBranchPC1 = eventualTargetOf(nextPC1 + ((branchDescriptor1->numBytes)));
	}
	else {
		nextPC1 = bytecodePC + ((primDescriptor->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPC1;
	postBranchPC = postBranchPC1;
	targetPC = targetBytecodePC;

	/* They can't be both constants to use correct machine opcodes.
	   However annotable constants can't be resolved statically, hence we need to careful. */
	argIsConstant = (((ssTop())->type)) == SSConstant;
	rcvrIsConstant = (!argIsConstant)
	 && ((((ssValue(1))->type)) == SSConstant);
	/* begin allocateEqualsEqualsRegistersArgNeedsReg:rcvrNeedsReg:into: */
	argNeedsReg = !argIsConstant;
	rcvrNeedsReg = !rcvrIsConstant;
	assert(argNeedsReg
	 || (rcvrNeedsReg));
	argReg1 = (rcvrReg1 = NoReg);
	if (argNeedsReg) {
		if (rcvrNeedsReg) {
			/* begin allocateRegForStackTopTwoEntriesInto: */
			topRegistersMask = 0;
			rTop1 = (rNext1 = NoReg);
			if ((registerOrNone(ssTop())) != NoReg) {
				rTop1 = registerOrNone(ssTop());
			}
			if ((registerOrNone(ssValue(1))) != NoReg) {
				/* begin registerMaskFor: */
				reg = (rNext1 = registerOrNone(ssValue(1)));
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
			if (rTop1 == NoReg) {
				rTop1 = allocateRegNotConflictingWith(topRegistersMask);
			}
			if (rNext1 == NoReg) {
				rNext1 = allocateRegNotConflictingWith(((rTop1 < 0) ? (((usqInt)(1)) >> (-rTop1)) : (1ULL << rTop1)));
			}
			assert(!(((rTop1 == NoReg)
 || (rNext1 == NoReg))));
			argReg1 = rTop1;
			rcvrReg1 = rNext1;
			popToReg(ssTop(), argReg1);
			popToReg(ssValue(1), rcvrReg1);
		}
		else {
			/* begin allocateRegForStackEntryAt: */
			argReg1 = allocateRegForStackEntryAtnotConflictingWith(0, 0);
			popToReg(ssTop(), argReg1);
			if (((ssValue(1))->spilled)) {
				/* begin AddCq:R: */
				
				BytesPerWord;
				anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
			}
		}
	}
	else {
		assert(rcvrNeedsReg);
		assert(!((((ssTop())->spilled))));
		/* begin allocateRegForStackEntryAt: */
		rcvrReg1 = allocateRegForStackEntryAtnotConflictingWith(1, 0);
		popToReg(ssValue(1), rcvrReg1);
	}
	assert(!((argNeedsReg
 && (argReg1 == NoReg))));
	assert(!((rcvrNeedsReg
 && (rcvrReg1 == NoReg))));
	rcvrReg = rcvrReg1;
	argReg = argReg1;
	if (!(((branchDescriptor->isBranchTrue))
		 || ((branchDescriptor->isBranchFalse)))) {
		return genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(argIsConstant, rcvrIsConstant, argReg, rcvrReg, orNot);
	}
	/* begin ssFlushTo: */
	index = simStackPtr - 2;
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= index) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = index + 1;
	}
	/* begin genCmpArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	assert((argReg != NoReg)
	 || (rcvrReg != NoReg));
	if (argIsConstant) {
		/* begin genCmpConstant:R: */
		constant = ((ssTop())->constant);
		if (shouldAnnotateObjectReference(constant)) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, rcvrReg)), constant);
		}
		else {
			/* begin CmpCq:R: */
			genoperandoperand(CmpCqR, constant, rcvrReg);
		}
	}
	else {
		if (rcvrIsConstant) {
			/* begin genCmpConstant:R: */
			constant1 = ((ssValue(1))->constant);
			if (shouldAnnotateObjectReference(constant1)) {
				annotateobjRef(checkLiteralforInstruction(constant1, genoperandoperand(CmpCwR, constant1, argReg)), constant1);
			}
			else {
				/* begin CmpCq:R: */
				genoperandoperand(CmpCqR, constant1, argReg);
			}
		}
		else {
			/* begin CmpR:R: */
			assert(!((argReg == SPReg)));
			genoperandoperand(CmpRR, argReg, rcvrReg);
		}
	}
	ssPop(2);
	if ((((fixupAt(nextPC))->targetInstruction)) == 0) {

		/* The next instruction is dead.  we can skip it. */
		deadCode = 1;
		ensureFixupAt(targetPC);
		ensureFixupAt(postBranchPC);
	}
	else {
		assert(!(deadCode));
	}
	if (orNot == ((branchDescriptor->isBranchTrue))) {

		/* a == b ifFalse: ... or a ~~ b ifTrue: ... jump on equal to post-branch pc */
		ensureNonMergeFixupAt(targetPC);
		/* begin JumpZero: */
		jumpTarget = ensureNonMergeFixupAt(postBranchPC);
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
		/* begin Jump: */
		jumpTarget1 = ensureNonMergeFixupAt(targetPC);
		genoperand(Jump, ((sqInt)jumpTarget1));
	}
	else {

		/* orNot is true for ~~ */
		/* a == b ifTrue: ... or a ~~ b ifFalse: ... jump on equal to target pc */
		/* begin JumpZero: */
		jumpTarget2 = ensureNonMergeFixupAt(targetPC);
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget2));
		/* begin Jump: */
		jumpTarget3 = ensureNonMergeFixupAt(postBranchPC);
		genoperand(Jump, ((sqInt)jumpTarget3));
	}
	if (!deadCode) {
		ssPushConstant(trueObject());
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#initSimStackForFramefulMethod: */
static void NoDbgRegParms
initSimStackForFramefulMethod(sqInt startpc)
{
    CogSimStackEntry * cascade0;
    CogSimStackEntry *desc;
    sqInt i;


	/* N.B. Includes num args */
	simStackPtr = methodOrBlockNumTemps;
	simSpillBase = methodOrBlockNumTemps + 1;
	simNativeSpillBase = (simNativeStackPtr = -1);
	simNativeStackSize = 0;
	cascade0 = simSelf();
	(cascade0->type = SSBaseOffset);
	(cascade0->spilled = 1);
	(cascade0->registerr = FPReg);
	(cascade0->offset = FoxMFReceiver);
	(cascade0->liveRegister = NoReg);
	for (i = 1; i <= methodOrBlockNumArgs; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = FPReg);
		(desc->offset = FoxCallerSavedIP + (((methodOrBlockNumArgs - i) + 1) * BytesPerWord));
		(desc->bcptr = startpc);
	}
	for (i = (methodOrBlockNumArgs + 1); i <= simStackPtr; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = FPReg);
		(desc->offset = FoxMFReceiver - ((i - methodOrBlockNumArgs) * BytesPerWord));
		(desc->bcptr = startpc);
	}
}


/*	The register receiver (the closure itself) and args are pushed by the
	closure value primitive(s)
	and hence a frameless block has all arguments and copied values pushed to
	the stack. However,
	the method receiver (self) is put in the ReceiverResultReg by the block
	entry. 
 */

	/* StackToRegisterMappingCogit>>#initSimStackForFramelessBlock: */
static void NoDbgRegParms
initSimStackForFramelessBlock(sqInt startpc)
{
    CogSimStackEntry * cascade0;
    CogSimStackEntry *desc;
    sqInt i;

	cascade0 = simSelf();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = ReceiverResultReg);
	(cascade0->liveRegister = ReceiverResultReg);
	assert(methodOrBlockNumTemps >= methodOrBlockNumArgs);
	for (i = 1; i <= methodOrBlockNumTemps; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = SPReg);
		(desc->offset = ((methodOrBlockNumArgs + 1) - i) * BytesPerWord);
		(desc->bcptr = startpc);
	}

	/* N.B. Includes num args */
	simStackPtr = methodOrBlockNumTemps;
	simSpillBase = methodOrBlockNumTemps + 1;
	simNativeSpillBase = (simNativeStackPtr = -1);
	simNativeStackSize = 0;
}

	/* StackToRegisterMappingCogit>>#initSimStackForFramelessMethod: */
static void NoDbgRegParms
initSimStackForFramelessMethod(sqInt startpc)
{
    CogSimStackEntry * cascade0;
    CogSimStackEntry *desc;
    sqInt i;

	cascade0 = simSelf();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = ReceiverResultReg);
	(cascade0->liveRegister = ReceiverResultReg);
	assert(methodOrBlockNumTemps == methodOrBlockNumArgs);
	assert((numRegArgs()) <= 2);
	if (((methodOrBlockNumArgs >= 1) && (methodOrBlockNumArgs <= (numRegArgs())))) {
		desc = simStackAt(1);
		(desc->type = SSRegister);
		(desc->spilled = 0);
		(desc->registerr = Arg0Reg);
		(desc->bcptr = startpc);
		if (methodOrBlockNumArgs > 1) {
			desc = simStackAt(2);
			(desc->type = SSRegister);
			(desc->spilled = 0);
			(desc->registerr = Arg1Reg);
			(desc->bcptr = startpc);
		}
	}
	else {
		for (i = 1; i <= methodOrBlockNumArgs; i += 1) {
			desc = simStackAt(i);
			(desc->type = SSBaseOffset);
			(desc->registerr = SPReg);
			(desc->spilled = 1);
			(desc->offset = ((methodOrBlockNumArgs + 1) - i) * BytesPerWord);
			(desc->bcptr = startpc);
		}
	}
	simStackPtr = methodOrBlockNumArgs;
	simSpillBase = methodOrBlockNumArgs + 1;
	simNativeSpillBase = (simNativeStackPtr = -1);
	simNativeStackSize = 0;
}


/*	Do not inline (inBlock access) */

	/* StackToRegisterMappingCogit>>#isNonForwarderReceiver: */
static sqInt NoDbgRegParms
isNonForwarderReceiver(sqInt reg)
{
	return ((((simSelf())->liveRegister)) == ReceiverResultReg)
	 && ((inBlock == 0)
	 && (reg == ReceiverResultReg));
}

	/* StackToRegisterMappingCogit>>#leaveNativeFrame */
static void
leaveNativeFrame(void)
{
    sqInt address;
    sqInt offset;

	assert(needsFrame);
	/* begin MoveMw:r:R: */
	offset = frameOffsetOfPreviousNativeStackPointer();
	genoperandoperandoperand(MoveMwrR, offset, FPReg, TempReg);
	/* begin SubCq:R: */
	genoperandoperand(SubCqR, 1, TempReg);
	/* begin MoveR:Aw: */
	address = nativeStackPointerAddress();
	genoperandoperand(MoveRAw, TempReg, address);
	return;
}

	/* StackToRegisterMappingCogit>>#liveFloatRegisters */
static sqInt
liveFloatRegisters(void)
{
    sqInt i;
    sqInt regsSet;

	regsSet = 0;
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= simStackPtr; i += 1) {
		regsSet = regsSet | 0 /* floatRegisterMask */;
	}
	for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= simNativeStackPtr; i += 1) {
		regsSet = regsSet | (nativeFloatRegisterMask(simNativeStackAt(i)));
	}
	return regsSet;
}

	/* StackToRegisterMappingCogit>>#liveRegisters */
static sqInt
liveRegisters(void)
{
    sqInt i;
    sqInt regsSet;

	if (needsFrame) {
		regsSet = 0;
	}
	else {
		/* begin registerMaskFor: */
		regsSet = (1U << ReceiverResultReg);
		if ((methodOrBlockNumArgs <= (numRegArgs()))
		 && (methodOrBlockNumArgs > 0)) {
			regsSet = regsSet | ((1U << Arg0Reg));
			if (methodOrBlockNumArgs > 1) {
				regsSet = regsSet | ((1U << Arg1Reg));
			}
		}
	}
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= simStackPtr; i += 1) {
		regsSet = regsSet | (registerMask(simStackAt(i)));
	}
	for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= simNativeStackPtr; i += 1) {
		regsSet = regsSet | (nativeRegisterMask(simNativeStackAt(i)));
	}
	return regsSet;
}


/*	insert nops for dead code that is mapped so that bc 
	to mc mapping is not many to one */

	/* StackToRegisterMappingCogit>>#mapDeadDescriptorIfNeeded: */
static sqInt NoDbgRegParms
mapDeadDescriptorIfNeeded(BytecodeDescriptor *descriptor)
{
    AbstractInstruction *abstractInstruction;

	flag("annotateInstruction");
	if (((descriptor->isMapped))
	 || ((inBlock > 0)
	 && ((descriptor->isMappedInBlock)))) {
		/* begin annotateBytecode: */
		abstractInstruction = gen(Nop);
		(abstractInstruction->annotation = HasBytecodePC);
	}
	return 0;
}


/*	Spill everything on the simulated stack that needs spilling (that below
	receiver and arguments).
	Marshall receiver and arguments to stack and/or registers depending on arg
	count. If the args don't fit in registers push receiver and args (spill
	everything), but still assign
	the receiver to ReceiverResultReg. */

	/* StackToRegisterMappingCogit>>#marshallSendArguments: */
static void NoDbgRegParms
marshallSendArguments(sqInt numArgs)
{
    sqInt anyRefs;
    CogSimStackEntry * cascade0;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt numSpilled;
    sqInt stackPtr;
    sqInt stackPtr1;
    sqInt stackPtr2;

	/* begin ssFlushTo: */
	index2 = (simStackPtr - numArgs) - 1;
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= index2) {
		for (i2 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index2) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index2)); i2 <= index2; i2 += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i2), frameOffsetOfTemporary(i2 - 1), FPReg);
		}
		simSpillBase = index2 + 1;
	}
	if (numArgs > (numRegArgs())) {

		/* If there are no spills and no references to ReceiverResultReg
		   the fetch of ReceiverResultReg from the stack can be avoided
		   by assigning directly to ReceiverResultReg and pushing it. */
		numSpilled = numberOfSpillsInTopNItems(numArgs + 1);
		anyRefs = anyReferencesToRegisterinTopNItems(ReceiverResultReg, numArgs + 1);
		if ((numSpilled > 0)
		 || (anyRefs)) {
			/* begin ssFlushTo: */
			index = simStackPtr;
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= index) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = index + 1;
			}
			storeToReg(simStackAt(simStackPtr - numArgs), ReceiverResultReg);
		}
		else {
			cascade0 = simStackAt(simStackPtr - numArgs);
			storeToReg(cascade0, ReceiverResultReg);
			(cascade0->type = SSRegister);
			(cascade0->registerr = ReceiverResultReg);
			/* begin ssFlushTo: */
			index1 = simStackPtr;
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= index1) {
				for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index1) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index1)); i1 <= index1; i1 += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
				}
				simSpillBase = index1 + 1;
			}
		}
	}
	else {

		/* Move the args to the register arguments, being careful to do
		   so last to first so e.g. previous contents don't get overwritten.
		   Also check for any arg registers in use by other args. */
		if (numArgs > 0) {
			if (numArgs > 1) {
				/* begin ssAllocateRequiredReg:upThrough: */
				stackPtr = simStackPtr - 2;
				ssAllocateRequiredRegMaskupThroughupThroughNative((1U << Arg0Reg), stackPtr, simNativeStackPtr);
				/* begin ssAllocateRequiredReg:upThrough: */
				stackPtr1 = simStackPtr - 1;
				ssAllocateRequiredRegMaskupThroughupThroughNative((1U << Arg1Reg), stackPtr1, simNativeStackPtr);
			}
			else {
				/* begin ssAllocateRequiredReg:upThrough: */
				stackPtr2 = simStackPtr - 1;
				ssAllocateRequiredRegMaskupThroughupThroughNative((1U << Arg0Reg), stackPtr2, simNativeStackPtr);
			}
		}
		if (numArgs > 1) {
			popToReg(simStackAt(simStackPtr), Arg1Reg);
		}
		if (numArgs > 0) {
			popToReg(simStackAt((simStackPtr - numArgs) + 1), Arg0Reg);
		}
		popToReg(simStackAt(simStackPtr - numArgs), ReceiverResultReg);
	}
	ssPop(numArgs + 1);
}


/*	For assert checking; or rather for avoiding assert fails when dealing with
	the hack for block temps in the SqueakV3PlusClosures bytecode set.
 */

	/* StackToRegisterMappingCogit>>#maybeCompilingFirstPassOfBlockWithInitialPushNil */
static sqInt
maybeCompilingFirstPassOfBlockWithInitialPushNil(void)
{
	return (inBlock == InVanillaBlock)
	 && ((methodOrBlockNumTemps > methodOrBlockNumArgs)
	 && (compilationPass == 1));
}


/*	If this bytecode has a fixup, some kind of merge needs to be done. There
	are 4 cases:
	1) the bytecode has no fixup (fixup isNotAFixup)
	do nothing
	2) the bytecode has a non merge fixup
	the fixup has needsNonMergeFixup.
	The code generating non merge fixup (currently only special selector code)
	is responsible
	for the merge so no need to do it.
	We set deadCode to false as the instruction can be reached from jumps.
	3) the bytecode has a merge fixup, but execution flow *cannot* fall
	through to the merge point.
	the fixup has needsMergeFixup and deadCode = true.
	ignores the current simStack as it does not mean anything 
	restores the simStack to the state the jumps to the merge point expects it
	to be.
	4) the bytecode has a merge fixup and execution flow *can* fall through to
	the merge point.
	the fixup has needsMergeFixup and deadCode = false.
	flushes the stack to the stack pointer so the fall through execution path
	simStack is 
	in the state the merge point expects it to be. 
	restores the simStack to the state the jumps to the merge point expects it
	to be.
	
	In addition, if this is a backjump merge point, we patch the fixup to hold
	the current simStackPtr 
	for later assertions. */

	/* StackToRegisterMappingCogit>>#mergeWithFixupIfRequired: */
static sqInt NoDbgRegParms
mergeWithFixupIfRequired(BytecodeFixup *fixup)
{
    CogSimStackEntry * cascade0;
    sqInt i;
    sqInt i1;
    sqInt index;

	/* begin assertCorrectSimStackPtr */
	assert((simSpillBase >= methodOrBlockNumTemps)
	 || ((maybeCompilingFirstPassOfBlockWithInitialPushNil())
	 && (simSpillBase > methodOrBlockNumArgs)));
	if (needsFrame
	 && (simSpillBase > 0)) {
		assert(((((simStackAt(simSpillBase - 1))->spilled)) == 1)
		 || ((maybeCompilingFirstPassOfBlockWithInitialPushNil())
		 && (simSpillBase > methodOrBlockNumArgs)));
		assert((simSpillBase > simStackPtr)
		 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	}
	if (((fixup->targetInstruction)) == 0) {
		return 0;
	}
	if ((((usqInt)((fixup->targetInstruction)))) == NeedsNonMergeFixupFlag) {
		deadCode = 0;
		return 0;
	}
	assert(isMergeFixup(fixup));
	traceMerge(fixup);
	if (deadCode) {

		/* case 3 */
		/* Would like to assert fixup simStackPtr >= methodOrBlockNumTemps
		   but can't because of the initialNils hack. */
		assert((((fixup->simStackPtr)) >= methodOrBlockNumTemps)
		 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
		simStackPtr = (fixup->simStackPtr);
		simNativeStackPtr = (fixup->simNativeStackPtr);
		simNativeStackSize = (fixup->simNativeStackSize);
	}
	else {

		/* case 4 */
		/* begin ssFlushTo: */
		index = simStackPtr;
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= index) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = index + 1;
		}
	}
	deadCode = 0;
	if ((fixup->isTargetOfBackwardBranch)) {
		(fixup->simStackPtr = simStackPtr);
		(fixup->simNativeStackPtr = simNativeStackPtr);
		(fixup->simNativeStackSize = simNativeStackSize);
	}
	(fixup->targetInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	assert(simStackPtr == ((fixup->simStackPtr)));
	assert(simNativeStackPtr == ((fixup->simNativeStackPtr)));
	assert(simNativeStackSize == ((fixup->simNativeStackSize)));
	/* begin restoreSimStackAtMergePoint: */
	
	((simSelf())->liveRegister = NoReg);
	for (i1 = (methodOrBlockNumTemps + 1); i1 <= simStackPtr; i1 += 1) {
		cascade0 = simStackAt(i1);
		(cascade0->type = SSSpill);
		(cascade0->offset = FoxMFReceiver - ((i1 - methodOrBlockNumArgs) * BytesPerOop));
		(cascade0->registerr = FPReg);
		(cascade0->spilled = 1);
	}
	simSpillBase = simStackPtr + 1;
	for (i1 = 0; i1 <= simNativeStackPtr; i1 += 1) {
		ensureIsMarkedAsSpilled(simNativeStackAt(i1));
	}
	simNativeSpillBase = simNativeStackPtr + 1;
	return 0;
}

	/* StackToRegisterMappingCogit>>#methodAbortTrampolineFor: */
static sqInt NoDbgRegParms
methodAbortTrampolineFor(sqInt numArgs)
{
	return methodAbortTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}


/*	This is a hook for subclasses to filter out methods they can't deal with. */
/*	Frameless methods with local temporaries cause problems,
	mostly in asserts, and yet they matter not at all for performance.
	Shun them. */

	/* StackToRegisterMappingCogit>>#methodFoundInvalidPostScan */
static sqInt
methodFoundInvalidPostScan(void)
{
	if (!needsFrame) {
		return methodOrBlockNumTemps > methodOrBlockNumArgs;
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#needsFrameIfMod16GENumArgs: */
static sqInt NoDbgRegParms
needsFrameIfMod16GENumArgs(sqInt stackDelta)
{
	return (byte0 % 16) >= methodOrBlockNumArgs;
}


/*	As of August 2013, the code generator can't deal with spills in frameless
	methods (the
	issue is to do with the stack offset to get at an argument, which is
	changed when there's a spill).
	In e.g. TextColor>>#dominates: other ^other class == self class the second
	send of class
	needs also rto allocate a register that the first one used, but the first
	one's register can't be
	spilled. So avoid this by only allowing class to be sent if the stack
	contains a single element. */

	/* StackToRegisterMappingCogit>>#needsFrameIfStackGreaterThanOne: */
static sqInt NoDbgRegParms
needsFrameIfStackGreaterThanOne(sqInt stackDelta)
{
	return stackDelta > 1;
}

	/* StackToRegisterMappingCogit>>#numberOfSpillsInTopNItems: */
static sqInt NoDbgRegParms
numberOfSpillsInTopNItems(sqInt n)
{
    sqInt i;

	for (i = simStackPtr; i >= ((simStackPtr - n) + 1); i += -1) {
		if ((((simStackAt(i))->type)) == SSSpill) {
			return n - (simStackPtr - i);
		}
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#picAbortTrampolineFor: */
static sqInt NoDbgRegParms
picAbortTrampolineFor(sqInt numArgs)
{
	return picAbortTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}

	/* StackToRegisterMappingCogit>>#prevInstIsPCAnnotated */
static sqInt
prevInstIsPCAnnotated(void)
{
    sqInt prevIndex;
    AbstractInstruction *prevInst;

	if (!(opcodeIndex > 0)) {
		return 0;
	}
	prevIndex = opcodeIndex - 1;
	while (1) {
		if (prevIndex <= 0) {
			return 0;
		}
		prevInst = abstractInstructionAt(prevIndex);
		if (((!((prevInst->annotation))
			? 0
			: (prevInst->annotation))) >= HasBytecodePC) {
			return 1;
		}
		if (!(((prevInst->opcode)) == Label)) break;
		prevIndex -= 1;
	}
	return 0;
}


/*	Used to mark ReceiverResultReg as dead or not containing simSelf.
	Used when the simStack has already been flushed, e.g. for sends. */

	/* StackToRegisterMappingCogit>>#receiverIsInReceiverResultReg */
static sqInt
receiverIsInReceiverResultReg(void)
{
	return (((simSelf())->liveRegister)) == ReceiverResultReg;
}


/*	When a block must be recompiled due to overestimating the
	numInitialNils fixups must be restored, which means rescannning
	since backward branches need their targets initialized. */

	/* StackToRegisterMappingCogit>>#reinitializeFixupsFrom:through: */
static void NoDbgRegParms
reinitializeFixupsFromthrough(sqInt start, sqInt end)
{
    BytecodeDescriptor *descriptor;
    sqInt distance;
    BytecodeFixup *fixup;
    sqInt nExts;
    sqInt pc;
    BytecodeFixup * self_in_reinitialize;
    sqInt targetPC;

	pc = start;
	nExts = 0;
	while (pc <= end) {
		/* begin reinitialize */
		
		self_in_reinitialize = fixupAtIndex(pc - initialPC);
		(self_in_reinitialize->targetInstruction) = 0;
		(self_in_reinitialize->simStackPtr) = 0;
		(self_in_reinitialize->simNativeStackPtr) = ((self_in_reinitialize->simNativeStackSize) = 0);
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((isBranch(descriptor))
		 && ((assert(((descriptor->spanFunction)) != null),
		(((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)) < 0))) {
			/* begin spanFor:at:exts:in: */
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			/* begin initializeFixupAt: */
			
			fixup = fixupAtIndex(targetPC - initialPC);
			/* begin initializeFixup: */
			
			(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);
			/* begin setIsBackwardBranchFixup */
			(fixup->isTargetOfBackwardBranch) = 1;
		}
		if ((descriptor->isBlockCreation)) {
			/* begin spanFor:at:exts:in: */
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			pc = (pc + ((descriptor->numBytes))) + distance;
		}
		else {
			pc += (descriptor->numBytes);
		}
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
	}
}


/*	Scan the block to determine if the block needs a frame or not */

	/* StackToRegisterMappingCogit>>#scanBlock: */
static sqInt NoDbgRegParms
scanBlock(BlockStart *blockStart)
{
    BytecodeDescriptor *descriptor;
    sqInt end;
    sqInt framelessStackDelta;
    sqInt nExts;
    sqInt numPushNils;
    sqInt (* const numPushNilsFunction)(struct _BytecodeDescriptor *,sqInt,sqInt,sqInt) = squeakV3orSistaV1NumPushNils;
    sqInt pc;
    sqInt pushingNils;

	needsFrame = 0;
	hasNativeFrame = 0;
	prevBCDescriptor = null;
	methodOrBlockNumArgs = (blockStart->numArgs);
	inBlock = InVanillaBlock;
	pc = (blockStart->startpc);
	end = ((blockStart->startpc)) + ((blockStart->span));
	framelessStackDelta = (nExts = (extA = (numExtB = (extB = 0))));
	pushingNils = 1;
	while (pc < end) {
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((descriptor->isExtension)) {
			loadSubsequentBytesForDescriptorat(descriptor, pc);
			((descriptor->generator))();
		}
		if (!needsFrame) {
			if ((((descriptor->needsFrameFunction)) == null)
			 || (((descriptor->needsFrameFunction))(framelessStackDelta))) {
				needsFrame = 1;
			}
			else {
				framelessStackDelta += (descriptor->stackDelta);
			}
		}
		/* begin maybeNoteDescriptor:blockStart: */
		if ((descriptor->isInstVarRef)) {
			(blockStart->hasInstVarRef = 1);
		}
		if (pushingNils
		 && (!((descriptor->isExtension)))) {

			/* Count the initial number of pushed nils acting as temp initializers.  We can't tell
			   whether an initial pushNil is an operand reference or a temp initializer, except
			   when the pushNil is a jump target (has a fixup), which never happens:
			   self systemNavigation browseAllSelect:
			   [:m| | ebc |
			   (ebc := m embeddedBlockClosures
			   select: [:ea| ea decompile statements first isMessage]
			   thenCollect: [:ea| ea decompile statements first selector]) notEmpty
			   and: [(#(whileTrue whileFalse whileTrue: whileFalse:) intersection: ebc) notEmpty]]
			   or if the bytecode set has a push multiple nils bytecode.  We simply count initial nils.
			   Rarely we may end up over-estimating.  We will correct by checking the stack depth
			   at the end of the block in compileBlockBodies. */
			if (((numPushNils = numPushNilsFunction(descriptor, pc, nExts, methodObj))) > 0) {
				assert(((descriptor->numBytes)) == 1);
				(blockStart->numInitialNils = ((blockStart->numInitialNils)) + numPushNils);
			}
			else {
				pushingNils = 0;
			}
		}
		/* begin nextBytecodePCFor:at:exts:in: */
		pc = (pc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? (/* begin spanFor:at:exts:in: */
		((descriptor->spanFunction))(descriptor, pc, nExts, methodObj))
	: 0));
		if ((descriptor->isExtension)) {
			nExts += 1;
		}
		else {
			nExts = (extA = (numExtB = (extB = 0)));
		}
		prevBCDescriptor = descriptor;
	}
	if (!needsFrame) {
		assert((framelessStackDelta >= 0)
		 && (((blockStart->numInitialNils)) >= framelessStackDelta));
		(blockStart->numInitialNils = ((blockStart->numInitialNils)) - framelessStackDelta);
	}
	return 0;
}


/*	Scan the method (and all embedded blocks) to determine
	- what the last bytecode is; extra bytes at the end of a method are used
	to encode things like source pointers or temp names
	- if the method needs a frame or not
	- what are the targets of any backward branches.
	- how many blocks it creates
	Answer the block count or on error a negative error code */

	/* StackToRegisterMappingCogit>>#scanMethod */
static sqInt
scanMethod(void)
{
    BytecodeDescriptor *descriptor;
    sqInt distance;
    BytecodeFixup *fixup;
    sqInt framelessStackDelta;
    sqInt latestContinuation;
    sqInt nExts;
    sqInt numBlocks;
    sqInt pc;
    sqInt seenInstVarStore;
    sqInt targetPC;

	needsFrame = (useTwoPaths = (seenInstVarStore = 0));
	hasNativeFrame = 0;
	prevBCDescriptor = null;
	if ((primitiveIndex > 0)
	 && (isQuickPrimitiveIndex(primitiveIndex))) {
		return 0;
	}
	pc = (latestContinuation = initialPC);
	numBlocks = (framelessStackDelta = (nExts = (extA = (numExtB = (extB = 0)))));
	while (pc <= endPC) {
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((descriptor->isExtension)) {
			if (((descriptor->opcode)) == Nop) {

				/* unknown bytecode tag; see Cogit class>>#generatorTableFrom: */
				return EncounteredUnknownBytecode;
			}
			loadSubsequentBytesForDescriptorat(descriptor, pc);
			((descriptor->generator))();
		}
		if (((descriptor->isReturn))
		 && (pc >= latestContinuation)) {
			endPC = pc;
		}
		if (!needsFrame) {
			if ((((descriptor->needsFrameFunction)) == null)
			 || (((descriptor->needsFrameFunction))(framelessStackDelta))) {

				/* With immutability we win simply by avoiding a frame build if the receiver is young and not immutable. */
#        if IMMUTABILITY
				if ((descriptor->is1ByteInstVarStore)) {
					useTwoPaths = 1;
				}
				else {
					needsFrame = 1;
					useTwoPaths = 0;
				}
#        else // IMMUTABILITY
				needsFrame = 1;
				useTwoPaths = 0;
#        endif
			}
			else {

				/* Without immutability we win if there are two or more stores and the receiver is new. */
				framelessStackDelta += (descriptor->stackDelta);
#        if IMMUTABILITY
#        else
				if ((descriptor->is1ByteInstVarStore)) {
					if (seenInstVarStore) {
						useTwoPaths = 1;
					}
					else {
						seenInstVarStore = 1;
					}
				}
#        endif // IMMUTABILITY
			}
		}
		if (isBranch(descriptor)) {
			/* begin spanFor:at:exts:in: */
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			if ((assert(((descriptor->spanFunction)) != null),
			(((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)) < 0)) {
				/* begin initializeFixupAt: */
				
				fixup = fixupAtIndex(targetPC - initialPC);
				/* begin initializeFixup: */
				
				(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);
				/* begin setIsBackwardBranchFixup */
				(fixup->isTargetOfBackwardBranch) = 1;
			}
			else {
				latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
			}
		}
		if ((descriptor->isBlockCreation)) {
			numBlocks += 1;
			/* begin spanFor:at:exts:in: */
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
		}
		pc += (descriptor->numBytes);
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: (extA = (numExtB = (extB = 0))));
		prevBCDescriptor = descriptor;
	}
	return numBlocks;
}

	/* StackToRegisterMappingCogit>>#squeakV3orSistaV1PushNilSize:numInitialNils: */
static sqInt NoDbgRegParms
squeakV3orSistaV1PushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils)
{
	return (methodUsesAlternateBytecodeSet(aMethodObj),
	numInitialNils);
}

	/* StackToRegisterMappingCogit>>#squeakV3orSistaV1:Num:Push:Nils: */
static sqInt NoDbgRegParms
squeakV3orSistaV1NumPushNils(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	return ((/* begin v3:Num:Push:Nils: */
	(((descriptor->generator)) == genPushConstantNilBytecode
			? 1
			: 0)));
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredFloatRegMask:upThrough:upThroughNative: */
static void NoDbgRegParms
ssAllocateRequiredFloatRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr)
{
    sqInt i;
    sqInt i1;
    sqInt lastRequired;
    sqInt lastRequiredNative;
    sqInt liveRegs;

	lastRequired = -1;

	/* compute live regs while noting the last occurrence of required regs.
	   If these are not free we must spill from simSpillBase to last occurrence.
	   Note we are conservative here; we could allocate FPReg in frameless methods. */
	lastRequiredNative = -1;
	liveRegs = NoReg;
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= stackPtr; i += 1) {
		liveRegs = liveRegs | (registerMask(simStackAt(i)));
		if ((0 /* floatRegisterMask */ & requiredRegsMask) != 0) {
			lastRequired = i;
		}
	}
	assert(lastRequiredNative == simNativeStackPtr);
	for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= nativeStackPtr; i += 1) {
		liveRegs = liveRegs | (nativeRegisterMask(simNativeStackAt(i)));
		if ((0 /* floatRegisterMask */ & requiredRegsMask) != 0) {
			lastRequiredNative = i;
		}
	}
	if (!((liveRegs & requiredRegsMask) == 0)) {

		/* Some live, must spill */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= lastRequired) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < lastRequired) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : lastRequired)); i1 <= lastRequired; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = lastRequired + 1;
		}
		assert(((liveFloatRegisters()) & requiredRegsMask) == 0);
	}
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredFloatReg: */
static void NoDbgRegParms
ssAllocateRequiredFloatReg(sqInt requiredReg)
{
	ssAllocateRequiredFloatRegMaskupThroughupThroughNative(((requiredReg < 0) ? (((usqInt)(1)) >> (-requiredReg)) : (1ULL << requiredReg)), simStackPtr, simNativeStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredRegMask:upThrough:upThroughNative: */
static void NoDbgRegParms
ssAllocateRequiredRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr)
{
    sqInt i;
    sqInt i1;
    sqInt lastRequired;
    sqInt lastRequiredNative;
    sqInt liveRegs;

	lastRequired = -1;

	/* compute live regs while noting the last occurrence of required regs.
	   If these are not free we must spill from simSpillBase to last occurrence.
	   Note we are conservative here; we could allocate FPReg in frameless methods. */
	lastRequiredNative = -1;
	/* begin registerMaskFor:and: */
	liveRegs = (1U << FPReg) | (1U << SPReg);
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= stackPtr; i += 1) {
		liveRegs = liveRegs | (registerMask(simStackAt(i)));
		if ((((registerMask(simStackAt(i))) & requiredRegsMask) != 0)) {
			lastRequired = i;
		}
	}
	assert(nativeStackPtr == simNativeStackPtr);
	for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= nativeStackPtr; i += 1) {
		liveRegs = liveRegs | (nativeRegisterMask(simNativeStackAt(i)));
		if ((((nativeRegisterMask(simNativeStackAt(i))) & requiredRegsMask) != 0)) {
			lastRequiredNative = i;
		}
	}
	if (((liveRegs & requiredRegsMask) != 0)) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= lastRequired) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < lastRequired) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : lastRequired)); i1 <= lastRequired; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = lastRequired + 1;
		}
		assert(!(((((liveRegisters()) & requiredRegsMask) != 0))));
	}
}


/*	Any occurrences on the stack of the value being stored (which is the top
	of stack)
	must be flushed, and hence any values colder than them stack. */

	/* StackToRegisterMappingCogit>>#ssFlushUpThroughReceiverVariable: */
static void NoDbgRegParms
ssFlushUpThroughReceiverVariable(sqInt slotIndex)
{
    sqInt i;
    sqInt index;

	ssNativeFlushTo(simNativeStackPtr);
	/* begin ssFlushUpThrough: */
	assert(simSpillBase >= 0);
	for (index = (simStackPtr - 1); index >= simSpillBase; index += -1) {
		if (((((simStackAt(index))->type)) == SSBaseOffset)
		 && (((((simStackAt(index))->registerr)) == ReceiverResultReg)
		 && ((((simStackAt(index))->offset)) == (slotOffsetOfInstVarIndex(slotIndex))))) {
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= index) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = index + 1;
			}
			return;
		}
	}
	return;
}


/*	Any occurrences on the stack of the value being stored (which is the top
	of stack)
	must be flushed, and hence any values colder than them stack. */

	/* StackToRegisterMappingCogit>>#ssFlushUpThroughTemporaryVariable: */
static void NoDbgRegParms
ssFlushUpThroughTemporaryVariable(sqInt tempIndex)
{
    sqInt i;
    sqInt index;
    sqInt offset;

	ssNativeFlushTo(simNativeStackPtr);
	offset = ((simStackAt(tempIndex + 1))->offset);
	assert(offset == (frameOffsetOfTemporary(tempIndex)));
	/* begin ssFlushUpThrough: */
	assert(simSpillBase >= 0);
	for (index = (simStackPtr - 1); index >= simSpillBase; index += -1) {
		if (((((simStackAt(index))->type)) == SSBaseOffset)
		 && (((((simStackAt(index))->registerr)) == FPReg)
		 && ((((simStackAt(index))->offset)) == offset))) {
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= index) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = index + 1;
			}
			return;
		}
	}
	return;
}

	/* StackToRegisterMappingCogit>>#ssNativeFlushTo: */
static void NoDbgRegParms
ssNativeFlushTo(sqInt index)
{
    sqInt allocatedScratchRegister;
    sqInt i;
    sqInt loadedPointer;
    sqInt offset;
    sqInt offset1;

	if (simNativeSpillBase <= index) {
		loadedPointer = 0;
		allocatedScratchRegister = 0;
		for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= index; i += 1) {
			if (!loadedPointer) {
				/* begin MoveMw:r:R: */
				offset = frameOffsetOfNativeFramePointer();
				genoperandoperandoperand(MoveMwrR, offset, FPReg, TempReg);
				loadedPointer = 1;
			}
			if ((spillingNeedsScratchRegister(simNativeStackAt(i)))
			 && (!allocatedScratchRegister)) {
				/* begin PushR: */
				genoperand(PushR, FPReg);
				allocatedScratchRegister = 1;
			}
			ensureSpilledSPscratchRegister(simNativeStackAt(i), TempReg, FPReg);
		}
		simNativeSpillBase = index + 1;
		if (allocatedScratchRegister) {
			/* begin PopR: */
			genoperand(PopR, FPReg);
		}
		if (loadedPointer) {
			/* begin SubCq:R: */
			genoperandoperand(SubCqR, simNativeStackSize, TempReg);
			/* begin MoveR:Mw:r: */
			offset1 = frameOffsetOfNativeStackPointer();
			genoperandoperandoperand(MoveRMwr, TempReg, offset1, FPReg);
		}
	}
}

	/* StackToRegisterMappingCogit>>#ssNativePop: */
static void NoDbgRegParms
ssNativePop(sqInt n)
{
	assert((simNativeStackPtr - n) >= -1);
	simNativeStackPtr -= n;
	if (simNativeStackPtr >= 0) {
		simNativeStackSize = ((ssNativeTop())->offset);
	}
	else {
		simNativeStackSize = 0;
	}
}

	/* StackToRegisterMappingCogit>>#ssNativePush: */
static void NoDbgRegParms
ssNativePush(sqInt n)
{
	simNativeStackPtr += n;
}

	/* StackToRegisterMappingCogit>>#ssNativeTop */
static CogSimStackNativeEntry *
ssNativeTop(void)
{
	assert(simNativeStackPtr >= 0);
	return simNativeStackAt(simNativeStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssNativeValue: */
static CogSimStackNativeEntry * NoDbgRegParms
ssNativeValue(sqInt n)
{
	return simNativeStackAt(simNativeStackPtr - n);
}

	/* StackToRegisterMappingCogit>>#ssPopNativeSize: */
static void NoDbgRegParms
ssPopNativeSize(sqInt popSize)
{
    sqInt popCount;
    sqInt poppingSize;
    sqInt stackPosition;

	poppingSize = 0;
	stackPosition = simNativeStackPtr;
	while ((poppingSize < popSize)
	 && (stackPosition >= 0)) {
		poppingSize += stackSpillSize(simNativeStackAt(stackPosition));
		stackPosition -= 1;
	}
	assert(poppingSize == popSize);
	popCount = simNativeStackPtr - stackPosition;
	ssNativePop(popCount);
}

	/* StackToRegisterMappingCogit>>#ssPop: */
static void NoDbgRegParms
ssPop(sqInt n)
{
    sqInt i;

	assert(((simStackPtr - n) >= methodOrBlockNumTemps)
	 || (((!needsFrame)
	 && ((simStackPtr - n) >= 0))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil())));
	simStackPtr -= n;
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return;
}

	/* StackToRegisterMappingCogit>>#ssPushAnnotatedConstant: */
static sqInt NoDbgRegParms
ssPushAnnotatedConstant(sqInt literal)
{
    AbstractInstruction *abstractInstruction;

	ssPushConstant(literal);
	/* begin annotateInstructionForBytecode */
	
	if (prevInstIsPCAnnotated()) {
		/* begin Nop */
		abstractInstruction = gen(Nop);
	}
	else {
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	(abstractInstruction->annotation = HasBytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushBase:offset: */
static sqInt NoDbgRegParms
ssPushBaseoffset(sqInt reg, sqInt offset)
{
    CogSimStackEntry * cascade0;
    sqInt i;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSBaseOffset);
	(cascade0->spilled = 0);
	(cascade0->registerr = reg);
	(cascade0->offset = offset);
	(cascade0->bcptr = bytecodePC);
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushConstant: */
static sqInt NoDbgRegParms
ssPushConstant(sqInt literal)
{
    CogSimStackEntry * cascade0;
    sqInt i;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSConstant);
	(cascade0->spilled = 0);
	(cascade0->constant = literal);
	(cascade0->bcptr = bytecodePC);
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushDesc: */
static sqInt NoDbgRegParms
ssPushDesc(SimStackEntry simStackEntry)
{
    sqInt i;

	if (((simStackEntry.type)) == SSSpill) {
		(simStackEntry.type = SSBaseOffset);
	}
	(simStackEntry.spilled = 0);
	(simStackEntry.bcptr = bytecodePC);
	simStack[(simStackPtr += 1)] = simStackEntry;
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantFloat32: */
static sqInt NoDbgRegParms
ssPushNativeConstantFloat32(float aFloat32)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantFloat32);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantFloat32 = aFloat32);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantFloat64: */
static sqInt NoDbgRegParms
ssPushNativeConstantFloat64(double aFloat64)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += 8;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantFloat64);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantFloat64 = aFloat64);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantInt32: */
static sqInt NoDbgRegParms
ssPushNativeConstantInt32(sqInt anInt32)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantInt32);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantInt32 = anInt32);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantInt64: */
static sqInt NoDbgRegParms
ssPushNativeConstantInt64(sqLong anInt64)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += 8;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantInt64);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantInt64 = anInt64);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantPointer: */
static sqInt NoDbgRegParms
ssPushNativeConstantPointer(sqInt aNativePointer)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantNativePointer);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantNativePointer = aNativePointer);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeRegisterDoubleFloat: */
static sqInt NoDbgRegParms
ssPushNativeRegisterDoubleFloat(sqInt reg)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += 8;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSRegisterDoubleFloat);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeRegisterSingleFloat: */
static sqInt NoDbgRegParms
ssPushNativeRegisterSingleFloat(sqInt reg)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSRegisterSingleFloat);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeRegister: */
static sqInt NoDbgRegParms
ssPushNativeRegister(sqInt reg)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSNativeRegister);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeRegister:secondRegister: */
static sqInt NoDbgRegParms
ssPushNativeRegistersecondRegister(sqInt reg, sqInt secondReg)
{
    CogSimStackNativeEntry * cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += 8;
	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSRegisterPair);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->registerr = reg);
	(cascade0->registerSecond = secondReg);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushRegister: */
static sqInt NoDbgRegParms
ssPushRegister(sqInt reg)
{
    CogSimStackEntry * cascade0;
    sqInt i;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPush: */
static void NoDbgRegParms
ssPush(sqInt n)
{
	simStackPtr += n;
}

	/* StackToRegisterMappingCogit>>#ssSelfDescriptor */
static SimStackEntry
ssSelfDescriptor(void)
{
	return simStack[0];
}


/*	In addition to ssStorePop:toReg:, if this is a store and not
	a popInto I change the simulated stack to use the register 
	for the top value */

	/* StackToRegisterMappingCogit>>#ssStoreAndReplacePop:toReg: */
static void NoDbgRegParms
ssStoreAndReplacePoptoReg(sqInt popBoolean, sqInt reg)
{
    char topSpilled;

	topSpilled = ((ssTop())->spilled);
	ssStorePoptoReg(popBoolean
	 || (topSpilled), reg);
	if (!popBoolean) {
		if (!topSpilled) {
			ssPop(1);
		}
		ssPushRegister(reg);
	}
}


/*	Store or pop the top simulated stack entry to a register.
	Use preferredReg if the entry is not itself a register.
	Answer the actual register the result ends up in. */

	/* StackToRegisterMappingCogit>>#ssStorePop:toPreferredReg: */
static sqInt NoDbgRegParms
ssStorePoptoPreferredReg(sqInt popBoolean, sqInt preferredReg)
{
    sqInt actualReg;

	actualReg = preferredReg;
	if ((((ssTop())->type)) == SSRegister) {
		assert(!(((ssTop())->spilled)));
		actualReg = ((ssTop())->registerr);
	}
	ssStorePoptoReg(popBoolean, actualReg);
	return actualReg;
}


/*	Store or pop the top simulated stack entry to a register.
	N.B.: popToReg: and storeToReg: does not generate anything if 
	it moves a register to the same register. */

	/* StackToRegisterMappingCogit>>#ssStorePop:toReg: */
static void NoDbgRegParms
ssStorePoptoReg(sqInt popBoolean, sqInt reg)
{
	if (popBoolean) {
		popToReg(ssTop(), reg);
		ssPop(1);
	}
	else {
		storeToReg(ssTop(), reg);
	}
}

	/* StackToRegisterMappingCogit>>#ssTop */
static CogSimStackEntry *
ssTop(void)
{
	return simStackAt(simStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssValue: */
static CogSimStackEntry * NoDbgRegParms
ssValue(sqInt n)
{
	return simStackAt(simStackPtr - n);
}

	/* StackToRegisterMappingCogit>>#stackEntryIsBoolean: */
static sqInt NoDbgRegParms
stackEntryIsBoolean(CogSimStackEntry *simStackEntry)
{
	return (((simStackEntry->type)) == SSConstant)
	 && ((((simStackEntry->constant)) == (trueObject()))
	 || (((simStackEntry->constant)) == (falseObject())));
}


/*	Answer if the stack is valid up to, but not including, simSpillBase. */

	/* StackToRegisterMappingCogit>>#tempsValidAndVolatileEntriesSpilled */
static sqInt
tempsValidAndVolatileEntriesSpilled(void)
{
    sqInt culprit;
    sqInt i;

	culprit = 0;
	for (i = 1; i <= methodOrBlockNumTemps; i += 1) {
		if (!(((((simStackAt(i))->type)) == SSBaseOffset)
			 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()))) {
			if (!culprit) {
				culprit = i;
			}
			return 0;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i < simSpillBase; i += 1) {
		if (!(((simStackAt(i))->spilled))) {
			if (!culprit) {
				culprit = i;
			}
			return 0;
		}
	}
	return 1;
}


/*	If the sequence of bytecodes is
	push: (Array new: 1)
	popIntoTemp: tempIndex
	pushConstant: const or pushTemp: n
	popIntoTemp: 0 inVectorAt: tempIndex
	collapse this into
	tempAt: tempIndex put: {const or temp}
	and answer true, otherwise answer false.
	One might think that we should look for a sequence of more than
	one pushes and pops but this is extremely rare.
	Exclude pushRcvr: n to avoid potential complications with context inst
	vars.  */

	/* StackToRegisterMappingCogit>>#tryCollapseTempVectorInitializationOfSize: */
static sqInt NoDbgRegParms
tryCollapseTempVectorInitializationOfSize(sqInt slots)
{
    sqInt pc;
    sqInt pc1;
    sqInt pc2;
    BytecodeDescriptor *pushArrayDesc;
    BytecodeDescriptor *pushValueDesc;
    sqInt reg;
    sqInt remoteTempIndex;
    BytecodeDescriptor *storeArrayDesc;
    BytecodeDescriptor *storeValueDesc;
    sqInt tempIndex;

	if (slots != 1) {
		return 0;
	}
	/* begin generatorForPC: */
	pushArrayDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(bytecodePC, methodObj)));
	assert(((pushArrayDesc->generator)) == genPushNewArrayBytecode);
	/* begin generatorForPC: */
	pc = bytecodePC + ((pushArrayDesc->numBytes));
	storeArrayDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
	if (((storeArrayDesc->generator)) == genStoreAndPopTemporaryVariableBytecode) {
		tempIndex = (fetchByteofObject(bytecodePC + ((pushArrayDesc->numBytes)), methodObj)) & 7;
	}
	else {
		if (!(((storeArrayDesc->generator)) == genLongStoreAndPopTemporaryVariableBytecode)) {
			return 0;
		}
		tempIndex = fetchByteofObject((bytecodePC + ((pushArrayDesc->numBytes))) + 1, methodObj);
	}
	/* begin generatorForPC: */
	pc1 = (bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes));
	pushValueDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc1, methodObj)));
	if (!((((pushValueDesc->generator)) == genPushLiteralConstantBytecode)
		 || ((((pushValueDesc->generator)) == genPushQuickIntegerConstantBytecode)
		 || (((pushValueDesc->generator)) == genPushTemporaryVariableBytecode)))) {
		return 0;
	}
	/* begin generatorForPC: */
	pc2 = ((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes));
	storeValueDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc2, methodObj)));
	remoteTempIndex = fetchByteofObject((((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes))) + 2, methodObj);
	if (!((((storeValueDesc->generator)) == genStoreAndPopRemoteTempLongBytecode)
		 && (tempIndex == remoteTempIndex))) {
		return 0;
	}
	genNewArrayOfSizeinitialized(1, 0);
	evaluateat(pushValueDesc, (bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes)));
	reg = ssStorePoptoPreferredReg(1, TempReg);
	genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, 0, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
	evaluateat(storeArrayDesc, bytecodePC + ((pushArrayDesc->numBytes)));

	/* + pushArrayDesc numBytes this gets added by nextBytecodePCFor:at:exts:in: */
	bytecodePC = ((bytecodePC + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes))) + ((storeValueDesc->numBytes));
	return 1;
}

	/* StackToRegisterMappingCogit>>#violatesEnsureSpilledSpillAssert */
static sqInt
violatesEnsureSpilledSpillAssert(void)
{
	return 1;
}


/*	Used when ReceiverResultReg is allocated for other than simSelf, and
	there may be references to ReceiverResultReg which need to be spilled. */

	/* StackToRegisterMappingCogit>>#voidReceiverResultRegContainsSelf */
static void
voidReceiverResultRegContainsSelf(void)
{
    sqInt i;
    sqInt i1;
    sqInt spillIndex;

	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	spillIndex = 0;
	for (i = ((((methodOrBlockNumTemps + 1) < simSpillBase) ? simSpillBase : (methodOrBlockNumTemps + 1))); i <= simStackPtr; i += 1) {
		if ((registerOrNone(simStackAt(i))) == ReceiverResultReg) {
			spillIndex = i;
		}
	}
	if (spillIndex > 0) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= spillIndex) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < spillIndex) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : spillIndex)); i1 <= spillIndex; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = spillIndex + 1;
		}
	}
}
