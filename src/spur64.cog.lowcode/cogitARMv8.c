/* Automatically generated by
	CCodeGenerator VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
   from
	StackToRegisterMappingCogit VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
 */
static char __buildInfo[] = "StackToRegisterMappingCogit VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3 " __DATE__ ;
char *__cogitBuildInfo = __buildInfo;



#include "sqConfig.h"
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sqPlatformSpecific.h"
#include "sqMemoryAccess.h"
#include "sqCogStackAlignment.h"
#include "dispdbg.h"
#include "cogmethod.h"
#if COGMTVM
#include "cointerpmt.h"
#else
#include "cointerp.h"
#endif
#include "cogit.h"


/* Cogit class>>preambleCCode */
#if __APPLE__ && __MACH__ // Mac OS X
# include <libkern/OSCacheControl.h>
#endif
#if __linux__
# include <sys/auxv.h>
#endif
/* end Cogit class>>preambleCCode */


/*** Constants ***/
#define ABICalleeSavedRegisterMask 0x1FF80000
#define ABICallerSavedRegisterMask 0x3FFFF
#define ABIResultReg 0
#define AddCqR 106
#define AddCqRR 123
#define AddCwR 114
#define AddRdRd 132
#define AddRR 100
#define AddRRR 126
#define AddRsRs 139
#define AL 14
#define AlignmentNops 3
#define AltBlockCreationBytecodeSize 3
#define AltFirstSpecialSelector 96
#define AltNumSpecialSelectors 32
#define AndCqR 108
#define AndCqRR 124
#define AndCwR 116
#define AndRR 102
#define AnnotationShift 5
#define Arg0Reg 7
#define Arg1Reg 8
#define ArithmeticAdd 0
#define ArithmeticAddS 1
#define ArithmeticShiftRightCqR 91
#define ArithmeticShiftRightCqRR 128
#define ArithmeticShiftRightRR 92
#define ArithmeticSub 2
#define ArithmeticSubS 3
#define BadRegisterSet 1
#define BlockCreationBytecodeSize 4
#define BytecodeSetHasDirectedSuperSend 1
#define CArg0Reg 0
#define CArg1Reg 1
#define CArg2Reg 2
#define CArg3Reg 3
#define CASAL 176
#define Call 6
#define CallerSavedRegisterMask 0x1F0
#define CallFull 7
#define CallR 8
#define CBNZ 177
#define CBZ 178
#define CC 3
#define CCMPNE 179
#if !defined(CheckRememberedInTrampoline) /* Allow this to be overridden on the compiler command line */
# define CheckRememberedInTrampoline 0
#endif
#define CLREX 181
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBlockClosureCompactIndex 37
#define ClassFloatCompactIndex 34
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMethodContextCompactIndex 36
#define ClassPointCompactIndex 54
#define ClassReg 4
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define ClzRR 157
#define CMBlock 4
#define CMClosedPIC 2
#define CMFree 1
#define CMMaxUsageCount 7
#define CMMethod 5
#define CMMethodFlaggedForBecome 6
#define CMOpenPIC 3
#define CmpC32R 113
#define CmpCqR 105
#define CmpCwR 112
#define CmpRdRd 131
#define CmpRR 99
#define CmpRsRs 138
#define CompletePrimitive 4
#define ConstZero 1
#define ConvertRdR 146
#define ConvertRdRs 148
#define ConvertRRd 145
#define ConvertRRs 150
#define ConvertRsR 149
#define ConvertRsRd 147
#define CS 2
#define CSET 180
#define DC 169
#define DC_CIVAC 14
#define DC_CVAC 16
#define DC_CVAU 19
#if !defined(Debug) /* Allow this to be overridden on the compiler command line */
# define Debug DEBUGVM
#endif
#define DisplacementMask 0x1F
#define DisplacementX2N 0
#define DivRdRd 135
#define DivRRR 163
#define DivRsRs 142
#define DPFPReg0 0
#define DPFPReg1 1
#define DPFPReg2 2
#define DPFPReg3 3
#define DPFPReg4 4
#define DPFPReg5 5
#define DPFPReg6 6
#define DPFPReg7 7
#define DSB 172
#define DSB_ALL 3
#define DSB_ISH 2
#define EncounteredUnknownBytecode -6
#define EQ 0
#define Extra0Reg 19
#define Extra1Reg 20
#define Extra2Reg 21
#define Fill32 4
#define FirstAnnotation 64
#define FirstJump 12
#define FirstSpecialSelector 176
#define FoxCallerSavedIP 8
#define FoxIFSavedIP -32
#define FoxMethod -8
#define FoxMFReceiver -24
#define FoxSavedFP 0
#define FoxThisContext -16
#define FP 29
#define FPReg 29
#define FullClosureCompiledBlockIndex 1
#define FullClosureFirstCopiedValueIndex 4
#define FullClosureReceiverIndex 3
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define GE 10
#define GT 12
#define HasBytecodePC 5
#define HashMultiplyConstant 1664525
#define HashMultiplyMask 0xFFFFFFF
#define HeaderIndex 0
#define HI 8
#define IC 170
#define IC_IVAU 2
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 1
#endif
#define InFullBlock 2
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define InsufficientCodeSpace -2
#define InVanillaBlock 1
#define ISB 173
#define IsAbsPCReference 3
#define IsAnnotationExtension 1
#define IsDirectedSuperBindingSend 10
#define IsDirectedSuperSend 9
#define IsDisplacementX2N 0
#define IsNSSendCall null
#define IsObjectReference 2
#define IsRelativeCall 4
#define IsSendCall 7
#define IsSuperSend 8
#define Jump 16
#define JumpAbove 33
#define JumpAboveOrEqual 32
#define JumpBelow 31
#define JumpBelowOrEqual 34
#define JumpCarry 25
#define JumpFPEqual 35
#define JumpFPGreater 39
#define JumpFPGreaterOrEqual 40
#define JumpFPLess 37
#define JumpFPLessOrEqual 38
#define JumpFPNotEqual 36
#define JumpFPOrdered 41
#define JumpFPUnordered 42
#define JumpFull 12
#define JumpGreater 29
#define JumpGreaterOrEqual 28
#define JumpLess 27
#define JumpLessOrEqual 30
#define JumpLong 13
#define JumpLongNonZero 15
#define JumpLongZero 14
#define JumpMulOverflow 23
#define JumpNegative 19
#define JumpNoCarry 26
#define JumpNoMulOverflow 24
#define JumpNonNegative 20
#define JumpNonZero 18
#define JumpNoOverflow 22
#define JumpOverflow 21
#define JumpR 10
#define JumpZero 17
#define Label 1
#define LargeContextSlots 62
#define LastJump 42
#define LDAXR 182
#define LE 13
#define LinkReg 30
#define Literal 2
#define LiteralStart 1
#define LoadEffectiveAddressMwrR 88
#define LogicalAndS 3
#define LogicalOr 1
#define LogicalShiftLeftCqR 95
#define LogicalShiftLeftCqRR 129
#define LogicalShiftLeftRR 96
#define LogicalShiftRightCqR 93
#define LogicalShiftRightCqRR 130
#define LogicalShiftRightRR 94
#define LogicalXor 2
#define LowcodeContextMark 60
#define LR 30
#define LS 9
#define LT 11
#define MapEnd 0
#define MaxCompiledPrimitiveIndex 582
#define MaxCPICCases 6
#define MaxMethodSize 65535
#define MaxNegativeErrorCode -8
#define MaxStackAllocSize 1572864
#define MaxStackCheckOffset 0xFFF
#define MaxX2NDisplacement 992
#define MethodCacheClass 2
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCacheSelector 1
#define MethodIndex 3
#define MethodTooBig -4
#define MFMethodFlagHasContextFlag 1
#define MFMethodFlagIsBlockFlag 2
#define MI 4
#define MoveAbR 48
#define MoveAwR 44
#define MoveAwRR 165
#define MoveC32R 71
#define MoveCqR 69
#define MoveCwR 70
#define MoveM16rR 57
#define MoveM32rR 61
#define MoveM32rRs 78
#define MoveM64rRd 75
#define MoveM8rR 54
#define MoveMbrR 65
#define MoveMwrR 50
#define MovePerfCnt64RL 159
#define MoveRAb 49
#define MoveRAw 46
#define MoveRdM64r 76
#define MoveRdR 73
#define MoveRdRd 74
#define MoveRM16r 58
#define MoveRM32r 62
#define MoveRM8r 56
#define MoveRMbr 66
#define MoveRMwr 51
#define MoveRR 43
#define MoveRRAw 166
#define MoveRRd 72
#define MoveRsM32r 79
#define MoveRsRs 77
#define MoveRX16rR 60
#define MoveRX32rR 64
#define MoveRXbrR 68
#define MoveRXwrR 53
#define MoveX16rRR 59
#define MoveX32rRR 63
#define MoveXbrRR 67
#define MoveXwrRR 52
#define MRS_CTR_EL0 174
#define MRS_ID_AA64ISAR0_EL1 175
#define MSubRRR 164
#define MulOverflowRRR 161
#define MulRdRd 134
#define MulRRR 160
#define MulRsRs 141
#define NativePopR 84
#define NativePopRR 168
#define NativePushR 85
#define NativePushRR 167
#define NativeRetN 86
#define NativeSPReg 31
#define NE 1
#define NeedsMergeFixupFlag 2
#define NeedsNonMergeFixupFlag 1
#define NegateR 89
#define NOP 3573751839U
#define Nop 5
#define NoReg -1
#define NotFullyInitialized -1
#define NotR 90
#define NumObjRefsInRuntime 0
#define NumSendTrampolines 4
#define NumSpecialSelectors 32
#define NumStoreTrampolines 5
#define NumTrampolines (82 + (IMMUTABILITY ? 5 : 0))
#define OrCqR 109
#define OrCqRR 125
#define OrCwR 117
#define OrRR 103
#define PL 5
#define PopR 80
#define PrefetchAw 87
#define PrimCallCollectsProfileSamples 16
#define PrimCallIsExternalCall 32
#define PrimCallMayEndureCodeCompaction 8
#define PrimCallNeedsNewMethod 4
#define PrimCallOnSmalltalkStack 1
#define PrimCallOnSmalltalkStackAlign2x 2
#define PrimNumberExternalCall 117
#define PrimNumberFFICall 120
#define PushCq 82
#define PushCw 83
#define PushR 81
#define R0 0
#define R1 1
#define R17 17
#define ReceiverIndex 5
#define ReceiverResultReg 5
#define RetN 9
#define RISCTempReg 9
#define RotateLeftCqR 97
#define RotateRightCqR 98
#define SelectorCannotInterpret 34
#define SelectorDoesNotUnderstand 20
#define SenderIndex 0
#define SendNumArgsReg 6
#define ShouldNotJIT -8
#define SignExtend16RR 152
#define SignExtend32RR 153
#define SignExtend8RR 151
#define SmallContextSlots 22
#define SP 31
#define SPReg 16
#define SpecialSelectors 23
#define SqrtRd 136
#define SqrtRs 143
#define SSBaseOffset 1
#define SSConstant 2
#define SSConstantFloat32 15
#define SSConstantFloat64 16
#define SSConstantInt32 13
#define SSConstantInt64 14
#define SSConstantNativePointer 17
#define SSNativeRegister 5
#define SSRegister 3
#define SSRegisterDoubleFloat 7
#define SSRegisterPair 6
#define SSRegisterSingleFloat 8
#define SSSpill 4
#define SSSpillFloat32 11
#define SSSpillFloat64 12
#define SSSpillInt64 10
#define SSSpillNative 9
#define STLR 184
#define STLXR 183
#define StackPointerIndex 2
#define Stop 11
#define SubCqR 107
#define SubCwR 115
#define SubRdRd 133
#define SubRR 101
#define SubRRR 127
#define SubRsRs 140
#define SXTX 7
#define TempReg 0
#define TstCqR 110
#define UnfailingPrimitive 3
#define UnimplementedPrimitive -7
#define UXTX 3
#define ValueIndex 1
#define VarBaseReg 28
#define VC 7
#define VS 6
#define XorCqR 111
#define XorCwR 118
#define XorRdRd 137
#define XorRR 104
#define XorRsRs 144
#define XZR 31
#define YoungSelectorInPIC -5
#define ZeroExtend16RR 155
#define ZeroExtend32RR 156
#define ZeroExtend8RR 154

typedef struct _AbstractInstruction {
	unsigned char	opcode;
	unsigned char	machineCodeSize;
	unsigned char	maxSize;
	unsigned char	annotation;
	unsigned int		machineCode[3];
	usqInt		operands[3];
	usqInt	address;
	struct _AbstractInstruction *dependent;
 } AbstractInstruction;

#define CogARMv8Compiler AbstractInstruction
#define CogAbstractInstruction AbstractInstruction


typedef struct {
	AbstractInstruction *fakeHeader;
	AbstractInstruction *fillInstruction;
	sqInt	numArgs;
	sqInt	numCopied;
	sqInt	numInitialNils;
	sqInt	startpc;
	AbstractInstruction *entryLabel;
	AbstractInstruction *stackCheckLabel;
	sqInt	span;
	sqInt	hasInstVarRef;
 } BlockStart;

#define CogBlockStart BlockStart


typedef struct _BytecodeDescriptor {
	sqInt (*generator)(void);
	sqInt NoDbgRegParms (*spanFunction)(struct _BytecodeDescriptor *,sqInt,sqInt,sqInt);
	sqInt NoDbgRegParms (*needsFrameFunction)(sqInt);
	signed char	stackDelta;
	unsigned char	opcode;
	unsigned char	numBytes;
	unsigned		isBranchTrue : 1;
	unsigned		isBranchFalse : 1;
	unsigned		isReturn : 1;
	unsigned		isBlockCreation : 1;
	unsigned		isMapped : 1;
	unsigned		isMappedInBlock : 1;
	unsigned		isExtension : 1;
	unsigned		isInstVarRef : 1;
	unsigned		is1ByteInstVarStore : 1;
	unsigned		hasUnsafeJump : 1;
 } BytecodeDescriptor;

#define CogBytecodeDescriptor BytecodeDescriptor


typedef struct {
	sqInt (*primitiveGenerator)(void);
	sqInt	primNumArgs;
 } PrimitiveDescriptor;

#define CogPrimitiveDescriptor PrimitiveDescriptor


typedef struct {
	char	type;
	char	spilled;
	signed char	liveRegister;
	signed char	registerr;
	sqInt	offset;
	sqInt	constant;
	sqInt	bcptr;
 } SimStackEntry;

#define CogSimStackEntry SimStackEntry


typedef struct {
	AbstractInstruction *targetInstruction;
	unsigned char	simStackPtr;
	char	isTargetOfBackwardBranch;
	unsigned short	instructionIndex;
	short	simNativeStackPtr;
	unsigned short	simNativeStackSize;
 } BytecodeFixup;

#define CogSSBytecodeFixup BytecodeFixup
#define CogBytecodeFixup BytecodeFixup


typedef struct {
	sqInt	isReceiverResultRegLive;
	CogSimStackEntry *ssEntry;
 } CogSSOptStatus;


typedef struct {
	char	type;
	char	spilled;
	sqInt	registerr;
	sqInt	registerSecond;
	sqInt	offset;
	sqInt	constant;
	sqInt	constantInt32;
	sqLong	constantInt64;
	float	constantFloat32;
	double	constantFloat64;
	sqInt	constantNativePointer;
	sqInt	bcptr;
 } CogSimStackNativeEntry;



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

static NoDbgRegParms AbstractInstruction * addDependent(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *anInstruction);
static NoDbgRegParms sqInt availableFloatRegisterOrNoneFor(AbstractInstruction *self_in_CogAbstractInstruction, sqInt liveRegsMask);
static NoDbgRegParms sqInt availableRegisterOrNoneFor(AbstractInstruction *self_in_CogAbstractInstruction, sqInt liveRegsMask);
static NoDbgRegParms AbstractInstruction * cloneLiteralFrom(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *existingLiteral);
static NoDbgRegParms sqInt concretizeAt(AbstractInstruction *self_in_CogAbstractInstruction, sqInt actualAddress);
static NoDbgRegParms sqInt genLoadCStackPointer(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms sqInt genLoadStackPointerForPrimCall(AbstractInstruction *self_in_CogAbstractInstruction, sqInt spareReg);
static NoDbgRegParms sqInt genLoadStackPointersForPrimCall(AbstractInstruction *self_in_CogAbstractInstruction, sqInt spareReg);
static NoDbgRegParms AbstractInstruction * genSwapRRScratch(AbstractInstruction *self_in_CogAbstractInstruction, sqInt regA, sqInt regB, sqInt regTmp);
static NoDbgRegParms AbstractInstruction * genWriteCResultIntoReg(AbstractInstruction *self_in_CogAbstractInstruction, sqInt abstractRegister);
static NoDbgRegParms AbstractInstruction * genWriteCSecondResultIntoReg(AbstractInstruction *self_in_CogAbstractInstruction, sqInt abstractRegister);
static NoDbgRegParms sqInt has64BitPerformanceCounter(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms AbstractInstruction * initializeSharableLiteral(AbstractInstruction *self_in_CogAbstractInstruction, sqInt literal);
static NoDbgRegParms AbstractInstruction * initializeUniqueLiteral(AbstractInstruction *self_in_CogAbstractInstruction, sqInt literal);
static NoDbgRegParms AbstractInstruction * jmpTarget(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *anAbstractInstruction);
static NoDbgRegParms AbstractInstruction * relocateJumpLongBeforeFollowingAddressby(AbstractInstruction *self_in_CogAbstractInstruction, sqInt pc, sqInt delta);
static NoDbgRegParms AbstractInstruction * relocateJumpLongConditionalBeforeFollowingAddressby(AbstractInstruction *self_in_CogAbstractInstruction, sqInt pc, sqInt delta);
static NoDbgRegParms AbstractInstruction * resolveJumpTarget(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms sqInt rewriteCallFullAttarget(AbstractInstruction *self_in_CogAbstractInstruction, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static NoDbgRegParms sqInt rewriteConditionalJumpLongAttarget(AbstractInstruction *self_in_CogAbstractInstruction, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static NoDbgRegParms sqInt addrnrdimmshiftBy12(AbstractInstruction *self_in_CogARMv8Compiler, sqInt rn, sqInt rd, sqInt offset, sqInt shiftBy12);
static NoDbgRegParms sqInt brlinkreg(AbstractInstruction *self_in_CogARMv8Compiler, sqInt link, sqInt reg);
static NoDbgRegParms sqInt callFullInstructionByteSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt callInstructionByteSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt callTargetFromReturnAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc);
static NoDbgRegParms sqInt cmpC32RTempByteSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt computeJumpTargetOffset(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt computeLowBit(AbstractInstruction *self_in_CogARMv8Compiler, sqInt nArg);
static NoDbgRegParms sqInt computeMaximumSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeConditionalJump(AbstractInstruction *self_in_CogARMv8Compiler, sqInt conditionCode);
static NoDbgRegParms sqInt concretizeCwRArithmeticRd(AbstractInstruction *self_in_CogARMv8Compiler, sqInt arithOp, sqInt destRegOrXZR);
static NoDbgRegParms sqInt concretizeCwRLogical(AbstractInstruction *self_in_CogARMv8Compiler, sqInt op);
static NoDbgRegParms sqInt concretizeDataCacheControl(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeFill32(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeLiteral(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeLoadEffectiveAddressMwrR(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeLogicalOpCqRDest(AbstractInstruction *self_in_CogARMv8Compiler, sqInt op, sqInt destReg);
static NoDbgRegParms sqInt concretizeMoveCqR(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeMoveMSrR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne);
static NoDbgRegParms sqInt concretizeMovePerfCnt64RL(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeMoveRMSr(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne);
static NoDbgRegParms sqInt concretizeMoveRXSrR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne);
static NoDbgRegParms sqInt concretizeMoveXSrRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne);
static NoDbgRegParms sqInt concretizeMulOverflowJump(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeRRArithmeticRd(AbstractInstruction *self_in_CogARMv8Compiler, sqInt arithOp, sqInt rd);
static NoDbgRegParms sqInt concretizeRRLogical(AbstractInstruction *self_in_CogARMv8Compiler, sqInt logicalOp);
static NoDbgRegParms sqInt concretizeSignExtendRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt width);
static NoDbgRegParms sqInt concretizeSTLR(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt concretizeZeroExtendRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt width);
static NoDbgRegParms sqInt countLeadingOnes(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger);
static NoDbgRegParms sqInt countTrailingOnes(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger);
static NoDbgRegParms sqInt countTrailingZeros(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger);
static NoDbgRegParms usqInt decodeNimmsimmr(AbstractInstruction *self_in_CogARMv8Compiler, sqInt n, sqInt imms, sqInt immr);
#if __linux__
static NoDbgRegParms AbstractInstruction * detectFeaturesOnLinux(AbstractInstruction *self_in_CogARMv8Compiler);
#endif /* __linux__ */
#if !__APPLE__ && !__linux__
static NoDbgRegParms AbstractInstruction * detectFeaturesOnRawMachine(AbstractInstruction *self_in_CogARMv8Compiler);
#endif /* !__APPLE__ && !__linux__ */
static NoDbgRegParms sqInt dispatchConcretize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt emitLdfprnrtimmshiftBy12at(AbstractInstruction *self_in_CogARMv8Compiler, sqInt baseReg, sqInt targetDPReg, sqInt offset, sqInt shiftBy12, sqInt instrOffset);
static NoDbgRegParms sqInt emitLdrnrtimmshiftBy12at(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne, sqInt baseReg, sqInt targetReg, sqInt offset, sqInt shiftBy12, sqInt instrOffset);
static NoDbgRegParms sqInt emitMoveCwintoRat(AbstractInstruction *self_in_CogARMv8Compiler, usqInt constantArg, sqInt destReg, sqInt offsetBytes);
static NoDbgRegParms sqInt emitStrnrtimmshiftBy12(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne, sqInt baseReg, sqInt sourceReg, sqInt offset, sqInt shiftBy12);
static NoDbgRegParms sqInt fullCallsAreRelative(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms AbstractInstruction * genDivRRQuoRem(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regDivisor, sqInt regDividend, sqInt regQuotient, sqInt regRemainder);
static NoDbgRegParms AbstractInstruction * generateDCacheFlush(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms AbstractInstruction * generateICacheFlush(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt genLoadCStackPointers(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms AbstractInstruction * genLoadNativeSPRegWithAlignedSPReg(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt genLoadStackPointers(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms AbstractInstruction * genMarshallNArgsargargargarg(AbstractInstruction *self_in_CogARMv8Compiler, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3);
static NoDbgRegParms AbstractInstruction * genMulOverflowRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regSource, sqInt regDest);
static NoDbgRegParms AbstractInstruction * genMulRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regSource, sqInt regDest);
static NoDbgRegParms AbstractInstruction * genPushRegisterArgsForAbortMissNumArgs(AbstractInstruction *self_in_CogARMv8Compiler, sqInt numArgs);
static NoDbgRegParms AbstractInstruction * genPushRegisterArgsForNumArgsscratchReg(AbstractInstruction *self_in_CogARMv8Compiler, sqInt numArgs, sqInt ignored);
static NoDbgRegParms sqInt genRemoveNArgsFromStack(AbstractInstruction *self_in_CogARMv8Compiler, sqInt n);
static NoDbgRegParms sqInt genRestoreRegs(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regMask);
static NoDbgRegParms sqInt genSaveRegs(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regMask);
static NoDbgRegParms sqInt genSaveStackPointers(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms AbstractInstruction * genSubstituteReturnAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt retpc);
static NoDbgRegParms sqInt hasVarBaseRegister(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms unsigned int inlineCacheTagAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt callSiteReturnAddress);
static NoDbgRegParms sqInt instructionAddressBefore(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc);
static NoDbgRegParms unsigned int instructionAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc);
static NoDbgRegParms int instructionIsADR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt word);
static NoDbgRegParms int instructionIsImm26BorBL(AbstractInstruction *self_in_CogARMv8Compiler, usqInt word);
static NoDbgRegParms int instructionIsLoadStore(AbstractInstruction *self_in_CogARMv8Compiler, sqInt instr);
static NoDbgRegParms int instructionIsPCRelativeLoad(AbstractInstruction *self_in_CogARMv8Compiler, sqInt instr);
static NoDbgRegParms sqInt instructionSizeAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc);
static NoDbgRegParms int inverseForArithOp(AbstractInstruction *self_in_CogARMv8Compiler, sqInt arithOp);
static NoDbgRegParms int isAddressRelativeToVarBase(AbstractInstruction *self_in_CogARMv8Compiler, usqInt varAddress);
static NoDbgRegParms sqInt isCallPrecedingReturnPC(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc);
static NoDbgRegParms int isFullJumpAtPC(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc);
static NoDbgRegParms sqInt isImm12orImm9offset(AbstractInstruction *self_in_CogARMv8Compiler, sqInt offset);
static NoDbgRegParms int isInImmediateBranchAndLinkRange(AbstractInstruction *self_in_CogARMv8Compiler, sqIntptr_t offset);
static NoDbgRegParms int isInImmediateBranchRange(AbstractInstruction *self_in_CogARMv8Compiler, usqIntptr_t offset);
static NoDbgRegParms int isInImmediateJumpRange(AbstractInstruction *self_in_CogARMv8Compiler, usqIntptr_t operand);
static NoDbgRegParms sqInt isInImmediateOffsetRange(AbstractInstruction *self_in_CogARMv8Compiler, sqInt offset);
static NoDbgRegParms sqInt isJump(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt isJumpAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc);
static NoDbgRegParms sqInt isPCDependent(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt isShiftedMask(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger);
static NoDbgRegParms sqInt isUnsigned12BitMultipleOf8(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger);
static NoDbgRegParms sqInt jumpLongByteSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt jumpLongConditionalByteSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt jumpLongTargetBeforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc);
static NoDbgRegParms usqInt jumpTargetPCAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc);
static NoDbgRegParms unsigned int literal32BeforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt followingAddress);
static NoDbgRegParms sqInt literalBeforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt followingAddress);
static NoDbgRegParms sqInt literalLoadInstructionBytes(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt loadLiteralByteSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt loadPICLiteralByteSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt machineCodeBytes(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt machineCodeWords(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt movernrd(AbstractInstruction *self_in_CogARMv8Compiler, sqInt srcReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * noteFollowingConditionalBranch(AbstractInstruction *self_in_CogARMv8Compiler, AbstractInstruction *branch);
static NoDbgRegParms sqInt numDCacheFlushOpcodes(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt numICacheFlushOpcodes(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt numIntRegArgs(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt outOfLineLiteralOpcodeLimit(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms AbstractInstruction * padIfPossibleWithStopsFromto(AbstractInstruction *self_in_CogARMv8Compiler, sqInt startAddr, sqInt endAddr);
static NoDbgRegParms sqInt pcRelativeAddressAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc);
static NoDbgRegParms sqInt prnimmshiftBy12(AbstractInstruction *self_in_CogARMv8Compiler, sqInt baseReg, sqInt offset, sqInt shiftBy12);
static NoDbgRegParms sqInt pushLinkRegisterByteSize(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms AbstractInstruction * relocateCallBeforeReturnPCby(AbstractInstruction *self_in_CogARMv8Compiler, sqInt retpc, sqInt delta);
static NoDbgRegParms AbstractInstruction * relocateMethodReferenceBeforeAddressby(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc, sqInt delta);
static NoDbgRegParms sqInt rewriteCallAttarget(AbstractInstruction *self_in_CogARMv8Compiler, usqInt callSiteReturnAddress, usqInt callTargetAddress);
static NoDbgRegParms sqInt rewriteImm19JumpBeforetarget(AbstractInstruction *self_in_CogARMv8Compiler, sqInt followingAddress, sqInt targetAddress);
static NoDbgRegParms sqInt rewriteImm26JumpBeforetarget(AbstractInstruction *self_in_CogARMv8Compiler, sqInt followingAddress, sqInt targetAddress);
static NoDbgRegParms sqInt rewriteInlineCacheAttagtarget(AbstractInstruction *self_in_CogARMv8Compiler, usqInt callSiteReturnAddress, sqInt cacheTag, usqInt callTargetAddress);
static NoDbgRegParms AbstractInstruction * rewriteInlineCacheTagat(AbstractInstruction *self_in_CogARMv8Compiler, sqInt cacheTag, sqInt callSiteReturnAddress);
static NoDbgRegParms sqInt rewriteJumpFullAttarget(AbstractInstruction *self_in_CogARMv8Compiler, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static NoDbgRegParms AbstractInstruction * setLiteralSize(AbstractInstruction *self_in_CogARMv8Compiler, sqInt sizeOfLiteral);
static NoDbgRegParms sqInt setsConditionCodesFor(AbstractInstruction *self_in_CogARMv8Compiler, sqInt aConditionalJumpOpcode);
static NoDbgRegParms unsigned char sizePCDependentInstructionAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt eventualAbsoluteAddress);
static NoDbgRegParms AbstractInstruction * stopsFromto(AbstractInstruction *self_in_CogARMv8Compiler, sqInt startAddr, sqInt endAddr);
static NoDbgRegParms AbstractInstruction * storeLiteral32beforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt literal, sqInt followingAddress);
static NoDbgRegParms AbstractInstruction * storeLiteralbeforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt literal, sqInt followingAddress);
static NoDbgRegParms sqInt strnrtimmshiftBy12(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne, sqInt baseReg, sqInt targetReg, sqInt offset, sqInt shiftBy12);
static NoDbgRegParms sqInt usesOutOfLineLiteral(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms sqInt zoneCallsAreRelative(AbstractInstruction *self_in_CogARMv8Compiler);
static NoDbgRegParms CogMethod * cmHomeMethod(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMBlock(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMClosedPIC(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMFree(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMMethodEtAl(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMOpenPIC(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms sqInt isBranch(BytecodeDescriptor *self_in_CogBytecodeDescriptor);
static NoDbgRegParms sqInt isConditionalBranch(BytecodeDescriptor *self_in_CogBytecodeDescriptor);
static NoDbgRegParms AbstractInstruction * gAddCqR(sqInt quickConstant, sqInt reg);
static NoDbgRegParms AbstractInstruction * gAddCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * gAndCqR(sqInt quickConstant, sqInt reg);
static NoDbgRegParms AbstractInstruction * gAndCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * gArithmeticShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
extern sqInt abortOffset(void);
static void addCleanBlockStarts(void);
extern void addCogMethodsToHeapMap(void);
static NoDbgRegParms sqInt addressIsInCurrentCompilation(sqInt address);
static NoDbgRegParms sqInt addressIsInFixups(BytecodeFixup *address);
static NoDbgRegParms sqInt addressOfEndOfCaseinCPIC(sqInt n, CogMethod *cPIC);
static void alignMethodZoneBase(void);
static NoDbgRegParms sqInt alignUptoRoutineBoundary(sqInt anAddress);
static sqInt allMachineCodeObjectReferencesValid(void);
static sqInt allMethodsHaveCorrectHeader(void);
static NoDbgRegParms AbstractInstruction * annotateAbsolutePCRef(AbstractInstruction *abstractInstruction);
static NoDbgRegParms AbstractInstruction * annotateBytecode(AbstractInstruction *abstractInstruction);
static NoDbgRegParms AbstractInstruction * annotateobjRef(AbstractInstruction *abstractInstruction, sqInt anOop);
static NoDbgRegParms void assertSaneJumpTarget(AbstractInstruction *jumpTarget);
static NoDbgRegParms sqInt availableRegisterOrNoneIn(sqInt liveRegsMask);
static NoDbgRegParms sqInt blockDispatchTargetsForperformarg(CogMethod *cogMethod, usqInt (*binaryFunction)(sqInt mcpc, sqInt arg), sqInt arg);
extern sqInt bytecodePCForstartBcpcin(sqInt mcpc, sqInt startbcpc, CogBlockMethod *cogMethod);
static NoDbgRegParms AbstractInstruction * CallRTregistersToBeSavedMask(sqInt callTarget, sqInt registersToBeSaved);
static NoDbgRegParms AbstractInstruction * gCmpCqR(sqInt quickConstant, sqInt reg);
static void callCogCodePopReceiver(void);
static void callCogCodePopReceiverAndClassRegs(void);
static NoDbgRegParms sqInt ceCPICMissreceiver(CogMethod *cPIC, sqInt receiver);
static NoDbgRegParms void ceFree(void *pointer);
static NoDbgRegParms void* ceMalloc(size_t size);
static NoDbgRegParms sqInt ceSICMiss(sqInt receiver);
static NoDbgRegParms sqInt checkIfValidOopRefAndTargetpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
static NoDbgRegParms sqInt checkIfValidOopRefpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
extern sqInt checkIntegrityOfObjectReferencesInCode(sqInt gcModes);
static NoDbgRegParms sqInt checkMaybeObjRefInClosedPIC(sqInt maybeObject);
static NoDbgRegParms sqInt checkValidObjectReferencesInClosedPIC(CogMethod *cPIC);
static NoDbgRegParms NeverInline sqInt cleanUpFailingCogCodeConstituents(CogMethod *cogMethodArg);
static NoDbgRegParms sqInt closedPICRefersToUnmarkedObject(CogMethod *cPIC);
extern char * codeEntryFor(char *address);
extern char * codeEntryNameFor(char *address);
extern sqInt cogCodeBase(void);
extern sqInt cogCodeConstituents(sqInt withDetails);
static NoDbgRegParms void cogExtendPICCaseNMethodtagisMNUCase(CogMethod *cPIC, sqInt caseNMethod, sqInt caseNTag, sqInt isMNUCase);
extern CogMethod * cogFullBlockMethodnumCopied(sqInt aMethodObj, sqInt numCopied);
extern void cogitPostGCAction(sqInt gcMode);
static NoDbgRegParms sqInt cogMethodDoesntLookKosher(CogMethod *cogMethod);
extern CogMethod * cogMNUPICSelectorreceivermethodOperandnumArgs(sqInt selector, sqInt rcvr, sqInt methodOperand, sqInt numArgs);
static NoDbgRegParms CogMethod * cogOpenPICSelectornumArgs(sqInt selector, sqInt numArgs);
static NoDbgRegParms CogMethod * cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase(sqInt selector, sqInt numArgs, CogMethod *case0CogMethod, sqInt case1MethodOrNil, sqInt case1Tag, sqInt isMNUCase);
extern CogMethod * cogselector(sqInt aMethodObj, sqInt aSelectorOop);
static NoDbgRegParms sqInt collectCogConstituentForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg);
static NoDbgRegParms sqInt collectCogMethodConstituent(CogMethod *cogMethod);
extern void compactCogCompiledCode(void);
static void compactPICsWithFreedTargets(void);
static AbstractInstruction * compileAbort(void);
static NoDbgRegParms sqInt compileBlockDispatchFromto(sqInt lowBlockStartIndex, sqInt highBlockStartIndex);
static NoDbgRegParms void compileBlockEntry(BlockStart *blockStart);
static NoDbgRegParms void compileCallFornumArgsargargargargfloatResultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask);
static NoDbgRegParms void compileCallFornumArgsargargargargresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask);
static NoDbgRegParms void compileCallFornumArgsfloatArgfloatArgfloatArgfloatArgresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask);
static AbstractInstruction * compileCPICEntry(void);
static NoDbgRegParms sqInt compileEntireFullBlockMethod(sqInt numCopied);
static void compileEntry(void);
static sqInt compileFullBlockEntry(void);
static sqInt compileMethodBody(void);
static NoDbgRegParms sqInt compilePICAbort(sqInt numArgs);
static NoDbgRegParms AbstractInstruction * compileStackOverflowCheck(sqInt canContextSwitch);
static NoDbgRegParms void compileTrampolineFornumArgsargargargargregsToSavepushLinkRegfloatResultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone);
static NoDbgRegParms void compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone);
static NoDbgRegParms void compileTrampolineFornumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone);
static void computeEntryOffsets(void);
static void computeFullBlockEntryOffsets(void);
static usqInt computeGoodVarBaseAddress(void);
static void computeMaximumSizes(void);
static NoDbgRegParms sqInt configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(CogMethod *cPIC, CogMethod *case0CogMethod, sqInt case1Method, sqInt case1Tag, sqInt isMNUCase, sqInt numArgs, sqInt addrDelta);
static NoDbgRegParms sqInt configureMNUCPICmethodOperandnumArgsdelta(CogMethod *cPIC, sqInt methodOperand, sqInt numArgs, sqInt addrDelta);
static NoDbgRegParms sqInt cPICCompactAndIsNowEmpty(CogMethod *cPIC);
static NoDbgRegParms sqInt cPICHasForwardedClass(CogMethod *cPIC);
static NoDbgRegParms sqInt cPICHasFreedTargets(CogMethod *cPIC);
static sqInt cPICPrototypeCaseOffset(void);
static NoDbgRegParms sqInt cPICHasTarget(CogMethod *cPIC, CogMethod *targetMethod);
static NoDbgRegParms sqInt createCPICData(CogMethod *cPIC);
static NoDbgRegParms AbstractInstruction * gDivRRQuoRem(sqInt rDivisor, sqInt rDividend, sqInt rQuotient, sqInt rRemainder);
extern int defaultCogCodeSize(void);
static NoDbgRegParms sqInt deltaToSkipPrimAndErrorStoreInheader(sqInt aMethodObj, sqInt aMethodHeader);
static NoDbgRegParms sqInt endPCOf(sqInt aMethod);
static void enterCogCodePopReceiver(void);
static NoDbgRegParms sqInt entryPointTagIsSelector(sqInt entryPoint);
static NoDbgRegParms sqInt expectedClosedPICPrototype(CogMethod *cPIC);
static sqInt extABytecode(void);
static sqInt extBBytecode(void);
static NoDbgRegParms sqInt fillInBlockHeadersAt(sqInt startAddress);
static NoDbgRegParms void fillInMethodHeadersizeselector(CogMethod *method, sqInt size, sqInt selector);
static NoDbgRegParms sqInt findBackwardBranchIsBackwardBranchMcpcBcpcMatchingBcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetBcpc);
static NoDbgRegParms usqInt findBlockMethodWithEntrystartBcpc(sqInt blockEntryMcpc, sqInt startBcpc);
static NoDbgRegParms sqInt findMapLocationForMcpcinMethod(usqInt targetMcpc, CogMethod *cogMethod);
extern CogBlockMethod * findMethodForStartBcpcinHomeMethod(sqInt startbcpc, CogMethod *cogMethod);
static NoDbgRegParms sqInt findIsBackwardBranchMcpcBcpcMatchingMcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetMcpc);
static NoDbgRegParms sqInt firstMappedPCFor(CogMethod *cogMethod);
static sqInt firstPrototypeMethodOop(void);
static NoDbgRegParms BytecodeFixup * fixupAt(sqInt fixupPC);
extern void flagCogMethodForBecome(CogMethod *cogMethod);
static NoDbgRegParms void followForwardedLiteralsImplementationIn(CogMethod *cogMethod);
extern void followForwardedLiteralsIn(CogMethod *cogMethod);
extern void followMovableLiteralsAndUpdateYoungReferrers(void);
extern void freeBecomeFlaggedMethods(void);
extern void freeCogMethod(CogMethod *cogMethod);
extern void freeUnmarkedMachineCode(void);
static NoDbgRegParms AbstractInstruction * genCallMustBeBooleanFor(sqInt boolean);
static NoDbgRegParms AbstractInstruction * genConditionalBranchoperand(sqInt opcode, sqInt operandOne);
static NoDbgRegParms void (*genEnilopmartForandandforCallcalled(sqInt regArg1, sqInt regArg2OrNone, sqInt regArg3OrNone, sqInt forCall, char *trampolineName))(void);
static NoDbgRegParms void genEnilopmartReturn(sqInt forCall);
static NoDbgRegParms NeverInline void generateCaptureCStackPointers(sqInt captureFramePointer);
static void generateClosedPICPrototype(void);
static CogMethod * generateCogFullBlock(void);
static NoDbgRegParms CogMethod * generateCogMethod(sqInt selector);
static NoDbgRegParms sqInt generateMapAtstart(usqInt addressOrNull, usqInt startAddress);
static void generateOpenPICPrototype(void);
static void generateRunTimeTrampolines(void);
static void generateStackPointerCapture(void);
static void generateTrampolines(void);
static NoDbgRegParms BytecodeDescriptor * generatorForPC(sqInt pc);
static usqInt genFFICalloutTrampoline(void);
static void genGetLeafCallStackPointers(void);
static NoDbgRegParms usqInt genInnerPICAbortTrampoline(char *name);
static void (*genInvokeInterpretTrampoline(void))(void);
static NoDbgRegParms void genLoadInlineCacheWithSelector(sqInt selectorIndex);
static usqInt genReturnToInterpreterTrampoline(void);
static NoDbgRegParms sqInt genSmalltalkToCStackSwitch(sqInt pushLinkReg);
static NoDbgRegParms usqInt genTrampolineForcalledargfloatResult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg);
static NoDbgRegParms usqInt genTrampolineForcalledfloatArgresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg);
static NoDbgRegParms usqInt genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegfloatResultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean);
static NoDbgRegParms usqInt genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean);
static NoDbgRegParms usqInt genTrampolineForcallednumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean);
static NoDbgRegParms void genTrampolineReturn(sqInt lnkRegWasPushed);
static NoDbgRegParms AbstractInstruction * gen(sqInt opcode);
static NoDbgRegParms AbstractInstruction * genoperand(sqInt opcode, sqInt operand);
static NoDbgRegParms AbstractInstruction * genoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo);
static NoDbgRegParms AbstractInstruction * genoperandoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo, sqInt operandThree);
static NoDbgRegParms sqInt getLiteral(sqInt litIndex);
static sqInt getOpcodeIndex(void);
static NoDbgRegParms sqInt incrementUsageOfTargetIfLinkedSendmcpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static NoDbgRegParms sqInt indexForSelectorin(sqInt selector, CogMethod *cogMethod);
extern void initializeCodeZoneFromupTo(sqInt startAddress, sqInt endAddress);
static sqInt initialMethodUsageCount(void);
static int initialOpenPICUsageCount(void);
static NoDbgRegParms sqInt inverseBranchFor(sqInt opcode);
static NoDbgRegParms int isPCWithinMethodZone(void *address);
extern sqInt isSendReturnPC(sqInt retpc);
static NoDbgRegParms AbstractInstruction * gJumpFPEqual(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gJumpFPGreaterOrEqual(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gJumpFPGreater(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gJumpFPLessOrEqual(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gJumpFPLess(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gJumpFPNotEqual(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gLogicalShiftLeftCqR(sqInt quickConstant, sqInt reg);
static NoDbgRegParms AbstractInstruction * gLogicalShiftLeftCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * gLogicalShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static AbstractInstruction * lastOpcode(void);
extern void linkSendAtintooffsetreceiver(sqInt callSiteReturnAddress, CogMethod *sendingMethod, CogMethod *targetMethod, sqInt theEntryOffset, sqInt receiver);
static BytecodeDescriptor * loadBytesAndGetDescriptor(void);
static NoDbgRegParms void loadSubsequentBytesForDescriptorat(BytecodeDescriptor *descriptor, sqInt pc);
static NoDbgRegParms AbstractInstruction * gMoveCqR(sqInt quickConstant, sqInt reg);
static NoDbgRegParms AbstractInstruction * gMoveCwR(sqInt wordConstant, sqInt reg);
static NoDbgRegParms AbstractInstruction * gMovePerfCnt64RL(sqInt destReg, sqInt liveRegisterMask);
static NoDbgRegParms AbstractInstruction * gMoveRMwr(sqInt sourceReg, sqInt offset, sqInt baseReg);
static NoDbgRegParms sqInt mapEndFor(CogMethod *cogMethod);
static NoDbgRegParms sqInt mapForperformUntilarg(CogMethod *cogMethod, sqInt (*functionSymbol)(sqInt annotation, char *mcpc, CogMethod *arg), CogMethod *arg);
static NoDbgRegParms sqInt mapObjectReferencesInClosedPIC(CogMethod *cPIC);
static void mapObjectReferencesInGeneratedRuntime(void);
static void mapObjectReferencesInMachineCodeForBecome(void);
static void mapObjectReferencesInMachineCodeForFullGC(void);
static void mapObjectReferencesInMachineCodeForYoungGC(void);
extern void mapObjectReferencesInMachineCode(sqInt gcMode);
extern void markAndTraceMachineCodeOfMarkedMethods(void);
static void markAndTraceObjectReferencesInGeneratedRuntime(void);
static NoDbgRegParms sqInt markAndTraceOrFreeCogMethodfirstVisit(CogMethod *cogMethod, sqInt firstVisit);
static NoDbgRegParms sqInt markAndTraceOrFreePICTargetin(sqInt entryPoint, CogMethod *cPIC);
static NoDbgRegParms sqInt markLiteralsAndUnlinkIfUnmarkedSendpcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
static NoDbgRegParms sqInt markLiteralspcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
extern void markMethodAndReferents(CogBlockMethod *aCogMethod);
extern usqInt maxCogMethodAddress(void);
static NoDbgRegParms sqInt maximumDistanceFromCodeZone(sqInt anAddress);
static NoDbgRegParms sqInt maybeFreeCogMethodDoesntLookKosher(CogMethod *cogMethod);
static int mclassCouldBeContext(void);
static int mclassIsSmallInteger(void);
extern usqInt mcPCForBackwardBranchstartBcpcin(sqInt bcpc, sqInt startbcpc, CogBlockMethod *cogMethod);
static NoDbgRegParms sqInt methodhasSameCodeAscheckPenultimate(sqInt methodA, sqInt methodB, sqInt comparePenultimateLiteral);
extern sqInt mnuOffset(void);
static NoDbgRegParms AbstractInstruction * gNativePopR(sqInt reg);
static NoDbgRegParms AbstractInstruction * gNativePushR(sqInt reg);
static NoDbgRegParms AbstractInstruction * gNativeRetN(sqInt offset);
static NoDbgRegParms sqInt needsFrameIfImmutability(sqInt stackDelta);
static NoDbgRegParms sqInt needsFrameIfInBlock(sqInt stackDelta);
static NoDbgRegParms sqInt needsFrameNever(sqInt stackDelta);
static NoDbgRegParms sqInt noAssertMethodClassAssociationOf(sqInt methodPointer);
static sqInt noCogMethodsMaximallyMarked(void);
static NoDbgRegParms int noTargetsFreeInClosedPIC(CogMethod *cPIC);
static NoDbgRegParms AbstractInstruction * gOrCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static NoDbgRegParms sqInt outputInstructionsAt(sqInt startAddress);
static NoDbgRegParms sqInt outputInstructionsForGeneratedRuntimeAt(sqInt startAddress);
extern sqInt patchToOpenPICFornumArgsreceiver(sqInt selector, sqInt numArgs, sqInt receiver);
static sqInt picAbortDiscriminatorValue(void);
static sqInt picInterpretAbortOffset(void);
static AbstractInstruction * previousInstruction(void);
extern void printCogMethodFor(void *address);
extern void printTrampolineTable(void);
static sqInt processorHasDivQuoRemAndMClassIsSmallInteger(void);
static sqInt processorHasMultiplyAndMClassIsSmallInteger(void);
static NoDbgRegParms void recordGeneratedRunTimeaddress(char *aString, sqInt address);
extern int recordPrimTraceFunc(void);
static void recordRunTimeObjectReferences(void);
static NoDbgRegParms sqInt registerMaskFor(sqInt reg);
static NoDbgRegParms sqInt registerMaskForandandand(sqInt reg1, sqInt reg2, sqInt reg3, sqInt reg4);
static NoDbgRegParms void relocateCallsAndSelfReferencesInMethod(CogMethod *cogMethod);
static NoDbgRegParms void relocateCallsInClosedPIC(CogMethod *cPIC);
static NoDbgRegParms sqInt relocateIfCallOrMethodReferencemcpcdelta(sqInt annotation, char *mcpc, CogMethod *refDeltaArg);
static NoDbgRegParms sqInt remapIfObjectRefpchasYoung(sqInt annotation, char *mcpc, CogMethod *hasYoungPtr);
static NoDbgRegParms sqInt remapMaybeObjRefInClosedPICAt(sqInt mcpc);
static NoDbgRegParms void rewriteCPICCaseAttagobjReftarget(sqInt followingAddress, sqInt newTag, sqInt newObjRef, sqInt newTarget);
static NoDbgRegParms AbstractInstruction * gSubRRR(sqInt subReg, sqInt fromReg, sqInt destReg);
static sqInt scanForCleanBlocks(void);
extern void setSelectorOfto(CogMethod *cogMethod, sqInt aSelectorOop);
static NoDbgRegParms sqInt spanForCleanBlockStartingAt(sqInt startPC);
static NoDbgRegParms usqInt stackCheckOffsetOfBlockAtisMcpc(sqInt blockEntryMcpc, sqInt mcpc);
static sqInt subsequentPrototypeMethodOop(void);
static NoDbgRegParms AbstractInstruction * gTstCqR(sqInt quickConstant, sqInt reg);
extern sqInt traceLinkedSendOffset(void);
static NoDbgRegParms char * trampolineNamenumArgs(char *routinePrefix, sqInt numArgs);
static NoDbgRegParms char * trampolineNamenumArgslimit(char *routinePrefix, int numArgs, sqInt argsLimit);
static NoDbgRegParms char * trampolineNamenumRegArgs(char *routinePrefix, sqInt numArgs);
extern void unflagBecomeFlaggedMethods(void);
static sqInt unknownBytecode(void);
extern void unlinkAllSends(void);
static NoDbgRegParms sqInt unlinkIfFreeOrLinkedSendpcof(sqInt annotation, char *mcpc, CogMethod *theSelector);
static NoDbgRegParms sqInt unlinkIfInvalidClassSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static NoDbgRegParms sqInt unlinkIfLinkedSendToFreepcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static NoDbgRegParms sqInt unlinkIfLinkedSendpcif(sqInt annotation, char *mcpc, CogMethod *criterionArg);
static NoDbgRegParms sqInt unlinkIfLinkedSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static NoDbgRegParms sqInt unlinkIfLinkedSendpcto(sqInt annotation, char *mcpc, CogMethod *theCogMethod);
extern void unlinkSendsLinkedForInvalidClasses(void);
extern void unlinkSendsOfisMNUSelector(sqInt selector, sqInt isMNUSelector);
static void unlinkSendsToFree(void);
extern void unlinkSendsToMethodsSuchThatAndFreeIf(sqInt (*criterion)(CogMethod *), sqInt freeIfTrue);
extern void unlinkSendsToandFreeIf(sqInt targetMethodObject, sqInt freeIfTrue);
extern void voidCogCompiledCode(void);
static void zeroOpcodeIndex(void);
static NoDbgRegParms void addToOpenPICList(CogMethod *anOpenPIC);
static NoDbgRegParms void addToYoungReferrers(CogMethod *writableCogMethod);
static NoDbgRegParms usqInt allocate(sqInt numBytes);
extern CogMethod * cogMethodContaining(usqInt mcpc);
static void compactCompiledCode(void);
static NoDbgRegParms void ensureInYoungReferrers(CogMethod *cogMethod);
static void followForwardedLiteralsInOpenPICList(void);
static NoDbgRegParms void freeMethod(CogMethod *cogMethod);
static void freeOlderMethodsForCompaction(void);
extern sqInt kosherYoungReferrers(void);
static NoDbgRegParms sqInt mcpcisAtStackCheckOfBlockMethodIn(sqInt mcpc, CogMethod *cogMethod);
extern CogMethod * methodFor(void *address);
extern sqInt methodsCompiledToMachineCodeInto(sqInt arrayObj);
extern sqInt numMethods(void);
extern sqInt numMethodsOfType(sqInt cogMethodType);
static NoDbgRegParms sqInt occurrencesInYoungReferrers(CogMethod *cogMethod);
static NoDbgRegParms CogMethod * openPICWithSelector(sqInt aSelector);
static void planCompaction(void);
extern void printCogMethods(void);
extern void printCogMethodsOfType(sqInt cmType);
extern void printCogMethodsWithMethod(sqInt methodOop);
extern void printCogMethodsWithPrimitive(sqInt primIdx);
extern void printCogMethodsWithSelector(sqInt selectorOop);
extern void printCogYoungReferrers(void);
extern sqInt printOpenPICList(void);
static sqInt pruneYoungReferrers(void);
static sqInt relocateAndPruneYoungReferrers(void);
static sqInt relocateMethodsPreCompaction(void);
static NoDbgRegParms sqInt removeFromOpenPICList(CogMethod *anOpenPIC);
static NoDbgRegParms void restorePICUsageCount(CogMethod *cogMethod);
static NoDbgRegParms sqInt roundUpLength(sqInt numBytes);
static NoDbgRegParms void savePICUsageCount(CogMethod *cogMethod);
static void voidOpenPICList(void);
static void voidUnpairedMethodList(void);
extern char * whereIsMaybeCodeThing(sqInt anOop);
static sqInt zoneAlignment(void);
static NoDbgRegParms sqInt checkValidObjectReference(sqInt anOop);
static NoDbgRegParms AbstractInstruction * genCmpClassFloatCompactIndexR(sqInt reg);
static NoDbgRegParms AbstractInstruction * genCmpClassMethodContextCompactIndexR(sqInt reg);
static void generateLowcodeObjectTrampolines(void);
static NoDbgRegParms sqInt genGetMethodHeaderOfintoscratch(sqInt methodReg, sqInt headerReg, sqInt scratchReg);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallIntegersInandscratch(sqInt aRegister, sqInt bRegister, sqInt scratchRegister);
static NoDbgRegParms void genLcByteSizeOfto(sqInt oop, sqInt resultRegister);
static NoDbgRegParms void genLcFloat32toOop(sqInt value, sqInt object);
static NoDbgRegParms void genLcFloat64toOop(sqInt value, sqInt object);
static NoDbgRegParms void genLcInstantiateOop(sqInt classOop);
static NoDbgRegParms void genLcInstantiateOopconstantIndexableSize(sqInt classOop, sqInt indexableSize);
static NoDbgRegParms void genLcInstantiateOopindexableSize(sqInt classOop, sqInt indexableSize);
static NoDbgRegParms void genLcInt64ToOop(sqInt value);
static NoDbgRegParms void genLcOopToInt64(sqInt value);
static NoDbgRegParms void genLcOopToPointer(sqInt object);
static NoDbgRegParms void genLcOopToUInt64(sqInt value);
static NoDbgRegParms void genLcOoptoFloat32(sqInt object, sqInt value);
static NoDbgRegParms void genLcOoptoFloat64(sqInt object, sqInt value);
static NoDbgRegParms void genLcPointerToOopclass(sqInt pointer, sqInt pointerClass);
static NoDbgRegParms void genLcUInt64ToOop(sqInt value);
static NoDbgRegParms sqInt genLoadSlotsourceRegdestReg(sqInt index, sqInt sourceReg, sqInt destReg);
static sqInt genPrimitiveAdd(void);
static sqInt genPrimitiveAsFloat(void);
static sqInt genPrimitiveBitAnd(void);
static sqInt genPrimitiveBitOr(void);
static sqInt genPrimitiveBitShift(void);
static sqInt genPrimitiveBitXor(void);
static sqInt genPrimitiveClass(void);
static sqInt genPrimitiveDiv(void);
static sqInt genPrimitiveDivide(void);
static sqInt genPrimitiveEqual(void);
static sqInt genPrimitiveFloatAdd(void);
static sqInt genPrimitiveFloatDivide(void);
static sqInt genPrimitiveFloatMultiply(void);
static sqInt genPrimitiveFloatSquareRoot(void);
static sqInt genPrimitiveFloatSubtract(void);
static sqInt genPrimitiveGreaterOrEqual(void);
static sqInt genPrimitiveGreaterThan(void);
static sqInt genPrimitiveHighBit(void);
static sqInt genPrimitiveIdentical(void);
static sqInt genPrimitiveLessOrEqual(void);
static sqInt genPrimitiveLessThan(void);
static sqInt genPrimitiveMod(void);
static sqInt genPrimitiveMultiply(void);
static sqInt genPrimitiveNewMethod(void);
static sqInt genPrimitiveNotEqual(void);
static sqInt genPrimitiveNotIdentical(void);
static sqInt genPrimitiveQuo(void);
static sqInt genPrimitiveSmallFloatAdd(void);
static sqInt genPrimitiveSmallFloatDivide(void);
static sqInt genPrimitiveSmallFloatEqual(void);
static sqInt genPrimitiveSmallFloatGreaterOrEqual(void);
static sqInt genPrimitiveSmallFloatGreaterThan(void);
static sqInt genPrimitiveSmallFloatLessOrEqual(void);
static sqInt genPrimitiveSmallFloatLessThan(void);
static sqInt genPrimitiveSmallFloatMultiply(void);
static sqInt genPrimitiveSmallFloatNotEqual(void);
static sqInt genPrimitiveSmallFloatSquareRoot(void);
static sqInt genPrimitiveSmallFloatSubtract(void);
static sqInt genPrimitiveSubtract(void);
static NoDbgRegParms sqInt genSmallIntegerComparison(sqInt jumpOpcode);
static NoDbgRegParms sqInt isUnannotatableConstant(CogSimStackEntry *simStackEntry);
static NoDbgRegParms sqInt classForInlineCacheTag(sqInt classIndex);
static NoDbgRegParms sqInt genAddSmallIntegerTagsTo(sqInt aRegister);
static NoDbgRegParms AbstractInstruction * genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(sqInt valueReg, sqInt resultReg, sqInt scratch1, sqInt scratch2);
static NoDbgRegParms AbstractInstruction * genAlloc64BitSignedIntegerValueintoscratchRegscratchReg(sqInt valueReg, sqInt resultReg, sqInt scratch1, sqInt scratch2);
static NoDbgRegParms AbstractInstruction * genAllocFloatValueintoscratchRegscratchReg(sqInt dpreg, sqInt resultReg, sqInt scratch1, sqInt scratch2);
static NoDbgRegParms sqInt genClearAndSetSmallIntegerTagsIn(sqInt scratchReg);
static NoDbgRegParms sqInt genConvertBitsToSmallFloatInscratch(sqInt reg, sqInt scratch);
static NoDbgRegParms void genConvertCharacterToSmallIntegerInReg(sqInt reg);
static NoDbgRegParms sqInt genConvertIntegerInRegtoSmallIntegerInReg(sqInt srcReg, sqInt destReg);
static NoDbgRegParms sqInt genConvertIntegerToSmallIntegerInReg(sqInt reg);
static NoDbgRegParms sqInt genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(sqInt reg, sqInt scratch);
static NoDbgRegParms void genConvertSmallIntegerToCharacterInReg(sqInt reg);
static NoDbgRegParms sqInt genConvertSmallIntegerToIntegerInReg(sqInt reg);
static NoDbgRegParms sqInt genFetchRegArgsForPerformWithArguments(sqInt sizeReg);
static NoDbgRegParms sqInt genFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed);
static NoDbgRegParms sqInt genFloatComparisonorIntegerComparisoninvertboxed(AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt jumpOpcode, sqInt invertComparison, sqInt rcvrBoxed);
static NoDbgRegParms sqInt genGetHashFieldNonImmOfasSmallIntegerInto(sqInt instReg, sqInt destReg);
static NoDbgRegParms sqInt genGetHashFieldNonImmOfinto(sqInt instReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * genGetInlineCacheClassTagFromintoforEntry(sqInt sourceReg, sqInt destReg, sqInt forEntry);
static NoDbgRegParms sqInt genGetNumBytesOfinto(sqInt srcReg, sqInt destReg);
static NoDbgRegParms sqInt genGetOverflowSlotsOfinto(sqInt srcReg, sqInt destReg);
static NoDbgRegParms sqInt genGetSmallFloatValueOfscratchinto(sqInt oopReg, sqInt scratch, sqInt dpReg);
static NoDbgRegParms AbstractInstruction * genJumpIsSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg);
static NoDbgRegParms AbstractInstruction * genJumpNotCharacter(sqInt reg);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallFloatValueBitsscratch(sqInt reg, sqInt exponent);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallFloat(sqInt reg);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallInteger(sqInt reg);
static NoDbgRegParms AbstractInstruction * genJumpSmallInteger(sqInt aRegister);
static NoDbgRegParms sqInt genLcInt32ToOop(sqInt value);
static NoDbgRegParms sqInt genLcOopToInt32(sqInt value);
static NoDbgRegParms sqInt genLcOopToUInt32(sqInt value);
static NoDbgRegParms sqInt genLcUInt32ToOop(sqInt value);
static NoDbgRegParms sqInt genPrimitiveAtPutSigned(sqInt signedVersion);
static NoDbgRegParms sqInt genPrimitiveAtSigned(sqInt signedVersion);
static sqInt genPrimitiveFloatEqual(void);
static sqInt genPrimitiveFloatGreaterOrEqual(void);
static sqInt genPrimitiveFloatGreaterThan(void);
static sqInt genPrimitiveFloatLessOrEqual(void);
static sqInt genPrimitiveFloatLessThan(void);
static sqInt genPrimitiveFloatNotEqual(void);
static sqInt genPrimitiveIdentityHash(void);
static sqInt genPrimitiveImmediateAsInteger(void);
static sqInt genPrimitiveNew(void);
static sqInt genPrimitiveNewWithArg(void);
static sqInt genPrimitiveShallowCopy(void);
static sqInt genPrimitiveSlotAt(void);
static sqInt genPrimitiveSlotAtPut(void);
static sqInt genPrimitiveStringAt(void);
static sqInt genPrimitiveStringAtPut(void);
static sqInt genPrimitiveUninitializedNewWithArg(void);
static NoDbgRegParms sqInt genPureFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed);
static NoDbgRegParms sqInt genPureFloatComparisoninvertboxed(AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt invertComparison, sqInt rcvrBoxed);
static NoDbgRegParms sqInt genRemoveSmallIntegerTagsInScratchReg(sqInt scratchReg);
static NoDbgRegParms sqInt genShiftAwaySmallIntegerTagsInScratchReg(sqInt scratchReg);
static NoDbgRegParms sqInt genSmallIntegerComparisonorDoubleComparisoninvert(sqInt jumpOpcode, AbstractInstruction * NoDbgRegParms (*jumpFPOpcodeGenerator)(void *), sqInt invertComparison);
static NoDbgRegParms sqInt getLiteralCountOfplusOneinBytesintoscratch(sqInt methodReg, sqInt plusOne, sqInt inBytes, sqInt litCountReg, sqInt scratchReg);
static NoDbgRegParms sqInt inlineCacheTagForInstance(sqInt oop);
static sqInt log2BytesPerWord(void);
static void maybeGenerateSelectorIndexDereferenceRoutine(void);
static sqInt numSmallIntegerBits(void);
static sqInt numSmallIntegerTagBits(void);
static NoDbgRegParms sqInt validInlineCacheTag(sqInt classIndexOrTagPattern);
static void callStoreCheckTrampoline(void);
static NoDbgRegParms sqInt checkValidOopReference(sqInt anOop);
static NoDbgRegParms sqInt couldBeObject(sqInt literal);
static NoDbgRegParms usqInt genActiveContextTrampolineLargeinBlockcalled(sqInt isLarge, sqInt isInBlock, char *aString);
static NoDbgRegParms AbstractInstruction * genCheckRememberedBitOfscratch(sqInt objReg, sqInt scratchReg);
static NoDbgRegParms sqInt genConvertCharacterToCodeInReg(sqInt reg);
static NoDbgRegParms sqInt genConvertIntegerToCharacterInReg(sqInt reg);
static NoDbgRegParms sqInt genCreateFullClosurenumArgsnumCopiedignoreContextcontextNumArgslargeinBlock(sqInt compiledBlock, sqInt numArgs, sqInt numCopied, sqInt ignoreContext, sqInt contextNumArgs, sqInt contextIsLarge, sqInt contextIsBlock);
static NoDbgRegParms sqInt genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(sqInt reg, sqInt scratch, void *fwdJumpTarget, void *nonFwdJumpTargetOrZero);
static NoDbgRegParms sqInt genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(sqInt reg, sqInt scratch, sqInt index, sqInt objReg);
static void generateObjectRepresentationTrampolines(void);
static NoDbgRegParms sqInt genGetActiveContextLargeinBlock(sqInt isLarge, sqInt isInBlock);
static NoDbgRegParms sqInt genGetActiveContextNumArgslargeinBlock(sqInt numArgs, sqInt isLargeContext, sqInt isInBlock);
static NoDbgRegParms sqInt genGetBitsofFormatByteOfinto(sqInt mask, sqInt sourceReg, sqInt destReg);
static NoDbgRegParms sqInt genGetClassIndexOfNonImminto(sqInt sourceReg, sqInt destReg);
static NoDbgRegParms sqInt genGetClassObjectOfClassIndexintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static NoDbgRegParms sqInt genGetClassObjectOfintoscratchRegmayBeAForwarder(sqInt instReg, sqInt destReg, sqInt scratchReg, sqInt mayBeForwarder);
static NoDbgRegParms AbstractInstruction * genGetClassTagOfintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static NoDbgRegParms sqInt genGetCompactClassIndexNonImmOfinto(sqInt instReg, sqInt destReg);
static NoDbgRegParms sqInt genGetDoubleValueOfinto(sqInt srcReg, sqInt destFPReg);
static NoDbgRegParms sqInt genGetFormatOfinto(sqInt srcReg, sqInt destReg);
static NoDbgRegParms sqInt genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(sqInt sourceReg, sqInt destReg, sqInt scratchRegOrNone);
static NoDbgRegParms sqInt genGetNumSlotsOfinto(sqInt srcReg, sqInt destReg);
static NoDbgRegParms sqInt genGetRawSlotSizeOfNonImminto(sqInt sourceReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * genJumpImmediate(sqInt aRegister);
#if IMMUTABILITY
static NoDbgRegParms AbstractInstruction * genJumpImmutablescratchReg(sqInt sourceReg, sqInt scratchReg);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static NoDbgRegParms AbstractInstruction * genJumpMutablescratchReg(sqInt sourceReg, sqInt scratchReg);
#endif /* IMMUTABILITY */
static NoDbgRegParms void genLcFirstFieldPointer(sqInt objectReg);
static NoDbgRegParms void genLcFirstIndexableFieldPointer(sqInt objectReg);
static NoDbgRegParms void genLcIsBytesto(sqInt objectReg, sqInt valueReg);
static NoDbgRegParms void genLcIsFloatObjectto(sqInt objectReg, sqInt valueReg);
static NoDbgRegParms void genLcIsIndexableto(sqInt objectReg, sqInt valueReg);
static NoDbgRegParms void genLcIsIntegerObjectto(sqInt objectReg, sqInt valueReg);
static NoDbgRegParms void genLcIsPointersto(sqInt objectReg, sqInt valueReg);
static NoDbgRegParms void genLcIsWordsOrBytesto(sqInt objectReg, sqInt valueReg);
static NoDbgRegParms void genLcIsWordsto(sqInt objectReg, sqInt valueReg);
static NoDbgRegParms void genLcLoadObjectat(sqInt object, sqInt fieldIndex);
static NoDbgRegParms void genLcLoadObjectfield(sqInt object, sqInt fieldIndex);
static NoDbgRegParms void genLcStoreobjectat(sqInt value, sqInt object, sqInt fieldIndex);
static NoDbgRegParms void genLcStoreobjectfield(sqInt value, sqInt object, sqInt fieldIndex);
static NoDbgRegParms sqInt genNewArrayOfSizeinitialized(sqInt size, sqInt initialize);
static NoDbgRegParms sqInt genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock);
static sqInt genPrimitiveAsCharacter(void);
static sqInt genPrimitiveAt(void);
static sqInt genPrimitiveAtPut(void);
static NoDbgRegParms sqInt genPrimitiveIdenticalOrNotIf(sqInt orNot);
static sqInt genPrimitiveIntegerAt(void);
static sqInt genPrimitiveIntegerAtPut(void);
static sqInt genPrimitiveMakePoint(void);
static sqInt genPrimitiveObjectAt(void);
static sqInt genPrimitiveSize(void);
static sqInt genPrimitiveStringCompareWith(void);
static sqInt genPrimitiveStringReplace(void);
static NoDbgRegParms sqInt genSetSmallIntegerTagsIn(sqInt scratchReg);
static usqInt genStoreCheckContextReceiverTrampoline(void);
static NoDbgRegParms sqInt genStoreCheckReceiverRegvalueRegscratchReginFrame(sqInt destReg, sqInt valueReg, sqInt scratchReg, sqInt inFrame);
static NoDbgRegParms sqInt genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt inFrame, sqInt needsStoreCheck);
static NoDbgRegParms sqInt genStoreSourceRegslotIndexintoNewObjectInDestReg(sqInt sourceReg, sqInt index, sqInt destReg);
#if IMMUTABILITY
static NoDbgRegParms usqInt genStoreTrampolineCalledinstVarIndex(char *trampolineName, sqInt instVarIndex);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static NoDbgRegParms sqInt genStoreWithImmutabilityAndStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needRestoreRcvr);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static NoDbgRegParms sqInt genStoreWithImmutabilityButNoStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needRestoreRcvr);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static NoDbgRegParms sqInt genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needsStoreCheck, sqInt needRestoreRcvr);
#endif /* IMMUTABILITY */
static sqInt getActiveContextAllocatesInMachineCode(void);
static NoDbgRegParms sqInt inlineCacheTagIsYoung(sqInt cacheTag);
static NoDbgRegParms AbstractInstruction * jumpNotCharacterUnsignedValueInRegister(sqInt reg);
static NoDbgRegParms sqInt markAndTraceLiteralinatpc(sqInt literal, CogMethod *cogMethodOrNil, usqInt address);
static NoDbgRegParms void markAndTraceLiteralinat(sqInt literal, CogMethod *cogMethod, sqInt *address);
static NoDbgRegParms void markAndTraceUpdatedLiteralin(sqInt objOop, CogMethod *cogMethodOrNil);
static NoDbgRegParms sqInt maybeCompileRetryOfonPrimitiveFailflags(void (*primitiveRoutine)(void), sqInt primIndex, sqInt flags);
static NoDbgRegParms sqInt maybeShiftClassTagRegisterForMethodCacheProbe(sqInt classTagReg);
static sqInt numCharacterBits(void);
static NoDbgRegParms sqInt remapObject(sqInt objOop);
static NoDbgRegParms sqInt remapOop(sqInt objOop);
static NoDbgRegParms sqInt shouldAnnotateObjectReference(sqInt anOop);
static NoDbgRegParms sqInt slotOffsetOfInstVarIndex(sqInt index);
static NoDbgRegParms SimStackEntry * ensureSpilledAtfrom(SimStackEntry *self_in_CogSimStackEntry, sqInt baseOffset, sqInt baseRegister);
static NoDbgRegParms sqInt floatRegisterMask(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms sqInt isSameEntryAs(SimStackEntry *self_in_CogSimStackEntry, CogSimStackEntry *ssEntry);
static NoDbgRegParms sqInt mayBeAForwarder(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms SimStackEntry * popToReg(SimStackEntry *self_in_CogSimStackEntry, sqInt reg);
static NoDbgRegParms sqInt registerMask(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms sqInt registerMaskOrNone(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms sqInt registerOrNone(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms SimStackEntry * storeToReg(SimStackEntry *self_in_CogSimStackEntry, sqInt reg);
static NoDbgRegParms CogSimStackNativeEntry * ensureIsMarkedAsSpilled(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry);
static NoDbgRegParms CogSimStackNativeEntry * ensureSpilledSPscratchRegister(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry, sqInt spRegister, sqInt scratchRegister);
static NoDbgRegParms sqInt nativeFloatRegisterMask(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry);
static NoDbgRegParms sqInt nativeFloatRegisterOrNone(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry);
static NoDbgRegParms CogSimStackNativeEntry * nativePopToReg(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry, sqInt reg);
static NoDbgRegParms sqInt nativeRegisterMask(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry);
static NoDbgRegParms sqInt nativeRegisterOrNone(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry);
static NoDbgRegParms sqInt nativeRegisterSecondOrNone(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry);
static NoDbgRegParms CogSimStackNativeEntry * nativeStackPopToReg(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry, sqInt reg);
static NoDbgRegParms sqInt spillingNeedsScratchRegister(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry);
static NoDbgRegParms sqInt stackSpillSize(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry);
static NoDbgRegParms char isBackwardBranchFixup(BytecodeFixup *self_in_CogSSBytecodeFixup);
static NoDbgRegParms int isMergeFixup(BytecodeFixup *self_in_CogSSBytecodeFixup);
static NoDbgRegParms AbstractInstruction * allocateLiteral(sqInt aLiteral);
static NoDbgRegParms sqInt literalInstructionInRange(AbstractInstruction *litInst);
static NoDbgRegParms AbstractInstruction * checkLiteral32forInstruction(sqInt literal, AbstractInstruction *anInstruction);
static NoDbgRegParms AbstractInstruction * checkLiteralforInstruction(sqInt literal, AbstractInstruction *anInstruction);
static NoDbgRegParms sqInt dumpLiterals(sqInt generateBranchAround);
static NoDbgRegParms AbstractInstruction * locateLiteralsize(sqInt aLiteral, sqInt litSize);
extern sqInt cogMethodHasExternalPrim(CogMethod *aCogMethod);
extern sqInt cogMethodHasMachineCodePrim(CogMethod *aCogMethod);
static sqInt compileBlockDispatch(void);
static void compileGetErrorCode(void);
static sqInt compileInterpreterPrimitive(void);
static NoDbgRegParms sqInt compileInterpreterPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags);
static NoDbgRegParms sqInt compileOnStackExternalPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags);
static NoDbgRegParms AbstractInstruction * compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selector, sqInt shift, sqInt baseRegOrNone);
static NoDbgRegParms void compileOpenPICnumArgs(sqInt selector, sqInt numArgs);
static NoDbgRegParms AbstractInstruction * compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selectorReg, sqInt shift, sqInt baseRegOrNone);
static sqInt compilePrimitive(void);
static sqInt extendedPushBytecode(void);
static sqInt extendedStoreAndPopBytecode(void);
static sqInt extendedStoreBytecode(void);
static int frameOffsetOfNativeFrameMark(void);
static int frameOffsetOfNativeFramePointer(void);
static int frameOffsetOfNativeStackPointer(void);
static int frameOffsetOfPreviousNativeStackPointer(void);
static NoDbgRegParms sqInt frameOffsetOfTemporary(sqInt index);
static sqInt genCallMappedInlinedPrimitive(void);
static NoDbgRegParms AbstractInstruction * genDoubleFailIfZeroArgRcvrarg(int rcvrReg, int argReg);
static sqInt genExtendedSendBytecode(void);
static sqInt genExtendedSuperBytecode(void);
static sqInt genExtJumpIfFalse(void);
static sqInt genExtJumpIfTrue(void);
static sqInt genExtNopBytecode(void);
static sqInt genExtPushCharacterBytecode(void);
static sqInt genExtPushIntegerBytecode(void);
static sqInt genExtPushLiteralBytecode(void);
static sqInt genExtPushLiteralVariableBytecode(void);
static sqInt genExtPushPseudoVariable(void);
static sqInt genExtPushReceiverVariableBytecode(void);
static sqInt genExtSendBytecode(void);
static sqInt genExtSendSuperBytecode(void);
static sqInt genExtStoreAndPopLiteralVariableBytecode(void);
static sqInt genExtStoreAndPopReceiverVariableBytecode(void);
static sqInt genExtStoreLiteralVariableBytecode(void);
static sqInt genExtStoreReceiverVariableBytecode(void);
static sqInt genExtUnconditionalJump(void);
static sqInt genFastPrimFail(void);
static NoDbgRegParms void genFastPrimTraceUsingand(sqInt r1, sqInt r2);
static void genLoadNewMethod(void);
static sqInt genLongJumpIfFalse(void);
static sqInt genLongJumpIfTrue(void);
static sqInt genLongPushTemporaryVariableBytecode(void);
static sqInt genLongStoreAndPopTemporaryVariableBytecode(void);
static sqInt genLongStoreTemporaryVariableBytecode(void);
static sqInt genLongUnconditionalBackwardJump(void);
static sqInt genLongUnconditionalForwardJump(void);
static NoDbgRegParms sqInt genLookupForPerformNumArgs(sqInt numArgs);
static NoDbgRegParms AbstractInstruction * genMoveConstantR(sqInt constant, sqInt reg);
static NoDbgRegParms usqInt genMustBeBooleanTrampolineForcalled(sqInt boolean, char *trampolineName);
static sqInt genPrimitiveHashMultiply(void);
static NoDbgRegParms void genPrimReturnEnterCogCodeEnilopmart(sqInt profiling);
static sqInt genPushConstantFalseBytecode(void);
static sqInt genPushConstantNilBytecode(void);
static sqInt genPushConstantOneBytecode(void);
static sqInt genPushConstantTrueBytecode(void);
static sqInt genPushConstantZeroBytecode(void);
static sqInt genPushLiteralConstantBytecode(void);
static sqInt genPushLiteralVariable16CasesBytecode(void);
static sqInt genPushLiteralVariableBytecode(void);
static sqInt genPushQuickIntegerConstantBytecode(void);
static sqInt genPushReceiverVariableBytecode(void);
static sqInt genPushTemporaryVariableBytecode(void);
extern sqInt genQuickReturnConst(void);
extern sqInt genQuickReturnInstVar(void);
extern sqInt genQuickReturnSelf(void);
static sqInt genReturnFalse(void);
static sqInt genReturnNil(void);
static sqInt genReturnNilFromBlock(void);
static sqInt genReturnTrue(void);
static sqInt genSecondExtendedSendBytecode(void);
static sqInt genSendLiteralSelector0ArgsBytecode(void);
static sqInt genSendLiteralSelector1ArgBytecode(void);
static sqInt genSendLiteralSelector2ArgsBytecode(void);
static sqInt genShortJumpIfFalse(void);
static sqInt genShortJumpIfTrue(void);
static sqInt genShortUnconditionalJump(void);
static sqInt genSpecialSelectorEqualsEquals(void);
static sqInt genSpecialSelectorNotEqualsEquals(void);
static sqInt genSpecialSelectorSend(void);
static sqInt genStoreAndPopReceiverVariableBytecode(void);
static sqInt genStoreAndPopRemoteTempLongBytecode(void);
static sqInt genStoreAndPopTemporaryVariableBytecode(void);
static sqInt genStoreRemoteTempLongBytecode(void);
static void genTakeProfileSample(void);
static sqInt genUnconditionalTrapBytecode(void);
static NoDbgRegParms void loadNativeArgumentAddressto(sqInt baseOffset, sqInt reg);
static NoDbgRegParms void loadNativeFramePointerInto(sqInt reg);
static NoDbgRegParms void loadNativeLocalAddressto(sqInt baseOffset, sqInt reg);
extern sqInt mapPCDataForinto(CogMethod *cogMethod, sqInt arrayObj);
static sqInt numSpecialSelectors(void);
static NoDbgRegParms usqInt pcDataForBlockEntryMethod(sqInt blockEntryMcpc, sqInt cogMethod);
static NoDbgRegParms sqInt pcDataForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg);
static PrimitiveDescriptor * primitiveGeneratorOrNil(void);
static NoDbgRegParms int registerisInMask(sqInt reg, sqInt mask);
static NoDbgRegParms int registerisNotInMask(sqInt reg, sqInt mask);
static NoDbgRegParms sqInt v3BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v3LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v3LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v3ShortForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v4BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v4LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v4LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
extern double getCogCodeZoneThreshold(void);
extern sqInt setCogCodeZoneThreshold(double ratio);
static NoDbgRegParms BlockStart * addBlockStartAtnumArgsnumCopiedspan(sqInt bytecodepc, sqInt numArgs, sqInt numCopied, sqInt span);
static NoDbgRegParms void adjustArgumentsForPerform(sqInt numArgs);
static NoDbgRegParms sqInt allocateFloatRegNotConflictingWith(sqInt regMask);
static NoDbgRegParms sqInt allocateRegForStackEntryAtnotConflictingWith(sqInt index, sqInt regMask);
static NoDbgRegParms sqInt allocateRegNotConflictingWith(sqInt regMask);
static NoDbgRegParms sqInt anyReferencesToRegisterinTopNItems(sqInt reg, sqInt n);
static NoDbgRegParms void beginHighLevelCall(sqInt alignment);
extern void callCogCodePopReceiverArg0Regs(void);
extern void callCogCodePopReceiverArg1Arg0Regs(void);
static sqInt callSwitchToCStack(void);
static void callSwitchToSmalltalkStack(void);
static NoDbgRegParms sqInt compileAbstractInstructionsFromthrough(sqInt start, sqInt end);
static sqInt compileBlockBodies(void);
static NoDbgRegParms void compileBlockFrameBuild(BlockStart *blockStart);
static NoDbgRegParms void compileBlockFramelessEntry(BlockStart *blockStart);
static NoDbgRegParms CogMethod * compileCogFullBlockMethod(sqInt numCopied);
static NoDbgRegParms CogMethod * compileCogMethod(sqInt selector);
static sqInt compileEntireMethod(void);
static void compileFrameBuild(void);
static NoDbgRegParms void compileFullBlockFramelessEntry(sqInt numCopied);
static NoDbgRegParms void compileFullBlockMethodFrameBuild(sqInt numCopied);
#if IMMUTABILITY
static void compileTwoPathFrameBuild(void);
#endif /* IMMUTABILITY */
static void compileTwoPathFramelessInit(void);
static NoDbgRegParms sqInt cPICMissTrampolineFor(sqInt numArgs);
static sqInt doubleExtendedDoAnythingBytecode(void);
static sqInt duplicateTopBytecode(void);
static void endHighLevelCallWithCleanup(void);
static void endHighLevelCallWithoutCleanup(void);
static NoDbgRegParms BytecodeFixup * ensureFixupAt(sqInt targetPC);
static NoDbgRegParms BytecodeFixup * ensureNonMergeFixupAt(sqInt targetPC);
static void ensureReceiverResultRegContainsSelf(void);
static NoDbgRegParms void evaluateat(BytecodeDescriptor *descriptor, sqInt pc);
static NoDbgRegParms sqInt eventualTargetOf(sqInt targetBytecodePC);
static NoDbgRegParms sqInt freeAnyFloatRegNotConflictingWith(sqInt regMask);
static NoDbgRegParms sqInt freeAnyRegNotConflictingWith(sqInt regMask);
static sqInt genBlockReturn(void);
static NoDbgRegParms void (*genCallPICEnilopmartNumArgs(sqInt numArgs))(void);
static sqInt genCallPrimitiveBytecode(void);
static sqInt genExternalizePointersForPrimitiveCall(void);
static AbstractInstruction * genExternalizeStackPointerForFastPrimitiveCall(void);
static sqInt genExtPushClosureBytecode(void);
static sqInt genExtPushFullClosureBytecode(void);
static void generateEnilopmarts(void);
static NoDbgRegParms sqInt generateInstructionsAt(sqInt eventualAbsoluteAddress);
static void generateMissAbortTrampolines(void);
static void generateSendTrampolines(void);
static void generateTracingTrampolines(void);
static NoDbgRegParms sqInt genForwardersInlinedIdenticalOrNotIf(sqInt orNot);
static NoDbgRegParms sqInt genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(sqInt argIsConstant, sqInt rcvrIsConstant, sqInt argReg, sqInt rcvrRegOrNone, sqInt orNot);
static NoDbgRegParms sqInt genInlinedIdenticalOrNotIf(sqInt orNot);
static NoDbgRegParms sqInt genJumpBackTo(sqInt targetBytecodePC);
static NoDbgRegParms sqInt genJumpIfto(sqInt boolean, sqInt targetBytecodePC);
static NoDbgRegParms sqInt genJumpTo(sqInt targetBytecodePC);
static NoDbgRegParms sqInt genLowcodeBinaryInlinePrimitive(sqInt prim);
static NoDbgRegParms sqInt genLowcodeNullaryInlinePrimitive(sqInt prim);
static NoDbgRegParms sqInt genLowcodeTrinaryInlinePrimitive(sqInt prim);
static NoDbgRegParms sqInt genLowcodeUnaryInlinePrimitive2(sqInt prim);
static NoDbgRegParms sqInt genLowcodeUnaryInlinePrimitive3(sqInt prim);
static NoDbgRegParms sqInt genLowcodeUnaryInlinePrimitive4(sqInt prim);
static NoDbgRegParms sqInt genLowcodeUnaryInlinePrimitive5(sqInt prim);
static NoDbgRegParms sqInt genLowcodeUnaryInlinePrimitive(sqInt prim);
static NoDbgRegParms sqInt genMarshalledSendnumArgssendTable(sqInt selectorIndex, sqInt numArgs, sqInt *sendTable);
static NoDbgRegParms usqInt genMethodAbortTrampolineFor(sqInt numArgs);
static NoDbgRegParms usqInt genPICAbortTrampolineFor(sqInt numArgs);
static NoDbgRegParms usqInt genPICMissTrampolineFor(sqInt numArgs);
static sqInt genPopStackBytecode(void);
static sqInt genPrimitiveClosureValue(void);
static sqInt genPrimitiveFullClosureValue(void);
static sqInt genPrimitivePerform(void);
static sqInt genPrimitivePerformWithArguments(void);
static sqInt genPushActiveContextBytecode(void);
static sqInt genPushClosureCopyCopiedValuesBytecode(void);
static NoDbgRegParms sqInt genPushLiteralIndex(sqInt literalIndex);
static NoDbgRegParms sqInt genPushLiteralVariable(sqInt literalIndex);
static NoDbgRegParms sqInt genPushMaybeContextReceiverVariable(sqInt slotIndex);
static sqInt genPushNewArrayBytecode(void);
static sqInt genPushReceiverBytecode(void);
static NoDbgRegParms sqInt genPushReceiverVariable(sqInt index);
static void genPushRegisterArgs(void);
static sqInt genPushRemoteTempLongBytecode(void);
static NoDbgRegParms sqInt genPushTemporaryVariable(sqInt index);
static sqInt genReturnReceiver(void);
static sqInt genReturnTopFromBlock(void);
static sqInt genReturnTopFromMethod(void);
static NoDbgRegParms sqInt genSendDirectedSupernumArgs(sqInt selectorIndex, sqInt numArgs);
static NoDbgRegParms sqInt genSendSupernumArgs(sqInt selectorIndex, sqInt numArgs);
static NoDbgRegParms usqInt genSendTrampolineFornumArgscalledargargargarg(void *aRoutine, sqInt numArgs, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3);
static NoDbgRegParms sqInt genSendnumArgs(sqInt selectorIndex, sqInt numArgs);
static sqInt genSpecialSelectorArithmetic(void);
static sqInt genSpecialSelectorClass(void);
static sqInt genSpecialSelectorComparison(void);
static sqInt genStaticallyResolvedSpecialSelectorComparison(void);
static NoDbgRegParms sqInt genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt litVarIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static NoDbgRegParms sqInt genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static NoDbgRegParms sqInt genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static NoDbgRegParms sqInt genStorePopRemoteTempAtneedsStoreCheck(sqInt popBoolean, sqInt slotIndex, sqInt remoteTempIndex, sqInt needsStoreCheck);
static NoDbgRegParms sqInt genStorePopTemporaryVariable(sqInt popBoolean, sqInt tempIndex);
static sqInt genUpArrowReturn(void);
static NoDbgRegParms sqInt genVanillaInlinedIdenticalOrNotIf(sqInt orNot);
static NoDbgRegParms void initSimStackForFramefulMethod(sqInt startpc);
static NoDbgRegParms void initSimStackForFramelessBlock(sqInt startpc);
static NoDbgRegParms void initSimStackForFramelessMethod(sqInt startpc);
static NoDbgRegParms sqInt isNonForwarderReceiver(sqInt reg);
static void leaveNativeFrame(void);
static sqInt liveFloatRegisters(void);
static sqInt liveRegisters(void);
static NoDbgRegParms sqInt mapDeadDescriptorIfNeeded(BytecodeDescriptor *descriptor);
static NoDbgRegParms void marshallSendArguments(sqInt numArgs);
static sqInt maybeCompilingFirstPassOfBlockWithInitialPushNil(void);
static NoDbgRegParms sqInt mergeWithFixupIfRequired(BytecodeFixup *fixup);
static NoDbgRegParms sqInt methodAbortTrampolineFor(sqInt numArgs);
static NoDbgRegParms sqInt needsFrameIfMod16GENumArgs(sqInt stackDelta);
static NoDbgRegParms sqInt needsFrameIfStackGreaterThanOne(sqInt stackDelta);
static NoDbgRegParms sqInt numberOfSpillsInTopNItems(sqInt n);
static NoDbgRegParms sqInt picAbortTrampolineFor(sqInt numArgs);
static sqInt prevInstIsPCAnnotated(void);
static int receiverIsInReceiverResultReg(void);
static NoDbgRegParms void reinitializeFixupsFromthrough(sqInt start, sqInt end);
static NoDbgRegParms sqInt scanBlock(BlockStart *blockStart);
static sqInt scanMethod(void);
static NoDbgRegParms sqInt squeakV3orSistaV1PushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils);
static NoDbgRegParms sqInt squeakV3orSistaV1NumPushNils(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms void ssAllocateRequiredFloatRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr);
static NoDbgRegParms void ssAllocateRequiredFloatReg(sqInt requiredReg);
static NoDbgRegParms void ssAllocateRequiredRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr);
static NoDbgRegParms void ssFlushUpThroughReceiverVariable(sqInt slotIndex);
static NoDbgRegParms void ssFlushUpThroughTemporaryVariable(sqInt tempIndex);
static NoDbgRegParms void ssNativeFlushTo(sqInt index);
static NoDbgRegParms void ssNativePop(sqInt n);
static NoDbgRegParms void ssNativePush(sqInt n);
static CogSimStackNativeEntry * ssNativeTop(void);
static NoDbgRegParms CogSimStackNativeEntry * ssNativeValue(sqInt n);
static NoDbgRegParms void ssPopNativeSize(sqInt popSize);
static NoDbgRegParms void ssPop(sqInt n);
static NoDbgRegParms sqInt ssPushAnnotatedConstant(sqInt literal);
static NoDbgRegParms sqInt ssPushBaseoffset(sqInt reg, sqInt offset);
static NoDbgRegParms sqInt ssPushConstant(sqInt literal);
static NoDbgRegParms sqInt ssPushDesc(SimStackEntry simStackEntry);
static NoDbgRegParms sqInt ssPushNativeConstantFloat32(float aFloat32);
static NoDbgRegParms sqInt ssPushNativeConstantFloat64(double aFloat64);
static NoDbgRegParms sqInt ssPushNativeConstantInt32(sqInt anInt32);
static NoDbgRegParms sqInt ssPushNativeConstantInt64(sqLong anInt64);
static NoDbgRegParms sqInt ssPushNativeConstantPointer(sqInt aNativePointer);
static NoDbgRegParms sqInt ssPushNativeRegisterDoubleFloat(sqInt reg);
static NoDbgRegParms sqInt ssPushNativeRegisterSingleFloat(sqInt reg);
static NoDbgRegParms sqInt ssPushNativeRegister(sqInt reg);
static NoDbgRegParms sqInt ssPushRegister(sqInt reg);
static NoDbgRegParms void ssPush(sqInt n);
static SimStackEntry ssSelfDescriptor(void);
static NoDbgRegParms void ssStoreAndReplacePoptoReg(sqInt popBoolean, sqInt reg);
static NoDbgRegParms sqInt ssStorePoptoPreferredReg(sqInt popBoolean, sqInt preferredReg);
static NoDbgRegParms void ssStorePoptoReg(sqInt popBoolean, sqInt reg);
static CogSimStackEntry * ssTop(void);
static NoDbgRegParms CogSimStackEntry * ssValue(sqInt n);
static NoDbgRegParms sqInt stackEntryIsBoolean(CogSimStackEntry *simStackEntry);
static sqInt tempsValidAndVolatileEntriesSpilled(void);
static NoDbgRegParms sqInt tryCollapseTempVectorInitializationOfSize(sqInt slots);
static sqInt violatesEnsureSpilledSpillAssert(void);
static void voidReceiverResultRegContainsSelf(void);


/*** Variables ***/
static AbstractInstruction * abstractOpcodes;
static usqInt allocationThreshold;
static usqInt baseAddress;
static sqInt blockCount;
static AbstractInstruction * blockEntryLabel;
static AbstractInstruction * blockEntryNoContextSwitch;
static BlockStart * blockStarts;
static sqInt breakBlock;
static sqInt breakMethod;
static sqInt byte0;
static sqInt byte1;
static sqInt byte2;
static sqInt byte3;
static sqInt bytecodePC;
static sqInt bytecodeSetOffset;
static sqInt ceByteSizeOfTrampoline;
static sqInt ceCPICMissTrampoline;
static sqInt ceDereferenceSelectorIndex;
static sqInt ceFetchContextInstVarTrampoline;
static sqInt ceFFICalloutTrampoline;
static sqInt ceFloatObjectOfTrampoline;
static sqInt ceFloatValueOfTrampoline;
static sqInt ceFreeTrampoline;
static sqInt ceInlineNewHashTrampoline;
static sqInt ceInstantiateClassIndexableSizeTrampoline;
static sqInt ceInstantiateClassTrampoline;
static sqInt ceLargeActiveContextInBlockTrampoline;
static sqInt ceLargeActiveContextInFullBlockTrampoline;
static sqInt ceLargeActiveContextInMethodTrampoline;
static sqInt ceMallocTrampoline;
static sqInt ceMethodAbortTrampoline;
static sqInt ceNewHashTrampoline;
static sqInt ceNonLocalReturnTrampoline;
static sqInt cePICAbortTrampoline;
static sqInt cePositive64BitIntegerTrampoline;
static sqInt cePositive64BitValueOfTrampoline;
static sqInt cePrimReturnEnterCogCode;
static sqInt cePrimReturnEnterCogCodeProfiling;
static sqInt ceReapAndResetErrorCodeTrampoline;
static sqInt ceScheduleScavengeTrampoline;
static sqInt ceSendMustBeBooleanAddFalseTrampoline;
static sqInt ceSendMustBeBooleanAddTrueTrampoline;
static sqInt ceSigned64BitIntegerTrampoline;
static sqInt ceSigned64BitValueOfTrampoline;
static sqInt ceSmallActiveContextInBlockTrampoline;
static sqInt ceSmallActiveContextInFullBlockTrampoline;
static sqInt ceSmallActiveContextInMethodTrampoline;
static sqInt ceStoreCheckContextReceiverTrampoline;
static sqInt ceStoreCheckTrampoline;
static sqInt ceStoreContextInstVarTrampoline;
static sqInt ceTraceBlockActivationTrampoline;
static sqInt ceTraceLinkedSendTrampoline;
static sqInt ceTraceStoreTrampoline;
static sqInt checkedEntryAlignment;
static sqInt closedPICSize;
static sqInt codeBase;
#if DUAL_MAPPED_CODE_ZONE
static sqInt codeToDataDelta;
#else
# define codeToDataDelta 0
#endif
static sqInt cogConstituentIndex;
static sqInt compactionInProgress;
static sqInt compilationPass;
static sqInt compilationTrace;
static sqInt cPICCaseSize;
static sqInt cPICEndOfCodeOffset;
static sqInt cPICEndSize;
static CogMethod * cPICPrototype;
static sqInt currentCallCleanUpSize;
static sqInt debugBytecodePointers;
static sqInt debugFixupBreaks;
static sqInt debugOpcodeIndices;
static sqInt debugStackPointers;
static sqInt directedSuperBindingSendTrampolines[NumSendTrampolines];
static sqInt directedSuperSendTrampolines[NumSendTrampolines];
static sqInt disassemblingMethod;
static AbstractInstruction * endCPICCase0;
static sqInt endPC;
static AbstractInstruction * entry;
static sqInt entryPointMask;
static CogMethod * enumeratingCogMethod;
static sqInt expectedFPAlignment;
static sqInt expectedSPAlignment;
static sqInt extA;
static sqInt extB;
static sqInt firstCPICCaseOffset;
static sqInt firstOpcodeIndex;
static sqInt firstSend;
static BytecodeFixup * fixups;
static AbstractInstruction * fullBlockEntry;
static AbstractInstruction * fullBlockNoContextSwitchEntry;
static BytecodeDescriptor generatorTable[512] = {
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushReceiverBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantTrueBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantFalseBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantNilBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genReturnReceiver, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTrue, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnFalse, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnNil, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTopFromMethod, 0, needsFrameIfInBlock, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTopFromBlock, 0, needsFrameNever, -1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ extendedPushBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ extendedStoreBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ extendedStoreAndPopBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ genExtendedSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ doubleExtendedDoAnythingBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtendedSuperBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0 },
	{ genSecondExtendedSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genPopStackBytecode, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ duplicateTopBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushActiveContextBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushNewArrayBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genCallPrimitiveBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushClosureCopyCopiedValuesBytecode, v3BlockCodeSize, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AddRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, SubRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLess, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreater, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLessOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreaterOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpNonZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AndRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, OrRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorClass, 0, needsFrameIfStackGreaterThanOne, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorNotEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariable16CasesBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushReceiverBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantTrueBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantFalseBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantNilBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantZeroBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantOneBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushPseudoVariable, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ duplicateTopBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genReturnReceiver, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTrue, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnFalse, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnNil, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTopFromMethod, 0, needsFrameIfInBlock, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnNilFromBlock, 0, needsFrameNever, -1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
	{ genReturnTopFromBlock, 0, needsFrameNever, -1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtNopBytecode, 0, needsFrameNever, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AddRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, SubRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLess, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreater, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLessOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreaterOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpNonZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AndRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, OrRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorClass, 0, needsFrameIfStackGreaterThanOne, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorNotEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfTrue, v3ShortForwardBranchDistance, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPopStackBytecode, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genUnconditionalTrapBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ extABytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ extBBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genExtPushReceiverVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genExtPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushLiteralBytecode, 0, needsFrameNever, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongPushTemporaryVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genPushNewArrayBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushIntegerBytecode, 0, needsFrameNever, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushCharacterBytecode, 0, needsFrameNever, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtSendSuperBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genCallMappedInlinedPrimitive, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },
	{ genExtUnconditionalJump, v4LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtJumpIfTrue, v4LongBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtJumpIfFalse, v4LongBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtStoreAndPopReceiverVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ genExtStoreAndPopLiteralVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 0, 0, 0 },
	{ genLongStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtStoreReceiverVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ genExtStoreLiteralVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 0, 0, 0 },
	{ genLongStoreTemporaryVariableBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genCallPrimitiveBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genExtPushFullClosureBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genExtPushClosureBytecode, v4BlockCodeSize, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
	{ genPushRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 }
};
static sqInt guardPageSize;
static sqInt initialPC;
static sqInt introspectionData;
static sqInt introspectionDataIndex;
static sqInt lastDumpedLiteralIndex;
static sqInt lastSend;
static usqInt limitAddress;
static AbstractInstruction * literals;
static sqInt literalsSize;
static sqInt maxLitIndex;
static sqInt methodAbortTrampolines[4];
static sqInt methodBytesFreedSinceLastCompaction;
static sqInt methodCount;
static sqInt methodHeader;
static sqInt methodObj;
static sqInt methodOrBlockNumArgs;
static sqInt methodOrBlockNumTemps;
static usqIntptr_t minValidCallAddress;
static usqInt mzFreeStart;
static sqInt nextLiteralIndex;
static AbstractInstruction * noCheckEntry;
static sqInt numAbstractOpcodes;
static sqInt numExtB;
static usqInt objectReferencesInRuntime[NumObjRefsInRuntime+1];
static sqInt opcodeIndex;
static CogMethod *openPICList = 0;
static sqInt openPICSize;
static sqInt ordinarySendTrampolines[NumSendTrampolines];
static sqInt picAbortTrampolines[4];
static AbstractInstruction * picInterpretAbort;
static sqInt picMissTrampolines[4];
static AbstractInstruction * picMNUAbort;
static BytecodeDescriptor * prevBCDescriptor;
static PrimitiveDescriptor primitiveGeneratorTable[MaxCompiledPrimitiveIndex+1] = {
	{ 0, -1 },
	{ genPrimitiveAdd, 1 },
	{ genPrimitiveSubtract, 1 },
	{ genPrimitiveLessThan, 1 },
	{ genPrimitiveGreaterThan, 1 },
	{ genPrimitiveLessOrEqual, 1 },
	{ genPrimitiveGreaterOrEqual, 1 },
	{ genPrimitiveEqual, 1 },
	{ genPrimitiveNotEqual, 1 },
	{ genPrimitiveMultiply, 1 },
	{ genPrimitiveDivide, 1 },
	{ genPrimitiveMod, 1 },
	{ genPrimitiveDiv, 1 },
	{ genPrimitiveQuo, 1 },
	{ genPrimitiveBitAnd, 1 },
	{ genPrimitiveBitOr, 1 },
	{ genPrimitiveBitXor, 1 },
	{ genPrimitiveBitShift, 1 },
	{ genPrimitiveMakePoint, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveAsFloat, 0 },
	{ genPrimitiveFloatAdd, 1 },
	{ genPrimitiveFloatSubtract, 1 },
	{ genPrimitiveFloatLessThan, 1 },
	{ genPrimitiveFloatGreaterThan, 1 },
	{ genPrimitiveFloatLessOrEqual, 1 },
	{ genPrimitiveFloatGreaterOrEqual, 1 },
	{ genPrimitiveFloatEqual, 1 },
	{ genPrimitiveFloatNotEqual, 1 },
	{ genPrimitiveFloatMultiply, 1 },
	{ genPrimitiveFloatDivide, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveFloatSquareRoot, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveAt, 1 },
	{ genPrimitiveAtPut, 2 },
	{ genPrimitiveSize, 0 },
	{ genPrimitiveStringAt, 1 },
	{ genPrimitiveStringAtPut, 2 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ genPrimitiveObjectAt, 1 },
	{ 0, -1 },
	{ genPrimitiveNew, 0 },
	{ genPrimitiveNewWithArg, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentityHash, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveNewMethod, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitivePerform, -1 },
	{ genPrimitivePerformWithArguments, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveStringReplace, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentical, 1 },
	{ genPrimitiveClass, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveShallowCopy, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveStringCompareWith, 1 },
	{ genPrimitiveHashMultiply, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIntegerAt, 1 },
	{ genPrimitiveIntegerAtPut, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveNotIdentical, 1 },
	{ genPrimitiveAsCharacter, -1 },
	{ genPrimitiveImmediateAsInteger, 0 },
	{ 0, -1 },
	{ genPrimitiveSlotAt, 1 },
	{ genPrimitiveSlotAtPut, 2 },
	{ genPrimitiveIdentityHash, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ 0, -1 },
	{ genPrimitiveClosureValue, 0 },
	{ genPrimitiveClosureValue, 1 },
	{ genPrimitiveClosureValue, 2 },
	{ genPrimitiveClosureValue, 3 },
	{ genPrimitiveClosureValue, 4 },
	{ 0, -1 },
	{ genPrimitiveFullClosureValue, -1 },
	{ 0, -1 },
	{ genPrimitiveFullClosureValue, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveClosureValue, 0 },
	{ genPrimitiveClosureValue, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveSmallFloatAdd, 1 },
	{ genPrimitiveSmallFloatSubtract, 1 },
	{ genPrimitiveSmallFloatLessThan, 1 },
	{ genPrimitiveSmallFloatGreaterThan, 1 },
	{ genPrimitiveSmallFloatLessOrEqual, 1 },
	{ genPrimitiveSmallFloatGreaterOrEqual, 1 },
	{ genPrimitiveSmallFloatEqual, 1 },
	{ genPrimitiveSmallFloatNotEqual, 1 },
	{ genPrimitiveSmallFloatMultiply, 1 },
	{ genPrimitiveSmallFloatDivide, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveSmallFloatSquareRoot, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveHighBit, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveUninitializedNewWithArg, 1 }
};
static sqInt primitiveIndex;
static sqInt processorLock;
static sqInt receiverTags;
static sqInt runtimeObjectRefIndex;
static AbstractInstruction * sendMiss;
static sqInt simNativeSpillBase;
static CogSimStackNativeEntry simNativeStack[70];
static sqInt simNativeStackPtr;
static sqInt simNativeStackSize;
static sqInt simSpillBase;
static SimStackEntry simStack[70];
static sqInt simStackPtr;
static AbstractInstruction * stackCheckLabel;
static AbstractInstruction * stackOverflowCall;
static sqInt superSendTrampolines[NumSendTrampolines];
static sqInt tempOop;
static char *trampolineAddresses[NumTrampolines*2];
static sqInt trampolineTableIndex;
static sqInt uncheckedEntryAlignment;
static usqInt unpairedMethodList;
static sqInt varBaseAddress;
static usqInt youngReferrers;
static const int cStackAlignment = STACK_ALIGN_BYTES & STACK_ALIGN_MASK;
static int labelCounter;
static unsigned char codeModified;
static unsigned char dataCacheFlushRequired;
static unsigned char dataCacheLineLength;
static unsigned char deadCode;
static unsigned char directedSendUsesBinding;
static unsigned char hasAtomicInstructions;
static unsigned char hasMovableLiteral;
static unsigned char hasNativeFrame;
static unsigned char hasYoungReferent;
static unsigned char inBlock;
static unsigned char instructionCacheFlushRequired;
static unsigned char instructionCacheLineLength;
static unsigned char needsFrame;
static unsigned char regArgsHaveBeenPushed;
static unsigned char useTwoPaths;
static AbstractInstruction aMethodLabel;
static AbstractInstruction * const backEnd = &aMethodLabel;
static void (*ceFlushDCache)(usqIntptr_t from, usqIntptr_t to);
static void (*ceFlushICache)(usqIntptr_t from, usqIntptr_t to);
#if IMMUTABILITY
static sqInt ceStoreTrampolines[5];;
#endif
static AbstractInstruction * const methodLabel = &aMethodLabel;
static double thresholdRatio = 0.5;
sqInt blockNoContextSwitchOffset;
sqInt breakPC;
sqInt cbEntryOffset;
sqInt cbNoSwitchEntryOffset;
sqInt ceBaseFrameReturnTrampoline;
sqInt ceCannotResumeTrampoline;
sqInt ceCheckForInterruptTrampoline;
sqInt ceReturnToInterpreterTrampoline;
#if !defined(cFramePointerInUse)
sqInt cFramePointerInUse;
#endif
sqInt cmEntryOffset;
sqInt cmNoCheckEntryOffset;
usqInt methodZoneBase;
sqInt missOffset;
const char * traceFlagsMeanings[] = {
		"1: print trace", "2: trace sends", "4: trace block activations", "8: trace interpreter primitives",
		"16: trace events (context switches, GCs, etc)", "32: trace stack overflow (poll for events hook)",
		"64: trace linked sends", "128: trace fast C call interpreter primitives", null
	};
sqInt traceStores;
int PJWPNChange;
int PJWPNClear;
int PJWPNSet;
int PJWPNState;
int traceFlags = 8 /* prim trace log on by default */;
void (*ceCall0ArgsPIC)(void);
void (*ceCall1ArgsPIC)(void);
void (*ceCall2ArgsPIC)(void);
void (*ceCallCogCodePopReceiverAndClassRegs)(void);
void (*ceCallCogCodePopReceiverArg0Regs)(void);
void (*ceCallCogCodePopReceiverArg1Arg0Regs)(void);
void (*ceCallCogCodePopReceiverReg)(void);
void (*ceCaptureCStackPointers)(void);
void (*ceEnterCogCodePopReceiverReg)(void);
usqIntptr_t (*ceGetFP)(void);
usqIntptr_t (*ceGetSP)(void);
void (*ceInvokeInterpret)(void);
void (*realCECallCogCodePopReceiverAndClassRegs)(void);
void (*realCECallCogCodePopReceiverArg0Regs)(void);
void (*realCECallCogCodePopReceiverArg1Arg0Regs)(void);
void (*realCECallCogCodePopReceiverReg)(void);
void (*realCEEnterCogCodePopReceiverReg)(void);


/*** Macros ***/
#define dataCacheFlushRequired(ign) dataCacheFlushRequired
#define dataCacheLineLength(ign) dataCacheLineLength
#define flushDCacheFromto(me,startAddress,endAddress) ceFlushDCache(startAddress,endAddress)
#define inlineCacheValueForSelectorin(backEnd,selector,aCogMethod) indexForSelectorin(selector,aCogMethod)
#define instructionCacheFlushRequired(ign) instructionCacheFlushRequired
#define instructionCacheLineLength(ign) instructionCacheLineLength
#define roundUpToMethodAlignment(ignored,numBytes) (((numBytes) + 15) & -16)
#define setDataCacheFlushRequired(ign,b) dataCacheFlushRequired = b
#define setDataCacheLineLength(ign,n) dataCacheLineLength = n
#define setInstructionCacheFlushRequired(ign,b) instructionCacheFlushRequired = b
#define setInstructionCacheLineLength(ign,n) instructionCacheLineLength = n
#define cPICNumCases stackCheckOffset
#define cPICNumCasesHack hack hack hack i.e. the getter macro does all the work
#define abstractInstructionAt(index) (&abstractOpcodes[index])
#define addressIsInInstructions(address) (!((usqInt)(address) & (BytesPerWord-1)) \
							&& (address) >= &abstractOpcodes[0] \
							&& (address) < &abstractOpcodes[opcodeIndex])
#define allocateBlockStarts(numBlocks) do { \
		blockStarts = (numBlocks) ? alloca(sizeof(BlockStart) * (numBlocks)) : 0; \
} while (0)
#define assertValidDualZone() true
#define assertValidDualZoneReadAddress(address) 0
#define assertValidDualZoneWriteAddress(address) 0
#define backEnd() backEnd
#define blockAlignment() 8
#define blockStartAt(index) (&blockStarts[index])
#define ceBaseFrameReturnPC() ceBaseFrameReturnTrampoline
#define ceCannotResumePC() ((usqInt)ceCannotResumeTrampoline)
#define ceCheckForInterruptTrampoline() ceCheckForInterruptTrampoline
#define ceReturnToInterpreterPC() ((usqInt)ceReturnToInterpreterTrampoline)
#define codeByteAtput(address,value) byteAtput((address) + codeToDataDelta, value)
#define codeLong32Atput(address,value) long32Atput((address) + codeToDataDelta, value)
#define codeLong64Atput(address,value) long64Atput((address) + codeToDataDelta, value)
#define codeLongAtput(address,value) longAtput((address) + codeToDataDelta, value)
#define codeMemcpy(dest,src,bytes) memcpy(dest,src,bytes)
#define codeMemmove(dest,src,bytes) memmove((char *)(dest)+codeToDataDelta,src,bytes)
#define cr() putchar('\n')
#define entryOffset() cmEntryOffset
#define generatorAt(index) (&generatorTable[index])
#define getCodeToDataDelta() codeToDataDelta
#define getIsObjectReference() 2
#define halt() warning("halt")
#define haltmsg(msg) warning("halt: " msg)
#define interpretOffset() missOffset
#define mapPerMethodProfile() 0
#define maxCogCodeSize() (16*1024*1024)
#define maybeBreakGeneratingFromto(address,end) 0
#define maybeBreakGeneratingInstructionWithIndex(i) 0
#define maybeHaltIfDebugPC() 0
#define methodLabel() methodLabel
#define methodZoneBase() methodZoneBase
#define minCogMethodAddress() methodZoneBase
#define moveProfileToMethods() 0
#define noCheckEntryOffset() cmNoCheckEntryOffset
#define noContextSwitchBlockEntryOffset() blockNoContextSwitchOffset
#define notYetImplemented() warning("not yet implemented")
#define null 0
#define printNum(n) printf("%" PRIdSQINT, (sqInt) (n))
#define printOnTrace() (traceFlags & 1)
#define recordBlockTrace() (traceFlags & 4)
#define recordEventTrace() (traceFlags & 16)
#define recordFastCCallPrimTrace() (traceFlags & 128)
#define recordOverflowTrace() (traceFlags & 32)
#define recordPrimTrace() (traceFlags & 8)
#define recordSendTrace() (traceFlags & 2)
#define reportError(n) warning("compilation error")
#define setHasMovableLiteral(b) (hasMovableLiteral = (b))
#define setHasYoungReferent(b) (hasYoungReferent = (b))
#define varBaseAddress() varBaseAddress
#define nextOpenPIC methodObject
#define nextOpenPICHack hack hack hack i.e. the getter macro does all the work
#define freeStart() mzFreeStart
#define limitZony() ((CogMethod *)mzFreeStart)
#define methodBytesFreedSinceLastCompaction() methodBytesFreedSinceLastCompaction
#define youngReferrers() youngReferrers
#define numRegArgs() 2
#define maybeConstant(sse) ((sse)->constant)
#define literalInstructionAt(index) (&literals[index])
#define fullBlockEntryOffset() cbEntryOffset
#define fullBlockNoContextSwitchEntryOffset() cbNoSwitchEntryOffset
#define needsFrame() needsFrame
#define fixupAtIndex(index) (&fixups[index])
#define simNativeStackAt(index) (simNativeStack + (index))
#define simSelf() simStack
#define simStackAt(index) (simStack + (index))
#define traceDescriptor(ign) 0
#define traceFixupmerge(igu,ana) 0
#define traceMerge(ign) 0
#define traceSimStack() 0
#define traceSpill(ign) 0
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))


/*** Methods ***/

	/* CogAbstractInstruction>>#addDependent: */
static NoDbgRegParms AbstractInstruction *
addDependent(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *anInstruction)
{
	if ((self_in_CogAbstractInstruction->dependent)) {
		(anInstruction->dependent = (self_in_CogAbstractInstruction->dependent));
	}
	return ((self_in_CogAbstractInstruction->dependent) = anInstruction);
}


/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them. */

	/* CogAbstractInstruction>>#availableFloatRegisterOrNoneFor: */
static NoDbgRegParms sqInt
availableFloatRegisterOrNoneFor(AbstractInstruction *self_in_CogAbstractInstruction, sqInt liveRegsMask)
{
	if (!(((liveRegsMask & ((1U << DPFPReg0))) != 0))) {
		return DPFPReg0;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg1))) != 0))) {
		return DPFPReg1;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg2))) != 0))) {
		return DPFPReg2;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg3))) != 0))) {
		return DPFPReg3;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg4))) != 0))) {
		return DPFPReg4;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg5))) != 0))) {
		return DPFPReg5;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg6))) != 0))) {
		return DPFPReg6;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg7))) != 0))) {
		return DPFPReg7;
	}
	return NoReg;
}


/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them.
	N.B. Do /not/ allocate TempReg. */

	/* CogAbstractInstruction>>#availableRegisterOrNoneFor: */
static NoDbgRegParms sqInt
availableRegisterOrNoneFor(AbstractInstruction *self_in_CogAbstractInstruction, sqInt liveRegsMask)
{
	if (!(((liveRegsMask & ((1U << Arg1Reg))) != 0))) {
		return Arg1Reg;
	}
	if (!(((liveRegsMask & ((1U << Arg0Reg))) != 0))) {
		return Arg0Reg;
	}
	if (!(((liveRegsMask & ((1U << SendNumArgsReg))) != 0))) {
		return SendNumArgsReg;
	}
	if (!(((liveRegsMask & ((1U << ClassReg))) != 0))) {
		return ClassReg;
	}
	if (!(((liveRegsMask & ((1U << ReceiverResultReg))) != 0))) {
		return ReceiverResultReg;
	}
	return NoReg;
}


/*	For out-of-line literal support, clone a literal from a literal. */

	/* CogAbstractInstruction>>#cloneLiteralFrom: */
static NoDbgRegParms AbstractInstruction *
cloneLiteralFrom(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *existingLiteral)
{
	assert((((existingLiteral->opcode)) == Literal)
	 && ((!((self_in_CogAbstractInstruction->dependent)))
	 && (!((self_in_CogAbstractInstruction->address)))));
	(self_in_CogAbstractInstruction->opcode) = Literal;
	(self_in_CogAbstractInstruction->annotation) = (existingLiteral->annotation);
	((self_in_CogAbstractInstruction->operands))[0] = (((existingLiteral->operands))[0]);
	((self_in_CogAbstractInstruction->operands))[1] = (((existingLiteral->operands))[1]);
	((self_in_CogAbstractInstruction->operands))[2] = (((existingLiteral->operands))[2]);
	return self_in_CogAbstractInstruction;
}


/*	Generate concrete machine code for the instruction at actualAddress,
	setting machineCodeSize, and answer the following address. */

	/* CogAbstractInstruction>>#concretizeAt: */
static NoDbgRegParms sqInt
concretizeAt(AbstractInstruction *self_in_CogAbstractInstruction, sqInt actualAddress)
{
	(self_in_CogAbstractInstruction->address) = actualAddress;
	(self_in_CogAbstractInstruction->machineCodeSize) = dispatchConcretize(self_in_CogAbstractInstruction);
	assert((((self_in_CogAbstractInstruction->maxSize)) == null)
	 || (((self_in_CogAbstractInstruction->maxSize)) >= ((self_in_CogAbstractInstruction->machineCodeSize))));
	return actualAddress + ((self_in_CogAbstractInstruction->machineCodeSize));
}


/*	Load the stack pointer register with that of the C stack, effecting
	a switch to the C stack. Used when machine code calls into the
	CoInterpreter run-time (e.g. to invoke interpreter primitives). */

	/* CogAbstractInstruction>>#genLoadCStackPointer */
static NoDbgRegParms sqInt
genLoadCStackPointer(AbstractInstruction *self_in_CogAbstractInstruction)
{
	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveAwR, cStackPointerAddress(), NativeSPReg));
	return 0;
}


/*	Switch back to the Smalltalk stack where there may be a C return address
	on top of stack below
	the last primitive argument. Assign SPReg first because typically it is
	used immediately afterwards.
 */

	/* CogAbstractInstruction>>#genLoadStackPointerForPrimCall: */
static NoDbgRegParms sqInt
genLoadStackPointerForPrimCall(AbstractInstruction *self_in_CogAbstractInstruction, sqInt spareReg)
{
	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveAwR, stackPointerAddress(), SPReg));
	return 0;
}


/*	Switch back to the Smalltalk stack where there may be a C return address
	on top of stack below
	the last primitive argument. Assign SPReg first because typically it is
	used immediately afterwards.
 */

	/* CogAbstractInstruction>>#genLoadStackPointersForPrimCall: */
static NoDbgRegParms sqInt
genLoadStackPointersForPrimCall(AbstractInstruction *self_in_CogAbstractInstruction, sqInt spareReg)
{
	genLoadStackPointers(self_in_CogAbstractInstruction);
	return 0;
}


/*	Generic register swap code. Subclasses for processors that have a true
	exchange operation will override to use it. */

	/* CogAbstractInstruction>>#genSwapR:R:Scratch: */
static NoDbgRegParms AbstractInstruction *
genSwapRRScratch(AbstractInstruction *self_in_CogAbstractInstruction, sqInt regA, sqInt regB, sqInt regTmp)
{
    AbstractInstruction *first;

	first = genoperandoperand(MoveRR, regA, regTmp);

	/* MoveR:R: */
	genoperandoperand(MoveRR, regB, regA);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, regB);
	return first;
}

	/* CogAbstractInstruction>>#genWriteCResultIntoReg: */
static NoDbgRegParms AbstractInstruction *
genWriteCResultIntoReg(AbstractInstruction *self_in_CogAbstractInstruction, sqInt abstractRegister)
{
	if ((abstractRegister != NoReg)
	 && (abstractRegister != ABIResultReg)) {
		genoperandoperand(MoveRR, ABIResultReg, abstractRegister);
	}
	return self_in_CogAbstractInstruction;
}

	/* CogAbstractInstruction>>#genWriteCSecondResultIntoReg: */
static NoDbgRegParms AbstractInstruction *
genWriteCSecondResultIntoReg(AbstractInstruction *self_in_CogAbstractInstruction, sqInt abstractRegister)
{
	if ((abstractRegister != NoReg)
	 && (abstractRegister != (cResultRegisterHigh()))) {
		genoperandoperand(MoveRR, cResultRegisterHigh(), abstractRegister);
	}
	return self_in_CogAbstractInstruction;
}


/*	At least x86, x86_64, AArch32 and AArch64 have a 64-bit performance
	counter. Subclasses can turn this off if rquired. */

	/* CogAbstractInstruction>>#has64BitPerformanceCounter */
static NoDbgRegParms sqInt
has64BitPerformanceCounter(AbstractInstruction *self_in_CogAbstractInstruction)
{
	return 1;
}


/*	For out-of-line literal support, initialize a sharable literal. */

	/* CogAbstractInstruction>>#initializeSharableLiteral: */
static NoDbgRegParms AbstractInstruction *
initializeSharableLiteral(AbstractInstruction *self_in_CogAbstractInstruction, sqInt literal)
{
	(self_in_CogAbstractInstruction->opcode) = Literal;

	/* separate := nil for Slang */
	(self_in_CogAbstractInstruction->annotation) = null;
	(self_in_CogAbstractInstruction->address) = null;
	(self_in_CogAbstractInstruction->dependent) = null;
	((self_in_CogAbstractInstruction->operands))[0] = literal;
	((self_in_CogAbstractInstruction->operands))[1] = (1 + ((((usqInt)(BytesPerOop) << 1))));
	((self_in_CogAbstractInstruction->operands))[2] = -1;
	return self_in_CogAbstractInstruction;
}


/*	For out-of-line literal support, initialize an unsharable literal. */

	/* CogAbstractInstruction>>#initializeUniqueLiteral: */
static NoDbgRegParms AbstractInstruction *
initializeUniqueLiteral(AbstractInstruction *self_in_CogAbstractInstruction, sqInt literal)
{
	(self_in_CogAbstractInstruction->opcode) = Literal;

	/* separate := nil for Slang */
	(self_in_CogAbstractInstruction->annotation) = null;
	(self_in_CogAbstractInstruction->address) = null;
	(self_in_CogAbstractInstruction->dependent) = null;
	((self_in_CogAbstractInstruction->operands))[0] = literal;
	((self_in_CogAbstractInstruction->operands))[1] = (0 + ((((usqInt)(BytesPerOop) << 1))));
	((self_in_CogAbstractInstruction->operands))[2] = -1;
	return self_in_CogAbstractInstruction;
}


/*	Set the target of a jump instruction. These all have the target in the
	first operand. */

	/* CogAbstractInstruction>>#jmpTarget: */
static NoDbgRegParms AbstractInstruction *
jmpTarget(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *anAbstractInstruction)
{
	((self_in_CogAbstractInstruction->operands))[0] = (((usqInt)anAbstractInstruction));
	return anAbstractInstruction;
}


/*	We assume here that calls and jumps look the same as regards their
	displacement. This works on at least x86, ARM and x86_64. Processors on
	which that isn't the
	case can override as necessary. */

	/* CogAbstractInstruction>>#relocateJumpLongBeforeFollowingAddress:by: */
static NoDbgRegParms AbstractInstruction *
relocateJumpLongBeforeFollowingAddressby(AbstractInstruction *self_in_CogAbstractInstruction, sqInt pc, sqInt delta)
{
	relocateCallBeforeReturnPCby(self_in_CogAbstractInstruction, pc, delta);
	return self_in_CogAbstractInstruction;
}


/*	Relocate a long conditional jump before pc. Default to relocating a
	non-conditional jump.
	Processors that have different formats for conditional and unconditional
	jumps override. */

	/* CogAbstractInstruction>>#relocateJumpLongConditionalBeforeFollowingAddress:by: */
static NoDbgRegParms AbstractInstruction *
relocateJumpLongConditionalBeforeFollowingAddressby(AbstractInstruction *self_in_CogAbstractInstruction, sqInt pc, sqInt delta)
{
	relocateJumpLongBeforeFollowingAddressby(self_in_CogAbstractInstruction, pc, delta);
	return self_in_CogAbstractInstruction;
}

	/* CogAbstractInstruction>>#resolveJumpTarget */
static NoDbgRegParms AbstractInstruction *
resolveJumpTarget(AbstractInstruction *self_in_CogAbstractInstruction)
{
    BytecodeFixup *fixup;

	assert(isJump(self_in_CogAbstractInstruction));
	fixup = ((BytecodeFixup *) (((self_in_CogAbstractInstruction->operands))[0]));
	if (addressIsInFixups(fixup)) {
		assert(addressIsInInstructions((fixup->targetInstruction)));
		jmpTarget(self_in_CogAbstractInstruction, (fixup->targetInstruction));
	}
	return self_in_CogAbstractInstruction;
}


/*	Rewrite a CallFull instruction to call a different target. This variant is
	used to rewrite cached primitive calls.
	Answer the extent of the code change which is used to compute the range of
	the icache to flush.
	This defaults to rewriteCallAt:target:; processors that differentiate
	between Call and CallFull will override. */

	/* CogAbstractInstruction>>#rewriteCallFullAt:target: */
static NoDbgRegParms sqInt
rewriteCallFullAttarget(AbstractInstruction *self_in_CogAbstractInstruction, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteCallAttarget(self_in_CogAbstractInstruction, callSiteReturnAddress, callTargetAddress);
}


/*	Rewrite a conditional jump long to jump to target. This version defaults
	to using
	rewriteJumpLongAt:, which works for many ISAs. Subclasses override if
	necessary.  */

	/* CogAbstractInstruction>>#rewriteConditionalJumpLongAt:target: */
static NoDbgRegParms sqInt
rewriteConditionalJumpLongAttarget(AbstractInstruction *self_in_CogAbstractInstruction, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteImm26JumpBeforetarget(self_in_CogAbstractInstruction, callSiteReturnAddress, callTargetAddress);
}


/*	C6.2.4 ADD (immediate) p761 */

	/* CogARMv8Compiler>>#addrn:rd:imm:shiftBy12: */
static NoDbgRegParms sqInt
addrnrdimmshiftBy12(AbstractInstruction *self_in_CogARMv8Compiler, sqInt rn, sqInt rd, sqInt offset, sqInt shiftBy12)
{
	assert(((offset >= 0) && (offset <= (0xFFF))));
	return (((0x91000000U + ((shiftBy12
		? 0x400000
		: 0))) + ((((usqInt)(offset) << 10)))) + ((((usqInt)(rn) << 5)))) + rd;
}

	/* CogARMv8Compiler>>#brlink:reg: */
static NoDbgRegParms sqInt
brlinkreg(AbstractInstruction *self_in_CogARMv8Compiler, sqInt link, sqInt reg)
{
	return ((0xD61F0000U) + ((link
		? 0x200000
		: 0))) + ((((usqInt)(reg) << 5)));
}

	/* CogARMv8Compiler>>#callFullInstructionByteSize */
static NoDbgRegParms sqInt
callFullInstructionByteSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 8;
}


/*	ARM calls and jumps span +/- 32 mb, more than enough for intra-zone calls
	and jumps.
 */

	/* CogARMv8Compiler>>#callInstructionByteSize */
static NoDbgRegParms sqInt
callInstructionByteSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 4;
}

	/* CogARMv8Compiler>>#callTargetFromReturnAddress: */
static NoDbgRegParms sqInt
callTargetFromReturnAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc)
{
    unsigned int instr;

	/* C6.2.26 	B		C6-799
	   C6.2.33	BL		C6-812 */
	instr = long32At(mcpc - 4);
	assert(((((usqInt)(instr)) >> 26) == 37)
	 || ((((usqInt)(instr)) >> 26) == 5));
	return (((((sqLong) (((sqInt)((usqInt)((instr & (0x3FFFFFF))) << 38)))))) >> 36) + (mcpc - 4);
}

	/* CogARMv8Compiler>>#cmpC32RTempByteSize */
static NoDbgRegParms sqInt
cmpC32RTempByteSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 8;
}

	/* CogARMv8Compiler>>#computeJumpTargetOffset */
static NoDbgRegParms sqInt
computeJumpTargetOffset(AbstractInstruction *self_in_CogARMv8Compiler)
{
    AbstractInstruction *jumpTarget;

	/* begin jumpTargetAddress */
	jumpTarget = ((AbstractInstruction *) (((self_in_CogARMv8Compiler->operands))[0]));
	assertSaneJumpTarget(jumpTarget);
	if (/* isAnInstruction: */
		(addressIsInInstructions(jumpTarget))
	 || (jumpTarget == (methodLabel))) {
		jumpTarget = ((AbstractInstruction *) ((jumpTarget->address)));
	}
	assert(jumpTarget != 0);
	return (((sqLong) jumpTarget)) - (((sqLong) ((self_in_CogARMv8Compiler->address))));
}


/*	Answer the index of the low order one bit.
	2r00101000 lowBit (Answers: 4)
	2r-00101000 lowBit (Answers: 4)
	This is an implementation of SmallInteger>>lowBit */

	/* CogARMv8Compiler>>#computeLowBit: */
static NoDbgRegParms sqInt
computeLowBit(AbstractInstruction *self_in_CogARMv8Compiler, sqInt nArg)
{
    sqInt n;
    sqInt result;

	if (!nArg) {
		return 0;
	}
	n = nArg;
	result = 1;
	while ((!(n & 0xFF))) {
		result += 8;
		n = (((usqInt)(n)) >> 8);
	}
	if ((!(n & 15))) {
		result += 4;
		n = (((usqInt)(n)) >> 4);
	}
	if ((!(n & 3))) {
		result += 2;
		n = (((usqInt)(n)) >> 2);
	}
	return (((n & 1) != 0)
			? result
			: result + 1);
}


/*	Because we don't use Thumb, each ARMv8 instruction has 4 bytes. Several
	abstract opcodes need more than one instruction. Instructions that refer
	to constants and/or literals depend on literals being stored out-of-line
	or encoded
	in immediate instruction fields (i.e. we only support
	OutOfLineLiteralsManager. 
	N.B. The ^N forms are to get around the old bytecode compiler's long
	branch limits which are exceeded when each case jumps around the
	otherwise.  */

	/* CogARMv8Compiler>>#computeMaximumSize */
static NoDbgRegParms sqInt
computeMaximumSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
    sqInt constant;
    sqInt imm;
    sqInt immediate;
    sqInt immrSqInt;
    usqInt mask;
    usqInt nImms;
    usqInt nUsqInt;
    sqInt numLeadingOnes;
    sqInt numTrailingOnes;
    sqInt rotateCount;
    sqInt size;

	switch ((self_in_CogARMv8Compiler->opcode)) {
	case Label:
		return 0;

	case Literal:
		/* begin literalSize */
		assert(((self_in_CogARMv8Compiler->opcode)) == Literal);
		return (((self_in_CogARMv8Compiler->operands))[1]
				? (((((self_in_CogARMv8Compiler->operands))[1])) >> 1) & 15
				: BytesPerOop);

	case AlignmentNops:
		return (((self_in_CogARMv8Compiler->operands))[0]) - 4;

	case CallFull:
	case JumpFull:
	case JumpLongZero:
	case JumpLongNonZero:
	case JumpMulOverflow:
	case JumpNoMulOverflow:
	case JumpFPOrdered:
	case JumpFPUnordered:
	case AddCwR:
	case AndCwR:
	case CmpCwR:
	case CmpC32R:
	case OrCwR:
	case SubCwR:
	case XorCwR:
	case PushCw:
	case PushCq:
		return 8;

	case RetN:
	case NativeRetN:
		return (((self_in_CogARMv8Compiler->operands))[0]
				? 8
				: 4);

	case AddCqR:
	case AddCqRR:
	case CmpCqR:
	case SubCqR:
	case LoadEffectiveAddressMwrR:
		immediate = ((sqLong) (((self_in_CogARMv8Compiler->operands))[0]));

		/* begin isPossiblyShiftableNegatableImm12:ifTrue:ifFalse: */
		if (((immediate >= (-4096)) && (immediate <= (0xFFF)))) {
			return 4;
		}
		if (((!(immediate & (0xFFF))))
		 && (((((immediate) >> 12) >= (-4096)) && (((immediate) >> 12) <= (0xFFF))))) {
			return 4;
		}
		return 8;

	case AndCqR:
	case OrCqR:
	case OrCqRR:
	case TstCqR:
	case XorCqR:
		constant = ((self_in_CogARMv8Compiler->operands))[0];

		/* begin isImmNImmSImmREncodableBitmask:ifTrue:ifFalse: */
		if (((constant >= -1) && (constant <= 0))) {
			return 8;
		}

		/* First, determine the element size. */
		imm = constant;
		size = 32;
		while (1) {
			mask = (1ULL << size) - 1;
			if (!(((imm & mask) != ((((usqInt)(imm)) >> size) & mask)
					? ((size = size * 2),
					0)
					: size > 2))) break;
			size = size / 2;
		}
		mask = ((usqInt)((0xFFFFFFFFFFFFFFFFULL))) >> (64 - size);
		imm = imm & mask;
		if (isShiftedMask(self_in_CogARMv8Compiler, imm)) {
			rotateCount = countTrailingZeros(self_in_CogARMv8Compiler, imm);
			numTrailingOnes = countTrailingOnes(self_in_CogARMv8Compiler, ((usqInt)(imm)) >> rotateCount);
		}
		else {
			imm = imm | (~(usqIntptr_t)mask);
			if (!(isShiftedMask(self_in_CogARMv8Compiler, imm))) {
				return 8;
			}
			numLeadingOnes = countLeadingOnes(self_in_CogARMv8Compiler, imm);
			rotateCount = 64 - numLeadingOnes;
			numTrailingOnes = (numLeadingOnes + (countTrailingOnes(self_in_CogARMv8Compiler, imm))) - (64 - size);
		}
		assert(size > rotateCount);

		/* If size has a 1 in the n'th bit, create a value that has zeroes in bits [0, n] and ones above that. */
		immrSqInt = (size - rotateCount) & (size - 1);

		/* Or the CTO value into the low bits, which must be below the Nth bit mentioned above. */
		nImms = ((sqInt)((usqInt)((~(usqIntptr_t)(size - 1))) << 1));

		/* Extract the seventh bit and toggle it to create the N field. */
		nImms = nImms | (numTrailingOnes - 1);
		nUsqInt = (((nImms) >> 6) & 1) ^ 1;
		nImms = nImms & 0x3F;
		assert((decodeNimmsimmr(self_in_CogARMv8Compiler, nUsqInt, nImms, immrSqInt)) == (((usqInt) constant)));
		return 4;

	case AndCqRR:

		/* N.B. For three operand logical ops only support AndCqRR with a NativeSPReg target, used for alignment purposes. */
		constant = ((self_in_CogARMv8Compiler->operands))[0];

		/* begin isImmNImmSImmREncodableBitmask:ifTrue:ifFalse: */
		if (((constant >= -1) && (constant <= 0))) {
			return ((((self_in_CogARMv8Compiler->operands))[2]) == SP
					? 12
					: 8);
		}

		/* First, determine the element size. */
		imm = constant;
		size = 32;
		while (1) {
			mask = (1ULL << size) - 1;
			if (!(((imm & mask) != ((((usqInt)(imm)) >> size) & mask)
					? ((size = size * 2),
					0)
					: size > 2))) break;
			size = size / 2;
		}
		mask = ((usqInt)((0xFFFFFFFFFFFFFFFFULL))) >> (64 - size);
		imm = imm & mask;
		if (isShiftedMask(self_in_CogARMv8Compiler, imm)) {
			rotateCount = countTrailingZeros(self_in_CogARMv8Compiler, imm);
			numTrailingOnes = countTrailingOnes(self_in_CogARMv8Compiler, ((usqInt)(imm)) >> rotateCount);
		}
		else {
			imm = imm | (~(usqIntptr_t)mask);
			if (!(isShiftedMask(self_in_CogARMv8Compiler, imm))) {
				return ((((self_in_CogARMv8Compiler->operands))[2]) == SP
						? 12
						: 8);
			}
			numLeadingOnes = countLeadingOnes(self_in_CogARMv8Compiler, imm);
			rotateCount = 64 - numLeadingOnes;
			numTrailingOnes = (numLeadingOnes + (countTrailingOnes(self_in_CogARMv8Compiler, imm))) - (64 - size);
		}
		assert(size > rotateCount);

		/* If size has a 1 in the n'th bit, create a value that has zeroes in bits [0, n] and ones above that. */
		immrSqInt = (size - rotateCount) & (size - 1);

		/* Or the CTO value into the low bits, which must be below the Nth bit mentioned above. */
		nImms = ((sqInt)((usqInt)((~(usqIntptr_t)(size - 1))) << 1));

		/* Extract the seventh bit and toggle it to create the N field. */
		nImms = nImms | (numTrailingOnes - 1);
		nUsqInt = (((nImms) >> 6) & 1) ^ 1;
		nImms = nImms & 0x3F;
		assert((decodeNimmsimmr(self_in_CogARMv8Compiler, nUsqInt, nImms, immrSqInt)) == (((usqInt) constant)));
		return ((((self_in_CogARMv8Compiler->operands))[2]) == SP
				? 8
				: 4);

	case SubRR:
	case SubRRR:
		return ((((self_in_CogARMv8Compiler->operands))[0]) == SP
				? 8
				: 4);

	case MulOverflowRRR:
		return 12;

	case MoveAwR:
		return (((((((self_in_CogARMv8Compiler->operands))[0]) >= ((varBaseAddress) - (0x100))) && ((((self_in_CogARMv8Compiler->operands))[0]) <= (((varBaseAddress) + (0x1000)) - 1))))
		 || (/* addressIsInCurrentCompilation: */
			((((usqInt)(((self_in_CogARMv8Compiler->operands))[0]))) >= ((methodLabel->address)))
		 && ((((usqInt)(((self_in_CogARMv8Compiler->operands))[0]))) < ((((youngReferrers) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers) : (((methodLabel->address)) + MaxMethodSize)))))
				? ((((self_in_CogARMv8Compiler->operands))[1]) != SP
						? 4
						: 8)
				: ((((self_in_CogARMv8Compiler->operands))[1]) != SP
						? 8
						: 12));

	case MoveRAw:
		return (((((((self_in_CogARMv8Compiler->operands))[1]) >= ((varBaseAddress) - (0x100))) && ((((self_in_CogARMv8Compiler->operands))[1]) <= (((varBaseAddress) + (0x1000)) - 1))))
		 || (/* addressIsInCurrentCompilation: */
			((((usqInt)(((self_in_CogARMv8Compiler->operands))[1]))) >= ((methodLabel->address)))
		 && ((((usqInt)(((self_in_CogARMv8Compiler->operands))[1]))) < ((((youngReferrers) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers) : (((methodLabel->address)) + MaxMethodSize)))))
				? ((((self_in_CogARMv8Compiler->operands))[0]) != SP
						? 4
						: 8)
				: ((((self_in_CogARMv8Compiler->operands))[0]) != SP
						? 8
						: 12));

	case MoveAwRR:
		assert(isAddressRelativeToVarBase(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[0]));
		return (((((self_in_CogARMv8Compiler->operands))[1]) == SP)
		 || ((((self_in_CogARMv8Compiler->operands))[2]) == SP)
				? 8
				: 4);

	case MoveRRAw:
		assert(isAddressRelativeToVarBase(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[2]));
		return (((((self_in_CogARMv8Compiler->operands))[0]) == SP)
		 || ((((self_in_CogARMv8Compiler->operands))[1]) == SP)
				? 8
				: 4);

	case MoveAbR:
		return ((((((self_in_CogARMv8Compiler->operands))[0]) >= ((varBaseAddress) - (0x100))) && ((((self_in_CogARMv8Compiler->operands))[0]) <= (((varBaseAddress) + (0x1000)) - 1)))
				? 4
				: 8);

	case MoveRAb:
		return ((((((self_in_CogARMv8Compiler->operands))[1]) >= ((varBaseAddress) - (0x100))) && ((((self_in_CogARMv8Compiler->operands))[1]) <= (((varBaseAddress) + (0x1000)) - 1)))
				? 4
				: 8);

	case MoveMwrR:
	case MoveM32rR:
	case MoveM16rR:
	case MoveMbrR:
		return (isImm12orImm9offset(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[0])
				? 4
				: 8);

	case MoveRMwr:
	case MoveRM32r:
	case MoveRM16r:
	case MoveRMbr:
		return (isImm12orImm9offset(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[1])
				? 4
				: 8);

	case MoveM64rRd:
		return (isUnsigned12BitMultipleOf8(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[0])
				? 4
				: 8);

	case MoveRdM64r:
		return (isUnsigned12BitMultipleOf8(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[1])
				? 4
				: 8);

	default:
		return 4;
	}
	return 0;
}


/*	Will get inlined into concretizeAt: switch. */
/*	Sizing/generating jumps.
	Jump targets can be to absolute addresses or other abstract instructions.
	Generating initial trampolines instructions may have no maxSize and be to
	absolute addresses.
	Otherwise instructions must have a machineCodeSize which must be kept to. */

	/* CogARMv8Compiler>>#concretizeConditionalJump: */
static NoDbgRegParms sqInt
concretizeConditionalJump(AbstractInstruction *self_in_CogARMv8Compiler, sqInt conditionCode)
{
    AbstractInstruction *jumpTarget;
    sqInt offset;

	/* begin computeJumpTargetOffset */
	/* begin jumpTargetAddress */
	jumpTarget = ((AbstractInstruction *) (((self_in_CogARMv8Compiler->operands))[0]));
	assertSaneJumpTarget(jumpTarget);
	if (/* isAnInstruction: */
		(addressIsInInstructions(jumpTarget))
	 || (jumpTarget == (methodLabel))) {
		jumpTarget = ((AbstractInstruction *) ((jumpTarget->address)));
	}
	assert(jumpTarget != 0);
	offset = (((sqLong) jumpTarget)) - (((sqLong) ((self_in_CogARMv8Compiler->address))));
	assert((offset != 0)
	 && (isInImmediateBranchRange(self_in_CogARMv8Compiler, offset)));
	((self_in_CogARMv8Compiler->machineCode))[0] = ((/* begin cond:offset: */
	assert((offset & 3) == 0),
((0x54000000) + ((((usqInt)((offset & (0x1FFFFF))) << 3)))) + conditionCode));
	return 4;
}


/*	cogit processor disassembleInstructionAt: 0 In: machineCode object */
/*	cogit processor disassembleInstructionAt: 4 In: machineCode object */

	/* CogARMv8Compiler>>#concretizeCwRArithmetic:Rd: */
static NoDbgRegParms sqInt
concretizeCwRArithmeticRd(AbstractInstruction *self_in_CogARMv8Compiler, sqInt arithOp, sqInt destRegOrXZR)
{
    sqInt instrBytes;

	/* ADD (extended register) on page C6-758
	   ADDS (extended register) on page C6-766
	   SUB (extended register) on page C6-1308
	   SUBS (extended register) on page C6-1318 */
	instrBytes = emitMoveCwintoRat(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[0], RISCTempReg, 0);
	((self_in_CogARMv8Compiler->machineCode))[instrBytes / 4] = ((((((0x8B200000U) + ((((usqInt)(arithOp) << 29)))) + ((((usqInt)(RISCTempReg) << 16)))) + ((((usqInt)(UXTX) << 13)))) + (((((self_in_CogARMv8Compiler->operands))[1]) << 5))) + destRegOrXZR);
	return instrBytes + 4;
}

	/* CogARMv8Compiler>>#concretizeCwRLogical: */
static NoDbgRegParms sqInt
concretizeCwRLogical(AbstractInstruction *self_in_CogARMv8Compiler, sqInt op)
{
    usqInt constant;
    usqInt destReg;
    sqInt offset;

	constant = ((self_in_CogARMv8Compiler->operands))[0];
	destReg = ((self_in_CogARMv8Compiler->operands))[1];

	/* AND	(shifted register) - 64-bit variant on page C6-777
	   BIC	(shifted register) - 64-bit variant on page C6-808
	   ORR	(shifted register) - 64-bit variant on page C6-1127
	   ORN	(shifted register) - 64-bit variant on page C6-1123
	   EOR	(shifted register) - 64-bit variant on page C6-898
	   EON	(shifted register) - 64-bit variant on page C6-894
	   ANDS	(shifted register) - 64-bit variant on page C6-781
	   BICS	(shifted register) - 64-bit variant on page C6-810 */
	offset = emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, RISCTempReg, 0);
	((self_in_CogARMv8Compiler->machineCode))[offset / 4] = (((((0x8A000000U) + ((((usqInt)(op) << 29)))) + ((((usqInt)(RISCTempReg) << 16)))) + ((destReg << 5))) + destReg);
	return offset + 4;
}


/*	Issue a DC CIVAC, CVAC or CVAU
	C5.3.14	DC CIVAC, Data or unified Cache line Clean and Invalidate by VA to
	PoC		C5-486 Clean and Invalidate data cache by address to Point of
	Coherency. C5.3.16	DC CVAC, Data or unified Cache line Clean by VA to
	PoC						C5-490 Clean data cache by address to Point of Coherency.
	C5.3.19	DC CVAU, Clean data cache by address to Point of
	Unification				C5-496 Clean data cache by address to Point of Unification. */
/*	(operands at: 0) is the target register, accessed within
	concretizeCacheControlOp1:CRm:Op2: 
 */

	/* CogARMv8Compiler>>#concretizeDataCacheControl */
static NoDbgRegParms sqInt
concretizeDataCacheControl(AbstractInstruction *self_in_CogARMv8Compiler)
{
    int cacheOpcode;

	switch (((self_in_CogARMv8Compiler->operands))[1]) {
	case DC_CIVAC:
		cacheOpcode = 14;
		break;
	case DC_CVAC:
		cacheOpcode = 10;
		break;
	case DC_CVAU:
		cacheOpcode = 11;
		break;
	default:
		error("Case not found and no otherwise clause");
	}

	/* begin concretizeCacheControlOp1:CRm:Op2: */
	((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xD50B7000U) + ((((usqInt)(cacheOpcode) << 8)))) + (32)) + (((self_in_CogARMv8Compiler->operands))[0]));
	return 4;
}


/*	fill with operand 0 according to the processor's endianness */

	/* CogARMv8Compiler>>#concretizeFill32 */
static NoDbgRegParms sqInt
concretizeFill32(AbstractInstruction *self_in_CogARMv8Compiler)
{
	((self_in_CogARMv8Compiler->machineCode))[0] = (((self_in_CogARMv8Compiler->operands))[0]);
	return 4;
}


/*	Generate an out-of-line literal. Copy the value and any annotation from
	the stand-in in the literals manager. */

	/* CogARMv8Compiler>>#concretizeLiteral */
static NoDbgRegParms sqInt
concretizeLiteral(AbstractInstruction *self_in_CogARMv8Compiler)
{
    usqInt literal;
    AbstractInstruction *literalAsInstruction;

	literalAsInstruction = ((AbstractInstruction *) (((self_in_CogARMv8Compiler->operands))[0]));
	literal = (/* isAnInstruction: */
			(addressIsInInstructions(literalAsInstruction))
		 || (literalAsInstruction == (methodLabel))
				? (literalAsInstruction->address)
				: ((usqInt)literalAsInstruction));
	assert((((self_in_CogARMv8Compiler->dependent)))
	 && (((((self_in_CogARMv8Compiler->dependent))->opcode)) == Literal));
	if ((((self_in_CogARMv8Compiler->dependent))->annotation)) {
		assert(!((self_in_CogARMv8Compiler->annotation)));
		(self_in_CogARMv8Compiler->annotation) = (((self_in_CogARMv8Compiler->dependent))->annotation);
	}
	if ((((self_in_CogARMv8Compiler->dependent))->address)) {
		assert(((((self_in_CogARMv8Compiler->dependent))->address)) == ((self_in_CogARMv8Compiler->address)));
	}
	(((self_in_CogARMv8Compiler->dependent))->address = (self_in_CogARMv8Compiler->address));
	((self_in_CogARMv8Compiler->machineCode))[0] = (literal & 0xFFFFFFFFU);
	if (((/* begin literalSize */
		assert(((self_in_CogARMv8Compiler->opcode)) == Literal),
	(((self_in_CogARMv8Compiler->operands))[1]
				? (((((self_in_CogARMv8Compiler->operands))[1])) >> 1) & 15
				: BytesPerOop))) == 4) {
		return 4;
	}
	((self_in_CogARMv8Compiler->machineCode))[1] = ((literal) >> 32);
	return 8;
}

	/* CogARMv8Compiler>>#concretizeLoadEffectiveAddressMwrR */
static NoDbgRegParms sqInt
concretizeLoadEffectiveAddressMwrR(AbstractInstruction *self_in_CogARMv8Compiler)
{
    usqInt baseReg;
    usqInt destReg;
    sqInt instrBytes;
    sqInt offset;

	offset = ((self_in_CogARMv8Compiler->operands))[0];
	baseReg = ((self_in_CogARMv8Compiler->operands))[1];
	destReg = ((self_in_CogARMv8Compiler->operands))[2];

	/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
	if (((offset >= 0) && (offset <= (0xFFF)))) {
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0x91000000U) + ((((usqInt)(offset) << 10)))) + ((baseReg << 5))) + destReg);
		return 4;
		goto l1;
	}
	if (((!(offset & (0xFFF))))
	 && (((((offset) >> 12) >= 0) && (((offset) >> 12) <= (0xFFF))))) {
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0x91000000U) + (((usqInt)(offset)) >> 2)) + ((baseReg << 5))) + destReg);
		return 4;
		goto l1;
	}
l1:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

	/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
	if ((((-offset) >= 0) && ((-offset) <= (0xFFF)))) {
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0x91000000U) + ((((usqInt)((-offset)) << 10)))) + ((baseReg << 5))) + destReg);
		return 4;
		goto l2;
	}
	if (((!((-offset) & (0xFFF))))
	 && ((((((-offset)) >> 12) >= 0) && ((((-offset)) >> 12) <= (0xFFF))))) {
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0x91000000U) + (((usqInt)((-offset))) >> 2)) + ((baseReg << 5))) + destReg);
		return 4;
		goto l2;
	}
l2:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

	/* C6.2.3		ADD (extended register) C6-758 */
	instrBytes = emitMoveCwintoRat(self_in_CogARMv8Compiler, offset, RISCTempReg, 0);
	((self_in_CogARMv8Compiler->machineCode))[instrBytes / 4] = (((((0x8B200000U) + ((destReg << 16))) + ((((usqInt)(UXTX) << 13)))) + ((((usqInt)(RISCTempReg) << 5)))) + destReg);
	return instrBytes + 4;
}


/*	AND	(immediate) - 64-bit variant on page C6-775
	ORR	(immediate) - 64-bit variant on page C6-1125
	EOR	(immediate) - 64-bit variant on page C6-896
	ANDS	(immediate) - 64-bit variant on page C6-779
	C6.2.329	TST (immediate)	C6-1346 */

	/* CogARMv8Compiler>>#concretizeLogicalOp:CqRDest: */
static NoDbgRegParms sqInt
concretizeLogicalOpCqRDest(AbstractInstruction *self_in_CogARMv8Compiler, sqInt op, sqInt destReg)
{
    usqInt constant;
    sqInt effectiveDestReg;
    sqInt imm;
    sqInt immrSqInt;
    usqInt mask;
    usqInt nImms;
    usqInt nUsqInt;
    sqInt numLeadingOnes;
    sqInt numTrailingOnes;
    sqInt offset;
    sqInt rotateCount;
    sqInt size;
    usqInt srcReg;

	constant = ((self_in_CogARMv8Compiler->operands))[0];

	/* N.B. For three operand logical ops only support AndCq: const R: reg R: NativeSPReg, which is used for alignment. */
	srcReg = ((self_in_CogARMv8Compiler->operands))[1];
	effectiveDestReg = ((((self_in_CogARMv8Compiler->opcode)) == AndCqRR)
		 && (destReg == SP)
				? RISCTempReg
				: destReg);

	/* begin isImmNImmSImmREncodableBitmask:ifTrue:ifFalse: */
	if (((constant >= -1) && (constant <= 0))) {
		/* OPC	N
		   00		0	AND (shifted register) - 64-bit variant on page C6-777
		   00		1	BIC (shifted register) - 64-bit variant on page C6-808
		   01		0	ORR (shifted register) - 64-bit variant on page C6-1127
		   01		1	ORN (shifted register) - 64-bit variant on page C6-1123
		   10		0	EOR (shifted register) - 64-bit variant on page C6-898
		   10		1	EON (shifted register) - 64-bit variant on page C6-894
		   11		0	ANDS (shifted register) - 64-bit variant on page C6-781
		   11		0	BICS (shifted register) - 64-bit variant on page C6-810 */
		offset = emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, RISCTempReg, 0);
		((self_in_CogARMv8Compiler->machineCode))[offset / 4] = (((((0x8A000000U) + ((((usqInt)(op) << 29)))) + ((((usqInt)(RISCTempReg) << 16)))) + ((srcReg << 5))) + effectiveDestReg);
		offset += 4;
		goto l1;
	}

	/* First, determine the element size. */
	imm = constant;
	size = 32;
	while (1) {
		mask = (1ULL << size) - 1;
		if (!(((imm & mask) != ((((usqInt)(imm)) >> size) & mask)
				? ((size = size * 2),
				0)
				: size > 2))) break;
		size = size / 2;
	}
	mask = ((usqInt)((0xFFFFFFFFFFFFFFFFULL))) >> (64 - size);
	imm = imm & mask;
	if (isShiftedMask(self_in_CogARMv8Compiler, imm)) {
		rotateCount = countTrailingZeros(self_in_CogARMv8Compiler, imm);
		numTrailingOnes = countTrailingOnes(self_in_CogARMv8Compiler, ((usqInt)(imm)) >> rotateCount);
	}
	else {
		imm = imm | (~(usqIntptr_t)mask);
		if (!(isShiftedMask(self_in_CogARMv8Compiler, imm))) {
			/* OPC	N
			   00		0	AND (shifted register) - 64-bit variant on page C6-777
			   00		1	BIC (shifted register) - 64-bit variant on page C6-808
			   01		0	ORR (shifted register) - 64-bit variant on page C6-1127
			   01		1	ORN (shifted register) - 64-bit variant on page C6-1123
			   10		0	EOR (shifted register) - 64-bit variant on page C6-898
			   10		1	EON (shifted register) - 64-bit variant on page C6-894
			   11		0	ANDS (shifted register) - 64-bit variant on page C6-781
			   11		0	BICS (shifted register) - 64-bit variant on page C6-810 */
			offset = emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, RISCTempReg, 0);
			((self_in_CogARMv8Compiler->machineCode))[offset / 4] = (((((0x8A000000U) + ((((usqInt)(op) << 29)))) + ((((usqInt)(RISCTempReg) << 16)))) + ((srcReg << 5))) + effectiveDestReg);
			offset += 4;
			goto l1;
		}
		numLeadingOnes = countLeadingOnes(self_in_CogARMv8Compiler, imm);
		rotateCount = 64 - numLeadingOnes;
		numTrailingOnes = (numLeadingOnes + (countTrailingOnes(self_in_CogARMv8Compiler, imm))) - (64 - size);
	}
	assert(size > rotateCount);

	/* If size has a 1 in the n'th bit, create a value that has zeroes in bits [0, n] and ones above that. */
	immrSqInt = (size - rotateCount) & (size - 1);

	/* Or the CTO value into the low bits, which must be below the Nth bit mentioned above. */
	nImms = ((sqInt)((usqInt)((~(usqIntptr_t)(size - 1))) << 1));

	/* Extract the seventh bit and toggle it to create the N field. */
	nImms = nImms | (numTrailingOnes - 1);
	nUsqInt = (((nImms) >> 6) & 1) ^ 1;
	nImms = nImms & 0x3F;
	assert((decodeNimmsimmr(self_in_CogARMv8Compiler, nUsqInt, nImms, immrSqInt)) == (((usqInt) constant)));
	((self_in_CogARMv8Compiler->machineCode))[0] = (((((((0x92000000U) + ((((usqInt)(op) << 29)))) + ((nUsqInt << 22))) + ((((usqInt)(immrSqInt) << 16)))) + ((nImms << 10))) + ((srcReg << 5))) + effectiveDestReg);
	offset = 4;
l1:	/* end isImmNImmSImmREncodableBitmask:ifTrue:ifFalse: */;
	if (!((((self_in_CogARMv8Compiler->opcode)) == AndCqRR)
		 && (destReg == SP))) {
		return offset;
	}
	((self_in_CogARMv8Compiler->machineCode))[offset / 4] = (movernrd(self_in_CogARMv8Compiler, effectiveDestReg, destReg));
	return offset + 4;
}


/*	C3.3.4		Move (immediate)	C3-215
	
	The Move (immediate) instructions are aliases for a single MOVZ, MOVN, or
	ORR (immediate with zero register),
	instruction to load an immediate value into the destination register. An
	assembler must permit a signed or
	unsigned immediate, as long as its binary representation can be generated
	using one of these instructions,
	and an assembler error results if the immediate cannot be generated in
	this way. On disassembly, it is
	unspecified whether the immediate is output as a signed or an unsigned
	value. 
	C6.2.191	MOVZ	C6-1102	Move wide with zero moves an optionally-shifted
	16-bit immediate value to a register.
	C6.2.190	MOVN	C6-1100	Move wide with NOT moves the inverse of an
	optionally-shifted 16-bit immediate value to a register.
	C6.2.204	ORR (immediate)	C6-1125
	Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register
	value and an immediate
	register value, and writes the result to the destination register. */

	/* CogARMv8Compiler>>#concretizeMoveCqR */
static NoDbgRegParms sqInt
concretizeMoveCqR(AbstractInstruction *self_in_CogARMv8Compiler)
{
    sqInt constant;
    usqInt destReg;
    sqInt imm;
    sqInt immrSqInt;
    sqInt lowBit;
    sqInt lowBitMod16;
    sqInt mask;
    usqInt maskUsqInt;
    usqInt nImms;
    usqInt nUsqInt;
    sqInt numLeadingOnes;
    sqInt numTrailingOnes;
    sqInt rotateCount;
    sqInt size;

	constant = ((self_in_CogARMv8Compiler->operands))[0];
	destReg = ((self_in_CogARMv8Compiler->operands))[1];
	if (destReg != SP) {
		lowBit = (constant > 0
					? computeLowBit(self_in_CogARMv8Compiler, constant)
					: 0);
		lowBitMod16 = (lowBit / 16) * 16;
		mask = ((sqInt)((usqInt)((0xFFFF)) << lowBitMod16));
		if ((constant & mask) == constant) {

			/* Use MOVZ */
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xD2800000U) + ((((usqInt)((lowBitMod16 / 16)) << 21)))) + ((((usqInt)((((usqInt)(constant)) >> lowBitMod16)) << 5)))) + destReg);
			return 4;
		}
		lowBit = ((((sqLong) constant)) < -1
					? computeLowBit(self_in_CogARMv8Compiler, ~(usqIntptr_t)constant)
					: 0);
		if ((((sqLong) (constant | mask))) == -1) {

			/* Use MOVN */
			assert((((usqInt)((~(usqIntptr_t)constant))) >> lowBitMod16) == ((((usqInt)((~(usqIntptr_t)constant))) >> lowBitMod16) & mask));
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0x92800000U) + ((((usqInt)((lowBitMod16 / 16)) << 21)))) + ((((usqInt)((((usqInt)((~(usqIntptr_t)constant))) >> lowBitMod16)) << 5)))) + destReg);
			return 4;
		}
	}

	/* begin isImmNImmSImmREncodableBitmask:ifTrue:ifFalse: */
	if (((constant >= -1) && (constant <= 0))) {
		return emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, destReg, 0);
	}

	/* First, determine the element size. */
	imm = constant;
	size = 32;
	while (1) {
		maskUsqInt = (1ULL << size) - 1;
		if (!(((imm & maskUsqInt) != ((((usqInt)(imm)) >> size) & maskUsqInt)
				? ((size = size * 2),
				0)
				: size > 2))) break;
		size = size / 2;
	}
	maskUsqInt = ((usqInt)((0xFFFFFFFFFFFFFFFFULL))) >> (64 - size);
	imm = imm & maskUsqInt;
	if (isShiftedMask(self_in_CogARMv8Compiler, imm)) {
		rotateCount = countTrailingZeros(self_in_CogARMv8Compiler, imm);
		numTrailingOnes = countTrailingOnes(self_in_CogARMv8Compiler, ((usqInt)(imm)) >> rotateCount);
	}
	else {
		imm = imm | (~(usqIntptr_t)maskUsqInt);
		if (!(isShiftedMask(self_in_CogARMv8Compiler, imm))) {
			return emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, destReg, 0);
		}
		numLeadingOnes = countLeadingOnes(self_in_CogARMv8Compiler, imm);
		rotateCount = 64 - numLeadingOnes;
		numTrailingOnes = (numLeadingOnes + (countTrailingOnes(self_in_CogARMv8Compiler, imm))) - (64 - size);
	}
	assert(size > rotateCount);

	/* If size has a 1 in the n'th bit, create a value that has zeroes in bits [0, n] and ones above that. */
	immrSqInt = (size - rotateCount) & (size - 1);

	/* Or the CTO value into the low bits, which must be below the Nth bit mentioned above. */
	nImms = ((sqInt)((usqInt)((~(usqIntptr_t)(size - 1))) << 1));

	/* Extract the seventh bit and toggle it to create the N field. */
	nImms = nImms | (numTrailingOnes - 1);
	nUsqInt = (((nImms) >> 6) & 1) ^ 1;
	nImms = nImms & 0x3F;
	assert((decodeNimmsimmr(self_in_CogARMv8Compiler, nUsqInt, nImms, immrSqInt)) == (((usqInt) constant)));
	((self_in_CogARMv8Compiler->machineCode))[0] = ((((((0xB2000000U) + ((nUsqInt << 22))) + ((((usqInt)(immrSqInt) << 16)))) + ((nImms << 10))) + ((((usqInt)(XZR) << 5)))) + destReg);
	return 4;
}


/*	Mwr/M32r/M16r/Mbr - memory unit whose address is a constant M away from an
	address in a register
 */

	/* CogARMv8Compiler>>#concretizeMoveMSrR: */
static NoDbgRegParms sqInt
concretizeMoveMSrR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne)
{
	return emitLdrnrtimmshiftBy12at(self_in_CogARMv8Compiler, unitSizeLog2MinusOne, ((self_in_CogARMv8Compiler->operands))[1], ((sqLong) (((self_in_CogARMv8Compiler->operands))[2])), ((self_in_CogARMv8Compiler->operands))[0], 0, 0);
}


/*	D13.8.26		CNTVCT_EL0, Counter-timer Virtual Count register		p D13-3774 */
/*	MRS <Xt>, CNTVCT_EL0		op0:0b11 op1:0b011 CRn:0b1110 CRm:0b0000 op2:0b010 */

	/* CogARMv8Compiler>>#concretizeMovePerfCnt64RL */
static NoDbgRegParms sqInt
concretizeMovePerfCnt64RL(AbstractInstruction *self_in_CogARMv8Compiler)
{
	((self_in_CogARMv8Compiler->machineCode))[0] = ((3577471040U) + (((self_in_CogARMv8Compiler->operands))[0]));
	return 4;
}


/*	Mwr/M32r/M16r/Mbr - memory unit whose address is a constant M away from an
	address in a register
 */

	/* CogARMv8Compiler>>#concretizeMoveRMSr: */
static NoDbgRegParms sqInt
concretizeMoveRMSr(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne)
{
	return emitStrnrtimmshiftBy12(self_in_CogARMv8Compiler, unitSizeLog2MinusOne, ((self_in_CogARMv8Compiler->operands))[2], ((self_in_CogARMv8Compiler->operands))[0], ((sqLong) (((self_in_CogARMv8Compiler->operands))[1])), 0);
}


/*	Xwr/X32r/X16r/Xbr - memory unit whose address is r * unit size away from
	an address in a register
 */
/*	C6.2.274	STR (register)	C6-1242 */

	/* CogARMv8Compiler>>#concretizeMoveRXSrR: */
static NoDbgRegParms sqInt
concretizeMoveRXSrR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne)
{
    usqInt base;
    usqInt index;
    usqInt src;

	src = ((self_in_CogARMv8Compiler->operands))[0];
	index = ((self_in_CogARMv8Compiler->operands))[1];
	base = ((self_in_CogARMv8Compiler->operands))[2];
	assert(!(((SP == src)
 || (SP == index))));
	((self_in_CogARMv8Compiler->machineCode))[0] = ((((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x38200000)) + ((index << 16))) + ((((usqInt)(UXTX) << 13)))) + (6144)) + ((base << 5))) + src);
	return 4;
}


/*	Xwr/X32r/X16r/Xbr - memory unit whose address is r * unit size away from
	an address in a register
 */
/*	C6.2.132	LDR (register)	C6-981 */

	/* CogARMv8Compiler>>#concretizeMoveXSrRR: */
static NoDbgRegParms sqInt
concretizeMoveXSrRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne)
{
    usqInt base;
    usqInt dest;
    usqInt index;

	index = ((self_in_CogARMv8Compiler->operands))[0];
	base = ((self_in_CogARMv8Compiler->operands))[1];
	dest = ((self_in_CogARMv8Compiler->operands))[2];
	assert(!((SP == dest)));
	((self_in_CogARMv8Compiler->machineCode))[0] = ((((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x38600000)) + ((index << 16))) + ((((usqInt)(UXTX) << 13)))) + (6144)) + ((base << 5))) + dest);
	return 4;
}


/*	Sizing/generating jumps.
	Jump targets can be to absolute addresses or other abstract instructions.
	Generating initial trampolines instructions may have no maxSize and be to
	absolute addresses.
	Otherwise instructions must have a machineCodeSize which must be kept to. */

	/* CogARMv8Compiler>>#concretizeMulOverflowJump */
static NoDbgRegParms sqInt
concretizeMulOverflowJump(AbstractInstruction *self_in_CogARMv8Compiler)
{
    sqInt offset;

	/* -4 because the jump is from the second word... */
	offset = (computeJumpTargetOffset(self_in_CogARMv8Compiler)) - 4;
	assert((offset != 0)
	 && (isInImmediateBranchRange(self_in_CogARMv8Compiler, offset)));
	((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x8B000000U) + ((((usqInt)(ArithmeticAddS) << 29)))) + ((((usqInt)(CArg1Reg) << 16)))) + ((((usqInt)(RISCTempReg) << 5)))) + RISCTempReg);
	((self_in_CogARMv8Compiler->machineCode))[1] = ((/* begin cond:offset: */
	assert((offset & 3) == 0),
((0x54000000) + ((((usqInt)((offset & (0x1FFFFF))) << 3)))) + ((((self_in_CogARMv8Compiler->opcode)) == JumpMulOverflow
		? NE
		: EQ))));
	return 8;
}


/*	rd := regA op regB */

	/* CogARMv8Compiler>>#concretizeRRArithmetic:Rd: */
static NoDbgRegParms sqInt
concretizeRRArithmeticRd(AbstractInstruction *self_in_CogARMv8Compiler, sqInt arithOp, sqInt rd)
{
    usqInt regA;
    usqInt regB;

	regB = ((self_in_CogARMv8Compiler->operands))[0];

	/* cogit processor disassembleInstructionAt: 0 In: machineCode object */
	/* cogit processor disassembleInstructionAt: 4 In: machineCode object */
	regA = ((self_in_CogARMv8Compiler->operands))[1];
	if (SP == regB) {

		/* Arithmetic with the sp; we must use the extended register forms, and negate
		   on subtract because we can't have Rm as SP, Rm = 31 is interoreted as XZR. */
		/* ADD (extended register) on page C6-758
		   ADDS (extended register) on page C6-766
		   SUB (extended register) on page C6-1308
		   SUBS (extended register) on page C6-1318 */
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((((0x8B200000U) + ((((usqInt)(arithOp) << 29)))) + ((regA << 16))) + ((((usqInt)(UXTX) << 13)))) + ((regB << 5))) + rd);
		if (!((arithOp == ArithmeticSub)
			 || (arithOp == ArithmeticSubS))) {
			return 4;
		}
		((self_in_CogARMv8Compiler->machineCode))[1] = (((((0x8B000000U) + ((((usqInt)(arithOp) << 29)))) + ((((usqInt)(rd) << 16)))) + ((((usqInt)(XZR) << 5)))) + rd);
		return 8;
	}
	if (SP == regA) {

		/* Arithmetic with the sp; we must use the extended register forms. */
		/* ADD (extended register) on page C6-758
		   ADDS (extended register) on page C6-766
		   SUB (extended register) on page C6-1308
		   SUBS (extended register) on page C6-1318
		   CMN (extended register) on page C6-850
		   CMP (extended register) on page C6-856 */
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((((0x8B200000U) + ((((usqInt)(arithOp) << 29)))) + ((regB << 16))) + ((((usqInt)(UXTX) << 13)))) + ((regA << 5))) + rd);
		return 4;
	}
	assert((regA != SP)
	 && (regB != SP));
	((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x8B000000U) + ((((usqInt)(arithOp) << 29)))) + ((regB << 16))) + ((regA << 5))) + rd);
	return 4;
}


/*	AND (shifted register) - 64-bit variant on page C6-777
	BIC (shifted register) - 64-bit variant on page C6-808
	ORR (shifted register) - 64-bit variant on page C6-1127
	ORN (shifted register) - 64-bit variant on page C6-1123
	EOR (shifted register) - 64-bit variant on page C6-898
	EON (shifted register) - 64-bit variant on page C6-894
	ANDS (shifted register) - 64-bit variant on page C6-781
	BICS (shifted register) - 64-bit variant on page C6-810 */

	/* CogARMv8Compiler>>#concretizeRRLogical: */
static NoDbgRegParms sqInt
concretizeRRLogical(AbstractInstruction *self_in_CogARMv8Compiler, sqInt logicalOp)
{
    usqInt destReg;
    usqInt srcReg;

	srcReg = ((self_in_CogARMv8Compiler->operands))[0];
	destReg = ((self_in_CogARMv8Compiler->operands))[1];
	((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x8A000000U) + ((((usqInt)(logicalOp) << 29)))) + ((srcReg << 16))) + ((destReg << 5))) + destReg);
	return 4;
}


/*	C6.2.320 SXTB	C6-1332
	C6.2.321 SXTH	C6-1334
	C6.2.322 SXTW	C6-1336 */

	/* CogARMv8Compiler>>#concretizeSignExtendRR: */
static NoDbgRegParms sqInt
concretizeSignExtendRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt width)
{
    usqInt rd;
    usqInt rn;

	rn = ((self_in_CogARMv8Compiler->operands))[0];
	rd = ((self_in_CogARMv8Compiler->operands))[1];
	((self_in_CogARMv8Compiler->machineCode))[0] = ((((0x93400000U) + ((((usqInt)((width - 1)) << 10)))) + ((rn << 5))) + rd);
	return 4;
}


/*	Xt */
/*	Xn */

	/* CogARMv8Compiler>>#concretizeSTLR */
static NoDbgRegParms sqInt
concretizeSTLR(AbstractInstruction *self_in_CogARMv8Compiler)
{
    usqInt baseReg;
    usqInt valueReg;

	valueReg = ((self_in_CogARMv8Compiler->operands))[0];
	baseReg = ((self_in_CogARMv8Compiler->operands))[1];
	((self_in_CogARMv8Compiler->machineCode))[0] = (((0xC89FFC00U) + ((baseReg << 5))) + valueReg);
	return 4;
}


/*	C6.2.333	UBFX	C6-1353
	C6.2.341 UXTB	C6-1364
	C6.2.342 UXTH	C6-1366 */

	/* CogARMv8Compiler>>#concretizeZeroExtendRR: */
static NoDbgRegParms sqInt
concretizeZeroExtendRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt width)
{
    usqInt rd;
    usqInt rn;

	rn = ((self_in_CogARMv8Compiler->operands))[0];
	rd = ((self_in_CogARMv8Compiler->operands))[1];
	((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xD3400000U) + ((((usqInt)((width - 1)) << 10)))) + ((rn << 5))) + rd);
	return 4;
}

	/* CogARMv8Compiler>>#countLeadingOnes: */
static NoDbgRegParms sqInt
countLeadingOnes(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger)
{
    sqInt count;
    sqInt logBase2Shift;
    sqInt shift;
    sqInt theInteger;

	if (anInteger >= 0) {
		return 0;
	}
	theInteger = anInteger;
	count = 0;
	for (logBase2Shift = 5; logBase2Shift >= 0; logBase2Shift += -1) {
		shift = 1ULL << logBase2Shift;
		if (((theInteger) >> shift) == -1) {
			count += shift;
		}
		else {
			theInteger = (theInteger) >> shift;
		}
	}
	return (theInteger == -1
			? count + 1
			: count);
}

	/* CogARMv8Compiler>>#countTrailingOnes: */
static NoDbgRegParms sqInt
countTrailingOnes(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger)
{
    sqInt bits;
    sqInt count;

	bits = anInteger;
	count = 0;
	while (((bits & 0xFFFF) == 0xFFFF)) {
		bits = (((usqInt)(bits)) >> 16);
		count += 16;
	}
	while (((bits & 0xFF) == 0xFF)) {
		bits = (((usqInt)(bits)) >> 8);
		count += 8;
	}
	if (((bits & 15) == 15)) {
		bits = (((usqInt)(bits)) >> 4);
		count += 4;
	}
	if (((bits & 3) == 3)) {
		bits = (((usqInt)(bits)) >> 2);
		count += 2;
	}
	return (((bits & 1) == 1)
			? count + 1
			: count);
}


/*	a.k.a. anInteger lowBit - 1 */

	/* CogARMv8Compiler>>#countTrailingZeros: */
static NoDbgRegParms sqInt
countTrailingZeros(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger)
{
    sqInt n;
    sqInt result;

	assert(anInteger != 0);
	n = anInteger;
	result = 0;
	while ((!(n & 0xFF))) {
		result += 8;
		n = (((usqInt)(n)) >> 8);
	}
	if ((!(n & 15))) {
		result += 4;
		n = (((usqInt)(n)) >> 4);
	}
	if ((!(n & 3))) {
		result += 2;
		n = (((usqInt)(n)) >> 2);
	}
	return (((n & 1) != 0)
			? result
			: result + 1);
}


/*	See aarch64/instrs/integer/bitmasks/DecodeBitMasks J1-7389. */

	/* CogARMv8Compiler>>#decodeN:imms:immr: */
static NoDbgRegParms usqInt
decodeNimmsimmr(AbstractInstruction *self_in_CogARMv8Compiler, sqInt n, sqInt imms, sqInt immr)
{
    usqInt bits;
    sqInt immediate;
    usqInt mask;
    sqInt rotation;
    sqInt width;

	bits = 0;
	width = 0;
	assert((((n >= 0) && (n <= 1)))
	 && ((((imms >= 0) && (imms <= 0x3F)))
	 && (((immr >= 0) && (immr <= 0x3F)))));
	if (imms == 0x3F) {
		return 0;
	}
	if (n == 1) {
		width = 64;
		mask = 0xFFFFFFFFFFFFFFFFULL;
		bits = imms;
		rotation = immr;
	}
	else {
		if (imms < 32) {
			width = 32;
			bits = imms;
		}
		else {
			if (imms < 48) {
				width = 16;
				bits = imms & 15;
			}
			else {
				if (imms < 56) {
					width = 8;
					bits = imms & 7;
				}
				else {
					if (imms < 60) {
						width = 4;
						bits = imms & 3;
					}
					else {
						if (imms < 0x3E) {
							width = 2;
							bits = imms & 1;
						}
						else {
							error("invalid logical immediate");
						}
					}
				}
			}
		}
		mask = (1ULL << width) - 1;
		rotation = immr & (width - 1);
	}
	if ((width - 1) == bits) {
		return 0;
	}
	immediate = (1ULL << (bits + 1)) - 1;
	if (rotation > 0) {
		immediate = ((sqInt)((usqInt)(immediate) << (width - rotation)));
	}
	if (((width >= 2) && (width <= 32))) {
		immediate = (((width < 0) ? (((usqInt)(immediate)) >> (-width)) : ((((usqInt)(immediate) << width))))) | immediate;
	}
	return immediate;
}


/*	Do a throw-away compilation to read CTR_EL0 and initialize ctrEl0.
	Some linux kernels trap and synthesize access to ID_AA64ISAR0_EL1,
	and some do not, so use getauxval(3) to access value(s) derived
	there-from, i.e. whether the processor has atomic instructions. */

	/* CogARMv8Compiler>>#detectFeaturesOnLinux */
#if __linux__
static NoDbgRegParms AbstractInstruction *
detectFeaturesOnLinux(AbstractInstruction *self_in_CogARMv8Compiler)
{
    sqInt ctrEL0;
    sqInt fixupSize;
    usqIntptr_t (*getFeatureReg)(void);
    sqInt opcodeSize;
    usqInt startAddress;

	startAddress = methodZoneBase;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 4;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;

	/* Return the value of CTR_EL0; that's the control register that defines the vital statistics of the processor's caches. */
	getFeatureReg = ((usqIntptr_t (*)(void)) startAddress);
	gen(Nop);
	genoperand(MRS_CTR_EL0, ABIResultReg);

	/* RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);

	/* begin resetMethodZoneBase: */
	methodZoneBase = startAddress;
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE


	/* see e.g. CogARMv8Compiler class>>printCTR_EL0:, concretizeCacheControlOp1:CRm:Op2: &
	   http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100403_0200_00_en/lau1443435580346.html
	   DminLine & IminLine are Log2 words; 16 words miniumum */
	ctrEL0 = getFeatureReg();
	setDataCacheFlushRequired(self_in_CogARMv8Compiler, (!(ctrEL0 & (0x10000000))));
	setDataCacheLineLength(self_in_CogARMv8Compiler, 4ULL << ((((usqInt)(ctrEL0)) >> 16) & 15));
	if (!(dataCacheLineLength(self_in_CogARMv8Compiler))) {
		setDataCacheLineLength(self_in_CogARMv8Compiler, 64);
	}
	setInstructionCacheFlushRequired(self_in_CogARMv8Compiler, (!(ctrEL0 & (0x20000000))));
	setInstructionCacheLineLength(self_in_CogARMv8Compiler, 4ULL << (ctrEL0 & 15));

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	if (!(instructionCacheLineLength(self_in_CogARMv8Compiler))) {
		setInstructionCacheLineLength(self_in_CogARMv8Compiler, 64);
	}
	return self_in_CogARMv8Compiler;
}
#endif /* __linux__ */


/*	Do throw-away compilations to read CTR_EL0 & ID_AA64ISAR0_EL1 and
	initialize ctrEl0 & idISAR0
 */

	/* CogARMv8Compiler>>#detectFeaturesOnRawMachine */
#if !__APPLE__ && !__linux__
static NoDbgRegParms AbstractInstruction *
detectFeaturesOnRawMachine(AbstractInstruction *self_in_CogARMv8Compiler)
{
    sqInt ctrEL0;
    sqInt fixupSize;
    usqIntptr_t (*getFeatureReg)(void);
    sqInt opcodeSize;
    usqInt startAddress;

	startAddress = methodZoneBase;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 4;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;

	/* Return the value of CTR_EL0; that's the control register that defines the vital statistics of the processor's caches. */
	getFeatureReg = ((usqIntptr_t (*)(void)) startAddress);
	gen(Nop);
	genoperand(MRS_CTR_EL0, ABIResultReg);

	/* RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);

	/* begin resetMethodZoneBase: */
	methodZoneBase = startAddress;
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE


	/* see e.g. CogARMv8Compiler class>>printCTR_EL0:, concretizeCacheControlOp1:CRm:Op2: &
	   http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100403_0200_00_en/lau1443435580346.html
	   DminLine & IminLine are Log2 words; 16 words miniumum */
	ctrEL0 = getFeatureReg();
	setDataCacheFlushRequired(self_in_CogARMv8Compiler, (!(ctrEL0 & (0x10000000))));
	setDataCacheLineLength(self_in_CogARMv8Compiler, 4ULL << ((((usqInt)(ctrEL0)) >> 16) & 15));
	if (!(dataCacheLineLength(self_in_CogARMv8Compiler))) {
		setDataCacheLineLength(self_in_CogARMv8Compiler, 64);
	}
	setInstructionCacheFlushRequired(self_in_CogARMv8Compiler, (!(ctrEL0 & (0x20000000))));
	setInstructionCacheLineLength(self_in_CogARMv8Compiler, 4ULL << (ctrEL0 & 15));

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	if (!(instructionCacheLineLength(self_in_CogARMv8Compiler))) {
		setInstructionCacheLineLength(self_in_CogARMv8Compiler, 64);
	}

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	gen(Nop);
	genoperand(MRS_ID_AA64ISAR0_EL1, ABIResultReg);

	/* RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	return self_in_CogARMv8Compiler;
}
#endif /* !__APPLE__ && !__linux__ */


/*	Attempt to generate concrete machine code for the instruction at address.
	This is the inner dispatch of concretizeAt: actualAddress which exists
	only to get around the branch size limits in the SqueakV3 (blue book
	derived) bytecode set. */

	/* CogARMv8Compiler>>#dispatchConcretize */
static NoDbgRegParms sqInt
dispatchConcretize(AbstractInstruction *self_in_CogARMv8Compiler)
{
    usqInt addressReg;
    usqInt baseReg;
    usqInt CRm;
    sqInt CRmSqInt;
    usqInt condition;
    sqInt constant;
    usqInt constantReg;
    usqInt constantUsqInt;
    AbstractInstruction *dependentChain;
    usqInt dest;
    usqInt destAddr;
    usqInt destReg;
    usqInt flags;
    sqInt instrBytes;
    sqInt instrOffset;
    AbstractInstruction *jumpTarget;
    usqInt maskReg;
    sqInt offset;
    usqInt offsetUsqInt;
    usqInt pairAddress;
    usqInt rA;
    usqInt rD;
    usqInt rd;
    usqInt reg;
    usqInt reg1;
    usqInt reg2;
    usqInt reg3;
    usqInt rM;
    usqInt rN;
    usqInt rn;
    AbstractInstruction *self_in_CogAbstractInstruction1;
    usqInt shiftCountReg;
    usqInt shiftedReg;
    usqInt srcAddr;
    usqInt srcReg;
    usqInt statusReg;
    usqInt targetReg;
    usqInt valueReg;

	switch ((self_in_CogARMv8Compiler->opcode)) {
	case Label:
		/* begin concretizeLabel */
		dependentChain = (self_in_CogARMv8Compiler->dependent);
		while (!(!dependentChain)) {
			self_in_CogAbstractInstruction1 = dependentChain;

			/* begin updateLabel: */
			assert((((self_in_CogAbstractInstruction1->opcode)) == MoveCwR)
			 || (((self_in_CogAbstractInstruction1->opcode)) == PushCw));
			((self_in_CogAbstractInstruction1->operands))[0] = (((self_in_CogARMv8Compiler->address)) + (((self_in_CogARMv8Compiler->operands))[1]));
			dependentChain = (dependentChain->dependent);
		}
		return 0;

	case Literal:
		return concretizeLiteral(self_in_CogARMv8Compiler);

	case AlignmentNops:
		/* begin concretizeAlignmentNops */
		assert((((self_in_CogARMv8Compiler->machineCodeSize)) % 4) == 0);
		((self_in_CogARMv8Compiler->machineCode))[0] = NOP;
		return (self_in_CogARMv8Compiler->machineCodeSize);

	case Fill32:
		/* begin concretizeFill32 */
		((self_in_CogARMv8Compiler->machineCode))[0] = (((self_in_CogARMv8Compiler->operands))[0]);
		return 4;

	case Nop:
		/* begin concretizeNop */
		((self_in_CogARMv8Compiler->machineCode))[0] = NOP;
		return 4;

	case Call:
		/* begin concretizeCall */
		offset = ((sqLong) ((((self_in_CogARMv8Compiler->operands))[0]) - ((self_in_CogARMv8Compiler->address))));
		assert((!(offset & 3)));
		assert(isInImmediateBranchAndLinkRange(self_in_CogARMv8Compiler, offset));
		((self_in_CogARMv8Compiler->machineCode))[0] = ((/* begin bl: */
	assert((!(offset & 3))),
(0x94000000U) + (((offset) >> 2) & (0x3FFFFFF))));
		return 4;

	case CallFull:
		/* begin concretizeCallJumpFull: */
		/* begin longJumpTargetAddress */
		jumpTarget = ((AbstractInstruction *) (((self_in_CogARMv8Compiler->operands))[0]));
		if (/* isAnInstruction: */
			(addressIsInInstructions(jumpTarget))
		 || (jumpTarget == (methodLabel))) {
			jumpTarget = ((AbstractInstruction *) ((jumpTarget->address)));
		}
		assert(jumpTarget != 0);
		instrOffset = emitMoveCwintoRat(self_in_CogARMv8Compiler, ((usqInt)jumpTarget), RISCTempReg, 0);
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = (brlinkreg(self_in_CogARMv8Compiler, 1, RISCTempReg));
		assert(instrOffset == (literalLoadInstructionBytes(self_in_CogARMv8Compiler)));
		return instrOffset + 4;

	case JumpR:
		/* begin concretizeJumpR */
		((self_in_CogARMv8Compiler->machineCode))[0] = (((0xD6000000U) + ((((usqInt)(XZR) << 16)))) + (((((self_in_CogARMv8Compiler->operands))[0]) << 5)));
		return 4;

	case JumpFull:
		/* begin concretizeCallJumpFull: */
		/* begin longJumpTargetAddress */
		jumpTarget = ((AbstractInstruction *) (((self_in_CogARMv8Compiler->operands))[0]));
		if (/* isAnInstruction: */
			(addressIsInInstructions(jumpTarget))
		 || (jumpTarget == (methodLabel))) {
			jumpTarget = ((AbstractInstruction *) ((jumpTarget->address)));
		}
		assert(jumpTarget != 0);
		instrOffset = emitMoveCwintoRat(self_in_CogARMv8Compiler, ((usqInt)jumpTarget), RISCTempReg, 0);
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = (brlinkreg(self_in_CogARMv8Compiler, 0, RISCTempReg));
		assert(instrOffset == (literalLoadInstructionBytes(self_in_CogARMv8Compiler)));
		return instrOffset + 4;

	case JumpLong:
		/* begin concretizeJumpLong */
		offset = (((self_in_CogARMv8Compiler->operands))[0]) - ((self_in_CogARMv8Compiler->address));
		assert((!(offset & 3)));
		assert(((((offset) >> 2) >= (-67108864)) && (((offset) >> 2) <= (0x3FFFFFF))));
		((self_in_CogARMv8Compiler->machineCode))[0] = ((0x14000000) + (((offset) >> 2) & (0x3FFFFFF)));
		return 4;

	case JumpLongZero:
		/* begin concretizeConditionalLongJump: */
		offset = (((self_in_CogARMv8Compiler->operands))[0]) - (((self_in_CogARMv8Compiler->address)) + 4);
		assert((!(offset & 3)));
		assert(((((offset) >> 2) >= (-67108864)) && (((offset) >> 2) <= (0x3FFFFFF))));
		((self_in_CogARMv8Compiler->machineCode))[0] = ((0x54000040) + NE);
		((self_in_CogARMv8Compiler->machineCode))[1] = ((0x14000000) + (((offset) >> 2) & (0x3FFFFFF)));
		return 8;

	case JumpLongNonZero:
		/* begin concretizeConditionalLongJump: */
		offset = (((self_in_CogARMv8Compiler->operands))[0]) - (((self_in_CogARMv8Compiler->address)) + 4);
		assert((!(offset & 3)));
		assert(((((offset) >> 2) >= (-67108864)) && (((offset) >> 2) <= (0x3FFFFFF))));
		((self_in_CogARMv8Compiler->machineCode))[0] = ((0x54000040) + EQ);
		((self_in_CogARMv8Compiler->machineCode))[1] = ((0x14000000) + (((offset) >> 2) & (0x3FFFFFF)));
		return 8;

	case Jump:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, AL);

	case JumpZero:
	case JumpFPEqual:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, EQ);

	case JumpNonZero:
	case JumpFPNotEqual:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, NE);

	case JumpNegative:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, MI);

	case JumpNonNegative:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, PL);

	case JumpOverflow:
	case JumpFPUnordered:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, VS);

	case JumpNoOverflow:
	case JumpFPOrdered:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, VC);

	case JumpMulOverflow:
	case JumpNoMulOverflow:
		return concretizeMulOverflowJump(self_in_CogARMv8Compiler);

	case JumpCarry:
	case JumpAboveOrEqual:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, CS);

	case JumpNoCarry:
	case JumpBelow:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, CC);

	case JumpLess:
	case JumpFPLess:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, LT);

	case JumpGreaterOrEqual:
	case JumpFPGreaterOrEqual:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, GE);

	case JumpGreater:
	case JumpFPGreater:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, GT);

	case JumpLessOrEqual:
	case JumpFPLessOrEqual:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, LE);

	case JumpAbove:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, HI);

	case JumpBelowOrEqual:
		return concretizeConditionalJump(self_in_CogARMv8Compiler, LS);

	case RetN:
		/* begin concretizeRetN */
		/* C6.2.218 RET p1147 */
		offset = ((self_in_CogARMv8Compiler->operands))[0];
		if (!offset) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((0xD6400000U) + ((((usqInt)(XZR) << 16)))) + ((((usqInt)(LR) << 5))));
			return 4;
		}
		((self_in_CogARMv8Compiler->machineCode))[0] = (addrnrdimmshiftBy12(self_in_CogARMv8Compiler, SPReg, SPReg, offset, 0));
		((self_in_CogARMv8Compiler->machineCode))[1] = (((0xD6400000U) + ((((usqInt)(XZR) << 16)))) + ((((usqInt)(LR) << 5))));
		return 8;

	case NativeRetN:
		/* begin concretizeNativeRetN */
		/* C6.2.218 RET p1147 */
		offset = ((self_in_CogARMv8Compiler->operands))[0];
		if (!offset) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((0xD6400000U) + ((((usqInt)(XZR) << 16)))) + ((((usqInt)(LR) << 5))));
			return 4;
		}
		((self_in_CogARMv8Compiler->machineCode))[0] = (addrnrdimmshiftBy12(self_in_CogARMv8Compiler, SP, SP, offset, 0));
		((self_in_CogARMv8Compiler->machineCode))[1] = (((0xD6400000U) + ((((usqInt)(XZR) << 16)))) + ((((usqInt)(LR) << 5))));
		return 8;

	case Stop:
		/* begin concretizeStop */
		((self_in_CogARMv8Compiler->machineCode))[0] = 0xD4400000U /* stop */;
		return 4;

	case AddCqR:
		destReg = ((self_in_CogARMv8Compiler->operands))[1];

		/* begin concretizeAddCqRDest: */
		constant = ((sqLong) (((self_in_CogARMv8Compiler->operands))[0]));
		srcReg = ((self_in_CogARMv8Compiler->operands))[1];

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if (((constant >= 0) && (constant <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((srcReg == SP
		? 0x122
		: 354))) << 23))) + ((((usqInt)(constant) << 10)))) + ((srcReg << 5))) + destReg);
			return 4;
			goto l1;
		}
		if (((!(constant & (0xFFF))))
		 && (((((constant) >> 12) >= 0) && (((constant) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((srcReg == SP
		? 0x122
		: 354))) << 23))) + ((((usqInt)(constant)) >> 2) + (0x400000))) + ((srcReg << 5))) + destReg);
			return 4;
			goto l1;
		}
l1:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if ((((-constant) >= 0) && ((-constant) <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((srcReg == SP
		? 418
		: 482))) << 23))) + ((((usqInt)((-constant)) << 10)))) + ((srcReg << 5))) + destReg);
			return 4;
			goto l2;
		}
		if (((!((-constant) & (0xFFF))))
		 && ((((((-constant)) >> 12) >= 0) && ((((-constant)) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((srcReg == SP
		? 418
		: 482))) << 23))) + ((((usqInt)((-constant))) >> 2) + (0x400000))) + ((srcReg << 5))) + destReg);
			return 4;
			goto l2;
		}
l2:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

		/* C6.2.7		ADDS (extended register)		C6-766 */
		offset = emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, RISCTempReg, 0);
		((self_in_CogARMv8Compiler->machineCode))[offset / 4] = (((((0xAB200000U) + ((((usqInt)(RISCTempReg) << 16)))) + ((((usqInt)(SXTX) << 13)))) + ((srcReg << 5))) + destReg);
		return offset + 4;

	case AddCqRR:
		destReg = ((self_in_CogARMv8Compiler->operands))[2];

		/* begin concretizeAddCqRDest: */
		constant = ((sqLong) (((self_in_CogARMv8Compiler->operands))[0]));
		srcReg = ((self_in_CogARMv8Compiler->operands))[1];

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if (((constant >= 0) && (constant <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((srcReg == SP
		? 0x122
		: 354))) << 23))) + ((((usqInt)(constant) << 10)))) + ((srcReg << 5))) + destReg);
			return 4;
			goto l3;
		}
		if (((!(constant & (0xFFF))))
		 && (((((constant) >> 12) >= 0) && (((constant) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((srcReg == SP
		? 0x122
		: 354))) << 23))) + ((((usqInt)(constant)) >> 2) + (0x400000))) + ((srcReg << 5))) + destReg);
			return 4;
			goto l3;
		}
l3:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if ((((-constant) >= 0) && ((-constant) <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((srcReg == SP
		? 418
		: 482))) << 23))) + ((((usqInt)((-constant)) << 10)))) + ((srcReg << 5))) + destReg);
			return 4;
			goto l4;
		}
		if (((!((-constant) & (0xFFF))))
		 && ((((((-constant)) >> 12) >= 0) && ((((-constant)) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((srcReg == SP
		? 418
		: 482))) << 23))) + ((((usqInt)((-constant))) >> 2) + (0x400000))) + ((srcReg << 5))) + destReg);
			return 4;
			goto l4;
		}
l4:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

		/* C6.2.7		ADDS (extended register)		C6-766 */
		offset = emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, RISCTempReg, 0);
		((self_in_CogARMv8Compiler->machineCode))[offset / 4] = (((((0xAB200000U) + ((((usqInt)(RISCTempReg) << 16)))) + ((((usqInt)(SXTX) << 13)))) + ((srcReg << 5))) + destReg);
		return offset + 4;

	case AndCqR:
		return concretizeLogicalOpCqRDest(self_in_CogARMv8Compiler, LogicalAndS, ((self_in_CogARMv8Compiler->operands))[1]);

	case AndCqRR:
		return concretizeLogicalOpCqRDest(self_in_CogARMv8Compiler, LogicalAndS, ((self_in_CogARMv8Compiler->operands))[2]);

	case OrCqR:
		return concretizeLogicalOpCqRDest(self_in_CogARMv8Compiler, LogicalOr, ((self_in_CogARMv8Compiler->operands))[1]);

	case OrCqRR:
		return concretizeLogicalOpCqRDest(self_in_CogARMv8Compiler, LogicalOr, ((self_in_CogARMv8Compiler->operands))[2]);

	case CmpCqR:
		/* begin concretizeCmpCqR */
		constant = ((sqLong) (((self_in_CogARMv8Compiler->operands))[0]));

		/* cogit processor disassembleInstructionAt: 0 In: machineCode object */
		rn = ((self_in_CogARMv8Compiler->operands))[1];
		if (((constant >= 0) && (constant <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xF1000000U) + ((((usqInt)(constant) << 10)))) + ((rn << 5))) + XZR);
			return 4;
			goto l5;
		}
		if (((!(constant & (0xFFF))))
		 && (((((constant) >> 12) >= 0) && (((constant) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xF1000000U) + ((((usqInt)(constant)) >> 2) + (0x400000))) + ((rn << 5))) + XZR);
			return 4;
			goto l5;
		}
l5:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if ((((-constant) >= 0) && ((-constant) <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xB1000000U) + ((((usqInt)((-constant)) << 10)))) + ((rn << 5))) + XZR);
			return 4;
			goto l6;
		}
		if (((!((-constant) & (0xFFF))))
		 && ((((((-constant)) >> 12) >= 0) && ((((-constant)) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xB1000000U) + ((((usqInt)((-constant))) >> 2) + (0x400000))) + ((rn << 5))) + XZR);
			return 4;
			goto l6;
		}
l6:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

		/* C6.2.60	CMP (extended register)	C6-856 */
		offset = emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, RISCTempReg, 0);
		((self_in_CogARMv8Compiler->machineCode))[offset / 4] = (((((0xEB200000U) + ((((usqInt)(RISCTempReg) << 16)))) + ((((usqInt)(UXTX) << 13)))) + ((rn << 5))) + XZR);
		return offset + 4;

	case SubCqR:
		/* begin concretizeSubCqR */
		constant = ((sqLong) (((self_in_CogARMv8Compiler->operands))[0]));
		reg = ((self_in_CogARMv8Compiler->operands))[1];

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if (((constant >= 0) && (constant <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((reg == SP
		? 418
		: 482))) << 23))) + ((((usqInt)(constant) << 10)))) + ((reg << 5))) + reg);
			return 4;
			goto l7;
		}
		if (((!(constant & (0xFFF))))
		 && (((((constant) >> 12) >= 0) && (((constant) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((reg == SP
		? 418
		: 482))) << 23))) + ((((usqInt)(constant)) >> 2) + (0x400000))) + ((reg << 5))) + reg);
			return 4;
			goto l7;
		}
l7:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if ((((-constant) >= 0) && ((-constant) <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((reg == SP
		? 0x122
		: 354))) << 23))) + ((((usqInt)((-constant)) << 10)))) + ((reg << 5))) + reg);
			return 4;
			goto l8;
		}
		if (((!((-constant) & (0xFFF))))
		 && ((((((-constant)) >> 12) >= 0) && ((((-constant)) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (((((((usqInt)(((reg == SP
		? 0x122
		: 354))) << 23))) + ((((usqInt)((-constant))) >> 2) + (0x400000))) + ((reg << 5))) + reg);
			return 4;
			goto l8;
		}
l8:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;
		offset = emitMoveCwintoRat(self_in_CogARMv8Compiler, constant, RISCTempReg, 0);
		assert(!((SP == reg)));
		((self_in_CogARMv8Compiler->machineCode))[offset / 4] = (((((0x8B000000U) + ((((usqInt)(ArithmeticSubS) << 29)))) + ((((usqInt)(RISCTempReg) << 16)))) + ((reg << 5))) + reg);
		return offset + 4;

	case TstCqR:
		return concretizeLogicalOpCqRDest(self_in_CogARMv8Compiler, LogicalAndS, XZR);

	case XorCqR:
		return concretizeLogicalOpCqRDest(self_in_CogARMv8Compiler, LogicalXor, ((self_in_CogARMv8Compiler->operands))[1]);

	case AddCwR:
		return concretizeCwRArithmeticRd(self_in_CogARMv8Compiler, ArithmeticAddS, ((self_in_CogARMv8Compiler->operands))[1]);

	case AndCwR:
		return concretizeCwRLogical(self_in_CogARMv8Compiler, LogicalAndS);

	case CmpCwR:
		return concretizeCwRArithmeticRd(self_in_CogARMv8Compiler, ArithmeticSubS, XZR);

	case CmpC32R:
		/* begin concretizeCmpC32R */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		rn = ((self_in_CogARMv8Compiler->operands))[1];
		assert(addressIsInCurrentCompilation((((self_in_CogARMv8Compiler->dependent))->address)));
		assert((((((self_in_CogARMv8Compiler->dependent))->address)) % 4) == 0);
		assert((SQABS(((((usqInt)((((self_in_CogARMv8Compiler->dependent))->address)))) - (((usqInt)((self_in_CogARMv8Compiler->address))))))) < (0x40000));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((0x18000000) + ((((usqInt)((((((self_in_CogARMv8Compiler->dependent))->address)) - ((self_in_CogARMv8Compiler->address)))) << 3)))) + RISCTempReg);
		((self_in_CogARMv8Compiler->machineCode))[1] = (((((0x6B200000) + ((((usqInt)(RISCTempReg) << 16)))) + ((((usqInt)(UXTX) << 13)))) + ((rn << 5))) + XZR);
		return 8;

	case OrCwR:
		return concretizeCwRLogical(self_in_CogARMv8Compiler, LogicalOr);

	case SubCwR:
		return concretizeCwRArithmeticRd(self_in_CogARMv8Compiler, ArithmeticSubS, ((self_in_CogARMv8Compiler->operands))[1]);

	case XorCwR:
		return concretizeCwRLogical(self_in_CogARMv8Compiler, LogicalXor);

	case AddRR:
		return concretizeRRArithmeticRd(self_in_CogARMv8Compiler, ArithmeticAddS, ((self_in_CogARMv8Compiler->operands))[1]);

	case AndRR:
		return concretizeRRLogical(self_in_CogARMv8Compiler, LogicalAndS);

	case CmpRR:
		return concretizeRRArithmeticRd(self_in_CogARMv8Compiler, ArithmeticSubS, XZR);

	case OrRR:
		return concretizeRRLogical(self_in_CogARMv8Compiler, LogicalOr);

	case SubRR:
		return concretizeRRArithmeticRd(self_in_CogARMv8Compiler, ArithmeticSubS, ((self_in_CogARMv8Compiler->operands))[1]);

	case XorRR:
		return concretizeRRLogical(self_in_CogARMv8Compiler, LogicalXor);

	case AddRRR:
		return concretizeRRArithmeticRd(self_in_CogARMv8Compiler, ArithmeticAddS, ((self_in_CogARMv8Compiler->operands))[2]);

	case SubRRR:
		return concretizeRRArithmeticRd(self_in_CogARMv8Compiler, ArithmeticSubS, ((self_in_CogARMv8Compiler->operands))[2]);

	case AddRdRd:
		/* begin concretizeMathRdRd: */
		srcReg = ((self_in_CogARMv8Compiler->operands))[0];
		destReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x1E600000) + ((srcReg << 16))) + (0x2800)) + ((destReg << 5))) + destReg);
		return 4;

	case CmpRdRd:
		/* begin concretizeCmpRdRd */
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0x1E600000) + (((((self_in_CogARMv8Compiler->operands))[0]) << 16))) + (0x2000)) + (((((self_in_CogARMv8Compiler->operands))[1]) << 5)));
		return 4;

	case DivRdRd:
		/* begin concretizeMathRdRd: */
		srcReg = ((self_in_CogARMv8Compiler->operands))[0];
		destReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x1E600000) + ((srcReg << 16))) + (6144)) + ((destReg << 5))) + destReg);
		return 4;

	case MulRdRd:
		/* begin concretizeMathRdRd: */
		srcReg = ((self_in_CogARMv8Compiler->operands))[0];
		destReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x1E600000) + ((srcReg << 16))) + (0x800)) + ((destReg << 5))) + destReg);
		return 4;

	case SubRdRd:
		/* begin concretizeMathRdRd: */
		srcReg = ((self_in_CogARMv8Compiler->operands))[0];
		destReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x1E600000) + ((srcReg << 16))) + (14336)) + ((destReg << 5))) + destReg);
		return 4;

	case XorRdRd:
		/* begin concretizeXorRdRd */
		srcReg = ((self_in_CogARMv8Compiler->operands))[0];
		destReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x2E200000) + ((srcReg << 16))) + (7168)) + ((destReg << 5))) + destReg);
		return 4;

	case SqrtRd:
		/* begin concretizeSqrtRd */
		reg = ((self_in_CogARMv8Compiler->operands))[0];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((509722624) + ((reg << 5))) + reg);
		return 4;

	case NegateR:
		/* begin concretizeNegateR */
		reg = ((self_in_CogARMv8Compiler->operands))[0];
		assert(!((SP == reg)));
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xCB000000U) + ((reg << 16))) + ((((usqInt)(XZR) << 5)))) + reg);
		return 4;

	case LoadEffectiveAddressMwrR:
		return concretizeLoadEffectiveAddressMwrR(self_in_CogARMv8Compiler);

	case ArithmeticShiftRightCqR:
		/* begin concretizeArithmeticShiftRightCqR */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		reg = ((self_in_CogARMv8Compiler->operands))[1];
		assert(((constantUsqInt >= 1) && (constantUsqInt <= 0x3F)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x93400000U) + ((constantUsqInt << 16))) + (0xFC00)) + ((reg << 5))) + reg);
		return 4;

	case ArithmeticShiftRightCqRR:
		/* begin concretizeArithmeticShiftRightCqRR */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		srcReg = ((self_in_CogARMv8Compiler->operands))[1];
		destReg = ((self_in_CogARMv8Compiler->operands))[2];
		assert(((constantUsqInt >= 1) && (constantUsqInt <= 0x3F)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x93400000U) + ((constantUsqInt << 16))) + (0xFC00)) + ((srcReg << 5))) + destReg);
		return 4;

	case LogicalShiftRightCqR:
		/* begin concretizeLogicalShiftRightCqR */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		reg = ((self_in_CogARMv8Compiler->operands))[1];
		assert(((constantUsqInt >= 1) && (constantUsqInt <= 0x3F)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xD3400000U) + ((constantUsqInt << 16))) + (0xFC00)) + ((reg << 5))) + reg);
		return 4;

	case LogicalShiftRightCqRR:
		/* begin concretizeLogicalShiftRightCqRR */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		srcReg = ((self_in_CogARMv8Compiler->operands))[1];
		destReg = ((self_in_CogARMv8Compiler->operands))[2];
		assert(((constantUsqInt >= 1) && (constantUsqInt <= 0x3F)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xD3400000U) + ((constantUsqInt << 16))) + (0xFC00)) + ((srcReg << 5))) + destReg);
		return 4;

	case LogicalShiftLeftCqR:
		/* begin concretizeLogicalShiftLeftCqR */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		reg = ((self_in_CogARMv8Compiler->operands))[1];
		assert(((constantUsqInt >= 1) && (constantUsqInt <= 0x3F)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xD3400000U) + ((((usqInt)((64 - constantUsqInt)) << 16)))) + ((((usqInt)((0x3F - constantUsqInt)) << 10)))) + ((reg << 5))) + reg);
		return 4;

	case LogicalShiftLeftCqRR:
		/* begin concretizeLogicalShiftLeftCqRR */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		srcReg = ((self_in_CogARMv8Compiler->operands))[1];
		destReg = ((self_in_CogARMv8Compiler->operands))[2];
		assert(((constantUsqInt >= 1) && (constantUsqInt <= 0x3F)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xD3400000U) + ((((usqInt)((64 - constantUsqInt)) << 16)))) + ((((usqInt)((0x3F - constantUsqInt)) << 10)))) + ((srcReg << 5))) + destReg);
		return 4;

	case ArithmeticShiftRightRR:
		/* begin concretizeShiftRR: */
		shiftCountReg = ((self_in_CogARMv8Compiler->operands))[0];
		shiftedReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x9AC00000U) + ((shiftCountReg << 16))) + (0x2800)) + ((shiftedReg << 5))) + shiftedReg);
		return 4;

	case LogicalShiftLeftRR:
		/* begin concretizeShiftRR: */
		shiftCountReg = ((self_in_CogARMv8Compiler->operands))[0];
		shiftedReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x9AC00000U) + ((shiftCountReg << 16))) + (0x2000)) + ((shiftedReg << 5))) + shiftedReg);
		return 4;

	case LogicalShiftRightRR:
		/* begin concretizeShiftRR: */
		shiftCountReg = ((self_in_CogARMv8Compiler->operands))[0];
		shiftedReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x9AC00000U) + ((shiftCountReg << 16))) + (9216)) + ((shiftedReg << 5))) + shiftedReg);
		return 4;

	case RotateRightCqR:
	case RotateLeftCqR:
		/* begin concretizeRotateCqR */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		reg = ((self_in_CogARMv8Compiler->operands))[1];
		assert(((constantUsqInt >= 1) && (constantUsqInt <= 0x3F)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x93C00000U) + ((reg << 16))) + ((((RotateRightCqR == ((self_in_CogARMv8Compiler->opcode))
		? constantUsqInt
		: 64 - constantUsqInt)) << 10))) + ((reg << 5))) + reg);
		return 4;

	case ClzRR:
		/* begin concretizeClzRR */
		maskReg = ((self_in_CogARMv8Compiler->operands))[0];
		dest = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((3670020096U) + ((maskReg << 5))) + dest);
		return 4;

	case MulRRR:
		/* begin concretizeMulRRR */
		reg1 = ((self_in_CogARMv8Compiler->operands))[0];
		reg2 = ((self_in_CogARMv8Compiler->operands))[1];
		reg3 = ((self_in_CogARMv8Compiler->operands))[2];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x9B000000U) + ((reg1 << 16))) + ((((usqInt)(XZR) << 10)))) + ((reg2 << 5))) + reg3);
		return 4;

	case MulOverflowRRR:
		/* begin concretizeMulOverflowRRR */
		reg1 = ((self_in_CogARMv8Compiler->operands))[0];
		reg2 = ((self_in_CogARMv8Compiler->operands))[1];

		/* RISCTempReg := high(reg1 * reg2); must precede destructive MUL */
		reg3 = ((self_in_CogARMv8Compiler->operands))[2];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x9B400000U) + ((reg1 << 16))) + ((((usqInt)(XZR) << 10)))) + ((reg2 << 5))) + RISCTempReg);
		((self_in_CogARMv8Compiler->machineCode))[1] = (((((0x9B000000U) + ((reg1 << 16))) + ((((usqInt)(XZR) << 10)))) + ((reg2 << 5))) + reg3);
		((self_in_CogARMv8Compiler->machineCode))[2] = (((0xD37FFC00U) + ((reg3 << 5))) + CArg1Reg);
		return 12;

	case DivRRR:
		/* begin concretizeDivRRR */
		reg1 = ((self_in_CogARMv8Compiler->operands))[0];
		reg2 = ((self_in_CogARMv8Compiler->operands))[1];
		reg3 = ((self_in_CogARMv8Compiler->operands))[2];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0x9AC00000U) + ((reg2 << 16))) + (0xC00)) + ((reg1 << 5))) + reg3);
		return 4;

	case MSubRRR:
		/* begin concretizeMSubRRR */
		rM = ((((self_in_CogARMv8Compiler->operands))[0])) >> 5;
		rN = (((self_in_CogARMv8Compiler->operands))[0]) & 0x1F;
		rA = ((self_in_CogARMv8Compiler->operands))[1];
		rD = ((self_in_CogARMv8Compiler->operands))[2];
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((((0x9B000000U) + ((rM << 16))) + (0x8000)) + ((rA << 10))) + ((rN << 5))) + rD);
		return 4;

	case DC:
		return concretizeDataCacheControl(self_in_CogARMv8Compiler);

	case DSB:
		/* begin concretizeDataSynchronizationBarrier */
		CRm = (((((self_in_CogARMv8Compiler->operands))[0]) << 2)) + (((self_in_CogARMv8Compiler->operands))[1]);
		((self_in_CogARMv8Compiler->machineCode))[0] = (0xD503309FU + ((CRm << 8)));
		return 4;

	case IC:
		/* begin concretizeInstructionCacheControl */
		/* begin concretizeCacheControlOp1:CRm:Op2: */
		((self_in_CogARMv8Compiler->machineCode))[0] = ((3574297888U) + (((self_in_CogARMv8Compiler->operands))[0]));
		return 4;

	case ISB:
		/* begin concretizeInstructionSynchronizationBarrier */
		CRmSqInt = 15;
		((self_in_CogARMv8Compiler->machineCode))[0] = (0xD50330DFU + ((((usqInt)(CRmSqInt) << 8))));
		return 4;

	case MRS_CTR_EL0:
		/* begin concretizeMRS_CTR_EL0 */
		/* begin concretizeMRSOp1:CRn:CRm:Op2: */
		((self_in_CogARMv8Compiler->machineCode))[0] = ((3577413664U) + (((self_in_CogARMv8Compiler->operands))[0]));
		return 4;

	case MRS_ID_AA64ISAR0_EL1:
		/* begin concretizeMRS_ID_AA64ISAR0_EL1 */
		/* begin concretizeMRSOp1:CRn:CRm:Op2: */
		((self_in_CogARMv8Compiler->machineCode))[0] = ((3577218560U) + (((self_in_CogARMv8Compiler->operands))[0]));
		return 4;

	case MoveCqR:
		return concretizeMoveCqR(self_in_CogARMv8Compiler);

	case MoveCwR:
		return emitMoveCwintoRat(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[0], ((self_in_CogARMv8Compiler->operands))[1], 0);

	case MoveC32R:
		/* begin concretizeMoveC32R */
		constantUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		rn = ((self_in_CogARMv8Compiler->operands))[1];
		assert(addressIsInCurrentCompilation((((self_in_CogARMv8Compiler->dependent))->address)));
		assert((((((self_in_CogARMv8Compiler->dependent))->address)) % 4) == 0);
		assert((((((self_in_CogARMv8Compiler->dependent))->address)) - ((self_in_CogARMv8Compiler->address))) < (0x100000));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((0x98000000U) + ((((usqInt)(((((((self_in_CogARMv8Compiler->dependent))->address)) - ((self_in_CogARMv8Compiler->address))) & (0x1FFFFF))) << 3)))) + rn);
		return 4;

	case MoveRR:
		/* begin concretizeMoveRR */
		srcReg = ((self_in_CogARMv8Compiler->operands))[0];

		/* C6.2.184 MOV (to/from SP) p1089
		   C6.2.188 MOV (register) p1096 */
		destReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((srcReg == SP)
 || (destReg == SP)
		? ((0x91000000U) + ((srcReg << 5))) + destReg
		: (((0xAA000000U) + ((srcReg << 16))) + ((((usqInt)(XZR) << 5)))) + destReg));
		return 4;

	case MoveRRd:
		/* begin concretizeMoveRRd */
		((self_in_CogARMv8Compiler->machineCode))[0] = (((0x9E670000U) + (((((self_in_CogARMv8Compiler->operands))[0]) << 5))) + (((self_in_CogARMv8Compiler->operands))[1]));
		return 4;

	case MoveRdR:
		/* begin concretizeMoveRdR */
		((self_in_CogARMv8Compiler->machineCode))[0] = (((0x9E660000U) + (((((self_in_CogARMv8Compiler->operands))[0]) << 5))) + (((self_in_CogARMv8Compiler->operands))[1]));
		return 4;

	case MoveAwR:
		/* begin concretizeMoveAwR */
		srcAddr = ((self_in_CogARMv8Compiler->operands))[0];

		/* ldr srcReg, [VarBaseReg, #offset] except that this is illegal for SP/X31 */
		destReg = ((self_in_CogARMv8Compiler->operands))[1];
		if (((srcAddr >= ((varBaseAddress) - (0x100))) && (srcAddr <= (((varBaseAddress) + (0x1000)) - 1)))) {
			if (srcAddr < (varBaseAddress)) {
				error("shouldBeImplemented");
				return 4;
			}
			if (destReg != SP) {
				return emitLdrnrtimmshiftBy12at(self_in_CogARMv8Compiler, 3, VarBaseReg, destReg, srcAddr - (varBaseAddress), 0, 0);
			}
			instrOffset = emitLdrnrtimmshiftBy12at(self_in_CogARMv8Compiler, 3, VarBaseReg, RISCTempReg, srcAddr - (varBaseAddress), 0, 0);
			((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = (movernrd(self_in_CogARMv8Compiler, RISCTempReg, destReg));
			return instrOffset + 4;
		}
		instrOffset = emitMoveCwintoRat(self_in_CogARMv8Compiler, srcAddr, RISCTempReg, 0);
		if (SP != destReg) {
			return emitLdrnrtimmshiftBy12at(self_in_CogARMv8Compiler, 3, RISCTempReg, destReg, 0, 0, instrOffset);
		}
		instrOffset = emitLdrnrtimmshiftBy12at(self_in_CogARMv8Compiler, 3, RISCTempReg, RISCTempReg, 0, 0, instrOffset);
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = (movernrd(self_in_CogARMv8Compiler, RISCTempReg, destReg));
		return instrOffset + 4;

	case MoveRAw:
		/* begin concretizeMoveRAw */
		srcReg = ((self_in_CogARMv8Compiler->operands))[0];

		/* str srcReg, [VarBaseReg, #offset] except that this is illegal for srcReg = SP/X31 */
		destAddr = ((self_in_CogARMv8Compiler->operands))[1];
		if (((destAddr >= ((varBaseAddress) - (0x100))) && (destAddr <= (((varBaseAddress) + (0x1000)) - 1)))) {
			if (destAddr < (varBaseAddress)) {
				error("shouldBeImplemented");
				return 4;
			}
			if (srcReg != SP) {
				((self_in_CogARMv8Compiler->machineCode))[0] = (strnrtimmshiftBy12(self_in_CogARMv8Compiler, 3, VarBaseReg, srcReg, destAddr - (varBaseAddress), 0));
				return 4;
			}
			((self_in_CogARMv8Compiler->machineCode))[0] = (movernrd(self_in_CogARMv8Compiler, srcReg, RISCTempReg));
			((self_in_CogARMv8Compiler->machineCode))[1] = (strnrtimmshiftBy12(self_in_CogARMv8Compiler, 3, VarBaseReg, RISCTempReg, destAddr - (varBaseAddress), 0));
			return 8;
		}
		instrOffset = emitMoveCwintoRat(self_in_CogARMv8Compiler, destAddr, RISCTempReg, 0);
		if (SP != srcReg) {
			((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = (strnrtimmshiftBy12(self_in_CogARMv8Compiler, 3, RISCTempReg, srcReg, 0, 0));
			return instrOffset + 4;
		}
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = (movernrd(self_in_CogARMv8Compiler, srcReg, CArg1Reg));
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = (strnrtimmshiftBy12(self_in_CogARMv8Compiler, 3, RISCTempReg, CArg1Reg, 0, 0));
		return instrOffset + 8;

	case MoveAwRR:
		/* begin concretizeMoveAwRR */
		pairAddress = ((self_in_CogARMv8Compiler->operands))[0];
		reg1 = ((self_in_CogARMv8Compiler->operands))[1];
		reg2 = ((self_in_CogARMv8Compiler->operands))[2];
		assert(reg1 != reg2);
		assert((reg1 != RISCTempReg)
		 && (reg2 != RISCTempReg));
		assert(isAddressRelativeToVarBase(self_in_CogARMv8Compiler, pairAddress));
		assert(((pairAddress - (varBaseAddress)) / 8) < (64));
		if (reg1 == SP) {
			reg1 = RISCTempReg;
		}
		if (reg2 == SP) {
			reg2 = RISCTempReg;
		}
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xA9400000U) + ((((usqInt)(((pairAddress - (varBaseAddress)) / 8)) << 15)))) + ((reg2 << 10))) + ((((usqInt)(VarBaseReg) << 5)))) + reg1);
		if ((reg1 != RISCTempReg)
		 && (reg2 != RISCTempReg)) {
			return 4;
		}
		((self_in_CogARMv8Compiler->machineCode))[1] = (movernrd(self_in_CogARMv8Compiler, RISCTempReg, SP));
		return 8;

	case MoveRRAw:
		/* begin concretizeMoveRRAw */
		reg1 = ((self_in_CogARMv8Compiler->operands))[0];
		reg2 = ((self_in_CogARMv8Compiler->operands))[1];
		pairAddress = ((self_in_CogARMv8Compiler->operands))[2];
		assert(reg1 != reg2);
		assert((reg1 != RISCTempReg)
		 && (reg2 != RISCTempReg));
		assert(isAddressRelativeToVarBase(self_in_CogARMv8Compiler, pairAddress));
		assert(((pairAddress - (varBaseAddress)) / 8) < (64));
		if (reg1 == SP) {
			reg1 = RISCTempReg;
		}
		if (reg2 == SP) {
			reg2 = RISCTempReg;
		}
		if ((reg1 == RISCTempReg)
		 || (reg2 == RISCTempReg)) {
			((self_in_CogARMv8Compiler->machineCode))[0] = (movernrd(self_in_CogARMv8Compiler, SP, RISCTempReg));
			offset = 1;
		}
		else {
			offset = 0;
		}
		((self_in_CogARMv8Compiler->machineCode))[offset] = (((((0xA9000000U) + ((((usqInt)(((pairAddress - (varBaseAddress)) / 8)) << 15)))) + ((reg2 << 10))) + ((((usqInt)(VarBaseReg) << 5)))) + reg1);
		return (offset + 1) * 4;

	case MoveAbR:
		/* begin concretizeMoveAbR */
		srcAddr = ((self_in_CogARMv8Compiler->operands))[0];
		destReg = ((self_in_CogARMv8Compiler->operands))[1];
		assert(!((SP == destReg)));
		if (((srcAddr >= ((varBaseAddress) - (0x100))) && (srcAddr <= (((varBaseAddress) + (0x1000)) - 1)))) {
			if (srcAddr < (varBaseAddress)) {
				error("shouldBeImplemented");
				return 4;
			}
			return emitLdrnrtimmshiftBy12at(self_in_CogARMv8Compiler, 0, VarBaseReg, destReg, srcAddr - (varBaseAddress), 0, 0);
		}
		instrOffset = emitMoveCwintoRat(self_in_CogARMv8Compiler, srcAddr, RISCTempReg, 0);
		return emitLdrnrtimmshiftBy12at(self_in_CogARMv8Compiler, 0, RISCTempReg, destReg, 0, 0, instrOffset);

	case MoveRAb:
		/* begin concretizeMoveRAb */
		srcReg = ((self_in_CogARMv8Compiler->operands))[0];
		destAddr = ((self_in_CogARMv8Compiler->operands))[1];
		assert(!((SP == srcReg)));
		if (((destAddr >= ((varBaseAddress) - (0x100))) && (destAddr <= (((varBaseAddress) + (0x1000)) - 1)))) {
			if (destAddr < (varBaseAddress)) {
				error("shouldBeImplemented");
				return 4;
			}
			((self_in_CogARMv8Compiler->machineCode))[0] = (strnrtimmshiftBy12(self_in_CogARMv8Compiler, 0, VarBaseReg, srcReg, destAddr - (varBaseAddress), 0));
			return 4;
		}
		instrOffset = emitMoveCwintoRat(self_in_CogARMv8Compiler, destAddr, RISCTempReg, 0);
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = (strnrtimmshiftBy12(self_in_CogARMv8Compiler, 0, RISCTempReg, srcReg, 0, 0));
		return instrOffset + 4;

	case MoveMwrR:
		return concretizeMoveMSrR(self_in_CogARMv8Compiler, 3);

	case MoveM32rR:
		return concretizeMoveMSrR(self_in_CogARMv8Compiler, 2);

	case MoveM16rR:
		return concretizeMoveMSrR(self_in_CogARMv8Compiler, 1);

	case MoveMbrR:
		return concretizeMoveMSrR(self_in_CogARMv8Compiler, 0);

	case MoveRMwr:
		return concretizeMoveRMSr(self_in_CogARMv8Compiler, 3);

	case MoveRM32r:
		return concretizeMoveRMSr(self_in_CogARMv8Compiler, 2);

	case MoveRM16r:
		return concretizeMoveRMSr(self_in_CogARMv8Compiler, 1);

	case MoveRMbr:
		return concretizeMoveRMSr(self_in_CogARMv8Compiler, 0);

	case MoveXwrRR:
		return concretizeMoveXSrRR(self_in_CogARMv8Compiler, 3);

	case MoveX32rRR:
		return concretizeMoveXSrRR(self_in_CogARMv8Compiler, 2);

	case MoveX16rRR:
		return concretizeMoveXSrRR(self_in_CogARMv8Compiler, 1);

	case MoveXbrRR:
		return concretizeMoveXSrRR(self_in_CogARMv8Compiler, 0);

	case MoveRXwrR:
		return concretizeMoveRXSrR(self_in_CogARMv8Compiler, 3);

	case MoveRX32rR:
		return concretizeMoveRXSrR(self_in_CogARMv8Compiler, 2);

	case MoveRX16rR:
		return concretizeMoveRXSrR(self_in_CogARMv8Compiler, 1);

	case MoveRXbrR:
		return concretizeMoveRXSrR(self_in_CogARMv8Compiler, 0);

	case MoveM64rRd:
		/* begin concretizeMoveM64rRd */
		offsetUsqInt = ((self_in_CogARMv8Compiler->operands))[0];
		baseReg = ((self_in_CogARMv8Compiler->operands))[1];
		rd = ((self_in_CogARMv8Compiler->operands))[2];
		assert((!(offsetUsqInt & 7)));
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xFD400000U) + ((offsetUsqInt << 7))) + ((baseReg << 5))) + rd);
		return 4;

	case MoveRdM64r:
		/* begin concretizeMoveRdM64r */
		rd = ((self_in_CogARMv8Compiler->operands))[0];
		offsetUsqInt = ((self_in_CogARMv8Compiler->operands))[1];
		baseReg = ((self_in_CogARMv8Compiler->operands))[2];
		assert((!(offsetUsqInt & 7)));
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xFD000000U) + ((offsetUsqInt << 7))) + ((baseReg << 5))) + rd);
		return 4;

	case PopR:
		/* begin concretizePopR */
		reg = ((self_in_CogARMv8Compiler->operands))[0];
		assert(!((SP == reg)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((4164977664U) + ((((usqInt)(SPReg) << 5)))) + reg);
		return 4;

	case PushR:
		/* begin concretizePushR */
		reg = ((self_in_CogARMv8Compiler->operands))[0];
		assert(!((SP == reg)));
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xF8000000U) + ((((usqInt)((-8 & (0x1FF))) << 12)))) + (0xC00)) + ((((usqInt)(SPReg) << 5)))) + reg);
		return 4;

	case NativePopRR:
		/* begin concretizeNativePopRR */
		reg1 = ((self_in_CogARMv8Compiler->operands))[0];

		/* Post-index */
		reg2 = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xA8C10000U) + ((reg2 << 10))) + ((((usqInt)(SP) << 5)))) + reg1);
		return 4;

	case NativePushRR:
		/* begin concretizeNativePushRR */
		reg1 = ((self_in_CogARMv8Compiler->operands))[0];

		/* Pre-index */
		reg2 = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xA9BF0000U) + ((reg2 << 10))) + ((((usqInt)(SP) << 5)))) + reg1);
		return 4;

	case PushCq:
		/* begin concretizePushCq */
		((self_in_CogARMv8Compiler->operands))[1] = RISCTempReg;

		/* C6.2.273	STR (immediate)	Pre-index	C6-1239 */
		instrBytes = concretizeMoveCqR(self_in_CogARMv8Compiler);
		((self_in_CogARMv8Compiler->machineCode))[instrBytes / 4] = (((((0xF8000000U) + ((((usqInt)((-8 & (0x1FF))) << 12)))) + (0xC00)) + ((((usqInt)(SPReg) << 5)))) + RISCTempReg);
		return instrBytes + 4;

	case PushCw:
		/* begin concretizePushCw */
		/* C6.2.273	STR (immediate)	Pre-index	C6-1239 */
		instrBytes = emitMoveCwintoRat(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[0], RISCTempReg, 0);
		((self_in_CogARMv8Compiler->machineCode))[instrBytes / 4] = (((((0xF8000000U) + ((((usqInt)((-8 & (0x1FF))) << 12)))) + (0xC00)) + ((((usqInt)(SPReg) << 5)))) + RISCTempReg);
		return instrBytes + 4;

	case PrefetchAw:
		/* begin concretizePrefetchAw */
		srcAddr = ((self_in_CogARMv8Compiler->operands))[0];
		if (((srcAddr >= ((varBaseAddress) - (0x100))) && (srcAddr <= (((varBaseAddress) + (0x1000)) - 1)))) {
			if (srcAddr < (varBaseAddress)) {
				error("shouldBeImplemented");
				return 4;
			}
			((self_in_CogARMv8Compiler->machineCode))[0] = (prnimmshiftBy12(self_in_CogARMv8Compiler, VarBaseReg, srcAddr - (varBaseAddress), 0));
			return 4;
		}
		return 0;

	case ConvertRRd:
		/* begin concretizeConvertRRd */
		((self_in_CogARMv8Compiler->machineCode))[0] = (((0x9E620000U) + (((((self_in_CogARMv8Compiler->operands))[0]) << 5))) + (((self_in_CogARMv8Compiler->operands))[1]));
		return 4;

	case ConvertRdR:
		/* begin concretizeConvertRdR */
		((self_in_CogARMv8Compiler->machineCode))[0] = (((0x9E780000U) + (((((self_in_CogARMv8Compiler->operands))[0]) << 5))) + (((self_in_CogARMv8Compiler->operands))[1]));
		return 4;

	case SignExtend8RR:
		return concretizeSignExtendRR(self_in_CogARMv8Compiler, 8);

	case SignExtend16RR:
		return concretizeSignExtendRR(self_in_CogARMv8Compiler, 16);

	case SignExtend32RR:
		return concretizeSignExtendRR(self_in_CogARMv8Compiler, 32);

	case ZeroExtend8RR:
		return concretizeZeroExtendRR(self_in_CogARMv8Compiler, 8);

	case ZeroExtend16RR:
		return concretizeZeroExtendRR(self_in_CogARMv8Compiler, 16);

	case ZeroExtend32RR:
		return concretizeZeroExtendRR(self_in_CogARMv8Compiler, 32);

	case LDAXR:
		/* begin concretizeLDAXR */
		targetReg = ((self_in_CogARMv8Compiler->operands))[0];
		addressReg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((3361733632U) + ((addressReg << 5))) + targetReg);
		return 4;

	case STLXR:
		/* begin concretizeSTLXR */
		valueReg = ((self_in_CogARMv8Compiler->operands))[0];
		addressReg = ((self_in_CogARMv8Compiler->operands))[1];
		statusReg = ((self_in_CogARMv8Compiler->operands))[2];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xC8000000U) + ((statusReg << 16))) + (0xFC00)) + ((addressReg << 5))) + valueReg);
		return 4;

	case CLREX:
		/* begin concretizeCLREX */
		((self_in_CogARMv8Compiler->machineCode))[0] = 0xD5033F5FU;
		return 4;

	case STLR:
		return concretizeSTLR(self_in_CogARMv8Compiler);

	case CASAL:
		/* begin concretizeCASAL */
		constantReg = ((self_in_CogARMv8Compiler->operands))[0];
		valueReg = ((self_in_CogARMv8Compiler->operands))[1];
		baseReg = ((self_in_CogARMv8Compiler->operands))[2];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xC8E00000U) + ((constantReg << 16))) + (0xFC00)) + ((baseReg << 5))) + valueReg);
		return 4;

	case CCMPNE:
		/* begin concretizeCCMPNE */
		rM = ((self_in_CogARMv8Compiler->operands))[0];
		rN = ((self_in_CogARMv8Compiler->operands))[1];
		flags = ((self_in_CogARMv8Compiler->operands))[2];
		((self_in_CogARMv8Compiler->machineCode))[0] = (((((0xFA400000U) + ((rM << 16))) + ((((usqInt)(NE) << 12)))) + ((rN << 5))) + flags);
		return 4;

	case CSET:
		/* begin concretizeCSET */
		reg = ((self_in_CogARMv8Compiler->operands))[0];
		condition = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0x9A9F0000U) + (((condition ^ 1) << 12))) + (0x7E0)) + reg);
		return 4;

	case CBNZ:
	case CBZ:
		/* begin concretizeCB */
		/* begin computeJumpTargetOffset */
		/* begin jumpTargetAddress */
		jumpTarget = ((AbstractInstruction *) (((self_in_CogARMv8Compiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget);
		if (/* isAnInstruction: */
			(addressIsInInstructions(jumpTarget))
		 || (jumpTarget == (methodLabel))) {
			jumpTarget = ((AbstractInstruction *) ((jumpTarget->address)));
		}
		assert(jumpTarget != 0);
		offset = (((sqLong) jumpTarget)) - (((sqLong) ((self_in_CogARMv8Compiler->address))));
		assert((offset != 0)
		 && (isInImmediateBranchRange(self_in_CogARMv8Compiler, offset)));
		reg = ((self_in_CogARMv8Compiler->operands))[1];
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xB4000000U) + ((((self_in_CogARMv8Compiler->opcode)) == CBNZ
		? 0x1000000
		: 0))) + ((((usqInt)((offset & (0x1FFFFF))) << 3)))) + reg);
		return 4;

	case MovePerfCnt64RL:
		return concretizeMovePerfCnt64RL(self_in_CogARMv8Compiler);

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}


/*	C7.2.184	LDR (immediate, SIMD&FP)	C7-1800
	C7.2.186	LDR (register, SIMD&FP)	C7-1806 */
/*	cogit processor disassembleInstructionAt: instrOffset In: machineCode
	object 
 */
/*	Unsigned offset, C7-1801 */

	/* CogARMv8Compiler>>#emitLdfprn:rt:imm:shiftBy12:at: */
static NoDbgRegParms sqInt
emitLdfprnrtimmshiftBy12at(AbstractInstruction *self_in_CogARMv8Compiler, sqInt baseReg, sqInt targetDPReg, sqInt offset, sqInt shiftBy12, sqInt instrOffset)
{
    sqInt instrBytes;

	if (((offset % 8) == 0)
	 && ((((offset / 8) >= 0) && ((offset / 8) <= (0xFFF))))) {
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = ((((0xFD400000U) + ((((usqInt)(offset) << 7)))) + ((((usqInt)(baseReg) << 5)))) + targetDPReg);
		return instrOffset + 4;
	}

	/* C7.2.186	LDR (register, SIMD&FP)	C7-1806 */
	instrBytes = emitMoveCwintoRat(self_in_CogARMv8Compiler, offset, RISCTempReg, instrOffset);
	((self_in_CogARMv8Compiler->machineCode))[instrBytes / 4] = ((((((0xFC600000U) + ((((usqInt)(RISCTempReg) << 16)))) + ((((usqInt)(UXTX) << 13)))) + (0x800)) + ((((usqInt)(baseReg) << 5)))) + targetDPReg);
	return instrBytes + 4;
}


/*	C6.2.130	LDR (immediate)	C6-976
	C6.2.132	LDR (register)		C6-981
	C6.2.136	LDRH (immediate)	C6-990
	C6.2.166	LDUR				C6-1058
	C6.2.134	LDRB (immediate)	C6-985
	C6.2.135	LDRB (register)		C6-988 */
/*	cogit processor disassembleInstructionAt: instrOffset In: machineCode
	object 
 */

	/* CogARMv8Compiler>>#emitLd:rn:rt:imm:shiftBy12:at: */
static NoDbgRegParms sqInt
emitLdrnrtimmshiftBy12at(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne, sqInt baseReg, sqInt targetReg, sqInt offset, sqInt shiftBy12, sqInt instrOffset)
{
    sqInt instrBytes;
    sqInt unitSize;

	/* Unsigned offset, C6-977 */
	unitSize = 1ULL << unitSizeLog2MinusOne;
	if (((offset % unitSize) == 0)
	 && ((((offset / unitSize) >= 0) && ((offset / unitSize) <= (0xFFF))))) {
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = ((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x39400000)) + ((((usqInt)(offset) << (10 - unitSizeLog2MinusOne))))) + ((((usqInt)(baseReg) << 5)))) + targetReg);
		return instrOffset + 4;
	}
	if (((offset >= -256) && (offset <= 0xFF))) {

		/* Unscaled signed 9-bit offset, C6-1058 */
		((self_in_CogARMv8Compiler->machineCode))[instrOffset / 4] = ((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x38400000)) + (((offset & 0x1FF) << 12))) + ((((usqInt)(baseReg) << 5)))) + targetReg);
		return instrOffset + 4;
	}
	instrBytes = emitMoveCwintoRat(self_in_CogARMv8Compiler, offset, RISCTempReg, instrOffset);
	((self_in_CogARMv8Compiler->machineCode))[instrBytes / 4] = ((((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x38600000)) + ((((usqInt)(RISCTempReg) << 16)))) + ((((usqInt)(UXTX) << 13)))) + (0x800)) + ((((usqInt)(baseReg) << 5)))) + targetReg);
	return instrBytes + 4;
}


/*	Emit a load of constant into destReg. Answer the number of bytes of
	machine code
	generated. Literals are stored out-of-line; emit a LDR (literal) with the
	relevant offset. */

	/* CogARMv8Compiler>>#emitMoveCw:intoR:at: */
static NoDbgRegParms sqInt
emitMoveCwintoRat(AbstractInstruction *self_in_CogARMv8Compiler, usqInt constantArg, sqInt destReg, sqInt offsetBytes)
{
    sqInt aligned;
    usqInt constant;
    sqInt pcRelativeOffset;
    usqInt unaligned;

	assert(!((destReg == SP)));
	constant = (/* isAnInstruction: */
			(addressIsInInstructions(((AbstractInstruction *) constantArg)))
		 || ((((AbstractInstruction *) constantArg)) == (methodLabel))
				? ((((AbstractInstruction *) constantArg))->address)
				: constantArg);
	if (((((self_in_CogARMv8Compiler->opcode)) == MoveCwR)
	 || (((self_in_CogARMv8Compiler->opcode)) == PushCw))
	 && (/* inCurrentCompilation: */
		(/* isAnInstruction: */
		(addressIsInInstructions(((AbstractInstruction *) constant)))
	 || ((((AbstractInstruction *) constant)) == (methodLabel)))
	 || (/* addressIsInCurrentCompilation: */
		((((usqInt)constant)) >= ((methodLabel->address)))
	 && ((((usqInt)constant)) < ((((youngReferrers) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers) : (((methodLabel->address)) + MaxMethodSize))))))) {

		/* C6.2.10 	ADR	C6-773 */
		unaligned = constant & 3;
		aligned = constant - unaligned;
		pcRelativeOffset = ((aligned - (((sqInt)((self_in_CogARMv8Compiler->address)))))) >> 2;
		assert(((pcRelativeOffset >= (-262144)) && (pcRelativeOffset <= (0x3FFFF))));
		((self_in_CogARMv8Compiler->machineCode))[offsetBytes / 4] = (((((unaligned << 29)) + (0x10000000)) + ((((usqInt)((pcRelativeOffset & (0x7FFFF))) << 5)))) + destReg);
		return offsetBytes + 4;
	}
	assert(addressIsInCurrentCompilation((((self_in_CogARMv8Compiler->dependent))->address)));
	assert((((((self_in_CogARMv8Compiler->dependent))->address)) % 4) == 0);
	assert((SQABS(((((usqInt)((((self_in_CogARMv8Compiler->dependent))->address)))) - (((usqInt)(((self_in_CogARMv8Compiler->address)) + offsetBytes)))))) < (0x100000));
	((self_in_CogARMv8Compiler->machineCode))[offsetBytes / 4] = (((0x58000000) + ((((usqInt)(((((((self_in_CogARMv8Compiler->dependent))->address)) - (((self_in_CogARMv8Compiler->address)) + offsetBytes)) & (0x1FFFFF))) << 3)))) + destReg);
	return offsetBytes + 4;
}


/*	C6.2.273	STR (immediate)	C6-1239
	C6.2.274	STR (register)		C6-1242
	C6.2.275	STRB (immediate)	C6-1244 */

	/* CogARMv8Compiler>>#emitSt:rn:rt:imm:shiftBy12: */
static NoDbgRegParms sqInt
emitStrnrtimmshiftBy12(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne, sqInt baseReg, sqInt sourceReg, sqInt offset, sqInt shiftBy12)
{
    sqInt instrBytes;
    sqInt unitSize;

	unitSize = 1ULL << unitSizeLog2MinusOne;
	assert(!((SP == sourceReg)));
	assert(!((baseReg == sourceReg)));
	if (((offset % unitSize) == 0)
	 && ((((offset / unitSize) >= 0) && ((offset / unitSize) <= (0xFFF))))) {
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x39000000)) + ((((usqInt)(offset) << (10 - unitSizeLog2MinusOne))))) + ((((usqInt)(baseReg) << 5)))) + sourceReg);
		return 4;
	}
	if (((offset >= -256) && (offset <= 0xFF))) {

		/* Unscaled signed 9-bit offset, C6-1244 */
		((self_in_CogARMv8Compiler->machineCode))[0] = ((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x38000000)) + (((offset & 0x1FF) << 12))) + ((((usqInt)(baseReg) << 5)))) + sourceReg);
		return 4;
	}
	if (/* isPossiblyShiftableNegatableImm12: */
		(((offset >= (-4096)) && (offset <= (0xFFF))))
	 || (((!(offset & (0xFFF))))
	 && (((((offset) >> 12) >= (-4096)) && (((offset) >> 12) <= (0xFFF)))))) {
		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if (((offset >= 0) && (offset <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xB1000000U) + ((((usqInt)(offset) << 10)))) + ((((usqInt)(baseReg) << 5)))) + RISCTempReg);
			goto l2;
		}
		if (((!(offset & (0xFFF))))
		 && (((((offset) >> 12) >= 0) && (((offset) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xB1000000U) + ((((usqInt)(offset)) >> 2) + (0x400000))) + ((((usqInt)(baseReg) << 5)))) + RISCTempReg);
			goto l2;
		}

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if ((((-offset) >= 0) && ((-offset) <= (0xFFF)))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xF1000000U) + ((((usqInt)((-offset)) << 10)))) + ((((usqInt)(baseReg) << 5)))) + RISCTempReg);
			goto l1;
		}
		if (((!((-offset) & (0xFFF))))
		 && ((((((-offset)) >> 12) >= 0) && ((((-offset)) >> 12) <= (0xFFF))))) {
			((self_in_CogARMv8Compiler->machineCode))[0] = ((((0xF1000000U) + ((((usqInt)((-offset))) >> 2) + (0x400000))) + ((((usqInt)(baseReg) << 5)))) + RISCTempReg);
			goto l1;
		}
		error("cannot happen");
l1:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;
l2:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;
		((self_in_CogARMv8Compiler->machineCode))[1] = ((((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x38200000)) + ((((usqInt)(XZR) << 16)))) + ((((usqInt)(UXTX) << 13)))) + (0x800)) + ((((usqInt)(RISCTempReg) << 5)))) + sourceReg);
		return 8;
	}
	instrBytes = emitMoveCwintoRat(self_in_CogARMv8Compiler, offset, RISCTempReg, 0);
	assert(instrBytes == 4);
	((self_in_CogARMv8Compiler->machineCode))[1] = ((((((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x38200000)) + ((((usqInt)(RISCTempReg) << 16)))) + ((((usqInt)(UXTX) << 13)))) + (0x800)) + ((((usqInt)(baseReg) << 5)))) + sourceReg);
	return 8;
}


/*	Answer if CallFull and/or JumpFull are relative and hence need relocating
	on method
	compation. If so, they are annotated with IsRelativeCall in methods and
	relocated in
	relocateIfCallOrMethodReference:mcpc:delta: */

	/* CogARMv8Compiler>>#fullCallsAreRelative */
static NoDbgRegParms sqInt
fullCallsAreRelative(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 0;
}


/*	Divide regDividend by regDivisor storing the quotient in regQuotient and
	remainder in regRemainder.
	MSUB Multiply-subtract		MSUB	C6-1109
	SDIV Signed divide			SDIV	C6-1174 */
/*	For the MSUB to work we must preserve regDivisor and regDividend for the
	MSUB; i.e. the DivRRR must not overwrite either regDivisor or regDividend. */

	/* CogARMv8Compiler>>#genDivR:R:Quo:Rem: */
static NoDbgRegParms AbstractInstruction *
genDivRRQuoRem(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regDivisor, sqInt regDividend, sqInt regQuotient, sqInt regRemainder)
{
    AbstractInstruction *instr;
    sqInt safeRegQuotient;

	safeRegQuotient = ((regQuotient == regDividend)
		 || (regQuotient == regDivisor)
				? RISCTempReg
				: regQuotient);

	/* MSUB <Xd>, <Xn>, <Xm>, <Xa>, Xd := Xa - (Xn * Xm) */
	/* MSUB regRemainder, regQuotient, regDivisor, regQuotient */
	instr = genoperandoperandoperand(DivRRR, regDividend, regDivisor, safeRegQuotient);
	genoperandoperandoperand(MSubRRR, ((((usqInt)(safeRegQuotient) << 5))) + regDivisor, regDividend, regRemainder);
	if (safeRegQuotient != regQuotient) {
		genoperandoperand(MoveRR, safeRegQuotient, regQuotient);
	}
	return instr;
}


/*	Use the DC instruction to implement ceFlushDCache(void *start, void *end);
	see flushDCacheFrom:to:.
	If there is a dual mapped zone then clean data via DC_CVAU as address +
	codeToDataDelta, then invalidate data at address via CIVAC. */
/*	D4.4.7		About cache maintenance in AArch64 state													D4-2478
	
	Terminology for Clean, Invalidate, and Clean and Invalidate
	instructions									D4-2479 ...
	-	For instructions operating by VA, the following conceptual points are
	defined:						D4-2480 Point of Unification (PoU)							
	The PoU for a PE is the point by which the instruction and data caches and
	the translation table walks of that
	PE are guaranteed to see the same copy of a memory location. In many
	cases, the Point of Unification is the
	point in a uniprocessor memory system by which the instruction and data
	caches and the translation table
	walks have merged.
	
	The PoU for an Inner Shareable shareability domain is the point by which
	the instruction and data caches
	and the translation table walks of all the PEs in that Inner Shareable
	shareability domain are guaranteed to
	see the same copy of a memory location. Defining this point permits
	self-modifying software to ensure future
	instruction fetches are associated with the modified version of the
	software by using the standard correctness
	policy of:
	1. Clean data cache entry by address.
	2. Invalidate instruction cache entry by address.
	
	Example code for cache maintenance instructions D4-2490 - D4-2491 */

	/* CogARMv8Compiler>>#generateDCacheFlush */
static NoDbgRegParms AbstractInstruction *
generateDCacheFlush(AbstractInstruction *self_in_CogARMv8Compiler)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *loop;
    sqInt mask;
    sqInt quickConstant;


#  if !(__APPLE__ && __MACH__)
	assert((getCodeToDataDelta()) != 0);

	/* Since this is used from C code we must use only caller-saved registers.
	   C arg registers 2 & 3 are such a convenient pair of caller-saved registers. */
	mask = (1ULL << (highBit(limitAddress))) - (dataCacheLineLength(self_in_CogARMv8Compiler));
	gAndCqRR(mask, CArg0Reg, CArg2Reg);
	gAddCqRR(getCodeToDataDelta(), CArg2Reg, CArg3Reg);

	/* see concretizeDataCacheControl */
	loop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genoperandoperand(DC, CArg3Reg, DC_CVAU);
	genoperandoperand(DC, CArg2Reg, DC_CIVAC);
	quickConstant = dataCacheLineLength(self_in_CogARMv8Compiler);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, CArg2Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	quickConstant = dataCacheLineLength(self_in_CogARMv8Compiler);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, CArg3Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!(0 /* (CArg1Reg = SPReg) */));
	genoperandoperand(CmpRR, CArg1Reg, CArg2Reg);

	/* JumpBelow: */
	genConditionalBranchoperand(JumpBelow, ((sqInt)loop));

	/* RetN: */
	genoperand(RetN, 0);
#  endif // !(__APPLE__ && __MACH__)

	return self_in_CogARMv8Compiler;
}


/*	Use DC VAUC, DSB, IC IVAU, and ISB instructions to implement
	ceFlushICache(void *start, void *end); see flushICacheFrom:to:.
	One might think that if there is a dual zone then data at address +
	codeToDataDelta must be cleaned,
	but this isn't the case. All we need to do is clean data at address via DC
	VAUC and instructions via IC IVAU. */
/*	B2.2.5		Concurrent modification and execution of
	instructions											B2-112 
	...to avoid UNPREDICTABLE or CONSTRAINED UNPREDICTABLE behavior,
	instruction modifications must be explicitly synchronized before they are
	executed. The required synchronization is as follows:
	
	1.	No PE must be executing an instruction when another PE is modifying
	that instruction.
	
	2.	To ensure that the modified instructions are observable, a PE that is
	writing the instructions must issue the following sequence of instructions
	and operations:
	
	; Coherency example for data and instruction accesses within the same
	Inner Shareable domain.
	; enter this code with <Wt> containing a new 32-bit instruction, to be
	held in Cacheable space at a location pointed to by Xn.
	
	STR Wt, [Xn]
	DC CVAU, Xn		; Clean data cache by VA to point of unification (PoU)
	DSB ISH			; Ensure visibility of the data cleaned from cache
	IC IVAU, Xn			; Invalidate instruction cache by VA to PoU
	DSB ISH
	
	Note
	-	The DC CVAU operation is not required if the area of memory is either
	Non-cacheable or Write-Through Cacheable.
	-	If the contents of physical memory differ between the mappings, changing
	the mapping of VAs to PAs can cause
	the instructions to be concurrently modified by one PE and executed by
	another PE. If the modifications affect
	instructions other than those listed as being acceptable for modification,
	synchronization must be used to avoid
	UNPREDICTABLE or CONSTRAINED UNPREDICTABLE behavior.
	
	3.	In a multiprocessor system, the IC IVAU is broadcast to all PEs within
	the Inner Shareable domain of the PE running this sequence.
	However, when the modified instructions are observable, each PE that is
	executing the modified instructions must issue the following
	instruction to ensure execution of the modified instructions:
	
	ISB					; Synchronize fetched instruction stream */
/*	D4.4.7		About cache maintenance in AArch64 state													D4-2478
	
	Terminology for Clean, Invalidate, and Clean and Invalidate
	instructions									D4-2479 ...
	-	For instructions operating by VA, the following conceptual points are
	defined:						D4-2480 Point of Unification (PoU)							
	The PoU for a PE is the point by which the instruction and data caches and
	the translation table walks of that
	PE are guaranteed to see the same copy of a memory location. In many
	cases, the Point of Unification is the
	point in a uniprocessor memory system by which the instruction and data
	caches and the translation table
	walks have merged.
	
	The PoU for an Inner Shareable shareability domain is the point by which
	the instruction and data caches
	and the translation table walks of all the PEs in that Inner Shareable
	shareability domain are guaranteed to
	see the same copy of a memory location. Defining this point permits
	self-modifying software to ensure future
	instruction fetches are associated with the modified version of the
	software by using the standard correctness
	policy of:
	1. Clean data cache entry by address.
	2. Invalidate instruction cache entry by address.
	
	Example code for cache maintenance instructions D4-2490 - D4-2491 */

	/* CogARMv8Compiler>>#generateICacheFlush */
static NoDbgRegParms AbstractInstruction *
generateICacheFlush(AbstractInstruction *self_in_CogARMv8Compiler)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *loop;
    sqInt mask;
    sqInt quickConstant;


#  if !(__APPLE__ && __MACH__)

	/* See concretizeCacheControlOp1:CRm:Op2: &
	   http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100403_0200_00_en/lau1443435580346.html */
	if (dataCacheFlushRequired(self_in_CogARMv8Compiler)) {

		/* CTR_EL0.IDC is zero; must clean data cache to point of unification. */
		/* Since this is used from C code we must use only caller-saved registers.
		   C arg registers 2 & 3 are as such a convenient pair of caller-saved registers. */
		/* Mask is large enough to encompass the method zone and has the correct minimum alignment. */
		mask = (1ULL << (highBit(limitAddress))) - (dataCacheLineLength(self_in_CogARMv8Compiler));
		gAndCqRR(mask, CArg0Reg, CArg2Reg);

		/* see concretizeDataCacheControl */
		loop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		genoperandoperand(DC, CArg2Reg, DC_CVAU);
		quickConstant = dataCacheLineLength(self_in_CogARMv8Compiler);

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, quickConstant, CArg2Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}

		/* begin CmpR:R: */
		assert(!(0 /* (CArg1Reg = SPReg) */));
		genoperandoperand(CmpRR, CArg1Reg, CArg2Reg);

		/* JumpBelow: */
		genConditionalBranchoperand(JumpBelow, ((sqInt)loop));
	}
	genoperandoperand(DSB, DSB_ISH, DSB_ALL);
	if (instructionCacheFlushRequired(self_in_CogARMv8Compiler)) {

		/* CTR_EL0.DIC is zero; must clean instruction cache to point of unification. */
		/* Mask is large enough to encompass the method zone and has the correct minimum alignment. */
		mask = (1ULL << (highBit(limitAddress))) - (instructionCacheLineLength(self_in_CogARMv8Compiler));
		gAndCqRR(mask, CArg0Reg, CArg2Reg);

		/* see concretizeDataCacheControl */
		loop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		genoperandoperand(IC, CArg2Reg, IC_IVAU);
		quickConstant = instructionCacheLineLength(self_in_CogARMv8Compiler);

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, quickConstant, CArg2Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}

		/* begin CmpR:R: */
		assert(!(0 /* (CArg1Reg = SPReg) */));
		genoperandoperand(CmpRR, CArg1Reg, CArg2Reg);

		/* JumpBelow: */
		genConditionalBranchoperand(JumpBelow, ((sqInt)loop));
		genoperandoperand(DSB, DSB_ISH, DSB_ALL);
	}
	gen(ISB);

	/* RetN: */
	genoperand(RetN, 0);
#  endif // !(__APPLE__ && __MACH__)

	return self_in_CogARMv8Compiler;
}


/*	Load the frame and stack pointer registers with those of the C stack,
	effecting a switch to the C stack. Used when machine code calls into
	the CoInterpreter run-time (e.g. to invoke interpreter primitives).
	N.B. CoInterpreter stack layout dictates that the stack pointer should be
	loaded first.
	The stack zone is allocated on the C stack before the interpreter runs and
	hence before CStackPointer and CFramePointer are captured. So when running
	in machine
	code the native stack pointer and frame pointer appear to be on a colder
	part of the
	stack to CStackPointer and CFramePointer. When CStackPointerhas been set
	and the frame pointer is still in machine code the current frame looks
	like it has lots of
	stack. If the frame pointer was set to CFramePointer before hand then it
	would be beyond the stack pointer for that one instruction. */
/*	Load the frame and stack pointer registers with those of the C stack,
	effecting a switch to the C stack. Used when machine code calls into
	the CoInterpreter run-time (e.g. to invoke interpreter primitives).
	Override to try and use MoveAwRR/ldp */

	/* CogARMv8Compiler>>#genLoadCStackPointers */
static NoDbgRegParms sqInt
genLoadCStackPointers(AbstractInstruction *self_in_CogARMv8Compiler)
{
	if (((cStackPointerAddress()) + 8) == (cFramePointerAddress())) {
		genoperandoperandoperand(MoveAwRR, cStackPointerAddress(), SP, FP);
		return 0;
	}

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveAwR, cStackPointerAddress(), NativeSPReg));

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(cFramePointerAddress(), genoperandoperand(MoveAwR, cFramePointerAddress(), FPReg));
	return 0;
}

	/* CogARMv8Compiler>>#genLoadNativeSPRegWithAlignedSPReg */
static NoDbgRegParms AbstractInstruction *
genLoadNativeSPRegWithAlignedSPReg(AbstractInstruction *self_in_CogARMv8Compiler)
{
	gAndCqRR((-1 - (((BytesPerWord * 2) - 1))), SPReg, SP);
	return self_in_CogARMv8Compiler;
}


/*	Switch back to the Smalltalk stack. Assign SPReg first
	because typically it is used immediately afterwards. */
/*	Switch back to the Smalltalk stack. Assign SPReg first
	because typically it is used immediately afterwards.
	Override to try and use MoveAwRR/ldp */

	/* CogARMv8Compiler>>#genLoadStackPointers */
static NoDbgRegParms sqInt
genLoadStackPointers(AbstractInstruction *self_in_CogARMv8Compiler)
{
	if (((stackPointerAddress()) + 8) == (framePointerAddress())) {
		genoperandoperandoperand(MoveAwRR, stackPointerAddress(), SPReg, FPReg);
		return 0;
	}
	if (((framePointerAddress()) + 8) == (stackPointerAddress())) {
		genoperandoperandoperand(MoveAwRR, framePointerAddress(), FPReg, SPReg);
		return 0;
	}

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveAwR, stackPointerAddress(), SPReg));

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(framePointerAddress(), genoperandoperand(MoveAwR, framePointerAddress(), FPReg));
	return 0;
}


/*	Generate the code to pass up to four arguments in a C run-time call. Hack:
	each argument is
	either a negative number, which encodes a constant, or a non-negative
	number, that of a register.
	The encoding for constants is defined by trampolineArgConstant: &
	trampolineArgValue:. Pass a constant as the result of
	trampolineArgConstant:. 
	Run-time calls have no more than four arguments, so chosen so that on ARM,
	where in its C ABI the
	first four integer arguments are passed in registers, all arguments can be
	passed in registers. We
	defer to the back end to generate this code not so much that the back end
	knows whether it uses
	the stack or registers to pass arguments (it does, but...). In fact we
	defer for an extremely evil reason.
	Doing so allows the x64 (where up to 6 args are passed) to assign the
	register arguments in an order
	that allows some of the argument registers to be used for specific
	abstract registers, specifically
	ReceiverResultReg and ClassReg. This is evil, evil, evil, but also it's
	really nice to keep using the old
	register assignments the original author has grown accustomed to. */

	/* CogARMv8Compiler>>#genMarshallNArgs:arg:arg:arg:arg: */
static NoDbgRegParms AbstractInstruction *
genMarshallNArgsargargargarg(AbstractInstruction *self_in_CogARMv8Compiler, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3)
{
    AbstractInstruction *anInstruction;

	if (!numArgs) {
		return self_in_CogARMv8Compiler;
	}
	if (numArgs > 1) {
		if ((!(regOrConst1 < NoReg))
		 && (regOrConst1 == CArg0Reg)) {
			/* MoveR:R: */
			genoperandoperand(MoveRR, regOrConst1, Extra0Reg);
			return genMarshallNArgsargargargarg(self_in_CogARMv8Compiler, numArgs, regOrConst0, Extra0Reg, regOrConst2, regOrConst3);
		}
		if (numArgs > 2) {
			if ((!(regOrConst2 < NoReg))
			 && ((regOrConst2 == CArg0Reg)
			 || (regOrConst2 == CArg1Reg))) {
				/* MoveR:R: */
				genoperandoperand(MoveRR, regOrConst2, Extra1Reg);
				return genMarshallNArgsargargargarg(self_in_CogARMv8Compiler, numArgs, regOrConst0, regOrConst1, Extra1Reg, regOrConst3);
			}
			if (numArgs > 3) {
				if ((!(regOrConst3 < NoReg))
				 && ((regOrConst3 == CArg0Reg)
				 || ((regOrConst3 == CArg1Reg)
				 || (regOrConst3 == CArg2Reg)))) {
					/* MoveR:R: */
					genoperandoperand(MoveRR, regOrConst3, Extra2Reg);
					return genMarshallNArgsargargargarg(self_in_CogARMv8Compiler, numArgs, regOrConst0, regOrConst1, regOrConst2, Extra2Reg);
				}
			}
		}
	}
	if (regOrConst0 < NoReg) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, -2 - regOrConst0, CArg0Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(-2 - regOrConst0, BytesPerOop));
		}
	}
	else {
		/* MoveR:R: */
		genoperandoperand(MoveRR, regOrConst0, CArg0Reg);
	}
	if (numArgs == 1) {
		return self_in_CogARMv8Compiler;
	}
	if (regOrConst1 < NoReg) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, -2 - regOrConst1, CArg1Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(-2 - regOrConst1, BytesPerOop));
		}
	}
	else {
		/* MoveR:R: */
		genoperandoperand(MoveRR, regOrConst1, CArg1Reg);
	}
	if (numArgs == 2) {
		return self_in_CogARMv8Compiler;
	}
	if (regOrConst2 < NoReg) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, -2 - regOrConst2, CArg2Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(-2 - regOrConst2, BytesPerOop));
		}
	}
	else {
		/* MoveR:R: */
		genoperandoperand(MoveRR, regOrConst2, CArg2Reg);
	}
	if (numArgs == 3) {
		return self_in_CogARMv8Compiler;
	}
	if (regOrConst3 < NoReg) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, -2 - regOrConst3, CArg3Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(-2 - regOrConst3, BytesPerOop));
		}
	}
	else {
		/* MoveR:R: */
		genoperandoperand(MoveRR, regOrConst3, CArg3Reg);
	}
	return self_in_CogARMv8Compiler;
}

	/* CogARMv8Compiler>>#genMulOverflowR:R: */
static NoDbgRegParms AbstractInstruction *
genMulOverflowRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regSource, sqInt regDest)
{
	return genoperandoperandoperand(MulOverflowRRR, regSource, regDest, regDest);
}

	/* CogARMv8Compiler>>#genMulR:R: */
static NoDbgRegParms AbstractInstruction *
genMulRR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regSource, sqInt regDest)
{
	return genoperandoperandoperand(MulRRR, regSource, regDest, regDest);
}


/*	Ensure that the register args are pushed before the outer and
	inner retpcs at an entry miss for arity <= self numRegArgs. The
	outer retpc is that of a call at a send site. The inner is the call
	from a method or PIC abort/miss to the trampoline. */
/*	Putting the receiver and args above the return address means the
	CoInterpreter has a single machine-code frame format which saves
	us a lot of work. */
/*	Iff there are register args convert
	sp		->	outerRetpc			(send site retpc)
	linkReg = innerRetpc			(PIC abort/miss retpc)
	to
	base	->	receiver
	(arg0)
	(arg1)
	sp		->	outerRetpc			(send site retpc)
	sp		->	linkReg/innerRetpc	(PIC abort/miss retpc) */

	/* CogARMv8Compiler>>#genPushRegisterArgsForAbortMissNumArgs: */
static NoDbgRegParms AbstractInstruction *
genPushRegisterArgsForAbortMissNumArgs(AbstractInstruction *self_in_CogARMv8Compiler, sqInt numArgs)
{
    AbstractInstruction *anInstruction;

	if (numArgs <= (numRegArgs())) {
		assert((numRegArgs()) <= 2);

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, SPReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* begin MoveR:Mw:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 0, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		if (numArgs > 0) {
			/* PushR: */
			genoperand(PushR, Arg0Reg);
			if (numArgs > 1) {
				/* PushR: */
				genoperand(PushR, Arg1Reg);
			}
		}

		/* PushR: */
		genoperand(PushR, TempReg);
	}

	/* PushR: */
	genoperand(PushR, LinkReg);
	return self_in_CogARMv8Compiler;
}


/*	Ensure that the register args are pushed before the retpc for arity <=
	self numRegArgs.
 */
/*	This is easy on a RISC like ARM because the return address is in the link
	register. Putting
	the receiver and args above the return address means the CoInterpreter has
	a single
	machine-code frame format which saves us a lot of work
	NOTA BENE: we do NOT push the return address here, which means it must be
	dealt with later. */

	/* CogARMv8Compiler>>#genPushRegisterArgsForNumArgs:scratchReg: */
static NoDbgRegParms AbstractInstruction *
genPushRegisterArgsForNumArgsscratchReg(AbstractInstruction *self_in_CogARMv8Compiler, sqInt numArgs, sqInt ignored)
{
	if (numArgs <= (numRegArgs())) {
		assert((numRegArgs()) <= 2);

		/* PushR: */
		genoperand(PushR, ReceiverResultReg);
		if (numArgs > 0) {
			/* PushR: */
			genoperand(PushR, Arg0Reg);
			if (numArgs > 1) {
				/* PushR: */
				genoperand(PushR, Arg1Reg);
			}
		}
	}
	return self_in_CogARMv8Compiler;
}


/*	This is a no-op on ARM64 since the ABI passes up to 6 args in registers
	and trampolines currently observe that limit, using only 4.
 */

	/* CogARMv8Compiler>>#genRemoveNArgsFromStack: */
static NoDbgRegParms sqInt
genRemoveNArgsFromStack(AbstractInstruction *self_in_CogARMv8Compiler, sqInt n)
{
	assert(n <= 6);
	return 0;
}


/*	Restore the registers in regMask as saved by genSaveRegs:.
	See
	http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf
	N.B. Alignment is handled by
	genAlignCStackSavingRegisters:numArgs:wordAlignment:. 
 */

	/* CogARMv8Compiler>>#genRestoreRegs: */
static NoDbgRegParms sqInt
genRestoreRegs(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regMask)
{
    sqInt nRegs;
    int pair;
    sqInt reg;

	if (!regMask) {
		return 0;
	}
	assert(!((registerisInMask(RISCTempReg, regMask))));
	nRegs = 0;
	for (reg = R1; reg <= R17; reg += 1) {
		if (((regMask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))) != 0)) {
			nRegs += 1;
		}
	}
	pair = ((!(nRegs & 1))
				? NoReg
				: RISCTempReg);
	for (reg = R1; reg <= R17; reg += 1) {
		if (((regMask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))) != 0)) {
			if (pair == NoReg) {
				pair = reg;
			}
			else {
				genoperandoperand(NativePopRR, reg, pair);
				pair = NoReg;
			}
		}
	}
	assert(pair == NoReg);
	return 0;
}


/*	Save the registers in regMask for a call into the C run-time from a
	trampoline. See
	http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf
	N.B. Alignment is handled by
	genAlignCStackSavingRegisters:numArgs:wordAlignment:. 
 */

	/* CogARMv8Compiler>>#genSaveRegs: */
static NoDbgRegParms sqInt
genSaveRegs(AbstractInstruction *self_in_CogARMv8Compiler, sqInt regMask)
{
    sqInt pair;
    sqInt reg;

	if (!regMask) {
		return 0;
	}
	assert(!((registerisInMask(RISCTempReg, regMask))));
	pair = NoReg;
	for (reg = R17; reg >= R0; reg += -1) {
		if (((regMask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))) != 0)) {
			if (pair == NoReg) {
				pair = reg;
			}
			else {
				genoperandoperand(NativePushRR, pair, reg);
				pair = NoReg;
			}
		}
	}
	if (pair != NoReg) {
		genoperandoperand(NativePushRR, pair, RISCTempReg);
	}
	return 0;
}


/*	Save the frame and stack pointer registers to the framePointer
	and stackPointer variables. Used to save the machine code frame
	for use by the run-time when calling into the CoInterpreter run-time. */
/*	Save the frame and stack pointer registers to the framePointer
	and stackPointer variables. Used to save the machine code frame
	for use by the run-time when calling into the CoInterpreter run-time.
	Override to try and use MoveRRAw/stp */

	/* CogARMv8Compiler>>#genSaveStackPointers */
static NoDbgRegParms sqInt
genSaveStackPointers(AbstractInstruction *self_in_CogARMv8Compiler)
{
	if (((stackPointerAddress()) + 8) == (framePointerAddress())) {
		genoperandoperandoperand(MoveRRAw, SPReg, FPReg, stackPointerAddress());
		return 0;
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(framePointerAddress(), genoperandoperand(MoveRAw, FPReg, framePointerAddress()));

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveRAw, SPReg, stackPointerAddress()));
	return 0;
}

	/* CogARMv8Compiler>>#genSubstituteReturnAddress: */
static NoDbgRegParms AbstractInstruction *
genSubstituteReturnAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt retpc)
{
	return checkLiteralforInstruction(retpc, genoperandoperand(MoveCwR, retpc, LR));
}


/*	Answer if the processor has a dedicated callee-saved register to point to
	the base of commonly-accessed variables. On ARMv8 we use R27 for this. */

	/* CogARMv8Compiler>>#hasVarBaseRegister */
static NoDbgRegParms sqInt
hasVarBaseRegister(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 1;
}

	/* CogARMv8Compiler>>#inlineCacheTagAt: */
static NoDbgRegParms unsigned int
inlineCacheTagAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt callSiteReturnAddress)
{
    sqInt pc;

	pc = pcRelativeAddressAt(self_in_CogARMv8Compiler, ((usqInt)(callSiteReturnAddress - 8)));

	/* begin instructionAt: */
	return long32At(pc);
}


/*	Answer the instruction address immediately preceding mcpc. */

	/* CogARMv8Compiler>>#instructionAddressBefore: */
static NoDbgRegParms sqInt
instructionAddressBefore(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc)
{
	return mcpc - 4;
}

	/* CogARMv8Compiler>>#instructionAt: */
static NoDbgRegParms unsigned int
instructionAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc)
{
	return long32At(pc);
}


/*	C6.2.10 ADR	C6-773 */

	/* CogARMv8Compiler>>#instructionIsADR: */
static NoDbgRegParms int
instructionIsADR(AbstractInstruction *self_in_CogARMv8Compiler, sqInt word)
{
	return ((((usqInt)(word)) >> 24) & 159) == 16;
}


/*	C6.2.26 B		C6-799
	C6.2.33	BL		C6-812 */
/*	BL is 2r100101, B is 2r000101 */

	/* CogARMv8Compiler>>#instructionIsImm26BorBL: */
static NoDbgRegParms int
instructionIsImm26BorBL(AbstractInstruction *self_in_CogARMv8Compiler, usqInt word)
{
	return (((word) >> 26) & 0x1F) == 5;
}


/*	C4.1	A64 instruction set encoding on page C4-252 */

	/* CogARMv8Compiler>>#instructionIsLoadStore: */
static NoDbgRegParms int
instructionIsLoadStore(AbstractInstruction *self_in_CogARMv8Compiler, sqInt instr)
{
	return ((((usqInt)(instr)) >> 25) & 5) == 4;
}


/*	C6.2.131	LDR (literal)		C6-979
	C6.2.143	LDRSW (literal)	C6-1008 */

	/* CogARMv8Compiler>>#instructionIsPCRelativeLoad: */
static NoDbgRegParms int
instructionIsPCRelativeLoad(AbstractInstruction *self_in_CogARMv8Compiler, sqInt instr)
{
	return ((((usqInt)(instr)) >> 24) & 0x3F) == 24;
}


/*	Answer the instruction size at pc.Simple on ARM ;-) */

	/* CogARMv8Compiler>>#instructionSizeAt: */
static NoDbgRegParms sqInt
instructionSizeAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc)
{
	return 4;
}


/*	Several of the opcodes are inverses. Answer the inverse for an opcode if
	it has one.
	See Table A3-2 in sec A3.4 Data-processing instructions of the AARM. */

	/* CogARMv8Compiler>>#inverseForArithOp: */
static NoDbgRegParms int
inverseForArithOp(AbstractInstruction *self_in_CogARMv8Compiler, sqInt arithOp)
{
	switch (arithOp) {
	case ArithmeticAdd:
		return ArithmeticSub;

	case ArithmeticAddS:
		return ArithmeticSubS;

	case ArithmeticSub:
		return ArithmeticAdd;

	case ArithmeticSubS:
		return ArithmeticAddS;

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}


/*	Support for addressing variables off the dedicated VarBaseReg */

	/* CogARMv8Compiler>>#isAddressRelativeToVarBase: */
static NoDbgRegParms int
isAddressRelativeToVarBase(AbstractInstruction *self_in_CogARMv8Compiler, usqInt varAddress)
{
	return ((varAddress >= ((varBaseAddress) - (0x100))) && (varAddress <= (((varBaseAddress) + (0x1000)) - 1)));
}


/*	Assuming mcpc is a send return pc answer if the instruction before it is a
	call (not a CallFull).
 */
/*	There are two types of calls: BL & BLR; BLR is used for CallFull */

	/* CogARMv8Compiler>>#isCallPrecedingReturnPC: */
static NoDbgRegParms sqInt
isCallPrecedingReturnPC(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc)
{
    unsigned int instruction;

	instruction = long32At(mcpc - 4);
	return ((((usqInt)(instruction)) >> 26) == 37)
	 || ((instruction | (0x3E0)) == 3594453984U);
}

	/* CogARMv8Compiler>>#isFullJumpAtPC: */
static NoDbgRegParms int
isFullJumpAtPC(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc)
{
	return ((long32At(mcpc)) | (0x3E0)) == 3592356832U;
}


/*	ARM64 load/store immediate offsets have an 11 bit unsigned amd a 9 bit
	signed form.
 */

	/* CogARMv8Compiler>>#isImm12orImm9offset: */
static NoDbgRegParms sqInt
isImm12orImm9offset(AbstractInstruction *self_in_CogARMv8Compiler, sqInt offset)
{
	return (offset >= -256)
	 && (offset < 0x1000);
}


/*	ARM64 calls span +/- 128 mb.
	C6.2.33 BL		C6-812 */

	/* CogARMv8Compiler>>#isInImmediateBranchAndLinkRange: */
static NoDbgRegParms int
isInImmediateBranchAndLinkRange(AbstractInstruction *self_in_CogARMv8Compiler, sqIntptr_t offset)
{
	assert((!(offset & 3)));
	return (((((((sqLong) offset))) >> 27) >= -1) && ((((((sqLong) offset))) >> 27) <= 0));
}


/*	ARM64 calls and jumps span +/- 1 mb. */

	/* CogARMv8Compiler>>#isInImmediateBranchRange: */
static NoDbgRegParms int
isInImmediateBranchRange(AbstractInstruction *self_in_CogARMv8Compiler, usqIntptr_t offset)
{
	assert((!(offset & 3)));
	return (((((((sqLong) offset))) >> 18) >= -1) && ((((((sqLong) offset))) >> 18) <= 0));
}


/*	ARMv8 calls and jumps span +/- 128 mb, more than enough for intra-zone
	calls and jumps.
 */

	/* CogARMv8Compiler>>#isInImmediateJumpRange: */
static NoDbgRegParms int
isInImmediateJumpRange(AbstractInstruction *self_in_CogARMv8Compiler, usqIntptr_t operand)
{
	assert((!(operand & 3)));
	return (((((int) operand)) >= ((-0x7FFFFFFF-1))) && ((((int) operand)) <= (0x7FFFFFF)));
}


/*	ARM64 load/store immediates have an 11 bit unsigned amd a 9 bit signed
	form. 
 */

	/* CogARMv8Compiler>>#isInImmediateOffsetRange: */
static NoDbgRegParms sqInt
isInImmediateOffsetRange(AbstractInstruction *self_in_CogARMv8Compiler, sqInt offset)
{
	return (offset >= -256)
	 && (offset < 0x1000);
}

	/* CogARMv8Compiler>>#isJump */
static NoDbgRegParms sqInt
isJump(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return (((((self_in_CogARMv8Compiler->opcode)) >= FirstJump) && (((self_in_CogARMv8Compiler->opcode)) <= LastJump)))
	 || (((((self_in_CogARMv8Compiler->opcode)) >= CBNZ) && (((self_in_CogARMv8Compiler->opcode)) <= CBZ)));
}


/*	C4.1	A64 instruction set encoding on page C4-252
	C4.1.3 Branches, Exception Generating and System instructions */
/*	cogit processor disassembleInstructionAt: pc In: objectMemory memory */

	/* CogARMv8Compiler>>#isJumpAt: */
static NoDbgRegParms sqInt
isJumpAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc)
{
    sqInt op0_101_op1MSB;

	op0_101_op1MSB = (((usqInt)((long32At(pc)))) >> 25);
	return (op0_101_op1MSB == 42)
	 || ((op0_101_op1MSB == 107)
	 || (((op0_101_op1MSB & 0x7E) == 74)
	 || ((op0_101_op1MSB & 0x7E) == 10)));
}


/*	Answer if the receiver is a pc-dependent instruction. With out-of-line
	literals any instruction
	that refers to a literal depends on the address of the literal, so add
	them in addition to the jumps. */

	/* CogARMv8Compiler>>#isPCDependent */
static NoDbgRegParms sqInt
isPCDependent(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return (isJump(self_in_CogARMv8Compiler))
	 || ((((self_in_CogARMv8Compiler->opcode)) == AlignmentNops)
	 || ((((self_in_CogARMv8Compiler->opcode)) != Literal)
	 && ((((self_in_CogARMv8Compiler->dependent)))
	 && (((((self_in_CogARMv8Compiler->dependent))->opcode)) == Literal))));
}

	/* CogARMv8Compiler>>#isShiftedMask: */
static NoDbgRegParms sqInt
isShiftedMask(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger)
{
    sqInt bits;

	return (anInteger != 0)
	 && (((bits = (anInteger - 1) | anInteger),
	(bits & (bits + 1)) == 0));
}

	/* CogARMv8Compiler>>#isUnsigned12BitMultipleOf8: */
static NoDbgRegParms sqInt
isUnsigned12BitMultipleOf8(AbstractInstruction *self_in_CogARMv8Compiler, sqInt anInteger)
{
	return ((anInteger % 8) == 0)
	 && ((((anInteger / 8) >= 0) && ((anInteger / 8) <= (0xFFF))));
}


/*	Branch/Call ranges. Jump[Cond] can be generated as short as possible.
	Call/Jump[Cond]Long must be generated
	in the same number of bytes irrespective of displacement since their
	targets may be updated, but they need only
	span 16Mb, the maximum size of the code zone. This allows e.g. ARM to use
	single-word call and jump instructions
	for most calls and jumps. CallFull/JumpFull must also be generated in the
	same number of bytes irrespective of
	displacement for the same reason, but they must be able to span the full
	(32-bit or 64-bit) address space because
	they are used to call code in the C runtime, which may be distant from the
	code zone
 */

	/* CogARMv8Compiler>>#jumpLongByteSize */
static NoDbgRegParms sqInt
jumpLongByteSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 4;
}

	/* CogARMv8Compiler>>#jumpLongConditionalByteSize */
static NoDbgRegParms sqInt
jumpLongConditionalByteSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 8;
}


/*	C6.2.26 B		C6-799 */

	/* CogARMv8Compiler>>#jumpLongTargetBeforeFollowingAddress: */
static NoDbgRegParms sqInt
jumpLongTargetBeforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc)
{
	return callTargetFromReturnAddress(self_in_CogARMv8Compiler, mcpc);
}


/*	cogit processor disassembleInstructionAt: pc In: objectMemory memory */

	/* CogARMv8Compiler>>#jumpTargetPCAt: */
static NoDbgRegParms usqInt
jumpTargetPCAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc)
{
    usqInt operand;
    unsigned int word;

	word = long32At(pc);
	assert((((usqInt)(word)) >> 26) == 21);
	operand = (((usqInt)(word)) >> 5) & 0x7FFFF;
	if (((operand & 0x40000) != 0)) {
		operand -= 0x80000;
	}
	return (operand * 4) + pc;
}


/*	Answer the 32-bit constant loaded by the instruction sequence just before
	this address:
	CmpC32R MoveC32R */

	/* CogARMv8Compiler>>#literal32BeforeFollowingAddress: */
static NoDbgRegParms unsigned int
literal32BeforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt followingAddress)
{
    sqInt pc;

	pc = pcRelativeAddressAt(self_in_CogARMv8Compiler, instructionAddressBefore(self_in_CogARMv8Compiler, (instructionIsPCRelativeLoad(self_in_CogARMv8Compiler, long32At(followingAddress - 4))
				? followingAddress
				: followingAddress - 4)));

	/* begin instructionAt: */
	return long32At(pc);
}


/*	Answer the literal referenced by the instruction immediately preceding
	followingAddress. ArithCwR MoveCwR PushCw */

	/* CogARMv8Compiler>>#literalBeforeFollowingAddress: */
static NoDbgRegParms sqInt
literalBeforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt followingAddress)
{
	return longAt(pcRelativeAddressAt(self_in_CogARMv8Compiler, instructionAddressBefore(self_in_CogARMv8Compiler, (instructionIsPCRelativeLoad(self_in_CogARMv8Compiler, long32At(followingAddress - 4))
			? followingAddress
			: followingAddress - 4))));
}


/*	Answer the size of a literal load instruction (which does not include the
	size of the literal).
	With out-of-line literals this is always a single LDR instruction that
	refers to the literal.
 */

	/* CogARMv8Compiler>>#literalLoadInstructionBytes */
static NoDbgRegParms sqInt
literalLoadInstructionBytes(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 4;
}


/*	Answer the byte size of a MoveCwR opcode's corresponding machine code.
	On ARMv8 this is a single instruction pc-relative register load */

	/* CogARMv8Compiler>>#loadLiteralByteSize */
static NoDbgRegParms sqInt
loadLiteralByteSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 4;
}


/*	Answer the byte size of a MoveCwR opcode's corresponding machine code
	when the argument is a PIC. This is for the self-reference at the end of a
	closed PIC. On ARM this is a single instruction pc-relative register load. */

	/* CogARMv8Compiler>>#loadPICLiteralByteSize */
static NoDbgRegParms sqInt
loadPICLiteralByteSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 4;
}


/*	Answer the maximum number of bytes of machine code generated for any
	abstract instruction.
	Likely to be quite different for AARCH64
 */

	/* CogARMv8Compiler>>#machineCodeBytes */
static NoDbgRegParms sqInt
machineCodeBytes(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 12;
}


/*	Answer the maximum number of words of machine code generated for any
	abstract instruction.
	Likely to be quite different for AARCH64
 */

	/* CogARMv8Compiler>>#machineCodeWords */
static NoDbgRegParms sqInt
machineCodeWords(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return (machineCodeBytes(self_in_CogARMv8Compiler)) / 4;
}

	/* CogARMv8Compiler>>#movern:rd: */
static NoDbgRegParms sqInt
movernrd(AbstractInstruction *self_in_CogARMv8Compiler, sqInt srcReg, sqInt destReg)
{
	return addrnrdimmshiftBy12(self_in_CogARMv8Compiler, srcReg, destReg, 0, 0);
}


/*	Morph an Overflow/NoOverflow check after a MulOverflow into an efficient
	test for overflow, hence avoiding having to set and test the V flag.
	MulOverflowRRR generates
	mul		Rd,Rm,Rn
	smulh RISCTempReg,Rm,Rn
	cmp	RISCTempReg, #0x1
	so it must be followed by an unsigned conditional jump, Above for
	Overflow, BelowOrEqual for NoOverflow. */

	/* CogARMv8Compiler>>#noteFollowingConditionalBranch: */
static NoDbgRegParms AbstractInstruction *
noteFollowingConditionalBranch(AbstractInstruction *self_in_CogARMv8Compiler, AbstractInstruction *branch)
{
	if ((((self_in_CogARMv8Compiler->opcode)) == MulOverflowRRR)
	 && ((((branch->opcode)) == JumpOverflow)
	 || (((branch->opcode)) == JumpNoOverflow))) {
		(branch->opcode = (((branch->opcode)) == JumpOverflow
				? JumpMulOverflow
				: JumpNoMulOverflow));
	}
	return branch;
}

	/* CogARMv8Compiler>>#numDCacheFlushOpcodes */
static NoDbgRegParms sqInt
numDCacheFlushOpcodes(AbstractInstruction *self_in_CogARMv8Compiler)
{

#  if DUAL_MAPPED_CODE_ZONE
	return (getCodeToDataDelta()
			? 15
			: 0);
#  else
	return 0;
#  endif
}


/*	Apple's code is simple and works; we can't better it... */

	/* CogARMv8Compiler>>#numICacheFlushOpcodes */
static NoDbgRegParms sqInt
numICacheFlushOpcodes(AbstractInstruction *self_in_CogARMv8Compiler)
{

#  if __APPLE__
	return 0;
#  else
	return 24;
#  endif
}


/*	See e.g.
	http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf
	Table 3-1 Register Usage in AArch64 SMC32, HVC32, SMC64, and HVC64 calls */

	/* CogARMv8Compiler>>#numIntRegArgs */
static NoDbgRegParms sqInt
numIntRegArgs(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 6;
}


/*	The maximum offset in a LDR (literal) is -2^18 to 2^18-1.
	And this is multiplied by 4 to produce the effective address.
	This is a huge range; we have no grounds for concern. */

	/* CogARMv8Compiler>>#outOfLineLiteralOpcodeLimit */
static NoDbgRegParms sqInt
outOfLineLiteralOpcodeLimit(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 0x3FFFF;
}

	/* CogARMv8Compiler>>#padIfPossibleWithStopsFrom:to: */
static NoDbgRegParms AbstractInstruction *
padIfPossibleWithStopsFromto(AbstractInstruction *self_in_CogARMv8Compiler, sqInt startAddr, sqInt endAddr)
{
    sqInt nullBytes;
    sqInt p;

	nullBytes = ((endAddr - startAddr) + 1) % 4;
	stopsFromto(self_in_CogARMv8Compiler, startAddr, endAddr - nullBytes);
	for (p = ((endAddr - nullBytes) + 1); p <= endAddr; p += 1) {
		codeByteAtput(p, 0xFF);
	}
	return self_in_CogARMv8Compiler;
}


/*	Extract the address of the adr rX, offset instruction at address mcpc
	C6.2.131	LDR (literal)		C6-979 */

	/* CogARMv8Compiler>>#pcRelativeAddressAt: */
static NoDbgRegParms sqInt
pcRelativeAddressAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt mcpc)
{
    unsigned int instr;

	/* cogit processor disassembleInstructionAt: mcpc In: objectMemory memory */
	instr = long32At(mcpc);
	assert(instructionIsPCRelativeLoad(self_in_CogARMv8Compiler, instr));
	return (((((usqInt)(instr)) >> 3) & (0x3FFFFC)) - ((((usqInt)(instr)) >> 2) & (0x200000))) + mcpc;
}


/*	C6.2.211	PRFM (immediate)	C6-1136 */
/*	Unsigned offset, C6-1136 */
/*	This is the only case we can make use of so far... */

	/* CogARMv8Compiler>>#prn:imm:shiftBy12: */
static NoDbgRegParms sqInt
prnimmshiftBy12(AbstractInstruction *self_in_CogARMv8Compiler, sqInt baseReg, sqInt offset, sqInt shiftBy12)
{
	assert(((offset % 8) == 0)
	 && ((((offset / 8) >= 0) && ((offset / 8) <= (0xFFF)))));
	return (((0xF9800000U) + ((((usqInt)(offset) << 7)))) + ((((usqInt)(baseReg) << 5))));
}

	/* CogARMv8Compiler>>#pushLinkRegisterByteSize */
static NoDbgRegParms sqInt
pushLinkRegisterByteSize(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 4;
}


/*	C6.2.26 B		C6-799
	C6.2.33	BL		C6-812 */

	/* CogARMv8Compiler>>#relocateCallBeforeReturnPC:by: */
static NoDbgRegParms AbstractInstruction *
relocateCallBeforeReturnPCby(AbstractInstruction *self_in_CogARMv8Compiler, sqInt retpc, sqInt delta)
{
    sqInt distanceDiv4;
    unsigned int instr;

	assert((delta % 4) == 0);
	if (delta) {
		instr = long32At(retpc - 4);
		assert(instructionIsImm26BorBL(self_in_CogARMv8Compiler, instr));
		distanceDiv4 = instr & (0x7FFFFFF);
		distanceDiv4 += delta / 4;
		codeLong32Atput(retpc - 4, (instr & 0xFC000000U) | (distanceDiv4 & 0x3FFFFFF));
	}
	return self_in_CogARMv8Compiler;
}


/*	We generate the method address using pc-relative addressing.
	Simply check that pc-relative addressing is being used. c.f.
	emitMoveCw:intoR:at: */

	/* CogARMv8Compiler>>#relocateMethodReferenceBeforeAddress:by: */
static NoDbgRegParms AbstractInstruction *
relocateMethodReferenceBeforeAddressby(AbstractInstruction *self_in_CogARMv8Compiler, sqInt pc, sqInt delta)
{
	assert((instructionIsADR(self_in_CogARMv8Compiler, instructionAt(self_in_CogARMv8Compiler, pc - 4)))
	 || (instructionIsADR(self_in_CogARMv8Compiler, instructionAt(self_in_CogARMv8Compiler, pc - 8))));
	return self_in_CogARMv8Compiler;
}


/*	Rewrite a call instruction to call a different target. This variant is
	used to link PICs
	in ceSendMiss et al, and to rewrite cached primitive calls. Answer the
	extent of
	the code change which is used to compute the range of the icache to flush. */

	/* CogARMv8Compiler>>#rewriteCallAt:target: */
static NoDbgRegParms sqInt
rewriteCallAttarget(AbstractInstruction *self_in_CogARMv8Compiler, usqInt callSiteReturnAddress, usqInt callTargetAddress)
{
	codeLong32Atput(
		callSiteReturnAddress - 4,
		(/* begin bl: */
			assert((!((callTargetAddress - (callSiteReturnAddress - 4)) & 3))),
		(0x94000000U) + ((((callTargetAddress - (callSiteReturnAddress - 4))) >> 2) & (0x3FFFFFF))));
	return 4;
}


/*	Rewrite a long jump/call instruction to jump/call to a different target.
	Answer the extent of the code change which is used to compute the range of
	the icache to flush.
	C6.2.25	B.cond		C6-798 */
/*	cogit processor disassembleInstructionAt: followingAddress - 4 In:
	objectMemory memory
 */

	/* CogARMv8Compiler>>#rewriteImm19JumpBefore:target: */
static NoDbgRegParms sqInt
rewriteImm19JumpBeforetarget(AbstractInstruction *self_in_CogARMv8Compiler, sqInt followingAddress, sqInt targetAddress)
{
    sqInt instrOpcode;
    unsigned int instruction;
    sqInt mcpc;
    sqInt offset;

	mcpc = followingAddress - 4;
	offset = targetAddress - mcpc;
	instruction = long32At(followingAddress - 4);
	instrOpcode = ((usqInt)(instruction)) >> 26;
	assert(instrOpcode == 21);
	codeLong32Atput(mcpc, (((((usqInt)(instrOpcode) << 26))) + ((((usqInt)((((offset) >> 2) & (0x7FFFF))) << 5)))) + (instruction & 15));
	return 4;
}


/*	Rewrite a long jump/call instruction to jump/call to a different target.
	Answer the extent of the code change which is used to compute the range of
	the icache to flush.
	C6.2.26	B	C6-799
	C6.2.33 BL	C6-812 */
/*	cogit processor disassembleInstructionAt: followingAddress - 4 In:
	objectMemory memory
 */

	/* CogARMv8Compiler>>#rewriteImm26JumpBefore:target: */
static NoDbgRegParms sqInt
rewriteImm26JumpBeforetarget(AbstractInstruction *self_in_CogARMv8Compiler, sqInt followingAddress, sqInt targetAddress)
{
    sqInt instrOpcode;
    sqInt mcpc;
    sqInt offset;

	mcpc = followingAddress - 4;
	offset = targetAddress - mcpc;
	instrOpcode = ((usqInt)((long32At(followingAddress - 4)))) >> 26;
	assert((instrOpcode == 5)
	 || (instrOpcode == 37));
	codeLong32Atput(mcpc, ((((usqInt)(instrOpcode) << 26))) + (((offset) >> 2) & (0x3FFFFFF)));
	return 4;
}


/*	Rewrite an inline cache to call a different target for a new tag. This
	variant is used
	to link unlinked sends in ceSend:to:numArgs: et al. Answer the extent of
	the code
	change which is used to compute the range of the icache to flush.
	N.B. On 64-bit platforms the inline cache tag is only 32-bits wide, hence
	this code
	is very similar to that for ARM32 CogOutOfLineLiteralsARMCompiler. */

	/* CogARMv8Compiler>>#rewriteInlineCacheAt:tag:target: */
static NoDbgRegParms sqInt
rewriteInlineCacheAttagtarget(AbstractInstruction *self_in_CogARMv8Compiler, usqInt callSiteReturnAddress, sqInt cacheTag, usqInt callTargetAddress)
{
    sqInt call;
    usqInt callDistance;

	/* return offset */
	callDistance = ((usqInt) (int)(callTargetAddress - (callSiteReturnAddress - 4)));
	assert(isInImmediateJumpRange(self_in_CogARMv8Compiler, callDistance));

	/* begin bl: */
	assert((!(callDistance & 3)));
	call = (0x94000000U) + ((((sqInt)(callDistance)) >> 2) & (0x3FFFFFF));
	codeLong32Atput(callSiteReturnAddress - 4, call);
	codeLong32Atput(pcRelativeAddressAt(self_in_CogARMv8Compiler, callSiteReturnAddress - 8), ((usqInt) (int)cacheTag));
	assert((((int) (inlineCacheTagAt(self_in_CogARMv8Compiler, callSiteReturnAddress)))) == cacheTag);
	return 4;
}


/*	Rewrite an inline cache with a new tag. This variant is used
	by the garbage collector. RThis cannot happen in 64-bits as cache tags are
	guaranteed to be 32-bits or less. */

	/* CogARMv8Compiler>>#rewriteInlineCacheTag:at: */
static NoDbgRegParms AbstractInstruction *
rewriteInlineCacheTagat(AbstractInstruction *self_in_CogARMv8Compiler, sqInt cacheTag, sqInt callSiteReturnAddress)
{
	error("should not happen");
	return self_in_CogARMv8Compiler;
}


/*	Rewrite a JumpFull instruction to jump to a different target. This variant
	is used to rewrite cached primitive calls.
	Answer the extent of the code change which is used to compute the range of
	the icache to flush. */
/*	cogit processor disassembleInstructionAt: callSiteReturnAddress - 8 In:
	objectMemory memory
 */
/*	cogit processor disassembleInstructionAt: callSiteReturnAddress - 4 In:
	objectMemory memory
 */

	/* CogARMv8Compiler>>#rewriteJumpFullAt:target: */
static NoDbgRegParms sqInt
rewriteJumpFullAttarget(AbstractInstruction *self_in_CogARMv8Compiler, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	codeLongAtput(pcRelativeAddressAt(self_in_CogARMv8Compiler, callSiteReturnAddress - 8), callTargetAddress);
	return 0;
}


/*	Set the size field. The only complication is that in Smalltalk (operands
	at: 1) may be nil. */

	/* CogARMv8Compiler>>#setLiteralSize: */
static NoDbgRegParms AbstractInstruction *
setLiteralSize(AbstractInstruction *self_in_CogARMv8Compiler, sqInt sizeOfLiteral)
{
    usqInt operand;

	((self_in_CogARMv8Compiler->operands))[1] = ((((operand = ((self_in_CogARMv8Compiler->operands))[1]),
(operand
			? ((operand | 30) - 30)
			: 0))) + ((((usqInt)(sizeOfLiteral) << 1))));
	return self_in_CogARMv8Compiler;
}


/*	to save Slang from having to be a real compiler (it can't inline switches
	that return)
 */
/*	Answer if the receiver's opcode sets the condition codes correctly for the
	given conditional jump opcode.
	ARMv8 appears not to set condition codes at all in its shift
	instruction(s), which are aliases for
	SBFM (signed bit field move) and C6.2.332 UBFM.
	
	C6.2.232	SBFM	C6-1170
	C6.2.332	UBFM	C6-1351 */

	/* CogARMv8Compiler>>#setsConditionCodesFor: */
static NoDbgRegParms sqInt
setsConditionCodesFor(AbstractInstruction *self_in_CogARMv8Compiler, sqInt aConditionalJumpOpcode)
{
	return 0;
}


/*	Size a jump and set its address. The target may be another instruction
	or an absolute address. On entry the address inst var holds our virtual
	address. On exit address is set to eventualAbsoluteAddress, which is
	where this instruction will be output. The span of a jump to a following
	instruction is therefore between that instruction's address and this
	instruction's address ((which are both still their virtual addresses), but
	the span of a jump to a preceding instruction or to an absolute address is
	between that instruction's address (which by now is its eventual absolute
	address) or absolute address and eventualAbsoluteAddress.
	
	ARMv8 is simple; the 26-bit call/jump range (for a signed 28 bit extent,
	+/- 128Mb) and
	19 bit conditional branch range (for a signed 21 bit extent, +/- 1Mb)
	means no short
	jumps. This routine only has to determine the targets of jumps, not
	determine sizes.
	
	This version also deals with out-of-line literals. If this is the real
	literal, update the stand-in in literalsManager with the address (because
	instructions referring to the literal are referring to the stand-in). If
	this is annotated with
	IsObjectReference transfer the annotation to the stand-in, whence it will
	be transferred to the real literal, simplifying update of literals. */

	/* CogARMv8Compiler>>#sizePCDependentInstructionAt: */
static NoDbgRegParms unsigned char
sizePCDependentInstructionAt(AbstractInstruction *self_in_CogARMv8Compiler, sqInt eventualAbsoluteAddress)
{
    usqInt alignment;

	if (((self_in_CogARMv8Compiler->opcode)) == AlignmentNops) {
		(self_in_CogARMv8Compiler->address) = eventualAbsoluteAddress;
		alignment = ((self_in_CogARMv8Compiler->operands))[0];
		return ((self_in_CogARMv8Compiler->machineCodeSize) = ((eventualAbsoluteAddress + (alignment - 1)) & (-alignment)) - eventualAbsoluteAddress);
	}
	assert((isJump(self_in_CogARMv8Compiler))
	 || ((((self_in_CogARMv8Compiler->opcode)) == Call)
	 || ((((self_in_CogARMv8Compiler->opcode)) == CallFull)
	 || ((((self_in_CogARMv8Compiler->dependent)))
	 && (((((self_in_CogARMv8Compiler->dependent))->opcode)) == Literal)))));
	if (isJump(self_in_CogARMv8Compiler)) {
		resolveJumpTarget(self_in_CogARMv8Compiler);
	}
	(self_in_CogARMv8Compiler->address) = eventualAbsoluteAddress;
	if ((((self_in_CogARMv8Compiler->dependent)))
	 && (((((self_in_CogARMv8Compiler->dependent))->opcode)) == Literal)) {
		if (((self_in_CogARMv8Compiler->opcode)) == Literal) {
			(((self_in_CogARMv8Compiler->dependent))->address = (self_in_CogARMv8Compiler->address));
		}
		if (((self_in_CogARMv8Compiler->annotation)) == (getIsObjectReference())) {
			(((self_in_CogARMv8Compiler->dependent))->annotation = (self_in_CogARMv8Compiler->annotation));
			(self_in_CogARMv8Compiler->annotation) = null;
		}
	}
	return ((self_in_CogARMv8Compiler->machineCodeSize) = (self_in_CogARMv8Compiler->maxSize));
}

	/* CogARMv8Compiler>>#stopsFrom:to: */
static NoDbgRegParms AbstractInstruction *
stopsFromto(AbstractInstruction *self_in_CogARMv8Compiler, sqInt startAddr, sqInt endAddr)
{
    sqInt addr;

	assert((((endAddr - startAddr) + 1) % 4) == 0);
	for (addr = startAddr; addr <= endAddr; addr += 4) {
		codeLong32Atput(addr, 0xD4400000U /* stop */);
	}
	return self_in_CogARMv8Compiler;
}


/*	Rewrite the 32-bit literal in the instruction immediately preceding
	followingAddress. 
 */

	/* CogARMv8Compiler>>#storeLiteral32:beforeFollowingAddress: */
static NoDbgRegParms AbstractInstruction *
storeLiteral32beforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt literal, sqInt followingAddress)
{
	codeLong32Atput(pcRelativeAddressAt(self_in_CogARMv8Compiler, instructionAddressBefore(self_in_CogARMv8Compiler, (instructionIsPCRelativeLoad(self_in_CogARMv8Compiler, long32At(followingAddress - 4))
			? followingAddress
			: followingAddress - 4))), literal);
	return self_in_CogARMv8Compiler;
}


/*	Rewrite the literal in the instruction immediately preceding
	followingAddress. 
 */

	/* CogARMv8Compiler>>#storeLiteral:beforeFollowingAddress: */
static NoDbgRegParms AbstractInstruction *
storeLiteralbeforeFollowingAddress(AbstractInstruction *self_in_CogARMv8Compiler, sqInt literal, sqInt followingAddress)
{
	codeLongAtput(pcRelativeAddressAt(self_in_CogARMv8Compiler, instructionAddressBefore(self_in_CogARMv8Compiler, (instructionIsPCRelativeLoad(self_in_CogARMv8Compiler, long32At(followingAddress - 4))
			? followingAddress
			: followingAddress - 4))), literal);
	return self_in_CogARMv8Compiler;
}


/*	C6.2.273	STR (immediate)	C6-1239
	C6.2.275	STRB (immediate)	C6-1244 */

	/* CogARMv8Compiler>>#st:rn:rt:imm:shiftBy12: */
static NoDbgRegParms sqInt
strnrtimmshiftBy12(AbstractInstruction *self_in_CogARMv8Compiler, sqInt unitSizeLog2MinusOne, sqInt baseReg, sqInt targetReg, sqInt offset, sqInt shiftBy12)
{
    sqInt unitSize;

	unitSize = 1ULL << unitSizeLog2MinusOne;
	assert(!((SP == targetReg)));
	assert(!((baseReg == targetReg)));
	if (((offset % unitSize) == 0)
	 && ((((offset / unitSize) >= 0) && ((offset / unitSize) <= (0xFFF))))) {
		return (((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x39000000)) + ((((usqInt)(offset) << (10 - unitSizeLog2MinusOne))))) + ((((usqInt)(baseReg) << 5)))) + targetReg;
	}
	if (!(asserta(((offset >= -256) && (offset <= 0xFF))))) {
		error("unhandled immediate offset in store");
	}
	return (((((((usqInt)(unitSizeLog2MinusOne) << 30))) + (0x38000000)) + (((offset & 0x1FF) << 12))) + ((((usqInt)(baseReg) << 5)))) + targetReg;
}


/*	Answer if the receiver uses an out-of-line literal. Needs only
	to work for the opcodes created with gen:literal:operand: et al. */

	/* CogARMv8Compiler>>#usesOutOfLineLiteral */
static NoDbgRegParms sqInt
usesOutOfLineLiteral(AbstractInstruction *self_in_CogARMv8Compiler)
{
    sqInt constant;
    sqInt imm;
    sqInt immediate;
    sqInt immrSqInt;
    usqInt mask;
    usqInt nImms;
    usqInt nUsqInt;
    sqInt numLeadingOnes;
    sqInt numTrailingOnes;
    sqInt rotateCount;
    sqInt size;

	switch ((self_in_CogARMv8Compiler->opcode)) {
	case CallFull:
	case JumpFull:
	case AddCwR:
	case AndCwR:
	case CmpCwR:
	case CmpC32R:
	case OrCwR:
	case SubCwR:
	case XorCwR:
	case MoveC32R:
		return 1;

	case AddCqR:
	case AddCqRR:
	case SubCqR:
	case CmpCqR:
		immediate = ((sqLong) (((self_in_CogARMv8Compiler->operands))[0]));

		/* begin isPossiblyShiftableNegatableImm12:ifTrue:ifFalse: */
		if (((immediate >= (-4096)) && (immediate <= (0xFFF)))) {
			return 0;
		}
		if (((!(immediate & (0xFFF))))
		 && (((((immediate) >> 12) >= (-4096)) && (((immediate) >> 12) <= (0xFFF))))) {
			return 0;
		}
		return 1;

	case LoadEffectiveAddressMwrR:
		immediate = ((sqLong) (((self_in_CogARMv8Compiler->operands))[0]));

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if (((immediate >= 0) && (immediate <= (0xFFF)))) {
			return 0;
		}
		if (((!(immediate & (0xFFF))))
		 && (((((immediate) >> 12) >= 0) && (((immediate) >> 12) <= (0xFFF))))) {
			return 0;
		}
		return 1;

	case AndCqR:
	case AndCqRR:
	case OrCqRR:
	case OrCqR:
	case TstCqR:
	case XorCqR:
		constant = ((self_in_CogARMv8Compiler->operands))[0];

		/* begin isImmNImmSImmREncodableBitmask:ifTrue:ifFalse: */
		if (((constant >= -1) && (constant <= 0))) {
			return 1;
		}

		/* First, determine the element size. */
		imm = constant;
		size = 32;
		while (1) {
			mask = (1ULL << size) - 1;
			if (!(((imm & mask) != ((((usqInt)(imm)) >> size) & mask)
					? ((size = size * 2),
					0)
					: size > 2))) break;
			size = size / 2;
		}
		mask = ((usqInt)((0xFFFFFFFFFFFFFFFFULL))) >> (64 - size);
		imm = imm & mask;
		if (isShiftedMask(self_in_CogARMv8Compiler, imm)) {
			rotateCount = countTrailingZeros(self_in_CogARMv8Compiler, imm);
			numTrailingOnes = countTrailingOnes(self_in_CogARMv8Compiler, ((usqInt)(imm)) >> rotateCount);
		}
		else {
			imm = imm | (~(usqIntptr_t)mask);
			if (!(isShiftedMask(self_in_CogARMv8Compiler, imm))) {
				return 1;
			}
			numLeadingOnes = countLeadingOnes(self_in_CogARMv8Compiler, imm);
			rotateCount = 64 - numLeadingOnes;
			numTrailingOnes = (numLeadingOnes + (countTrailingOnes(self_in_CogARMv8Compiler, imm))) - (64 - size);
		}
		assert(size > rotateCount);

		/* If size has a 1 in the n'th bit, create a value that has zeroes in bits [0, n] and ones above that. */
		immrSqInt = (size - rotateCount) & (size - 1);

		/* Or the CTO value into the low bits, which must be below the Nth bit mentioned above. */
		nImms = ((sqInt)((usqInt)((~(usqIntptr_t)(size - 1))) << 1));

		/* Extract the seventh bit and toggle it to create the N field. */
		nImms = nImms | (numTrailingOnes - 1);
		nUsqInt = (((nImms) >> 6) & 1) ^ 1;
		nImms = nImms & 0x3F;
		assert((decodeNimmsimmr(self_in_CogARMv8Compiler, nUsqInt, nImms, immrSqInt)) == (((usqInt) constant)));
		return 0;

	case MoveCqR:
		immediate = ((self_in_CogARMv8Compiler->operands))[0];

		/* begin isPossiblyShiftableImm12:ifTrue:ifFalse: */
		if (((immediate >= 0) && (immediate <= (0xFFF)))) {
			return 0;
			goto l1;
		}
		if (((!(immediate & (0xFFF))))
		 && (((((immediate) >> 12) >= 0) && (((immediate) >> 12) <= (0xFFF))))) {
			return 0;
			goto l1;
		}
l1:	/* end isPossiblyShiftableImm12:ifTrue:ifFalse: */;
		constant = ((self_in_CogARMv8Compiler->operands))[0];

		/* begin isImmNImmSImmREncodableBitmask:ifTrue:ifFalse: */
		if (((constant >= -1) && (constant <= 0))) {
			return 1;
		}

		/* First, determine the element size. */
		imm = constant;
		size = 32;
		while (1) {
			mask = (1ULL << size) - 1;
			if (!(((imm & mask) != ((((usqInt)(imm)) >> size) & mask)
					? ((size = size * 2),
					0)
					: size > 2))) break;
			size = size / 2;
		}
		mask = ((usqInt)((0xFFFFFFFFFFFFFFFFULL))) >> (64 - size);
		imm = imm & mask;
		if (isShiftedMask(self_in_CogARMv8Compiler, imm)) {
			rotateCount = countTrailingZeros(self_in_CogARMv8Compiler, imm);
			numTrailingOnes = countTrailingOnes(self_in_CogARMv8Compiler, ((usqInt)(imm)) >> rotateCount);
		}
		else {
			imm = imm | (~(usqIntptr_t)mask);
			if (!(isShiftedMask(self_in_CogARMv8Compiler, imm))) {
				return 1;
			}
			numLeadingOnes = countLeadingOnes(self_in_CogARMv8Compiler, imm);
			rotateCount = 64 - numLeadingOnes;
			numTrailingOnes = (numLeadingOnes + (countTrailingOnes(self_in_CogARMv8Compiler, imm))) - (64 - size);
		}
		assert(size > rotateCount);

		/* If size has a 1 in the n'th bit, create a value that has zeroes in bits [0, n] and ones above that. */
		immrSqInt = (size - rotateCount) & (size - 1);

		/* Or the CTO value into the low bits, which must be below the Nth bit mentioned above. */
		nImms = ((sqInt)((usqInt)((~(usqIntptr_t)(size - 1))) << 1));

		/* Extract the seventh bit and toggle it to create the N field. */
		nImms = nImms | (numTrailingOnes - 1);
		nUsqInt = (((nImms) >> 6) & 1) ^ 1;
		nImms = nImms & 0x3F;
		assert((decodeNimmsimmr(self_in_CogARMv8Compiler, nUsqInt, nImms, immrSqInt)) == (((usqInt) constant)));
		return 0;

	case MoveCwR:
	case PushCw:
		return !(/* inCurrentCompilation: */
			(/* isAnInstruction: */
			(addressIsInInstructions(((AbstractInstruction *) (((self_in_CogARMv8Compiler->operands))[0]))))
		 || ((((AbstractInstruction *) (((self_in_CogARMv8Compiler->operands))[0]))) == (methodLabel)))
		 || (/* addressIsInCurrentCompilation: */
			((((usqInt)(((self_in_CogARMv8Compiler->operands))[0]))) >= ((methodLabel->address)))
		 && ((((usqInt)(((self_in_CogARMv8Compiler->operands))[0]))) < ((((youngReferrers) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers) : (((methodLabel->address)) + MaxMethodSize))))));

	case MoveAwR:
	case MoveAbR:
	case PrefetchAw:
		return !((((((self_in_CogARMv8Compiler->operands))[0]) >= ((varBaseAddress) - (0x100))) && ((((self_in_CogARMv8Compiler->operands))[0]) <= (((varBaseAddress) + (0x1000)) - 1))));

	case MoveRAw:
	case MoveRAb:
		return !((((((self_in_CogARMv8Compiler->operands))[1]) >= ((varBaseAddress) - (0x100))) && ((((self_in_CogARMv8Compiler->operands))[1]) <= (((varBaseAddress) + (0x1000)) - 1))));

	case MoveMwrR:
	case MoveMbrR:
	case MoveM16rR:
		return !(isImm12orImm9offset(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[0]));

	case MoveRMwr:
	case MoveRMbr:
	case MoveRM16r:
		immediate = ((self_in_CogARMv8Compiler->operands))[1];

		/* begin isPossiblyShiftableNegatableImm12:ifTrue:ifFalse: */
		if (((immediate >= (-4096)) && (immediate <= (0xFFF)))) {
			return 0;
		}
		if (((!(immediate & (0xFFF))))
		 && (((((immediate) >> 12) >= (-4096)) && (((immediate) >> 12) <= (0xFFF))))) {
			return 0;
		}
		return 1;

	case MoveRdM64r:
		return !(isUnsigned12BitMultipleOf8(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[1]));

	case MoveM64rRd:
		return !(isUnsigned12BitMultipleOf8(self_in_CogARMv8Compiler, ((self_in_CogARMv8Compiler->operands))[0]));

	case PushCq:
		return !((((((self_in_CogARMv8Compiler->operands))[0]) >= -256) && ((((self_in_CogARMv8Compiler->operands))[0]) <= 0xFF)));

	default:
		assert(0);
	}
	return 0;
}


/*	Answer if Call and JumpLong are relative and hence need to take the
	caller's relocation delta into account during code compaction, rather than
	just the
	callee's delta. */

	/* CogARMv8Compiler>>#zoneCallsAreRelative */
static NoDbgRegParms sqInt
zoneCallsAreRelative(AbstractInstruction *self_in_CogARMv8Compiler)
{
	return 1;
}

	/* CogBlockMethod>>#cmHomeMethod */
static NoDbgRegParms CogMethod *
cmHomeMethod(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cpicHasMNUCaseOrCMIsFullBlock)
			? ((CogMethod *) self_in_CogBlockMethod)
			: ((CogMethod *) ((((usqInt)self_in_CogBlockMethod)) - ((self_in_CogBlockMethod->homeOffset)))));
}

	/* CogBlockMethod>>#isCMBlock */
static NoDbgRegParms int
isCMBlock(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMBlock;
}

	/* CogBlockMethod>>#isCMClosedPIC */
static NoDbgRegParms int
isCMClosedPIC(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMClosedPIC;
}

	/* CogBlockMethod>>#isCMFree */
static NoDbgRegParms int
isCMFree(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMFree;
}

	/* CogBlockMethod>>#isCMMethodEtAl */
static NoDbgRegParms int
isCMMethodEtAl(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) >= CMMethod;
}

	/* CogBlockMethod>>#isCMOpenPIC */
static NoDbgRegParms int
isCMOpenPIC(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMOpenPIC;
}

	/* CogBytecodeDescriptor>>#isBranch */
static NoDbgRegParms sqInt
isBranch(BytecodeDescriptor *self_in_CogBytecodeDescriptor)
{
	return (((self_in_CogBytecodeDescriptor->spanFunction)))
	 && (!((self_in_CogBytecodeDescriptor->isBlockCreation)));
}

	/* CogBytecodeDescriptor>>#isConditionalBranch */
static NoDbgRegParms sqInt
isConditionalBranch(BytecodeDescriptor *self_in_CogBytecodeDescriptor)
{
	return ((self_in_CogBytecodeDescriptor->isBranchTrue))
	 || ((self_in_CogBytecodeDescriptor->isBranchFalse));
}

	/* Cogit>>#AddCq:R: */
static NoDbgRegParms AbstractInstruction *
gAddCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return anInstruction;
}


/*	N.B. if the condition codes don't require setting and three address
	arithmetic is unavailable, then LoadEffectiveAddressMw:r:R: can be used
	instead. 
 */

	/* Cogit>>#AddCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gAddCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *first;

	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(AddCqRR, quickConstant, srcReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return anInstruction;
	if (srcReg == destReg) {
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, quickConstant, destReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		return anInstruction;
	}
	first = genoperandoperand(MoveRR, srcReg, destReg);

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return first;
}

	/* Cogit>>#AndCq:R: */
static NoDbgRegParms AbstractInstruction *
gAndCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return anInstruction;
}

	/* Cogit>>#AndCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gAndCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *first;

	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(AndCqRR, quickConstant, srcReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return anInstruction;
	if (srcReg == destReg) {
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		return anInstruction;
	}
	first = genoperandoperand(MoveRR, srcReg, destReg);

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return first;
}


/*	destReg := (signed)srcReg >> quickConstant */

	/* Cogit>>#ArithmeticShiftRightCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gArithmeticShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	return genoperandoperandoperand(ArithmeticShiftRightCqRR, quickConstant, srcReg, destReg);
	first = genoperandoperand(MoveRR, srcReg, destReg);
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, destReg);
	return first;
}

	/* Cogit>>#abortOffset */
sqInt
abortOffset(void)
{
	return missOffset;
}

	/* Cogit>>#addCleanBlockStarts */
static void
addCleanBlockStarts(void)
{
    sqInt i;
    sqInt lit;
    sqInt startPCOrNil;
    sqInt toDoLimit;

	toDoLimit = literalCountOf(methodObj);
	for (i = 1; i <= toDoLimit; i += 1) {
		lit = fetchPointerofObject(i, methodObj);
		startPCOrNil = startPCOrNilOfLiteralin(lit, methodObj);
		if (startPCOrNil) {
			maxLitIndex = ((maxLitIndex < i) ? i : maxLitIndex);
			addBlockStartAtnumArgsnumCopiedspan(startPCOrNil - 1, argumentCountOfClosure(lit), copiedValueCountOfClosure(lit), spanForCleanBlockStartingAt(startPCOrNil - 1));
		}
	}
}


/*	Perform an integrity/leak check using the heapMap.
	Set a bit at each cog method's header. */

	/* Cogit>>#addCogMethodsToHeapMap */
void
addCogMethodsToHeapMap(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			heapMapAtWordPut(cogMethod, 1);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* Cogit>>#addressIsInCurrentCompilation: */
static NoDbgRegParms sqInt
addressIsInCurrentCompilation(sqInt address)
{
	return ((((usqInt)address)) >= ((methodLabel->address)))
	 && ((((usqInt)address)) < ((((youngReferrers) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers) : (((methodLabel->address)) + MaxMethodSize))));
}

	/* Cogit>>#addressIsInFixups: */
static NoDbgRegParms sqInt
addressIsInFixups(BytecodeFixup *address)
{
	return (BytecodeFixup *)address >= fixups && (BytecodeFixup *)address < (fixups + numAbstractOpcodes);
}


/*	calculate the end of the n'th case statement - which is complicated
	because we have case 1 right at the top of our CPIC and then build up from
	the last one. Yes I know this sounds strange, but trust me - I'm an
	Engineer, we do things backwards all the emit
 */

	/* Cogit>>#addressOfEndOfCase:inCPIC: */
static NoDbgRegParms sqInt
addressOfEndOfCaseinCPIC(sqInt n, CogMethod *cPIC)
{
	assert((n >= 1)
	 && (n <= MaxCPICCases));
	return (n == 1
			? (((sqInt)cPIC)) + firstCPICCaseOffset
			: ((((sqInt)cPIC)) + firstCPICCaseOffset) + (((MaxCPICCases + 1) - n) * cPICCaseSize));
}


/*	Align methodZoneBase to that for the start of a method. */

	/* Cogit>>#alignMethodZoneBase */
static void
alignMethodZoneBase(void)
{
    usqInt oldBase;

	oldBase = methodZoneBase;
	methodZoneBase = roundUpToMethodAlignment(backEnd, methodZoneBase);
	stopsFromto(backEnd, oldBase, methodZoneBase - 1);
}

	/* Cogit>>#alignUptoRoutineBoundary: */
static NoDbgRegParms sqInt
alignUptoRoutineBoundary(sqInt anAddress)
{
	return (((anAddress + 7) | 7) - 7);
}


/*	Check that all methods have valid selectors, and that all linked sends are
	to valid targets and have valid cache tags
 */

	/* Cogit>>#allMachineCodeObjectReferencesValid */
static sqInt
allMachineCodeObjectReferencesValid(void)
{
    CogMethod *cogMethod;
    sqInt ok;

	ok = 1;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (!(asserta(checkValidOopReference((cogMethod->selector))))) {
				ok = 0;
			}
			if (!(asserta((cogMethodDoesntLookKosher(cogMethod)) == 0))) {
				ok = 0;
			}
		}
		if ((((cogMethod->cmType)) >= CMMethod)
		 || (((cogMethod->cmType)) == CMOpenPIC)) {
			if (!(asserta((mapForperformUntilarg(cogMethod, checkIfValidOopRefAndTargetpccogMethod, cogMethod)) == 0))) {
				ok = 0;
			}
		}
		if (((cogMethod->cmType)) == CMClosedPIC) {
			if (!(asserta(noTargetsFreeInClosedPIC(cogMethod)))) {
				ok = 0;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return ok;
}

	/* Cogit>>#allMethodsHaveCorrectHeader */
static sqInt
allMethodsHaveCorrectHeader(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			if (!(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()))) {
				return 0;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return 1;
}

	/* Cogit>>#annotateAbsolutePCRef: */
static NoDbgRegParms AbstractInstruction *
annotateAbsolutePCRef(AbstractInstruction *abstractInstruction)
{
	(abstractInstruction->annotation = IsAbsPCReference);
	return abstractInstruction;
}

	/* Cogit>>#annotateBytecode: */
static NoDbgRegParms AbstractInstruction *
annotateBytecode(AbstractInstruction *abstractInstruction)
{
	(abstractInstruction->annotation = HasBytecodePC);
	return abstractInstruction;
}

	/* Cogit>>#annotate:objRef: */
static NoDbgRegParms AbstractInstruction *
annotateobjRef(AbstractInstruction *abstractInstruction, sqInt anOop)
{
	if (/* shouldAnnotateObjectReference: */
		(isNonImmediate(anOop))
	 && ((oopisGreaterThan(anOop, classTableRootObj()))
	 || (oopisLessThan(anOop, nilObject())))) {
		setHasMovableLiteral(1);
		if (isYoungObject(anOop)) {
			setHasYoungReferent(1);
		}
		(abstractInstruction->annotation = IsObjectReference);
	}
	return abstractInstruction;
}

	/* Cogit>>#assertSaneJumpTarget: */
static NoDbgRegParms void
assertSaneJumpTarget(AbstractInstruction *jumpTarget)
{
	assert((!closedPICSize)
	 || ((!openPICSize)
	 || ((addressIsInInstructions(jumpTarget))
	 || ((((((usqInt)jumpTarget)) >= codeBase) && ((((usqInt)jumpTarget)) <= ((((sqInt)(limitZony()))) + (((closedPICSize < openPICSize) ? openPICSize : closedPICSize)))))))));
}


/*	Answer an unused abstract register in the registerMask, or NoReg if none. */

	/* Cogit>>#availableRegisterOrNoneIn: */
static NoDbgRegParms sqInt
availableRegisterOrNoneIn(sqInt liveRegsMask)
{
    sqInt reg;

	if (liveRegsMask) {
		for (reg = 0; reg <= 0x1F; reg += 1) {
			if (((liveRegsMask & (1ULL << reg)) != 0)) {
				return reg;
			}
		}
	}
	return NoReg;
}


/*	Evaluate binaryFunction with the block start mcpc and supplied arg for
	each entry in the block dispatch. If the function answers non-zero answer
	the value
	it answered. Used to update back-references to the home method in
	compaction.  */

	/* Cogit>>#blockDispatchTargetsFor:perform:arg: */
static NoDbgRegParms sqInt
blockDispatchTargetsForperformarg(CogMethod *cogMethod, usqInt (*binaryFunction)(sqInt mcpc, sqInt arg), sqInt arg)
{
    sqInt blockEntry;
    sqInt end;
    sqInt pc;
    sqInt result;
    usqInt targetpc;

	if (!((cogMethod->blockEntryOffset))) {
		return null;
	}
	blockEntry = ((cogMethod->blockEntryOffset)) + (((sqInt)cogMethod));
	pc = blockEntry;
	end = (mapEndFor(cogMethod)) - 1;
	while (pc < end) {
		if (isJumpAt(backEnd, pc)) {
			targetpc = jumpTargetPCAt(backEnd, pc);
			if (targetpc < blockEntry) {
				result = binaryFunction(targetpc, arg);
				if (result) {
					return result;
				}
			}
		}
		pc += instructionSizeAt(backEnd, pc);
	}
	return 0;
}


/*	Answer the zero-relative bytecode pc matching the machine code pc argument
	in cogMethod, given the start of the bytecodes for cogMethod's block or
	method object. */

	/* Cogit>>#bytecodePCFor:startBcpc:in: */
sqInt
bytecodePCForstartBcpcin(sqInt mcpc, sqInt startbcpc, CogBlockMethod *cogMethod)
{
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    usqInt isInBlock;
    sqInt latestContinuation;
    sqInt map;
    sqInt mapByte;
    usqInt mcpcUsqInt;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt targetPC;

	/* begin mapFor:bcpc:performUntil:arg: */
	descriptor = ((BytecodeDescriptor *) 0);
	latestContinuation = 0;
	mapByte = 0;
	nextBcpc = 0;
	assert(((cogMethod->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpcUsqInt = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	result = findIsBackwardBranchMcpcBcpcMatchingMcpc(null, 0 + ((((usqInt)(HasBytecodePC) << 1))), ((char *) mcpcUsqInt), startbcpc, ((void *)mcpc));
	if (result) {
		return result;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if (((cogMethod->cmType)) >= CMMethod) {
		isInBlock = (cogMethod->cpicHasMNUCaseOrCMIsFullBlock);
		homeMethod = ((CogMethod *) cogMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;

		/* If the method has a primitive, skip it and the error code store, if any;
		   Logically. these come before the stack check and so must be ignored. */
		bsOffset = /* begin bytecodeSetOffsetForHeader: */
				(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
					? 0x100
					: 0);
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == ((cogMethod->startpc)));
		homeMethod = cmHomeMethod(cogMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - (/* begin blockCreationBytecodeSizeForHeader: */
	(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
		? AltBlockCreationBytecodeSize
		: BlockCreationBytecodeSize));
		bsOffset = /* begin bytecodeSetOffsetForHeader: */
				(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
					? 0x100
					: 0);
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj)
		: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	enumeratingCogMethod = homeMethod;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpcUsqInt += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							return 0;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							return 0;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)
		: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
								? nExts + 1
								: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
					 && ((/* begin isBackwardBranch:at:exts:in: */
						assert(((descriptor->spanFunction))),
					(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = findIsBackwardBranchMcpcBcpcMatchingMcpc(descriptor, (isBackwardBranch
							? ((((usqInt)(annotation) << 1))) + 1
							: ((sqInt)((usqInt)(annotation) << 1))), ((char *) mcpcUsqInt), (isBackwardBranch
							? bcpc - (2 * nExts)
							: bcpc), ((void *)mcpc));
				if (result) {
					return result;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
							? nExts + 1
							: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpcUsqInt += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
			}
		}
		map -= 1;
	}
	return 0;
}

	/* Cogit>>#CallRT:registersToBeSavedMask: */
static NoDbgRegParms AbstractInstruction *
CallRTregistersToBeSavedMask(sqInt callTarget, sqInt registersToBeSaved)
{
    sqInt callerSavedRegsToBeSaved;
    AbstractInstruction *lastInst;
    sqInt reg;
    sqInt registersToBePushed;

	callerSavedRegsToBeSaved = CallerSavedRegisterMask & registersToBeSaved;
	registersToBePushed = callerSavedRegsToBeSaved;
	reg = 0;
	while (registersToBePushed != 0) {
		if (((registersToBePushed & 1) != 0)) {
			/* PushR: */
			genoperand(PushR, reg);
		}
		reg += 1;
		registersToBePushed = (registersToBePushed) >> 1;
	}

	/* begin CallRT: */
	lastInst = genoperand(Call, callTarget);
	(lastInst->annotation = IsRelativeCall);
	while (reg > 0) {
		reg -= 1;
		if (((callerSavedRegsToBeSaved & (1ULL << reg)) != 0)) {
			lastInst = genoperand(PopR, reg);
		}
	}
	return lastInst;
}

	/* Cogit>>#CmpCq:R: */
static NoDbgRegParms AbstractInstruction *
gCmpCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return anInstruction;
}


/*	This is a static version of ceCallCogCodePopReceiverReg for break-pointing
	when debugging in C. Marked <api> so the code generator won't delete it. */

	/* Cogit>>#callCogCodePopReceiver */
static void
callCogCodePopReceiver(void)
{
	realCECallCogCodePopReceiverReg();
	if (!Debug) {
		error("what??");
	}
}


/*	This is a static version of ceCallCogCodePopReceiverAndClassRegs for
	break-pointing when debugging in C. Marked <api> so the code generator
	won't delete it. */

	/* Cogit>>#callCogCodePopReceiverAndClassRegs */
static void
callCogCodePopReceiverAndClassRegs(void)
{
	realCECallCogCodePopReceiverAndClassRegs();
}


/*	Code entry closed PIC miss. A send has fallen
	through a closed (finite) polymorphic inline cache.
	Either extend it or patch the send site to an open PIC.
	The stack looks like:
	receiver
	args
	sp=>	sender return address */
/*	Marked <api> so the code generator won't delete it. */

	/* Cogit>>#ceCPICMiss:receiver: */
static NoDbgRegParms sqInt
ceCPICMissreceiver(CogMethod *cPIC, sqInt receiver)
{
    sqInt cacheTag;
    sqInt errorSelectorOrNil;
    sqInt methodOrSelectorIndex;
    sqInt newTargetMethodOrNil;
    sqInt outerReturn;
    sqInt result;
    sqInt selector;

	if (isOopForwarded(receiver)) {
		return ceSendFromInLineCacheMiss(cPIC);
	}
	outerReturn = stackTop();
	assert(!(((inlineCacheTagAt(backEnd, outerReturn)) == (picAbortDiscriminatorValue()))));
	if (((cPIC->cPICNumCases)) < MaxCPICCases) {
		selector = (cPIC->selector);

		/* begin lookup:for:methodAndErrorSelectorInto: */
		methodOrSelectorIndex = lookupOrdinaryreceiver(selector, receiver);
		if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
			if (!(isOopCompiledMethod(methodOrSelectorIndex))) {
				newTargetMethodOrNil = methodOrSelectorIndex;
				errorSelectorOrNil = SelectorCannotInterpret;
				goto l1;
			}
			if ((!(methodHasCogMethod(methodOrSelectorIndex)))
			 && (methodShouldBeCogged(methodOrSelectorIndex))) {

				/* We assume cog:selector: will *not* reclaim the method zone */
				cogselector(methodOrSelectorIndex, selector);
			}
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = null;
			goto l1;
		}
		if (methodOrSelectorIndex == SelectorDoesNotUnderstand) {
			methodOrSelectorIndex = lookupMNUreceiver(splObj(SelectorDoesNotUnderstand), receiver);
			if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
				assert(isOopCompiledMethod(methodOrSelectorIndex));
				if ((!(methodHasCogMethod(methodOrSelectorIndex)))
				 && (methodShouldBeCogged(methodOrSelectorIndex))) {

					/* We assume cog:selector: will *not* reclaim the method zone */
					cogselector(methodOrSelectorIndex, splObj(SelectorDoesNotUnderstand));
				}
				newTargetMethodOrNil = methodOrSelectorIndex;
				errorSelectorOrNil = SelectorDoesNotUnderstand;
				goto l1;
			}
			newTargetMethodOrNil = null;
			errorSelectorOrNil = SelectorDoesNotUnderstand;
			goto l1;
		}
		newTargetMethodOrNil = null;
		errorSelectorOrNil = methodOrSelectorIndex;
l1:	/* end lookup:for:methodAndErrorSelectorInto: */;
	}
	else {
		newTargetMethodOrNil = (errorSelectorOrNil = null);
	}
	assert(outerReturn == (stackTop()));

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	cacheTag = inlineCacheTagForInstance(receiver);
	if ((((cPIC->cPICNumCases)) >= MaxCPICCases)
	 || (/* closedPICInappropriateForCacheTag:targetMethod:orErrorSelector: */
		((errorSelectorOrNil)
	 && (errorSelectorOrNil != SelectorDoesNotUnderstand))
	 || ((!newTargetMethodOrNil)
	 || (isYoung(newTargetMethodOrNil))))) {
		result = patchToOpenPICFornumArgsreceiver((cPIC->selector), (cPIC->cmNumArgs), receiver);
		assert(!result);

		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneExecutable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(1);
		PJWPNSet = __LINE__;
		PJWPNChange = __LINE__;
		PJWPNState = 1;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

		return ceSendFromInLineCacheMiss(cPIC);
	}
	cogExtendPICCaseNMethodtagisMNUCase(cPIC, newTargetMethodOrNil, cacheTag, errorSelectorOrNil == SelectorDoesNotUnderstand);

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	executeCogPICfromLinkedSendWithReceiverandCacheTag(cPIC, receiver, inlineCacheTagAt(backEnd, outerReturn));
	return null;
}


/*	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it. 
 */

	/* Cogit>>#ceFree: */
static NoDbgRegParms void
ceFree(void *pointer)
{
	free(pointer);
}


/*	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it. 
 */

	/* Cogit>>#ceMalloc: */
static NoDbgRegParms void*
ceMalloc(size_t size)
{
	return malloc(size);
}


/*	An in-line cache check in a method has failed. The failing entry check has
	jumped to the ceMethodAbort abort call at the start of the method which
	has called this routine.
	If possible allocate a closed PIC for the current and existing classes.
	The stack looks like:
	receiver
	args
	sender return address
	sp=>	ceMethodAbort call return address
	So we can find the method that did the failing entry check at
	ceMethodAbort call return address - missOffset
	and we can find the send site from the outer return address.
	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it.  */

	/* Cogit>>#ceSICMiss: */
static NoDbgRegParms sqInt
ceSICMiss(sqInt receiver)
{
    sqInt cacheTag;
    unsigned int codeInstruction;
    unsigned int dataInstruction;
    sqInt entryPoint;
    sqInt errorSelectorOrNil;
    sqInt extent;
    usqInt innerReturn;
    sqInt methodOrSelectorIndex;
    sqInt newTargetMethodOrNil;
    usqInt outerReturn;
    CogMethod *pic;
    sqInt result;
    sqInt selector;
    CogMethod *targetMethod;


	/* Whether we can relink to a PIC or not we need to pop off the inner return and identify the target method. */
	innerReturn = ((usqInt)(popStack()));
	targetMethod = ((CogMethod *) (innerReturn - missOffset));
	if (isOopForwarded(receiver)) {
		return ceSendFromInLineCacheMiss(targetMethod);
	}
	outerReturn = ((usqInt)(stackTop()));
	assert(((outerReturn >= methodZoneBase) && (outerReturn <= (freeStart()))));
	entryPoint = callTargetFromReturnAddress(backEnd, outerReturn);
	assert(((targetMethod->selector)) != (nilObject()));
	assert(((((sqInt)targetMethod)) + cmEntryOffset) == entryPoint);
	selector = (targetMethod->selector);

	/* begin lookup:for:methodAndErrorSelectorInto: */
	methodOrSelectorIndex = lookupOrdinaryreceiver(selector, receiver);
	if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
		if (!(isOopCompiledMethod(methodOrSelectorIndex))) {
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = SelectorCannotInterpret;
			goto l1;
		}
		if ((!(methodHasCogMethod(methodOrSelectorIndex)))
		 && (methodShouldBeCogged(methodOrSelectorIndex))) {

			/* We assume cog:selector: will *not* reclaim the method zone */
			cogselector(methodOrSelectorIndex, selector);
		}
		newTargetMethodOrNil = methodOrSelectorIndex;
		errorSelectorOrNil = null;
		goto l1;
	}
	if (methodOrSelectorIndex == SelectorDoesNotUnderstand) {
		methodOrSelectorIndex = lookupMNUreceiver(splObj(SelectorDoesNotUnderstand), receiver);
		if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
			assert(isOopCompiledMethod(methodOrSelectorIndex));
			if ((!(methodHasCogMethod(methodOrSelectorIndex)))
			 && (methodShouldBeCogged(methodOrSelectorIndex))) {

				/* We assume cog:selector: will *not* reclaim the method zone */
				cogselector(methodOrSelectorIndex, splObj(SelectorDoesNotUnderstand));
			}
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = SelectorDoesNotUnderstand;
			goto l1;
		}
		newTargetMethodOrNil = null;
		errorSelectorOrNil = SelectorDoesNotUnderstand;
		goto l1;
	}
	newTargetMethodOrNil = null;
	errorSelectorOrNil = methodOrSelectorIndex;
l1:	/* end lookup:for:methodAndErrorSelectorInto: */;
	assert(outerReturn == (stackTop()));
	cacheTag = inlineCacheTagForInstance(receiver);
	if ((/* closedPICInappropriateForCacheTag:targetMethod:orErrorSelector: */
		((errorSelectorOrNil)
	 && (errorSelectorOrNil != SelectorDoesNotUnderstand))
	 || ((!newTargetMethodOrNil)
	 || (isYoung(newTargetMethodOrNil))))
	 || ((inlineCacheTagAt(backEnd, outerReturn)) == 0 /* picAbortDiscriminatorValue */)) {
		result = patchToOpenPICFornumArgsreceiver((targetMethod->selector), (targetMethod->cmNumArgs), receiver);
		assert(!result);
		return ceSendFromInLineCacheMiss(targetMethod);
	}

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	pic = openPICWithSelector((targetMethod->selector));
	if (!pic) {

		/* otherwise attempt to create a closed PIC for the two cases. */
		pic = cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase((targetMethod->selector), (targetMethod->cmNumArgs), targetMethod, newTargetMethodOrNil, cacheTag, errorSelectorOrNil == SelectorDoesNotUnderstand);
		if ((((((sqInt)pic)) >= MaxNegativeErrorCode) && ((((sqInt)pic)) <= -1))) {

			/* For some reason the PIC couldn't be generated, most likely a lack of code memory.
			   Continue as if this is an unlinked send. */
			if ((((sqInt)pic)) == InsufficientCodeSpace) {
				callForCogCompiledCodeCompaction();
			}

			/* begin ensureExecutableCodeZone */
#      if !DUAL_MAPPED_CODE_ZONE
			/* begin makeCodeZoneExecutable */
#      if __APPLE__ && __MACH__
			pthread_jit_write_protect_np(1);
			PJWPNSet = __LINE__;
			PJWPNChange = __LINE__;
			PJWPNState = 1;
#      endif

#      endif // !DUAL_MAPPED_CODE_ZONE

			return ceSendFromInLineCacheMiss(targetMethod);
		}
	}
	extent = (((pic->cmType)) == CMOpenPIC
				? rewriteInlineCacheAttagtarget(backEnd, outerReturn, inlineCacheValueForSelectorin(backEnd, (targetMethod->selector), mframeHomeMethodExport()), (((sqInt)pic)) + cmEntryOffset)
				: rewriteCallAttarget(backEnd, outerReturn, (((sqInt)pic)) + cmEntryOffset));
	(((usqInt)pic)) + closedPICSize;

	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	/* begin assertCoherentCodeAt:delta: */
	codeInstruction = long32At((((usqInt)pic)) + cmNoCheckEntryOffset);
	dataInstruction = long32At(((((usqInt)pic)) + cmNoCheckEntryOffset) + codeToDataDelta);
	assert(codeInstruction == dataInstruction);
#  endif // DUAL_MAPPED_CODE_ZONE


	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) (((usqInt)pic))), ((((usqInt)pic)) + closedPICSize) - (((usqInt)pic)));
	sys_icache_invalidate(((void *) (((usqInt)pic))), ((((usqInt)pic)) + closedPICSize) - (((usqInt)pic)));
#  else // __APPLE__ && __MACH__
	ceFlushICache(((usqInt)pic), (((usqInt)pic)) + closedPICSize);
#  endif


	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) ((((usqInt)outerReturn)) - extent)), (((usqInt)outerReturn)) - ((((usqInt)outerReturn)) - extent));
	sys_icache_invalidate(((void *) ((((usqInt)outerReturn)) - extent)), (((usqInt)outerReturn)) - ((((usqInt)outerReturn)) - extent));
#  else // __APPLE__ && __MACH__
	ceFlushICache((((usqInt)outerReturn)) - extent, ((usqInt)outerReturn));
#  endif

	executeCogPICfromLinkedSendWithReceiverandCacheTag(pic, receiver, inlineCacheTagAt(backEnd, outerReturn));
	return null;
}


/*	Check for a valid object reference, if any, at a map entry. Answer a code
	unique to each error for debugging. */

	/* Cogit>>#checkIfValidOopRefAndTarget:pc:cogMethod: */
static NoDbgRegParms sqInt
checkIfValidOopRefAndTargetpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    unsigned int cacheTag1;
    sqInt entryPoint;
    sqInt entryPointSqInt;
    sqInt literal;
    sqInt offsetSqInt;
    sqInt pc;
    sqInt *sendTable1;
    sqInt tagCouldBeObj;
    CogMethod *targetMethod1;

	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		if (!(asserta(checkValidOopReference(literal)))) {
			return 1;
		}
		if ((couldBeObject(literal))
		 && (isReallyYoungObject(literal))) {
			if (!(asserta(((((CogMethod *) cogMethod))->cmRefersToYoung)))) {
				return 2;
			}
		}
	}
	if (annotation >= IsSendCall) {
		if (!(asserta(isCMMethodEtAl(((CogBlockMethod *) (((CogMethod *) cogMethod))))))) {
			return 3;
		}

		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		/* begin inlineCacheTagAt: */
		pc = pcRelativeAddressAt(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 8)));
		cacheTag1 = long32At(pc);

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPointSqInt = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj = 0;
		entryPoint = entryPointSqInt;
		if (tagCouldBeObj) {
			if (couldBeObject(cacheTag1)) {
				if (!(asserta(checkValidOopReference(cacheTag1)))) {
					return 4;
				}
			}
			else {
				if (!(asserta(validInlineCacheTag(cacheTag1)))) {
					return 5;
				}
			}
			if ((couldBeObject(cacheTag1))
			 && (isReallyYoungObject(cacheTag1))) {
				if (!(asserta(((((CogMethod *) cogMethod))->cmRefersToYoung)))) {
					return 6;
				}
			}
		}
		else {
			if (entryPointTagIsSelector(entryPoint)) {
				if ((((int) cacheTag1)) < 0) {
					if ((-(((int) cacheTag1))) > NumSpecialSelectors) {
						return 7;
					}
				}
				else {
					if (cacheTag1 >= (literalCountOf((enumeratingCogMethod->methodObject)))) {
						return 8;
					}
				}
			}
			else {
				if (!(asserta(validInlineCacheTag(cacheTag1)))) {
					return 9;
				}
			}
		}
		if (entryPoint > methodZoneBase) {

			/* It's a linked send; find which kind. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));
			if (!(asserta((isCMMethodEtAl(((CogBlockMethod *) targetMethod1)))
				 || ((isCMClosedPIC(((CogBlockMethod *) targetMethod1)))
				 || (isCMOpenPIC(((CogBlockMethod *) targetMethod1))))))) {
				return 10;
			}
		}
	}
	return 0;
}


/*	Check for a valid object reference, if any, at a map entry. Answer a code
	unique to each error for debugging. */

	/* Cogit>>#checkIfValidOopRef:pc:cogMethod: */
static NoDbgRegParms sqInt
checkIfValidOopRefpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    sqInt entryPoint;
    sqInt literal;
    sqInt offset;
    sqInt offsetSqInt;
    sqInt pc;
    unsigned int selectorOrCacheTag;
    sqInt *sendTable;

	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		if (!(checkValidOopReference(literal))) {
			print("object ref leak in CM ");
			printHex(((sqInt)cogMethod));
			print(" @ ");
			printHex(((sqInt)mcpc));
			eekcr();
			return 1;
		}
	}
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint <= methodZoneBase) {
			offset = entryPoint;
		}
		else {
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable = superSendTrampolines;
					}
				}
			}
			offset = offsetSqInt;
		}

		/* begin inlineCacheTagAt: */
		pc = pcRelativeAddressAt(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 8)));
		selectorOrCacheTag = long32At(pc);
		if ((entryPoint > methodZoneBase)
		 && ((offset != cmNoCheckEntryOffset)
		 && (!((((((CogMethod *) (entryPoint - offset)))->cmType)) == CMOpenPIC)))) {

			/* linked non-super send, cacheTag is a cacheTag */
			if (!(validInlineCacheTag(selectorOrCacheTag))) {
				print("cache tag leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" @ ");
				printHex(((sqInt)mcpc));
				eekcr();
				return 1;
			}
		}
		else {

			/* unlinked send or super send; cacheTag is a selector unless 64-bit, in which case it is an index. */
		}
	}
	return 0;
}


/*	Answer if all references to objects in machine-code are valid. */

	/* Cogit>>#checkIntegrityOfObjectReferencesInCode: */
sqInt
checkIntegrityOfObjectReferencesInCode(sqInt gcModes)
{
    CogMethod *cogMethod;
    sqInt count;
    sqInt ok;

	cogMethod = ((CogMethod *) methodZoneBase);
	ok = 1;
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if ((cogMethod->cmRefersToYoung)) {
				if (((count = occurrencesInYoungReferrers(cogMethod))) != 1) {
					print("young referrer CM ");
					printHex(((sqInt)cogMethod));
					if (count) {
						print(" is in youngReferrers ");
						printNum(count);
						print(" times!");
						eekcr();
					}
					else {
						print(" is not in youngReferrers");
						eekcr();
					}
					ok = 0;
				}
			}
			if (!(checkValidOopReference((cogMethod->selector)))) {
				print("object leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" selector");
				eekcr();
				ok = 0;
			}
			if (((cogMethod->cmType)) >= CMMethod) {
				assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
				if (!(checkValidObjectReference((cogMethod->methodObject)))) {
					print("object leak in CM ");
					printHex(((sqInt)cogMethod));
					print(" methodObject");
					eekcr();
					ok = 0;
				}
				if (!(isOopCompiledMethod((cogMethod->methodObject)))) {
					print("non-method in CM ");
					printHex(((sqInt)cogMethod));
					print(" methodObject");
					eekcr();
					ok = 0;
				}
				if (mapForperformUntilarg(cogMethod, checkIfValidOopRefpccogMethod, cogMethod)) {
					ok = 0;
				}
				if (((isYoungObject((cogMethod->methodObject)))
				 || (isYoung((cogMethod->selector))))
				 && (!((cogMethod->cmRefersToYoung)))) {
					print("CM ");
					printHex(((sqInt)cogMethod));
					print(" refers to young but not marked as such");
					eekcr();
					ok = 0;
				}
			}
			else {
				if (((cogMethod->cmType)) == CMClosedPIC) {
					if (!(checkValidObjectReferencesInClosedPIC(cogMethod))) {
						ok = 0;
					}
				}
				else {
					if (((cogMethod->cmType)) == CMOpenPIC) {
						if (mapForperformUntilarg(cogMethod, checkIfValidOopRefpccogMethod, cogMethod)) {
							ok = 0;
						}
					}
				}
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return ok;
}

	/* Cogit>>#checkMaybeObjRefInClosedPIC: */
static NoDbgRegParms sqInt
checkMaybeObjRefInClosedPIC(sqInt maybeObject)
{
	if (!maybeObject) {
		return 1;
	}
	if (!(couldBeObject(maybeObject))) {
		return 1;
	}
	return checkValidObjectReference(maybeObject);
}

	/* Cogit>>#checkValidObjectReferencesInClosedPIC: */
static NoDbgRegParms sqInt
checkValidObjectReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt ok;
    sqInt pc;

	ok = 1;

	/* first we check the obj ref at the beginning of the CPIC */
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	if (!(checkMaybeObjRefInClosedPIC(literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)))))) {
		print("object leak in CPIC ");
		printHex(((sqInt)cPIC));
		print(" @ ");
		printHex(pc - (jumpLongByteSize(backEnd)));
		cr();
		ok = 0;
	}

	/* For each case we check any object reference at the end address - sizeof(conditional instruction) and then increment the end address by case size */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (!(checkMaybeObjRefInClosedPIC(literalBeforeFollowingAddress(backEnd, (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))))) {
			print("object leak in CPIC ");
			printHex(((sqInt)cPIC));
			print(" @ ");
			printHex(pc - (jumpLongConditionalByteSize(backEnd)));
			cr();
			ok = 0;
		}
		pc += cPICCaseSize;
	}
	return ok;
}


/*	i.e. this should never be called, so keep it out of the main path. */

	/* Cogit>>#cleanUpFailingCogCodeConstituents: */
static NoDbgRegParms NeverInline sqInt
cleanUpFailingCogCodeConstituents(CogMethod *cogMethodArg)
{
    CogMethod *cogMethod;

	cogMethod = cogMethodArg;
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMClosedPIC) {
			(cogMethod->methodObject = 0);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	popRemappableOop();
	return null;
}


/*	Answer if the ClosedPIC refers to any unmarked objects or freed/freeable
	target methods,
	applying markAndTraceOrFreeCogMethod:firstVisit: to those targets to
	determine if freed/freeable.
 */

	/* Cogit>>#closedPICRefersToUnmarkedObject: */
static NoDbgRegParms sqInt
closedPICRefersToUnmarkedObject(CogMethod *cPIC)
{
    sqInt i;
    sqInt object;
    sqInt pc;

	if (!((isImmediate((cPIC->selector)))
		 || (isMarked((cPIC->selector))))) {
		return 1;
	}
	pc = addressOfEndOfCaseinCPIC(1, cPIC);
	if (couldBeObject((object = literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)))))) {
		if (!(isMarked(object))) {
			return 1;
		}
	}
	if (markAndTraceOrFreePICTargetin(jumpLongTargetBeforeFollowingAddress(backEnd, pc), cPIC)) {
		return 1;
	}
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (couldBeObject((object = literalBeforeFollowingAddress(backEnd, (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))))) {
			if (!(isMarked(object))) {
				return 1;
			}
		}
		if (markAndTraceOrFreePICTargetin(jumpLongTargetBeforeFollowingAddress(backEnd, pc), cPIC)) {
			return 1;
		}
	}
	return 0;
}

	/* Cogit>>#codeEntryFor: */
char *
codeEntryFor(char *address)
{
    sqInt i;

	for (i = 0; i <= (trampolineTableIndex - 3); i += 2) {
		if (((address >= (trampolineAddresses[i + 1])) && (address <= ((trampolineAddresses[i + 3]) - 1)))) {
			return trampolineAddresses[i + 1];
		}
	}
	return null;
}

	/* Cogit>>#codeEntryNameFor: */
char *
codeEntryNameFor(char *address)
{
    sqInt i;

	for (i = 0; i <= (trampolineTableIndex - 3); i += 2) {
		if (((address >= (trampolineAddresses[i + 1])) && (address <= ((trampolineAddresses[i + 3]) - 1)))) {
			return trampolineAddresses[i];
		}
	}
	return null;
}


/*	used e.g. in the platform's backtrace generators. Declared api to place it
	in cogit.h
 */

	/* Cogit>>#cogCodeBase */
sqInt
cogCodeBase(void)
{
	return codeBase;
}


/*	Answer the contents of the code zone as an array of pair-wise element,
	address in ascending address order.
	Answer a string for a runtime routine or abstract label (beginning, end,
	etc), a CompiledMethod for a CMMethod,
	or a selector (presumably a Symbol) for a PIC.
	If withDetails is true
	- answer machine-code to bytecode pc mapping information for methods
	- answer class, target pair information for closed PIC
	N.B. Since the class tag for the first case of a closed PIC is stored at
	the send site, it must be collected
	by scanning methods (see
	collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method:). Since closed PICs
	are never shared they always come after the method that references them,
	so we don't need an extra pass
	to collect the first case class tags, which are (temporarily) assigned to
	each closed PIC's methodObject field.
	But we do need to reset the methodObject fields to zero. This is done in
	createPICData:, unless memory
	runs out, in which case it is done by cleanUpFailingCogCodeConstituents:. */

	/* Cogit>>#cogCodeConstituents: */
sqInt
cogCodeConstituents(sqInt withDetails)
{
    CogMethod *cogMethod;
    sqInt constituents;
    sqInt count;
    sqInt i;
    sqInt label;
    sqInt profileData;
    sqInt value;

	/* + 3 for start, freeStart and end */
	count = (trampolineTableIndex / 2) + 3;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			count += 1;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	constituents = instantiateClassindexableSize(classArray(), count * 2);
	if (!constituents) {
		return constituents;
	}
	pushRemappableOop(constituents);
	if ((!((label = stringForCString("CogCode"))))
	 || (!((value = positive64BitIntegerFor(codeBase))))) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(0, constituents, label);
	storePointerUncheckedofObjectwithValue(1, constituents, value);
	for (i = 0; i < trampolineTableIndex; i += 2) {
		if ((!((label = stringForCString(trampolineAddresses[i]))))
		 || (!((value = positive64BitIntegerFor(((usqInt)(trampolineAddresses[i + 1]))))))) {
			popRemappableOop();
			return null;
		}
		storePointerUncheckedofObjectwithValue(2 + i, constituents, label);
		storePointerUncheckedofObjectwithValue(3 + i, constituents, value);
	}
	count = trampolineTableIndex + 2;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			profileData = /* profileDataFor:withDetails: */
					(((cogMethod->cmType)) >= CMMethod
						? (cogMethod->methodObject)
						: (withDetails
						 && (((cogMethod->cmType)) == CMClosedPIC)
								? createCPICData(cogMethod)
								: (cogMethod->selector)));
			if (!profileData) {
				return cleanUpFailingCogCodeConstituents(cogMethod);
			}
			storePointerUncheckedofObjectwithValue(count, constituents, profileData);
			value = (withDetails
						? collectCogMethodConstituent(cogMethod)
						: positive64BitIntegerFor(((usqInt)cogMethod)));
			if (!value) {
				return cleanUpFailingCogCodeConstituents(cogMethod);
			}
			storePointerUncheckedofObjectwithValue(count + 1, constituents, value);
			count += 2;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if ((!((label = stringForCString("CCFree"))))
	 || (!((value = positive64BitIntegerFor(mzFreeStart))))) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(count, constituents, label);
	storePointerUncheckedofObjectwithValue(count + 1, constituents, value);
	if ((!((label = stringForCString("CCEnd"))))
	 || (!((value = positive64BitIntegerFor(limitAddress))))) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(count + 2, constituents, label);
	storePointerUncheckedofObjectwithValue(count + 3, constituents, value);
	constituents = popRemappableOop();
	beRootIfOld(constituents);
	return constituents;
}


/*	Extend the cPIC with the supplied case. If caseNMethod is cogged dispatch
	direct to
	its unchecked entry-point. If caseNMethod is not cogged, jump to the fast
	interpreter dispatch, and if isMNUCase then dispatch to fast MNU
	invocation and mark the cPIC as
	having the MNU case for cache flushing. */

	/* Cogit>>#cogExtendPIC:CaseNMethod:tag:isMNUCase: */
static NoDbgRegParms void
cogExtendPICCaseNMethodtagisMNUCase(CogMethod *cPIC, sqInt caseNMethod, sqInt caseNTag, sqInt isMNUCase)
{
    sqInt address;
    usqInt addressFollowingJump;
    unsigned int codeInstruction;
    unsigned int dataInstruction;
    usqInt jumpTargetAddr;
    sqInt operand;
    sqInt target;

	compilationBreakpointclassTagisMNUCase((cPIC->selector), caseNTag, isMNUCase);
	assert(!(inlineCacheTagIsYoung(caseNTag)));
	assert((caseNMethod)
	 && (!(isYoung(caseNMethod))));
	if ((!isMNUCase)
	 && (methodHasCogMethod(caseNMethod))) {

		/* this isn't an MNU and we have an already cogged method to jump to */
		operand = 0;
		target = (((sqInt)(cogMethodOf(caseNMethod)))) + cmNoCheckEntryOffset;
	}
	else {
		operand = caseNMethod;
		if (isMNUCase) {

			/* this is an MNU so tag the CPIC header and setup a jump to the MNUAbort */
			/* cpicHasMNUCase: */
			((((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta)))->cpicHasMNUCaseOrCMIsFullBlock) = 1;
			target = (((sqInt)cPIC)) + (sizeof(CogMethod));
		}
		else {

			/* setup a jump to the interpretAborth so we can cog the target method */
			target = (((sqInt)cPIC)) + (picInterpretAbortOffset());
		}
	}
	address = addressOfEndOfCaseinCPIC(((cPIC->cPICNumCases)) + 1, cPIC);
	rewriteCPICCaseAttagobjReftarget(address, caseNTag, operand, target);

	/* begin rewriteCPIC:caseJumpTo: */
	addressFollowingJump = (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd));
	jumpTargetAddr = address - cPICCaseSize;

	/* begin rewriteCPICJumpAt:target: */
	rewriteImm19JumpBeforetarget(((AbstractInstruction *) backEnd), addressFollowingJump, jumpTargetAddr);
	((((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta)))->cPICNumCases = ((cPIC->cPICNumCases)) + 1);

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) (((usqInt)cPIC))), ((((usqInt)cPIC)) + closedPICSize) - (((usqInt)cPIC)));
	sys_icache_invalidate(((void *) (((usqInt)cPIC))), ((((usqInt)cPIC)) + closedPICSize) - (((usqInt)cPIC)));
#  else // __APPLE__ && __MACH__
	ceFlushICache(((usqInt)cPIC), (((usqInt)cPIC)) + closedPICSize);
#  endif

	(((usqInt)cPIC)) + closedPICSize;

	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	/* begin assertCoherentCodeAt:delta: */
	codeInstruction = long32At((((usqInt)cPIC)) + cmNoCheckEntryOffset);
	dataInstruction = long32At(((((usqInt)cPIC)) + cmNoCheckEntryOffset) + codeToDataDelta);
	assert(codeInstruction == dataInstruction);
#  endif // DUAL_MAPPED_CODE_ZONE
}


/*	Attempt to produce a machine code method for the bytecode method
	object aMethodObj. N.B. If there is no code memory available do *NOT*
	attempt to reclaim the method zone. Certain clients (e.g. ceSICMiss:)
	depend on the zone remaining constant across method generation. */

	/* Cogit>>#cogFullBlockMethod:numCopied: */
CogMethod *
cogFullBlockMethodnumCopied(sqInt aMethodObj, sqInt numCopied)
{
    CogMethod *cogMethod;

	assert(!((methodHasCogMethod(aMethodObj))));
	if (aMethodObj == breakMethod) {
		haltmsg("Compilation of breakMethod");
	}
	ensureNoForwardedLiteralsIn(aMethodObj);
	if (methodUsesAlternateBytecodeSet(aMethodObj)) {
		if ((numElementsIn(generatorTable)) <= 0x100) {
			return null;
		}
		bytecodeSetOffset = 0x100;
	}
	else {
		bytecodeSetOffset = 0;
	}
	assert(isFullBlockMethod(aMethodObj));
	methodObj = aMethodObj;
	methodHeader = methodHeaderOf(aMethodObj);

	/* lazy initialization */
	receiverTags = -1;
	cogMethod = compileCogFullBlockMethod(numCopied);
	if ((((((sqInt)cogMethod)) >= MaxNegativeErrorCode) && ((((sqInt)cogMethod)) <= -1))) {
		if ((((sqInt)cogMethod)) == InsufficientCodeSpace) {
			callForCogCompiledCodeCompaction();
		}
		return null;
	}
	return cogMethod;
}

	/* Cogit>>#cogitPostGCAction: */
void
cogitPostGCAction(sqInt gcMode)
{
	if (gcMode == GCModeBecome) {
		followForwardedLiteralsInOpenPICList();
	}
	assert(allMethodsHaveCorrectHeader());
	assert(((!(gcMode & (GCModeFull + GCModeNewSpace))))
	 || (kosherYoungReferrers()));

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}


/*	Check that the header fields onf a non-free method are consistent with
	the type. Answer 0 if it is ok, otherwise answer a code for the error. */

	/* Cogit>>#cogMethodDoesntLookKosher: */
static NoDbgRegParms sqInt
cogMethodDoesntLookKosher(CogMethod *cogMethod)
{
	if (((((cogMethod->blockSize)) & (BytesPerWord - 1)) != 0)
	 || ((((cogMethod->blockSize)) < (sizeof(CogMethod)))
	 || (((cogMethod->blockSize)) >= 0x8000))) {
		return 1;
	}
	if (((cogMethod->cmType)) == CMFree) {
		return 2;
	}
	if (((cogMethod->cmType)) >= CMMethod) {
		if (!((((((cogMethod->methodHeader))) & 7) == 1))) {
			return 11;
		}
		if (!(couldBeObject((cogMethod->methodObject)))) {
			return 12;
		}
		if ((((cogMethod->stackCheckOffset)) > 0)
		 && (((cogMethod->stackCheckOffset)) < cmNoCheckEntryOffset)) {
			return 13;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		if (((cogMethod->blockSize)) != openPICSize) {
			return 21;
		}
		if ((cogMethod->methodHeader)) {
			return 22;
		}
		if (((cogMethod->objectHeader)) >= 0) {
			if (!((((cogMethod->methodObject)) == 0)
				 || (compactionInProgress
				 || (((cogMethod->methodObject)) == (((usqInt)(methodFor(((void *)((cogMethod->methodObject))))))))))) {
				return 23;
			}
		}
		if ((cogMethod->stackCheckOffset)) {
			return 24;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		if (((cogMethod->blockSize)) != closedPICSize) {
			return 0x1F;
		}
		if (!(((((cogMethod->cPICNumCases)) >= 1) && (((cogMethod->cPICNumCases)) <= MaxCPICCases)))) {
			return 32;
		}
		if ((cogMethod->methodHeader)) {
			return 33;
		}
		if ((cogMethod->methodObject)) {
			return 34;
		}
		return 0;
	}
	return 9;
}


/*	Attempt to create a one-case PIC for an MNU.
	The tag for the case is at the send site and so doesn't need to be
	generated. 
 */

	/* Cogit>>#cogMNUPICSelector:receiver:methodOperand:numArgs: */
CogMethod *
cogMNUPICSelectorreceivermethodOperandnumArgs(sqInt selector, sqInt rcvr, sqInt methodOperand, sqInt numArgs)
{
    CogMethod *actualPIC;
    unsigned int codeInstruction;
    unsigned int dataInstruction;
    usqInt startAddress;
    CogMethod *writablePIC;

	if ((isYoung(selector))
	 || ((inlineCacheTagForInstance(rcvr)) == 0 /* picAbortDiscriminatorValue */)) {
		return 0;
	}
	compilationBreakpointclassTagisMNUCase(selector, fetchClassTagOf(rcvr), 1);
	assert(endCPICCase0);
	startAddress = allocate(closedPICSize);
	if (!startAddress) {
		callForCogCompiledCodeCompaction();
		return 0;
	}
	maybeBreakGeneratingFromto(startAddress, startAddress + closedPICSize);

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE


	/* memcpy the prototype across to our allocated space; because anything else would be silly */
	writablePIC = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	codeMemcpy(writablePIC, cPICPrototype, closedPICSize);

	/* begin fillInCPICHeader:numArgs:numCases:hasMNUCase:selector: */
	assert(!(isYoung(selector)));
	(writablePIC->cmType = CMClosedPIC);
	(writablePIC->objectHeader = 0);
	(writablePIC->blockSize = closedPICSize);
	(writablePIC->methodObject = 0);
	(writablePIC->methodHeader = 0);
	(writablePIC->selector = selector);
	(writablePIC->cmNumArgs = numArgs);
	(writablePIC->cmHasMovableLiteral = 0);
	(writablePIC->cmRefersToYoung = 0);
	(writablePIC->cmUsageCount = CMMaxUsageCount / 2);

	/* cpicHasMNUCase: */
	(writablePIC->cpicHasMNUCaseOrCMIsFullBlock) = 1;
	(writablePIC->cPICNumCases = 1);
	(writablePIC->blockEntryOffset = 0);
	assert(isCMClosedPIC(((CogBlockMethod *) writablePIC)));
	assert(((writablePIC->selector)) == selector);
	assert(((writablePIC->cmNumArgs)) == numArgs);
	assert(((writablePIC->cPICNumCases)) == 1);
	assert(closedPICSize == (roundUpLength(closedPICSize)));
	configureMNUCPICmethodOperandnumArgsdelta((actualPIC = ((CogMethod *) startAddress)), methodOperand, numArgs, startAddress - (((usqInt)cPICPrototype)));

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) startAddress), (startAddress + closedPICSize) - startAddress);
	sys_icache_invalidate(((void *) startAddress), (startAddress + closedPICSize) - startAddress);
#  else // __APPLE__ && __MACH__
	ceFlushICache(startAddress, startAddress + closedPICSize);
#  endif

	assert((callTargetFromReturnAddress(backEnd, startAddress + missOffset)) == (picAbortTrampolineFor(numArgs)));

	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	/* begin assertCoherentCodeAt:delta: */
	codeInstruction = long32At(startAddress + cmNoCheckEntryOffset);
	dataInstruction = long32At((startAddress + cmNoCheckEntryOffset) + codeToDataDelta);
	assert(codeInstruction == dataInstruction);
#  endif // DUAL_MAPPED_CODE_ZONE

	return actualPIC;
}


/*	Create an Open PIC. Temporarily create a direct call of
	ceSendFromOpenPIC:. Should become a probe of the first-level method lookup
	cache followed by a
	call of ceSendFromOpenPIC: if the probe fails. */

	/* Cogit>>#cogOpenPICSelector:numArgs: */
static NoDbgRegParms CogMethod *
cogOpenPICSelectornumArgs(sqInt selector, sqInt numArgs)
{
    unsigned int codeInstruction;
    sqInt codeSize;
    unsigned int dataInstruction;
    sqInt end;
    sqInt fixupSize;
    sqInt mapSize;
    sqInt opcodeSize;
    CogMethod *pic;
    usqInt startAddress;

	compilationBreakpointisMNUCase(selector, 0);
	startAddress = allocate(openPICSize);
	if (!startAddress) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	(methodLabel->address = startAddress);
	(methodLabel->dependent = null);

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 100;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	compileOpenPICnumArgs(selector, numArgs);
	computeMaximumSizes();
	concretizeAt(methodLabel, startAddress);
	codeSize = generateInstructionsAt(startAddress + (sizeof(CogMethod)));

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	mapSize = generateMapAtstart((startAddress + openPICSize) - 1, startAddress + cmNoCheckEntryOffset);
	assert((((entry->address)) - startAddress) == cmEntryOffset);
	assert(((roundUpLength((sizeof(CogMethod)) + codeSize)) + (roundUpLength(mapSize))) <= openPICSize);
	end = outputInstructionsAt(startAddress + (sizeof(CogMethod)));
	pic = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));

	/* begin fillInOPICHeader:numArgs:selector: */
	(pic->cmType = CMOpenPIC);
	(pic->objectHeader = 0);
	(pic->blockSize = openPICSize);
	addToOpenPICList(pic);
	(pic->methodHeader = 0);
	(pic->selector = selector);
	(pic->cmNumArgs = numArgs);
	(pic->cmHasMovableLiteral = isNonImmediate(selector));
	if ((pic->cmRefersToYoung = isYoung(selector))) {
		addToYoungReferrers(pic);
	}
	(pic->cmUsageCount = initialOpenPICUsageCount());

	/* cpicHasMNUCase: */
	(pic->cpicHasMNUCaseOrCMIsFullBlock) = 0;
	(pic->cPICNumCases = 0);
	(pic->blockEntryOffset = 0);

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) ((((usqInt)pic)) - codeToDataDelta)), (((((usqInt)pic)) - codeToDataDelta) + openPICSize) - ((((usqInt)pic)) - codeToDataDelta));
	sys_icache_invalidate(((void *) ((((usqInt)pic)) - codeToDataDelta)), (((((usqInt)pic)) - codeToDataDelta) + openPICSize) - ((((usqInt)pic)) - codeToDataDelta));
#  else // __APPLE__ && __MACH__
	ceFlushICache((((usqInt)pic)) - codeToDataDelta, ((((usqInt)pic)) - codeToDataDelta) + openPICSize);
#  endif

	assert(isCMOpenPIC(((CogBlockMethod *) pic)));
	assert(((pic->selector)) == selector);
	assert(((pic->cmNumArgs)) == numArgs);
	assert((callTargetFromReturnAddress(backEnd, ((((sqInt)pic)) - codeToDataDelta) + missOffset)) == (picAbortTrampolineFor(numArgs)));
	assert(openPICSize == (roundUpLength(openPICSize)));
	((((usqInt)pic)) - codeToDataDelta) + openPICSize;

	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	/* begin assertCoherentCodeAt:delta: */
	codeInstruction = long32At(((((usqInt)pic)) - codeToDataDelta) + cmNoCheckEntryOffset);
	dataInstruction = long32At((((((usqInt)pic)) - codeToDataDelta) + cmNoCheckEntryOffset) + codeToDataDelta);
	assert(codeInstruction == dataInstruction);
#  endif // DUAL_MAPPED_CODE_ZONE

	return ((CogMethod *) startAddress);
}


/*	Attempt to create a two-case PIC for case0CogMethod and
	case1Method,case1Tag. The tag for case0CogMethod is at the send site and
	so doesn't need to be generated.
	case1Method may be any of
	- a Cog method; link to its unchecked entry-point
	- a CompiledMethod; link to ceInterpretMethodFromPIC:
	- a CompiledMethod; link to ceMNUFromPICMNUMethod:receiver: */

	/* Cogit>>#cogPICSelector:numArgs:Case0Method:Case1Method:tag:isMNUCase: */
static NoDbgRegParms CogMethod *
cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase(sqInt selector, sqInt numArgs, CogMethod *case0CogMethod, sqInt case1MethodOrNil, sqInt case1Tag, sqInt isMNUCase)
{
    CogMethod *actualPIC;
    usqInt startAddress;
    CogMethod *writablePIC;

	if (isYoung(selector)) {
		return ((CogMethod *) YoungSelectorInPIC);
	}
	compilationBreakpointclassTagisMNUCase(selector, case1Tag, isMNUCase);
	startAddress = allocate(closedPICSize);
	if (!startAddress) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	maybeBreakGeneratingFromto(startAddress, startAddress + closedPICSize);

	/* memcpy the prototype across to our allocated space; because anything else would be silly */
	writablePIC = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	codeMemcpy(writablePIC, cPICPrototype, closedPICSize);

	/* begin fillInCPICHeader:numArgs:numCases:hasMNUCase:selector: */
	assert(!(isYoung(selector)));
	(writablePIC->cmType = CMClosedPIC);
	(writablePIC->objectHeader = 0);
	(writablePIC->blockSize = closedPICSize);
	(writablePIC->methodObject = 0);
	(writablePIC->methodHeader = 0);
	(writablePIC->selector = selector);
	(writablePIC->cmNumArgs = numArgs);
	(writablePIC->cmHasMovableLiteral = 0);
	(writablePIC->cmRefersToYoung = 0);
	(writablePIC->cmUsageCount = CMMaxUsageCount / 2);

	/* cpicHasMNUCase: */
	(writablePIC->cpicHasMNUCaseOrCMIsFullBlock) = isMNUCase;
	(writablePIC->cPICNumCases = 2);
	(writablePIC->blockEntryOffset = 0);
	assert(isCMClosedPIC(((CogBlockMethod *) writablePIC)));
	assert(((writablePIC->selector)) == selector);
	assert(((writablePIC->cmNumArgs)) == numArgs);
	assert(((writablePIC->cPICNumCases)) == 2);
	assert(closedPICSize == (roundUpLength(closedPICSize)));
	configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta((actualPIC = ((CogMethod *) startAddress)), case0CogMethod, case1MethodOrNil, case1Tag, isMNUCase, numArgs, startAddress - (((usqInt)cPICPrototype)));
	assert((callTargetFromReturnAddress(backEnd, startAddress + missOffset)) == (picAbortTrampolineFor(numArgs)));
	return actualPIC;
}


/*	Attempt to produce a machine code method for the bytecode method
	object aMethodObj. N.B. If there is no code memory available do *NOT*
	attempt to reclaim the method zone. Certain clients (e.g. ceSICMiss:)
	depend on the zone remaining constant across method generation. */

	/* Cogit>>#cog:selector: */
CogMethod *
cogselector(sqInt aMethodObj, sqInt aSelectorOop)
{
    CogMethod *cogMethod;
    sqInt selector;

	assert(!((methodHasCogMethod(aMethodObj))));

	/* coInterpreter stringOf: selector */
	selector = (aSelectorOop == (nilObject())
				? maybeSelectorOfMethod(aMethodObj)
				: aSelectorOop);
	if (selector) {
		compilationBreakpointisMNUCase(selector, 0);
	}
	if (aMethodObj == breakMethod) {
		haltmsg("Compilation of breakMethod");
	}
	ensureNoForwardedLiteralsIn(aMethodObj);
	if (methodUsesAlternateBytecodeSet(aMethodObj)) {
		if ((numElementsIn(generatorTable)) <= 0x100) {
			return null;
		}
		bytecodeSetOffset = 0x100;
	}
	else {
		bytecodeSetOffset = 0;
	}
	assert(!((isFullBlockMethod(aMethodObj))));
	methodObj = aMethodObj;
	methodHeader = methodHeaderOf(aMethodObj);

	/* lazy initialization */
	receiverTags = -1;
	cogMethod = compileCogMethod(aSelectorOop);
	if ((((((sqInt)cogMethod)) >= MaxNegativeErrorCode) && ((((sqInt)cogMethod)) <= -1))) {
		if ((((sqInt)cogMethod)) == InsufficientCodeSpace) {
			callForCogCompiledCodeCompaction();
		}
		return null;
	}
	return cogMethod;
}

	/* Cogit>>#collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method: */
static NoDbgRegParms sqInt
collectCogConstituentForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg)
{
    sqInt address;
    sqInt annotation;
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt *sendTable1;
    CogMethod *targetMethod1;

	if (!descriptor) {
		return 0;
	}
	if (!((descriptor->isMapped))) {
		return 0;
	}
	address = positive64BitIntegerFor(((usqInt)mcpc));
	if (!address) {
		return PrimErrNoMemory;
	}
	storePointerUncheckedofObjectwithValue(cogConstituentIndex, topRemappableOop(), address);
	storePointerUncheckedofObjectwithValue(cogConstituentIndex + 1, topRemappableOop(), (((usqInt)bcpc << 3) | 1));

	/* Collect any first case classTags for closed PICs. */
	cogConstituentIndex += 2;
	if (((!(isBackwardBranchAndAnnotation & 1)))
	 && (/* isSendAnnotation: */
		((((usqInt)(isBackwardBranchAndAnnotation)) >> 1) >= IsSendCall))) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* send is linked */
			annotation = ((usqInt)(isBackwardBranchAndAnnotation)) >> 1;

			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));
			if (((targetMethod1->cmType)) == CMClosedPIC) {
				(targetMethod1->methodObject = classForInlineCacheTag(inlineCacheTagAt(backEnd, ((sqInt)mcpc))));
			}
		}
	}
	return 0;
}


/*	Answer a description of the mapping between machine code pointers and
	bytecode pointers for the Cog Method.
	First value is the address of the cog method.
	Following values are pairs of machine code pc and bytecode pc */

	/* Cogit>>#collectCogMethodConstituent: */
static NoDbgRegParms sqInt
collectCogMethodConstituent(CogMethod *cogMethod)
{
    sqInt address;
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    CogBlockMethod *cogBlockMethod;
    sqInt data;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    sqInt errCode;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    usqInt isInBlock;
    sqInt latestContinuation;
    sqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt nSlots;
    sqInt result;
    sqInt startbcpc;
    sqInt targetPC;

	if (!(((cogMethod->cmType)) >= CMMethod)) {
		return positive64BitIntegerFor(((usqInt)cogMethod));
	}
	cogBlockMethod = ((CogBlockMethod *) cogMethod);
	if (!((cogBlockMethod->stackCheckOffset))) {

		/* isFrameless ? */
		return positive64BitIntegerFor(((usqInt)cogMethod));
	}

	/* +1 for first address */
	nSlots = ((((byteSizeOf((cogMethod->methodObject))) - (startPCOfMethodHeader((cogMethod->methodHeader)))) * 2) + (minSlotsForShortening())) + 1;
	data = instantiateClassindexableSize(splObj(ClassArray), nSlots);
	if (!data) {
		return null;
	}
	pushRemappableOop(data);
	address = positive64BitIntegerFor(((usqInt)cogMethod));
	if (!address) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(0, topRemappableOop(), address);
	cogConstituentIndex = 1;
	startbcpc = startPCOfMethod((cogMethod->methodObject));

	/* begin mapFor:bcpc:performUntil:arg: */
	descriptor = ((BytecodeDescriptor *) 0);
	latestContinuation = 0;
	mapByte = 0;
	nextBcpc = 0;
	assert(((cogBlockMethod->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)cogBlockMethod)) + ((cogBlockMethod->stackCheckOffset));
	result = collectCogConstituentForAnnotationMcpcBcpcMethod(null, 0 + ((((usqInt)(HasBytecodePC) << 1))), ((char *) mcpc), startbcpc, ((void *)cogMethod));
	if (result) {
		errCode = result;
		goto l1;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if (((cogBlockMethod->cmType)) >= CMMethod) {
		isInBlock = (cogBlockMethod->cpicHasMNUCaseOrCMIsFullBlock);
		homeMethod = ((CogMethod *) cogBlockMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;

		/* If the method has a primitive, skip it and the error code store, if any;
		   Logically. these come before the stack check and so must be ignored. */
		bsOffset = /* begin bytecodeSetOffsetForHeader: */
				(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
					? 0x100
					: 0);
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == ((cogBlockMethod->startpc)));
		homeMethod = cmHomeMethod(cogBlockMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogBlockMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - (/* begin blockCreationBytecodeSizeForHeader: */
	(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
		? AltBlockCreationBytecodeSize
		: BlockCreationBytecodeSize));
		bsOffset = /* begin bytecodeSetOffsetForHeader: */
				(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
					? 0x100
					: 0);
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj)
		: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	enumeratingCogMethod = homeMethod;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							errCode = 0;
							goto l1;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							errCode = 0;
							goto l1;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)
		: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
								? nExts + 1
								: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
					 && ((/* begin isBackwardBranch:at:exts:in: */
						assert(((descriptor->spanFunction))),
					(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = collectCogConstituentForAnnotationMcpcBcpcMethod(descriptor, (isBackwardBranch
							? ((((usqInt)(annotation) << 1))) + 1
							: ((sqInt)((usqInt)(annotation) << 1))), ((char *) mcpc), (isBackwardBranch
							? bcpc - (2 * nExts)
							: bcpc), ((void *)cogMethod));
				if (result) {
					errCode = result;
					goto l1;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
							? nExts + 1
							: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
			}
		}
		map -= 1;
	}
	errCode = 0;
l1:	/* end mapFor:bcpc:performUntil:arg: */;
	if (errCode) {
		popRemappableOop();
		return null;
	}
	if (cogConstituentIndex < nSlots) {
		shortentoIndexableSize(topRemappableOop(), cogConstituentIndex);
	}
	return popRemappableOop();
}

	/* Cogit>>#compactCogCompiledCode */
void
compactCogCompiledCode(void)
{
    sqInt endAddress;

	assertValidDualZone();
	assert(noCogMethodsMaximallyMarked());
	moveProfileToMethods();

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	markActiveMethodsAndReferents();
	freeOlderMethodsForCompaction();
	compactPICsWithFreedTargets();
	planCompaction();
	updateStackZoneReferencesToCompiledCodePreCompaction();
	relocateMethodsPreCompaction();
	assertValidDualZone();
	compactCompiledCode();
	stopsFromto(backEnd, freeStart(), (youngReferrers) - 1);
	endAddress = ((usqInt)(youngReferrers));

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
	sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#  else // __APPLE__ && __MACH__
	ceFlushICache(((usqInt)methodZoneBase), endAddress);
#  endif

	assert(allMethodsHaveCorrectHeader());
	assert(kosherYoungReferrers());
	assertValidDualZone();
}

	/* Cogit>>#compactPICsWithFreedTargets */
static void
compactPICsWithFreedTargets(void)
{
    CogMethod *cogMethod;
    sqInt count;

	cogMethod = ((CogMethod *) methodZoneBase);
	count = 0;
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) == CMClosedPIC)
		 && (cPICCompactAndIsNowEmpty(cogMethod))) {
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMFree);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		count += 1;
	}
	assert(count == (numMethods()));
}


/*	The start of a CogMethod has a call to a run-time abort routine that
	either handles an in-line cache failure or a stack overflow. The routine
	selects the
	path depending on ReceiverResultReg; if zero it takes the stack overflow
	path; if nonzero the in-line cache miss path. Neither of these paths
	returns. The abort routine must be called; In the callee the method is
	located by
	adding the relevant offset to the return address of the call.
	
	N.B. This code must match that in compilePICAbort: so that the offset of
	the return address of the call is the same in methods and closed PICs. */

	/* Cogit>>#compileAbort */
static AbstractInstruction *
compileAbort(void)
{
    AbstractInstruction *anInstruction;
    sqInt callTarget;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	stackOverflowCall = anInstruction;
	sendMiss = genoperand(PushR, LinkReg);
	callTarget = methodAbortTrampolineFor(methodOrBlockNumArgs);

	/* begin Call: */
	return genoperand(Call, callTarget);
}

	/* Cogit>>#compileBlockDispatchFrom:to: */
static NoDbgRegParms sqInt
compileBlockDispatchFromto(sqInt lowBlockStartIndex, sqInt highBlockStartIndex)
{
    AbstractInstruction *anInstruction;
    BlockStart *blockStart;
    sqInt halfWay;
    AbstractInstruction *jmp;
    sqInt quickConstant;

	if (lowBlockStartIndex == highBlockStartIndex) {
		blockStart = blockStartAt(lowBlockStartIndex);

		/* Jump: */
		genoperand(Jump, ((sqInt)((blockStart->entryLabel))));
		return null;
	}
	halfWay = (highBlockStartIndex + lowBlockStartIndex) / 2;
	assert(((halfWay >= lowBlockStartIndex) && (halfWay <= highBlockStartIndex)));

	/* N.B. FLAGS := TempReg - startpc */
	blockStart = blockStartAt(halfWay);
	quickConstant = (((usqInt)(((blockStart->startpc)) + 1) << 3) | 1);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	if (lowBlockStartIndex == halfWay) {
		/* JumpLessOrEqual: */
		genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)((blockStart->entryLabel))));
		compileBlockDispatchFromto(halfWay + 1, highBlockStartIndex);
		return null;
	}
	if ((halfWay + 1) == highBlockStartIndex) {
		blockStart = blockStartAt(highBlockStartIndex);

		/* JumpGreater: */
		genConditionalBranchoperand(JumpGreater, ((sqInt)((blockStart->entryLabel))));
		return compileBlockDispatchFromto(lowBlockStartIndex, halfWay);
	}
	jmp = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	compileBlockDispatchFromto(lowBlockStartIndex, halfWay);
	if (halfWay == highBlockStartIndex) {
		blockStart = blockStartAt(highBlockStartIndex);
		jmpTarget(jmp, (blockStart->entryLabel));
	}
	else {
		jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileBlockDispatchFromto(halfWay + 1, highBlockStartIndex);
	}
	return 0;
}


/*	Compile a block's entry. This looks like a dummy CogBlockMethod header
	(for frame parsing)
	followed by either a frame build, if a frame is required, or nothing. The
	CogMethodHeader's objectHeader field is a back pointer to the method, but
	this can't be filled in until code generation. */

	/* Cogit>>#compileBlockEntry: */
static NoDbgRegParms void
compileBlockEntry(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    sqInt alignment;

	alignment = blockAlignment();

	/* begin AlignmentNops: */
	genoperand(AlignmentNops, alignment);
	(blockStart->fakeHeader = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	switch (sizeof(CogBlockMethod)) {
	case 8:
		/* Fill32: */
		genoperand(Fill32, 0);

		/* Fill32: */
		genoperand(Fill32, 0);
		break;
	case 12:
		/* Fill32: */
		genoperand(Fill32, 0);

		/* Fill32: */
		genoperand(Fill32, 0);

		/* Fill32: */
		genoperand(Fill32, 0);
		break;
	case 16:
		/* Fill32: */
		genoperand(Fill32, 0);

		/* Fill32: */
		genoperand(Fill32, 0);

		/* Fill32: */
		genoperand(Fill32, 0);

		/* Fill32: */
		genoperand(Fill32, 0);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	(blockStart->entryLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (needsFrame) {
		compileBlockFrameBuild(blockStart);
		if (recordBlockTrace()) {
			/* begin CallRT: */
			abstractInstruction = genoperand(Call, ceTraceBlockActivationTrampoline);
			(abstractInstruction->annotation = IsRelativeCall);
		}
	}
	else {
		compileBlockFramelessEntry(blockStart);
	}
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. The encoding for constants is defined by
	trampolineArgConstant: & trampolineArgValue:. Pass a constant as the
	result of trampolineArgConstant:. */

	/* Cogit>>#compileCallFor:numArgs:arg:arg:arg:arg:floatResultReg:regsToSave: */
static NoDbgRegParms void
compileCallFornumArgsargargargargfloatResultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask)
{
    sqInt regsToSave;

	regsToSave = (resultRegOrNone == NoReg
				? regMask
				: ((regMask | (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))) - (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))));
	if (cStackAlignment > BytesPerWord) {
		/* genAlignCStackSavingRegisters:numArgs:wordAlignment: */
	}
	genSaveRegs(backEnd, regsToSave);
	genMarshallNArgsargargargarg(backEnd, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3);

	/* #CallFullRT: #CallFull: #gen:literal: */
	checkLiteralforInstruction(((usqInt)aRoutine), genoperand(CallFull, ((usqInt)aRoutine)));
	if (resultRegOrNone != NoReg) {
		cFloatResultToRd(backEnd, resultRegOrNone);
	}

	/* begin genRemoveNArgsFromStack: */
	assert(numArgs <= 6);
	genRestoreRegs(backEnd, regsToSave);
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. The encoding for constants is defined by
	trampolineArgConstant: & trampolineArgValue:. Pass a constant as the
	result of trampolineArgConstant:. */

	/* Cogit>>#compileCallFor:numArgs:arg:arg:arg:arg:resultReg:regsToSave: */
static NoDbgRegParms void
compileCallFornumArgsargargargargresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask)
{
    sqInt regsToSave;

	regsToSave = (resultRegOrNone == NoReg
				? regMask
				: ((regMask | (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))) - (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))));
	if (cStackAlignment > BytesPerWord) {
		/* genAlignCStackSavingRegisters:numArgs:wordAlignment: */
	}
	genSaveRegs(backEnd, regsToSave);
	genMarshallNArgsargargargarg(backEnd, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3);

	/* #CallFullRT: #CallFull: #gen:literal: */
	checkLiteralforInstruction(((usqInt)aRoutine), genoperand(CallFull, ((usqInt)aRoutine)));
	genWriteCResultIntoReg(backEnd, resultRegOrNone);

	/* begin genRemoveNArgsFromStack: */
	assert(numArgs <= 6);
	genRestoreRegs(backEnd, regsToSave);
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. */

	/* Cogit>>#compileCallFor:numArgs:floatArg:floatArg:floatArg:floatArg:resultReg:regsToSave: */
static NoDbgRegParms void
compileCallFornumArgsfloatArgfloatArgfloatArgfloatArgresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask)
{
    sqInt regsToSave;

	regsToSave = (resultRegOrNone == NoReg
				? regMask
				: ((regMask | (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))) - (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1ULL << resultRegOrNone)))));
	if (cStackAlignment > BytesPerWord) {
		/* genAlignCStackSavingRegisters:numArgs:wordAlignment: */
	}
	genSaveRegs(backEnd, regsToSave);
	genMarshallNArgsfloatArgfloatArgfloatArgfloatArg(backEnd, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3);

	/* #CallFullRT: #CallFull: #gen:literal: */
	checkLiteralforInstruction(((usqInt)aRoutine), genoperand(CallFull, ((usqInt)aRoutine)));
	genWriteCResultIntoReg(backEnd, resultRegOrNone);
	genRemoveNFloatArgsFromStack(backEnd, numArgs);
	genRestoreRegs(backEnd, regsToSave);
}


/*	Compile the cache tag computation and the first comparison. Answer the
	address of that comparison. */

	/* Cogit>>#compileCPICEntry */
static AbstractInstruction *
compileCPICEntry(void)
{
	entry = genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, TempReg, 1);

	/* begin CmpR:R: */
	assert(!(0 /* (ClassReg = SPReg) */));
	genoperandoperand(CmpRR, ClassReg, TempReg);
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}


/*	Compile the abstract instructions for the entire full block method. */

	/* Cogit>>#compileEntireFullBlockMethod: */
static NoDbgRegParms sqInt
compileEntireFullBlockMethod(sqInt numCopied)
{
    sqInt result;

	/* begin preenMethodLabel */
	/* setLabelOffset: */
	((methodLabel->operands))[1] = 0;
	compileFullBlockEntry();
	compileFullBlockMethodFrameBuild(numCopied);
	if (((result = compileMethodBody())) < 0) {
		return result;
	}
	assert(blockCount == 0);
	return 0;
}


/*	The entry code to a method checks that the class of the current receiver
	matches that in the inline cache. Other non-obvious elements are that its
	alignment must be
	different from the alignment of the noCheckEntry so that the method map
	machinery can distinguish normal and super sends (super sends bind to the
	noCheckEntry).  */

	/* Cogit>>#compileEntry */
static void
compileEntry(void)
{
    AbstractInstruction *inst;

	entry = genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, TempReg, 1);

	/* begin CmpR:R: */
	assert(!(0 /* (ClassReg = SPReg) */));
	genoperandoperand(CmpRR, ClassReg, TempReg);

	/* JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)sendMiss));
	noCheckEntry = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (((traceFlags & 64) == 64)) {
		/* begin saveAndRestoreLinkRegAround: */
		inst = genoperand(PushR, LinkReg);

		/* #CallFullRT: #CallFull: #gen:literal: */
		checkLiteralforInstruction(ceTraceLinkedSendTrampoline, genoperand(CallFull, ceTraceLinkedSendTrampoline));

		/* PopR: */
		genoperand(PopR, LinkReg);
	}
}


/*	Compile the abstract instructions for the entire method, including blocks. */
/*	Abort for stack overflow on full block activation (no inline cache miss
	possible). The flag is SendNumArgsReg. */

	/* Cogit>>#compileFullBlockEntry */
static sqInt
compileFullBlockEntry(void)
{
    AbstractInstruction *anInstruction;
    sqInt callTarget;
    AbstractInstruction *jumpNoContextSwitch;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	stackOverflowCall = anInstruction;

	/* PushR: */
	genoperand(PushR, LinkReg);
	callTarget = methodAbortTrampolineFor(methodOrBlockNumArgs);

	/* begin Call: */
	genoperand(Call, callTarget);
	anInstruction = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	fullBlockNoContextSwitchEntry = anInstruction;
	jumpNoContextSwitch = genoperand(Jump, ((sqInt)0));

	/* AlignmentNops: */
	genoperand(AlignmentNops, ((BytesPerWord < 8) ? 8 : BytesPerWord));
	fullBlockEntry = genoperandoperand(MoveRR, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jumpNoContextSwitch, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	Compile the top-level method body. */

	/* Cogit>>#compileMethodBody */
static sqInt
compileMethodBody(void)
{
	if (endPC < initialPC) {
		return 0;
	}
	return compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
}


/*	The start of a PIC has a call to a run-time abort routine that either
	handles a dispatch to an
	interpreted method or a dispatch of an MNU case. The routine selects the
	path by testing
	ClassReg, which holds the inline cache tag; if equal to the
	picAbortDiscriminatorValue (zero)
	it takes the MNU path; if nonzero the dispatch to interpreter path.
	Neither of these paths
	returns. The abort routine must be called; In the callee the PIC is
	located by adding the
	relevant offset to the return address of the call.
	
	N.B. This code must match that in compileAbort so that the offset of the
	return address of
	the call is the same in methods and closed PICs. */

	/* Cogit>>#compilePICAbort: */
static NoDbgRegParms sqInt
compilePICAbort(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    sqInt callTarget;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0 /* picAbortDiscriminatorValue */, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0 /* picAbortDiscriminatorValue */, BytesPerOop));
	}
	picMNUAbort = anInstruction;
	picInterpretAbort = genoperand(PushR, LinkReg);
	callTarget = picAbortTrampolineFor(numArgs);

	/* begin Call: */
	genoperand(Call, callTarget);
	return 0;
}


/*	Compile the compare of stackLimit against the stack pointer, jumping to
	the stackOverflowCall if
	the stack pointer is below the limit. Answer a bytecode annotated label
	that follows the sequence.
	
	The stack check functions both as a genuine stack limit check to prevent
	calls overflowing stack pages,
	and as an event/context-switch break out. To cause an event check
	(including a check for a required
	context switch), stackLimit is set to the highest possible value, and
	hence all stack limit checks will
	fail. A path in the stack overflow abort then arranges to call event
	checking if it has been requested.
	
	Certain block activations (e.g. valueNoContextSwitch:) must not context
	switch, and in that
	case, SendNumArgs is set to zero to communicate to the stack overflow
	abort that it should
	not perform event/context-switch (yet). */

	/* Cogit>>#compileStackOverflowCheck: */
static NoDbgRegParms AbstractInstruction *
compileStackOverflowCheck(sqInt canContextSwitch)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSkip;
    AbstractInstruction *label;

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(stackLimitAddress(), genoperandoperand(MoveAwR, stackLimitAddress(), TempReg));

	/* begin CmpR:R: */
	assert(!(0 /* (TempReg = SPReg) */));
	genoperandoperand(CmpRR, TempReg, SPReg);
	if (canContextSwitch) {
		/* JumpBelow: */
		genConditionalBranchoperand(JumpBelow, ((sqInt)stackOverflowCall));
		label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	else {
		jumpSkip = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* Jump: */
		genoperand(Jump, ((sqInt)stackOverflowCall));
		jmpTarget(jumpSkip, (label = genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	}

	/* begin annotateBytecode: */
	(label->annotation = HasBytecodePC);
	return label;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:floatResultReg: */
static NoDbgRegParms void
compileTrampolineFornumArgsargargargargregsToSavepushLinkRegfloatResultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsargargargargfloatResultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, regMask);
	genLoadStackPointers(backEnd);
	genTrampolineReturn(pushLinkReg);
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg: */
static NoDbgRegParms void
compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsargargargargresultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, regMask);
	genLoadStackPointers(backEnd);
	genTrampolineReturn(pushLinkReg);
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:floatArg:floatArg:floatArg:floatArg:regsToSave:pushLinkReg:resultReg: */
static NoDbgRegParms void
compileTrampolineFornumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsfloatArgfloatArgfloatArgfloatArgresultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, regMask);
	genLoadStackPointers(backEnd);
	genTrampolineReturn(pushLinkReg);
}


/*	Generate the entry code for a method to determine cmEntryOffset and
	cmNoCheckEntryOffset. We
	need cmNoCheckEntryOffset up front to be able to generate the map starting
	from cmNoCheckEntryOffset */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#computeEntryOffsets */
static void
computeEntryOffsets(void)
{
    sqInt fixupSize;
    sqInt opcodeSize;
    AbstractInstruction *sendMissCall;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 24;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	methodOrBlockNumArgs = 0;
	sendMissCall = compileAbort();
	compileEntry();
	computeMaximumSizes();
	generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	cmEntryOffset = ((entry->address)) - methodZoneBase;
	cmNoCheckEntryOffset = ((noCheckEntry->address)) - methodZoneBase;
	missOffset = (((sendMissCall->address)) + ((sendMissCall->machineCodeSize))) - methodZoneBase;
	entryPointMask = BytesPerWord - 1;
	while ((cmEntryOffset & entryPointMask) == (cmNoCheckEntryOffset & entryPointMask)) {
		entryPointMask = (entryPointMask + entryPointMask) + 1;
	}
	if (entryPointMask >= (roundUpToMethodAlignment(backEnd, 1))) {
		error("cannot differentiate checked and unchecked entry-points with current cog method alignment");
	}
	checkedEntryAlignment = cmEntryOffset & entryPointMask;
	uncheckedEntryAlignment = cmNoCheckEntryOffset & entryPointMask;
	assert(checkedEntryAlignment != uncheckedEntryAlignment);
}


/*	Generate the entry code for a method to determine cmEntryOffset and
	cmNoCheckEntryOffset. We
	need cmNoCheckEntryOffset up front to be able to generate the map starting
	from cmNoCheckEntryOffset */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#computeFullBlockEntryOffsets */
static void
computeFullBlockEntryOffsets(void)
{
    sqInt fixupSize;
    sqInt opcodeSize;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 24;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	methodOrBlockNumArgs = 0;
	compileFullBlockEntry();
	computeMaximumSizes();
	generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	cbEntryOffset = ((fullBlockEntry->address)) - methodZoneBase;
	cbNoSwitchEntryOffset = ((fullBlockNoContextSwitchEntry->address)) - methodZoneBase;
}


/*	While we order variables in the CoInterpreter in order of dynamic
	frequency, and hence
	expect that stackPointer will be output first, C optimizers and linkers
	may get their own
	ideas and ``improve upon'' this ordering. So we cannot depend on
	stackPointer being
	at the lowest address of the variables we want to access through
	VarBaseReg. Here we
	choose the minimum amongst a set to try to choose a varBaseAddress that is
	just less
	than but within range of all variables we want to access through it. */

	/* Cogit>>#computeGoodVarBaseAddress */
static usqInt
computeGoodVarBaseAddress(void)
{
    usqInt minAddress;

	/* stackLimit was e.g. lowest using the clang toolchain on MacOS X (prior to the use of variable_order) */
	minAddress = stackLimitAddress();
	if ((stackPointerAddress()) < minAddress) {
		minAddress = stackPointerAddress();
	}
	if ((framePointerAddress()) < minAddress) {
		minAddress = framePointerAddress();
	}
	if ((instructionPointerAddress()) < minAddress) {
		minAddress = instructionPointerAddress();
	}
	if ((argumentCountAddress()) < minAddress) {
		minAddress = argumentCountAddress();
	}
	if ((primFailCodeAddress()) < minAddress) {
		minAddress = primFailCodeAddress();
	}
	return minAddress;
}


/*	This pass assigns maximum sizes to all abstract instructions and
	eliminates jump fixups.
	It hence assigns the maximum address an instruction will occur at which
	allows the next
	pass to conservatively size jumps. */

	/* Cogit>>#computeMaximumSizes */
static void
computeMaximumSizes(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt relativeAddress;

	dumpLiterals(0);
	relativeAddress = 0;
	for (i = 0; i < opcodeIndex; i += 1) {
		maybeBreakGeneratingInstructionWithIndex(i);
		abstractInstruction = abstractInstructionAt(i);
		(abstractInstruction->address = relativeAddress);
		(abstractInstruction->maxSize = computeMaximumSize(abstractInstruction));
		relativeAddress += (abstractInstruction->maxSize);
	}
}


/*	Configure a copy of the prototype CPIC for a two-case PIC for 
	case0CogMethod and
	case1Method
	case1Tag.
	The tag for case0CogMethod is at the send site and so doesn't need to be
	generated. case1Method may be any of
	- a Cog method; jump to its unchecked entry-point
	- a CompiledMethod; jump to the ceInterpretFromPIC trampoline
	- nil; call ceMNUFromPIC
	addDelta is the address change from the prototype to the new CPIC
	location, needed
	because the loading of the CPIC label at the end may use a literal instead
	of a pc relative load. */
/*	self disassembleFrom: cPIC asInteger + (self sizeof: CogMethod) to: cPIC
	asInteger + closedPICSize
 */

	/* Cogit>>#configureCPIC:Case0:Case1Method:tag:isMNUCase:numArgs:delta: */
static NoDbgRegParms sqInt
configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(CogMethod *cPIC, CogMethod *case0CogMethod, sqInt case1Method, sqInt case1Tag, sqInt isMNUCase, sqInt numArgs, sqInt addrDelta)
{
    sqInt callTargetAddress;
    sqInt caseEndAddress;
    sqInt operand;
    sqInt pc;
    sqInt targetEntry;

	assert(case1Method);
	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + missOffset, picAbortTrampolineFor(numArgs));
	assert(!(inlineCacheTagIsYoung(case1Tag)));
	if ((!isMNUCase)
	 && (methodHasCogMethod(case1Method))) {
		operand = 0;
		targetEntry = (((sqInt)(cogMethodOf(case1Method)))) + cmNoCheckEntryOffset;
	}
	else {

		/* We do not scavenge PICs, hence we cannot cache the MNU method if it is in new space. */
		operand = ((!case1Method)
			 || (isYoungObject(case1Method))
					? 0
					: case1Method);
		targetEntry = (case1Method
					? (((sqInt)cPIC)) + (picInterpretAbortOffset())
					: (((sqInt)cPIC)) + (sizeof(CogMethod)));
	}

	/* rewriteJumpLongAt:target: */
	rewriteImm26JumpBeforetarget(backEnd, (((sqInt)cPIC)) + firstCPICCaseOffset, (((sqInt)case0CogMethod)) + cmNoCheckEntryOffset);

	/* update the cpic case */
	caseEndAddress = addressOfEndOfCaseinCPIC(2, cPIC);
	rewriteCPICCaseAttagobjReftarget(caseEndAddress, case1Tag, operand, ((sqInt)((isMNUCase
		? (((sqInt)cPIC)) + (sizeof(CogMethod))
		: targetEntry))));
	pc = ((((sqInt)cPIC)) + cPICEndOfCodeOffset) - (jumpLongByteSize(backEnd));

	/* begin relocateMethodReferenceBeforeAddress:by: */
	assert((instructionIsADR(((AbstractInstruction *) backEnd), instructionAt(((AbstractInstruction *) backEnd), pc - 4)))
	 || (instructionIsADR(((AbstractInstruction *) backEnd), instructionAt(((AbstractInstruction *) backEnd), pc - 8))));
	callTargetAddress = cPICMissTrampolineFor(numArgs);

	/* begin rewriteJumpLongAt:target: */
	rewriteImm26JumpBeforetarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + cPICEndOfCodeOffset, callTargetAddress);
	return 0;
}


/*	Configure a copy of the prototype CPIC for a one-case MNU CPIC that calls
	ceMNUFromPIC for
	case0Tag The tag for case0 is at the send site and so doesn't need to be
	generated. addDelta is the address change from the prototype to the new
	CPIC location, needed
	because the loading of the CPIC label at the end may be a literal instead
	of a pc-relative load. */
/*	adjust the jump at missOffset, the ceAbortXArgs */

	/* Cogit>>#configureMNUCPIC:methodOperand:numArgs:delta: */
static NoDbgRegParms sqInt
configureMNUCPICmethodOperandnumArgsdelta(CogMethod *cPIC, sqInt methodOperand, sqInt numArgs, sqInt addrDelta)
{
    usqInt addressFollowingJump;
    sqInt callTargetAddress;
    usqInt jumpTargetAddr;
    sqInt operand;
    sqInt pc;
    sqInt target;

	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + missOffset, picAbortTrampolineFor(numArgs));

	/* set the jump to the case0 method */
	operand = ((!methodOperand)
		 || (isYoungObject(methodOperand))
				? 0
				: methodOperand);
	callTargetAddress = (((sqInt)cPIC)) + (sizeof(CogMethod));

	/* begin rewriteJumpLongAt:target: */
	rewriteImm26JumpBeforetarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + firstCPICCaseOffset, callTargetAddress);
	storeLiteralbeforeFollowingAddress(backEnd, operand, ((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd)));
	callTargetAddress = cPICMissTrampolineFor(numArgs);

	/* begin rewriteJumpLongAt:target: */
	rewriteImm26JumpBeforetarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + cPICEndOfCodeOffset, callTargetAddress);
	pc = ((((sqInt)cPIC)) + cPICEndOfCodeOffset) - (jumpLongByteSize(backEnd));

	/* begin relocateMethodReferenceBeforeAddress:by: */
	assert((instructionIsADR(((AbstractInstruction *) backEnd), instructionAt(((AbstractInstruction *) backEnd), pc - 4)))
	 || (instructionIsADR(((AbstractInstruction *) backEnd), instructionAt(((AbstractInstruction *) backEnd), pc - 8))));
	target = addressOfEndOfCaseinCPIC(2, cPIC);

	/* begin rewriteCPIC:caseJumpTo: */
	addressFollowingJump = (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd));
	jumpTargetAddr = target;

	/* begin rewriteCPICJumpAt:target: */
	rewriteImm19JumpBeforetarget(((AbstractInstruction *) backEnd), addressFollowingJump, jumpTargetAddr);
	return 0;
}


/*	Scan the CPIC for target methods that have been freed and eliminate them.
	Since the first entry cannot be eliminated, answer that the PIC should be
	freed if the first entry is to a free target. Answer if the PIC is now
	empty or should be freed. */

	/* Cogit>>#cPICCompactAndIsNowEmpty: */
static NoDbgRegParms sqInt
cPICCompactAndIsNowEmpty(CogMethod *cPIC)
{
    usqInt addressFollowingJump;
    sqInt entryPoint;
    sqInt i;
    usqInt jumpTargetAddr;
    sqInt methods[MaxCPICCases];
    sqInt pc;
    int tags[MaxCPICCases];
    CogMethod *targetMethod;
    sqInt targets[MaxCPICCases];
    sqInt used;
    sqInt valid;

	used = 0;
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		entryPoint = (jumpLongTargetBeforeFollowingAddress(backEnd, pc));

		/* Collect all target triples except for triples whose entry-point is a freed method */
		valid = 1;
		if (!(/* containsAddress: */
				((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
			 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint))))) {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
			 || (isCMFree(((CogBlockMethod *) targetMethod))));
			if (((targetMethod->cmType)) == CMFree) {
				if (i == 1) {
					return 1;
				}
				valid = 0;
			}
		}
		if (valid) {
			tags[used] = ((i > 1
		? literal32BeforeFollowingAddress(backEnd, pc - (jumpLongConditionalByteSize(backEnd)))
		: 0));
			targets[used] = entryPoint;
			methods[used] = (literalBeforeFollowingAddress(backEnd, pc - ((i == 1
		? jumpLongByteSize(backEnd)
		: (jumpLongConditionalByteSize(backEnd)) + (cmpC32RTempByteSize(backEnd))))));
			used += 1;
		}
	}
	if (used == ((cPIC->cPICNumCases))) {
		return 0;
	}
	if (!used) {
		return 1;
	}
	((((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta)))->cPICNumCases = used);
	if (used == 1) {
		pc = addressOfEndOfCaseinCPIC(2, cPIC);

		/* begin rewriteCPIC:caseJumpTo: */
		addressFollowingJump = (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd));
		jumpTargetAddr = pc;

		/* begin rewriteCPICJumpAt:target: */
		rewriteImm19JumpBeforetarget(((AbstractInstruction *) backEnd), addressFollowingJump, jumpTargetAddr);
		return 0;
	}
	for (i = 1; i < used; i += 1) {
		pc = addressOfEndOfCaseinCPIC(i + 1, cPIC);
		rewriteCPICCaseAttagobjReftarget(pc, tags[i], methods[i], targets[i]);
	}

	/* begin rewriteCPIC:caseJumpTo: */
	addressFollowingJump = (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd));
	jumpTargetAddr = pc - cPICCaseSize;

	/* begin rewriteCPICJumpAt:target: */
	rewriteImm19JumpBeforetarget(((AbstractInstruction *) backEnd), addressFollowingJump, jumpTargetAddr);
	return 0;
}


/*	The first case in a CPIC doesn't have a class reference so we need only
	step over actually usd subsequent cases.
 */

	/* Cogit>>#cPICHasForwardedClass: */
static NoDbgRegParms sqInt
cPICHasForwardedClass(CogMethod *cPIC)
{
    unsigned int classIndex;
    sqInt i;
    sqInt pc;


	/* start by finding the address of the topmost case, the cPICNumCases'th one */
	pc = (addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC)) - (jumpLongConditionalByteSize(backEnd));
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		classIndex = literal32BeforeFollowingAddress(backEnd, pc);
		if (isForwardedClassIndex(classIndex)) {
			return 1;
		}
		pc += cPICCaseSize;
	}
	return 0;
}


/*	scan the CPIC for target methods that have been freed. */

	/* Cogit>>#cPICHasFreedTargets: */
static NoDbgRegParms sqInt
cPICHasFreedTargets(CogMethod *cPIC)
{
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    CogMethod *targetMethod;

	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);

		/* Find target from jump.  Ignore jumps to the interpret and MNU calls within this PIC */
		entryPoint = (jumpLongTargetBeforeFollowingAddress(backEnd, pc));
		if (!(/* containsAddress: */
				((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
			 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint))))) {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
			 || (isCMFree(((CogBlockMethod *) targetMethod))));
			if (((targetMethod->cmType)) == CMFree) {
				return 1;
			}
		}
	}
	return 0;
}


/*	Whimsey; we want 16rCA5E10 + cPICPrototypeCaseOffset to be somewhere in
	the middle of the zone.
 */

	/* Cogit>>#cPICPrototypeCaseOffset */
static sqInt
cPICPrototypeCaseOffset(void)
{
	return ((methodZoneBase + (youngReferrers)) / 2) - 13262352;
}


/*	Are any of the jumps from this CPIC to targetMethod? */

	/* Cogit>>#cPIC:HasTarget: */
static NoDbgRegParms sqInt
cPICHasTarget(CogMethod *cPIC, CogMethod *targetMethod)
{
    sqInt i;
    sqInt pc;
    sqInt target;

	target = (((usqInt)targetMethod)) + cmNoCheckEntryOffset;

	/* Since this is a fast test doing simple compares we don't need to care that some
	   cases have nonsense addresses in there. Just zip on through. */
	/* First jump is unconditional; subsequent ones are conditional */
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	if (target == (jumpLongTargetBeforeFollowingAddress(backEnd, pc))) {
		return 1;
	}
	for (i = 2; i <= MaxCPICCases; i += 1) {
		pc += cPICCaseSize;
		if (target == (jumpLongTargetBeforeFollowingAddress(backEnd, pc))) {
			return 1;
		}
	}
	return 0;
}


/*	Answer an Array of the PIC's selector, followed by class and
	targetMethod/doesNotUnderstand: for each entry in the PIC.
 */

	/* Cogit>>#createCPICData: */
static NoDbgRegParms sqInt
createCPICData(CogMethod *cPIC)
{
    sqInt class;
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    sqInt picData;
    sqInt target;
    CogMethod *targetMethod;

	assert((((cPIC->methodObject)) == 0)
	 || (addressCouldBeOop((cPIC->methodObject))));
	picData = instantiateClassindexableSize(classArray(), (((cPIC->cPICNumCases)) * 2) + 1);
	if (!picData) {
		return picData;
	}
	storePointerUncheckedofObjectwithValue(0, picData, (cPIC->selector));
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (i == 1) {
			/* first case may have been collected and stored here by collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method: */
			class = (cPIC->methodObject);
			if (!class) {
				class = nilObject();
			}
			entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		}
		else {
			class = classForInlineCacheTag(literal32BeforeFollowingAddress(backEnd, pc - (jumpLongConditionalByteSize(backEnd))));
			entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		}
		if (/* containsAddress: */
			((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
		 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {
			target = splObj(SelectorDoesNotUnderstand);
		}
		else {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert(isCMMethodEtAl(((CogBlockMethod *) targetMethod)));
			target = (targetMethod->methodObject);
		}
		storePointerUncheckedofObjectwithValue((i * 2) - 1, picData, class);
		storePointerUncheckedofObjectwithValue(i * 2, picData, target);
	}
	beRootIfOld(picData);
	(cPIC->methodObject = 0);
	return picData;
}


/*	Division is a little weird on some processors. Defer to the backEnd
	to allow it to generate any special code it may need to. */

	/* Cogit>>#DivR:R:Quo:Rem: */
static NoDbgRegParms AbstractInstruction *
gDivRRQuoRem(sqInt rDivisor, sqInt rDividend, sqInt rQuotient, sqInt rRemainder)
{
	genDivRRQuoRem(backEnd, rDivisor, rDividend, rQuotient, rRemainder);
	return abstractInstructionAt(opcodeIndex - 1);
}


/*	Return the default number of bytes to allocate for native code at startup.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file. */

	/* Cogit>>#defaultCogCodeSize */
int
defaultCogCodeSize(void)
{
	return 0x1A0000;
}


/*	Answer the number of bytecodes to skip to get to the first bytecode
	past the primitive call and any store of the error code. */

	/* Cogit>>#deltaToSkipPrimAndErrorStoreIn:header: */
static NoDbgRegParms sqInt
deltaToSkipPrimAndErrorStoreInheader(sqInt aMethodObj, sqInt aMethodHeader)
{
	return (/* methodUsesPrimitiveErrorCode:header: */
		((primitiveIndexOfMethodheader(aMethodObj, aMethodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(aMethodHeader)) == (fetchByteofObject((startPCOfMethodHeader(aMethodHeader)) + (sizeOfCallPrimitiveBytecode(aMethodHeader)), aMethodObj)))
			? (sizeOfCallPrimitiveBytecode(aMethodHeader)) + (sizeOfLongStoreTempBytecode(aMethodHeader))
			: 0);
}

	/* Cogit>>#endPCOf: */
static NoDbgRegParms sqInt
endPCOf(sqInt aMethod)
{
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt end;
    sqInt latestContinuation;
    sqInt nExts;
    sqInt pc;
    sqInt prim;
    sqInt targetPC;

	pc = (latestContinuation = startPCOfMethod(aMethod));
	if (((prim = primitiveIndexOf(aMethod))) > 0) {
		if (isQuickPrimitiveIndex(prim)) {
			return pc - 1;
		}
	}
	bsOffset = /* begin bytecodeSetOffsetFor: */
			(methodUsesAlternateBytecodeSet(aMethod)
				? 0x100
				: 0);
	nExts = 0;
	end = numBytesOf(aMethod);
	while (pc <= end) {
		byte = fetchByteofObject(pc, aMethod);
		descriptor = generatorAt(byte + bsOffset);
		if (((descriptor->isReturn))
		 && (pc >= latestContinuation)) {
			end = pc;
		}
		if ((isBranch(descriptor))
		 || ((descriptor->isBlockCreation))) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, aMethod);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
			if ((descriptor->isBlockCreation)) {
				pc += distance;
			}
		}
		else {
		}
		nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
		pc += (descriptor->numBytes);
	}
	return end;
}


/*	This is a static version of ceEnterCogCodePopReceiverReg for
	break-pointing when debugging in C. Marked <api> so the code generator
	won't delete it. */

	/* Cogit>>#enterCogCodePopReceiver */
static void
enterCogCodePopReceiver(void)
{
	realCEEnterCogCodePopReceiverReg();
	if (!Debug) {
		error("what??");
	}
}


/*	Answer if the entryPoint's tag is expected to be a selector reference, as
	opposed to a class tag.
 */

	/* Cogit>>#entryPointTagIsSelector: */
static NoDbgRegParms sqInt
entryPointTagIsSelector(sqInt entryPoint)
{
	return (entryPoint < methodZoneBase)
	 || (((entryPoint & entryPointMask) == uncheckedEntryAlignment)
	 || (((entryPoint & entryPointMask) == checkedEntryAlignment)
	 && ((((((CogMethod *) (entryPoint - cmEntryOffset)))->cmType)) == CMOpenPIC)));
}


/*	Use asserts to check if the ClosedPICPrototype is as expected from
	compileClosedPICPrototype, and can be updated as required via
	rewriteCPICCaseAt:tag:objRef:target:. If all asserts pass, answer
	0, otherwise answer a bit mask identifying all the errors. */
/*	self disassembleFrom: methodZoneBase + (self sizeof: CogMethod) to:
	methodZoneBase + closedPICSize
 */

	/* Cogit>>#expectedClosedPICPrototype: */
static NoDbgRegParms sqInt
expectedClosedPICPrototype(CogMethod *cPIC)
{
    unsigned int classTag;
    sqInt classTagPC;
    sqInt entryPoint;
    sqInt errors;
    sqInt i;
    sqInt methodObjPC;
    sqInt object;
    sqInt pc;

	errors = 0;

	/* First jump is unconditional; subsequent ones are conditional */
	pc = (((usqInt)cPIC)) + firstCPICCaseOffset;
	object = literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)));
	if (!(asserta(object == (firstPrototypeMethodOop())))) {
		errors = 1;
	}
	entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
	if (!(asserta(entryPoint == ((cPICPrototypeCaseOffset()) + 13262352)))) {
		errors += 2;
	}
	for (i = 1; i < MaxCPICCases; i += 1) {
		/* verify information in case is as expected. */
		pc += cPICCaseSize;
		methodObjPC = (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd));
		object = literalBeforeFollowingAddress(backEnd, methodObjPC);
		if (!(asserta(object == ((subsequentPrototypeMethodOop()) + i)))) {
			errors = errors | 4;
		}
		classTagPC = pc - (jumpLongConditionalByteSize(backEnd));
		classTag = literal32BeforeFollowingAddress(backEnd, classTagPC);
		if (!(asserta(classTag == (0xBABE1F15U + i)))) {
			errors = errors | 8;
		}
		entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		if (!(asserta(entryPoint == (((cPICPrototypeCaseOffset()) + 13262352) + (i * 16))))) {
			errors = errors | 16;
		}
		rewriteCPICCaseAttagobjReftarget(pc, classTag ^ 0x5A5A5A5A, object ^ 0xA5A5A5A5U, entryPoint ^ 0x55AA50);
		object = literalBeforeFollowingAddress(backEnd, methodObjPC);
		if (!(asserta(object == (((subsequentPrototypeMethodOop()) + i) ^ 0xA5A5A5A5U)))) {
			errors = errors | 32;
		}
		classTag = literal32BeforeFollowingAddress(backEnd, classTagPC);
		if (!(asserta(classTag == ((0xBABE1F15U + i) ^ 0x5A5A5A5A)))) {
			errors = errors | 64;
		}
		entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		if (!(asserta(entryPoint == ((((cPICPrototypeCaseOffset()) + 13262352) + (i * 16)) ^ 0x55AA50)))) {
			errors = errors | 128;
		}
		rewriteCPICCaseAttagobjReftarget(pc, classTag ^ 0x5A5A5A5A, object ^ 0xA5A5A5A5U, entryPoint ^ 0x55AA50);
	}
	entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, (((usqInt)cPIC)) + cPICEndOfCodeOffset);
	if (!(asserta(entryPoint == (cPICMissTrampolineFor(0))))) {
		errors += 0x100;
	}
	return errors;
}


/*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A) */

	/* Cogit>>#extABytecode */
static sqInt
extABytecode(void)
{
	extA = (((((usqInt)(extA) << 8)))) + byte1;
	return 0;
}


/*	225		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B) */

	/* Cogit>>#extBBytecode */
static sqInt
extBBytecode(void)
{
	extB = ((numExtB == 0)
		 && (byte1 > 0x7F)
				? byte1 - 0x100
				: (((((usqInt)(extB) << 8)))) + byte1);
	numExtB += 1;
	return 0;
}


/*	Fill in the block headers now we know the exact layout of the code. */

	/* Cogit>>#fillInBlockHeadersAt: */
static NoDbgRegParms sqInt
fillInBlockHeadersAt(sqInt startAddress)
{
    sqInt aCogMethodOrInteger;
    CogBlockMethod *blockHeader;
    BlockStart *blockStart;
    sqInt i;

	if (!(needsFrame
		 && (blockCount > 0))) {
		return null;
	}
	if (blockNoContextSwitchOffset) {
		assert(blockNoContextSwitchOffset == (((blockEntryLabel->address)) - ((blockEntryNoContextSwitch->address))));
	}
	else {
		blockNoContextSwitchOffset = ((blockEntryLabel->address)) - ((blockEntryNoContextSwitch->address));
	}
	for (i = 0; i < blockCount; i += 1) {
		blockStart = blockStartAt(i);
		aCogMethodOrInteger = (((blockStart->fakeHeader))->address);

		/* begin writableBlockMethodFor: */
		blockHeader = ((CogBlockMethod *) ((((usqInt)aCogMethodOrInteger)) + codeToDataDelta));
		(blockHeader->homeOffset = ((((blockStart->fakeHeader))->address)) - startAddress);
		(blockHeader->startpc = (blockStart->startpc));
		(blockHeader->cmType = CMBlock);
		(blockHeader->cmNumArgs = (blockStart->numArgs));
		(blockHeader->cbUsesInstVars = (blockStart->hasInstVarRef));
		(blockHeader->stackCheckOffset = ((blockStart->stackCheckLabel)
				? ((((blockStart->stackCheckLabel))->address)) - ((((blockStart->fakeHeader))->address))
				: 0));
	}
	return 0;
}


/*	Fill in the header for theCogMethod method. This may be located at the
	writable mapping. */

	/* Cogit>>#fillInMethodHeader:size:selector: */
static NoDbgRegParms void
fillInMethodHeadersizeselector(CogMethod *method, sqInt size, sqInt selector)
{
    sqInt actualMethodLocation;
    unsigned int codeInstruction;
    unsigned int dataInstruction;
    CogMethod *originalMethod;
    sqInt rawHeader;

	actualMethodLocation = (((usqInt)method)) - codeToDataDelta;
	(method->cmType = CMMethod);
	(method->objectHeader = nullHeaderForMachineCodeMethod());
	(method->blockSize = size);
	(method->methodObject = methodObj);

	/* If the method has already been cogged (e.g. Newspeak accessors) then
	   leave the original method attached to its cog method, but get the right header. */
	rawHeader = rawHeaderOf(methodObj);
	if (isCogMethodReference(rawHeader)) {
		originalMethod = ((CogMethod *) rawHeader);
		assert(((originalMethod->blockSize)) == size);
		assert(methodHeader == ((originalMethod->methodHeader)));
	}
	else {
		rawHeaderOfput(methodObj, actualMethodLocation);
	}
	(method->methodHeader = methodHeader);
	(method->selector = selector);
	(method->cmNumArgs = argumentCountOfMethodHeader(methodHeader));
	(method->cmHasMovableLiteral = hasMovableLiteral);
	if ((method->cmRefersToYoung = hasYoungReferent)) {
		addToYoungReferrers(method);
	}
	(method->cmUsageCount = initialMethodUsageCount());

	/* cpicHasMNUCase: */
	(method->cpicHasMNUCaseOrCMIsFullBlock) = 0;
	(method->cmUsesPenultimateLit = maxLitIndex >= ((literalCountOfMethodHeader(methodHeader)) - 2));
	(method->blockEntryOffset = (blockEntryLabel
			? ((blockEntryLabel->address)) - actualMethodLocation
			: 0));
	if (needsFrame) {
		if (!((((stackCheckLabel->address)) - actualMethodLocation) <= MaxStackCheckOffset)) {
			error("too much code for stack check offset");
		}
	}
	(method->stackCheckOffset = (needsFrame
			? ((stackCheckLabel->address)) - actualMethodLocation
			: 0));
	assert((callTargetFromReturnAddress(backEnd, actualMethodLocation + missOffset)) == (methodAbortTrampolineFor((method->cmNumArgs))));
	assert(size == (roundUpLength(size)));

	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	/* begin assertCoherentCodeAt:delta: */
	codeInstruction = long32At(actualMethodLocation + cmNoCheckEntryOffset);
	dataInstruction = long32At((actualMethodLocation + cmNoCheckEntryOffset) + codeToDataDelta);
	assert(codeInstruction == dataInstruction);
#  endif // DUAL_MAPPED_CODE_ZONE
}

	/* Cogit>>#findBackwardBranch:IsBackwardBranch:Mcpc:Bcpc:MatchingBcpc: */
static NoDbgRegParms sqInt
findBackwardBranchIsBackwardBranchMcpcBcpcMatchingBcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetBcpc)
{
	return ((((isBackwardBranchAndAnnotation & 1) != 0))
	 && ((((sqInt)targetBcpc)) == bcpc)
			? ((sqInt)mcpc)
			: 0);
}

	/* Cogit>>#findBlockMethodWithEntry:startBcpc: */
static NoDbgRegParms usqInt
findBlockMethodWithEntrystartBcpc(sqInt blockEntryMcpc, sqInt startBcpc)
{
    CogBlockMethod *cogBlockMethod;

	cogBlockMethod = ((CogBlockMethod *) (blockEntryMcpc - (sizeof(CogBlockMethod))));
	if (((cogBlockMethod->startpc)) == startBcpc) {
		return ((usqInt)cogBlockMethod);
	}
	return 0;
}

	/* Cogit>>#findMapLocationForMcpc:inMethod: */
static NoDbgRegParms sqInt
findMapLocationForMcpcinMethod(usqInt targetMcpc, CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;

	mapByte = 0;
	mcpc = /* firstMappedPCFor: */
			((((cogMethod->cmType)) >= CMMethod)
		 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	if (mcpc == targetMcpc) {
		return map;
	}
	while (((mapByte = byteAt(map))) != MapEnd) {
		annotation = ((usqInt)(mapByte)) >> AnnotationShift;
		if (annotation != IsAnnotationExtension) {
			mcpc += 4 /* codeGranularity */ * ((annotation
		? mapByte & DisplacementMask
		: ((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))));
		}
		if (mcpc >= targetMcpc) {
			assert(mcpc == targetMcpc);
			if (!annotation) {
				map -= 1;
				mapByte = byteAt(map);
				annotation = ((usqInt)(mapByte)) >> AnnotationShift;
				assert(annotation > IsAnnotationExtension);
			}
			return map;
		}
		map -= 1;
	}
	return 0;
}


/*	Find the CMMethod or CMBlock that has zero-relative startbcpc as its first
	bytecode pc.
	As this is for cannot resume processing and/or conversion to machine-code
	on backward
	branch, it doesn't have to be fast. Enumerate block returns and map to
	bytecode pcs. */

	/* Cogit>>#findMethodForStartBcpc:inHomeMethod: */
CogBlockMethod *
findMethodForStartBcpcinHomeMethod(sqInt startbcpc, CogMethod *cogMethod)
{
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
	if (startbcpc == (startPCOfMethodHeader((cogMethod->methodHeader)))) {
		return ((CogBlockMethod *) cogMethod);
	}
	assert(((cogMethod->blockEntryOffset)) != 0);
	return ((CogBlockMethod *) (blockDispatchTargetsForperformarg(cogMethod, findBlockMethodWithEntrystartBcpc, startbcpc)));
}


/*	Machine code addresses map to the following bytecode for all bytecodes
	except backward branches, where they map to the backward branch itself.
	This is so that loops continue, rather than terminate prematurely. */

	/* Cogit>>#find:IsBackwardBranch:Mcpc:Bcpc:MatchingMcpc: */
static NoDbgRegParms sqInt
findIsBackwardBranchMcpcBcpcMatchingMcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetMcpc)
{
	return (targetMcpc == mcpc
			? ((!descriptor)
			 || (((isBackwardBranchAndAnnotation & 1) != 0))
					? bcpc
					: bcpc + ((descriptor->numBytes)))
			: 0);
}

	/* Cogit>>#firstMappedPCFor: */
static NoDbgRegParms sqInt
firstMappedPCFor(CogMethod *cogMethod)
{
	return ((((cogMethod->cmType)) >= CMMethod)
	 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
			? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
			: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
}


/*	Answer a fake value for the first method oop in the PIC prototype.
	Since we use MoveUniqueCw:R: it must not be confused with a
	method-relative address. */

	/* Cogit>>#firstPrototypeMethodOop */
static sqInt
firstPrototypeMethodOop(void)
{
	return (/* addressIsInCurrentCompilation: */
		((((usqInt)0x5EAF00D)) >= ((methodLabel->address)))
	 && ((((usqInt)0x5EAF00D)) < ((((youngReferrers) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers) : (((methodLabel->address)) + MaxMethodSize))))
			? 0xCA7F00D
			: 0x5EAF00D);
}

	/* Cogit>>#fixupAt: */
static NoDbgRegParms BytecodeFixup *
fixupAt(sqInt fixupPC)
{
	return fixupAtIndex(fixupPC - initialPC);
}

	/* Cogit>>#flagCogMethodForBecome: */
void
flagCogMethodForBecome(CogMethod *cogMethod)
{
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMMethodFlaggedForBecome);
}

	/* Cogit>>#followForwardedLiteralsImplementationIn: */
static NoDbgRegParms void
followForwardedLiteralsImplementationIn(CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt hasYoungObj;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *writableCogMethod;

	assert((!(isCMMethodEtAl(((CogBlockMethod *) cogMethod))))
	 || (!(isForwarded((cogMethod->methodObject)))));
	writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
	hasYoungObj = isYoung((cogMethod->methodObject));
	if (shouldRemapOop((cogMethod->selector))) {
		(writableCogMethod->selector = remapObj((cogMethod->selector)));
		if (isYoung((cogMethod->selector))) {
			hasYoungObj = 1;
		}
	}

	/* begin mapFor:performUntil:arg: */
	mapByte = 0;
	mcpc = /* firstMappedPCFor: */
			((((cogMethod->cmType)) >= CMMethod)
		 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {
			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = remapIfObjectRefpchasYoung(annotation, ((char *) mcpc), ((void *)((&hasYoungObj))));
			if (result) {
				goto l1;
			}
		}
		else {
			if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
			}
		}
		map -= 1;
	}
l1:	/* end mapFor:performUntil:arg: */;
	if (hasYoungObj) {
		ensureInYoungReferrers(cogMethod);
	}
	else {
		(writableCogMethod->cmRefersToYoung = 0);
	}
}

	/* Cogit>>#followForwardedLiteralsIn: */
void
followForwardedLiteralsIn(CogMethod *cogMethod)
{
    usqInt wasInYoungReferrers;

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	wasInYoungReferrers = (cogMethod->cmRefersToYoung);
	followForwardedLiteralsImplementationIn(cogMethod);
	if (wasInYoungReferrers
	 && (!((cogMethod->cmRefersToYoung)))) {
		pruneYoungReferrers();
	}

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}


/*	To avoid runtime checks on literal variable and literal accesses in == and
	~~, 
	we follow literals in methods having movable literals in the postBecome
	action. To avoid scanning every method, we annotate cogMethods with the 
	cmHasMovableLiteral flag. */

	/* Cogit>>#followMovableLiteralsAndUpdateYoungReferrers */
void
followMovableLiteralsAndUpdateYoungReferrers(void)
{
    CogMethod *cogMethod;
    sqInt endAddress;

	assert(kosherYoungReferrers());
	codeModified = 0;

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!((((cogMethod->cmType)) == CMFree)
			 || (((cogMethod->cmType)) == CMMethodFlaggedForBecome))) {
			if ((cogMethod->cmHasMovableLiteral)) {
				followForwardedLiteralsImplementationIn(cogMethod);
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		endAddress = freeStart();

		/* begin flushICacheFrom:to: */
		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneExecutable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(1);
		PJWPNSet = __LINE__;
		PJWPNChange = __LINE__;
		PJWPNState = 1;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) (((usqInt)codeBase))), endAddress - (((usqInt)codeBase)));
		sys_icache_invalidate(((void *) (((usqInt)codeBase))), endAddress - (((usqInt)codeBase)));
#    else // __APPLE__ && __MACH__
		ceFlushICache(((usqInt)codeBase), endAddress);
#    endif

	}

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}


/*	N.B. because becomeEffectFlags indicates whether jitted methods were
	becommed or not, if this method is called flagged methods exist, will be
	freed, and so on. So there is no need to check. Just do it. */

	/* Cogit>>#freeBecomeFlaggedMethods */
void
freeBecomeFlaggedMethods(void)
{
    CogMethod *cogMethod;

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
			freeMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	unlinkSendsToFree();

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}

	/* Cogit>>#freeCogMethod: */
void
freeCogMethod(CogMethod *cogMethod)
{
	moveProfileToMethods();
	freeMethod(cogMethod);

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}


/*	Free machine-code methods whose compiled methods are unmarked
	and open PICs whose selectors are not marked, and closed PICs that
	refer to unmarked objects. */

	/* Cogit>>#freeUnmarkedMachineCode */
void
freeUnmarkedMachineCode(void)
{
    CogMethod *cogMethod;
    sqInt freedMethod;

	moveProfileToMethods();
	freedMethod = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) >= CMMethod)
		 && (!(isMarked((cogMethod->methodObject))))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		if ((((cogMethod->cmType)) == CMOpenPIC)
		 && ((!(isImmediate((cogMethod->selector))))
		 && (!(isMarked((cogMethod->selector)))))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		if ((((cogMethod->cmType)) == CMClosedPIC)
		 && (closedPICRefersToUnmarkedObject(cogMethod))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedMethod) {
		unlinkSendsToFree();
	}

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}


/*	Call ceSendMustBeBooleanTo: via the relevant trampoline. */

	/* Cogit>>#genCallMustBeBooleanFor: */
static NoDbgRegParms AbstractInstruction *
genCallMustBeBooleanFor(sqInt boolean)
{
    AbstractInstruction *abstractInstruction;
    sqInt callTarget;

	callTarget = (boolean == (falseObject())
				? ceSendMustBeBooleanAddFalseTrampoline
				: ceSendMustBeBooleanAddTrueTrampoline);

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, callTarget);
	(abstractInstruction->annotation = IsRelativeCall);
	return abstractInstruction;
}

	/* Cogit>>#genConditionalBranch:operand: */
static NoDbgRegParms AbstractInstruction *
genConditionalBranchoperand(sqInt opcode, sqInt operandOne)
{
	return noteFollowingConditionalBranch(previousInstruction(), genoperand(opcode, operandOne));
}


/*	An enilopmart (the reverse of a trampoline) is a piece of code that makes
	the system-call-like transition from the C runtime into generated machine
	code. The desired arguments and entry-point are pushed on a stackPage's
	stack. The enilopmart pops off the values to be loaded into registers and
	then executes a return instruction to pop off the entry-point and jump to
	it. 
	BEFORE				AFTER			(stacks grow down)
	whatever			stackPointer ->	whatever
	target address =>	reg1 = reg1val, etc
	reg1val				pc = target address
	reg2val
	stackPointer ->	reg3val */

	/* Cogit>>#genEnilopmartFor:and:and:forCall:called: */
static NoDbgRegParms void
(*genEnilopmartForandandforCallcalled(sqInt regArg1, sqInt regArg2OrNone, sqInt regArg3OrNone, sqInt forCall, char *trampolineName))(void)
{
    AbstractInstruction *anInstruction;
    sqInt endAddress;
    usqInt enilopmart;
    sqInt quickConstant;
    sqInt size;

	zeroOpcodeIndex();
	quickConstant = varBaseAddress;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	genLoadStackPointers(backEnd);
	if (regArg3OrNone != NoReg) {
		/* PopR: */
		genoperand(PopR, regArg3OrNone);
	}
	if (regArg2OrNone != NoReg) {
		/* PopR: */
		genoperand(PopR, regArg2OrNone);
	}

	/* PopR: */
	genoperand(PopR, regArg1);
	genEnilopmartReturn(forCall);
	computeMaximumSizes();
	size = generateInstructionsAt(methodZoneBase);
	endAddress = outputInstructionsAt(methodZoneBase);
	assert((methodZoneBase + size) == endAddress);
	enilopmart = methodZoneBase;
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	recordGeneratedRunTimeaddress(trampolineName, enilopmart);
	return ((void (*)(void)) enilopmart);
}


/*	An enilopmart (the reverse of a trampoline) is a piece of code that makes
	the system-call-like transition from the C runtime into generated machine
	code. At the point the enilopmart enters machine code via a return
	instruction, any argument registers have been loaded with their values and
	the stack, if
	for call, looks like
	ret pc
	stackPointer ->	target address
	
	and if not for call, looks like
	whatever
	stackPointer ->	target address
	
	If forCall and running on a CISC, ret pc must be left on the stack. If
	forCall and
	running on a RISC, ret pc must be popped into LinkReg. In either case,
	target address must be removed from the stack and jumped/returned to. */

	/* Cogit>>#genEnilopmartReturn: */
static NoDbgRegParms void
genEnilopmartReturn(sqInt forCall)
{
	if (forCall) {
		/* PopR: */
		genoperand(PopR, RISCTempReg);

		/* PopR: */
		genoperand(PopR, LinkReg);

		/* JumpR: */
		genoperand(JumpR, RISCTempReg);
	}
	else {
		/* PopR: */
		genoperand(PopR, RISCTempReg);

		/* JumpR: */
		genoperand(JumpR, RISCTempReg);
	}
}


/*	Generate the routine that writes the current values of the C frame and
	stack pointers into
	variables. These are used to establish the C stack in trampolines back
	into the C run-time.
	This routine assumes the system's frame pointer is the same as that used
	in generated code. */

	/* Cogit>>#generateCaptureCStackPointers: */
static NoDbgRegParms NeverInline void
generateCaptureCStackPointers(sqInt captureFramePointer)
{
    AbstractInstruction *anInstruction;
    sqInt callerSavedReg;
    sqInt fixupSize;
    sqInt offset;
    sqInt opcodeSize;
    sqInt pushedVarBaseReg;
    sqInt quickConstant;
    usqInt startAddress;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 32;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;

	/* Must happen first; value may be used in accessing any of the following addresses */
	startAddress = methodZoneBase;
	callerSavedReg = 0;
	pushedVarBaseReg = 0;
	if (!(((CallerSavedRegisterMask & ((1U << VarBaseReg))) != 0))) {

		/* VarBaseReg is not caller-saved; must save and restore it, either by using an available caller-saved reg or push/pop. */
		/* TempReg used below */
		callerSavedReg = availableRegisterOrNoneIn(((ABICallerSavedRegisterMask | (1U << TempReg)) - (1U << TempReg)));
		if (callerSavedReg == NoReg) {
			gNativePushR(VarBaseReg);
			pushedVarBaseReg = 1;
		}
		else {
			/* MoveR:R: */
			genoperandoperand(MoveRR, VarBaseReg, callerSavedReg);
		}
	}
	quickConstant = varBaseAddress;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	if (captureFramePointer) {
		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(cFramePointerAddress(), genoperandoperand(MoveRAw, FPReg, cFramePointerAddress()));
	}
	if (pushedVarBaseReg) {
		offset = (pushedVarBaseReg
					? 0 /* leafCallStackPointerDelta */ + BytesPerWord
					: 0 /* leafCallStackPointerDelta */);

		/* begin LoadEffectiveAddressMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, offset, NativeSPReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}

		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveRAw, TempReg, cStackPointerAddress()));
	}
	else {
		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveRAw, NativeSPReg, cStackPointerAddress()));
	}
	if (!(((CallerSavedRegisterMask & ((1U << VarBaseReg))) != 0))) {
		if (pushedVarBaseReg) {
			gNativePopR(VarBaseReg);
		}
		else {
			/* MoveR:R: */
			genoperandoperand(MoveRR, callerSavedReg, VarBaseReg);
		}
	}
	gNativeRetN(0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) (((usqInt)startAddress))), (((usqInt)methodZoneBase)) - (((usqInt)startAddress)));
	sys_icache_invalidate(((void *) (((usqInt)startAddress))), (((usqInt)methodZoneBase)) - (((usqInt)startAddress)));
#  else // __APPLE__ && __MACH__
	ceFlushICache(((usqInt)startAddress), ((usqInt)methodZoneBase));
#  endif

	recordGeneratedRunTimeaddress("ceCaptureCStackPointers", startAddress);
	ceCaptureCStackPointers = ((void (*)(void)) startAddress);
}


/*	Generate the prototype ClosedPIC to determine how much space a full closed
	PIC takes.
	When we first allocate a closed PIC it only has one or two cases and we
	want to grow it.
	So we have to determine how big a full one is before hand. */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#generateClosedPICPrototype */
static void
generateClosedPICPrototype(void)
{
    AbstractInstruction *anInstruction;
    CogMethod *cPIC;
    AbstractInstruction * cPICEndOfCodeLabel;
    sqInt endAddress;
    AbstractInstruction * endCPICCase1;
    sqInt fixupSize;
    sqInt h;
    AbstractInstruction *jumpNext;
    sqInt jumpTarget;
    sqInt numArgs;
    sqInt opcodeSize;
    sqInt wordConstant;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = MaxCPICCases * 9;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	(methodLabel->address = methodZoneBase);
	(methodLabel->dependent = null);

	/* begin compileClosedPICPrototype */
	compilePICAbort((numArgs = 0));

	/* At the end of the entry code we need to jump to the first case code, which is actually the last chunk.
	   On each entension we must update this jump to move back one case. */
	jumpNext = compileCPICEntry();
	wordConstant = firstPrototypeMethodOop();

	/* begin MoveUniqueCw:R: */
	/* begin gen:uniqueLiteral:operand: */
	anInstruction = genoperandoperand(MoveCwR, wordConstant, SendNumArgsReg);
	assert(usesOutOfLineLiteral(anInstruction));
	(anInstruction->dependent = allocateLiteral(wordConstant));
	jumpTarget = (((methodZoneBase + (youngReferrers)) / 2) - 13262352) + 13262352;

	/* begin JumpLong: */
	genoperand(JumpLong, jumpTarget);
	endCPICCase0 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	for (h = 1; h < MaxCPICCases; h += 1) {
		if (h == (MaxCPICCases - 1)) {
			jmpTarget(jumpNext, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		}
		wordConstant = (subsequentPrototypeMethodOop()) + h;

		/* begin MoveUniqueCw:R: */
		/* begin gen:uniqueLiteral:operand: */
		anInstruction = genoperandoperand(MoveCwR, wordConstant, SendNumArgsReg);
		assert(usesOutOfLineLiteral(anInstruction));
		(anInstruction->dependent = allocateLiteral(wordConstant));

		/* #CmpC32:R: #gen:literal32:operand: */
		checkLiteral32forInstruction(0xBABE1F15U + h, genoperandoperand(CmpC32R, 0xBABE1F15U + h, TempReg));
		jumpTarget = ((((methodZoneBase + (youngReferrers)) / 2) - 13262352) + 13262352) + (h * 16);

		/* begin JumpLongZero: */
		genConditionalBranchoperand(JumpLongZero, ((sqInt)jumpTarget));
		if (h == 1) {
			endCPICCase1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
	}

	/* #MoveCw:R: #gen:literal:operand: */
	checkLiteralforInstruction((methodLabel->address), genoperandoperand(MoveCwR, (methodLabel->address), ClassReg));
	jumpTarget = cPICMissTrampolineFor(numArgs);

	/* begin JumpLong: */
	genoperand(JumpLong, jumpTarget);
	cPICEndOfCodeLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	dumpLiterals(0);
	computeMaximumSizes();
	cPIC = ((CogMethod *) methodZoneBase);
	closedPICSize = (sizeof(CogMethod)) + (generateInstructionsAt(methodZoneBase + (sizeof(CogMethod))));
	endAddress = outputInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	assert((methodZoneBase + closedPICSize) == endAddress);
	firstCPICCaseOffset = ((endCPICCase0->address)) - methodZoneBase;
	cPICEndOfCodeOffset = ((cPICEndOfCodeLabel->address)) - methodZoneBase;
	cPICCaseSize = ((endCPICCase1->address)) - ((endCPICCase0->address));
	cPICEndSize = closedPICSize - (((MaxCPICCases - 1) * cPICCaseSize) + firstCPICCaseOffset);
	closedPICSize = roundUpToMethodAlignment(backEnd, closedPICSize);
	assert(((picInterpretAbort->address)) == (((methodLabel->address)) + (picInterpretAbortOffset())));
	assert((expectedClosedPICPrototype(cPIC)) == 0);
	storeLiteralbeforeFollowingAddress(backEnd, 0, ((endCPICCase0->address)) - (jumpLongByteSize(backEnd)));
	methodZoneBase = alignUptoRoutineBoundary(endAddress);

	/* self cCode: ''
	   inSmalltalk:
	   [self disassembleFrom: cPIC + (self sizeof: CogMethod) to: cPIC + closedPICSize - 1.
	   self halt] */
	cPICPrototype = cPIC;
}


/*	We handle jump sizing simply. First we make a pass that asks each
	instruction to compute its maximum size. Then we make a pass that
	sizes jumps based on the maxmimum sizes. Then we make a pass
	that fixes up jumps. When fixing up a jump the jump is not allowed to
	choose a smaller offset but must stick to the size set in the second pass. */

	/* Cogit>>#generateCogFullBlock */
static CogMethod *
generateCogFullBlock(void)
{
    sqInt codeSize;
    usqIntptr_t headerSize;
    sqInt mapSize;
    CogMethod *method;
    sqInt result;
    usqInt startAddress;
    sqInt totalSize;

	headerSize = sizeof(CogMethod);
	(methodLabel->address = freeStart());
	computeMaximumSizes();
	concretizeAt(methodLabel, freeStart());
	codeSize = generateInstructionsAt(((methodLabel->address)) + headerSize);
	mapSize = generateMapAtstart(null, ((methodLabel->address)) + cbNoSwitchEntryOffset);
	totalSize = roundUpToMethodAlignment(backEnd, (headerSize + codeSize) + mapSize);
	if (totalSize > MaxMethodSize) {
		return ((CogMethod *) MethodTooBig);
	}
	startAddress = allocate(totalSize);
	if (!startAddress) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	assert((startAddress + cbEntryOffset) == ((fullBlockEntry->address)));
	assert((startAddress + cbNoSwitchEntryOffset) == ((fullBlockNoContextSwitchEntry->address)));
	result = outputInstructionsAt(startAddress + headerSize);
	assert(((startAddress + headerSize) + codeSize) == result);
	padIfPossibleWithStopsFromto(backEnd, result, ((startAddress + totalSize) - mapSize) - 1);
	generateMapAtstart((startAddress + totalSize) - 1, startAddress + cbNoSwitchEntryOffset);
	flag("TOCHECK");
	method = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	fillInMethodHeadersizeselector(method, totalSize, nilObject());
	(method->cpicHasMNUCaseOrCMIsFullBlock = 1);

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) startAddress), (startAddress + totalSize) - startAddress);
	sys_icache_invalidate(((void *) startAddress), (startAddress + totalSize) - startAddress);
#  else // __APPLE__ && __MACH__
	ceFlushICache(startAddress, startAddress + totalSize);
#  endif

	return ((CogMethod *) startAddress);
}


/*	We handle jump sizing simply. First we make a pass that asks each
	instruction to compute its maximum size. Then we make a pass that
	sizes jumps based on the maxmimum sizes. Then we make a pass
	that fixes up jumps. When fixing up a jump the jump is not allowed to
	choose a smaller offset but must stick to the size set in the second pass. */

	/* Cogit>>#generateCogMethod: */
static NoDbgRegParms CogMethod *
generateCogMethod(sqInt selector)
{
    sqInt codeSize;
    usqIntptr_t headerSize;
    sqInt mapSize;
    sqInt result;
    usqInt startAddress;
    sqInt totalSize;

	headerSize = sizeof(CogMethod);
	(methodLabel->address = freeStart());
	computeMaximumSizes();
	concretizeAt(methodLabel, freeStart());
	codeSize = generateInstructionsAt(((methodLabel->address)) + headerSize);
	mapSize = generateMapAtstart(null, ((methodLabel->address)) + cmNoCheckEntryOffset);
	totalSize = roundUpToMethodAlignment(backEnd, (headerSize + codeSize) + mapSize);
	if (totalSize > MaxMethodSize) {
		return ((CogMethod *) MethodTooBig);
	}
	startAddress = allocate(totalSize);
	if (!startAddress) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	assert((startAddress + cmEntryOffset) == ((entry->address)));
	assert((startAddress + cmNoCheckEntryOffset) == ((noCheckEntry->address)));
	result = outputInstructionsAt(startAddress + headerSize);
	assert(((startAddress + headerSize) + codeSize) == result);
	padIfPossibleWithStopsFromto(backEnd, result, ((startAddress + totalSize) - mapSize) - 1);
	generateMapAtstart((startAddress + totalSize) - 1, startAddress + cmNoCheckEntryOffset);
	fillInBlockHeadersAt(startAddress);
	fillInMethodHeadersizeselector(((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta)), totalSize, selector);

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) startAddress), (startAddress + totalSize) - startAddress);
	sys_icache_invalidate(((void *) startAddress), (startAddress + totalSize) - startAddress);
#  else // __APPLE__ && __MACH__
	ceFlushICache(startAddress, startAddress + totalSize);
#  endif

	return ((CogMethod *) startAddress);
}


/*	Generate the method map at addressrNull (or compute it if addressOrNull is
	null). Answer the length of the map in byes. Each entry in the map is in
	two parts. In the
	least signficant bits are a displacement of how far from the start or
	previous entry,
	unless it is an IsAnnotationExtension byte, in which case those bits are
	the extension.
	In the most signficant bits are the type of annotation at the point
	reached. A null
	byte ends the map. */

	/* Cogit>>#generateMapAt:start: */
static NoDbgRegParms sqInt
generateMapAtstart(usqInt addressOrNull, usqInt startAddress)
{
    unsigned char annotation;
    sqInt delta;
    sqInt i;
    AbstractInstruction *instruction;
    sqInt length;
    usqInt location;
    sqInt mapEntry;
    sqInt maxDelta;
    usqInt mcpc;

	delta = 0;
	length = 0;
	location = startAddress;
	for (i = 0; i < opcodeIndex; i += 1) {
		instruction = abstractInstructionAt(i);
		annotation = (instruction->annotation);
		if (annotation) {
			/* begin assertValidAnnotation:for: */
			assert((annotation != (getIsObjectReference()))
			 || (((instruction->opcode)) == Literal));
			mcpc = /* mapEntryAddress */
					(((instruction->opcode)) == Literal
						? (instruction->address)
						: ((instruction->address)) + ((instruction->machineCodeSize)));
			while (((delta = (mcpc - location) / 4 /* codeGranularity */)) > DisplacementMask) {
				maxDelta = (((((delta < MaxX2NDisplacement) ? delta : MaxX2NDisplacement)) | DisplacementMask) - DisplacementMask);
				assert((((usqInt)(maxDelta)) >> AnnotationShift) <= DisplacementMask);
				if (addressOrNull) {
					/* begin addToMap:instruction:byte:at:for: */
					codeByteAtput(addressOrNull - length, (((usqInt)(maxDelta)) >> AnnotationShift) + DisplacementX2N);
				}
				location += maxDelta * 4 /* codeGranularity */;
				length += 1;
			}
			if (addressOrNull) {
				mapEntry = delta + ((((usqInt)((((annotation < IsSendCall) ? annotation : IsSendCall))) << AnnotationShift)));

				/* begin addToMap:instruction:byte:at:for: */
				codeByteAtput(addressOrNull - length, mapEntry);
			}
			location += delta * 4 /* codeGranularity */;
			length += 1;
			if (annotation > IsSendCall) {

				/* Add the necessary IsAnnotationExtension */
				if (addressOrNull) {
					mapEntry = ((((usqInt)(IsAnnotationExtension) << AnnotationShift))) + (annotation - IsSendCall);

					/* begin addToMap:instruction:byte:at:for: */
					codeByteAtput(addressOrNull - length, mapEntry);
				}
				length += 1;
			}
		}
	}
	if (addressOrNull) {
		/* begin addToMap:instruction:byte:at:for: */
		codeByteAtput(addressOrNull - length, MapEnd);
	}
	return length + 1;
}


/*	Generate the prototype OpenPIC to determine how much space an open PIC
	takes. 
 */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#generateOpenPICPrototype */
static void
generateOpenPICPrototype(void)
{
    sqInt codeSize;
    sqInt fixupSize;
    sqInt mapSize;
    sqInt opcodeSize;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 100;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	(methodLabel->address = methodZoneBase);
	(methodLabel->dependent = null);
	compileOpenPICnumArgs(specialSelector(0), numRegArgs());
	computeMaximumSizes();
	concretizeAt(methodLabel, methodZoneBase);
	codeSize = generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	mapSize = generateMapAtstart(null, methodZoneBase + cmNoCheckEntryOffset);

	/* self cCode: ''
	   inSmalltalk:
	   [| end |
	   end := self outputInstructionsAt: methodZoneBase + headerSize.
	   self disassembleFrom: methodZoneBase + (self sizeof: CogMethod) to: end - 1.
	   self halt] */
	openPICSize = (roundUpLength((sizeof(CogMethod)) + codeSize)) + (roundUpToMethodAlignment(backEnd, mapSize));
}


/*	Generate the run-time entries at the base of the native code zone and
	update the base.
 */

	/* Cogit>>#generateRunTimeTrampolines */
static void
generateRunTimeTrampolines(void)
{
	ceSendMustBeBooleanAddFalseTrampoline = genMustBeBooleanTrampolineForcalled(falseObject(), "ceSendMustBeBooleanAddFalseTrampoline");
	ceSendMustBeBooleanAddTrueTrampoline = genMustBeBooleanTrampolineForcalled(trueObject(), "ceSendMustBeBooleanAddTrueTrampoline");

	/* begin genNonLocalReturnTrampoline */
	zeroOpcodeIndex();

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, LinkReg, instructionPointerAddress()));
	ceNonLocalReturnTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNonLocalReturn, "ceNonLocalReturnTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 1);

	/* begin genCheckForInterruptsTrampoline */
	zeroOpcodeIndex();

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, LinkReg, instructionPointerAddress()));
	ceCheckForInterruptTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCheckForInterrupt, "ceCheckForInterruptTrampoline", 0, null, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 1);
	ceFetchContextInstVarTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceContextinstVar, "ceFetchContextInstVarTrampoline", 2, ReceiverResultReg, SendNumArgsReg, null, null, 0 /* emptyRegisterMask */, 1, SendNumArgsReg, 0);

	/* to keep ReceiverResultReg live. */
	ceStoreContextInstVarTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceContextinstVarvalue, "ceStoreContextInstVarTrampoline", 3, ReceiverResultReg, SendNumArgsReg, ClassReg, null, 0 /* emptyRegisterMask */, 1, ReceiverResultReg, 0);

	/* ceInvokeInterpreter is an optimization and a work-around. Historically we used setjmp/longjmp to reenter the
	   interpreter at the current C stack base.  The C stack base is set at start-up and on each callback enter and
	   callback return. The interpreter must be invoked whenever a non-machine-code method must be run.  That might
	   be when invoking an interpreter method from one of the send linking routines (ceSend:...), or on continuing from
	   an evaluation primitive such as primitiveExecuteMethod.  The problem here is that such primitives could have
	   been invoked by the interpreter or by machine code.  So some form of non-local jump is required. But at least as
	   early as MSVC Community 2017, the Microshaft longjmp performs stack unwinding which gets hoplessly confused
	   (bless its little heart) by any stack switch between machine code and C stack, and raises a spurious
	   Stack cookie instrumentation code detected a stack-based buffer overrun
	   error from the bowels of gs_report.c _GSHandlerCheck.
	   Since the CoInterpreter maintains the base of the C stack in CFramePointer & CStackPointer, it is straight-forward
	   for us to simply call interpret after doing the switch to the C stack, avoiding the stack unwind issue altogether. */
	ceCannotResumeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCannotResume, "ceCannotResumeTrampoline", 0, null, null, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 0);

	/* These two are unusual; they are reached by return instructions. */
	ceInvokeInterpret = genInvokeInterpretTrampoline();
	ceReturnToInterpreterTrampoline = genReturnToInterpreterTrampoline();
	ceBaseFrameReturnTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceBaseFrameReturn, "ceBaseFrameReturnTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 0);
	ceFFICalloutTrampoline = genFFICalloutTrampoline();
	ceMallocTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceMalloc, "ceMallocTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	ceFreeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceFree, "ceFreeTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 0);
}


/*	Generate a routine ceCaptureCStackPointers that will capture the C stack
	pointer, and, if it is in use, the C frame pointer. These are used in
	trampolines to call
	run-time routines in the interpreter from machine-code. */

	/* Cogit>>#generateStackPointerCapture */
static void
generateStackPointerCapture(void)
{
    usqInt oldMethodZoneBase;
    sqInt oldTrampolineTableIndex;


#  if defined(cFramePointerInUse)
	assertCStackWellAligned();
	generateCaptureCStackPointers(cFramePointerInUse);
#  else
	/* For the benefit of the following assert, assume the minimum at first. */
	cFramePointerInUse = 0;
	assertCStackWellAligned();
	oldMethodZoneBase = methodZoneBase;
	oldTrampolineTableIndex = trampolineTableIndex;
	generateCaptureCStackPointers(1);
	ceCaptureCStackPointers();
	if (!((cFramePointerInUse = checkIfCFramePointerInUse()))) {
		methodZoneBase = oldMethodZoneBase;
		trampolineTableIndex = oldTrampolineTableIndex;
		generateCaptureCStackPointers(0);
	}
#  endif // defined(cFramePointerInUse)


	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	assertCStackWellAligned();
}


/*	Generate the run-time entries and exits at the base of the native code
	zone and update the base.
	Read the class-side method trampolines for documentation on the various
	trampolines 
 */

	/* Cogit>>#generateTrampolines */
static void
generateTrampolines(void)
{
    sqInt fixupSize;
    usqInt methodZoneStart;
    sqInt opcodeSize;

	methodZoneStart = methodZoneBase;
	(methodLabel->address = methodZoneStart);

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 80;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	setHasYoungReferent(0);
	maybeGenerateSelectorIndexDereferenceRoutine();
	generateSendTrampolines();
	generateMissAbortTrampolines();
	generateObjectRepresentationTrampolines();
	generateRunTimeTrampolines();
	generateEnilopmarts();
	generateTracingTrampolines();
	recordGeneratedRunTimeaddress("methodZoneBase", methodZoneBase);
}

	/* Cogit>>#generatorForPC: */
static NoDbgRegParms BytecodeDescriptor *
generatorForPC(sqInt pc)
{
	return generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
}

	/* Cogit>>#genFFICalloutTrampoline */
static usqInt
genFFICalloutTrampoline(void)
{
    usqInt startAddress;

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, LinkReg, instructionPointerAddress()));

	/* CallR: */
	genoperand(CallR, TempReg);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));

	/* RetN: */
	genoperand(RetN, 0);
	startAddress = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceFFICalloutTrampoline", startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate a pair of routines that answer the frame pointer, and the stack
	pointer immediately
	after a leaf call, used for checking stack pointer alignment, frame
	pointer usage, etc. N.B.
	these are exported to the CoInterpreter et al via Cogit
	class>>mustBeGlobal:. 
 */

	/* Cogit>>#genGetLeafCallStackPointers */
static void
genGetLeafCallStackPointers(void)
{
    sqInt fixupSize;
    sqInt opcodeSize;
    usqInt startAddress;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 4;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	startAddress = methodZoneBase;

	/* MoveR:R: */
	genoperandoperand(MoveRR, FPReg, ABIResultReg);

	/* RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceGetFP", startAddress);
	ceGetFP = ((usqIntptr_t (*)(void)) startAddress);
	startAddress = methodZoneBase;
	zeroOpcodeIndex();

	/* MoveR:R: */
	genoperandoperand(MoveRR, NativeSPReg, ABIResultReg);

	/* RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceGetSP", startAddress);
	ceGetSP = ((usqIntptr_t (*)(void)) startAddress);
}


/*	Generate the abort for a PIC. This abort performs either a call of
	ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged target
	or a call of ceMNUFromPICMNUMethod:receiver: to handle an MNU dispatch
	in a closed PIC. It distinguishes the two by testing ClassReg. If the
	register is zero then this is an MNU.
	
	This poses a problem in 32-bit Spur, where zero is the cache tag for
	immediate characters (tag pattern 2r10) because SmallIntegers have tag
	patterns 2r11
	and 2r01, so anding with 1 reduces these to 0 & 1. We solve the ambiguity
	by patching send sites with a 0 cache tag to open PICs instead of closed
	PICs.  */

	/* Cogit>>#genInnerPICAbortTrampoline: */
static NoDbgRegParms usqInt
genInnerPICAbortTrampoline(char *name)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpMNUCase;

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0 /* picAbortDiscriminatorValue */, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0 /* picAbortDiscriminatorValue */, BytesPerOop));
	}
	jumpMNUCase = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceInterpretMethodFromPICreceiver, 2, SendNumArgsReg, ReceiverResultReg, null, null, 0 /* emptyRegisterMask */, 0, NoReg);
	jmpTarget(jumpMNUCase, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceMNUFromPICMNUMethodreceiver, name, 2, SendNumArgsReg, ReceiverResultReg, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 1);
}


/*	Switch to the C stack (do *not* save the Smalltalk stack pointers;
	this is the caller's responsibility), and invoke interpret PDQ. */

	/* Cogit>>#genInvokeInterpretTrampoline */
static void
(*genInvokeInterpretTrampoline(void))(void)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	quickConstant = varBaseAddress;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	genMarshallNArgsargargargarg(backEnd, 0, null, null, null, null);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(cReturnAddressAddress(), genoperandoperand(MoveAwR, cReturnAddressAddress(), LinkReg));

	/* #JumpFullRT: #JumpFull: #gen:literal: */
	checkLiteralforInstruction(((sqInt)(((usqInt)interpret))), genoperand(JumpFull, ((sqInt)(((usqInt)interpret)))));
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceInvokeInterpret", startAddress);
	return ((void (*)(void)) startAddress);
}


/*	The in-line cache for a send is implemented as a constant load into
	ClassReg. We always use a 32-bit load, even in 64-bits.
	
	In the initial (unlinked) state the in-line cache is notionally loaded
	with the selector.
	But since in 64-bits an arbitrary selector oop won't fit in a 32-bit
	constant load, we
	instead load the cache with the selector's index, either into the literal
	frame of the
	current method, or into the special selector array. Negative values are
	1-relative indices into the special selector array.
	
	When a send is linked, the load of the selector, or selector index, is
	overwritten with a
	load of the receiver's class, or class tag. Hence, the 64-bit VM is
	currently constrained
	to use class indices as cache tags. If out-of-line literals are used,
	distinct caches /must
	not/ share acche locations, for if they do, send cacheing will be confused
	by the sharing.
	Hence we use the MoveUniqueC32:R: instruction that will not share literal
	locations.  */

	/* Cogit>>#genLoadInlineCacheWithSelector: */
static NoDbgRegParms void
genLoadInlineCacheWithSelector(sqInt selectorIndex)
{
    AbstractInstruction *anInstruction;
    sqInt cacheValue;
    AbstractInstruction *existingInst;
    sqInt i;
    sqInt initialNumLiterals;
    AbstractInstruction *literalInstruction;
    AbstractInstruction *newInst;
    AbstractInstruction *newLiterals;

	assert((selectorIndex < 0
			? (((-selectorIndex) >= 1) && ((-selectorIndex) <= (numSpecialSelectors())))
			: ((selectorIndex >= 0) && (selectorIndex <= ((literalCountOf(methodObj)) - 1)))));
	cacheValue = selectorIndex;

	/* begin MoveUniqueC32:R: */
	/* begin gen:uniqueLiteral32:operand: */
	anInstruction = genoperandoperand(MoveC32R, cacheValue, ClassReg);
	assert(usesOutOfLineLiteral(anInstruction));
	if (nextLiteralIndex >= literalsSize) {
		initialNumLiterals = literalsSize + 8;

		/* begin allocateLiterals: */
		if (initialNumLiterals > literalsSize) {
			/* Must copy across state (not using realloc, cuz...) and
			   must also update existing instructions to refer to the new ones...
			   It's either this or modify all generation routines to be able to retry
			   with more literals after running out of literals. */
			newLiterals = calloc(initialNumLiterals, sizeof(CogAbstractInstruction));
			if (literals) {
				for (i = 0; i < nextLiteralIndex; i += 1) {
					existingInst = literalInstructionAt(i);
					newInst = (&(newLiterals[i]));
					cloneLiteralFrom(newInst, existingInst);
					assert(!((existingInst->dependent)));
					(existingInst->dependent = newInst);
				}
				for (i = 0; i < opcodeIndex; i += 1) {
					existingInst = abstractInstructionAt(i);
					if ((((existingInst->dependent)))
					 && (((((existingInst->dependent))->opcode)) == Literal)) {
						(existingInst->dependent = (((existingInst->dependent))->dependent));
					}
				}
			}
			free(literals);
			literals = newLiterals;
			literalsSize = initialNumLiterals;
		}
	}
	literalInstruction = literalInstructionAt(nextLiteralIndex);
	initializeUniqueLiteral(literalInstruction, cacheValue);

	/* Record the opcodeIndex of the first dependent instruction (the first instruction that references an out-of-line literal) */
	nextLiteralIndex += 1;
	if (firstOpcodeIndex > opcodeIndex) {
		firstOpcodeIndex = opcodeIndex - 1;
	}
	setLiteralSize(literalInstruction, 4);
	(anInstruction->dependent = literalInstruction);
}

	/* Cogit>>#genReturnToInterpreterTrampoline */
static usqInt
genReturnToInterpreterTrampoline(void)
{
    AbstractInstruction *anInstruction;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();

	/* PushR: */
	genoperand(PushR, ReceiverResultReg);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, FoxIFSavedIP, FPReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxIFSavedIP, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, TempReg, instructionPointerAddress()));
	genSmalltalkToCStackSwitch(0);
	genMarshallNArgsargargargarg(backEnd, 0, null, null, null, null);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(cReturnAddressAddress(), genoperandoperand(MoveAwR, cReturnAddressAddress(), LinkReg));

	/* #JumpFullRT: #JumpFull: #gen:literal: */
	checkLiteralforInstruction(((sqInt)(((usqInt)interpret))), genoperand(JumpFull, ((sqInt)(((usqInt)interpret)))));
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceReturnToInterpreterTrampoline", startAddress);
	return startAddress;
}


/*	If the client requires, then on an ARM-like RISC processor, the return
	address needs to
	be pushed to the stack so that the interpreter sees the same stack layout
	as on CISC.
 */

	/* Cogit>>#genSmalltalkToCStackSwitch: */
static NoDbgRegParms sqInt
genSmalltalkToCStackSwitch(sqInt pushLinkReg)
{
	if (pushLinkReg) {
		/* PushR: */
		genoperand(PushR, LinkReg);
	}
	genSaveStackPointers(backEnd);
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	return 0;
}


/*	Generate a trampoline with one argument that answers a result.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:floatResult: */
static NoDbgRegParms usqInt
genTrampolineForcalledargfloatResult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegfloatResultRegappendOpcodes(aRoutine, aString, 1, regOrConst0, null, null, null, 0 /* emptyRegisterMask */, 1, resultReg, 0);
}


/*	Generate a trampoline with one argument that answers a result.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:floatArg:result: */
static NoDbgRegParms usqInt
genTrampolineForcalledfloatArgresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt resultReg)
{
	return genTrampolineForcallednumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 1, regOrConst0, null, null, null, 0 /* emptyRegisterMask */, 1, resultReg, 0);
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:floatResultReg:appendOpcodes: */
static NoDbgRegParms usqInt
genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegfloatResultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegfloatResultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg:appendOpcodes: */
static NoDbgRegParms usqInt
genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean)
{
    unsigned int codeInstruction;
    unsigned int dataInstruction;
    usqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();

	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	/* begin assertCoherentCodeAt:delta: */
	codeInstruction = long32At(codeBase + cmNoCheckEntryOffset);
	dataInstruction = long32At((codeBase + cmNoCheckEntryOffset) + codeToDataDelta);
	assert(codeInstruction == dataInstruction);
#  endif // DUAL_MAPPED_CODE_ZONE

	return startAddress;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:floatArg:floatArg:floatArg:floatArg:regsToSave:pushLinkReg:resultReg:appendOpcodes: */
static NoDbgRegParms usqInt
genTrampolineForcallednumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsfloatArgfloatArgfloatArgfloatArgregsToSavepushLinkRegresultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	To return from a trampoline call we have to take the return address off
	the stack,
	iof it has been saved */

	/* Cogit>>#genTrampolineReturn: */
static NoDbgRegParms void
genTrampolineReturn(sqInt lnkRegWasPushed)
{
	if (lnkRegWasPushed) {
		/* PopR: */
		genoperand(PopR, LinkReg);

		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, 0);
	}
}


/*	<Integer> */

	/* Cogit>>#gen: */
static NoDbgRegParms AbstractInstruction *
gen(sqInt opcode)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand: */
static NoDbgRegParms AbstractInstruction *
genoperand(sqInt opcode, sqInt operand)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operand;
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand:operand: */
static NoDbgRegParms AbstractInstruction *
genoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operandOne;
	((abstractInstruction->operands))[1] = operandTwo;
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand:operand:operand: */
static NoDbgRegParms AbstractInstruction *
genoperandoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo, sqInt operandThree)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operandOne;
	((abstractInstruction->operands))[1] = operandTwo;
	((abstractInstruction->operands))[2] = operandThree;
	return abstractInstruction;
}

	/* Cogit>>#getLiteral: */
static NoDbgRegParms sqInt
getLiteral(sqInt litIndex)
{
	if (maxLitIndex < litIndex) {
		maxLitIndex = litIndex;
	}
	return literalofMethod(litIndex, methodObj);
}


/*	Access for the literal manager. */

	/* Cogit>>#getOpcodeIndex */
static sqInt
getOpcodeIndex(void)
{
	return opcodeIndex;
}

	/* Cogit>>#incrementUsageOfTargetIfLinkedSend:mcpc:ignored: */
static NoDbgRegParms sqInt
incrementUsageOfTargetIfLinkedSendmcpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt *sendTable1;
    CogMethod *targetMethod1;

	if (annotation >= IsSendCall) {
		assert(annotation != IsNSSendCall);
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));
			if (((targetMethod1->cmUsageCount)) < (CMMaxUsageCount / 2)) {
				((((CogMethod *) ((((usqInt)targetMethod1)) + codeToDataDelta)))->cmUsageCount = ((targetMethod1->cmUsageCount)) + 1);
			}
		}
	}
	return 0;
}


/*	Answer the value to put in an inline-cache that is being loaded with the
	selector. Usually this is simply the selector, but in 64-bits the cache is
	only 32-bits wide
	and so the cache is loaded with the index of the selector. */
/*	First search the special selectors; there are only 32 of them so this
	shouldn't take too long.
	We could short-circuit this by keeping a hint bit in the target method, or
	by maintaining the
	maximum range of selector oops in specialSelectors since they're likely to
	cluster. 
 */

	/* Cogit>>#indexForSelector:in: */
static NoDbgRegParms sqInt
indexForSelectorin(sqInt selector, CogMethod *cogMethod)
{
    sqInt i;
    sqInt methodOop;
    sqInt toDoLimit;

	for (i = 0; i < NumSpecialSelectors; i += 1) {
		if (selector == (specialSelector(i))) {
			return -1 - i;
		}
	}

	/* Then search the method's literal frame... open code fetchPointer:ofObject: for speed... */
	methodOop = (cogMethod->methodObject);
	toDoLimit = literalCountOfMethodHeader((cogMethod->methodHeader));
	for (i = LiteralStart; i <= toDoLimit; i += 1) {
		if ((longAt(((i * BytesPerOop) + BaseHeaderSize) + methodOop)) == selector) {
			assert(selector == (literalofMethod(i - 1, methodOop)));
			return i - 1;
		}
	}
	error("could not find selector in method when unlinking send site");
	return 0;
}

	/* Cogit>>#initializeCodeZoneFrom:upTo: */
void
initializeCodeZoneFromupTo(sqInt startAddress, sqInt endAddress)
{
    sqInt endAddressSqInt;
    usqInt endAddressUsqInt;
    AbstractInstruction *existingInst;
    sqInt fixupSize;
    sqInt i;
    AbstractInstruction *newInst;
    AbstractInstruction *newLiterals;
    sqInt numberOfAbstractOpcodes;
    sqInt opcodeSize;
    usqInt startAddressUsqInt;

	/* begin initializeBackend */
	(methodLabel->machineCodeSize = 0);
	(methodLabel->opcode = Label);
	((methodLabel->operands))[0] = 0;
	((methodLabel->operands))[1] = 0;
	assert((!((registerMaskFor(VarBaseReg)) & CallerSavedRegisterMask)));
	varBaseAddress = computeGoodVarBaseAddress();
	assert((stackLimitAddress()) >= varBaseAddress);
	assert((cStackPointerAddress()) >= varBaseAddress);
	assert((cFramePointerAddress()) >= varBaseAddress);
	assert((cReturnAddressAddress()) >= varBaseAddress);
	assert((nextProfileTickAddress()) >= varBaseAddress);

	/* begin allocateLiterals: */
	if (4 > literalsSize) {
		/* Must copy across state (not using realloc, cuz...) and
		   must also update existing instructions to refer to the new ones...
		   It's either this or modify all generation routines to be able to retry
		   with more literals after running out of literals. */
		newLiterals = calloc(4, sizeof(CogAbstractInstruction));
		if (literals) {
			for (i = 0; i < nextLiteralIndex; i += 1) {
				existingInst = literalInstructionAt(i);
				newInst = (&(newLiterals[i]));
				cloneLiteralFrom(newInst, existingInst);
				assert(!((existingInst->dependent)));
				(existingInst->dependent = newInst);
			}
			for (i = 0; i < opcodeIndex; i += 1) {
				existingInst = abstractInstructionAt(i);
				if ((((existingInst->dependent)))
				 && (((((existingInst->dependent))->opcode)) == Literal)) {
					(existingInst->dependent = (((existingInst->dependent))->dependent));
				}
			}
		}
		free(literals);
		literals = newLiterals;
		literalsSize = 4;
	}

	/* begin resetLiterals */
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);

	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

	sqMakeMemoryExecutableFromToCodeToDataDelta(startAddress, endAddress, 
#  if DUAL_MAPPED_CODE_ZONE
		(&codeToDataDelta)
#  else
		null
#  endif
		);
	codeBase = (methodZoneBase = startAddress);
	stopsFromto(backEnd, startAddress, endAddress - 1);

	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress = methodZoneBase);
	youngReferrers = (limitAddress = endAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;

	/* begin computeAllocationThreshold */
	allocationThreshold = ((((((usqInt)((limitAddress - baseAddress) * thresholdRatio))) + ((zoneAlignment()) - 1)) & ~7)) + baseAddress;
	assertValidDualZone();

	/* begin detectFeatures */
#  if __APPLE__
	/* begin detectFeaturesOnMacOS */
#  else
#  if __linux__
	detectFeaturesOnLinux(((AbstractInstruction *) backEnd));
#  else
	detectFeaturesOnRawMachine(((AbstractInstruction *) backEnd));
#  endif

#  endif // __APPLE__


	/* begin maybeGenerateCacheFlush */
	if ((numICacheFlushOpcodes(backEnd)) > 0) {
		numberOfAbstractOpcodes = numICacheFlushOpcodes(backEnd);

		/* begin allocateOpcodes:bytecodes: */
		numAbstractOpcodes = numberOfAbstractOpcodes;
		opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
		fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
		abstractOpcodes = alloca(opcodeSize + fixupSize);
		bzero(abstractOpcodes, opcodeSize + fixupSize);
		fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

		/* begin zeroOpcodeIndexForNewOpcodes */
		opcodeIndex = 0;
		firstOpcodeIndex = 0x10000;
		nextLiteralIndex = (lastDumpedLiteralIndex = 0);
		labelCounter = 0;
		startAddressUsqInt = methodZoneBase;
		generateICacheFlush(backEnd);
		outputInstructionsForGeneratedRuntimeAt(startAddressUsqInt);
		recordGeneratedRunTimeaddress("ceFlushICache", startAddressUsqInt);
		ceFlushICache = ((void (*)(usqIntptr_t,usqIntptr_t)) startAddressUsqInt);

		/* begin initialFlushICacheFrom:to: */
#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) startAddressUsqInt), (methodZoneBase - startAddressUsqInt) + 1);
		sys_icache_invalidate(((void *) startAddressUsqInt), (methodZoneBase - startAddressUsqInt) + 1);
#    elif __GNUC__
		__clear_cache(((char *) startAddressUsqInt), ((char *) methodZoneBase));
#    else
		error("cache flushing method unknown for this platform");
#    endif

	}
	if ((numDCacheFlushOpcodes(backEnd)) > 0) {
		numberOfAbstractOpcodes = numDCacheFlushOpcodes(backEnd);

		/* begin allocateOpcodes:bytecodes: */
		numAbstractOpcodes = numberOfAbstractOpcodes;
		opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
		fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
		abstractOpcodes = alloca(opcodeSize + fixupSize);
		bzero(abstractOpcodes, opcodeSize + fixupSize);
		fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));

		/* begin zeroOpcodeIndexForNewOpcodes */
		opcodeIndex = 0;
		firstOpcodeIndex = 0x10000;
		nextLiteralIndex = (lastDumpedLiteralIndex = 0);
		labelCounter = 0;
		startAddressUsqInt = methodZoneBase;
		generateDCacheFlush(backEnd);
		outputInstructionsForGeneratedRuntimeAt(startAddressUsqInt);
		recordGeneratedRunTimeaddress("ceFlushDCache", startAddressUsqInt);
		ceFlushDCache = ((void (*)(usqIntptr_t,usqIntptr_t)) startAddressUsqInt);

		/* begin initialFlushICacheFrom:to: */
#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) startAddressUsqInt), (methodZoneBase - startAddressUsqInt) + 1);
		sys_icache_invalidate(((void *) startAddressUsqInt), (methodZoneBase - startAddressUsqInt) + 1);
#    elif __GNUC__
		__clear_cache(((char *) startAddressUsqInt), ((char *) methodZoneBase));
#    else
		error("cache flushing method unknown for this platform");
#    endif

	}
	genGetLeafCallStackPointers();
	generateStackPointerCapture();
	generateTrampolines();
	computeEntryOffsets();
	computeFullBlockEntryOffsets();
	generateClosedPICPrototype();
	alignMethodZoneBase();
	endAddressSqInt = ((usqInt)methodZoneBase);

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) startAddress), endAddressSqInt - startAddress);
	sys_icache_invalidate(((void *) startAddress), endAddressSqInt - startAddress);
#  else // __APPLE__ && __MACH__
	ceFlushICache(startAddress, endAddressSqInt);
#  endif

	startAddressUsqInt = startAddress;
	endAddressUsqInt = ((usqInt)methodZoneBase);

	/* begin maybeFlushWritableZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	if (codeToDataDelta > 0) {
		flushDCacheFromto(backEnd, startAddressUsqInt, endAddressUsqInt);
	}
#  endif


	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress = methodZoneBase);
	youngReferrers = (limitAddress = endAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;

	/* begin computeAllocationThreshold */
	allocationThreshold = ((((((usqInt)((limitAddress - baseAddress) * thresholdRatio))) + ((zoneAlignment()) - 1)) & ~7)) + baseAddress;
	generateOpenPICPrototype();
}


/*	Answer a usage count that reflects likely long-term usage.
	Answer 1 for non-primitives or quick primitives (inst var accessors),
	2 for methods with interpreter primitives, and 3 for compiled primitives. */

	/* Cogit>>#initialMethodUsageCount */
static sqInt
initialMethodUsageCount(void)
{
	if ((primitiveIndex == 1)
	 || (isQuickPrimitiveIndex(primitiveIndex))) {
		return 1;
	}
	if (!(primitiveGeneratorOrNil())) {
		return 2;
	}
	return 3;
}


/*	Answer a usage count that reflects likely long-term usage. */

	/* Cogit>>#initialOpenPICUsageCount */
static int
initialOpenPICUsageCount(void)
{
	return CMMaxUsageCount - 1;
}

	/* Cogit>>#inverseBranchFor: */
static NoDbgRegParms sqInt
inverseBranchFor(sqInt opcode)
{
	switch (opcode) {
	case JumpLongZero:
		return JumpLongNonZero;

	case JumpLongNonZero:
		return JumpLongZero;

	case JumpZero:
		return JumpNonZero;

	case JumpNonZero:
		return JumpZero;

	case JumpNegative:
		return JumpNonNegative;

	case JumpNonNegative:
		return JumpNegative;

	case JumpOverflow:
		return JumpNoOverflow;

	case JumpNoOverflow:
		return JumpOverflow;

	case JumpCarry:
		return JumpNoCarry;

	case JumpNoCarry:
		return JumpCarry;

	case JumpLess:
		return JumpGreaterOrEqual;

	case JumpGreaterOrEqual:
		return JumpLess;

	case JumpGreater:
		return JumpLessOrEqual;

	case JumpLessOrEqual:
		return JumpGreater;

	case JumpBelow:
		return JumpAboveOrEqual;

	case JumpAboveOrEqual:
		return JumpBelow;

	case JumpAbove:
		return JumpBelowOrEqual;

	case JumpBelowOrEqual:
		return JumpAbove;

	default:
		error("Case not found and no otherwise clause");
	}
	error("invalid opcode for inverse");
	return 0;
}


/*	Useful for debugging. Marked <api> so the code generator won't delete it. */

	/* Cogit>>#isPCWithinMethodZone: */
static NoDbgRegParms int
isPCWithinMethodZone(void *address)
{
	return (((((usqInt)address)) >= methodZoneBase) && ((((usqInt)address)) <= (freeStart())));
}


/*	Answer if the instruction preceding retpc is a call instruction. */

	/* Cogit>>#isSendReturnPC: */
sqInt
isSendReturnPC(sqInt retpc)
{
    sqInt target;

	if (!(isCallPrecedingReturnPC(backEnd, retpc))) {
		return 0;
	}
	target = callTargetFromReturnAddress(backEnd, retpc);
	return (((target >= firstSend) && (target <= lastSend)))
	 || (((target >= methodZoneBase) && (target <= (freeStart()))));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPEqual: */
static NoDbgRegParms AbstractInstruction *
gJumpFPEqual(void *jumpTarget)
{
	return genoperand(JumpFPEqual, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPGreaterOrEqual: */
static NoDbgRegParms AbstractInstruction *
gJumpFPGreaterOrEqual(void *jumpTarget)
{
	return genoperand(JumpFPGreaterOrEqual, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPGreater: */
static NoDbgRegParms AbstractInstruction *
gJumpFPGreater(void *jumpTarget)
{
	return genoperand(JumpFPGreater, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPLessOrEqual: */
static NoDbgRegParms AbstractInstruction *
gJumpFPLessOrEqual(void *jumpTarget)
{
	return genoperand(JumpFPLessOrEqual, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPLess: */
static NoDbgRegParms AbstractInstruction *
gJumpFPLess(void *jumpTarget)
{
	return genoperand(JumpFPLess, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPNotEqual: */
static NoDbgRegParms AbstractInstruction *
gJumpFPNotEqual(void *jumpTarget)
{
	return genoperand(JumpFPNotEqual, ((sqInt)jumpTarget));
}

	/* Cogit>>#LogicalShiftLeftCq:R: */
static NoDbgRegParms AbstractInstruction *
gLogicalShiftLeftCqR(sqInt quickConstant, sqInt reg)
{
	return genoperandoperand(LogicalShiftLeftCqR, quickConstant, reg);
}


/*	destReg := srcReg << quickConstant */

	/* Cogit>>#LogicalShiftLeftCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gLogicalShiftLeftCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	return genoperandoperandoperand(LogicalShiftLeftCqRR, quickConstant, srcReg, destReg);
	first = genoperandoperand(MoveRR, srcReg, destReg);
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, destReg);
	return first;
}


/*	destReg := (unsigned)srcReg >> quickConstant */

	/* Cogit>>#LogicalShiftRightCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gLogicalShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	return genoperandoperandoperand(LogicalShiftRightCqRR, quickConstant, srcReg, destReg);
	first = genoperandoperand(MoveRR, srcReg, destReg);
	genoperandoperand(LogicalShiftRightCqR, quickConstant, destReg);
	return first;
}

	/* Cogit>>#lastOpcode */
static AbstractInstruction *
lastOpcode(void)
{
	assert(opcodeIndex > 0);
	return abstractInstructionAt(opcodeIndex - 1);
}

	/* Cogit>>#linkSendAt:in:to:offset:receiver: */
void
linkSendAtintooffsetreceiver(sqInt callSiteReturnAddress, CogMethod *sendingMethod, CogMethod *targetMethod, sqInt theEntryOffset, sqInt receiver)
{
    sqInt extent;
    sqInt inlineCacheTag;

	assert((theEntryOffset == cmEntryOffset)
	 || (theEntryOffset == cmNoCheckEntryOffset));
	assert(((callSiteReturnAddress >= methodZoneBase) && (callSiteReturnAddress <= (freeStart()))));

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	if (theEntryOffset == cmNoCheckEntryOffset) {

		/* no need to change selector cache tag */
		extent = rewriteCallAttarget(backEnd, callSiteReturnAddress, (((sqInt)targetMethod)) + cmNoCheckEntryOffset);
	}
	else {
		inlineCacheTag = inlineCacheTagForInstance(receiver);
		extent = rewriteInlineCacheAttagtarget(backEnd, callSiteReturnAddress, inlineCacheTag, (((sqInt)targetMethod)) + theEntryOffset);
	}

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) ((((usqInt)callSiteReturnAddress)) - extent)), (((usqInt)callSiteReturnAddress)) - ((((usqInt)callSiteReturnAddress)) - extent));
	sys_icache_invalidate(((void *) ((((usqInt)callSiteReturnAddress)) - extent)), (((usqInt)callSiteReturnAddress)) - ((((usqInt)callSiteReturnAddress)) - extent));
#  else // __APPLE__ && __MACH__
	ceFlushICache((((usqInt)callSiteReturnAddress)) - extent, ((usqInt)callSiteReturnAddress));
#  endif
}

	/* Cogit>>#loadBytesAndGetDescriptor */
static BytecodeDescriptor *
loadBytesAndGetDescriptor(void)
{
    BytecodeDescriptor *descriptor;

	byte0 = (fetchByteofObject(bytecodePC, methodObj)) + bytecodeSetOffset;
	descriptor = generatorAt(byte0);
	loadSubsequentBytesForDescriptorat(descriptor, bytecodePC);
	return descriptor;
}

	/* Cogit>>#loadSubsequentBytesForDescriptor:at: */
static NoDbgRegParms void
loadSubsequentBytesForDescriptorat(BytecodeDescriptor *descriptor, sqInt pc)
{
	if (((descriptor->numBytes)) > 1) {
		byte1 = fetchByteofObject(pc + 1, methodObj);
		if (((descriptor->numBytes)) > 2) {
			byte2 = fetchByteofObject(pc + 2, methodObj);
			if (((descriptor->numBytes)) > 3) {
				byte3 = fetchByteofObject(pc + 3, methodObj);
				if (((descriptor->numBytes)) > 4) {
					notYetImplemented();
				}
			}
		}
	}
}

	/* Cogit>>#MoveCq:R: */
static NoDbgRegParms AbstractInstruction *
gMoveCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return anInstruction;
}

	/* Cogit>>#MoveCw:R: */
static NoDbgRegParms AbstractInstruction *
gMoveCwR(sqInt wordConstant, sqInt reg)
{
	return checkLiteralforInstruction(wordConstant, genoperandoperand(MoveCwR, wordConstant, reg));
}

	/* Cogit>>#MovePerfCnt64R:L: */
static NoDbgRegParms AbstractInstruction *
gMovePerfCnt64RL(sqInt destReg, sqInt liveRegisterMask)
{
	assert(BytesPerWord == 8);
	return genoperandoperand(MovePerfCnt64RL, destReg, liveRegisterMask);
}

	/* Cogit>>#MoveR:Mw:r: */
static NoDbgRegParms AbstractInstruction *
gMoveRMwr(sqInt sourceReg, sqInt offset, sqInt baseReg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, baseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	return anInstruction;
}


/*	Answer the address of the null byte at the end of the method map. */

	/* Cogit>>#mapEndFor: */
static NoDbgRegParms sqInt
mapEndFor(CogMethod *cogMethod)
{
    sqInt end;

	end = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	while ((byteAt(end)) != MapEnd) {
		end -= 1;
		assert(end > (firstMappedPCFor(cogMethod)));
	}
	return end;
}


/*	Unlinking/GC/Disassembly support */
/*	most of the time arg is a CogMethod... */

	/* Cogit>>#mapFor:performUntil:arg: */
static NoDbgRegParms sqInt
mapForperformUntilarg(CogMethod *cogMethod, sqInt (*functionSymbol)(sqInt annotation, char *mcpc, CogMethod *arg), CogMethod *arg)
{
    sqInt annotation;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	mapByte = 0;
	mcpc = /* firstMappedPCFor: */
			((((cogMethod->cmType)) >= CMMethod)
		 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {
			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = functionSymbol(annotation, (((char *) mcpc)), arg);
			if (result) {
				return result;
			}
		}
		else {
			if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
			}
		}
		map -= 1;
	}
	return 0;
}


/*	Remap all object references in the closed PIC. Answer if any references
	are young.
	Set codeModified if any modifications are made. */

	/* Cogit>>#mapObjectReferencesInClosedPIC: */
static NoDbgRegParms sqInt
mapObjectReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt pc;
    sqInt refersToYoung;

	/* first we check the potential method oop load at the beginning of the CPIC */
	pc = addressOfEndOfCaseinCPIC(1, cPIC);

	/* We find the end address of the cPICNumCases'th case and can then just step forward by the case size thereafter */
	refersToYoung = remapMaybeObjRefInClosedPICAt(pc - (jumpLongByteSize(backEnd)));

	/* Next we check the potential class ref in the compare instruction, and the potential method oop load for each case. */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (remapMaybeObjRefInClosedPICAt((pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))) {
			refersToYoung = 1;
		}
		pc += cPICCaseSize;
	}
	return refersToYoung;
}


/*	Update all references to objects in the generated runtime. */

	/* Cogit>>#mapObjectReferencesInGeneratedRuntime */
static void
mapObjectReferencesInGeneratedRuntime(void)
{
    sqInt i;
    sqInt literal;
    sqInt mappedLiteral;
    usqInt mcpc;

	for (i = 0; i < runtimeObjectRefIndex; i += 1) {
		mcpc = objectReferencesInRuntime[i];
		literal = longAt(mcpc);
		mappedLiteral = remapObject(literal);
		if (mappedLiteral != literal) {
			/* begin setCodeModified */
#      if DUAL_MAPPED_CODE_ZONE
			codeModified = 1;
#      else
			if (!codeModified) {
				codeModified = 1;

				/* begin makeCodeZoneWritable */
#        if __APPLE__ && __MACH__
				pthread_jit_write_protect_np(0);
				PJWPNClear = __LINE__;
#        endif

			}
#      endif // DUAL_MAPPED_CODE_ZONE


			/* begin storeLiteral:atAnnotatedAddress:using: */
			codeLongAtput(mcpc, mappedLiteral);
		}
	}
}


/*	Update all references to objects in machine code for a become.
	Unlike incrementalGC or fullGC a method that does not refer to young may
	refer to young as a result of the become operation. Unlike incrementalGC
	or fullGC the reference from a Cog method to its methodObject *must not*
	change since the two are two halves of the same object. */

	/* Cogit>>#mapObjectReferencesInMachineCodeForBecome */
static void
mapObjectReferencesInMachineCodeForBecome(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt freedPIC;
    sqInt hasYoungObj;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt remappedMethod;
    sqInt result;
    CogMethod *writableCogMethod;

	hasYoungObj = 0;
	codeModified = (freedPIC = 0);
	mapObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		assert(!hasYoungObj);
		if (!(((cogMethod->cmType)) == CMFree)) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
			(writableCogMethod->selector = remapOop((cogMethod->selector)));
			if (((cogMethod->cmType)) == CMClosedPIC) {
				if ((isYoung((cogMethod->selector)))
				 || (mapObjectReferencesInClosedPIC(cogMethod))) {
					freedPIC = 1;
					freeMethod(cogMethod);
				}
			}
			else {
				if (isYoung((cogMethod->selector))) {
					hasYoungObj = 1;
				}
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					remappedMethod = remapOop((cogMethod->methodObject));
					if (remappedMethod != ((cogMethod->methodObject))) {
						if (methodHasCogMethod(remappedMethod)) {
							error("attempt to become two cogged methods");
						}
						if (!(withoutForwardingOnandwithsendToCogit((cogMethod->methodObject), remappedMethod, (cogMethod->cmUsesPenultimateLit), methodhasSameCodeAscheckPenultimate))) {
							error("attempt to become cogged method into different method");
						}
						if ((rawHeaderOf((cogMethod->methodObject))) == (((sqInt)cogMethod))) {
							rawHeaderOfput((cogMethod->methodObject), (cogMethod->methodHeader));
							(writableCogMethod->methodHeader = rawHeaderOf(remappedMethod));
							(writableCogMethod->methodObject = remappedMethod);
							rawHeaderOfput(remappedMethod, ((sqInt)cogMethod));
						}
						else {
							assert((noAssertMethodClassAssociationOf((cogMethod->methodObject))) == (nilObject()));
							(writableCogMethod->methodHeader = rawHeaderOf(remappedMethod));
							(writableCogMethod->methodObject = remappedMethod);
						}
					}
					if (isYoung((cogMethod->methodObject))) {
						hasYoungObj = 1;
					}
				}

				/* begin mapFor:performUntil:arg: */
				mapByte = 0;
				mcpc = /* firstMappedPCFor: */
						((((cogMethod->cmType)) >= CMMethod)
					 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
							? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
							: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, ((char *) mcpc), ((void *)((&hasYoungObj))));
						if (result) {
							goto l1;
						}
					}
					else {
						if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
						}
					}
					map -= 1;
				}
l1:	/* end mapFor:performUntil:arg: */;
				if (hasYoungObj) {
					ensureInYoungReferrers(cogMethod);
					hasYoungObj = 0;
				}
				else {
					(cogMethod->cmRefersToYoung = 0);
				}
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (freedPIC) {
		unlinkSendsToFree();
	}
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		endAddress = freeStart();

		/* begin flushICacheFrom:to: */
		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneExecutable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(1);
		PJWPNSet = __LINE__;
		PJWPNChange = __LINE__;
		PJWPNState = 1;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) (((usqInt)codeBase))), endAddress - (((usqInt)codeBase)));
		sys_icache_invalidate(((void *) (((usqInt)codeBase))), endAddress - (((usqInt)codeBase)));
#    else // __APPLE__ && __MACH__
		ceFlushICache(((usqInt)codeBase), endAddress);
#    endif

	}
}


/*	Update all references to objects in machine code for a full gc. Since
	the current (New)ObjectMemory GC makes everything old in a full GC
	a method not referring to young will not refer to young afterwards */

	/* Cogit>>#mapObjectReferencesInMachineCodeForFullGC */
static void
mapObjectReferencesInMachineCodeForFullGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *writableCogMethod;

	codeModified = 0;
	mapObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
			(writableCogMethod->selector = remapOop((cogMethod->selector)));
			if (((cogMethod->cmType)) == CMClosedPIC) {
				assert(!((cogMethod->cmRefersToYoung)));
				mapObjectReferencesInClosedPIC(cogMethod);
			}
			else {
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					(writableCogMethod->methodObject = remapOop((cogMethod->methodObject)));
				}

				/* begin mapFor:performUntil:arg: */
				mapByte = 0;
				mcpc = /* firstMappedPCFor: */
						((((cogMethod->cmType)) >= CMMethod)
					 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
							? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
							: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, ((char *) mcpc), 0);
						if (result) {
							goto l1;
						}
					}
					else {
						if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
						}
					}
					map -= 1;
				}
l1:	/* end mapFor:performUntil:arg: */;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		endAddress = freeStart();

		/* begin flushICacheFrom:to: */
		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneExecutable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(1);
		PJWPNSet = __LINE__;
		PJWPNChange = __LINE__;
		PJWPNState = 1;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) (((usqInt)codeBase))), endAddress - (((usqInt)codeBase)));
		sys_icache_invalidate(((void *) (((usqInt)codeBase))), endAddress - (((usqInt)codeBase)));
#    else // __APPLE__ && __MACH__
		ceFlushICache(((usqInt)codeBase), endAddress);
#    endif

	}
}


/*	Update all references to objects in machine code for either a Spur
	scavenging gc
	or a Squeak V3 incremental GC. Avoid scanning all code by using the
	youngReferrers list. In a young gc a method referring to young may no
	longer refer to young, but a
	method not referring to young cannot and will not refer to young
	afterwards.  */

	/* Cogit>>#mapObjectReferencesInMachineCodeForYoungGC */
static void
mapObjectReferencesInMachineCodeForYoungGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt hasYoungObj;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    usqInt pointer;
    sqInt result;
    CogMethod *writableCogMethod;
    sqInt zoneIsWritable;

	codeModified = (zoneIsWritable = (hasYoungObj = 0));
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		assert(!hasYoungObj);
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (((cogMethod->cmType)) == CMFree) {
			assert(!((cogMethod->cmRefersToYoung)));
		}
		else {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			if ((cogMethod->cmRefersToYoung)) {
				assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
				 || (isCMOpenPIC(((CogBlockMethod *) cogMethod))));
				if (!zoneIsWritable) {
					/* begin ensureWritableCodeZone */
#          if !DUAL_MAPPED_CODE_ZONE
					/* begin makeCodeZoneWritable */
#          if __APPLE__ && __MACH__
					pthread_jit_write_protect_np(0);
					PJWPNClear = __LINE__;
#          endif

#          endif // !DUAL_MAPPED_CODE_ZONE

					zoneIsWritable = 1;
				}
				writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
				(writableCogMethod->selector = remapOop((cogMethod->selector)));
				if (isYoung((cogMethod->selector))) {
					hasYoungObj = 1;
				}
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					(writableCogMethod->methodObject = remapOop((cogMethod->methodObject)));
					if (isYoung((cogMethod->methodObject))) {
						hasYoungObj = 1;
					}
				}

				/* begin mapFor:performUntil:arg: */
				mapByte = 0;
				mcpc = /* firstMappedPCFor: */
						((((cogMethod->cmType)) >= CMMethod)
					 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
							? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
							: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, ((char *) mcpc), ((void *)((&hasYoungObj))));
						if (result) {
							goto l1;
						}
					}
					else {
						if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
						}
					}
					map -= 1;
				}
l1:	/* end mapFor:performUntil:arg: */;
				if (hasYoungObj) {
					hasYoungObj = 0;
				}
				else {
					(writableCogMethod->cmRefersToYoung = 0);
				}
			}
		}
		pointer += BytesPerWord;
	}
	pruneYoungReferrers();
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		endAddress = freeStart();

		/* begin flushICacheFrom:to: */
		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneExecutable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(1);
		PJWPNSet = __LINE__;
		PJWPNChange = __LINE__;
		PJWPNState = 1;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
		sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#    else // __APPLE__ && __MACH__
		ceFlushICache(((usqInt)methodZoneBase), endAddress);
#    endif

	}
}


/*	Update all references to objects in machine code. */

	/* Cogit>>#mapObjectReferencesInMachineCode: */
void
mapObjectReferencesInMachineCode(sqInt gcMode)
{
	switch (gcMode) {
	case GCModeNewSpace:

		/* N.B. do *not* ensureWritableCodeZone for every scavenge. */
		mapObjectReferencesInMachineCodeForYoungGC();
		break;
	case GCModeFull:
		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneWritable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(0);
		PJWPNClear = __LINE__;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

		mapObjectReferencesInMachineCodeForFullGC();
		break;
	case GCModeBecome:
		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneWritable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(0);
		PJWPNClear = __LINE__;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

		mapObjectReferencesInMachineCodeForBecome();
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	mapPerMethodProfile();
	if (!(asserta((freeStart()) <= (youngReferrers)))) {
		error("youngReferrers list overflowed");
	}
}


/*	Mark objects in machine-code of marked methods (or open PICs with marked
	selectors). 
 */

	/* Cogit>>#markAndTraceMachineCodeOfMarkedMethods */
void
markAndTraceMachineCodeOfMarkedMethods(void)
{
    sqInt annotation;
    sqInt annotationSqInt;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt map;
    sqInt mapByte;
    sqInt mapByteSqInt;
    sqInt mapSqInt;
    sqInt mcpc;
    sqInt mcpcSqInt;
    sqInt result;
    sqInt resultSqInt;

	if (leakCheckFullGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	codeModified = 0;
	markAndTraceObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) >= CMMethod)
		 && (isMarked((cogMethod->methodObject)))) {
			/* begin markAndTraceLiteralsIn: */
			assert(((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
			 && (isMarked((cogMethod->methodObject))))
			 || ((isCMOpenPIC(((CogBlockMethod *) cogMethod)))
			 && ((isImmediate((cogMethod->selector)))
			 || (isMarked((cogMethod->selector))))));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));

			/* begin maybeMarkIRCsIn: */
			mapByte = 0;
			mcpc = /* firstMappedPCFor: */
					((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
						? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
						: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = markLiteralspcmethod(annotation, ((char *) mcpc), cogMethod);
					if (result) {
						goto l1;
					}
				}
				else {
					if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
					}
				}
				map -= 1;
			}
l1:	/* end mapFor:performUntil:arg: */;
		}
		if ((((cogMethod->cmType)) == CMOpenPIC)
		 && ((isImmediate((cogMethod->selector)))
		 || (isMarked((cogMethod->selector))))) {
			/* begin markAndTraceLiteralsIn: */
			assert(((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
			 && (isMarked((cogMethod->methodObject))))
			 || ((isCMOpenPIC(((CogBlockMethod *) cogMethod)))
			 && ((isImmediate((cogMethod->selector)))
			 || (isMarked((cogMethod->selector))))));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));

			/* begin maybeMarkIRCsIn: */
			mapByteSqInt = 0;
			mcpcSqInt = /* firstMappedPCFor: */
					((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
						? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
						: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			mapSqInt = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByteSqInt = byteAt(mapSqInt))) != MapEnd) {
				if (mapByteSqInt >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpcSqInt += (mapByteSqInt & DisplacementMask) * 4 /* codeGranularity */;
					if ((((annotationSqInt = ((usqInt)(mapByteSqInt)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByteSqInt = byteAt(mapSqInt - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotationSqInt += mapByteSqInt & DisplacementMask;
						mapSqInt -= 1;
					}
					resultSqInt = markLiteralspcmethod(annotationSqInt, ((char *) mcpcSqInt), cogMethod);
					if (resultSqInt) {
						goto l2;
					}
				}
				else {
					if (mapByteSqInt < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpcSqInt += ((((usqInt)((mapByteSqInt - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
					}
				}
				mapSqInt -= 1;
			}
l2:	/* end mapFor:performUntil:arg: */;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (leakCheckFullGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		endAddress = freeStart();

		/* begin flushICacheFrom:to: */
		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneExecutable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(1);
		PJWPNSet = __LINE__;
		PJWPNChange = __LINE__;
		PJWPNState = 1;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
		sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#    else // __APPLE__ && __MACH__
		ceFlushICache(((usqInt)methodZoneBase), endAddress);
#    endif

	}
}


/*	Mark and trace any object references in the generated run-time. */

	/* Cogit>>#markAndTraceObjectReferencesInGeneratedRuntime */
static void
markAndTraceObjectReferencesInGeneratedRuntime(void)
{
    sqInt i;
    sqInt literal;
    usqInt mcpc;

	for (i = 0; i < runtimeObjectRefIndex; i += 1) {
		mcpc = objectReferencesInRuntime[i];
		literal = longAt(mcpc);
		markAndTraceLiteralinatpc(literal, ((CogMethod *) null), ((usqInt)mcpc));
	}
}


/*	Mark and trace objects in the argument and free if it is appropriate.
	Answer if the method has been freed. firstVisit is a hint used to avoid
	scanning methods we've already seen. False positives are fine.
	For a CMMethod this
	frees if the bytecode method isnt marked,
	marks and traces object literals and selectors,
	unlinks sends to targets that should be freed.
	For a CMClosedPIC this
	frees if it refers to anything that should be freed or isn't marked.
	For a CMOpenPIC this
	frees if the selector isn't marked. */
/*	this recurses at most one level down */

	/* Cogit>>#markAndTraceOrFreeCogMethod:firstVisit: */
static NoDbgRegParms sqInt
markAndTraceOrFreeCogMethodfirstVisit(CogMethod *cogMethod, sqInt firstVisit)
{
    sqInt annotation;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (((cogMethod->cmType)) == CMFree) {
		return 1;
	}
	assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
	if (((cogMethod->cmType)) >= CMMethod) {
		if (!(isMarked((cogMethod->methodObject)))) {
			/* begin ensureWritableCodeZone */
#      if !DUAL_MAPPED_CODE_ZONE
			/* begin makeCodeZoneWritable */
#      if __APPLE__ && __MACH__
			pthread_jit_write_protect_np(0);
			PJWPNClear = __LINE__;
#      endif

#      endif // !DUAL_MAPPED_CODE_ZONE

			freeMethod(cogMethod);
			return 1;
		}
		if (firstVisit) {
			/* begin markLiteralsAndUnlinkUnmarkedSendsIn: */
			assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
			assert(isMarked((cogMethod->methodObject)));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));

			/* begin maybeMarkIRCsIn: */
			mapByte = 0;
			mcpc = /* firstMappedPCFor: */
					((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
						? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
						: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = markLiteralsAndUnlinkIfUnmarkedSendpcmethod(annotation, ((char *) mcpc), cogMethod);
					if (result) {
						goto l1;
					}
				}
				else {
					if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
					}
				}
				map -= 1;
			}
l1:	/* end mapFor:performUntil:arg: */;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		if (!(closedPICRefersToUnmarkedObject(cogMethod))) {
			return 0;
		}

		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneWritable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(0);
		PJWPNClear = __LINE__;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

		freeMethod(cogMethod);
		return 1;
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		if (isMarked((cogMethod->selector))) {
			return 0;
		}

		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneWritable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(0);
		PJWPNClear = __LINE__;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

		freeMethod(cogMethod);
		return 1;
	}
	assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
	 || ((isCMClosedPIC(((CogBlockMethod *) cogMethod)))
	 || (isCMOpenPIC(((CogBlockMethod *) cogMethod)))));
	return 0;
}


/*	If entryPoint is that of some method, then mark and trace objects in it
	and free if it is appropriate.
	Answer if the method has been freed. */

	/* Cogit>>#markAndTraceOrFreePICTarget:in: */
static NoDbgRegParms sqInt
markAndTraceOrFreePICTargetin(sqInt entryPoint, CogMethod *cPIC)
{
    CogMethod *targetMethod;

	assert((entryPoint > methodZoneBase)
	 && (entryPoint < (freeStart())));
	if (/* containsAddress: */
		((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
	 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {
		return 0;
	}
	targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
	assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
	 || (isCMFree(((CogBlockMethod *) targetMethod))));
	return markAndTraceOrFreeCogMethodfirstVisit(targetMethod, (((usqInt)targetMethod)) > (((usqInt)cPIC)));
}


/*	Mark and trace literals. Unlink sends that have unmarked cache tags or
	targets. 
 */

	/* Cogit>>#markLiteralsAndUnlinkIfUnmarkedSend:pc:method: */
static NoDbgRegParms sqInt
markLiteralsAndUnlinkIfUnmarkedSendpcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    unsigned int cacheTag1;
    sqInt cacheTagMarked;
    sqInt entryPointSqInt;
    sqInt literal;
    sqInt offsetSqInt;
    sqInt pc;
    sqInt *sendTable1;
    sqInt tagCouldBeObjSqInt;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		if (markAndTraceLiteralinatpc(literal, ((CogMethod *) cogMethod), ((usqInt)mcpc))) {
			codeModified = 1;
		}
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		/* begin inlineCacheTagAt: */
		pc = pcRelativeAddressAt(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 8)));
		cacheTag1 = long32At(pc);

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPointSqInt = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObjSqInt = 0;
		cacheTagMarked = tagCouldBeObjSqInt;
		if (entryPointSqInt > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPointSqInt - offsetSqInt));
			if ((!cacheTagMarked)
			 || (markAndTraceOrFreeCogMethodfirstVisit(targetMethod1, (((usqInt)targetMethod1)) > (((usqInt)mcpc))))) {

				/* Either the cacheTag is unmarked (e.g. new class) or the target
				   has been freed (because it is unmarked), so unlink the send. */
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				if (!codeModified) {
					codeModified = 1;

					/* begin makeCodeZoneWritable */
#          if __APPLE__ && __MACH__
					pthread_jit_write_protect_np(0);
					PJWPNClear = __LINE__;
#          endif

				}
#        endif // DUAL_MAPPED_CODE_ZONE

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
				markAndTraceLiteralinat((targetMethod1->selector), targetMethod1, (&((targetMethod1->selector))));
			}
		}
		else {

			/* cacheTag is selector */
		}
	}
	return 0;
}


/*	Mark and trace literals.
	Additionally in Newspeak, void push implicits that have unmarked classes. */

	/* Cogit>>#markLiterals:pc:method: */
static NoDbgRegParms sqInt
markLiteralspcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    unsigned int cacheTag1;
    sqInt entryPointSqInt;
    sqInt literal;
    sqInt pc;
    sqInt tagCouldBeObjSqInt;

	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		if (markAndTraceLiteralinatpc(literal, cogMethod, ((usqInt)mcpc))) {
			codeModified = 1;
		}
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		/* begin inlineCacheTagAt: */
		pc = pcRelativeAddressAt(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 8)));
		cacheTag1 = long32At(pc);

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPointSqInt = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObjSqInt = 0;
	}
	return 0;
}

	/* Cogit>>#markMethodAndReferents: */
void
markMethodAndReferents(CogBlockMethod *aCogMethod)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *writableMethod;

	assert((isCMMethodEtAl(aCogMethod))
	 || (isCMBlock(aCogMethod)));
	cogMethod = (((aCogMethod->cmType)) >= CMMethod
				? ((CogMethod *) aCogMethod)
				: cmHomeMethod(aCogMethod));
	writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
	(writableMethod->cmUsageCount = CMMaxUsageCount);

	/* begin mapFor:performUntil:arg: */
	mapByte = 0;
	mcpc = /* firstMappedPCFor: */
			((((cogMethod->cmType)) >= CMMethod)
		 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {
			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = incrementUsageOfTargetIfLinkedSendmcpcignored(annotation, ((char *) mcpc), 0);
			if (result) {
				goto l1;
			}
		}
		else {
			if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
			}
		}
		map -= 1;
	}
l1:	/* end mapFor:performUntil:arg: */;
}

	/* Cogit>>#maxCogMethodAddress */
usqInt
maxCogMethodAddress(void)
{
	return ((usqInt)(limitZony()));
}

	/* Cogit>>#maximumDistanceFromCodeZone: */
static NoDbgRegParms sqInt
maximumDistanceFromCodeZone(sqInt anAddress)
{
	return (anAddress > codeBase
			? anAddress - codeBase
			: limitAddress - anAddress);
}


/*	Check that the header fields are consistent with the type.
	Answer 0 if it is ok, otherwise answer a code for the error. */

	/* Cogit>>#maybeFreeCogMethodDoesntLookKosher: */
static NoDbgRegParms sqInt
maybeFreeCogMethodDoesntLookKosher(CogMethod *cogMethod)
{
    sqInt result;

	result = cogMethodDoesntLookKosher(cogMethod);
	return (result == 2
			? 0
			: result);
}

	/* Cogit>>#mclassCouldBeContext */
static int
mclassCouldBeContext(void)
{
	if (receiverTags < 0) {
		receiverTags = receiverTagBitsForMethod(methodObj);
	}
	return ((receiverTags & ((1U << (numTagBits())))) != 0);
}

	/* Cogit>>#mclassIsSmallInteger */
static int
mclassIsSmallInteger(void)
{
	if (receiverTags < 0) {
		receiverTags = receiverTagBitsForMethod(methodObj);
	}
	return (((receiverTags) & 7) == 1);
}


/*	Answer the absolute machine code pc matching the zero-relative
	bytecode pc of a backward branch in cogMethod, given the start
	of the bytecodes for cogMethod's block or method object. */

	/* Cogit>>#mcPCForBackwardBranch:startBcpc:in: */
usqInt
mcPCForBackwardBranchstartBcpcin(sqInt bcpc, sqInt startbcpc, CogBlockMethod *cogMethod)
{
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpcSqInt;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    usqInt isInBlock;
    sqInt latestContinuation;
    sqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt targetPC;

	/* begin mapFor:bcpc:performUntil:arg: */
	descriptor = ((BytecodeDescriptor *) 0);
	latestContinuation = 0;
	mapByte = 0;
	nextBcpc = 0;
	assert(((cogMethod->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	result = findBackwardBranchIsBackwardBranchMcpcBcpcMatchingBcpc(null, 0 + ((((usqInt)(HasBytecodePC) << 1))), ((char *) mcpc), startbcpc, ((void *)bcpc));
	if (result) {
		return result;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpcSqInt = startbcpc;
	if (((cogMethod->cmType)) >= CMMethod) {
		isInBlock = (cogMethod->cpicHasMNUCaseOrCMIsFullBlock);
		homeMethod = ((CogMethod *) cogMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;

		/* If the method has a primitive, skip it and the error code store, if any;
		   Logically. these come before the stack check and so must be ignored. */
		bsOffset = /* begin bytecodeSetOffsetForHeader: */
				(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
					? 0x100
					: 0);
		bcpcSqInt += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpcSqInt == ((cogMethod->startpc)));
		homeMethod = cmHomeMethod(cogMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpcSqInt = startbcpc - (/* begin blockCreationBytecodeSizeForHeader: */
	(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
		? AltBlockCreationBytecodeSize
		: BlockCreationBytecodeSize));
		bsOffset = /* begin bytecodeSetOffsetForHeader: */
				(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
					? 0x100
					: 0);
		byte = (fetchByteofObject(bcpcSqInt, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpcSqInt + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bcpcSqInt, -1, aMethodObj)
		: 0));
		bcpcSqInt = startbcpc;
	}
	nExts = 0;
	enumeratingCogMethod = homeMethod;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpcSqInt, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpcSqInt >= endbcpc) {
							return 0;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpcSqInt >= latestContinuation)) {
							return 0;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpcSqInt, nExts, aMethodObj);
							targetPC = (bcpcSqInt + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpcSqInt + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bcpcSqInt, nExts, aMethodObj)
		: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpcSqInt = nextBcpc;
					nExts = ((descriptor->isExtension)
								? nExts + 1
								: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
					 && ((/* begin isBackwardBranch:at:exts:in: */
						assert(((descriptor->spanFunction))),
					(((descriptor->spanFunction))(descriptor, bcpcSqInt, nExts, aMethodObj)) < 0));
				result = findBackwardBranchIsBackwardBranchMcpcBcpcMatchingBcpc(descriptor, (isBackwardBranch
							? ((((usqInt)(annotation) << 1))) + 1
							: ((sqInt)((usqInt)(annotation) << 1))), ((char *) mcpc), (isBackwardBranch
							? bcpcSqInt - (2 * nExts)
							: bcpcSqInt), ((void *)bcpc));
				if (result) {
					return result;
				}
				bcpcSqInt = nextBcpc;
				nExts = ((descriptor->isExtension)
							? nExts + 1
							: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
			}
		}
		map -= 1;
	}
	return 0;
}


/*	For the purposes of become: see if the two methods are similar, i.e. can
	be safely becommed.
	This is pretty strict. All literals and bytecodes must be identical. Only
	trailer bytes and header
	flags can differ. */

	/* Cogit>>#method:hasSameCodeAs:checkPenultimate: */
static NoDbgRegParms sqInt
methodhasSameCodeAscheckPenultimate(sqInt methodA, sqInt methodB, sqInt comparePenultimateLiteral)
{
    sqInt bi;
    sqInt endPCA;
    sqInt headerA;
    sqInt headerB;
    sqInt li;
    sqInt numLitsA;

	headerA = methodHeaderOf(methodA);
	headerB = methodHeaderOf(methodB);
	numLitsA = literalCountOfMethodHeader(headerA);
	endPCA = endPCOf(methodA);
	if (((argumentCountOfMethodHeader(headerA)) != (argumentCountOfMethodHeader(headerB)))
	 || (((temporaryCountOfMethodHeader(headerA)) != (temporaryCountOfMethodHeader(headerB)))
	 || (((primitiveIndexOfMethodheader(methodA, headerA)) != (primitiveIndexOfMethodheader(methodB, headerB)))
	 || ((numLitsA != (literalCountOfMethodHeader(headerB)))
	 || (endPCA > (numBytesOf(methodB))))))) {
		return 0;
	}
	for (li = 1; li < numLitsA; li += 1) {
		if ((fetchPointerofObject(li, methodA)) != (fetchPointerofObject(li, methodB))) {
			if ((li < (numLitsA - 1))
			 || (comparePenultimateLiteral)) {
				return 0;
			}
		}
	}
	for (bi = (startPCOfMethodHeader(headerA)); bi <= endPCA; bi += 1) {
		if ((fetchByteofObject(bi, methodA)) != (fetchByteofObject(bi, methodB))) {
			return 0;
		}
	}
	return 1;
}

	/* Cogit>>#mnuOffset */
sqInt
mnuOffset(void)
{
	return missOffset;
}

	/* Cogit>>#NativePopR: */
static NoDbgRegParms AbstractInstruction *
gNativePopR(sqInt reg)
{
	return genoperand(NativePopR, reg);
}

	/* Cogit>>#NativePushR: */
static NoDbgRegParms AbstractInstruction *
gNativePushR(sqInt reg)
{
	return genoperand(NativePushR, reg);
}

	/* Cogit>>#NativeRetN: */
static NoDbgRegParms AbstractInstruction *
gNativeRetN(sqInt offset)
{
	return genoperand(NativeRetN, offset);
}

	/* Cogit>>#needsFrameIfImmutability: */
static NoDbgRegParms sqInt
needsFrameIfImmutability(sqInt stackDelta)
{
	return IMMUTABILITY;
}

	/* Cogit>>#needsFrameIfInBlock: */
static NoDbgRegParms sqInt
needsFrameIfInBlock(sqInt stackDelta)
{
	return inBlock > 0;
}

	/* Cogit>>#needsFrameNever: */
static NoDbgRegParms sqInt
needsFrameNever(sqInt stackDelta)
{
	return 0;
}

	/* Cogit>>#noAssertMethodClassAssociationOf: */
static NoDbgRegParms sqInt
noAssertMethodClassAssociationOf(sqInt methodPointer)
{
	return literalofMethod((literalCountOfMethodHeader(noAssertHeaderOf(methodPointer))) - 1, methodPointer);
}


/*	Check that no method is maximally marked. A maximal mark is an indication
	the method has been scanned to increase the usage count of its referent
	methods.  */

	/* Cogit>>#noCogMethodsMaximallyMarked */
static sqInt
noCogMethodsMaximallyMarked(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->cmUsageCount)) == CMMaxUsageCount)) {
			return 0;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return 1;
}


/*	Answer if all targets in the PIC are in-use methods. */

	/* Cogit>>#noTargetsFreeInClosedPIC: */
static NoDbgRegParms int
noTargetsFreeInClosedPIC(CogMethod *cPIC)
{
	return !(cPICHasFreedTargets(cPIC));
}

	/* Cogit>>#OrCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gOrCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *first;

	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(OrCqRR, quickConstant, srcReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return anInstruction;
	if (srcReg == destReg) {
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(OrCqR, quickConstant, destReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		return anInstruction;
	}
	first = genoperandoperand(MoveRR, srcReg, destReg);

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(OrCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return first;
}


/*	Store the generated machine code, answering the last address */

	/* Cogit>>#outputInstructionsAt: */
static NoDbgRegParms sqInt
outputInstructionsAt(sqInt startAddress)
{
    sqInt absoluteAddress;
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt j;

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	absoluteAddress = startAddress;
	for (i = 0; i < opcodeIndex; i += 1) {
		maybeBreakGeneratingInstructionWithIndex(i);
		abstractInstruction = abstractInstructionAt(i);
		assert(((abstractInstruction->address)) == absoluteAddress);

		/* begin outputMachineCodeAt: */
		for (j = 0; j < ((abstractInstruction->machineCodeSize)); j += 4) {
			codeLong32Atput(absoluteAddress + j, ((abstractInstruction->machineCode))[j / 4]);
		}
		absoluteAddress += (abstractInstruction->machineCodeSize);
	}
	return absoluteAddress;
}


/*	Output instructions generated for one of the generated run-time routines,
	a trampoline, etc
 */

	/* Cogit>>#outputInstructionsForGeneratedRuntimeAt: */
static NoDbgRegParms sqInt
outputInstructionsForGeneratedRuntimeAt(sqInt startAddress)
{
    sqInt endAddress;
    sqInt size;

	computeMaximumSizes();
	(methodLabel->address = startAddress);
	size = generateInstructionsAt(startAddress);
	endAddress = outputInstructionsAt(startAddress);
	assert((startAddress + size) == endAddress);
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	return startAddress;
}


/*	Code entry closed PIC full or miss to an instance of a young class or to a
	young target method.
	Attempt to patch the send site to an open PIC. Answer if the attempt
	succeeded; in fact it will
	only return if the attempt failed.
	The stack looks like:
	receiver
	args
	sp=>	sender return address */

	/* Cogit>>#patchToOpenPICFor:numArgs:receiver: */
sqInt
patchToOpenPICFornumArgsreceiver(sqInt selector, sqInt numArgs, sqInt receiver)
{
    sqInt extent;
    CogMethod *oPIC;
    sqInt outerReturn;

	/* See if an Open PIC is already available. */
	outerReturn = stackTop();
	oPIC = openPICWithSelector(selector);
	if (!oPIC) {

		/* otherwise attempt to create an Open PIC. */
		oPIC = cogOpenPICSelectornumArgs(selector, numArgs);
		if ((((((sqInt)oPIC)) >= MaxNegativeErrorCode) && ((((sqInt)oPIC)) <= -1))) {

			/* For some reason the PIC couldn't be generated, most likely a lack of code memory. */
			if ((((sqInt)oPIC)) == InsufficientCodeSpace) {
				callForCogCompiledCodeCompaction();
			}
			return 0;
		}
	}

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	extent = rewriteInlineCacheAttagtarget(backEnd, outerReturn, inlineCacheValueForSelectorin(backEnd, selector, mframeHomeMethodExport()), (((sqInt)oPIC)) + cmEntryOffset);

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) ((((usqInt)outerReturn)) - extent)), (((usqInt)outerReturn)) - ((((usqInt)outerReturn)) - extent));
	sys_icache_invalidate(((void *) ((((usqInt)outerReturn)) - extent)), (((usqInt)outerReturn)) - ((((usqInt)outerReturn)) - extent));
#  else // __APPLE__ && __MACH__
	ceFlushICache((((usqInt)outerReturn)) - extent, ((usqInt)outerReturn));
#  endif


	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) (((usqInt)oPIC))), ((((usqInt)oPIC)) + openPICSize) - (((usqInt)oPIC)));
	sys_icache_invalidate(((void *) (((usqInt)oPIC))), ((((usqInt)oPIC)) + openPICSize) - (((usqInt)oPIC)));
#  else // __APPLE__ && __MACH__
	ceFlushICache(((usqInt)oPIC), (((usqInt)oPIC)) + openPICSize);
#  endif

	executeCogMethodfromLinkedSendWithReceiver(oPIC, receiver);
	return 1;
}


/*	This value is used to decide between MNU processing
	or interpretation in the closed PIC aborts. */

	/* Cogit>>#picAbortDiscriminatorValue */
static sqInt
picAbortDiscriminatorValue(void)
{
	return 0;
}


/*	Answer the start of the abort sequence for invoking the interpreter in a
	closed PIC.
 */

	/* Cogit>>#picInterpretAbortOffset */
static sqInt
picInterpretAbortOffset(void)
{
	return (interpretOffset()) - ((pushLinkRegisterByteSize(backEnd)) + (callInstructionByteSize(backEnd)));
}

	/* Cogit>>#previousInstruction */
static AbstractInstruction *
previousInstruction(void)
{
	assert(opcodeIndex > 0);
	return abstractInstructionAt(opcodeIndex - 1);
}


/*	useful for debugging */

	/* Cogit>>#printCogMethodFor: */
void
printCogMethodFor(void *address)
{
    CogMethod *cogMethod;

	cogMethod = methodFor(address);
	if (cogMethod) {
		printCogMethod(cogMethod);
	}
	else {
		if (codeEntryFor(address)) {
			print("trampoline ");
			print(codeEntryNameFor(address));
			cr();
		}
		else {
			print("not a method");
			cr();
		}
	}
}


/*	useful for debugging */

	/* Cogit>>#printTrampolineTable */
void
printTrampolineTable(void)
{
    sqInt i;

	for (i = 0; i < trampolineTableIndex; i += 2) {
		fprintf(getTranscript(),
				"%p: %s\n",
				((void *)(trampolineAddresses[i + 1])),
				((char *)(trampolineAddresses[i])));
	}
}

	/* Cogit>>#processorHasDivQuoRemAndMClassIsSmallInteger */
static sqInt
processorHasDivQuoRemAndMClassIsSmallInteger(void)
{
	return mclassIsSmallInteger();
}

	/* Cogit>>#processorHasMultiplyAndMClassIsSmallInteger */
static sqInt
processorHasMultiplyAndMClassIsSmallInteger(void)
{
	return mclassIsSmallInteger();
}

	/* Cogit>>#recordGeneratedRunTime:address: */
static NoDbgRegParms void
recordGeneratedRunTimeaddress(char *aString, sqInt address)
{
	assert((trampolineTableIndex + 2) <= (NumTrampolines * 2));
	trampolineAddresses[trampolineTableIndex] = aString;
	trampolineAddresses[trampolineTableIndex + 1] = (((char *) address));

	/* self printTrampolineTable */
	trampolineTableIndex += 2;
}


/*	This one for C support code. */

	/* Cogit>>#recordPrimTraceFunc */
int
recordPrimTraceFunc(void)
{
	return recordPrimTrace();
}

	/* Cogit>>#recordRunTimeObjectReferences */
static void
recordRunTimeObjectReferences(void)
{
    sqInt i;
    AbstractInstruction *instruction;

	for (i = 0; i < opcodeIndex; i += 1) {
		instruction = abstractInstructionAt(i);
		if (((instruction->annotation)) == IsObjectReference) {
			assert(runtimeObjectRefIndex < NumObjRefsInRuntime);
			assert(!hasYoungReferent);
			if (hasYoungReferent) {
				error("attempt to generate run-time routine containing young object reference.  Cannot initialize Cogit run-time.");
			}
			objectReferencesInRuntime[runtimeObjectRefIndex] = (((usqInt)(/* mapEntryAddress */
	(((instruction->opcode)) == Literal
		? (instruction->address)
		: ((instruction->address)) + ((instruction->machineCodeSize))))));
			runtimeObjectRefIndex += 1;
		}
	}
}


/*	N.B. (self registerMaskFor: NoReg) = 0 */

	/* Cogit>>#registerMaskFor: */
static NoDbgRegParms sqInt
registerMaskFor(sqInt reg)
{
	return ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
}

	/* Cogit>>#registerMaskFor:and:and:and: */
static NoDbgRegParms sqInt
registerMaskForandandand(sqInt reg1, sqInt reg2, sqInt reg3, sqInt reg4)
{
	return (((1ULL << reg1) | (1ULL << reg2)) | (1ULL << reg3)) | (1ULL << reg4);
}

	/* Cogit>>#relocateCallsAndSelfReferencesInMethod: */
static NoDbgRegParms void
relocateCallsAndSelfReferencesInMethod(CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt callDelta;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqLong refDelta;
    sqInt result;

	refDelta = (cogMethod->objectHeader);
	callDelta = refDelta;
	assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
	 || (isCMOpenPIC(((CogBlockMethod *) cogMethod))));
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)cogMethod)) + missOffset)) == ((isCMMethodEtAl(((CogBlockMethod *) cogMethod))
			? methodAbortTrampolineFor((cogMethod->cmNumArgs))
			: picAbortTrampolineFor((cogMethod->cmNumArgs)))));
	relocateCallBeforeReturnPCby(backEnd, (((sqInt)cogMethod)) + missOffset, -callDelta);

	/* begin mapFor:performUntil:arg: */
	mapByte = 0;
	mcpc = /* firstMappedPCFor: */
			((((cogMethod->cmType)) >= CMMethod)
		 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
				: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {
			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = relocateIfCallOrMethodReferencemcpcdelta(annotation, ((char *) mcpc), ((void *)refDelta));
			if (result) {
				goto l1;
			}
		}
		else {
			if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
			}
		}
		map -= 1;
	}
l1:	/* end mapFor:performUntil:arg: */;
}

	/* Cogit>>#relocateCallsInClosedPIC: */
static NoDbgRegParms void
relocateCallsInClosedPIC(CogMethod *cPIC)
{
    sqInt callDelta;
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    sqInt pcSqInt;
    sqLong refDelta;
    CogMethod *targetMethod;

	refDelta = (cPIC->objectHeader);
	callDelta = refDelta;
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)cPIC)) + missOffset)) == (picAbortTrampolineFor((cPIC->cmNumArgs))));
	relocateCallBeforeReturnPCby(backEnd, (((sqInt)cPIC)) + missOffset, -callDelta);
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		entryPoint = (jumpLongTargetBeforeFollowingAddress(backEnd, pc));
		if (/* containsAddress: */
			((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
		 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {

			/* Interpret/MNU */
		}
		else {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert(isCMMethodEtAl(((CogBlockMethod *) targetMethod)));
			if (i == 1) {
				relocateJumpLongBeforeFollowingAddressby(backEnd, pc, -(callDelta - ((targetMethod->objectHeader))));
			}
			else {
				relocateJumpLongConditionalBeforeFollowingAddressby(backEnd, pc, -(callDelta - ((targetMethod->objectHeader))));
			}
		}
	}
	assert(((cPIC->cPICNumCases)) > 0);
	pcSqInt = (addressOfEndOfCaseinCPIC(2, cPIC)) + (loadPICLiteralByteSize(backEnd));

	/* begin relocateMethodReferenceBeforeAddress:by: */
	assert((instructionIsADR(((AbstractInstruction *) backEnd), instructionAt(((AbstractInstruction *) backEnd), pcSqInt - 4)))
	 || (instructionIsADR(((AbstractInstruction *) backEnd), instructionAt(((AbstractInstruction *) backEnd), pcSqInt - 8))));
	relocateJumpLongBeforeFollowingAddressby(backEnd, (((sqInt)cPIC)) + cPICEndOfCodeOffset, -callDelta);
}


/*	To placate the C static type system... */

	/* Cogit>>#relocateIfCallOrMethodReference:mcpc:delta: */
static NoDbgRegParms sqInt
relocateIfCallOrMethodReferencemcpcdelta(sqInt annotation, char *mcpc, CogMethod *refDeltaArg)
{
    sqInt callDelta;
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt refDelta;
    sqInt *sendTable1;
    CogMethod *targetMethod;
    sqInt unlinkedRoutine;

	refDelta = ((sqInt) refDeltaArg);
	callDelta = refDelta;
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint <= methodZoneBase) {

			/* send is not linked; just relocate */
			relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -callDelta);
			return 0;
		}

		/* begin offsetAndSendTableFor:annotation:into: */
		if (annotation == IsSendCall) {
			offsetSqInt = cmEntryOffset;
			sendTable1 = ordinarySendTrampolines;
		}
		else {
			if (annotation == IsDirectedSuperSend) {
				offsetSqInt = cmNoCheckEntryOffset;
				sendTable1 = directedSuperSendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperBindingSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperBindingSendTrampolines;
				}
				else {
					assert(annotation == IsSuperSend);
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = superSendTrampolines;
				}
			}
		}
		targetMethod = ((CogMethod *) (entryPoint - offsetSqInt));
		if (!(((targetMethod->cmType)) == CMFree)) {

			/* send target not freed; just relocate. */
			relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -(callDelta - ((targetMethod->objectHeader))));
			restorePICUsageCount(targetMethod);
			return 0;
		}
		unlinkedRoutine = sendTable1[((((targetMethod->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod->cmNumArgs)) : (NumSendTrampolines - 1))];
		unlinkedRoutine -= callDelta;
		rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod->selector), enumeratingCogMethod), unlinkedRoutine);
		return 0;
	}
	if (annotation == IsRelativeCall) {
		relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -callDelta);
		return 0;
	}
	if (annotation == IsAbsPCReference) {
		/* begin relocateMethodReferenceBeforeAddress:by: */
		assert((instructionIsADR(backEnd, instructionAt(backEnd, (((sqInt)mcpc)) - 4)))
		 || (instructionIsADR(backEnd, instructionAt(backEnd, (((sqInt)mcpc)) - 8))));
	}
	return 0;
}


/*	to placate the C static type system... */

	/* Cogit>>#remapIfObjectRef:pc:hasYoung: */
static NoDbgRegParms sqInt
remapIfObjectRefpchasYoung(sqInt annotation, char *mcpc, CogMethod *hasYoungPtr)
{
    unsigned int cacheTag1;
    sqInt entryPointSqInt;
    sqInt literal;
    sqInt mappedCacheTag;
    sqInt mappedLiteral;
    sqInt offsetSqInt;
    sqInt pc;
    sqInt *sendTable1;
    sqInt tagCouldBeObjSqInt;
    CogMethod *targetMethod1;

	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		if (couldBeObject(literal)) {
			mappedLiteral = remapObject(literal);
			if (literal != mappedLiteral) {
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				if (!codeModified) {
					codeModified = 1;

					/* begin makeCodeZoneWritable */
#          if __APPLE__ && __MACH__
					pthread_jit_write_protect_np(0);
					PJWPNClear = __LINE__;
#          endif

				}
#        endif // DUAL_MAPPED_CODE_ZONE


				/* begin storeLiteral:atAnnotatedAddress:using: */
				codeLongAtput(((usqInt)mcpc), mappedLiteral);
			}
			if ((hasYoungPtr != 0)
			 && (isYoung(mappedLiteral))) {
				(*((sqInt *) hasYoungPtr) = 1);
			}
		}
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		/* begin inlineCacheTagAt: */
		pc = pcRelativeAddressAt(((AbstractInstruction *) backEnd), ((usqInt)((((sqInt)mcpc)) - 8)));
		cacheTag1 = long32At(pc);

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPointSqInt = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObjSqInt = 0;
		if (tagCouldBeObjSqInt
		 && (couldBeObject(cacheTag1))) {
			mappedCacheTag = remapObject(cacheTag1);
			if (cacheTag1 != mappedCacheTag) {
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				if (!codeModified) {
					codeModified = 1;

					/* begin makeCodeZoneWritable */
#          if __APPLE__ && __MACH__
					pthread_jit_write_protect_np(0);
					PJWPNClear = __LINE__;
#          endif

				}
#        endif // DUAL_MAPPED_CODE_ZONE

				rewriteInlineCacheTagat(backEnd, mappedCacheTag, ((usqInt)mcpc));
			}
			if ((hasYoungPtr != 0)
			 && (isYoung(mappedCacheTag))) {
				(*((sqInt *) hasYoungPtr) = 1);
			}
		}
		if (hasYoungPtr) {

			/* Since the unlinking routines may rewrite the cacheTag to the send's selector, and
			   since they don't have the cogMethod to hand and can't add it to youngReferrers,
			   the method must remain in youngReferrers if the targetMethod's selector is young. */
			if (entryPointSqInt > methodZoneBase) {

				/* It's a linked send. */
				/* begin targetMethodAndSendTableFor:annotation:into: */
				/* begin offsetAndSendTableFor:annotation:into: */
				if (annotation == IsSendCall) {
					offsetSqInt = cmEntryOffset;
					sendTable1 = ordinarySendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperSendTrampolines;
					}
					else {
						if (annotation == IsDirectedSuperBindingSend) {
							offsetSqInt = cmNoCheckEntryOffset;
							sendTable1 = directedSuperBindingSendTrampolines;
						}
						else {
							assert(annotation == IsSuperSend);
							offsetSqInt = cmNoCheckEntryOffset;
							sendTable1 = superSendTrampolines;
						}
					}
				}
				targetMethod1 = ((CogMethod *) (entryPointSqInt - offsetSqInt));
				if (isYoung((targetMethod1->selector))) {
					(*((sqInt *) hasYoungPtr) = 1);
				}
			}
		}
	}
	return 0;
}


/*	Remap a potential object reference from a closed PIC.
	This may be an object reference, an inline cache tag or null.
	Answer if the updated literal is young.
	mcpc is the address of the next instruction following either
	the load of the method literal or the compare of the class tag. */

	/* Cogit>>#remapMaybeObjRefInClosedPICAt: */
static NoDbgRegParms sqInt
remapMaybeObjRefInClosedPICAt(sqInt mcpc)
{
    sqInt object;
    sqInt subject;

	object = literalBeforeFollowingAddress(backEnd, mcpc);
	if (!(couldBeObject(object))) {
		return 0;
	}
	subject = remapOop(object);
	if (object != subject) {
		/* begin setCodeModified */
#    if DUAL_MAPPED_CODE_ZONE
		codeModified = 1;
#    else
		if (!codeModified) {
			codeModified = 1;

			/* begin makeCodeZoneWritable */
#      if __APPLE__ && __MACH__
			pthread_jit_write_protect_np(0);
			PJWPNClear = __LINE__;
#      endif

		}
#    endif // DUAL_MAPPED_CODE_ZONE

		storeLiteralbeforeFollowingAddress(backEnd, subject, mcpc);
	}
	return isYoungObject(subject);
}


/*	Rewrite the three values involved in a CPIC case. Used by the initialize &
	extend CPICs.
	c.f. expectedClosedPICPrototype: */
/*	write the obj ref/operand via the second ldr */

	/* Cogit>>#rewriteCPICCaseAt:tag:objRef:target: */
static NoDbgRegParms void
rewriteCPICCaseAttagobjReftarget(sqInt followingAddress, sqInt newTag, sqInt newObjRef, sqInt newTarget)
{
    sqInt classTagPC;
    sqInt methodObjPC;

	methodObjPC = (followingAddress - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd));
	storeLiteralbeforeFollowingAddress(backEnd, newObjRef, methodObjPC);

	/* rewite the tag via the first ldr */
	classTagPC = followingAddress - (jumpLongConditionalByteSize(backEnd));
	storeLiteral32beforeFollowingAddress(backEnd, newTag, classTagPC);
	rewriteConditionalJumpLongAttarget(backEnd, followingAddress, newTarget);
}


/*	destReg := fromReg - subReg */

	/* Cogit>>#SubR:R:R: */
static NoDbgRegParms AbstractInstruction *
gSubRRR(sqInt subReg, sqInt fromReg, sqInt destReg)
{
    AbstractInstruction *first;

	return genoperandoperandoperand(SubRRR, subReg, fromReg, destReg);
	assert(subReg != destReg);
	first = genoperandoperand(MoveRR, fromReg, destReg);
	genoperandoperand(SubRR, subReg, destReg);
	return first;
}


/*	Answer the number of clean blocks found in the literal frame */

	/* Cogit>>#scanForCleanBlocks */
static sqInt
scanForCleanBlocks(void)
{
    sqInt i;
    sqInt lit;
    sqInt numCleanBlocks;
    sqInt startPCOrNil;
    sqInt toDoLimit;

	numCleanBlocks = 0;
	toDoLimit = literalCountOf(methodObj);
	for (i = 1; i <= toDoLimit; i += 1) {
		lit = fetchPointerofObject(i, methodObj);
		startPCOrNil = startPCOrNilOfLiteralin(lit, methodObj);
		if (startPCOrNil) {
			numCleanBlocks += 1;
		}
	}
	return numCleanBlocks;
}


/*	If a method is compiled to machine code via a block entry it won't have a
	selector. A subsequent send can find the method and hence fill in the
	selector. 
 */
/*	self disassembleMethod: cogMethod */

	/* Cogit>>#setSelectorOf:to: */
void
setSelectorOfto(CogMethod *cogMethod, sqInt aSelectorOop)
{
	compilationBreakpointisMNUCase(aSelectorOop, 0);
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->selector = aSelectorOop);
	if (isYoung(aSelectorOop)) {
		ensureInYoungReferrers(cogMethod);
	}

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}

	/* Cogit>>#spanForCleanBlockStartingAt: */
static NoDbgRegParms sqInt
spanForCleanBlockStartingAt(sqInt startPC)
{
    BytecodeDescriptor *descriptor;
    sqInt end;
    sqInt pc;

	pc = startPC;
	end = numBytesOf(methodObj);
	while (pc <= end) {
		/* begin generatorForPC: */
		descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
		pc += (descriptor->numBytes);
		if ((descriptor->isReturn)) {
			return pc - startPC;
		}
	}
	error("couldn't locate end of clean block");
	return 0;
}

	/* Cogit>>#stackCheckOffsetOfBlockAt:isMcpc: */
static NoDbgRegParms usqInt
stackCheckOffsetOfBlockAtisMcpc(sqInt blockEntryMcpc, sqInt mcpc)
{
    CogBlockMethod *cogBlockMethod;

	cogBlockMethod = ((CogBlockMethod *) (blockEntryMcpc - (sizeof(CogBlockMethod))));
	if (((((sqInt)cogBlockMethod)) + ((cogBlockMethod->stackCheckOffset))) == mcpc) {
		return ((usqInt)cogBlockMethod);
	}
	return 0;
}


/*	Answer a fake value for the method oop in other than the first case in the
	PIC prototype.
	Since we use MoveUniqueCw:R: it must not be confused with a
	method-relative address.
 */

	/* Cogit>>#subsequentPrototypeMethodOop */
static sqInt
subsequentPrototypeMethodOop(void)
{
	return (/* addressIsInCurrentCompilation: */
		((((usqInt)0xBADA550)) >= ((methodLabel->address)))
	 && ((((usqInt)0xBADA550)) < ((((youngReferrers) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers) : (((methodLabel->address)) + MaxMethodSize))))
			? 0xDEADEAD
			: 0xBADA550);
}

	/* Cogit>>#TstCq:R: */
static NoDbgRegParms AbstractInstruction *
gTstCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return anInstruction;
}

	/* Cogit>>#traceLinkedSendOffset */
sqInt
traceLinkedSendOffset(void)
{
	return (cmNoCheckEntryOffset + (callFullInstructionByteSize(backEnd))) + (pushLinkRegisterByteSize(backEnd));
}

	/* Cogit>>#trampolineName:numArgs: */
static NoDbgRegParms char *
trampolineNamenumArgs(char *routinePrefix, sqInt numArgs)
{
    char *theString;

	/* begin trampolineName:numArgs:limit: */
	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, ((((int) numArgs)) <= (NumSendTrampolines - 2)
			? '0' + (((int) numArgs))
			: 'N'));
	return theString;
}


/*	Malloc a string with the contents for the trampoline table */

	/* Cogit>>#trampolineName:numArgs:limit: */
static NoDbgRegParms char *
trampolineNamenumArgslimit(char *routinePrefix, int numArgs, sqInt argsLimit)
{
    char *theString;

	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, (numArgs <= argsLimit
			? '0' + numArgs
			: 'N'));
	return theString;
}

	/* Cogit>>#trampolineName:numRegArgs: */
static NoDbgRegParms char *
trampolineNamenumRegArgs(char *routinePrefix, sqInt numArgs)
{
    char *theString;

	/* begin trampolineName:numArgs:limit: */
	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, ((((int) numArgs)) <= (numRegArgs())
			? '0' + (((int) numArgs))
			: 'N'));
	return theString;
}

	/* Cogit>>#unflagBecomeFlaggedMethods */
void
unflagBecomeFlaggedMethods(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* Cogit>>#unknownBytecode */
static sqInt
unknownBytecode(void)
{
	return EncounteredUnknownBytecode;
}


/*	Unlink all sends in cog methods. */

	/* Cogit>>#unlinkAllSends */
void
unlinkAllSends(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	cogMethod = ((CogMethod *) methodZoneBase);
	voidOpenPICList();
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mapByte = 0;
			mcpc = /* firstMappedPCFor: */
					((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
						? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
						: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendpcignored(annotation, ((char *) mcpc), 0);
					if (result) {
						goto l1;
					}
				}
				else {
					if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
					}
				}
				map -= 1;
			}
l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if (!(((cogMethod->cmType)) == CMFree)) {
				freeMethod(cogMethod);
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	endAddress = freeStart();

	/* begin flushICacheFrom:to: */
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

#  if __APPLE__ && __MACH__
	sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
	sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#  else // __APPLE__ && __MACH__
	ceFlushICache(((usqInt)methodZoneBase), endAddress);
#  endif
}


/*	To placate the C static type system... */

	/* Cogit>>#unlinkIfFreeOrLinkedSend:pc:of: */
static NoDbgRegParms sqInt
unlinkIfFreeOrLinkedSendpcof(sqInt annotation, char *mcpc, CogMethod *theSelector)
{
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));
			if ((((targetMethod1->cmType)) == CMFree)
			 || (((targetMethod1->selector)) == (((sqInt) theSelector)))) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				if (!codeModified) {
					codeModified = 1;

					/* begin makeCodeZoneWritable */
#          if __APPLE__ && __MACH__
					pthread_jit_write_protect_np(0);
					PJWPNClear = __LINE__;
#          endif

				}
#        endif // DUAL_MAPPED_CODE_ZONE

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfInvalidClassSend:pc:ignored: */
static NoDbgRegParms sqInt
unlinkIfInvalidClassSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send, but maybe a super send or linked to an OpenPIC, in which case the cache tag will be a selector.... */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));
			if (!((/* annotationIsForUncheckedEntryPoint: */
					(annotation == IsSuperSend)
				 || (((annotation >= IsDirectedSuperSend) && (annotation <= IsDirectedSuperBindingSend))))
				 || (((targetMethod1->cmType)) == CMOpenPIC))) {
				if (!(isValidClassTag(inlineCacheTagAt(backEnd, ((sqInt)mcpc))))) {
					/* begin unlinkSendAt:targetMethod:sendTable: */
					unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#          if DUAL_MAPPED_CODE_ZONE
					codeModified = 1;
#          else
					if (!codeModified) {
						codeModified = 1;

						/* begin makeCodeZoneWritable */
#            if __APPLE__ && __MACH__
						pthread_jit_write_protect_np(0);
						PJWPNClear = __LINE__;
#            endif

					}
#          endif // DUAL_MAPPED_CODE_ZONE

					rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
				}
			}
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSendToFree:pc:ignored: */
static NoDbgRegParms sqInt
unlinkIfLinkedSendToFreepcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));
			if (((targetMethod1->cmType)) == CMFree) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				if (!codeModified) {
					codeModified = 1;

					/* begin makeCodeZoneWritable */
#          if __APPLE__ && __MACH__
					pthread_jit_write_protect_np(0);
					PJWPNClear = __LINE__;
#          endif

				}
#        endif // DUAL_MAPPED_CODE_ZONE

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}


/*	To placate the C static type system... */

	/* Cogit>>#unlinkIfLinkedSend:pc:if: */
static NoDbgRegParms sqInt
unlinkIfLinkedSendpcif(sqInt annotation, char *mcpc, CogMethod *criterionArg)
{
    sqInt (*criterion)(CogMethod *);
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	criterion = ((void *)criterionArg);
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));
			if (criterion(targetMethod1)) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				if (!codeModified) {
					codeModified = 1;

					/* begin makeCodeZoneWritable */
#          if __APPLE__ && __MACH__
					pthread_jit_write_protect_np(0);
					PJWPNClear = __LINE__;
#          endif

				}
#        endif // DUAL_MAPPED_CODE_ZONE

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSend:pc:ignored: */
static NoDbgRegParms sqInt
unlinkIfLinkedSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));

			/* begin unlinkSendAt:targetMethod:sendTable: */
			unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#      if DUAL_MAPPED_CODE_ZONE
			codeModified = 1;
#      else
			if (!codeModified) {
				codeModified = 1;

				/* begin makeCodeZoneWritable */
#        if __APPLE__ && __MACH__
				pthread_jit_write_protect_np(0);
				PJWPNClear = __LINE__;
#        endif

			}
#      endif // DUAL_MAPPED_CODE_ZONE

			rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSend:pc:to: */
static NoDbgRegParms sqInt
unlinkIfLinkedSendpcto(sqInt annotation, char *mcpc, CogMethod *theCogMethod)
{
    sqInt entryPoint;
    sqInt offsetSqInt;
    sqInt *sendTable1;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offsetSqInt = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				if (annotation == IsDirectedSuperSend) {
					offsetSqInt = cmNoCheckEntryOffset;
					sendTable1 = directedSuperSendTrampolines;
				}
				else {
					if (annotation == IsDirectedSuperBindingSend) {
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = directedSuperBindingSendTrampolines;
					}
					else {
						assert(annotation == IsSuperSend);
						offsetSqInt = cmNoCheckEntryOffset;
						sendTable1 = superSendTrampolines;
					}
				}
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offsetSqInt));
			if (targetMethod1 == theCogMethod) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				if (!codeModified) {
					codeModified = 1;

					/* begin makeCodeZoneWritable */
#          if __APPLE__ && __MACH__
					pthread_jit_write_protect_np(0);
					PJWPNClear = __LINE__;
#          endif

				}
#        endif // DUAL_MAPPED_CODE_ZONE

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}


/*	Unlink all sends in cog methods whose class tag is that of a forwarded
	class. 
 */

	/* Cogit>>#unlinkSendsLinkedForInvalidClasses */
void
unlinkSendsLinkedForInvalidClasses(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt freedPIC;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	cogMethod = ((CogMethod *) methodZoneBase);
	codeModified = (freedPIC = 0);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mapByte = 0;
			mcpc = /* firstMappedPCFor: */
					((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
						? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
						: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfInvalidClassSendpcignored(annotation, ((char *) mcpc), 0);
					if (result) {
						goto l1;
					}
				}
				else {
					if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
					}
				}
				map -= 1;
			}
l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if ((((cogMethod->cmType)) == CMClosedPIC)
			 && (cPICHasForwardedClass(cogMethod))) {
				freeMethod(cogMethod);
				freedPIC = 1;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedPIC) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {

			/* After possibly updating inline caches we need to flush the icache. */
			endAddress = freeStart();

			/* begin flushICacheFrom:to: */
			/* begin ensureExecutableCodeZone */
#      if !DUAL_MAPPED_CODE_ZONE
			/* begin makeCodeZoneExecutable */
#      if __APPLE__ && __MACH__
			pthread_jit_write_protect_np(1);
			PJWPNSet = __LINE__;
			PJWPNChange = __LINE__;
			PJWPNState = 1;
#      endif

#      endif // !DUAL_MAPPED_CODE_ZONE

#      if __APPLE__ && __MACH__
			sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
			sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#      else // __APPLE__ && __MACH__
			ceFlushICache(((usqInt)methodZoneBase), endAddress);
#      endif

		}
	}
}


/*	Unlink all sends in cog methods. Free all Closed PICs with the selector,
	or with an MNU case if isMNUSelector. First check if any method actually
	has the selector; if not there can't be any linked send to it. This
	routine (including descendents) is performance critical. It contributes
	perhaps 30% of entire execution time in Compiler recompileAll. */

	/* Cogit>>#unlinkSendsOf:isMNUSelector: */
void
unlinkSendsOfisMNUSelector(sqInt selector, sqInt isMNUSelector)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt mustScanAndUnlink;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	cogMethod = ((CogMethod *) methodZoneBase);
	mustScanAndUnlink = 0;
	if (isMNUSelector) {
		while (cogMethod < (limitZony())) {
			if (!(((cogMethod->cmType)) == CMFree)) {
				if (/* cpicHasMNUCase */
					((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
				 && (((cogMethod->cmType)) == CMClosedPIC)) {
					assert(isCMClosedPIC(((CogBlockMethod *) cogMethod)));
					freeMethod(cogMethod);
					mustScanAndUnlink = 1;
				}
				else {
					if (((cogMethod->selector)) == selector) {
						mustScanAndUnlink = 1;
						if (((cogMethod->cmType)) == CMClosedPIC) {
							freeMethod(cogMethod);
						}
					}
				}
			}
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	}
	else {
		while (cogMethod < (limitZony())) {
			if ((!(((cogMethod->cmType)) == CMFree))
			 && (((cogMethod->selector)) == selector)) {
				mustScanAndUnlink = 1;
				if (((cogMethod->cmType)) == CMClosedPIC) {
					freeMethod(cogMethod);
				}
			}
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	}
	if (!mustScanAndUnlink) {
		return;
	}
	codeModified = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mapByte = 0;
			mcpc = /* firstMappedPCFor: */
					((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
						? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
						: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfFreeOrLinkedSendpcof(annotation, ((char *) mcpc), ((CogMethod *) selector));
					if (result) {
						goto l1;
					}
				}
				else {
					if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
					}
				}
				map -= 1;
			}
l1:	/* end mapFor:performUntil:arg: */;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (codeModified) {

		/* After possibly updating inline caches we need to flush the icache. */
		endAddress = freeStart();

		/* begin flushICacheFrom:to: */
		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneExecutable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(1);
		PJWPNSet = __LINE__;
		PJWPNChange = __LINE__;
		PJWPNState = 1;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
		sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#    else // __APPLE__ && __MACH__
		ceFlushICache(((usqInt)methodZoneBase), endAddress);
#    endif

	}

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}


/*	Unlink all sends in cog methods to free methods and/or pics. */

	/* Cogit>>#unlinkSendsToFree */
static void
unlinkSendsToFree(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	codeModified = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mapByte = 0;
			mcpc = /* firstMappedPCFor: */
					((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
						? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
						: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendToFreepcignored(annotation, ((char *) mcpc), 0);
					if (result) {
						goto l1;
					}
				}
				else {
					if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
					}
				}
				map -= 1;
			}
l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				assert(noTargetsFreeInClosedPIC(cogMethod));
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (codeModified) {

		/* After possibly updating inline caches we need to flush the icache. */
		endAddress = freeStart();

		/* begin flushICacheFrom:to: */
		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneExecutable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(1);
		PJWPNSet = __LINE__;
		PJWPNChange = __LINE__;
		PJWPNState = 1;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

#    if __APPLE__ && __MACH__
		sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
		sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#    else // __APPLE__ && __MACH__
		ceFlushICache(((usqInt)methodZoneBase), endAddress);
#    endif

	}
}


/*	Unlink all sends in cog methods to methods with a machine code
	primitive, and free machine code primitive methods if freeIfTrue.
	To avoid having to scan PICs, free any and all PICs */

	/* Cogit>>#unlinkSendsToMethodsSuchThat:AndFreeIf: */
void
unlinkSendsToMethodsSuchThatAndFreeIf(sqInt (*criterion)(CogMethod *), sqInt freeIfTrue)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt freedSomething;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	codeModified = (freedSomething = 0);
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			if (freeIfTrue
			 && (criterion(cogMethod))) {
				freeMethod(cogMethod);
				freedSomething = 1;
			}
			else {
				/* begin mapFor:performUntil:arg: */
				mapByte = 0;
				mcpc = /* firstMappedPCFor: */
						((((cogMethod->cmType)) >= CMMethod)
					 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
							? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
							: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = unlinkIfLinkedSendpcif(annotation, ((char *) mcpc), ((void *)criterion));
						if (result) {
							goto l1;
						}
					}
					else {
						if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
						}
					}
					map -= 1;
				}
l1:	/* end mapFor:performUntil:arg: */;
			}
		}
		else {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				freeMethod(cogMethod);
				freedSomething = 1;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedSomething) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {

			/* After possibly updating inline caches we need to flush the icache. */
			endAddress = freeStart();

			/* begin flushICacheFrom:to: */
			/* begin ensureExecutableCodeZone */
#      if !DUAL_MAPPED_CODE_ZONE
			/* begin makeCodeZoneExecutable */
#      if __APPLE__ && __MACH__
			pthread_jit_write_protect_np(1);
			PJWPNSet = __LINE__;
			PJWPNChange = __LINE__;
			PJWPNState = 1;
#      endif

#      endif // !DUAL_MAPPED_CODE_ZONE

#      if __APPLE__ && __MACH__
			sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
			sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#      else // __APPLE__ && __MACH__
			ceFlushICache(((usqInt)methodZoneBase), endAddress);
#      endif

		}
	}

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}


/*	Unlink all sends in cog methods to a particular target method.
	If targetMethodObject isn't actually a method (perhaps being
	used via invokeAsMethod) then there's nothing to do. */

	/* Cogit>>#unlinkSendsTo:andFreeIf: */
void
unlinkSendsToandFreeIf(sqInt targetMethodObject, sqInt freeIfTrue)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt endAddress;
    sqInt freedPIC;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *targetMethod;

	if (!((isOopCompiledMethod(targetMethodObject))
		 && (methodHasCogMethod(targetMethodObject)))) {
		return;
	}
	targetMethod = cogMethodOf(targetMethodObject);
	if (!methodZoneBase) {
		return;
	}

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	codeModified = (freedPIC = 0);
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mapByte = 0;
			mcpc = /* firstMappedPCFor: */
					((((cogMethod->cmType)) >= CMMethod)
				 && ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock))
						? (((usqInt)cogMethod)) + cbNoSwitchEntryOffset
						: (((usqInt)cogMethod)) + cmNoCheckEntryOffset);
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendpcto(annotation, ((char *) mcpc), targetMethod);
					if (result) {
						goto l1;
					}
				}
				else {
					if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
					}
				}
				map -= 1;
			}
l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if ((((cogMethod->cmType)) == CMClosedPIC)
			 && (cPICHasTarget(cogMethod, targetMethod))) {
				freeMethod(cogMethod);
				freedPIC = 1;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freeIfTrue) {
		freeMethod(targetMethod);
	}
	if (freedPIC) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {

			/* After possibly updating inline caches we need to flush the icache. */
			endAddress = freeStart();

			/* begin flushICacheFrom:to: */
			/* begin ensureExecutableCodeZone */
#      if !DUAL_MAPPED_CODE_ZONE
			/* begin makeCodeZoneExecutable */
#      if __APPLE__ && __MACH__
			pthread_jit_write_protect_np(1);
			PJWPNSet = __LINE__;
			PJWPNChange = __LINE__;
			PJWPNState = 1;
#      endif

#      endif // !DUAL_MAPPED_CODE_ZONE

#      if __APPLE__ && __MACH__
			sys_dcache_flush(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
			sys_icache_invalidate(((void *) (((usqInt)methodZoneBase))), endAddress - (((usqInt)methodZoneBase)));
#      else // __APPLE__ && __MACH__
			ceFlushICache(((usqInt)methodZoneBase), endAddress);
#      endif

		}
	}

	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}

	/* Cogit>>#voidCogCompiledCode */
void
voidCogCompiledCode(void)
{
    CogMethod *cogMethod;
    usqInt theLimitAddress;
    usqInt theStartAddress;

	/* begin clearCogCompiledCode */
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) >= CMMethod) {
			freeMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	theStartAddress = baseAddress;
	theLimitAddress = limitAddress;

	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress = theStartAddress);
	youngReferrers = (limitAddress = theLimitAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;

	/* begin computeAllocationThreshold */
	allocationThreshold = ((((((usqInt)((limitAddress - baseAddress) * thresholdRatio))) + ((zoneAlignment()) - 1)) & ~7)) + baseAddress;
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneExecutable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(1);
	PJWPNSet = __LINE__;
	PJWPNChange = __LINE__;
	PJWPNState = 1;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE
}


/*	Access for the object representations when they need to prepend code to
	trampolines. 
 */
/*	Eliminate stale dependent info. */

	/* Cogit>>#zeroOpcodeIndex */
static void
zeroOpcodeIndex(void)
{
    sqInt i;

	for (i = 0; i < opcodeIndex; i += 1) {
		((abstractOpcodes[i]).dependent = null);
	}

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
}

	/* CogMethodZone>>#addToOpenPICList: */
static NoDbgRegParms void
addToOpenPICList(CogMethod *anOpenPIC)
{
	assert(isCMOpenPIC(((CogBlockMethod *) anOpenPIC)));
	assert((openPICList == null)
	 || (isCMOpenPIC(((CogBlockMethod *) openPICList))));
	assertValidDualZoneWriteAddress(anOpenPIC);
	(anOpenPIC->nextOpenPIC = ((usqInt)openPICList));
	openPICList = ((CogMethod *) ((((usqInt)anOpenPIC)) - (getCodeToDataDelta())));
}

	/* CogMethodZone>>#addToYoungReferrers: */
static NoDbgRegParms void
addToYoungReferrers(CogMethod *writableCogMethod)
{
	assertValidDualZoneWriteAddress(writableCogMethod);
	assert((occurrencesInYoungReferrers(writableCogMethod)) == 0);
	assert((writableCogMethod->cmRefersToYoung));
	assert((youngReferrers <= limitAddress)
	 && (youngReferrers >= (limitAddress - (methodCount * BytesPerWord))));
	if (!(asserta((limitAddress - (methodCount * BytesPerWord)) >= mzFreeStart))) {
		error("no room on youngReferrers list");
	}
	youngReferrers -= BytesPerWord;
	codeLongAtput(youngReferrers, (((usqInt)writableCogMethod)) - (getCodeToDataDelta()));
}

	/* CogMethodZone>>#allocate: */
static NoDbgRegParms usqInt
allocate(sqInt numBytes)
{
    usqInt allocation;
    sqInt roundedBytes;

	roundedBytes = (numBytes + 7) & -8;
	if ((mzFreeStart + roundedBytes) >= ((((limitAddress - (methodCount * BytesPerWord)) < allocationThreshold) ? (limitAddress - (methodCount * BytesPerWord)) : allocationThreshold))) {
		return 0;
	}
	allocation = mzFreeStart;
	mzFreeStart += roundedBytes;
	methodCount += 1;
	return allocation;
}


/*	Answer the method containing mcpc for the purposes of code zone
	compaction, where mcpc is actually the value of instructionPointer at the
	time of a compaction. */

	/* CogMethodZone>>#cogMethodContaining: */
CogMethod *
cogMethodContaining(usqInt mcpc)
{
    CogMethod *cogMethod;
    CogMethod *prevMethod;

	if (mcpc > limitAddress) {
		return null;
	}
	if (mcpc < baseAddress) {
		/* assertMcpcIsPrimReturn: */
		assert((mcpc == cePrimReturnEnterCogCode)
		 || (mcpc == cePrimReturnEnterCogCodeProfiling));
		return null;
	}
	assert(mcpc < (freeStart()));
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mcpc) {
		prevMethod = cogMethod;
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	assert((prevMethod)
	 && ((mcpc == ((((usqInt)prevMethod)) + ((prevMethod->stackCheckOffset))))
	 || ((mcpcisAtStackCheckOfBlockMethodIn(mcpc, prevMethod))
	 || (((primitiveIndexOfMethodheader((prevMethod->methodObject), (prevMethod->methodHeader))) > 0)
	 || ((isCallPrecedingReturnPC(backEnd, mcpc))
	 && ((callTargetFromReturnAddress(backEnd, mcpc)) == (ceCheckForInterruptTrampoline)))))));
	return prevMethod;
}

	/* CogMethodZone>>#compactCompiledCode */
static void
compactCompiledCode(void)
{
    unsigned short bytes;
    CogMethod *dest;
    sqLong objectHeaderValue;
    CogMethod *source;
    CogMethod *writableVersion;

	compactionInProgress = 1;
	methodCount = 0;
	objectHeaderValue = nullHeaderForMachineCodeMethod();
	source = ((CogMethod *) baseAddress);
	voidOpenPICList();
	while ((source < (limitZony()))
	 && (!(((source->cmType)) == CMFree))) {
		assert((cogMethodDoesntLookKosher(source)) == 0);
		writableVersion = ((CogMethod *) ((((usqInt)source)) + codeToDataDelta));
		(writableVersion->objectHeader = objectHeaderValue);
		if (((source->cmUsageCount)) > 0) {
			(writableVersion->cmUsageCount = ((source->cmUsageCount)) / 2);
		}

		/* begin maybeLinkOnUnpairedMethodList: */
		if (((writableVersion->cmType)) == CMClosedPIC) {
			(writableVersion->blockEntryOffset = 0);
		}
		if (((source->cmType)) == CMOpenPIC) {
			addToOpenPICList(writableVersion);
		}
		methodCount += 1;
		source = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)source)) + ((source->blockSize)))));
	}
	if (source >= (limitZony())) {
		haltmsg("no free methods; cannot compact.");
		return;
	}
	dest = source;
	while (source < (limitZony())) {
		assert((maybeFreeCogMethodDoesntLookKosher(source)) == 0);
		bytes = (source->blockSize);
		if (!(((source->cmType)) == CMFree)) {
			methodCount += 1;
			codeMemmove(dest, source, bytes);

			/* begin maybeFlushWritableZoneFrom:to: */
#      if DUAL_MAPPED_CODE_ZONE
			if (codeToDataDelta > 0) {
				flushDCacheFromto(backEnd, ((usqInt)dest), (((usqInt)dest)) + bytes);
			}
#      endif

			((writableVersion = ((CogMethod *) ((((usqInt)dest)) + codeToDataDelta)))->objectHeader = objectHeaderValue);
			if (((dest->cmType)) >= CMMethod) {

				/* For non-Newspeak there should be a one-to-one mapping between bytecoded and
				   cog methods.  For Newspeak not necessarily, but only for anonymous accessors. */
				/* Only update the original method's header if it is referring to this CogMethod. */
				if ((((sqInt)(rawHeaderOf((dest->methodObject))))) == (((sqInt)source))) {
					rawHeaderOfput((dest->methodObject), ((sqInt)dest));
				}
				else {
					assert((noAssertMethodClassAssociationOf((dest->methodObject))) == (nilObject()));

					/* begin linkOnUnpairedMethodList: */
				}
			}
			else {
				/* begin clearSavedPICUsageCount: */
				if (((writableVersion->cmType)) == CMClosedPIC) {
					(writableVersion->blockEntryOffset = 0);
				}
				if (((dest->cmType)) == CMOpenPIC) {
					addToOpenPICList(writableVersion);
				}
			}
			if (((dest->cmUsageCount)) > 0) {
				(writableVersion->cmUsageCount = ((dest->cmUsageCount)) / 2);
			}

			/* begin maybeFlushWritableZoneFrom:to: */
#      if DUAL_MAPPED_CODE_ZONE
			if (codeToDataDelta > 0) {
				flushDCacheFromto(backEnd, ((usqInt)dest), ((usqInt)(dest + 1)));
			}
#      endif

			dest = ((CogMethod *) ((((usqInt)dest)) + bytes));
		}
		source = ((CogMethod *) ((((usqInt)source)) + bytes));
	}
	mzFreeStart = ((usqInt)dest);
	methodBytesFreedSinceLastCompaction = 0;
	compactionInProgress = 0;
}

	/* CogMethodZone>>#ensureInYoungReferrers: */
static NoDbgRegParms void
ensureInYoungReferrers(CogMethod *cogMethod)
{
    CogMethod *writableMethod;

	assertValidDualZoneReadAddress(cogMethod);
	if (!((cogMethod->cmRefersToYoung))) {
		assert((occurrencesInYoungReferrers(cogMethod)) == 0);

		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
		/* begin makeCodeZoneWritable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(0);
		PJWPNClear = __LINE__;
#    endif

#    endif // !DUAL_MAPPED_CODE_ZONE

		((writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmRefersToYoung = 1);
		addToYoungReferrers(writableMethod);
	}
}

	/* CogMethodZone>>#followForwardedLiteralsInOpenPICList */
static void
followForwardedLiteralsInOpenPICList(void)
{
    CogMethod *openPIC;

	openPIC = openPICList;
	while (openPIC) {
		followForwardedLiteralsImplementationIn(openPIC);
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	}
	pruneYoungReferrers();
}

	/* CogMethodZone>>#freeMethod: */
static NoDbgRegParms void
freeMethod(CogMethod *cogMethod)
{
    CogMethod *writableMethod;

	assert(!((isCMFree(((CogBlockMethod *) cogMethod)))));
	assert((cogMethodDoesntLookKosher(cogMethod)) == 0);

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
	/* begin makeCodeZoneWritable */
#  if __APPLE__ && __MACH__
	pthread_jit_write_protect_np(0);
	PJWPNClear = __LINE__;
#  endif

#  endif // !DUAL_MAPPED_CODE_ZONE

	if (((cogMethod->cmType)) >= CMMethod) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
		}
		else {

			/* For non-Newspeak there should be a one-to-one mapping between bytecoded and
			   cog methods.  For Newspeak not necessarily, but only for anonymous accessors. */
			/* Only reset the original method's header if it is referring to this CogMethod. */
			if ((((sqInt)(rawHeaderOf((cogMethod->methodObject))))) == (((sqInt)cogMethod))) {
				rawHeaderOfput((cogMethod->methodObject), (cogMethod->methodHeader));
			}
			else {
				assert((noAssertMethodClassAssociationOf((cogMethod->methodObject))) == (nilObject()));
			}
		}
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		removeFromOpenPICList(cogMethod);
	}
	writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
	(writableMethod->cmRefersToYoung = 0);
	(writableMethod->cmType = CMFree);
	methodBytesFreedSinceLastCompaction += (cogMethod->blockSize);
}


/*	Free methods, preferring older methods for compaction, up to some
	fraction, currently a quarter.
 */

	/* CogMethodZone>>#freeOlderMethodsForCompaction */
static void
freeOlderMethodsForCompaction(void)
{
    sqInt amountToFree;
    CogMethod *cogMethod;
    sqInt freeableUsage;
    sqInt freedSoFar;
    sqInt initialFreeSpace;
    sqInt zoneSize;

	zoneSize = ((((limitAddress) < allocationThreshold) ? (limitAddress) : allocationThreshold)) - baseAddress;
	initialFreeSpace = (((((limitAddress) < allocationThreshold) ? (limitAddress) : allocationThreshold)) - mzFreeStart) + methodBytesFreedSinceLastCompaction;
	freedSoFar = initialFreeSpace;

	/* 4 needs to be e.g. a start-up parameter */
	amountToFree = zoneSize / 4;
	freeableUsage = 0;
	do {
		cogMethod = ((CogMethod *) baseAddress);
		while (((((usqInt)cogMethod)) < mzFreeStart)
		 && (freedSoFar < amountToFree)) {
			if (/* shouldFreeMethod:given: */
				(((cogMethod->cmType)) >= CMMethod
					? ((cogMethod->cmUsageCount)) <= freeableUsage
					: (!(((cogMethod->cmType)) == CMFree))
					 && (((cogMethod->cmUsageCount)) == 0))) {
				freeMethod(cogMethod);
				freedSoFar += (cogMethod->blockSize);
			}
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	} while((freedSoFar < amountToFree)
		 && (((freeableUsage += 1)) < CMMaxUsageCount));
}


/*	Answer that all entries in youngReferrers are in-use and have the
	cmRefersToYoung flag set.
	Used to check that the youngreferrers pruning routines work correctly. */

	/* CogMethodZone>>#kosherYoungReferrers */
sqInt
kosherYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt pointer;
    CogMethod *prevMethod;

	if ((youngReferrers > limitAddress)
	 || (youngReferrers < mzFreeStart)) {
		return 0;
	}
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (!((cogMethod->cmRefersToYoung))) {
				return 0;
			}
			if ((occurrencesInYoungReferrers(cogMethod)) != 1) {
				return 0;
			}
		}
		pointer += BytesPerWord;
	}
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		prevMethod = cogMethod;
		if (!(((cogMethod->cmType)) == CMFree)) {
			if ((occurrencesInYoungReferrers(cogMethod)) != (((cogMethod->cmRefersToYoung)
					? 1
					: 0))) {
				return 0;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		if (cogMethod == prevMethod) {
			return 0;
		}
	}
	return 1;
}


/*	For assert checking... */

	/* CogMethodZone>>#mcpc:isAtStackCheckOfBlockMethodIn: */
static NoDbgRegParms sqInt
mcpcisAtStackCheckOfBlockMethodIn(sqInt mcpc, CogMethod *cogMethod)
{
	if (!((cogMethod->blockEntryOffset))) {
		return 0;
	}
	return (blockDispatchTargetsForperformarg(cogMethod, stackCheckOffsetOfBlockAtisMcpc, mcpc)) != 0;
}

	/* CogMethodZone>>#methodFor: */
CogMethod *
methodFor(void *address)
{
    CogMethod *cogMethod;
    CogMethod *nextMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((cogMethod < (limitZony()))
	 && ((((usqInt)cogMethod)) <= (((usqInt)address)))) {
		nextMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		if (nextMethod == cogMethod) {
			return null;
		}
		if (((((usqInt)address)) >= (((usqInt)cogMethod)))
		 && ((((usqInt)address)) < (((usqInt)nextMethod)))) {
			return cogMethod;
		}
		cogMethod = nextMethod;
	}
	return null;
}

	/* CogMethodZone>>#methodsCompiledToMachineCodeInto: */
sqInt
methodsCompiledToMachineCodeInto(sqInt arrayObj)
{
    CogMethod *cogMethod;
    sqInt methodIndex;

	methodIndex = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			storePointerUncheckedofObjectwithValue(methodIndex, arrayObj, (cogMethod->methodObject));
			methodIndex += 1;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return methodIndex;
}

	/* CogMethodZone>>#numMethods */
sqInt
numMethods(void)
{
	return methodCount;
}

	/* CogMethodZone>>#numMethodsOfType: */
sqInt
numMethodsOfType(sqInt cogMethodType)
{
    CogMethod *cogMethod;
    sqInt n;

	n = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == cogMethodType) {
			n += 1;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return n;
}

	/* CogMethodZone>>#occurrencesInYoungReferrers: */
static NoDbgRegParms sqInt
occurrencesInYoungReferrers(CogMethod *cogMethod)
{
    sqInt count;
    usqInt pointer;

	assert(youngReferrers <= limitAddress);
	count = 0;
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		if ((((sqInt)cogMethod)) == (longAt(pointer))) {
			count += 1;
		}
		pointer += BytesPerWord;
	}
	return count;
}

	/* CogMethodZone>>#openPICWithSelector: */
static NoDbgRegParms CogMethod *
openPICWithSelector(sqInt aSelector)
{
    CogMethod *openPIC;

	openPIC = openPICList;
	do {
		if ((openPIC == null)
		 || (((openPIC->selector)) == aSelector)) {
			return openPIC;
		}
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	} while(1);
	return 0;
}


/*	Some methods have been freed. Compute how much each survivor needs to
	move during the ensuing compaction and record it in the objectHeader
	field. 
	For Sista, where we want PICs to last so they can be observed, we need to
	keep PICs unless
	they are definitely unused. So we need to identify unused PICs. So in
	planCompact, zero the
	usage counts of all PICs, saving the actual usage count in
	blockEntryOffset. Then in
	relocateMethodsPreCompaction (actually in
	relocateIfCallOrMethodReference:mcpc:delta:) restore the usage counts of
	used PICs. Finally in compactCompiledCode, clear the blockEntryOffset
	of the unused PICs; they will then have a zero count and be reclaimed in
	the next code compaction. */

	/* CogMethodZone>>#planCompaction */
static void
planCompaction(void)
{
    CogMethod *cogMethod;
    sqInt delta;

	delta = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) == CMFree) {
			delta -= (cogMethod->blockSize);
		}
		else {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->objectHeader = delta);
			savePICUsageCount(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethods */
void
printCogMethods(void)
{
    CogMethod *cogMethod;
    sqInt nb;
    sqInt nc;
    sqInt nf;
    sqInt nm;
    sqInt no;
    sqInt nu;

	/* begin printCogMethodsSummarizing: */
	nm = (nb = (nc = (no = (nf = (nu = 0)))));
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		printCogMethod(cogMethod);
		switch ((cogMethod->cmType)) {
		case CMFree:
			nf += 1;
			break;
		case CMMethod:
			nm += 1;
			break;
		case CMMethodFlaggedForBecome:
			nb += 1;
			break;
		case CMClosedPIC:
			nc += 1;
			break;
		case CMOpenPIC:
			no += 1;
			break;
		default:
			nu += 1;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	print("CMMethod ");
	printNum(nm);
	if (nb > 0) {
		print(" (flagged for become: ");
		printNum(nb);
		print(")");
	}
	print(" CMClosedPIC ");
	printNum(nc);
	print(" CMOpenPIC ");
	printNum(no);
	print(" CMFree ");
	printNum(nf);
	if (nu > 0) {
		print(" UNKNOWN ");
		printNum(nu);
	}
	print(" total ");
	printNum(((((nm + nc) + no) + nf) + nu) + nb);
	cr();
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsOfType: */
void
printCogMethodsOfType(sqInt cmType)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == cmType) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithMethod: */
void
printCogMethodsWithMethod(sqInt methodOop)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->methodObject)) == methodOop)) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithPrimitive: */
void
printCogMethodsWithPrimitive(sqInt primIdx)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) >= CMMethod)
		 && (primIdx == (primitiveIndexOfMethodheader((cogMethod->methodObject), (cogMethod->methodHeader))))) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithSelector: */
void
printCogMethodsWithSelector(sqInt selectorOop)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->selector)) == selectorOop)) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogYoungReferrers */
void
printCogYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt pointer;

	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!((cogMethod->cmRefersToYoung))) {
			print("*");
		}
		if (((cogMethod->cmType)) == CMFree) {
			print("!");
		}
		if (!(((cogMethod->cmRefersToYoung))
			 && (!(((cogMethod->cmType)) == CMFree)))) {
			print(" ");
		}
		printCogMethod(cogMethod);
		pointer += BytesPerWord;
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printOpenPICList */
sqInt
printOpenPICList(void)
{
    sqInt n;
    CogMethod *openPIC;

	/* begin printOpenPICListSummarizing: */
	n = 0;
	openPIC = openPICList;
	while (!(openPIC == null)) {
		n += 1;
		printCogMethod(openPIC);
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	}
	return n;
}

	/* CogMethodZone>>#pruneYoungReferrers */
static sqInt
pruneYoungReferrers(void)
{
    usqInt dest;
    usqInt next;
    usqInt source;

	next = 0;
	assert(youngReferrers <= limitAddress);
	if (youngReferrers == limitAddress) {
		return null;
	}
	dest = limitAddress;
	while (1) {
		next = dest - BytesPerWord;
		if (!((next >= youngReferrers)
		 && (((((CogMethod *) (longAt(next))))->cmRefersToYoung)))) break;
		dest = next;
	}
	assert(dest >= youngReferrers);
	source = dest - BytesPerWord;
	while (source >= youngReferrers) {
		if (((((CogMethod *) (longAt(source))))->cmRefersToYoung)) {
			assert(source < (dest - BytesPerWord));
			if (next) {

				/* convenient first-time flag */
				next = null;

				/* begin ensureWritableCodeZone */
#        if !DUAL_MAPPED_CODE_ZONE
				/* begin makeCodeZoneWritable */
#        if __APPLE__ && __MACH__
				pthread_jit_write_protect_np(0);
				PJWPNClear = __LINE__;
#        endif

#        endif // !DUAL_MAPPED_CODE_ZONE

			}
			codeLongAtput((dest -= BytesPerWord), longAt(source));
		}
		source -= BytesPerWord;
	}
	youngReferrers = dest;
	assert(kosherYoungReferrers());
	return 0;
}

	/* CogMethodZone>>#relocateAndPruneYoungReferrers */
static sqInt
relocateAndPruneYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt dest;
    usqInt next;
    usqInt source;

	cogMethod = ((CogMethod *) 0);
	next = 0;
	assert(youngReferrers <= limitAddress);
	if (youngReferrers == limitAddress) {
		return null;
	}
	dest = limitAddress;
	while (1) {
		next = dest - BytesPerWord;
		if (!((next >= youngReferrers)
		 && ((!(isCMFree(((CogBlockMethod *) ((cogMethod = ((CogMethod *) (longAt(next)))))))))
		 && ((cogMethod->cmRefersToYoung))))) break;
		if ((cogMethod->objectHeader)) {
			codeLongAtput(next, (((sqInt)cogMethod)) + ((cogMethod->objectHeader)));
		}
		dest = next;
	}
	assert(dest >= youngReferrers);
	source = dest - BytesPerWord;
	while (source >= youngReferrers) {
		cogMethod = ((CogMethod *) (longAt(source)));
		if ((!(((cogMethod->cmType)) == CMFree))
		 && ((cogMethod->cmRefersToYoung))) {
			assert(source < (dest - BytesPerWord));
			if ((cogMethod->objectHeader)) {
				cogMethod = ((CogMethod *) ((((sqInt)cogMethod)) + (((sqInt)((cogMethod->objectHeader))))));
			}
			codeLongAtput((dest -= BytesPerWord), ((sqInt)cogMethod));
		}
		source -= BytesPerWord;
	}

	/* this assert must be deferred until after compaction.  See the end of compactCogCompiledCode */
	/* self assert: self kosherYoungReferrers */
	youngReferrers = dest;
	return 0;
}


/*	All surviving methods have had the amount they are going to relocate by
	stored in their objectHeader fields. Relocate all relative calls so that
	after the compaction of both the method containing each call and the call
	target the calls invoke the same target. */

	/* CogMethodZone>>#relocateMethodsPreCompaction */
static sqInt
relocateMethodsPreCompaction(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				relocateCallsInClosedPIC(cogMethod);
			}
			else {
				relocateCallsAndSelfReferencesInMethod(cogMethod);
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd, (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	relocateAndPruneYoungReferrers();
	return 1;
}

	/* CogMethodZone>>#removeFromOpenPICList: */
static NoDbgRegParms sqInt
removeFromOpenPICList(CogMethod *anOpenPIC)
{
    CogMethod *prevPIC;

	assert(isCMOpenPIC(((CogBlockMethod *) anOpenPIC)));
	if (!openPICList) {
		return null;
	}
	assert((isCMOpenPIC(((CogBlockMethod *) openPICList)))
	 && ((!((openPICList->nextOpenPIC)))
	 || (isCMOpenPIC(((CogBlockMethod *) (((CogMethod *) ((openPICList->nextOpenPIC)))))))));
	if (anOpenPIC == openPICList) {

		/* N.B. Use self rather than coInterpreter to avoid attempting to cast nil.
		   Conversion to CogMethod done in the nextOpenPIC accessor. */
		openPICList = ((CogMethod *) ((anOpenPIC->nextOpenPIC)));
		return null;
	}
	prevPIC = openPICList;
	do {
		assert((prevPIC != null)
		 && (isCMOpenPIC(((CogBlockMethod *) prevPIC))));
		if (((prevPIC->nextOpenPIC)) == (((usqInt)anOpenPIC))) {
			((((CogMethod *) ((((usqInt)prevPIC)) + codeToDataDelta)))->nextOpenPIC = (anOpenPIC->nextOpenPIC));
			return null;
		}
		prevPIC = ((CogMethod *) ((prevPIC->nextOpenPIC)));
	} while(1);
	return 0;
}


/*	For Sista, where we want PICs to last so they can be observed, we need to
	keep PICs unless
	they are definitely unused. So we need to identify unused PICs. So in
	planCompact, zero the
	usage counts of all PICs, saving the actual usage count in
	blockEntryOffset. Then in
	relocateMethodsPreCompaction (actually in
	relocateIfCallOrMethodReference:mcpc:delta:) restore the usage counts of
	used PICs. Finally in compactCompiledCode, clear the blockEntryOffset
	of the unused PICs; they will then have a zero count and be reclaimed in
	the next code compaction. */

	/* CogMethodZone>>#restorePICUsageCount: */
static NoDbgRegParms void
restorePICUsageCount(CogMethod *cogMethod)
{
	if ((((cogMethod->cmType)) == CMClosedPIC)
	 && (((cogMethod->blockEntryOffset)) != 0)) {
		(cogMethod->cmUsageCount = (cogMethod->blockEntryOffset));
		(cogMethod->blockEntryOffset = 0);
	}
}


/*	Determine the default alignment for the start of a CogMethod, which in
	turn determines the size of the mask used to distinguish the checked and
	unchecked entry-points, used to distinguish normal and super sends on
	method unlinking.
	This is passed onto the backEnd to allow processors with coarse
	instructions (ARM) to increase the alignment if required. */

	/* CogMethodZone>>#roundUpLength: */
static NoDbgRegParms sqInt
roundUpLength(sqInt numBytes)
{
	return roundUpToMethodAlignment(backEnd, numBytes);
}


/*	For Sista, where we want PICs to last so they can be observed, we need to
	keep PICs unless
	they are definitely unused. So we need to identify unused PICs. So in
	planCompact, zero the
	usage counts of all PICs, saving the actual usage count in
	blockEntryOffset. Then in
	relocateMethodsPreCompaction (actually in
	relocateIfCallOrMethodReference:mcpc:delta:) restore the usage counts of
	used PICs. Finally in compactCompiledCode, clear the blockEntryOffset
	of the unused PICs; they will then have a zero count and be reclaimed in
	the next code compaction. */

	/* CogMethodZone>>#savePICUsageCount: */
static NoDbgRegParms void
savePICUsageCount(CogMethod *cogMethod)
{
	if (((cogMethod->cmType)) == CMClosedPIC) {
		(cogMethod->blockEntryOffset = (cogMethod->cmUsageCount));
		(cogMethod->cmUsageCount = 0);
	}
}

	/* CogMethodZone>>#voidOpenPICList */
static void
voidOpenPICList(void)
{
	openPICList = null;
}

	/* CogMethodZone>>#voidUnpairedMethodList */
static void
voidUnpairedMethodList(void)
{
}

	/* CogMethodZone>>#whereIsMaybeCodeThing: */
char *
whereIsMaybeCodeThing(sqInt anOop)
{
	if (oopisGreaterThanOrEqualToandLessThan(anOop, codeBase, limitAddress)) {
		if (oopisLessThan(anOop, minCogMethodAddress())) {
			return " is in generated runtime";
		}
		if (oopisLessThan(anOop, mzFreeStart)) {
			return " is in generated methods";
		}
		if (oopisLessThan(anOop, youngReferrers)) {
			return " is in code zone";
		}
		return " is in young referrers";
	}
	return null;
}

	/* CogMethodZone>>#zoneAlignment */
static sqInt
zoneAlignment(void)
{
	return 8;
}

	/* CogObjectRepresentation>>#checkValidObjectReference: */
static NoDbgRegParms sqInt
checkValidObjectReference(sqInt anOop)
{
	return (!(isImmediate(anOop)))
	 && ((heapMapAtWord(pointerForOop(anOop))) != 0);
}

	/* CogObjectRepresentation>>#genCmpClassFloatCompactIndexR: */
static NoDbgRegParms AbstractInstruction *
genCmpClassFloatCompactIndexR(sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassFloatCompactIndex, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassFloatCompactIndex, BytesPerOop));
	}
	return anInstruction;
}

	/* CogObjectRepresentation>>#genCmpClassMethodContextCompactIndexR: */
static NoDbgRegParms AbstractInstruction *
genCmpClassMethodContextCompactIndexR(sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassMethodContextCompactIndex, BytesPerOop));
	}
	return anInstruction;
}

	/* CogObjectRepresentation>>#generateLowcodeObjectTrampolines */
static void
generateLowcodeObjectTrampolines(void)
{
	ceFloatObjectOfTrampoline = genTrampolineForcalledfloatArgresult(floatObjectOf, "ceFloatObjectOfTrampoline", DPFPReg0, TempReg);
	ceFloatValueOfTrampoline = genTrampolineForcalledargfloatResult(floatValueOf, "ceFloatValueOfTrampoline", ReceiverResultReg, DPFPReg0);
	ceInstantiateClassIndexableSizeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(instantiateClassindexableSize, "ceInstantiateClassIndexableSizeTrampoline", 2, Arg0Reg, Arg1Reg, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	ceInstantiateClassTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(instantiateClassindexableSize, "ceInstantiateClassTrampoline", 2, ReceiverResultReg, 0, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	ceByteSizeOfTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(byteSizeOf, "ceByteSizeOfTrampoline", 1, Arg0Reg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	cePositive64BitIntegerTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(positive64BitIntegerFor, "cePositive64BitIntegerTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	cePositive64BitValueOfTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(positive64BitValueOf, "cePositive64BitValueOfTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	ceSigned64BitIntegerTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(signed64BitIntegerFor, "ceSigned64BitIntegerTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
	ceSigned64BitValueOfTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(signed64BitValueOf, "ceSigned64BitValueOfTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, TempReg, 0);
}


/*	Get the method header (first word) of a CompiledMethod into headerReg.
	Deal with the method possibly being cogged. */

	/* CogObjectRepresentation>>#genGetMethodHeaderOf:into:scratch: */
static NoDbgRegParms sqInt
genGetMethodHeaderOfintoscratch(sqInt methodReg, sqInt headerReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpNotCogged;
    sqInt offset;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, methodReg, headerReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	jumpNotCogged = genJumpSmallInteger(headerReg);
	offset = offsetof(CogMethod, methodHeader);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, headerReg, headerReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	jmpTarget(jumpNotCogged, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	Generate a compare and branch to test if aRegister and bRegister contains
	other than SmallIntegers,
	i.e. don't branch if both aRegister and bRegister contain SmallIntegers.
	Answer the jump. Destroy scratchRegister if required. */

	/* CogObjectRepresentation>>#genJumpNotSmallIntegersIn:and:scratch: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallIntegersInandscratch(sqInt aRegister, sqInt bRegister, sqInt scratchRegister)
{
	/* MoveR:R: */
	genoperandoperand(MoveRR, aRegister, scratchRegister);

	/* AndR:R: */
	genoperandoperand(AndRR, bRegister, scratchRegister);
	return genJumpNotSmallInteger(scratchRegister);
}


/*	TODO: Optimize this one avoiding the trampoline */

	/* CogObjectRepresentation>>#genLcByteSizeOf:to: */
static NoDbgRegParms void
genLcByteSizeOfto(sqInt oop, sqInt resultRegister)
{
    AbstractInstruction *abstractInstruction;

	if (oop != Arg0Reg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, oop, Arg0Reg);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceByteSizeOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, resultRegister);
	ssPushNativeRegister(resultRegister);
}

	/* CogObjectRepresentation>>#genLcFloat32:toOop: */
static NoDbgRegParms void
genLcFloat32toOop(sqInt value, sqInt object)
{
    AbstractInstruction *abstractInstruction;

	/* ConvertRs:Rd: */
	genoperandoperand(ConvertRsRd, value, DPFPReg0);

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceFloatObjectOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, object);
	ssPushRegister(object);
}

	/* CogObjectRepresentation>>#genLcFloat64:toOop: */
static NoDbgRegParms void
genLcFloat64toOop(sqInt value, sqInt object)
{
    AbstractInstruction *abstractInstruction;

	if (value) {
		/* MoveRd:Rd: */
		genoperandoperand(MoveRdRd, value, DPFPReg0);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceFloatObjectOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, object);
	ssPushRegister(object);
}

	/* CogObjectRepresentation>>#genLcInstantiateOop: */
static NoDbgRegParms void
genLcInstantiateOop(sqInt classOop)
{
    AbstractInstruction *abstractInstruction;

	if (classOop != ReceiverResultReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, classOop, ReceiverResultReg);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceInstantiateClassTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, classOop);
	ssPushRegister(classOop);
}

	/* CogObjectRepresentation>>#genLcInstantiateOop:constantIndexableSize: */
static NoDbgRegParms void
genLcInstantiateOopconstantIndexableSize(sqInt classOop, sqInt indexableSize)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;

	if (classOop != Arg0Reg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, classOop, Arg0Reg);
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, indexableSize, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(indexableSize, BytesPerOop));
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceInstantiateClassIndexableSizeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, classOop);
	ssPushRegister(classOop);
}

	/* CogObjectRepresentation>>#genLcInstantiateOop:indexableSize: */
static NoDbgRegParms void
genLcInstantiateOopindexableSize(sqInt classOop, sqInt indexableSize)
{
    AbstractInstruction *abstractInstruction;

	if (classOop != Arg0Reg) {
		if (indexableSize == Arg0Reg) {
			/* MoveR:R: */
			genoperandoperand(MoveRR, indexableSize, TempReg);
		}

		/* MoveR:R: */
		genoperandoperand(MoveRR, classOop, Arg0Reg);
	}
	if (indexableSize != Arg1Reg) {
		if (indexableSize == Arg0Reg) {
			/* MoveR:R: */
			genoperandoperand(MoveRR, TempReg, Arg1Reg);
		}
		else {
			/* MoveR:R: */
			genoperandoperand(MoveRR, indexableSize, Arg1Reg);
		}
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceInstantiateClassIndexableSizeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, classOop);
	ssPushRegister(classOop);
}

	/* CogObjectRepresentation>>#genLcInt64ToOop: */
static NoDbgRegParms void
genLcInt64ToOop(sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (value != ReceiverResultReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, value, ReceiverResultReg);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceSigned64BitIntegerTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
}

	/* CogObjectRepresentation>>#genLcOopToInt64: */
static NoDbgRegParms void
genLcOopToInt64(sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (value != ReceiverResultReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, value, ReceiverResultReg);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceSigned64BitValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushNativeRegister(ReceiverResultReg);
}


/*	Assume this is always correct */

	/* CogObjectRepresentation>>#genLcOopToPointer: */
static NoDbgRegParms void
genLcOopToPointer(sqInt object)
{
    AbstractInstruction *anInstruction;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, object, object);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	ssPushNativeRegister(object);
}

	/* CogObjectRepresentation>>#genLcOopToUInt64: */
static NoDbgRegParms void
genLcOopToUInt64(sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (value != ReceiverResultReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, value, ReceiverResultReg);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, cePositive64BitValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushNativeRegister(ReceiverResultReg);
}

	/* CogObjectRepresentation>>#genLcOop:toFloat32: */
static NoDbgRegParms void
genLcOoptoFloat32(sqInt object, sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (object != ReceiverResultReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, object, ReceiverResultReg);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceFloatValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* ConvertRd:Rs: */
	genoperandoperand(ConvertRdRs, DPFPReg0, value);
	ssPushNativeRegisterSingleFloat(value);
}

	/* CogObjectRepresentation>>#genLcOop:toFloat64: */
static NoDbgRegParms void
genLcOoptoFloat64(sqInt object, sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (object != ReceiverResultReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, object, ReceiverResultReg);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceFloatValueOfTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	if (DPFPReg0 != value) {
		/* MoveRd:Rd: */
		genoperandoperand(MoveRdRd, DPFPReg0, value);
	}
	ssPushNativeRegisterDoubleFloat(value);
}

	/* CogObjectRepresentation>>#genLcPointerToOop:class: */
static NoDbgRegParms void
genLcPointerToOopclass(sqInt pointer, sqInt pointerClass)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;

	/* PushR: */
	genoperand(PushR, pointer);
	annotateobjRef(checkLiteralforInstruction(pointerClass, genoperandoperand(MoveCwR, pointerClass, Arg0Reg)), pointerClass);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BytesPerOop, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerOop, BytesPerOop));
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceInstantiateClassIndexableSizeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* PopR: */
	genoperand(PopR, pointer);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, pointer, BaseHeaderSize, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, pointer);
	ssPushRegister(pointer);
}

	/* CogObjectRepresentation>>#genLcUInt64ToOop: */
static NoDbgRegParms void
genLcUInt64ToOop(sqInt value)
{
    AbstractInstruction *abstractInstruction;

	if (value != ReceiverResultReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, value, ReceiverResultReg);
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, cePositive64BitIntegerTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
}

	/* CogObjectRepresentation>>#genLoadSlot:sourceReg:destReg: */
static NoDbgRegParms sqInt
genLoadSlotsourceRegdestReg(sqInt index, sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	offset = (index * BytesPerWord) + BaseHeaderSize;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, sourceReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveAdd */
static sqInt
genPrimitiveAdd(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(ClassReg);

	/* AddR:R: */
	genoperandoperand(AddRR, ReceiverResultReg, ClassReg);
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveAsFloat */
static sqInt
genPrimitiveAsFloat(void)
{
    AbstractInstruction *jumpFailAlloc;


	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);

	/* ConvertR:Rd: */
	genoperandoperand(ConvertRRd, TempReg, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveBitAnd */
static sqInt
genPrimitiveBitAnd(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* Whether the SmallInteger tags are zero or non-zero, anding them together will preserve them. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);

	/* AndR:R: */
	genoperandoperand(AndRR, Arg0Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitOr */
static sqInt
genPrimitiveBitOr(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* Whether the SmallInteger tags are zero or non-zero, oring them together will preserve them. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);

	/* OrR:R: */
	genoperandoperand(OrRR, Arg0Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	rTemp := rArg0
	rClass := tTemp
	rTemp := rTemp & 1
	jz nonInt
	rClass >>= 1
	cmp 0,rClass
	jge neg
	cmp 31,rClass // numSmallIntegerBits, jge for sign
	jge tooBig
	rTemp := rReceiver
	rTemp <<= rClass
	rTemp >>= rClass (arithmetic)
	cmp rTemp,rReceiver
	jnz ovfl
	rReceiver := rReceiver - 1
	rReceiver := rReceiver <<= rClass
	rReceiver := rReceiver + 1
	ret
	neg:
	rClass := 0 - rClass
	cmp 31,rClass // numSmallIntegerBits
	jge inRange
	rClass := 31
	inRange
	rReceiver := rReceiver >>= rClass.
	rReceiver := rReceiver | smallIntegerTags.
	ret
	ovfl
	tooBig
	nonInt:
	fail
 */

	/* CogObjectRepresentation>>#genPrimitiveBitShift */
static sqInt
genPrimitiveBitShift(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpInRange;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;
    AbstractInstruction *jumpTooBig;
    sqInt quickConstant;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpNegative = genConditionalBranchoperand(JumpNegative, ((sqInt)0));
	quickConstant = numSmallIntegerBits();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpTooBig = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);

	/* LogicalShiftLeftR:R: */
	genoperandoperand(LogicalShiftLeftRR, ClassReg, TempReg);

	/* ArithmeticShiftRightR:R: */
	genoperandoperand(ArithmeticShiftRightRR, ClassReg, TempReg);

	/* begin CmpR:R: */
	assert(!(0 /* (TempReg = SPReg) */));
	genoperandoperand(CmpRR, TempReg, ReceiverResultReg);
	jumpOvfl = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genRemoveSmallIntegerTagsInScratchReg(ReceiverResultReg);

	/* LogicalShiftLeftR:R: */
	genoperandoperand(LogicalShiftLeftRR, ClassReg, ReceiverResultReg);
	genAddSmallIntegerTagsTo(ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNegative, genoperand(NegateR, ClassReg));
	quickConstant = numSmallIntegerBits();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpInRange = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	quickConstant = numSmallIntegerBits();

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jmpTarget(jumpInRange, genoperandoperand(ArithmeticShiftRightRR, ClassReg, ReceiverResultReg));
	genClearAndSetSmallIntegerTagsIn(ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, jmpTarget(jumpTooBig, jmpTarget(jumpOvfl, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitXor */
static sqInt
genPrimitiveBitXor(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* Clear one or the other tag so that xoring will preserve them. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(Arg0Reg);

	/* XorR:R: */
	genoperandoperand(XorRR, Arg0Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveClass */
static sqInt
genPrimitiveClass(void)
{
    sqInt reg;

	reg = ReceiverResultReg;
	if (methodOrBlockNumArgs > 0) {
		if (methodOrBlockNumArgs > 1) {
			return UnimplementedPrimitive;
		}
		reg = Arg0Reg;
		/* empty genLoadArgAtDepth:into: */;
	}
	if ((genGetClassObjectOfintoscratchRegmayBeAForwarder(reg, ReceiverResultReg, TempReg, reg != ReceiverResultReg)) == BadRegisterSet) {
		genGetClassObjectOfintoscratchRegmayBeAForwarder(reg, ClassReg, TempReg, reg != ReceiverResultReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveDiv */
static sqInt
genPrimitiveDiv(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *convert;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpIsSI;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpSameSign;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);

	/* We must shift away the tags, not just subtract them, so that the
	   overflow case doesn't actually overflow the machine instruction. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* If arg and remainder signs are different we must round down. */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpSameSign = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	jmpTarget(jumpSameSign, (convert = genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpIsSI = genJumpIsSmallIntegerValuescratch(TempReg, Arg1Reg);
	jmpTarget(jumpIsSI, convert);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveDivide */
static sqInt
genPrimitiveDivide(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpInexact;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOverflow;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);

	/* We must shift away the tags, not just subtract them, so that the
	   overflow case doesn't actually overflow the machine instruction. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* test for overflow; the only case is SmallInteger minVal / -1 */
	jumpInexact = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	jumpOverflow = genJumpNotSmallIntegerValuescratch(TempReg, Arg1Reg);
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOverflow, jmpTarget(jumpInexact, jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveEqual */
static sqInt
genPrimitiveEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genSmallIntegerComparisonorDoubleComparisoninvert(JumpZero, gJumpFPEqual, 0)
			: genSmallIntegerComparison(JumpZero));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatAdd */
static sqInt
genPrimitiveFloatAdd(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatArithmeticpreOpCheckboxed(AddRdRd, null, 1)
			: genPureFloatArithmeticpreOpCheckboxed(AddRdRd, null, 1));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatDivide */
static sqInt
genPrimitiveFloatDivide(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 1)
			: genPureFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 1));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatMultiply */
static sqInt
genPrimitiveFloatMultiply(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatArithmeticpreOpCheckboxed(MulRdRd, null, 1)
			: genPureFloatArithmeticpreOpCheckboxed(MulRdRd, null, 1));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatSquareRoot */
static sqInt
genPrimitiveFloatSquareRoot(void)
{
    AbstractInstruction *jumpFailAlloc;

	genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);

	/* SqrtRd: */
	genoperand(SqrtRd, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveFloatSubtract */
static sqInt
genPrimitiveFloatSubtract(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatArithmeticpreOpCheckboxed(SubRdRd, null, 1)
			: genPureFloatArithmeticpreOpCheckboxed(SubRdRd, null, 1));
}

	/* CogObjectRepresentation>>#genPrimitiveGreaterOrEqual */
static sqInt
genPrimitiveGreaterOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genSmallIntegerComparisonorDoubleComparisoninvert(JumpGreaterOrEqual, gJumpFPGreaterOrEqual, 0)
			: genSmallIntegerComparison(JumpGreaterOrEqual));
}

	/* CogObjectRepresentation>>#genPrimitiveGreaterThan */
static sqInt
genPrimitiveGreaterThan(void)
{
	return (primitiveDoMixedArithmetic()
			? genSmallIntegerComparisonorDoubleComparisoninvert(JumpGreater, gJumpFPGreater, 0)
			: genSmallIntegerComparison(JumpGreater));
}


/*	Implementation notes: there are two reasons to use TempReg
	-1) if primitive fails, ReceiverResultReg must remain unchanged (we
	CompletePrimitive) -2) CLZ/BSR only work on 64bits for registers R0-R7 on
	Intel X64. But Win64 uses R9
	Normally, this should be backEnd dependent, but for now we have a single
	64bits target...
 */

	/* CogObjectRepresentation>>#genPrimitiveHighBit */
static sqInt
genPrimitiveHighBit(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpNegativeReceiver;
    sqInt quickConstant;


	/* remove excess tag bits from the receiver oop */
	gOrCqRR((1U << (numSmallIntegerTagBits())) - 1, ReceiverResultReg, TempReg);
	quickConstant = (numSmallIntegerTagBits()) - 1;

	/* begin ArithmeticShiftRightCq:R: */
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, TempReg);
	backEnd;

	/* begin genHighBitIn:ofSmallIntegerOopWithSingleTagBit: */
	/* begin genHighBitClzIn:ofSmallIntegerOopWithSingleTagBit: */
	/* ClzR:R: */
	genoperandoperand(ClzRR, TempReg, TempReg);
	anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* Note the nice bit trick below:
	   highBit_1based_of_small_int_value = (BytesPerWord * 8) - leadingZeroCout_of_oop - 1 toAccountForTagBit.
	   This is like 2 complements (- reg - 1) on (BytesPerWord * 8) log2 bits, or exactly a bit invert operation... */
	jumpNegativeReceiver = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* #XorCw:R: #gen:literal:operand: */
	checkLiteralforInstruction((BytesPerWord * 8) - 1, genoperandoperand(XorCwR, (BytesPerWord * 8) - 1, TempReg));
	if (!jumpNegativeReceiver) {
		return UnimplementedPrimitive;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNegativeReceiver, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveIdentical */
static sqInt
genPrimitiveIdentical(void)
{
	return genPrimitiveIdenticalOrNotIf(0);
}

	/* CogObjectRepresentation>>#genPrimitiveLessOrEqual */
static sqInt
genPrimitiveLessOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genSmallIntegerComparisonorDoubleComparisoninvert(JumpLessOrEqual, gJumpFPGreaterOrEqual, 1)
			: genSmallIntegerComparison(JumpLessOrEqual));
}

	/* CogObjectRepresentation>>#genPrimitiveLessThan */
static sqInt
genPrimitiveLessThan(void)
{
	return (primitiveDoMixedArithmetic()
			? genSmallIntegerComparisonorDoubleComparisoninvert(JumpLess, gJumpFPGreater, 1)
			: genSmallIntegerComparison(JumpLess));
}

	/* CogObjectRepresentation>>#genPrimitiveMod */
static sqInt
genPrimitiveMod(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpSameSign;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(ClassReg);
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, Arg1Reg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genRemoveSmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* If arg and remainder signs are different we must reflect around zero. */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpSameSign = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));

	/* XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ClassReg);
	jmpTarget(jumpSameSign, jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genSetSmallIntegerTagsIn(ClassReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveMultiply */
static sqInt
genPrimitiveMultiply(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(processorHasMultiplyAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, Arg1Reg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	genRemoveSmallIntegerTagsInScratchReg(Arg1Reg);

	/* MulOverflowR:R: */
	genMulOverflowRR(backEnd, Arg1Reg, ClassReg);
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	genSetSmallIntegerTagsIn(ClassReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveNewMethod */
static sqInt
genPrimitiveNewMethod(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveNotEqual */
static sqInt
genPrimitiveNotEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genSmallIntegerComparisonorDoubleComparisoninvert(JumpNonZero, gJumpFPNotEqual, 0)
			: genSmallIntegerComparison(JumpNonZero));
}

	/* CogObjectRepresentation>>#genPrimitiveNotIdentical */
static sqInt
genPrimitiveNotIdentical(void)
{
	return genPrimitiveIdenticalOrNotIf(1);
}

	/* CogObjectRepresentation>>#genPrimitiveQuo */
static sqInt
genPrimitiveQuo(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *convert;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpIsSI;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);

	/* We must shift away the tags, not just subtract them, so that the
	   overflow case doesn't actually overflow the machine instruction. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	convert = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpIsSI = genJumpIsSmallIntegerValuescratch(TempReg, Arg1Reg);
	jmpTarget(jumpIsSI, convert);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatAdd */
static sqInt
genPrimitiveSmallFloatAdd(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatArithmeticpreOpCheckboxed(AddRdRd, null, 0)
			: genPureFloatArithmeticpreOpCheckboxed(AddRdRd, null, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatDivide */
static sqInt
genPrimitiveSmallFloatDivide(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 0)
			: genPureFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatEqual */
static sqInt
genPrimitiveSmallFloatEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPEqual, JumpZero, 0, 0)
			: genPureFloatComparisoninvertboxed(gJumpFPEqual, 0, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatGreaterOrEqual */
static sqInt
genPrimitiveSmallFloatGreaterOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreaterOrEqual, JumpGreaterOrEqual, 0, 0)
			: genPureFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 0, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatGreaterThan */
static sqInt
genPrimitiveSmallFloatGreaterThan(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreater, JumpGreater, 0, 0)
			: genPureFloatComparisoninvertboxed(gJumpFPGreater, 0, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatLessOrEqual */
static sqInt
genPrimitiveSmallFloatLessOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreaterOrEqual, JumpLessOrEqual, 1, 0)
			: genPureFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 1, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatLessThan */
static sqInt
genPrimitiveSmallFloatLessThan(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreater, JumpLess, 1, 0)
			: genPureFloatComparisoninvertboxed(gJumpFPGreater, 1, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatMultiply */
static sqInt
genPrimitiveSmallFloatMultiply(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatArithmeticpreOpCheckboxed(MulRdRd, null, 0)
			: genPureFloatArithmeticpreOpCheckboxed(MulRdRd, null, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatNotEqual */
static sqInt
genPrimitiveSmallFloatNotEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPNotEqual, JumpNonZero, 0, 0)
			: genPureFloatComparisoninvertboxed(gJumpFPNotEqual, 0, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatSquareRoot */
static sqInt
genPrimitiveSmallFloatSquareRoot(void)
{
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpNegative;

	genGetSmallFloatValueOfscratchinto(ReceiverResultReg, SendNumArgsReg, DPFPReg0);

	/* XorRd:Rd: */
	genoperandoperand(XorRdRd, DPFPReg1, DPFPReg1);

	/* CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	jumpNegative = gJumpFPGreater(0);

	/* SqrtRd: */
	genoperand(SqrtRd, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNegative, jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatSubtract */
static sqInt
genPrimitiveSmallFloatSubtract(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatArithmeticpreOpCheckboxed(SubRdRd, null, 0)
			: genPureFloatArithmeticpreOpCheckboxed(SubRdRd, null, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveSubtract */
static sqInt
genPrimitiveSubtract(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, Arg0Reg, TempReg);
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	genAddSmallIntegerTagsTo(TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genSmallIntegerComparison: */
static NoDbgRegParms sqInt
genSmallIntegerComparison(sqInt jumpOpcode)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpTrue;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	jumpFail = genJumpNotSmallInteger(Arg0Reg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpTrue = genConditionalBranchoperand(jumpOpcode, 0);

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpTrue, genMoveConstantR(trueObject(), ReceiverResultReg));

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#isUnannotatableConstant: */
static NoDbgRegParms sqInt
isUnannotatableConstant(CogSimStackEntry *simStackEntry)
{
	return (((simStackEntry->type)) == SSConstant)
	 && ((isImmediate((simStackEntry->constant)))
	 || (!(/* shouldAnnotateObjectReference: */
		(isNonImmediate((simStackEntry->constant)))
	 && ((oopisGreaterThan((simStackEntry->constant), classTableRootObj()))
	 || (oopisLessThan((simStackEntry->constant), nilObject()))))));
}

	/* CogObjectRepresentationFor64BitSpur>>#classForInlineCacheTag: */
static NoDbgRegParms sqInt
classForInlineCacheTag(sqInt classIndex)
{
	return classOrNilAtIndex(classIndex);
}

	/* CogObjectRepresentationFor64BitSpur>>#genAddSmallIntegerTagsTo: */
static NoDbgRegParms sqInt
genAddSmallIntegerTagsTo(sqInt aRegister)
{
    AbstractInstruction *anInstruction;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, aRegister);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genAlloc64BitPositiveIntegerValue:into:scratchReg:scratchReg: */
static NoDbgRegParms AbstractInstruction *
genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(sqInt valueReg, sqInt resultReg, sqInt scratch1, sqInt scratch2)
{
    sqInt allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    usqLong newLPIHeader;
    sqInt quickConstant;

	allocSize = BaseHeaderSize + BytesPerWord;
	newLPIHeader = headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargePositiveIntegerCompactIndex);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), resultReg));

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(allocSize, BytesPerOop));
	}
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpFail = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, scratch1, freeStartAddress()));

	/* begin genStoreHeader:intoNewInstance:using: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, newLPIHeader, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(newLPIHeader, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, scratch1, 0, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, valueReg, BaseHeaderSize, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	return jumpFail;
}

	/* CogObjectRepresentationFor64BitSpur>>#genAlloc64BitSignedIntegerValue:into:scratchReg:scratchReg: */
static NoDbgRegParms AbstractInstruction *
genAlloc64BitSignedIntegerValueintoscratchRegscratchReg(sqInt valueReg, sqInt resultReg, sqInt scratch1, sqInt scratch2)
{
    sqInt allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpNeg;
    usqLong newLNIHeader;
    sqInt quickConstant;

	allocSize = BaseHeaderSize + BytesPerWord;
	newLNIHeader = headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargeNegativeIntegerCompactIndex);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), resultReg));

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(allocSize, BytesPerOop));
	}
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpFail = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, scratch1, freeStartAddress()));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, newLNIHeader, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(newLNIHeader, BytesPerOop));
	}

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* We can avoid duplicating the large constant and a jump choosing between
	   the alternatives by incrementing the single constant if positive.  The assert
	   checks that the hack works. Compact code is to be preferred because it is
	   an uncommon case; usually the value will fit in a SmallInteger. */
	jumpNeg = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	assert((headerForSlotsformatclassIndex(0, 0, 1)) == 1);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, ClassLargePositiveIntegerCompactIndex - ClassLargeNegativeIntegerCompactIndex, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassLargePositiveIntegerCompactIndex - ClassLargeNegativeIntegerCompactIndex, BytesPerOop));
	}
	jmpTarget(jumpNeg, gMoveRMwr(scratch1, 0, resultReg));

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, valueReg, BaseHeaderSize, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	return jumpFail;
}


/*	Override to answer a SmallFloat64 if possible. */

	/* CogObjectRepresentationFor64BitSpur>>#genAllocFloatValue:into:scratchReg:scratchReg: */
static NoDbgRegParms AbstractInstruction *
genAllocFloatValueintoscratchRegscratchReg(sqInt dpreg, sqInt resultReg, sqInt scratch1, sqInt scratch2)
{
    usqIntptr_t allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpFail1;
    AbstractInstruction *jumpMerge;
    AbstractInstruction *jumpNotSF;
    usqLong newFloatHeader;
    sqInt quickConstant;

	/* begin MoveRd:R: */
	assert(BytesPerWord == 8);
	genoperandoperand(MoveRdR, dpreg, resultReg);
	jumpNotSF = genJumpNotSmallFloatValueBitsscratch(resultReg, scratch1);
	genConvertBitsToSmallFloatInscratch(resultReg, scratch1);
	jumpMerge = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpNotSF, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	allocSize = BaseHeaderSize + (sizeof(double));
	newFloatHeader = headerForSlotsformatclassIndex((sizeof(double)) / BytesPerWord, firstLongFormat(), ClassFloatCompactIndex);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), resultReg));

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(allocSize, BytesPerOop));
	}
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpFail1 = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, scratch1, freeStartAddress()));

	/* begin genStoreHeader:intoNewInstance:using: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, newFloatHeader, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(newFloatHeader, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, scratch1, 0, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin MoveRd:M64:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRdM64r, dpreg, BaseHeaderSize, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	jumpFail = jumpFail1;
	jmpTarget(jumpMerge, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return jumpFail;
}


/*	Set the SmallInteger tag bits when the tag bits may be filled with
	garbage. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genClearAndSetSmallIntegerTagsIn: */
static NoDbgRegParms sqInt
genClearAndSetSmallIntegerTagsIn(sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = -1 - (tagMask());

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin OrCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(OrCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	return 0;
}


/*	Convert the in-SmallFloat64-range floating point value in integer register
	into a tagged SmallFloat64 oop.
	c.f. Spur64BitMemoryManager>>smallFloatObjectOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertBitsToSmallFloatIn:scratch: */
static NoDbgRegParms sqInt
genConvertBitsToSmallFloatInscratch(sqInt reg, sqInt scratch)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpZero;
    sqInt quickConstant;

	/* RotateLeftCq:R: */
	genoperandoperand(RotateLeftCqR, 1, reg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 1, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	jumpZero = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jmpTarget(jumpZero, genoperandoperand(LogicalShiftLeftCqR, numTagBits(), reg));
	quickConstant = smallFloatTag();

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return 0;
}


/*	Convert the Character in reg to a SmallInteger, assuming
	the Character's value is a valid character. */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertCharacterToSmallIntegerInReg: */
static NoDbgRegParms void
genConvertCharacterToSmallIntegerInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = (characterTag()) - (smallIntegerTag());

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
}

	/* CogObjectRepresentationFor64BitSpur>>#genConvertIntegerInReg:toSmallIntegerInReg: */
static NoDbgRegParms sqInt
genConvertIntegerInRegtoSmallIntegerInReg(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	gLogicalShiftLeftCqRR(numTagBits(), srcReg, destReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genConvertIntegerToSmallIntegerInReg: */
static NoDbgRegParms sqInt
genConvertIntegerToSmallIntegerInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, numTagBits(), reg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	return 0;
}


/*	Convert the SmallFloat in reg to its identityHash as a SmallInteger.
	Rotate the sign bit from bit 3 (zero-relative) to the sign bit. 
	c.f. Spur64BitMemoryManager>>rotatedFloatBitsOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallFloatToSmallFloatHashAsIntegerInReg:scratch: */
static NoDbgRegParms sqInt
genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(sqInt reg, sqInt scratch)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	assert(((((usqInt)((smallFloatTag()))) >> 1) - (smallIntegerTag())) == (smallIntegerTag()));

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 1, reg);
	gAndCqRR(1U << ((numTagBits()) - 1), reg, scratch);

	/* SubR:R: */
	genoperandoperand(SubRR, scratch, reg);
	quickConstant = (((usqInt)((smallFloatTag()))) >> 1) - (smallIntegerTag());

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	quickConstant = 0x3F - ((numTagBits()) - 1);

	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, scratch);

	/* OrR:R: */
	genoperandoperand(OrRR, scratch, reg);
	return 0;
}


/*	Convert the SmallInteger in reg to a Character, assuming
	the SmallInteger's value is a valid character. */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallIntegerToCharacterInReg: */
static NoDbgRegParms void
genConvertSmallIntegerToCharacterInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = (characterTag()) - (smallIntegerTag());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
}

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallIntegerToIntegerInReg: */
static NoDbgRegParms sqInt
genConvertSmallIntegerToIntegerInReg(sqInt reg)
{
	/* ArithmeticShiftRightCq:R: */
	genoperandoperand(ArithmeticShiftRightCqR, numTagBits(), reg);
	return 0;
}


/*	The arguments are in an array in Arg1Reg. Its size is in sizeReg.
	Load Arg0Reg and Arg1Reg with the first two slots, as appropriate.
	Since objects always have at least one slot it is safe to load arg0
	without checking.
	But the array could be at the end of memory so we must check that it has
	two slots before it is safe to access the second slot. */

	/* CogObjectRepresentationFor64BitSpur>>#genFetchRegArgsForPerformWithArguments: */
static NoDbgRegParms sqInt
genFetchRegArgsForPerformWithArguments(sqInt sizeReg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    AbstractInstruction *skip;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 2, sizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(2, BytesPerOop));
	}
	skip = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	offset = BaseHeaderSize + BytesPerWord;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, Arg1Reg, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genFloatArithmetic:preOpCheck:boxed: */
static NoDbgRegParms sqInt
genFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed)
{
    AbstractInstruction *doOp;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFailCheck;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;
    AbstractInstruction *jumpNotSmallInteger;

	jumpFailCheck = ((AbstractInstruction *) 0);
	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	doOp = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (preOpCheckOrNil) {
		jumpFailCheck = preOpCheckOrNil(DPFPReg0, DPFPReg1);
	}
	genoperandoperand(arithmeticOperator, DPFPReg1, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpNotSmallInteger = genJumpNotSmallInteger(Arg0Reg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);

	/* ConvertR:Rd: */
	genoperandoperand(ConvertRRd, Arg1Reg, DPFPReg1);

	/* Jump: */
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);

	/* Jump: */
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, jmpTarget(jumpNotSmallInteger, jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	if (preOpCheckOrNil) {
		jmpTarget(jumpFailCheck, ((AbstractInstruction *) (((jumpFailAlloc->operands))[0])));
	}
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genFloatComparison:orIntegerComparison:invert:boxed: */
static NoDbgRegParms sqInt
genFloatComparisonorIntegerComparisoninvertboxed(AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt jumpOpcode, sqInt invertComparison, sqInt rcvrBoxed)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *compareFloat;
    AbstractInstruction *jumpAmbiguous;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;
    AbstractInstruction *jumpNotSmallInteger;
    AbstractInstruction *jumpTrue;
    AbstractInstruction *returnTrue;

	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	compareFloat = (invertComparison
				? genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1)
				: genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0));

	/* FP jumps are a little weird */
	jumpCond = jumpFPOpcodeGenerator(0);

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, (returnTrue = genMoveConstantR(trueObject(), ReceiverResultReg)));

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* Test for ambiguity, that is when floatRcvr == (double) intArg */
	jumpNotSmallInteger = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);

	/* ConvertR:Rd: */
	genoperandoperand(ConvertRRd, Arg0Reg, DPFPReg1);

	/* CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);

	/* Case of non ambiguity, use compareFloat(floatRcvr,(double) intArg) */
	jumpAmbiguous = gJumpFPEqual(0);

	/* Jump: */
	genoperand(Jump, ((sqInt)compareFloat));
	jmpTarget(jumpAmbiguous, genoperandoperand(ConvertRdR, DPFPReg0, ReceiverResultReg));

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpTrue = genConditionalBranchoperand(jumpOpcode, 0);

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpTrue, returnTrue);
	jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);

	/* Jump: */
	genoperand(Jump, ((sqInt)compareFloat));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	Fetch the instance's identity hash into destReg, encoded as a
	SmallInteger. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genGetHashFieldNonImmOf:asSmallIntegerInto: */
static NoDbgRegParms sqInt
genGetHashFieldNonImmOfasSmallIntegerInto(sqInt instReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = (identityHashFullWordShift()) - (numTagBits());

	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, quickConstant, destReg);
	quickConstant = ((sqInt)((usqInt)((identityHashHalfWordMask())) << (numTagBits())));

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	quickConstant = smallIntegerTag();

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return 0;
}


/*	Fetch the instance's identity hash into destReg, unencoded. */

	/* CogObjectRepresentationFor64BitSpur>>#genGetHashFieldNonImmOf:into: */
static NoDbgRegParms sqInt
genGetHashFieldNonImmOfinto(sqInt instReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 32, destReg);
	quickConstant = identityHashHalfWordMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return 0;
}


/*	Extract the inline cache tag for the object in sourceReg into destReg. The
	inline cache tag for a given object is the value loaded in inline caches
	to distinguish
	objects of different classes. In Spur this is either the tags for
	immediates, or
	the receiver's classIndex. Answer the label for the start of the sequence. */

	/* CogObjectRepresentationFor64BitSpur>>#genGetInlineCacheClassTagFrom:into:forEntry: */
static NoDbgRegParms AbstractInstruction *
genGetInlineCacheClassTagFromintoforEntry(sqInt sourceReg, sqInt destReg, sqInt forEntry)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *entryLabel;
    AbstractInstruction *jumpImm;
    sqInt quickConstant;

	if (forEntry) {
		/* AlignmentNops: */
		genoperand(AlignmentNops, BytesPerWord);
	}
	entryLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	gAndCqRR(tagMask(), sourceReg, destReg);

	/* Get least significant half of header word in destReg */
	jumpImm = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	flag("endianness");

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, sourceReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = classIndexMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jmpTarget(jumpImm, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return entryLabel;
}


/*	Get the size in byte-sized slots of the object in srcReg into destReg.
	srcReg may equal destReg.
	destReg <- numSlots << self shiftForWord - (fmt bitAnd: 7).
	Assumes the object in srcReg has a byte format, i.e. 16 to 23 or 24 to 31 */

	/* CogObjectRepresentationFor64BitSpur>>#genGetNumBytesOf:into: */
static NoDbgRegParms sqInt
genGetNumBytesOfinto(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmp;
    sqInt quickConstant;

	genGetRawSlotSizeOfNonImminto(srcReg, destReg);
	quickConstant = numSlotsMask();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jmp = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genGetOverflowSlotsOfinto(srcReg, destReg);
	jmpTarget(jmp, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), destReg));
	genGetBitsofFormatByteOfinto(7, srcReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, TempReg, destReg);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genGetOverflowSlotsOf:into: */
static NoDbgRegParms sqInt
genGetOverflowSlotsOfinto(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, -BaseHeaderSize, srcReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(-BaseHeaderSize, BytesPerOop));
	}

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 8, destReg);

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 8, destReg);
	return 0;
}


/*	Convert the SmallFloat oop in ooppReg into the corresponding float value
	in dpReg.
	c.f. Spur64BitMemoryManager>>smallFloatBitsOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genGetSmallFloatValueOf:scratch:into: */
static NoDbgRegParms sqInt
genGetSmallFloatValueOfscratchinto(sqInt oopReg, sqInt scratch, sqInt dpReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSFZero;
    sqInt quickConstant;

	/* MoveR:R: */
	genoperandoperand(MoveRR, oopReg, scratch);

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, numTagBits(), scratch);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 1, scratch);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	jumpSFZero = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	quickConstant = ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, scratch);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jmpTarget(jumpSFZero, genoperandoperand(RotateRightCqR, 1, scratch));

	/* begin MoveR:Rd: */
	assert(BytesPerWord == 8);
	genoperandoperand(MoveRRd, scratch, dpReg);
	return 0;
}


/*	Generate a test for aRegister containing an integer value in the
	SmallInteger range, and a jump if so, answering the jump.
	c.f. Spur64BitMemoryManager>>isIntegerValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpIsSmallIntegerValue:scratch: */
static NoDbgRegParms AbstractInstruction *
genJumpIsSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	gArithmeticShiftRightCqRR(0x3F - (numTagBits()), aRegister, scratchReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	quickConstant = (1U << ((numTagBits()) + 1)) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
}


/*	Generate a compare and branch to test if aRegister contains other than a
	Character. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotCharacter: */
static NoDbgRegParms AbstractInstruction *
genJumpNotCharacter(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = characterTag();

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpZero, ((sqInt)0));
}


/*	Generate a test to check that the integer register contains a floating
	point value within the SmallFloat64 range,
	and answer the jump. c.f. Spur64BitMemoryManager>>isSmallFloatValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallFloatValueBits:scratch: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallFloatValueBitsscratch(sqInt reg, sqInt exponent)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpMaxExponent;
    AbstractInstruction *jumpMinExponent;
    AbstractInstruction *jumpTest;
    AbstractInstruction *jumpZeroMantissa;
    sqInt quickConstant;

	flag("if we combine the exponent range test with the conversion to tagged representation we test for a zero exponent only once. further, if we extract tags once into a scratch on the input side we test for immediates, SmallInteger and SmallFloat using the same intermediate result.  so to do is to move fp arithmetic into the object representations");
	gLogicalShiftLeftCqRR(1, reg, exponent);
	quickConstant = (smallFloatMantissaBits()) + 1;

	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, quickConstant, exponent);
	quickConstant = smallFloatExponentOffset();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, exponent);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpMinExponent = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	quickConstant = 0xFF + (smallFloatExponentOffset());

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, exponent);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpMaxExponent = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	jumpFail = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpMinExponent, gTstCqR((1ULL << (smallFloatMantissaBits())) - 1, reg));
	jumpZeroMantissa = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	quickConstant = smallFloatExponentOffset();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, exponent);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpTest = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpZeroMantissa, gCmpCqR(0, exponent));
	jmpTarget(jumpTest, genConditionalBranchoperand(JumpNonZero, ((sqInt)jumpFail)));
	jmpTarget(jumpMaxExponent, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return jumpFail;
}


/*	Generate a compare and branch to test if aRegister contains other than a
	SmallFloat. Answer the jump. */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallFloat: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallFloat(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = smallFloatTag();

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpZero, ((sqInt)0));
}


/*	Generate a test for aRegister containing an integer value outside the
	SmallInteger range, and a jump if so, answering the jump.
	c.f. Spur64BitMemoryManager>>isIntegerValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallIntegerValue:scratch: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	gArithmeticShiftRightCqRR(0x3F - (numTagBits()), aRegister, scratchReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	quickConstant = (1U << ((numTagBits()) + 1)) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpGreater, ((sqInt)0));
}


/*	Generate a compare and branch to test if aRegister contains other than a
	SmallInteger. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallInteger: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallInteger(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = smallIntegerTag();

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpZero, ((sqInt)0));
}


/*	Generate a compare and branch to test if aRegister contains a
	SmallInteger. Answer the jump, or UnimplementedOperation if this cannot be
	done with
	a single register. */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpSmallInteger: */
static NoDbgRegParms AbstractInstruction *
genJumpSmallInteger(sqInt aRegister)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = smallIntegerTag();

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, aRegister);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}

	/* CogObjectRepresentationFor64BitSpur>>#genLcInt32ToOop: */
static NoDbgRegParms sqInt
genLcInt32ToOop(sqInt value)
{
	/* SignExtend32R:R: */
	genoperandoperand(SignExtend32RR, value, value);
	genConvertIntegerToSmallIntegerInReg(value);
	ssPushRegister(value);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genLcOopToInt32: */
static NoDbgRegParms sqInt
genLcOopToInt32(sqInt value)
{
	genConvertSmallIntegerToIntegerInReg(value);
	ssPushNativeRegister(value);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genLcOopToUInt32: */
static NoDbgRegParms sqInt
genLcOopToUInt32(sqInt value)
{
	genConvertSmallIntegerToIntegerInReg(value);
	ssPushNativeRegister(value);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genLcUInt32ToOop: */
static NoDbgRegParms sqInt
genLcUInt32ToOop(sqInt value)
{
	/* begin ZeroExtend32R:R: */
	genoperandoperand(ZeroExtend32RR, value, value);
	genConvertIntegerToSmallIntegerInReg(value);
	ssPushRegister(value);
	return 0;
}


/*	Generate the code for primitives 61 & 165, at:put:/basicAt:put: &
	integerAt:put:. If signedVersion is true
	then generate signed accesses to the bits classes (a la 164 & 165). If
	signedVersion is false,
	generate unsigned accesses (a la 60, 61, 63 & 64). */
/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveAtPutSigned: */
static NoDbgRegParms sqInt
genPrimitiveAtPutSigned(sqInt signedVersion)
{
    AbstractInstruction *anInstruction;
    sqInt formatReg;
    AbstractInstruction *jump64BitArgIsImmediate;
    AbstractInstruction *jump64BitsOutOfBounds;
    AbstractInstruction *jumpArrayOutOfBounds;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpBytesOutOfRange;
    AbstractInstruction *jumpDoubleWordsOutOfRange;
    AbstractInstruction *jumpFixedFieldsOutOfBounds;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsCompiledMethod;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpIsWords;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNonSmallIntegerValue;
    AbstractInstruction *jumpNot64BitIndexable;
    AbstractInstruction *jumpNot8ByteInteger;
    AbstractInstruction *jumpNotIndexableBits;
    AbstractInstruction *jumpNotIndexablePointers;
    AbstractInstruction *jumpNotPointers;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpShortsOutOfRange;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfRange;
    AbstractInstruction *methodInBounds;
    sqInt nSlotsOrBytesReg;
    sqInt quickConstant;
    AbstractInstruction *rejoin;

	jumpDoubleWordsOutOfRange = ((AbstractInstruction *) 0);
	jumpNegative = ((AbstractInstruction *) 0);
	nSlotsOrBytesReg = ClassReg;
	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
#  if IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);

	/* begin genJumpBaseHeaderImmutable: */
	quickConstant = immutableBitMask();
	anInstruction = genoperandoperand(TstCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpImmutable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
#  else // IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
#  endif // IMMUTABILITY

	genGetNumSlotsOfinto(ReceiverResultReg, nSlotsOrBytesReg);
	quickConstant = weakArrayFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* optimistic store check; assume index in range (almost always is). */
	jumpNotPointers = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genStoreCheckReceiverRegvalueRegscratchReginFrame(ReceiverResultReg, Arg1Reg, TempReg, 0);
	quickConstant = arrayFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNotIndexablePointers = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	jumpHasFixedFields = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpArrayOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, Arg1Reg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpHasFixedFields, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genGetClassIndexOfNonImminto(ReceiverResultReg, formatReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassMethodContextCompactIndex, BytesPerOop));
	}

	/* get # fixed fields in formatReg */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(formatReg, Extra0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Extra0Reg, formatReg);
	genConvertSmallIntegerToIntegerInReg(formatReg);
	quickConstant = fixedFieldsOfClassFormatMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpFixedFieldsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* AddR:R: */
	genoperandoperand(AddRR, formatReg, Arg0Reg);

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, Arg1Reg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotPointers, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpNonSmallIntegerValue = genJumpNotSmallInteger(Arg1Reg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = sixtyFourBitIndexableFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* fall through to 64-bit words */
	jumpNotIndexableBits = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, SendNumArgsReg);
	genConvertSmallIntegerToIntegerInReg(SendNumArgsReg);
	if (!signedVersion) {
		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 0, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jumpNegative = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	}

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	rejoin = genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jump64BitsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, SendNumArgsReg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNonSmallIntegerValue, gCmpCqR(sixtyFourBitIndexableFormat(), formatReg));
	jumpNot64BitIndexable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	jump64BitArgIsImmediate = genJumpImmediate(Arg1Reg);
	if (signedVersion) {

		/* Test top bit of 64-bit word in large integer for range check. */
		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
		}

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jumpDoubleWordsOutOfRange = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	}

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, Arg1Reg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = headerForSlotsformatclassIndex(numSlotsMask(), formatMask(), classIndexMask());

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	quickConstant = headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargePositiveIntegerCompactIndex);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNot8ByteInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)rejoin));
	if (signedVersion) {

		/* Now check if the header is that of an 8 byte LargeNegativeInteger */
		jmpTarget(jumpNot8ByteInteger, gCmpCqR(headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargeNegativeIntegerCompactIndex), SendNumArgsReg));
		jumpNot8ByteInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
		}

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* SubR:R: */
		genoperandoperand(SubRR, TempReg, SendNumArgsReg);

		/* Jump: */
		genoperand(Jump, ((sqInt)rejoin));
	}
	if (signedVersion) {
		jmpTarget(jumpIsWords, gArithmeticShiftRightCqRR(0x1F + (numTagBits()), Arg1Reg, TempReg));

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, 1, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 1, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}
	}
	else {
		jmpTarget(jumpIsWords, gCmpCqR((((usqInt)0xFFFFFFFFU << 3) | 1), Arg1Reg));
	}
	jumpWordsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, nSlotsOrBytesReg);
	quickConstant = (BytesPerWord / 4) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	quickConstant = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:X32r:R: */
	genoperandoperandoperand(MoveRX32rR, TempReg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	if (signedVersion) {
		jmpTarget(jumpIsBytes, gArithmeticShiftRightCqRR(7 + (numTagBits()), Arg1Reg, TempReg));

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, 1, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 1, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}
	}
	else {
		jmpTarget(jumpIsBytes, gCmpCqR((((usqInt)0xFF << 3) | 1), Arg1Reg));
	}
	jumpBytesOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), nSlotsOrBytesReg);
	gAndCqRR(BytesPerWord - 1, formatReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, TempReg, nSlotsOrBytesReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsCompiledMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	methodInBounds = genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BaseHeaderSize, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveR:Xbr:R: */
	genoperandoperandoperand(MoveRXbrR, TempReg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	if (signedVersion) {
		jmpTarget(jumpIsShorts, gArithmeticShiftRightCqRR(15 + (numTagBits()), Arg1Reg, TempReg));

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, 1, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 1, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}
	}
	else {
		jmpTarget(jumpIsShorts, gCmpCqR((((usqInt)0xFFFF << 3) | 1), Arg1Reg));
	}
	jumpShortsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 1, nSlotsOrBytesReg);
	quickConstant = (BytesPerWord / 2) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);

	/* begin MoveR:M16:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRM16r, TempReg, BaseHeaderSize, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsCompiledMethod, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	getLiteralCountOfplusOneinBytesintoscratch(ReceiverResultReg, 1, 1, nSlotsOrBytesReg, TempReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);

	/* JumpBelow: */
	genConditionalBranchoperand(JumpBelow, ((sqInt)methodInBounds));
	jmpTarget(jumpNot8ByteInteger, jmpTarget(jump64BitArgIsImmediate, jmpTarget(jumpNot64BitIndexable, jmpTarget(jumpIsContext, jmpTarget(jumpNotIndexableBits, jmpTarget(jumpBytesOutOfRange, jmpTarget(jumpShortsOutOfRange, jmpTarget(jumpWordsOutOfRange, jmpTarget(jumpIsCompiledMethod, jmpTarget(jumpArrayOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jump64BitsOutOfBounds, jmpTarget(jumpNotIndexablePointers, jmpTarget(jumpFixedFieldsOutOfBounds, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))))))))))))));
	if (signedVersion) {
		jmpTarget(jumpDoubleWordsOutOfRange, ((AbstractInstruction *) (((jumpIsContext->operands))[0])));
	}
	else {
		jmpTarget(jumpNegative, ((AbstractInstruction *) (((jumpIsContext->operands))[0])));
	}
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, ((AbstractInstruction *) (((jumpIsContext->operands))[0])));
#  endif


	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	genConvertIntegerToSmallIntegerInReg(Arg0Reg);
	jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}


/*	Generate the code for primitives 60 & 164, at:/basicAt: & integerAt:. If
	signedVersion is true
	then generate signed accesses to the bits classes (a la 164 & 165). If
	signedVersion is false,
	generate unsigned accesses (a la 60, 61, 63 & 64). */
/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveAtSigned: */
static NoDbgRegParms sqInt
genPrimitiveAtSigned(sqInt signedVersion)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *convertToIntAndReturn;
    sqInt formatReg;
    AbstractInstruction *jumpArrayOutOfBounds;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFixedFieldsOutOfBounds;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpIsArray;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsLongs;
    AbstractInstruction *jumpIsMethod;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpIsWords;
    AbstractInstruction *jumpLongsOutOfBounds;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpNotSmallInteger;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *methodInBounds;
    sqInt nSlotsOrElementsReg;
    sqInt quickConstant;

	nSlotsOrElementsReg = ClassReg;
	jumpImmediate = genJumpImmediate(ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	genGetNumSlotsOfinto(ReceiverResultReg, nSlotsOrElementsReg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = arrayFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsArray = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	jumpNotIndexable = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	quickConstant = weakArrayFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpHasFixedFields = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = sixtyFourBitIndexableFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsLongs = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	jmpTarget(jumpNotIndexable, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpNotIndexable = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsArray,
		
		(/* begin CmpR:R: */
			assert(!(0 /* (Arg1Reg = SPReg) */)),
		genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg)));
	jumpArrayOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsBytes, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), nSlotsOrElementsReg));
	gAndCqRR(7, formatReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, TempReg, nSlotsOrElementsReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	methodInBounds = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	if (usesOutOfLineLiteral(methodInBounds)) {
		(methodInBounds->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	if (signedVersion) {
		/* SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, ReceiverResultReg, ReceiverResultReg);
	}
	convertToIntAndReturn = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, nSlotsOrElementsReg));

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, 3, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(3, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);

	/* begin MoveM16:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveM16rR, BaseHeaderSize, ReceiverResultReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	if (signedVersion) {
		/* SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, ReceiverResultReg, ReceiverResultReg);
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpIsWords, gLogicalShiftLeftCqR((shiftForWord()) - 2, nSlotsOrElementsReg));

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, 1, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveX32r:R:R: */
	genoperandoperandoperand(MoveX32rRR, Arg1Reg, ReceiverResultReg, TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	if (signedVersion) {
		/* SignExtend32R:R: */
		genoperandoperand(SignExtend32RR, ReceiverResultReg, ReceiverResultReg);
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpHasFixedFields, gAndCqR(classIndexMask(), TempReg));

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, formatReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassMethodContextCompactIndex, BytesPerOop));
	}
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(formatReg, Extra0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Extra0Reg, formatReg);
	genConvertSmallIntegerToIntegerInReg(formatReg);
	quickConstant = fixedFieldsOfClassFormatMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);

	/* index is (formatReg (fixed fields) + Arg1Reg (0-rel index)) * wordSize + baseHeaderSize */
	jumpFixedFieldsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* AddR:R: */
	genoperandoperand(AddRR, formatReg, Arg1Reg);
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsLongs,
		
		(/* begin CmpR:R: */
			assert(!(0 /* (Arg1Reg = SPReg) */)),
		genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg)));
	jumpLongsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ClassReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	if (signedVersion) {

		/* c.f. Spur64BitMemoryManager>>#isIntegerValue: */
		/* ArithmeticShiftRightCq:R: */
		genoperandoperand(ArithmeticShiftRightCqR, numSmallIntegerBits(), TempReg);

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, 15, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(15, BytesPerOop));
		}

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 1, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}
		jumpNotSmallInteger = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

		/* MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);

		/* Jump: */
		genoperand(Jump, ((sqInt)convertToIntAndReturn));
		jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jumpFailAlloc = genAlloc64BitSignedIntegerValueintoscratchRegscratchReg(ClassReg, SendNumArgsReg, Extra0Reg, TempReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

		/* genPrimReturn */
		if (methodOrBlockNumArgs <= (numRegArgs())) {
			/* RetN: */
			genoperand(RetN, 0);
		}
		else {
			/* RetN: */
			genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
		}
	}
	else {
		quickConstant = (numSmallIntegerBits()) - 1;

		/* begin LogicalShiftRightCq:R: */
		genoperandoperand(LogicalShiftRightCqR, quickConstant, TempReg);
		anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jumpNotSmallInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

		/* MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);

		/* Jump: */
		genoperand(Jump, ((sqInt)convertToIntAndReturn));
		jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jumpFailAlloc = genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(ClassReg, SendNumArgsReg, Extra0Reg, TempReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

		/* genPrimReturn */
		if (methodOrBlockNumArgs <= (numRegArgs())) {
			/* RetN: */
			genoperand(RetN, 0);
		}
		else {
			/* RetN: */
			genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
		}
	}
	jmpTarget(jumpIsMethod, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	getLiteralCountOfplusOneinBytesintoscratch(ReceiverResultReg, 1, 1, nSlotsOrElementsReg, TempReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);

	/* JumpBelow: */
	genConditionalBranchoperand(JumpBelow, ((sqInt)methodInBounds));
	jmpTarget(jumpFailAlloc, jmpTarget(jumpLongsOutOfBounds, jmpTarget(jumpFixedFieldsOutOfBounds, jmpTarget(jumpArrayOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpNotIndexable, jmpTarget(jumpIsContext, jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))))))))));
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatEqual */
static sqInt
genPrimitiveFloatEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPEqual, JumpZero, 0, 1)
			: genPureFloatComparisoninvertboxed(gJumpFPEqual, 0, 1));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatGreaterOrEqual */
static sqInt
genPrimitiveFloatGreaterOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreaterOrEqual, JumpGreaterOrEqual, 0, 1)
			: genPureFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 0, 1));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatGreaterThan */
static sqInt
genPrimitiveFloatGreaterThan(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreater, JumpGreater, 0, 1)
			: genPureFloatComparisoninvertboxed(gJumpFPGreater, 0, 1));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatLessOrEqual */
static sqInt
genPrimitiveFloatLessOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreaterOrEqual, JumpLessOrEqual, 1, 1)
			: genPureFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 1, 1));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatLessThan */
static sqInt
genPrimitiveFloatLessThan(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPGreater, JumpLess, 1, 1)
			: genPureFloatComparisoninvertboxed(gJumpFPGreater, 1, 1));
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveFloatNotEqual */
static sqInt
genPrimitiveFloatNotEqual(void)
{
	return (primitiveDoMixedArithmetic()
			? genFloatComparisonorIntegerComparisoninvertboxed(gJumpFPNotEqual, JumpNonZero, 0, 1)
			: genPureFloatComparisoninvertboxed(gJumpFPNotEqual, 0, 1));
}


/*	Arguably we should fail for immediates, but so far no one has complained,
	so... 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveIdentityHash */
static sqInt
genPrimitiveIdentityHash(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *inst;
    AbstractInstruction *jumpImm;
    AbstractInstruction *jumpNotCharacter;
    AbstractInstruction *jumpNotSet;
    sqInt quickConstant;
    AbstractInstruction *ret;

	/* uses TstCqR */
	jumpImm = genJumpImmediate(ReceiverResultReg);
	genGetHashFieldNonImmOfasSmallIntegerInto(ReceiverResultReg, TempReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ConstZero, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ConstZero, BytesPerOop));
	}
	jumpNotSet = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	ret = /* genPrimReturn */
			(methodOrBlockNumArgs <= (numRegArgs())
				? genoperand(RetN, 0)
				: genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord));
	jmpTarget(jumpImm, gAndCqRR(tagMask(), ReceiverResultReg, TempReg));
	quickConstant = characterTag();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNotCharacter = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertCharacterToSmallIntegerInReg(ReceiverResultReg);
	ret = /* genPrimReturn */
			(methodOrBlockNumArgs <= (numRegArgs())
				? genoperand(RetN, 0)
				: genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord));
	jmpTarget(jumpNotCharacter, gCmpCqR(smallFloatTag(), TempReg));

	/* JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)ret));
	genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(ReceiverResultReg, TempReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSet, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (!(primitiveIndex == 75)) {
		return 0;
	}
	backEnd;

	/* begin saveAndRestoreLinkRegAround: */
	inst = genoperand(PushR, LinkReg);
	abstractInstruction = genoperand(Call, ceNewHashTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* PopR: */
	genoperand(PopR, LinkReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveImmediateAsInteger */
static sqInt
genPrimitiveImmediateAsInteger(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpNotCharacter;
    sqInt quickConstant;
    AbstractInstruction *ret;

	gAndCqRR(tagMask(), ReceiverResultReg, TempReg);
	quickConstant = characterTag();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNotCharacter = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertCharacterToSmallIntegerInReg(ReceiverResultReg);
	ret = /* genPrimReturn */
			(methodOrBlockNumArgs <= (numRegArgs())
				? genoperand(RetN, 0)
				: genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord));
	jmpTarget(jumpNotCharacter, gCmpCqR(smallFloatTag(), TempReg));

	/* JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)ret));
	genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(ReceiverResultReg, TempReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}


/*	Implement primitiveNew for convenient cases:
	- the receiver has a hash
	- the receiver is fixed size (excluding ephemerons to save instructions &
	miniscule time)
	- single word header/num slots < numSlotsMask
	- the result fits in eden (actually below scavengeThreshold)
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveNew */
static sqInt
genPrimitiveNew(void)
{
    AbstractInstruction *anInstruction;
    sqInt byteSizeReg;
    AbstractInstruction *fillLoop;
    sqInt fillReg;
    sqInt headerReg;
    sqInt instSpecReg;
    AbstractInstruction *jumpHasSlots;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpTooBig;
    AbstractInstruction *jumpUnhashed;
    AbstractInstruction *jumpVariableOrEphemeron;
    sqInt quickConstant;
    AbstractInstruction *skip;

	if (methodOrBlockNumArgs) {
		return UnimplementedPrimitive;
	}

	/* inst spec will hold class's instance specification, then byte size and finally end of new object. */
	headerReg = (fillReg = SendNumArgsReg);

	/* get freeStart as early as possible so as not to wait later... */
	instSpecReg = (byteSizeReg = ClassReg);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), Arg1Reg));
	genGetHashFieldNonImmOfinto(ReceiverResultReg, headerReg);

	/* get class's format inst var for both inst spec (format field) and num fixed fields */
	jumpUnhashed = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, ReceiverResultReg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, instSpecReg);

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, fixedFieldsFieldWidth(), TempReg);
	quickConstant = formatMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	quickConstant = fixedFieldsOfClassFormatMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	quickConstant = nonIndexablePointerFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpVariableOrEphemeron = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	quickConstant = numSlotsMask();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* Add format to classIndex/format in header; the add in numSlots */
	jumpTooBig = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, formatShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, numSlotsFullShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpHasSlots = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BaseHeaderSize * 2, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize * 2, BytesPerOop));
	}

	/* round up to allocationUnit */
	skip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasSlots, gAddCqR(BaseHeaderSize / BytesPerWord, byteSizeReg));

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	jmpTarget(skip, genoperandoperand(AddRR, Arg1Reg, byteSizeReg));
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* write back new freeStart; get result. byteSizeReg holds new freeStart, the limit of the object */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, byteSizeReg, freeStartAddress()));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, headerReg, 0, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, BaseHeaderSize, ReceiverResultReg, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), fillReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	fillLoop = genoperandoperandoperand(MoveRMwr, fillReg, 0, Arg1Reg);
	if (usesOutOfLineLiteral(fillLoop)) {
		(fillLoop->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 8, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(8, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, byteSizeReg);

	/* JumpAbove: */
	genConditionalBranchoperand(JumpAbove, ((sqInt)fillLoop));

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpUnhashed, jmpTarget(jumpVariableOrEphemeron, jmpTarget(jumpTooBig, jmpTarget(jumpNoSpace, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	return 0;
}


/*	Implement primitiveNewWithArg for convenient cases:
	- the receiver has a hash
	- the receiver is variable and not compiled method
	- single word header/num slots < numSlotsMask
	- the result fits in eden
	See superclass method for dynamic frequencies of formats.
	For the moment we implement only arrayFormat, firstByteFormat &
	firstLongFormat 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveNewWithArg */
static sqInt
genPrimitiveNewWithArg(void)
{
    AbstractInstruction *anInstruction;
    sqInt byteSizeReg;
    AbstractInstruction *fillLoop;
    sqInt fillReg;
    sqInt headerReg;
    sqInt instSpecReg;
    AbstractInstruction *jumpArrayFormat;
    AbstractInstruction *jumpArrayTooBig;
    AbstractInstruction *jumpByteFormat;
    AbstractInstruction *jumpBytePrepDone;
    AbstractInstruction *jumpByteTooBig;
    AbstractInstruction *jumpFailCuzFixed;
    AbstractInstruction *jumpHasSlots;
    AbstractInstruction *jumpLongPrepDone;
    AbstractInstruction *jumpLongTooBig;
    AbstractInstruction *jumpNElementsNonInt;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpUnhashed;
    sqInt maxSlots;
    sqInt quickConstant;
    AbstractInstruction *skip;

	if (methodOrBlockNumArgs != 1) {
		return UnimplementedPrimitive;
	}

	/* Assume there's an available scratch register on 64-bit machines.  This holds the saved numFixedFields and then the value to fill with */
	headerReg = SendNumArgsReg;
	fillReg = Extra0Reg;
	assert(fillReg > 0);

	/* The max slots we'll allocate here are those for a single header */
	instSpecReg = (byteSizeReg = ClassReg);

	/* get freeStart as early as possible so as not to wait later... */
	maxSlots = (numSlotsMask()) - 1;

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), Arg1Reg));
	genGetHashFieldNonImmOfinto(ReceiverResultReg, headerReg);

	/* get index and fail if not a +ve integer */
	jumpUnhashed = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* get class's format inst var for inst spec (format field) */
	jumpNElementsNonInt = genJumpNotSmallInteger(Arg0Reg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, ReceiverResultReg, instSpecReg);
	quickConstant = (fixedFieldsFieldWidth()) + (numSmallIntegerTagBits());

	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, quickConstant, instSpecReg);
	quickConstant = formatMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, formatShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, fillReg);
	genConvertSmallIntegerToIntegerInReg(fillReg);
	quickConstant = arrayFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpArrayFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpByteFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpFailCuzFixed = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)(maxSlots * 2) << 3) | 1), Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)(maxSlots * 2) << 3) | 1), BytesPerOop));
	}

	/* save num elements/slot size to instSpecReg */
	jumpLongTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BytesPerWord / 4, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord / 4, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	quickConstant = (BytesPerWord / 4) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, formatShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	quickConstant = (BytesPerWord / 4) - 1;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, (shiftForWord()) - 2, instSpecReg);
	anInstruction = genoperandoperand(MoveCqR, 0, fillReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* go allocate */
	jumpLongPrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpByteFormat, gCmpCqR((((usqInt)(maxSlots * BytesPerWord) << 3) | 1), Arg0Reg));

	/* save num elements to instSpecReg */
	jumpByteTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BytesPerWord, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, BytesPerWord - 1, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord - 1, BytesPerOop));
	}

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, formatShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BytesPerWord - 1, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord - 1, BytesPerOop));
	}

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, shiftForWord(), instSpecReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, fillReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* go allocate */
	jumpBytePrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpArrayFormat, gCmpCqR((((usqInt)maxSlots << 3) | 1), Arg0Reg));

	/* save num elements/slot size to instSpecReg */
	jumpArrayTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), fillReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}
	jmpTarget(jumpBytePrepDone, jmpTarget(jumpLongPrepDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));

	/* MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, numSlotsFullShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpHasSlots = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BaseHeaderSize * 2, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize * 2, BytesPerOop));
	}
	skip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasSlots, gAddCqR(BaseHeaderSize / BytesPerWord, byteSizeReg));

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	jmpTarget(skip, genoperandoperand(AddRR, Arg1Reg, byteSizeReg));
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* get result, increment freeStart and write it back. Arg1Reg holds new freeStart, the limit of the object */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, byteSizeReg, freeStartAddress()));

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, headerReg, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, BaseHeaderSize, ReceiverResultReg, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	fillLoop = genoperandoperandoperand(MoveRMwr, fillReg, 0, Arg1Reg);
	if (usesOutOfLineLiteral(fillLoop)) {
		(fillLoop->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 8, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(8, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, byteSizeReg);

	/* JumpAbove: */
	genConditionalBranchoperand(JumpAbove, ((sqInt)fillLoop));

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNoSpace, jmpTarget(jumpUnhashed, jmpTarget(jumpFailCuzFixed, jmpTarget(jumpArrayTooBig, jmpTarget(jumpByteTooBig, jmpTarget(jumpLongTooBig, jmpTarget(jumpNElementsNonInt, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))))));
	return 0;
}


/*	Implement primitiveShallowCopy/primitiveClone for convenient cases:
	- the receiver is not a context
	- the receiver is not a compiled method
	- the result fits in eden (actually below scavengeThreshold) */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveShallowCopy */
static sqInt
genPrimitiveShallowCopy(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *continuance;
    AbstractInstruction *copyLoop;
    sqInt formatReg;
    AbstractInstruction *jumpEmpty;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpIsMethod;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpTooBig;
    AbstractInstruction *jumpVariable;
    sqInt ptrReg;
    sqInt quickConstant;
    sqInt resultReg;
    sqInt slotsReg;

	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	resultReg = Arg0Reg;

	/* get freeStart as early as possible so as not to wait later... */
	slotsReg = Arg1Reg;

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), resultReg));
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (ptrReg = (formatReg = SendNumArgsReg)), NoReg);
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = indexablePointersFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpVariable = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	continuance = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genGetRawSlotSizeOfNonImminto(ReceiverResultReg, slotsReg);
	quickConstant = numSlotsMask();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, slotsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpTooBig = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, slotsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* compute byte size for slots */
	jumpEmpty = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	quickConstant = BaseHeaderSize / BytesPerWord;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, slotsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), slotsReg);

	/* AddR:R: */
	genoperandoperand(AddRR, resultReg, slotsReg);
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, slotsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, resultReg, ptrReg);

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, slotsReg, freeStartAddress()));

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, BytesPerWord * 2, slotsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord * 2, BytesPerOop));
	}

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, ReceiverResultReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = headerForSlotsformatclassIndex(numSlotsMask(), formatMask(), classIndexMask());

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, 0, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	copyLoop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BytesPerWord, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
	}

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BytesPerWord, ptrReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
	}

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, ReceiverResultReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, 0, ptrReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!((ptrReg == SPReg)));
	genoperandoperand(CmpRR, ptrReg, slotsReg);

	/* JumpAboveOrEqual: */
	genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)copyLoop));

	/* MoveR:R: */
	genoperandoperand(MoveRR, resultReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpVariable, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genGetClassIndexOfNonImminto(ReceiverResultReg, ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassMethodContextCompactIndex, BytesPerOop));
	}

	/* JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)continuance));
	jmpTarget(jumpImmediate, jmpTarget(jumpNoSpace, jmpTarget(jumpIsMethod, jmpTarget(jumpTooBig, jmpTarget(jumpEmpty, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	return 0;
}


/*	Generate the code for primitive 173, instVarAt:. Defer to
	StackInterpreterPrimitives>>primitiveSlotAt for Contexts.
 */
/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveSlotAt */
static sqInt
genPrimitiveSlotAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *convertToIntAndReturn;
    sqInt formatReg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsMethod;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpIsWords;
    AbstractInstruction *jumpLongsOutOfBounds;
    AbstractInstruction *jumpNonPointers;
    AbstractInstruction *jumpPointersOutOfBounds;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpToReturnLargeInteger;
    AbstractInstruction *jumpWordsOutOfBounds;
    sqInt nSlotsOrElementsReg;
    sqInt quickConstant;

	nSlotsOrElementsReg = ClassReg;
	jumpImmediate = genJumpImmediate(ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	genGetNumSlotsOfinto(ReceiverResultReg, nSlotsOrElementsReg);
	quickConstant = sixtyFourBitIndexableFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNonPointers = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = classIndexMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassMethodContextCompactIndex, BytesPerOop));
	}

	/* Fail to StackInterpreterPrimitives>>primitiveSlotAt for Context */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);

	/* index is (formatReg Arg1Reg (0-rel index) * wordSize + baseHeaderSize */
	jumpPointersOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNonPointers, gCmpCqR(firstByteFormat(), formatReg));
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* fall through to objectMemory sixtyFourBitIndexableFormat */
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	jumpLongsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ClassReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	quickConstant = (numSmallIntegerBits()) - 1;

	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, quickConstant, TempReg);
	anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpToReturnLargeInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertIntegerInRegtoSmallIntegerInReg(ClassReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpToReturnLargeInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpFailAlloc = genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(ClassReg, SendNumArgsReg, Extra0Reg, TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsBytes, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), nSlotsOrElementsReg));
	gAndCqRR(7, formatReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, TempReg, nSlotsOrElementsReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	convertToIntAndReturn = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, nSlotsOrElementsReg));

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, 3, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(3, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);

	/* begin MoveM16:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveM16rR, BaseHeaderSize, ReceiverResultReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpIsWords, gLogicalShiftLeftCqR((shiftForWord()) - 2, nSlotsOrElementsReg));

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, 1, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrElementsReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, nSlotsOrElementsReg);
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveX32r:R:R: */
	genoperandoperandoperand(MoveX32rRR, Arg1Reg, ReceiverResultReg, TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);

	/* Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpFailAlloc, jmpTarget(jumpLongsOutOfBounds, jmpTarget(jumpPointersOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpIsMethod, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpIsContext, jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))))))));
	return 0;
}


/*	Generate the code for primitive 174, instVarAt:put:. Defer to
	StackInterpreterPrimitives>>primitiveSlotAtPut for Contexts.
 */
/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveSlotAtPut */
static sqInt
genPrimitiveSlotAtPut(void)
{
    AbstractInstruction *anInstruction;
    sqInt formatReg;
    AbstractInstruction *jump64BitArgIsImmediate;
    AbstractInstruction *jump64BitsOutOfBounds;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpBytesOutOfRange;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsCompiledMethod;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpIsWords;
    AbstractInstruction *jumpNonSmallIntegerValue;
    AbstractInstruction *jumpNot64BitIndexable;
    AbstractInstruction *jumpNot8ByteInteger;
    AbstractInstruction *jumpNotIndexableBits;
    AbstractInstruction *jumpNotPointers;
    AbstractInstruction *jumpPointersOutOfBounds;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpShortsOutOfRange;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfRange;
    sqInt nSlotsOrBytesReg;
    sqInt quickConstant;
    AbstractInstruction *rejoin;

	nSlotsOrBytesReg = Extra0Reg;
	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
#  if IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);

	/* begin genJumpBaseHeaderImmutable: */
	quickConstant = immutableBitMask();
	anInstruction = genoperandoperand(TstCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpImmutable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
#  else // IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
#  endif // IMMUTABILITY

	genGetNumSlotsOfinto(ReceiverResultReg, nSlotsOrBytesReg);
	quickConstant = weakArrayFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNotPointers = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genGetClassIndexOfNonImminto(ReceiverResultReg, ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassMethodContextCompactIndex, BytesPerOop));
	}

	/* Fail to StackInterpreterPrimitives>>primitiveSlotAtPut for Context */
	/* optimistic store check; assume index in range (almost always is). */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genStoreCheckReceiverRegvalueRegscratchReginFrame(ReceiverResultReg, Arg1Reg, TempReg, 0);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpPointersOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, Arg1Reg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotPointers, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpNonSmallIntegerValue = genJumpNotSmallInteger(Arg1Reg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = sixtyFourBitIndexableFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* fall through to 64-bit words */
	jumpNotIndexableBits = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, SendNumArgsReg);
	genConvertSmallIntegerToIntegerInReg(SendNumArgsReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	rejoin = genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jump64BitsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, SendNumArgsReg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNonSmallIntegerValue, gCmpCqR(sixtyFourBitIndexableFormat(), formatReg));
	jumpNot64BitIndexable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* Now check if the header is that of an 8 byte LargePositiveInteger */
	jump64BitArgIsImmediate = genJumpImmediate(Arg1Reg);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, Arg1Reg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = headerForSlotsformatclassIndex(numSlotsMask(), formatMask(), classIndexMask());

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	quickConstant = headerForSlotsformatclassIndex(1, firstByteFormat(), ClassLargePositiveIntegerCompactIndex);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNot8ByteInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, Arg1Reg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)rejoin));
	jmpTarget(jumpIsWords, gCmpCqR((((usqInt)0xFFFFFFFFU << 3) | 1), Arg1Reg));
	jumpWordsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, nSlotsOrBytesReg);
	quickConstant = (BytesPerWord / 4) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	quickConstant = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:X32r:R: */
	genoperandoperandoperand(MoveRX32rR, TempReg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gCmpCqR((((usqInt)0xFFFF << 3) | 1), Arg1Reg));
	jumpShortsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 1, nSlotsOrBytesReg);
	quickConstant = (BytesPerWord / 2) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, nSlotsOrBytesReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);

	/* begin MoveR:M16:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRM16r, TempReg, BaseHeaderSize, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsBytes, gCmpCqR((((usqInt)0xFF << 3) | 1), Arg1Reg));
	jumpBytesOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), nSlotsOrBytesReg);
	gAndCqRR(BytesPerWord - 1, formatReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, TempReg, nSlotsOrBytesReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, nSlotsOrBytesReg);
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsCompiledMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BaseHeaderSize, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveR:Xbr:R: */
	genoperandoperandoperand(MoveRXbrR, TempReg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNot8ByteInteger, jmpTarget(jump64BitArgIsImmediate, jmpTarget(jumpNot64BitIndexable, jmpTarget(jumpIsContext, jmpTarget(jumpNotIndexableBits, jmpTarget(jumpBytesOutOfRange, jmpTarget(jumpShortsOutOfRange, jmpTarget(jumpWordsOutOfRange, jmpTarget(jumpIsCompiledMethod, jmpTarget(jumpPointersOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jump64BitsOutOfBounds, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))))))))))));
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, ((AbstractInstruction *) (((jumpIsContext->operands))[0])));
#  endif


	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	genConvertIntegerToSmallIntegerInReg(Arg0Reg);
	jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}


/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveStringAt */
static sqInt
genPrimitiveStringAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *done;
    sqInt formatReg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpWordsDone;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordTooBig;
    sqInt quickConstant;

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsBytes = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsShorts = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* fall through to double words */
	jumpNotIndexable = genConditionalBranchoperand(JumpLess, ((sqInt)0));

	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, ClassReg);
	quickConstant = (BytesPerWord / 4) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	quickConstant = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveX32r:R:R: */
	genoperandoperandoperand(MoveX32rRR, Arg1Reg, ReceiverResultReg, TempReg);
	jumpWordTooBig = jumpNotCharacterUnsignedValueInRegister(TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	jumpWordsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsBytes, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), ClassReg));

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, BytesPerWord - 1, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord - 1, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	jmpTarget(jumpWordsDone, (done = genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genConvertIntegerToCharacterInReg(ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, ClassReg));
	quickConstant = (BytesPerWord / 2) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg1Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);

	/* begin MoveM16:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveM16rR, BaseHeaderSize, ReceiverResultReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)done));
	jmpTarget(jumpWordTooBig, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpNotIndexable, jmpTarget(jumpBadIndex, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))));
	return CompletePrimitive;
}


/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveStringAtPut */
static sqInt
genPrimitiveStringAtPut(void)
{
    AbstractInstruction *anInstruction;
    sqInt formatReg;
    AbstractInstruction *jumpBadArg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpBytesOutOfRange;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsCompiledMethod;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpNotString;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpShortsOutOfRange;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfRange;
    sqInt quickConstant;

	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	jumpBadArg = genJumpNotCharacter(Arg1Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
#  if IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);

	/* begin genJumpBaseHeaderImmutable: */
	quickConstant = immutableBitMask();
	anInstruction = genoperandoperand(TstCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpImmutable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
#  else // IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
#  endif // IMMUTABILITY

	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpNotString = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsCompiledMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* fall through to double words */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	quickConstant = characterObjectOf((1U << (numCharacterBits())) - 1);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpWordsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, ClassReg);
	quickConstant = (BytesPerWord / 4) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);
	quickConstant = ((usqInt)(BaseHeaderSize)) >> ((shiftForWord()) - 1);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:X32r:R: */
	genoperandoperandoperand(MoveRX32rR, TempReg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsShorts, gCmpCqR(characterObjectOf(0xFFFF), Arg1Reg));
	jumpShortsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 1, ClassReg);
	quickConstant = (BytesPerWord / 2) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);

	/* begin MoveR:M16:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRM16r, TempReg, BaseHeaderSize, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIsBytes, gCmpCqR(characterObjectOf(0xFF), Arg1Reg));
	jumpBytesOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), ClassReg);

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, BytesPerWord - 1, formatReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord - 1, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BaseHeaderSize, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* MoveR:Xbr:R: */
	genoperandoperandoperand(MoveRXbrR, TempReg, Arg0Reg, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotString, jmpTarget(jumpBytesOutOfRange, jmpTarget(jumpShortsOutOfRange, jmpTarget(jumpWordsOutOfRange, jmpTarget(jumpIsCompiledMethod, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))))));
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, ((AbstractInstruction *) (((jumpNotString->operands))[0])));
#  endif


	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	genConvertIntegerToSmallIntegerInReg(Arg0Reg);
	jmpTarget(jumpBadArg, jmpTarget(jumpBadIndex, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	Implement primitiveUninitializedNewWithArg for convenient cases:
	- the receiver has a hash
	- the receiver is variable and not compiled method
	- the result fits in eden
	See superclass method for dynamic frequencies of formats.
	For the moment we implement only arrayFormat, firstByteFormat &
	firstLongFormat 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveUninitializedNewWithArg */
static sqInt
genPrimitiveUninitializedNewWithArg(void)
{
    AbstractInstruction *anInstruction;
    sqInt byteSizeReg;
    sqInt fillReg;
    sqInt headerReg;
    sqInt instSpecReg;
    AbstractInstruction *jumpByteFormat;
    AbstractInstruction *jumpByteTooBig;
    AbstractInstruction *jumpDoubleByteFormat;
    AbstractInstruction *jumpDoubleBytePrepDone;
    AbstractInstruction *jumpDoubleWordFormat;
    AbstractInstruction *jumpDoubleWordPrepDone;
    AbstractInstruction *jumpDoubleWordTooBig;
    AbstractInstruction *jumpFailCuzFixed;
    AbstractInstruction *jumpHasSlots;
    AbstractInstruction *jumpLongPrepDone;
    AbstractInstruction *jumpLongTooBig;
    AbstractInstruction *jumpNElementsNonInt;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpNoSpaceBigObjects;
    AbstractInstruction *jumpOverflowHeader;
    AbstractInstruction *jumpShortTooBig;
    AbstractInstruction *jumpUnhashed;
    sqInt maxSlots;
    sqInt quickConstant;
    AbstractInstruction *skip;

	if (methodOrBlockNumArgs != 1) {
		return UnimplementedPrimitive;
	}

	/* Assume there's an available scratch register on 64-bit machines.  This holds the saved numFixedFields and then the value to fill with */
	headerReg = SendNumArgsReg;
	fillReg = Extra0Reg;
	assert(fillReg > 0);

	/* Allow a max of 1 MB */
	instSpecReg = (byteSizeReg = ClassReg);

	/* get freeStart as early as possible so as not to wait later... */
	maxSlots = maxSlotsForNewSpaceAlloc();

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), Arg1Reg));
	genGetHashFieldNonImmOfinto(ReceiverResultReg, headerReg);

	/* get index and fail if not a +ve integer */
	jumpUnhashed = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* get class's format inst var for inst spec (format field) */
	jumpNElementsNonInt = genJumpNotSmallInteger(Arg0Reg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, ReceiverResultReg, instSpecReg);
	quickConstant = (fixedFieldsFieldWidth()) + (numSmallIntegerTagBits());

	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, quickConstant, instSpecReg);
	quickConstant = formatMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, formatShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, fillReg);
	genConvertSmallIntegerToIntegerInReg(fillReg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpByteFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpDoubleByteFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	quickConstant = sixtyFourBitIndexableFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpDoubleWordFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* allocates a 32-bit array */
	jumpFailCuzFixed = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)(maxSlots * 2) << 3) | 1), Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)(maxSlots * 2) << 3) | 1), BytesPerOop));
	}

	/* save num elements/slot size to instSpecReg */
	jumpLongTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BytesPerWord / 4, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord / 4, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	quickConstant = (BytesPerWord / 4) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, formatShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	quickConstant = (BytesPerWord / 4) - 1;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, (shiftForWord()) - 2, instSpecReg);

	/* go allocate */
	/* allocates a 16-bit array */
	jumpLongPrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpDoubleByteFormat, gCmpCqR((((usqInt)(maxSlots * 4) << 3) | 1), Arg0Reg));

	/* save num elements to instSpecReg */
	jumpShortTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BytesPerWord / 2, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord / 2, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	quickConstant = (BytesPerWord / 2) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, formatShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	quickConstant = (BytesPerWord / 2) - 1;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, (shiftForWord()) - 1, instSpecReg);

	/* go allocate */
	/* allocates a 64-bit array */
	jumpDoubleBytePrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpDoubleWordFormat, gCmpCqR((((usqInt)maxSlots << 3) | 1), Arg0Reg));

	/* save num elements to instSpecReg */
	jumpDoubleWordTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);

	/* go allocate */
	/* allocates a byte array */
	jumpDoubleWordPrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpByteFormat, gCmpCqR((((usqInt)(maxSlots * BytesPerWord) << 3) | 1), Arg0Reg));

	/* save num elements to instSpecReg */
	jumpByteTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BytesPerWord, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, BytesPerWord - 1, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord - 1, BytesPerOop));
	}

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, formatShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BytesPerWord - 1, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord - 1, BytesPerOop));
	}

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, shiftForWord(), instSpecReg);
	jmpTarget(jumpDoubleWordPrepDone, jmpTarget(jumpDoubleBytePrepDone, jmpTarget(jumpLongPrepDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	quickConstant = numSlotsMask();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, instSpecReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* fallthrough: allocate objects with < 255 slots */
	/* store numSlots to headerReg */
	jumpOverflowHeader = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, numSlotsFullShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpHasSlots = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BaseHeaderSize * 2, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize * 2, BytesPerOop));
	}
	skip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasSlots, gAddCqR(BaseHeaderSize / BytesPerWord, byteSizeReg));

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	jmpTarget(skip, genoperandoperand(AddRR, Arg1Reg, byteSizeReg));
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* get result, increment freeStart and write it back. Arg1Reg holds new freeStart, the limit of the object */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, byteSizeReg, freeStartAddress()));

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, headerReg, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOverflowHeader, gMoveCqR(0xFF, TempReg));

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, numSlotsFullShift(), TempReg);

	/* AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);

	/* AddR:R: */
	genoperandoperand(AddRR, instSpecReg, TempReg);
	quickConstant = (BaseHeaderSize * 2) / BytesPerWord;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);

	/* AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, byteSizeReg);
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, byteSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* get result, increment freeStart and write it back. Arg1Reg holds new freeStart, the limit of the object */
	jumpNoSpaceBigObjects = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, byteSizeReg, freeStartAddress()));

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, headerReg, BaseHeaderSize, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpShortTooBig, jmpTarget(jumpDoubleWordTooBig, jmpTarget(jumpNoSpaceBigObjects, jmpTarget(jumpNoSpace, jmpTarget(jumpUnhashed, jmpTarget(jumpFailCuzFixed, jmpTarget(jumpByteTooBig, jmpTarget(jumpLongTooBig, jmpTarget(jumpNElementsNonInt, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))))))));
	return 0;
}


/*	In the Pure version, mixed arithmetic with SmallInteger is forbidden */

	/* CogObjectRepresentationFor64BitSpur>>#genPureFloatArithmetic:preOpCheck:boxed: */
static NoDbgRegParms sqInt
genPureFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed)
{
    AbstractInstruction *doOp;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFailCheck;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;

	jumpFailCheck = ((AbstractInstruction *) 0);
	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	doOp = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (preOpCheckOrNil) {
		jumpFailCheck = preOpCheckOrNil(DPFPReg0, DPFPReg1);
	}
	genoperandoperand(arithmeticOperator, DPFPReg1, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);

	/* Jump: */
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	if (preOpCheckOrNil) {
		jmpTarget(jumpFailCheck, ((AbstractInstruction *) (((jumpFailAlloc->operands))[0])));
	}
	return 0;
}


/*	In the Pure version, mixed arithmetic with SmallInteger is forbidden */

	/* CogObjectRepresentationFor64BitSpur>>#genPureFloatComparison:invert:boxed: */
static NoDbgRegParms sqInt
genPureFloatComparisoninvertboxed(AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt invertComparison, sqInt rcvrBoxed)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *compareFloat;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;

	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	compareFloat = (invertComparison
				? genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1)
				: genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0));

	/* FP jumps are a little weird */
	jumpCond = jumpFPOpcodeGenerator(0);

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, genMoveConstantR(trueObject(), ReceiverResultReg));

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);

	/* Jump: */
	genoperand(Jump, ((sqInt)compareFloat));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentationFor64BitSpur>>#genRemoveSmallIntegerTagsInScratchReg: */
static NoDbgRegParms sqInt
genRemoveSmallIntegerTagsInScratchReg(sqInt scratchReg)
{
    AbstractInstruction *anInstruction;

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genShiftAwaySmallIntegerTagsInScratchReg: */
static NoDbgRegParms sqInt
genShiftAwaySmallIntegerTagsInScratchReg(sqInt scratchReg)
{
	/* ArithmeticShiftRightCq:R: */
	genoperandoperand(ArithmeticShiftRightCqR, numTagBits(), scratchReg);
	return 0;
}


/*	Stack looks like
	return address */

	/* CogObjectRepresentationFor64BitSpur>>#genSmallIntegerComparison:orDoubleComparison:invert: */
static NoDbgRegParms sqInt
genSmallIntegerComparisonorDoubleComparisoninvert(sqInt jumpOpcode, AbstractInstruction * NoDbgRegParms (*jumpFPOpcodeGenerator)(void *), sqInt invertComparison)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *compareIntFloat;
    AbstractInstruction *jumpAmbiguous;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotFloatAtAll;
    AbstractInstruction *jumpNotSmallFloat;
    AbstractInstruction *jumpTrue;
    sqInt r;
    AbstractInstruction *returnTrue;

	r = genSmallIntegerComparison(jumpOpcode);
	if (r < 0) {
		return r;
	}
#  if defined(DPFPReg0)

	/* Fall through on non-SmallInteger argument.  Argument may be a Float : let us check or fail */
	/* check for Small Float argument */
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	compareIntFloat = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertSmallIntegerToIntegerInReg(ReceiverResultReg);

	/* ConvertR:Rd: */
	genoperandoperand(ConvertRRd, ReceiverResultReg, DPFPReg0);

	/* CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);

	/* Case of non ambiguity, use compareFloat((double) intRcvr,floatArg) */
	jumpAmbiguous = gJumpFPEqual(0);
	if (invertComparison) {

		/* May need to invert for NaNs */
		/* CmpRd:Rd: */
		genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		/* CmpRd:Rd: */
		genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}

	/* FP jumps are a little weird */
	jumpCond = jumpFPOpcodeGenerator(0);

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, (returnTrue = genMoveConstantR(trueObject(), ReceiverResultReg)));

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpAmbiguous, genoperandoperand(ConvertRdR, DPFPReg1, Arg0Reg));

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpTrue = genConditionalBranchoperand(jumpOpcode, 0);

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpTrue, returnTrue);
	jmpTarget(jumpNotSmallFloat, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpNotFloatAtAll = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);

	/* It was a Boxed Float, so convert the receiver to double and perform the (int compare: float) operation */
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);

	/* Jump: */
	genoperand(Jump, ((sqInt)compareIntFloat));
	jmpTarget(jumpNotBoxedFloat, jmpTarget(jumpNotFloatAtAll, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
#  endif // defined(DPFPReg0)

	return CompletePrimitive;
}


/*	Get the literal count of a CompiledMethod into headerReg, plus one if
	requested. If inBytes is true, scale the count by the word size. Deal with
	the possibility of
	the method being cogged. */

	/* CogObjectRepresentationFor64BitSpur>>#getLiteralCountOf:plusOne:inBytes:into:scratch: */
static NoDbgRegParms sqInt
getLiteralCountOfplusOneinBytesintoscratch(sqInt methodReg, sqInt plusOne, sqInt inBytes, sqInt litCountReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	genGetMethodHeaderOfintoscratch(methodReg, litCountReg, scratchReg);
	assert((1U << (numTagBits())) == BytesPerWord);
	if (inBytes) {
		quickConstant = ((sqInt)((usqInt)((alternateHeaderNumLiteralsMask())) << (numTagBits())));

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, quickConstant, litCountReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
	}
	else {
		/* LogicalShiftRightCq:R: */
		genoperandoperand(LogicalShiftRightCqR, numTagBits(), litCountReg);
		quickConstant = alternateHeaderNumLiteralsMask();

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, quickConstant, litCountReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
	}
	if (plusOne) {
		quickConstant = (inBytes
					? LiteralStart * BytesPerWord
					: LiteralStart);

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, quickConstant, litCountReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
	}
	return 0;
}


/*	Answer the relevant inline cache tag for an instance.
	c.f. getInlineCacheClassTagFrom:into: & inlineCacheTagForClass: */

	/* CogObjectRepresentationFor64BitSpur>>#inlineCacheTagForInstance: */
static NoDbgRegParms sqInt
inlineCacheTagForInstance(sqInt oop)
{
	return (isImmediate(oop)
			? oop & (tagMask())
			: classIndexOf(oop));
}

	/* CogObjectRepresentationFor64BitSpur>>#log2BytesPerWord */
static sqInt
log2BytesPerWord(void)
{
	return 3;
}


/*	Generate the routine that converts selector indices into selector objects.
	It is called from the send trampolines.
	If the selector index is negative, convert it into a positive index into
	the special selectors array and index that. Otherwise, index the current
	method. The routine uses Extra0Reg & Extra1Reg, which are available, since
	they are not live at point of send. */

	/* CogObjectRepresentationFor64BitSpur>>#maybeGenerateSelectorIndexDereferenceRoutine */
static void
maybeGenerateSelectorIndexDereferenceRoutine(void)
{
    AbstractInstruction *anInstruction;
    sqInt byteOffset;
    AbstractInstruction *jumpFullBlock;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNotBlock;
    sqInt offset;
    sqInt quickConstant;

	zeroOpcodeIndex();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jumpNegative = genConditionalBranchoperand(JumpLess, ((sqInt)0));

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, FoxMethod, FPReg, Extra0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxMethod, BytesPerOop));
	}

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 2, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(2, BytesPerOop));
	}

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, MFMethodFlagIsBlockFlag, Extra0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(MFMethodFlagIsBlockFlag, BytesPerOop));
	}

	/* If in a block, need to find the home method...  If using full blocks, need to test the cpicHasMNUCaseOrCMIsFullBlock bit */
	jumpNotBlock = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	quickConstant = -(zoneAlignment());

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, Extra0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	byteOffset = BaseHeaderSize + 1;

	/* begin MoveMb:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMbrR, byteOffset, Extra0Reg, Extra1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(byteOffset, BytesPerOop));
	}

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, 16, Extra1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(16, BytesPerOop));
	}
	jumpFullBlock = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin MoveM16:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveM16rR, 0, Extra0Reg, Extra1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, Extra1Reg, Extra0Reg);
	jmpTarget(jumpNotBlock, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jmpTarget(jumpFullBlock, ((AbstractInstruction *) (((jumpNotBlock->operands))[0])));
	quickConstant = -(zoneAlignment());

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, Extra0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	offset = offsetof(CogMethod, methodObject);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, Extra0Reg, Extra1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, ClassReg, Extra1Reg, ClassReg);

	/* RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNegative, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* NegateR: */
	genoperand(NegateR, ClassReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 1, ClassReg);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(specialObjectsOopAddress(), genoperandoperand(MoveAwR, specialObjectsOopAddress(), Extra0Reg));

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	offset = (SpecialSelectors + 1) * BytesPerWord;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, Extra0Reg, Extra1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, ClassReg, Extra1Reg, ClassReg);

	/* RetN: */
	genoperand(RetN, 0);
	ceDereferenceSelectorIndex = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(ceDereferenceSelectorIndex);
	recordGeneratedRunTimeaddress("ceDereferenceSelectorIndex", ceDereferenceSelectorIndex);
	recordRunTimeObjectReferences();
}

	/* CogObjectRepresentationFor64BitSpur>>#numSmallIntegerBits */
static sqInt
numSmallIntegerBits(void)
{
	return 61;
}

	/* CogObjectRepresentationFor64BitSpur>>#numSmallIntegerTagBits */
static sqInt
numSmallIntegerTagBits(void)
{
	return 3;
}


/*	The three valid tag patterns are 1 (SmallInteger), 2 (Character) and 3
	(SmallFloat64). 
 */

	/* CogObjectRepresentationFor64BitSpur>>#validInlineCacheTag: */
static NoDbgRegParms sqInt
validInlineCacheTag(sqInt classIndexOrTagPattern)
{
	return ((classIndexOrTagPattern >= 1)
	 && (classIndexOrTagPattern <= 3))
	 || ((classAtIndex(classIndexOrTagPattern)));
}

	/* CogObjectRepresentationForSpur>>#callStoreCheckTrampoline */
static void
callStoreCheckTrampoline(void)
{
    AbstractInstruction *abstractInstruction;

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceStoreCheckTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
}

	/* CogObjectRepresentationForSpur>>#checkValidOopReference: */
static NoDbgRegParms sqInt
checkValidOopReference(sqInt anOop)
{
	return (isImmediate(anOop))
	 || ((heapMapAtWord(pointerForOop(anOop))) != 0);
}

	/* CogObjectRepresentationForSpur>>#couldBeObject: */
static NoDbgRegParms sqInt
couldBeObject(sqInt literal)
{
	return (isNonImmediate(literal))
	 && (oopisGreaterThanOrEqualTo(literal, startOfMemory()));
}


/*	Create a trampoline to answer the active context that will
	answer it if a frame is already married, and create it otherwise.
	Assume numArgs is in SendNumArgsReg and ClassReg is free. */

	/* CogObjectRepresentationForSpur>>#genActiveContextTrampolineLarge:inBlock:called: */
static NoDbgRegParms usqInt
genActiveContextTrampolineLargeinBlockcalled(sqInt isLarge, sqInt isInBlock, char *aString)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genGetActiveContextLargeinBlock(isLarge, isInBlock);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(aString, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Check the remembered bit of the object in objReg; answer the jump taken if
	the bit is already set.
	Only need to fetch the byte containing it, which reduces the size of the
	mask constant.
 */

	/* CogObjectRepresentationForSpur>>#genCheckRememberedBitOf:scratch: */
static NoDbgRegParms AbstractInstruction *
genCheckRememberedBitOfscratch(sqInt objReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt mask;
    sqInt rememberedBitByteOffset;

	rememberedBitByteOffset = (rememberedBitShift()) / 8;
	mask = 1ULL << ((rememberedBitShift()) % 8);

	/* begin MoveMb:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMbrR, rememberedBitByteOffset, objReg, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(rememberedBitByteOffset, BytesPerOop));
	}

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, mask, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(mask, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}

	/* CogObjectRepresentationForSpur>>#genConvertCharacterToCodeInReg: */
static NoDbgRegParms sqInt
genConvertCharacterToCodeInReg(sqInt reg)
{
	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, numTagBits(), reg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genConvertIntegerToCharacterInReg: */
static NoDbgRegParms sqInt
genConvertIntegerToCharacterInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, numTagBits(), reg);
	quickConstant = characterTag();

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return 0;
}


/*	Create a full closure with the given values. */

	/* CogObjectRepresentationForSpur>>#genCreateFullClosure:numArgs:numCopied:ignoreContext:contextNumArgs:large:inBlock: */
static NoDbgRegParms sqInt
genCreateFullClosurenumArgsnumCopiedignoreContextcontextNumArgslargeinBlock(sqInt compiledBlock, sqInt numArgs, sqInt numCopied, sqInt ignoreContext, sqInt contextNumArgs, sqInt contextIsLarge, sqInt contextIsBlock)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    usqInt byteSize;
    usqLong header;
    sqInt numSlots;
    sqInt offset;
    sqInt quickConstant;
    AbstractInstruction *skip;


	/* First get thisContext into ReceiverResultReg and thence in ClassReg. */
	if (ignoreContext) {
		/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, nilObject(), ClassReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
		}
	}
	else {
		genGetActiveContextNumArgslargeinBlock(contextNumArgs, contextIsLarge, contextIsBlock);

		/* MoveR:R: */
		genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	}
	numSlots = FullClosureFirstCopiedValueIndex + numCopied;
	byteSize = smallObjectBytesForSlots(numSlots);
	assert(ClassFullBlockClosureCompactIndex != 0);
	header = headerForSlotsformatclassIndex(numSlots, indexablePointersFormat(), ClassFullBlockClosureCompactIndex);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), ReceiverResultReg));

	/* begin genStoreHeader:intoNewInstance:using: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, header, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(header, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, byteSize, ReceiverResultReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(byteSize, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, TempReg, freeStartAddress()));
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	skip = genConditionalBranchoperand(JumpBelow, ((sqInt)0));

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	offset = (ClosureOuterContextIndex * BytesPerOop) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, ClassReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin genMoveConstant:R: */
	if (/* shouldAnnotateObjectReference: */
		(isNonImmediate(compiledBlock))
	 && ((oopisGreaterThan(compiledBlock, classTableRootObj()))
	 || (oopisLessThan(compiledBlock, nilObject())))) {
		annotateobjRef(checkLiteralforInstruction(compiledBlock, genoperandoperand(MoveCwR, compiledBlock, TempReg)), compiledBlock);
	}
	else {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, compiledBlock, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(compiledBlock, BytesPerOop));
		}
	}
	offset = (ClosureStartPCIndex * BytesPerOop) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, (((usqInt)numArgs << 3) | 1), TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)numArgs << 3) | 1), BytesPerOop));
	}
	offset = (ClosureNumArgsIndex * BytesPerOop) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	return 0;
}


/*	Make sure that the oop in reg is not forwarded. 
	Use the fact that isForwardedObjectClassIndexPun is a power of two to save
	an instruction. */
/*	maybe a fixup or an instruction */
/*	maybe a fixup or an instruction */

	/* CogObjectRepresentationForSpur>>#genEnsureOopInRegNotForwarded:scratchReg:ifForwarder:ifNotForwarder: */
static NoDbgRegParms sqInt
genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(sqInt reg, sqInt scratch, void *fwdJumpTarget, void *nonFwdJumpTargetOrZero)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *finished;
    AbstractInstruction *imm;
    AbstractInstruction *ok;
    sqInt quickConstant;

	assert(reg != scratch);

	/* notionally
	   self genGetClassIndexOfNonImm: reg into: scratch.
	   cogit CmpCq: objectMemory isForwardedObjectClassIndexPun R: TempReg.
	   but the following is an instruction shorter: */
	imm = genJumpImmediate(reg);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, reg, scratch);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratch);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, reg, reg);

	/* Jump: */
	genoperand(Jump, ((sqInt)fwdJumpTarget));
	finished = (((usqInt)nonFwdJumpTargetOrZero)
				? nonFwdJumpTargetOrZero
				: genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jmpTarget(imm, jmpTarget(ok, finished));
	return 0;
}


/*	Make sure that the oop in reg is not forwarded, updating the slot in
	objReg with the value.
 */

	/* CogObjectRepresentationForSpur>>#genEnsureOopInRegNotForwarded:scratchReg:updatingSlot:in: */
static NoDbgRegParms sqInt
genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(sqInt reg, sqInt scratch, sqInt index, sqInt objReg)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *imm;
    AbstractInstruction *inst;
    AbstractInstruction *loop;
    sqInt offset;
    AbstractInstruction *ok;
    sqInt quickConstant;


	/* Open-code
	   self genEnsureOopInRegNotForwarded: reg
	   scratchReg: scratch
	   updatingMw: index * objectMemory wordSize + objectMemory baseHeaderSize
	   r: objReg.
	   to avoid calling the store check unless the receiver is forwarded. */
	assert((reg != scratch)
	 && (objReg != scratch));
	loop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* notionally
	   self genGetClassIndexOfNonImm: reg into: scratch.
	   cogit CmpCq: objectMemory isForwardedObjectClassIndexPun R: TempReg.
	   but the following is an instruction shorter: */
	imm = genJumpImmediate(reg);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, reg, scratch);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratch);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, reg, reg);
	offset = (index * BytesPerWord) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, reg, offset, objReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	assert((reg == Arg0Reg)
	 && ((scratch == TempReg)
	 && (objReg == ReceiverResultReg)));
	if (needsFrame) {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceStoreCheckContextReceiverTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		backEnd;

		/* begin saveAndRestoreLinkRegAround: */
		inst = genoperand(PushR, LinkReg);
		abstractInstruction = genoperand(Call, ceStoreCheckContextReceiverTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);

		/* PopR: */
		genoperand(PopR, LinkReg);
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)loop));
	jmpTarget(ok, jmpTarget(imm, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}


/*	Do the store check. Answer the argument for the benefit of the code
	generator; ReceiverResultReg may be caller-saved and hence smashed by this
	call. Answering
	it allows the code generator to reload ReceiverResultReg cheaply.
	In Spur the only thing we leave to the run-time is adding the receiver to
	the remembered set and setting its isRemembered bit. */

	/* CogObjectRepresentationForSpur>>#generateObjectRepresentationTrampolines */
static void
generateObjectRepresentationTrampolines(void)
{
    sqInt instVarIndex;
    AbstractInstruction *jumpSC;


#  if IMMUTABILITY
	for (instVarIndex = 0; instVarIndex < NumStoreTrampolines; instVarIndex += 1) {
		ceStoreTrampolines[instVarIndex] = (genStoreTrampolineCalledinstVarIndex(trampolineNamenumArgslimit("ceStoreTrampoline", instVarIndex, NumStoreTrampolines - 2), instVarIndex));
	}
#  endif // IMMUTABILITY

	ceNewHashTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNewHashOf, "ceNewHash", 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, ReceiverResultReg, 0);
	ceInlineNewHashTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNewHashOf, "ceInlineNewHash", 1, ReceiverResultReg, null, null, null, ((CallerSavedRegisterMask | ((1U << ReceiverResultReg))) - ((1U << ReceiverResultReg))), 1, ReceiverResultReg, 0);

	/* begin genStoreCheckTrampoline */
	if (CheckRememberedInTrampoline) {
		zeroOpcodeIndex();
		jumpSC = genCheckRememberedBitOfscratch(ReceiverResultReg, ABIResultReg);
		assert(((jumpSC->opcode)) == JumpNonZero);
		(jumpSC->opcode = JumpZero);

		/* RetN: */
		genoperand(RetN, 0);
		jmpTarget(jumpSC, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	ceStoreCheckTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(remember, "ceStoreCheckTrampoline", 1, ReceiverResultReg, null, null, null, ((CallerSavedRegisterMask | ((1U << ReceiverResultReg))) - ((1U << ReceiverResultReg))), 1, /* returnRegForStoreCheck */
			(((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)
				? ReceiverResultReg
				: ABIResultReg), CheckRememberedInTrampoline);
	ceStoreCheckContextReceiverTrampoline = genStoreCheckContextReceiverTrampoline();
	ceScheduleScavengeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceScheduleScavenge, "ceScheduleScavengeTrampoline", 0, null, null, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
	ceSmallActiveContextInMethodTrampoline = genActiveContextTrampolineLargeinBlockcalled(0, 0, "ceSmallMethodContext");
	ceSmallActiveContextInBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(0, InVanillaBlock, "ceSmallBlockContext");
	ceSmallActiveContextInFullBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(0, InFullBlock, "ceSmallFullBlockContext");
	ceLargeActiveContextInMethodTrampoline = genActiveContextTrampolineLargeinBlockcalled(1, 0, "ceLargeMethodContext");
	ceLargeActiveContextInBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(1, InVanillaBlock, "ceLargeBlockContext");
	ceLargeActiveContextInFullBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(1, InFullBlock, "ceLargeFullBlockContext");
	generateLowcodeObjectTrampolines();
}


/*	Create a trampoline to answer the active context that will
	answer it if a frame is already married, and create it otherwise.
	Assume numArgs is in SendNumArgsReg and ClassReg is free. */

	/* CogObjectRepresentationForSpur>>#genGetActiveContextLarge:inBlock: */
static NoDbgRegParms sqInt
genGetActiveContextLargeinBlock(sqInt isLarge, sqInt isInBlock)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *continuation;
    AbstractInstruction *exit;
    usqLong header;
    AbstractInstruction *inst;
    AbstractInstruction *jumpNeedScavenge;
    AbstractInstruction *jumpSingle;
    AbstractInstruction *loopHead;
    sqInt offset;
    sqInt quickConstant;
    int slotSize;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, FoxMethod, FPReg, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxMethod, BytesPerOop));
	}

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, MFMethodFlagHasContextFlag, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(MFMethodFlagHasContextFlag, BytesPerOop));
	}

	/* jump if flag bit not set */
	jumpSingle = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, FoxThisContext, FPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxThisContext, BytesPerOop));
	}

	/* RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpSingle, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* begin OrCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(OrCqR, MFMethodFlagHasContextFlag, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(MFMethodFlagHasContextFlag, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, ClassReg, FoxMethod, FPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxMethod, BytesPerOop));
	}
	switch (isInBlock) {
	case InFullBlock:
		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, 3, ClassReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(3, BytesPerOop));
		}
		break;
	case InVanillaBlock:
		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, 3, ClassReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(3, BytesPerOop));
		}

		/* begin MoveM16:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM16rR, 0, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* SubR:R: */
		genoperandoperand(SubRR, TempReg, ClassReg);
		break;
	case 0:
		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, 1, ClassReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	slotSize = (isLarge
				? LargeContextSlots
				: SmallContextSlots);
	header = headerForSlotsformatclassIndex(slotSize, indexablePointersFormat(), ClassMethodContextCompactIndex);
	flag("endianness");

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), ReceiverResultReg));

	/* begin genStoreHeader:intoNewInstance:using: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, header, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(header, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	offset = smallObjectBytesForSlots(slotSize);

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, offset, ReceiverResultReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, TempReg, freeStartAddress()));
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* Now initialize the fields of the context.  See CoInterpreter>>marryFrame:SP:copyTemps: */
	/* sender gets frame pointer as a SmallInteger */
	jumpNeedScavenge = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* begin genSetSmallIntegerTagsIn:into: */
	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	continuation = genoperandoperandoperand(LoadEffectiveAddressMwrR, 1, FPReg, TempReg);
	if (usesOutOfLineLiteral(continuation)) {
		(continuation->dependent = locateLiteralsize(1, BytesPerOop));
	}
	offset = BaseHeaderSize + (SenderIndex * BytesPerOop);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, FoxSavedFP, FPReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxSavedFP, BytesPerOop));
	}
	genSetSmallIntegerTagsIn(TempReg);
	offset = BaseHeaderSize + (InstructionPointerIndex * BytesPerOop);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	offset = offsetof(CogMethod, methodObject);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	offset = BaseHeaderSize + (MethodIndex * BytesPerWord);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, FoxThisContext, FPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxThisContext, BytesPerOop));
	}
	gSubRRR(SPReg, FPReg, TempReg);

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, log2BytesPerWord(), TempReg);

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 3, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(3, BytesPerOop));
	}

	/* AddR:R: */
	genoperandoperand(AddRR, SendNumArgsReg, TempReg);
	genConvertIntegerToSmallIntegerInReg(TempReg);
	offset = BaseHeaderSize + (StackPointerIndex * BytesPerOop);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	if (isInBlock > 0) {
		/* begin LoadEffectiveAddressMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, 2, SendNumArgsReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(2, BytesPerOop));
		}

		/* MoveXwr:R:R: */
		genoperandoperandoperand(MoveXwrRR, TempReg, FPReg, TempReg);
	}
	else {
		/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, nilObject(), TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
		}
	}
	offset = BaseHeaderSize + (ClosureIndex * BytesPerOop);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, FoxMFReceiver, FPReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxMFReceiver, BytesPerOop));
	}
	offset = BaseHeaderSize + (ReceiverIndex * BytesPerOop);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 1, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!(0 /* (SendNumArgsReg = SPReg) */));
	loopHead = genoperandoperand(CmpRR, SendNumArgsReg, ClassReg);
	exit = genConditionalBranchoperand(JumpGreater, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, ClassReg, TempReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 2, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(2, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, TempReg, FPReg, TempReg);
	quickConstant = ReceiverIndex + (BaseHeaderSize / BytesPerWord);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, ClassReg, ReceiverResultReg);
	quickConstant = (ReceiverIndex + (BaseHeaderSize / BytesPerWord)) - 1;

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, quickConstant, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)loopHead));
	jmpTarget(exit, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, FoxMFReceiver, FPReg, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(FoxMFReceiver, BytesPerOop));
	}
	quickConstant = (ReceiverIndex + 1) + (BaseHeaderSize / BytesPerWord);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	loopHead = genoperandoperand(SubCqR, BytesPerWord, ClassReg);
	if (usesOutOfLineLiteral(loopHead)) {
		(loopHead->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!(0 /* (ClassReg = SPReg) */));
	genoperandoperand(CmpRR, ClassReg, SPReg);
	exit = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, SendNumArgsReg, ReceiverResultReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* Jump: */
	genoperand(Jump, ((sqInt)loopHead));
	jmpTarget(exit, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNeedScavenge, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	backEnd;

	/* begin saveAndRestoreLinkRegAround: */
	inst = genoperand(PushR, LinkReg);
	CallRTregistersToBeSavedMask(ceScheduleScavengeTrampoline, ((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg));

	/* PopR: */
	genoperand(PopR, LinkReg);

	/* Jump: */
	genoperand(Jump, ((sqInt)continuation));
	return 0;
}


/*	Get the active context into ReceiverResultReg, creating it if necessary. */

	/* CogObjectRepresentationForSpur>>#genGetActiveContextNumArgs:large:inBlock: */
static NoDbgRegParms sqInt
genGetActiveContextNumArgslargeinBlock(sqInt numArgs, sqInt isLargeContext, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt routine;

	if (isLargeContext) {
		switch (isInBlock) {
		case 0:
						routine = ceLargeActiveContextInMethodTrampoline;
			break;

		case InVanillaBlock:
						routine = ceLargeActiveContextInBlockTrampoline;
			break;

		case InFullBlock:
						routine = ceLargeActiveContextInFullBlockTrampoline;
			break;

		default:
			error("Case not found and no otherwise clause");
			routine = -1;
		}
	}
	else {
		switch (isInBlock) {
		case 0:
						routine = ceSmallActiveContextInMethodTrampoline;
			break;

		case InVanillaBlock:
						routine = ceSmallActiveContextInBlockTrampoline;
			break;

		case InFullBlock:
						routine = ceSmallActiveContextInFullBlockTrampoline;
			break;

		default:
			error("Case not found and no otherwise clause");
			routine = -1;
		}
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, numArgs, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(numArgs, BytesPerOop));
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, routine);
	(abstractInstruction->annotation = IsRelativeCall);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genGetBits:ofFormatByteOf:into: */
static NoDbgRegParms sqInt
genGetBitsofFormatByteOfinto(sqInt mask, sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	flag("endianness");

	/* begin MoveMb:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMbrR, 3, sourceReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(3, BytesPerOop));
	}

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, mask, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(mask, BytesPerOop));
	}
	return 0;
}


/*	Fetch the instance's class index into destReg. */

	/* CogObjectRepresentationForSpur>>#genGetClassIndexOfNonImm:into: */
static NoDbgRegParms sqInt
genGetClassIndexOfNonImminto(sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, sourceReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = classIndexMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return 0;
}


/*	Fetch the class object whose index is in instReg into destReg.
	It is non-obvious, but the Cogit assumes loading a class does not involve
	a runtime call, so do not call classAtIndex: */

	/* CogObjectRepresentationForSpur>>#genGetClassObjectOfClassIndex:into:scratchReg: */
static NoDbgRegParms sqInt
genGetClassObjectOfClassIndexintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt quickConstant;

	assert(instReg != destReg);
	assert(instReg != scratchReg);
	assert(destReg != scratchReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, instReg, scratchReg);

	/* LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, classTableMajorIndexShift(), scratchReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), scratchReg);
	assert(!(shouldAnnotateObjectReference(classTableRootObj())));
	offset = (classTableRootObj()) + BaseHeaderSize;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, scratchReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, instReg, scratchReg);
	quickConstant = classTableMinorIndexMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, scratchReg, destReg, destReg);
	return 0;
}


/*	Fetch the instance's class into destReg. If the instance is not the
	receiver and is forwarded, follow forwarding. */

	/* CogObjectRepresentationForSpur>>#genGetClassObjectOf:into:scratchReg:mayBeAForwarder: */
static NoDbgRegParms sqInt
genGetClassObjectOfintoscratchRegmayBeAForwarder(sqInt instReg, sqInt destReg, sqInt scratchReg, sqInt mayBeForwarder)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpIsImm;
    AbstractInstruction *jumpNotForwarded;
    AbstractInstruction *loop;
    sqInt quickConstant;

	if ((instReg == destReg)
	 || ((instReg == scratchReg)
	 || (destReg == scratchReg))) {
		return BadRegisterSet;
	}
	loop = genoperandoperand(MoveRR, instReg, scratchReg);
	quickConstant = tagMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsImm = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	flag("endianness");

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, instReg, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	quickConstant = classIndexMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	if (mayBeForwarder) {

		/* if it is forwarded... */
		quickConstant = isForwardedObjectClassIndexPun();

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, quickConstant, scratchReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}

		/* ...follow the forwarding pointer and loop to fetch its classIndex */
		jumpNotForwarded = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, instReg, instReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
		}

		/* Jump: */
		genoperand(Jump, ((sqInt)loop));
		jmpTarget(jumpNotForwarded, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	jmpTarget(jumpIsImm, genoperandoperand(MoveRR, scratchReg, destReg));
	if (scratchReg) {
		genGetClassObjectOfClassIndexintoscratchReg(destReg, scratchReg, TempReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, scratchReg, destReg);
	}
	else {
		/* PushR: */
		genoperand(PushR, instReg);
		genGetClassObjectOfClassIndexintoscratchReg(destReg, instReg, TempReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, instReg, destReg);

		/* PopR: */
		genoperand(PopR, instReg);
	}
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genGetClassTagOf:into:scratchReg: */
static NoDbgRegParms AbstractInstruction *
genGetClassTagOfintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
	return genGetInlineCacheClassTagFromintoforEntry(instReg, destReg, 1);
}


/*	Fetch the instance's class index into destReg. */

	/* CogObjectRepresentationForSpur>>#genGetCompactClassIndexNonImmOf:into: */
static NoDbgRegParms sqInt
genGetCompactClassIndexNonImmOfinto(sqInt instReg, sqInt destReg)
{
	return genGetClassIndexOfNonImminto(instReg, destReg);
}

	/* CogObjectRepresentationForSpur>>#genGetDoubleValueOf:into: */
static NoDbgRegParms sqInt
genGetDoubleValueOfinto(sqInt srcReg, sqInt destFPReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveM64:r:Rd: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveM64rRd, BaseHeaderSize, srcReg, destFPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	return 0;
}


/*	Get the format field of the object in srcReg into destReg.
	srcReg may equal destReg. */

	/* CogObjectRepresentationForSpur>>#genGetFormatOf:into: */
static NoDbgRegParms sqInt
genGetFormatOfinto(sqInt srcReg, sqInt destReg)
{
	return genGetBitsofFormatByteOfinto(formatMask(), srcReg, destReg);
}


/*	Get the format of the object in sourceReg into destReg. If
	scratchRegOrNone is not NoReg, load at least the least significant 32-bits
	(64-bits in 64-bits) of the
	header word, which contains the format, into scratchRegOrNone. */

	/* CogObjectRepresentationForSpur>>#genGetFormatOf:into:leastSignificantHalfOfBaseHeaderIntoScratch: */
static NoDbgRegParms sqInt
genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(sqInt sourceReg, sqInt destReg, sqInt scratchRegOrNone)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	if (scratchRegOrNone == NoReg) {
		flag("endianness");

		/* begin MoveMb:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMbrR, 3, sourceReg, destReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(3, BytesPerOop));
		}
	}
	else {
		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, sourceReg, scratchRegOrNone);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		gLogicalShiftRightCqRR(formatShift(), scratchRegOrNone, destReg);
	}
	quickConstant = formatMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return 0;
}


/*	Get the size in word-sized slots of the object in srcReg into destReg.
	srcReg may equal destReg. */

	/* CogObjectRepresentationForSpur>>#genGetNumSlotsOf:into: */
static NoDbgRegParms sqInt
genGetNumSlotsOfinto(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmp;
    sqInt quickConstant;

	assert(srcReg != destReg);
	genGetRawSlotSizeOfNonImminto(srcReg, destReg);
	quickConstant = numSlotsMask();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jmp = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genGetOverflowSlotsOfinto(srcReg, destReg);
	jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	The raw numSlots field is the most significant byte of the 64-bit header
	word. MoveMbrR zero-extends. */

	/* CogObjectRepresentationForSpur>>#genGetRawSlotSizeOfNonImm:into: */
static NoDbgRegParms sqInt
genGetRawSlotSizeOfNonImminto(sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;


	/* begin MoveMb:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMbrR, 7, sourceReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(7, BytesPerOop));
	}
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genJumpImmediate: */
static NoDbgRegParms AbstractInstruction *
genJumpImmediate(sqInt aRegister)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = tagMask();

	/* begin TstCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, aRegister);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}

	/* CogObjectRepresentationForSpur>>#genJumpImmutable:scratchReg: */
#if IMMUTABILITY
static NoDbgRegParms AbstractInstruction *
genJumpImmutablescratchReg(sqInt sourceReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, sourceReg, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin genJumpBaseHeaderImmutable: */
	quickConstant = immutableBitMask();
	anInstruction = genoperandoperand(TstCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}
#endif /* IMMUTABILITY */

	/* CogObjectRepresentationForSpur>>#genJumpMutable:scratchReg: */
#if IMMUTABILITY
static NoDbgRegParms AbstractInstruction *
genJumpMutablescratchReg(sqInt sourceReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, sourceReg, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin genJumpBaseHeaderMutable: */
	quickConstant = immutableBitMask();
	anInstruction = genoperandoperand(TstCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpZero, ((sqInt)0));
}
#endif /* IMMUTABILITY */

	/* CogObjectRepresentationForSpur>>#genLcFirstFieldPointer: */
static NoDbgRegParms void
genLcFirstFieldPointer(sqInt objectReg)
{
    AbstractInstruction *anInstruction;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 8, objectReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(8, BytesPerOop));
	}
	ssPushNativeRegister(objectReg);
}


/*	TODO: Retrieve the number of fixed fields. */

	/* CogObjectRepresentationForSpur>>#genLcFirstIndexableFieldPointer: */
static NoDbgRegParms void
genLcFirstIndexableFieldPointer(sqInt objectReg)
{
    AbstractInstruction *anInstruction;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 8, objectReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(8, BytesPerOop));
	}
	ssPushNativeRegister(objectReg);
}


/*	Check for integer */

	/* CogObjectRepresentationForSpur>>#genLcIsBytes:to: */
static NoDbgRegParms void
genLcIsBytesto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *cont;
    AbstractInstruction *falseTarget;
    AbstractInstruction *isCompiledMethod;
    AbstractInstruction *isImmediate;
    AbstractInstruction *isNotBytes;
    sqInt quickConstant;

	/* MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	quickConstant = tagMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* Get the format */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetFormatOfinto(objectReg, valueReg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	isNotBytes = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* True result */
	isCompiledMethod = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 1, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* False result */
	cont = genoperand(Jump, ((sqInt)0));
	falseTarget = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isImmediate, falseTarget);
	jmpTarget(isNotBytes, falseTarget);
	jmpTarget(isCompiledMethod, falseTarget);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushNativeRegister(valueReg);
}


/*	TODO: Implement this one */

	/* CogObjectRepresentationForSpur>>#genLcIsFloatObject:to: */
static NoDbgRegParms void
genLcIsFloatObjectto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 1, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	ssPushNativeRegister(valueReg);
}


/*	TODO: Implement this one */

	/* CogObjectRepresentationForSpur>>#genLcIsIndexable:to: */
static NoDbgRegParms void
genLcIsIndexableto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 1, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	ssPushNativeRegister(valueReg);
}


/*	Check for the immediate case */

	/* CogObjectRepresentationForSpur>>#genLcIsIntegerObject:to: */
static NoDbgRegParms void
genLcIsIntegerObjectto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *cont;
    AbstractInstruction *falseResult;
    AbstractInstruction *isImmediate;
    AbstractInstruction *isLargeNegativeInteger;
    AbstractInstruction *isLargePositiveInteger;
    sqInt quickConstant;
    AbstractInstruction *trueResult;

	/* MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	quickConstant = smallIntegerTag();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* Check the non-immediate case */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetClassIndexOfNonImminto(objectReg, TempReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassLargePositiveInteger, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassLargePositiveInteger, BytesPerOop));
	}
	isLargePositiveInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassLargeNegativeInteger, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassLargeNegativeInteger, BytesPerOop));
	}
	isLargeNegativeInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* XorR:R: */
	genoperandoperand(XorRR, valueReg, valueReg);

	/* True result */
	falseResult = genoperand(Jump, ((sqInt)0));
	trueResult = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isLargePositiveInteger, trueResult);
	jmpTarget(isLargeNegativeInteger, trueResult);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 1, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	cont = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(falseResult, cont);
	jmpTarget(isImmediate, cont);
	ssPushNativeRegister(valueReg);
}


/*	Check for immediate */

	/* CogObjectRepresentationForSpur>>#genLcIsPointers:to: */
static NoDbgRegParms void
genLcIsPointersto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *cont;
    AbstractInstruction *falseTarget;
    AbstractInstruction *isImmediate;
    AbstractInstruction *isNotPointers;
    sqInt quickConstant;

	/* MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	quickConstant = tagMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* Get the format */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetFormatOfinto(objectReg, valueReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 9, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(9, BytesPerOop));
	}

	/* True result */
	isNotPointers = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 1, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* False result */
	cont = genoperand(Jump, ((sqInt)0));
	falseTarget = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isImmediate, falseTarget);
	jmpTarget(isNotPointers, falseTarget);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushNativeRegister(valueReg);
}


/*	Check for immediate */

	/* CogObjectRepresentationForSpur>>#genLcIsWordsOrBytes:to: */
static NoDbgRegParms void
genLcIsWordsOrBytesto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *cont;
    AbstractInstruction *falseTarget;
    AbstractInstruction *isCompiledMethod;
    AbstractInstruction *isImmediate;
    AbstractInstruction *isNotBits;
    sqInt quickConstant;

	/* MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	quickConstant = tagMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* Get the format */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetFormatOfinto(objectReg, valueReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 9, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(9, BytesPerOop));
	}
	isNotBits = genConditionalBranchoperand(JumpLess, ((sqInt)0));

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 24, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(24, BytesPerOop));
	}

	/* True result */
	isCompiledMethod = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 1, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* False result */
	cont = genoperand(Jump, ((sqInt)0));
	falseTarget = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isImmediate, falseTarget);
	jmpTarget(isNotBits, falseTarget);
	jmpTarget(isCompiledMethod, falseTarget);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushNativeRegister(valueReg);
}


/*	Check for immediate */

	/* CogObjectRepresentationForSpur>>#genLcIsWords:to: */
static NoDbgRegParms void
genLcIsWordsto(sqInt objectReg, sqInt valueReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *cont;
    AbstractInstruction *falseTarget;
    AbstractInstruction *isAboveRange;
    AbstractInstruction *isBelowRange;
    AbstractInstruction *isImmediate;
    sqInt quickConstant;

	isAboveRange = ((AbstractInstruction *) 0);
	isBelowRange = ((AbstractInstruction *) 0);

	/* MoveR:R: */
	genoperandoperand(MoveRR, objectReg, valueReg);
	quickConstant = tagMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* Get the format */
	isImmediate = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetFormatOfinto(objectReg, valueReg);
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	isBelowRange = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	isAboveRange = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 1, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* False result */
	cont = genoperand(Jump, ((sqInt)0));
	falseTarget = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	jmpTarget(isImmediate, falseTarget);
	jmpTarget(isBelowRange, falseTarget);
	jmpTarget(isAboveRange, falseTarget);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, valueReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushNativeRegister(valueReg);
}

	/* CogObjectRepresentationForSpur>>#genLcLoadObject:at: */
static NoDbgRegParms void
genLcLoadObjectat(sqInt object, sqInt fieldIndex)
{
    AbstractInstruction *anInstruction;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 8, object);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(8, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, fieldIndex, object, object);
	ssPushRegister(object);
}

	/* CogObjectRepresentationForSpur>>#genLcLoadObject:field: */
static NoDbgRegParms void
genLcLoadObjectfield(sqInt object, sqInt fieldIndex)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	offset = BaseHeaderSize + (BytesPerOop * fieldIndex);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, object, object);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	ssPushRegister(object);
}

	/* CogObjectRepresentationForSpur>>#genLcStore:object:at: */
static NoDbgRegParms void
genLcStoreobjectat(sqInt value, sqInt object, sqInt fieldIndex)
{
    AbstractInstruction *anInstruction;

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 8, object);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(8, BytesPerOop));
	}

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, value, fieldIndex, object);
}

	/* CogObjectRepresentationForSpur>>#genLcStore:object:field: */
static NoDbgRegParms void
genLcStoreobjectfield(sqInt value, sqInt object, sqInt fieldIndex)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	offset = BaseHeaderSize + (fieldIndex * BytesPerOop);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, value, offset, object);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
}


/*	Generate a call to code that allocates a new Array of size.
	The Array should be initialized with nils iff initialize is true.
	The size arg is passed in SendNumArgsReg, the result
	must come back in ReceiverResultReg. */

	/* CogObjectRepresentationForSpur>>#genNewArrayOfSize:initialized: */
static NoDbgRegParms sqInt
genNewArrayOfSizeinitialized(sqInt size, sqInt initialize)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    usqLong header;
    sqInt i;
    sqInt offset;
    sqInt quickConstant;
    AbstractInstruction *skip;

	assert(size < (numSlotsMask()));
	header = headerForSlotsformatclassIndex(size, arrayFormat(), ClassArrayCompactIndex);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), ReceiverResultReg));

	/* begin genStoreHeader:intoNewInstance:using: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, header, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(header, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	if (initialize
	 && (size > 0)) {
		/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, nilObject(), TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
		}
		for (i = 0; i < size; i += 1) {
			offset = (i * BytesPerWord) + BaseHeaderSize;

			/* begin MoveR:Mw:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
		}
	}
	offset = smallObjectBytesForSlots(size);

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, offset, ReceiverResultReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, TempReg, freeStartAddress()));
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	skip = genConditionalBranchoperand(JumpBelow, ((sqInt)0));

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	Create a closure with the given startpc, numArgs and numCopied
	within a context with ctxtNumArgs, large if isLargeCtxt that is in a
	block if isInBlock. Do /not/ initialize the copied values. */

	/* CogObjectRepresentationForSpur>>#genNoPopCreateClosureAt:numArgs:numCopied:contextNumArgs:large:inBlock: */
static NoDbgRegParms sqInt
genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    usqInt byteSize;
    usqLong header;
    sqInt numSlots;
    sqInt offset;
    sqInt quickConstant;
    AbstractInstruction *skip;


	/* First get thisContext into ReceiverResultRega and thence in ClassReg. */
	genGetActiveContextNumArgslargeinBlock(ctxtNumArgs, isLargeCtxt, isInBlock);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	numSlots = ClosureFirstCopiedValueIndex + numCopied;
	byteSize = smallObjectBytesForSlots(numSlots);
	header = headerForSlotsformatclassIndex(numSlots, indexablePointersFormat(), ClassBlockClosureCompactIndex);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), ReceiverResultReg));

	/* begin genStoreHeader:intoNewInstance:using: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, header, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(header, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, byteSize, ReceiverResultReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(byteSize, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, TempReg, freeStartAddress()));
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	skip = genConditionalBranchoperand(JumpBelow, ((sqInt)0));

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	offset = (ClosureOuterContextIndex * BytesPerOop) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, ClassReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, (((usqInt)bcpc << 3) | 1), TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)bcpc << 3) | 1), BytesPerOop));
	}
	offset = (ClosureStartPCIndex * BytesPerOop) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, (((usqInt)numArgs << 3) | 1), TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)numArgs << 3) | 1), BytesPerOop));
	}
	offset = (ClosureNumArgsIndex * BytesPerOop) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveAsCharacter */
static sqInt
genPrimitiveAsCharacter(void)
{
    AbstractInstruction *jumpNotInt;
    AbstractInstruction *jumpOutOfRange;
    sqInt reg;

	jumpNotInt = ((AbstractInstruction *) 0);
	if (methodOrBlockNumArgs) {
		if (methodOrBlockNumArgs > 1) {
			return UnimplementedPrimitive;
		}
		reg = Arg0Reg;
		jumpNotInt = genJumpNotSmallInteger(reg);
	}
	else {
		reg = ReceiverResultReg;
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	jumpOutOfRange = jumpNotCharacterUnsignedValueInRegister(TempReg);
	genConvertSmallIntegerToCharacterInReg(reg);
	if (reg != ReceiverResultReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, reg, ReceiverResultReg);
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOutOfRange, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (reg != ReceiverResultReg) {
		jmpTarget(jumpNotInt, ((AbstractInstruction *) (((jumpOutOfRange->operands))[0])));
	}
	return CompletePrimitive;
}


/*	Generate primitive 60, at: with unsigned access for pure bits classes. */

	/* CogObjectRepresentationForSpur>>#genPrimitiveAt */
static sqInt
genPrimitiveAt(void)
{
	return genPrimitiveAtSigned(0);
}


/*	Generate primitive 61, at:put: with unsigned access for pure bits classes. */

	/* CogObjectRepresentationForSpur>>#genPrimitiveAtPut */
static sqInt
genPrimitiveAtPut(void)
{
	return genPrimitiveAtPutSigned(0);
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveIdenticalOrNotIf: */
static NoDbgRegParms sqInt
genPrimitiveIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *comp;
    AbstractInstruction *jumpCmp;

	/* begin CmpR:R: */
	assert(!(0 /* (Arg0Reg = SPReg) */));
	comp = genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	if (orNot) {
		jumpCmp = genConditionalBranchoperand(JumpZero, ((sqInt)0));

		/* genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(Arg0Reg, TempReg, comp, 0);
	}
	else {
		jumpCmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	}

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, trueObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(trueObject(), BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (!orNot) {
		/* genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(Arg0Reg, TempReg, comp, 0);
	}

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
	}

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}


/*	Generate primitive 164, at: with signed access for pure bits classes. */

	/* CogObjectRepresentationForSpur>>#genPrimitiveIntegerAt */
static sqInt
genPrimitiveIntegerAt(void)
{
	return genPrimitiveAtSigned(1);
}


/*	Generate primitive 165, at:put: with signed access for pure bits classes. */

	/* CogObjectRepresentationForSpur>>#genPrimitiveIntegerAtPut */
static sqInt
genPrimitiveIntegerAtPut(void)
{
	return genPrimitiveAtPutSigned(1);
}


/*	<returnTypeC: #'AbstractInstruction *'> */

	/* CogObjectRepresentationForSpur>>#genPrimitiveMakePoint */
static sqInt
genPrimitiveMakePoint(void)
{
    sqInt allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    usqLong newPointHeader;
    sqInt offset;
    sqInt quickConstant;
    sqInt resultReg;
    sqInt scratchReg;

	resultReg = ClassReg;

	/* <var: #jumpFail type: #'AbstractInstruction *'> */
	scratchReg = SendNumArgsReg;
	allocSize = BaseHeaderSize + (BytesPerWord * 2);
	newPointHeader = headerForSlotsformatclassIndex(2, nonIndexablePointerFormat(), ClassPointCompactIndex);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), resultReg));

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(allocSize, BytesPerOop));
	}
	quickConstant = getScavengeThreshold();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpFail = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, scratchReg, freeStartAddress()));

	/* begin genStoreHeader:intoNewInstance:using: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, newPointHeader, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(newPointHeader, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, scratchReg, 0, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, BaseHeaderSize, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	offset = BaseHeaderSize + BytesPerWord;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, Arg0Reg, offset, resultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* MoveR:R: */
	genoperandoperand(MoveRR, resultReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveObjectAt */
static sqInt
genPrimitiveObjectAt(void)
{
    AbstractInstruction *anInstruction;
    sqInt headerReg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBounds;
    AbstractInstruction *jumpNotHeaderIndex;
    sqInt quickConstant;

	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genGetMethodHeaderOfintoscratch(ReceiverResultReg, (headerReg = Arg1Reg), TempReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)1 << 3) | 1), Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)1 << 3) | 1), BytesPerOop));
	}
	jumpNotHeaderIndex = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, headerReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotHeaderIndex, gAndCqR((((usqInt)(alternateHeaderNumLiteralsMask()) << 3) | 1), headerReg));
	quickConstant = ((((usqInt)1 << 3) | 1)) - (smallIntegerTag());

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!((headerReg == SPReg)));
	genoperandoperand(CmpRR, headerReg, Arg0Reg);
	jumpBounds = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	quickConstant = ((usqInt)(BaseHeaderSize)) >> (shiftForWord());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, Arg0Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg0Reg, ReceiverResultReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpBounds, gAddCqR(((((usqInt)1 << 3) | 1)) - (smallIntegerTag()), Arg0Reg));
	jmpTarget(jumpBadIndex, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	c.f. StackInterpreter>>stSizeOf: lengthOf:baseHeader:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationForSpur>>#genPrimitiveSize */
static sqInt
genPrimitiveSize(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jump32BitLongsDone;
    AbstractInstruction *jump64BitLongsDone;
    AbstractInstruction *jumpArrayDone;
    AbstractInstruction *jumpBytesDone;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImm;
    AbstractInstruction *jumpIs32BitLongs;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsContext1;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpNotIndexable1;
    AbstractInstruction *jumpShortsDone;
    sqInt quickConstant;

	jumpImm = genJumpImmediate(ReceiverResultReg);

	/* begin genGetSizeOf:into:formatReg:scratchReg:abortJumpsInto: */
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, SendNumArgsReg, TempReg);
	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsBytes = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	quickConstant = arrayFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpArrayDone = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	jumpNotIndexable1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	quickConstant = weakArrayFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpHasFixedFields = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	quickConstant = firstShortFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIsShorts = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	quickConstant = firstLongFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIs32BitLongs = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	quickConstant = sixtyFourBitIndexableFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jump64BitLongsDone = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	jmpTarget(jumpNotIndexable1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpNotIndexable1 = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsBytes, genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), ClassReg));

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, BytesPerWord - 1, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord - 1, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jumpBytesDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, ClassReg));
	quickConstant = (((usqInt)(BytesPerWord)) >> 1) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jumpShortsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIs32BitLongs, gLogicalShiftLeftCqR((shiftForWord()) - 2, ClassReg));
	quickConstant = (((usqInt)(BytesPerWord)) >> 2) - 1;

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);

	/* formatReg contains fmt, now up for grabs.
	   destReg contains numSlots, precious.
	   sourceReg must be preserved */
	jump32BitLongsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasFixedFields, gAndCqR(classIndexMask(), TempReg));

	/* MoveR:R: */
	genoperandoperand(MoveRR, TempReg, SendNumArgsReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassMethodContextCompactIndex, BytesPerOop));
	}
	jumpIsContext1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(SendNumArgsReg, Extra0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Extra0Reg, SendNumArgsReg);
	genConvertSmallIntegerToIntegerInReg(SendNumArgsReg);
	quickConstant = fixedFieldsOfClassFormatMask();

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jmpTarget(jumpArrayDone, jmpTarget(jump64BitLongsDone, jmpTarget(jump32BitLongsDone, jmpTarget(jumpShortsDone, jmpTarget(jumpBytesDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	jumpNotIndexable = jumpNotIndexable1;
	jumpIsContext = jumpIsContext1;
	genConvertIntegerInRegtoSmallIntegerInReg(ClassReg, ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpImm, jmpTarget(jumpNotIndexable, jmpTarget(jumpIsContext, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return CompletePrimitive;
}


/*	primitiveCompareWith: */

	/* CogObjectRepresentationForSpur>>#genPrimitiveStringCompareWith */
static sqInt
genPrimitiveStringCompareWith(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *instr;
    AbstractInstruction *jump;
    AbstractInstruction *jumpAbove;
    AbstractInstruction *jumpIncorrectFormat1;
    AbstractInstruction *jumpIncorrectFormat2;
    AbstractInstruction *jumpIncorrectFormat3;
    AbstractInstruction *jumpIncorrectFormat4;
    AbstractInstruction *jumpMidFailure;
    AbstractInstruction *jumpSuccess;
    sqInt minSizeReg;
    sqInt quickConstant;
    sqInt string1CharOrByteSizeReg;
    sqInt string1Reg;
    sqInt string2CharOrByteSizeReg;
    sqInt string2Reg;


	/* I redefine those name to ease program comprehension */
	string1Reg = ReceiverResultReg;
	string2Reg = Arg0Reg;
	string1CharOrByteSizeReg = Arg1Reg;
	string2CharOrByteSizeReg = ClassReg;

	/* Load arguments in reg */
	minSizeReg = SendNumArgsReg;
	genGetFormatOfinto(string1Reg, TempReg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIncorrectFormat1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIncorrectFormat2 = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	genGetNumSlotsOfinto(string1Reg, string1CharOrByteSizeReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), string1CharOrByteSizeReg);
	gAndCqRR(BytesPerWord - 1, TempReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, TempReg, string1CharOrByteSizeReg);
	genGetFormatOfinto(string2Reg, TempReg);
	quickConstant = firstByteFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIncorrectFormat3 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpIncorrectFormat4 = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	genGetNumSlotsOfinto(string2Reg, string2CharOrByteSizeReg);

	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), string2CharOrByteSizeReg);
	gAndCqRR(BytesPerWord - 1, TempReg, TempReg);

	/* SubR:R: */
	genoperandoperand(SubRR, TempReg, string2CharOrByteSizeReg);

	/* begin CmpR:R: */
	assert(!((string1CharOrByteSizeReg == SPReg)));
	genoperandoperand(CmpRR, string1CharOrByteSizeReg, string2CharOrByteSizeReg);
	jumpAbove = genConditionalBranchoperand(JumpBelow, ((sqInt)0));

	/* MoveR:R: */
	genoperandoperand(MoveRR, string1CharOrByteSizeReg, minSizeReg);
	jump = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpAbove, genoperandoperand(MoveRR, string2CharOrByteSizeReg, minSizeReg));
	jmpTarget(jump, gCmpCqR(0, minSizeReg));

	/* if one of the string is empty, no need to go through the comparing loop */
	/* Compare the bytes */
	jumpSuccess = genConditionalBranchoperand(JumpZero, ((sqInt)0));

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, BaseHeaderSize, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BaseHeaderSize, minSizeReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BaseHeaderSize, BytesPerOop));
	}
	instr = genoperandoperandoperand(MoveXbrRR, TempReg, string1Reg, string1CharOrByteSizeReg);

	/* MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, TempReg, string2Reg, string2CharOrByteSizeReg);

	/* SubR:R: */
	genoperandoperand(SubRR, string2CharOrByteSizeReg, string1CharOrByteSizeReg);

	/* the 2 compared characters are different, exit the loop */
	jumpMidFailure = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, 1, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* begin CmpR:R: */
	assert(!(0 /* (TempReg = SPReg) */));
	genoperandoperand(CmpRR, TempReg, minSizeReg);

	/* JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)instr));
	genGetNumBytesOfinto(string1Reg, string1CharOrByteSizeReg);
	genGetNumBytesOfinto(string2Reg, string2CharOrByteSizeReg);
	jmpTarget(jumpSuccess, genoperandoperand(SubRR, string2CharOrByteSizeReg, string1CharOrByteSizeReg));
	jmpTarget(jumpMidFailure, genoperandoperand(MoveRR, string1CharOrByteSizeReg, ReceiverResultReg));
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);

	/* genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpIncorrectFormat4, jmpTarget(jumpIncorrectFormat3, jmpTarget(jumpIncorrectFormat2, jmpTarget(jumpIncorrectFormat1, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	return CompletePrimitive;
}


/*	replaceFrom: start to: stop with: replacement startingAt: repStart. 
	
	The primitive in the JIT tries to deal with two pathological cases, copy
	of arrays and byteStrings,
	which often copies only a dozen of fields and where switching to the C
	runtime cost a lot.
	
	Based on heuristics on the method class, I generate a quick array path
	(typically for Array),
	a quick byteString path (typically for ByteString, ByteArray and
	LargeInteger) or no quick 
	path at all (Typically for Bitmap).
	
	The many tests to ensure that the primitive won't fail are not super
	optimised (multiple reloading
	or stack arguments in registers) but this is still good enough and worth
	it since we're avoiding 
	the Smalltalk to C stack switch. The tight copying loops are optimised. 
	
	It is possible to build a bigger version with the 2 different paths but I
	(Clement) believe this 
	is too big machine code wise to be worth it.
 */

	/* CogObjectRepresentationForSpur>>#genPrimitiveStringReplace */
static sqInt
genPrimitiveStringReplace(void)
{
    sqInt adjust;
    AbstractInstruction *anInstruction;
    sqInt arrayReg;
    AbstractInstruction *inst;
    AbstractInstruction *instr;
    AbstractInstruction *jmpAlreadyRemembered;
    AbstractInstruction *jmpDestYoung;
    AbstractInstruction *jumpEmpty;
    AbstractInstruction *jumpImm;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpIncorrectFormat1;
    AbstractInstruction *jumpIncorrectFormat2;
    AbstractInstruction *jumpIncorrectFormat3;
    AbstractInstruction *jumpIncorrectFormat4;
    AbstractInstruction *jumpNotSmi1;
    AbstractInstruction *jumpNotSmi2;
    AbstractInstruction *jumpNotSmi3;
    AbstractInstruction *jumpOutOfBounds1;
    AbstractInstruction *jumpOutOfBounds2;
    AbstractInstruction *jumpOutOfBounds3;
    AbstractInstruction *jumpOutOfBounds4;
    sqInt offset;
    sqInt quickConstant;
    sqInt replReg;
    sqInt repStartReg;
    sqInt result;
    sqInt startReg;
    sqInt stopReg;


	/* Can I generate a quick path for this method ? */
	jumpOutOfBounds3 = ((AbstractInstruction *) 0);
	jumpOutOfBounds4 = ((AbstractInstruction *) 0);
	if (!((maybeMethodClassOfseemsToBeInstantiating(methodObj, arrayFormat()))
		 || (maybeMethodClassOfseemsToBeInstantiating(methodObj, firstByteFormat())))) {
		return UnimplementedPrimitive;
	}
	arrayReg = ReceiverResultReg;
	startReg = Arg0Reg;
	stopReg = Arg1Reg;
	replReg = ClassReg;

	/* Load arguments in reg */
	repStartReg = SendNumArgsReg;

	/* begin genStackArgAt:into: */
	offset = (0) * BytesPerWord;
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, repStartReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin genStackArgAt:into: */
	offset = (1) * BytesPerWord;
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, replReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin genStackArgAt:into: */
	offset = (2) * BytesPerWord;
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, stopReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin genStackArgAt:into: */
	offset = (3) * BytesPerWord;
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, startReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	jumpNotSmi1 = genJumpNotSmallInteger(repStartReg);
	jumpNotSmi2 = genJumpNotSmallInteger(stopReg);

	/* repl non immediate or fail the primitive */
	jumpNotSmi3 = genJumpNotSmallInteger(startReg);

	/* if start>stop primitive success */
	jumpImm = genJumpImmediate(replReg);

	/* begin CmpR:R: */
	assert(!((startReg == SPReg)));
	genoperandoperand(CmpRR, startReg, stopReg);

	/* If receiver immutable fail the primitive */
	jumpEmpty = genConditionalBranchoperand(JumpLess, ((sqInt)0));
#  if IMMUTABILITY
	jumpImmutable = genJumpImmutablescratchReg(ReceiverResultReg, TempReg);
#  endif


	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)0 << 3) | 1), startReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)0 << 3) | 1), BytesPerOop));
	}

	/* 0 >= replStart, fail */
	jumpOutOfBounds1 = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)0 << 3) | 1), repStartReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)0 << 3) | 1), BytesPerOop));
	}

	/* --- Pointer object version --- */
	jumpOutOfBounds2 = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	if (maybeMethodClassOfseemsToBeInstantiating(methodObj, arrayFormat())) {

		/* Are they both array format ? */
		genGetFormatOfinto(arrayReg, TempReg);
		genGetFormatOfinto(replReg, startReg);
		quickConstant = arrayFormat();

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, quickConstant, startReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		jumpIncorrectFormat1 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		quickConstant = arrayFormat();

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}

		/* Both objects are arrays, */
		jumpIncorrectFormat2 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		genGetNumSlotsOfinto(arrayReg, TempReg);
		genConvertSmallIntegerToIntegerInReg(stopReg);

		/* begin CmpR:R: */
		assert(!(0 /* (TempReg = SPReg) */));
		genoperandoperand(CmpRR, TempReg, stopReg);

		/* rep size < repStart - start + stop */
		jumpOutOfBounds3 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
		genGetNumSlotsOfinto(replReg, TempReg);

		/* begin genStackArgAt:into: */
		offset = (3) * BytesPerWord;
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, startReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		genConvertSmallIntegerToIntegerInReg(startReg);
		genConvertSmallIntegerToIntegerInReg(repStartReg);

		/* SubR:R: */
		genoperandoperand(SubRR, startReg, stopReg);

		/* AddR:R: */
		genoperandoperand(AddRR, repStartReg, stopReg);

		/* begin CmpR:R: */
		assert(!(0 /* (TempReg = SPReg) */));
		genoperandoperand(CmpRR, TempReg, stopReg);

		/* Everything in bounds */
		/* PossibleRemembered object */
		jumpOutOfBounds4 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));

		/* #MoveCw:R: #gen:literal:operand: */
		checkLiteralforInstruction(storeCheckBoundary(), genoperandoperand(MoveCwR, storeCheckBoundary(), TempReg));

		/* begin CmpR:R: */
		assert(!(0 /* (TempReg = SPReg) */));
		genoperandoperand(CmpRR, TempReg, arrayReg);
		jmpDestYoung = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
		jmpAlreadyRemembered = genCheckRememberedBitOfscratch(arrayReg, TempReg);
		backEnd;

		/* begin saveAndRestoreLinkRegAround: */
		inst = genoperand(PushR, LinkReg);
		callStoreCheckTrampoline();

		/* PopR: */
		genoperand(PopR, LinkReg);
		jmpTarget(jmpDestYoung, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jmpTarget(jmpAlreadyRemembered, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin genStackArgAt:into: */
		offset = (2) * BytesPerWord;
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, stopReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		genConvertSmallIntegerToIntegerInReg(stopReg);

		/* SubR:R: */
		genoperandoperand(SubRR, startReg, repStartReg);

		/* LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), repStartReg);

		/* AddR:R: */
		genoperandoperand(AddRR, repStartReg, replReg);
		adjust = (((usqInt)(BaseHeaderSize)) >> (shiftForWord())) - 1;
		if (adjust) {
			/* begin AddCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(AddCqR, adjust, startReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(adjust, BytesPerOop));
			}

			/* begin AddCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(AddCqR, adjust, stopReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(adjust, BytesPerOop));
			}
		}
		instr = genoperandoperandoperand(MoveXwrRR, startReg, replReg, TempReg);

		/* MoveR:Xwr:R: */
		genoperandoperandoperand(MoveRXwrR, TempReg, startReg, arrayReg);

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, 1, startReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* begin CmpR:R: */
		assert(!((startReg == SPReg)));
		genoperandoperand(CmpRR, startReg, stopReg);

		/* JumpAboveOrEqual: */
		genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)instr));
		jmpTarget(jumpEmpty, /* genPrimReturn */
			(methodOrBlockNumArgs <= (numRegArgs())
				? genoperand(RetN, 0)
				: genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord)));
		jmpTarget(jumpIncorrectFormat1, jmpTarget(jumpIncorrectFormat2, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	}
	if (maybeMethodClassOfseemsToBeInstantiating(methodObj, firstByteFormat())) {

		/* Are they both byte array format ? CompiledMethod excluded */
		genGetFormatOfinto(arrayReg, TempReg);
		genGetFormatOfinto(replReg, repStartReg);
		quickConstant = firstByteFormat();

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, quickConstant, repStartReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		jumpIncorrectFormat1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
		quickConstant = firstCompiledMethodFormat();

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, quickConstant, repStartReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		jumpIncorrectFormat2 = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
		quickConstant = firstByteFormat();

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		jumpIncorrectFormat3 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
		quickConstant = firstCompiledMethodFormat();

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}

		/* Both objects are byte arrays */
		jumpIncorrectFormat4 = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
		genGetNumSlotsOfinto(arrayReg, startReg);

		/* LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), startReg);
		gAndCqRR(BytesPerWord - 1, TempReg, TempReg);

		/* SubR:R: */
		genoperandoperand(SubRR, TempReg, startReg);
		genConvertSmallIntegerToIntegerInReg(stopReg);

		/* begin CmpR:R: */
		assert(!((startReg == SPReg)));
		genoperandoperand(CmpRR, startReg, stopReg);

		/* rep size < repStart - start + stop */
		jumpOutOfBounds3 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));

		/* MoveR:R: */
		genoperandoperand(MoveRR, repStartReg, TempReg);

		/* begin genStackArgAt:into: */
		offset = (0) * BytesPerWord;
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, repStartReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}

		/* begin genStackArgAt:into: */
		offset = (3) * BytesPerWord;
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, startReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		genConvertSmallIntegerToIntegerInReg(startReg);
		genConvertSmallIntegerToIntegerInReg(repStartReg);

		/* SubR:R: */
		genoperandoperand(SubRR, startReg, stopReg);

		/* AddR:R: */
		genoperandoperand(AddRR, repStartReg, stopReg);
		genGetNumSlotsOfinto(replReg, startReg);

		/* LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), startReg);
		gAndCqRR(BytesPerWord - 1, TempReg, TempReg);

		/* SubR:R: */
		genoperandoperand(SubRR, TempReg, startReg);

		/* begin CmpR:R: */
		assert(!((startReg == SPReg)));
		genoperandoperand(CmpRR, startReg, stopReg);

		/* Everything in bounds */
		/* Copy the bytes */
		jumpOutOfBounds4 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));

		/* begin genStackArgAt:into: */
		offset = (3) * BytesPerWord;
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, startReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		genConvertSmallIntegerToIntegerInReg(startReg);

		/* begin genStackArgAt:into: */
		offset = (2) * BytesPerWord;
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, stopReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		genConvertSmallIntegerToIntegerInReg(stopReg);

		/* SubR:R: */
		genoperandoperand(SubRR, startReg, repStartReg);

		/* AddR:R: */
		genoperandoperand(AddRR, repStartReg, replReg);
		adjust = BaseHeaderSize - 1;
		if (adjust) {
			/* begin AddCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(AddCqR, adjust, startReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(adjust, BytesPerOop));
			}

			/* begin AddCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(AddCqR, adjust, stopReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(adjust, BytesPerOop));
			}
		}
		instr = genoperandoperandoperand(MoveXbrRR, startReg, replReg, TempReg);

		/* MoveR:Xbr:R: */
		genoperandoperandoperand(MoveRXbrR, TempReg, startReg, arrayReg);

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, 1, startReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* begin CmpR:R: */
		assert(!((startReg == SPReg)));
		genoperandoperand(CmpRR, startReg, stopReg);

		/* JumpAboveOrEqual: */
		genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)instr));
		jmpTarget(jumpEmpty, /* genPrimReturn */
			(methodOrBlockNumArgs <= (numRegArgs())
				? genoperand(RetN, 0)
				: genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord)));
		jmpTarget(jumpIncorrectFormat4, jmpTarget(jumpIncorrectFormat3, jmpTarget(jumpIncorrectFormat2, jmpTarget(jumpIncorrectFormat1, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	}
	if (((result = compileInterpreterPrimitive())) < 0) {
		return result;
	}
	jmpTarget(jumpImm, jmpTarget(jumpNotSmi1, jmpTarget(jumpNotSmi2, jmpTarget(jumpNotSmi3, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	jmpTarget(jumpOutOfBounds1, jmpTarget(jumpOutOfBounds2, jmpTarget(jumpOutOfBounds3, jmpTarget(jumpOutOfBounds4, ((AbstractInstruction *) (((jumpImm->operands))[0]))))));
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, ((AbstractInstruction *) (((jumpImm->operands))[0])));
#  endif

	return CompletePrimitive;
}

	/* CogObjectRepresentationForSpur>>#genSetSmallIntegerTagsIn: */
static NoDbgRegParms sqInt
genSetSmallIntegerTagsIn(sqInt scratchReg)
{
    AbstractInstruction *anInstruction;

	/* begin OrCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(OrCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	return 0;
}


/*	Create a trampoline to store-check the update of the receiver in a
	closure's outerContext in compileBlockFrameBuild:. */

	/* CogObjectRepresentationForSpur>>#genStoreCheckContextReceiverTrampoline */
static usqInt
genStoreCheckContextReceiverTrampoline(void)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genStoreCheckReceiverRegvalueRegscratchReginFrame(ReceiverResultReg, Arg0Reg, TempReg, 0);

	/* RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceStoreCheckContextReceiver", startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate the code for a store check of valueReg into destReg. */

	/* CogObjectRepresentationForSpur>>#genStoreCheckReceiverReg:valueReg:scratchReg:inFrame: */
static NoDbgRegParms sqInt
genStoreCheckReceiverRegvalueRegscratchReginFrame(sqInt destReg, sqInt valueReg, sqInt scratchReg, sqInt inFrame)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *inst;
    AbstractInstruction *jmpAlreadyRemembered;
    AbstractInstruction *jmpDestYoung;
    AbstractInstruction *jmpImmediate;
    AbstractInstruction *jmpSourceOld;


	/* Is value stored an immediate?  If so we're done */
	jmpAlreadyRemembered = ((AbstractInstruction *) 0);

	/* Get the old/new boundary in scratchReg */
	jmpImmediate = genJumpImmediate(valueReg);

	/* #MoveCw:R: #gen:literal:operand: */
	checkLiteralforInstruction(storeCheckBoundary(), genoperandoperand(MoveCwR, storeCheckBoundary(), scratchReg));

	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, destReg);

	/* Is value stored old?  If so we're done. */
	jmpDestYoung = genConditionalBranchoperand(JumpBelow, ((sqInt)0));

	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, valueReg);

	/* value is young and target is old.
	   Need to remember this only if the remembered bit is not already set. */
	jmpSourceOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	if (!CheckRememberedInTrampoline) {
		jmpAlreadyRemembered = genCheckRememberedBitOfscratch(destReg, scratchReg);
	}
	assert(destReg == ReceiverResultReg);

	/* begin evaluateTrampolineCallBlock:protectLinkRegIfNot: */
	if (inFrame) {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceStoreCheckTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* begin saveAndRestoreLinkRegAround: */
		inst = genoperand(PushR, LinkReg);
		abstractInstruction = genoperand(Call, ceStoreCheckTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);

		/* PopR: */
		genoperand(PopR, LinkReg);
	}
	jmpTarget(jmpImmediate, jmpTarget(jmpDestYoung, jmpTarget(jmpSourceOld, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	if (!CheckRememberedInTrampoline) {
		jmpTarget(jmpAlreadyRemembered, ((AbstractInstruction *) (((jmpSourceOld->operands))[0])));
	}
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genStoreSourceReg:slotIndex:destReg:scratchReg:inFrame:needsStoreCheck: */
static NoDbgRegParms sqInt
genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt inFrame, sqInt needsStoreCheck)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt offset;

	/* begin genTraceStores */
	if (traceStores > 0) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, TempReg);

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	offset = (index * BytesPerWord) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	if (needsStoreCheck) {
		return genStoreCheckReceiverRegvalueRegscratchReginFrame(destReg, sourceReg, scratchReg, inFrame);
	}
	return 0;
}


/*	This method is used for unchecked stores in objects after their creation
	(typically, inlined creation of Array, closures and some temp vectors). 
	Currently there is no need to do the immutability check here
 */

	/* CogObjectRepresentationForSpur>>#genStoreSourceReg:slotIndex:intoNewObjectInDestReg: */
static NoDbgRegParms sqInt
genStoreSourceRegslotIndexintoNewObjectInDestReg(sqInt sourceReg, sqInt index, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	offset = (index * BytesPerWord) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	return 0;
}


/*	Convention:
	- RcvrResultReg holds the object mutated.
	If immutability failure:
	- TempReg holds the instance variable index mutated 
	if instVarIndex > numDedicatedStoreTrampoline
	- ClassReg holds the value to store
	Registers are not lived across this trampoline as the 
	immutability failure may need new stack frames. */

	/* CogObjectRepresentationForSpur>>#genStoreTrampolineCalled:instVarIndex: */
#if IMMUTABILITY
static NoDbgRegParms usqInt
genStoreTrampolineCalledinstVarIndex(char *trampolineName, sqInt instVarIndex)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpRC;
    sqInt pushLinkReg;
    sqInt quickConstant;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	if (CheckRememberedInTrampoline) {
		/* begin genStoreTrampolineCheckingRememberedCalled:instVarIndex: */
		/* Store check */
		/* If on 64-bits and doing the remembered bit test here, we can combine the tests to fetch the header once. */
		jumpImmutable = genJumpImmutablescratchReg(ReceiverResultReg, SendNumArgsReg);
		quickConstant = 1U << (rememberedBitShift());

		/* begin TstCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(TstCqR, quickConstant, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		jumpRC = genConditionalBranchoperand(JumpZero, ((sqInt)0));

		/* RetN: */
		genoperand(RetN, 0);
		jmpTarget(jumpRC, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(remember, 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 1, /* returnRegForStoreCheck */
			(((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)
				? ReceiverResultReg
				: ABIResultReg));
		jmpTarget(jumpImmutable, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceCannotAssignTowithIndexvalueToAssign, 3, ReceiverResultReg, (instVarIndex < (NumStoreTrampolines - 1)
				? (/* begin trampolineArgConstant: */
					assert(instVarIndex >= 0),
				-2 - instVarIndex)
				: TempReg), ClassReg, null, 0 /* emptyRegisterMask */, 1, NoReg);
	}
	else {
		/* begin genStoreTrampolineNotCheckingRememberedCalled:instVarIndex: */
		genSmalltalkToCStackSwitch((pushLinkReg = 1 /* hasLinkRegister */));

		/* Store check */
		jumpImmutable = genJumpImmutablescratchReg(ReceiverResultReg, SendNumArgsReg);
		compileCallFornumArgsargargargargresultRegregsToSave(remember, 1, ReceiverResultReg, null, null, null, /* returnRegForStoreCheck */
			(((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)
				? ReceiverResultReg
				: ABIResultReg), 0 /* emptyRegisterMask */);
		genLoadStackPointers(backEnd);
		genTrampolineReturn(pushLinkReg);
		jmpTarget(jumpImmutable, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileCallFornumArgsargargargargresultRegregsToSave(ceCannotAssignTowithIndexvalueToAssign, 3, ReceiverResultReg, (instVarIndex < (NumStoreTrampolines - 1)
				? (/* begin trampolineArgConstant: */
					assert(instVarIndex >= 0),
				-2 - instVarIndex)
				: TempReg), ClassReg, null, NoReg, 0 /* emptyRegisterMask */);
		genLoadStackPointers(backEnd);
		genTrampolineReturn(pushLinkReg);
	}
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}
#endif /* IMMUTABILITY */


/*	Store check code is duplicated to use a single trampoline */

	/* CogObjectRepresentationForSpur>>#genStoreWithImmutabilityAndStoreCheckSourceReg:slotIndex:destReg:scratchReg:needRestoreRcvr: */
#if IMMUTABILITY
static NoDbgRegParms sqInt
genStoreWithImmutabilityAndStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needRestoreRcvr)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *immutableJump;
    AbstractInstruction *jmpAlreadyRemembered;
    AbstractInstruction *jmpDestYoung;
    AbstractInstruction *jmpImmediate;
    AbstractInstruction *jmpSourceOld;
    sqInt offset;

	jmpAlreadyRemembered = ((AbstractInstruction *) 0);
	immutableJump = genJumpImmutablescratchReg(destReg, scratchReg);

	/* begin genTraceStores */
	if (traceStores > 0) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, TempReg);

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	offset = (index * BytesPerWord) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* Get the old/new boundary in scratchReg */
	jmpImmediate = genJumpImmediate(sourceReg);

	/* #MoveCw:R: #gen:literal:operand: */
	checkLiteralforInstruction(storeCheckBoundary(), genoperandoperand(MoveCwR, storeCheckBoundary(), scratchReg));

	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, destReg);

	/* Is value stored old?  If so we're done. */
	jmpDestYoung = genConditionalBranchoperand(JumpBelow, ((sqInt)0));

	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, sourceReg);

	/* value is young and target is old.
	   Need to remember this only if the remembered bit is not already set. */
	jmpSourceOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	if (!CheckRememberedInTrampoline) {
		jmpAlreadyRemembered = genCheckRememberedBitOfscratch(destReg, scratchReg);
	}
	jmpTarget(immutableJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* begin genStoreTrampolineCall: */
	assert(IMMUTABILITY);
	if (index >= (NumStoreTrampolines - 1)) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, index, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(index, BytesPerOop));
		}

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceStoreTrampolines[NumStoreTrampolines - 1]);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceStoreTrampolines[index]);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);

	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	if (needRestoreRcvr) {
		/* begin putSelfInReceiverResultReg */
		storeToReg(simSelf(), ReceiverResultReg);
	}
	jmpTarget(jmpImmediate, jmpTarget(jmpDestYoung, jmpTarget(jmpSourceOld, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	if (!CheckRememberedInTrampoline) {
		jmpTarget(jmpAlreadyRemembered, ((AbstractInstruction *) (((jmpSourceOld->operands))[0])));
	}
	return 0;
}
#endif /* IMMUTABILITY */


/*	Gen an immutability check with no store check (e.g. assigning an immediate
	literal) 
 */
/*	imm check has its own trampoline */

	/* CogObjectRepresentationForSpur>>#genStoreWithImmutabilityButNoStoreCheckSourceReg:slotIndex:destReg:scratchReg:needRestoreRcvr: */
#if IMMUTABILITY
static NoDbgRegParms sqInt
genStoreWithImmutabilityButNoStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needRestoreRcvr)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *immutabilityFailure;
    AbstractInstruction *mutableJump;
    sqInt offset;

	mutableJump = genJumpMutablescratchReg(destReg, scratchReg);

	/* begin genStoreTrampolineCall: */
	assert(IMMUTABILITY);
	if (index >= (NumStoreTrampolines - 1)) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, index, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(index, BytesPerOop));
		}

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceStoreTrampolines[NumStoreTrampolines - 1]);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceStoreTrampolines[index]);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);

	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	if (needRestoreRcvr) {
		/* begin putSelfInReceiverResultReg */
		storeToReg(simSelf(), ReceiverResultReg);
	}
	immutabilityFailure = genoperand(Jump, ((sqInt)0));
	jmpTarget(mutableJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* begin genTraceStores */
	if (traceStores > 0) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, TempReg);

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	offset = (index * BytesPerWord) + BaseHeaderSize;

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	jmpTarget(immutabilityFailure, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}
#endif /* IMMUTABILITY */


/*	We know there is a frame as immutability check requires a frame */
/*	needRestoreRcvr has to be true to keep RcvrResultReg live with the
	receiver in it across the trampoline
 */
/*	Trampoline convention... */

	/* CogObjectRepresentationForSpur>>#genStoreWithImmutabilityCheckSourceReg:slotIndex:destReg:scratchReg:needsStoreCheck:needRestoreRcvr: */
#if IMMUTABILITY
static NoDbgRegParms sqInt
genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt needsStoreCheck, sqInt needRestoreRcvr)
{
	assert(destReg == ReceiverResultReg);
	assert(scratchReg == TempReg);
	assert(sourceReg == ClassReg);
	if (needsStoreCheck) {
		genStoreWithImmutabilityAndStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sourceReg, index, destReg, scratchReg, needRestoreRcvr);
	}
	else {
		genStoreWithImmutabilityButNoStoreCheckSourceRegslotIndexdestRegscratchRegneedRestoreRcvr(sourceReg, index, destReg, scratchReg, needRestoreRcvr);
	}
	return 0;
}
#endif /* IMMUTABILITY */


/*	Make sure SendNumArgsReg and ClassReg are available in addition to
	ReceiverResultReg and TempReg in
	genGetActiveContextNumArgs:large:inBlock:. 
 */

	/* CogObjectRepresentationForSpur>>#getActiveContextAllocatesInMachineCode */
static sqInt
getActiveContextAllocatesInMachineCode(void)
{
	return 1;
}


/*	Since all cache tags in Spur are class indices none of
	them are young or have to be updated in a scavenge. */

	/* CogObjectRepresentationForSpur>>#inlineCacheTagIsYoung: */
static NoDbgRegParms sqInt
inlineCacheTagIsYoung(sqInt cacheTag)
{
	return 0;
}

	/* CogObjectRepresentationForSpur>>#jumpNotCharacterUnsignedValueInRegister: */
static NoDbgRegParms AbstractInstruction *
jumpNotCharacterUnsignedValueInRegister(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = (1U << (numCharacterBits())) - 1;

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	return genConditionalBranchoperand(JumpAbove, ((sqInt)0));
}


/*	Mark and trace a literal in a machine code instruction preceding address
	in cogMethodOrNil.
	Answer if code was modified. */

	/* CogObjectRepresentationForSpur>>#markAndTraceLiteral:in:atpc: */
static NoDbgRegParms sqInt
markAndTraceLiteralinatpc(sqInt literal, CogMethod *cogMethodOrNil, usqInt address)
{
    sqInt objOop;

	if (!(couldBeObject(literal))) {
		return 0;
	}
	assert(addressCouldBeObj(literal));
	if (!(isForwarded(literal))) {
		markAndTrace(literal);
		return 0;
	}

	/* begin setCodeModified */
#  if DUAL_MAPPED_CODE_ZONE
	codeModified = 1;
#  else
	if (!codeModified) {
		codeModified = 1;

		/* begin makeCodeZoneWritable */
#    if __APPLE__ && __MACH__
		pthread_jit_write_protect_np(0);
		PJWPNClear = __LINE__;
#    endif

	}
#  endif // DUAL_MAPPED_CODE_ZONE

	objOop = followForwarded(literal);
	storeLiteralbeforeFollowingAddress(backEnd, objOop, address);
	markAndTraceUpdatedLiteralin(objOop, cogMethodOrNil);
	return 1;
}


/*	Mark and trace a literal in a sqInt variable of cogMethod. */

	/* CogObjectRepresentationForSpur>>#markAndTraceLiteral:in:at: */
static NoDbgRegParms void
markAndTraceLiteralinat(sqInt literal, CogMethod *cogMethod, sqInt *address)
{
    sqInt objOop;

	if (!(couldBeObject(literal))) {
		return;
	}
	assert(addressCouldBeObj(literal));
	if (!(isForwarded(literal))) {
		markAndTrace(literal);
		return;
	}
	objOop = followForwarded(literal);
	address[0] = objOop;
	markAndTraceUpdatedLiteralin(objOop, cogMethod);
}


/*	Common code to mark a literal in cogMethod and add
	the cogMethod to youngReferrers if the literal is young. */

	/* CogObjectRepresentationForSpur>>#markAndTraceUpdatedLiteral:in: */
static NoDbgRegParms void
markAndTraceUpdatedLiteralin(sqInt objOop, CogMethod *cogMethodOrNil)
{
	if (isNonImmediate(objOop)) {
		if ((cogMethodOrNil)
		 && (isYoungObject(objOop))) {
			ensureInYoungReferrers(cogMethodOrNil);
		}
		markAndTrace(objOop);
	}
}


/*	If primIndex has an accessorDepth and fails, or it is external and fails
	with PrimErrNoMemory,
	call ceCheckAndMaybeRetryPrimitive if so If ceCheck.... answers true,
	retry the primitive. */

	/* CogObjectRepresentationForSpur>>#maybeCompileRetryOf:onPrimitiveFail:flags: */
static NoDbgRegParms sqInt
maybeCompileRetryOfonPrimitiveFailflags(void (*primitiveRoutine)(void), sqInt primIndex, sqInt flags)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmp;

	if ((accessorDepthForPrimitiveIndex(primIndex)) >= 0) {
		/* #MoveAw:R: #gen:literal:operand: */
		checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmp = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	}
	else {
		if (PrimNumberExternalCall != primIndex) {
			return 0;
		}

		/* #MoveAw:R: #gen:literal:operand: */
		checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, PrimErrNoMemory, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(PrimErrNoMemory, BytesPerOop));
		}
		jmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	}
	if (!(((flags & PrimCallNeedsNewMethod) != 0))) {
		genLoadNewMethod();
	}

	/* #MoveCw:R: #gen:literal:operand: */
	checkLiteralforInstruction(((sqInt)primitiveRoutine), genoperandoperand(MoveCwR, ((sqInt)primitiveRoutine), TempReg));

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(primitiveFunctionPointerAddress(), genoperandoperand(MoveRAw, TempReg, primitiveFunctionPointerAddress()));
	compileCallFornumArgsargargargargresultRegregsToSave(
		ceCheckAndMaybeRetryPrimitive,
		1,
		(/* begin trampolineArgConstant: */
			assert(primIndex >= 0),
		-2 - primIndex),
		null,
		null,
		null,
		TempReg,
		0 /* emptyRegisterMask */);
	jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	Generate a shift of the register containing the class tag in a method
	cache probe.
	c.f. SpurMemoryManager>>methodCacheHashOf:with: */

	/* CogObjectRepresentationForSpur>>#maybeShiftClassTagRegisterForMethodCacheProbe: */
static NoDbgRegParms sqInt
maybeShiftClassTagRegisterForMethodCacheProbe(sqInt classTagReg)
{
	/* LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 2, classTagReg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#numCharacterBits */
static sqInt
numCharacterBits(void)
{
	return 30;
}

	/* CogObjectRepresentationForSpur>>#remapObject: */
static NoDbgRegParms sqInt
remapObject(sqInt objOop)
{
	assert(addressCouldBeObj(objOop));
	return (shouldRemapObj(objOop)
			? remapObj(objOop)
			: objOop);
}

	/* CogObjectRepresentationForSpur>>#remapOop: */
static NoDbgRegParms sqInt
remapOop(sqInt objOop)
{
	return (shouldRemapOop(objOop)
			? remapObj(objOop)
			: objOop);
}


/*	Objects in newSpace or oldSpace except nil, true, false &
	classTableRootObj need to be annotated.
 */

	/* CogObjectRepresentationForSpur>>#shouldAnnotateObjectReference: */
static NoDbgRegParms sqInt
shouldAnnotateObjectReference(sqInt anOop)
{
	return (isNonImmediate(anOop))
	 && ((oopisGreaterThan(anOop, classTableRootObj()))
	 || (oopisLessThan(anOop, nilObject())));
}

	/* CogObjectRepresentationForSpur>>#slotOffsetOfInstVarIndex: */
static NoDbgRegParms sqInt
slotOffsetOfInstVarIndex(sqInt index)
{
	return (index * BytesPerWord) + BaseHeaderSize;
}

	/* CogSimStackEntry>>#ensureSpilledAt:from: */
static NoDbgRegParms SimStackEntry *
ensureSpilledAtfrom(SimStackEntry *self_in_CogSimStackEntry, sqInt baseOffset, sqInt baseRegister)
{
    AbstractInstruction *anInstruction;
    sqInt baseReg;
    sqInt constant;
    AbstractInstruction *inst;
    sqInt offset;

	if ((self_in_CogSimStackEntry->spilled)) {
		if (((self_in_CogSimStackEntry->type)) == SSSpill) {
			assert(((((self_in_CogSimStackEntry->offset)) == baseOffset)
			 && (((self_in_CogSimStackEntry->registerr)) == baseRegister))
			 || (violatesEnsureSpilledSpillAssert()));
			return self_in_CogSimStackEntry;
		}
	}
	assert(((self_in_CogSimStackEntry->type)) != SSSpill);
	traceSpill(self_in_CogSimStackEntry);
	if (((self_in_CogSimStackEntry->type)) == SSConstant) {
		constant = (self_in_CogSimStackEntry->constant);

		/* begin genPushConstant: */
		if (/* shouldAnnotateObjectReference: */
			(isNonImmediate(constant))
		 && ((oopisGreaterThan(constant, classTableRootObj()))
		 || (oopisLessThan(constant, nilObject())))) {
			inst = annotateobjRef(checkLiteralforInstruction(constant, genoperand(PushCw, constant)), constant);
		}
		else {
			/* begin PushCq: */
			/* begin gen:quickConstant: */
			anInstruction = genoperand(PushCq, constant);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
			}
			inst = anInstruction;
		}
	}
	else {
		if (((self_in_CogSimStackEntry->type)) == SSBaseOffset) {
			offset = (self_in_CogSimStackEntry->offset);
			baseReg = (self_in_CogSimStackEntry->registerr);

			/* begin MoveMw:r:R: */
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, TempReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			inst = genoperand(PushR, TempReg);
		}
		else {
			assert(((self_in_CogSimStackEntry->type)) == SSRegister);
			inst = genoperand(PushR, (self_in_CogSimStackEntry->registerr));
		}
		(self_in_CogSimStackEntry->type) = SSSpill;
		(self_in_CogSimStackEntry->offset) = baseOffset;
		(self_in_CogSimStackEntry->registerr) = baseRegister;
	}
	(self_in_CogSimStackEntry->spilled) = 1;
	return self_in_CogSimStackEntry;
}

	/* CogSimStackEntry>>#floatRegisterMask */
static NoDbgRegParms sqInt
floatRegisterMask(SimStackEntry *self_in_CogSimStackEntry)
{
	return 0;
}

	/* CogSimStackEntry>>#isSameEntryAs: */
static NoDbgRegParms sqInt
isSameEntryAs(SimStackEntry *self_in_CogSimStackEntry, CogSimStackEntry *ssEntry)
{
	return (((self_in_CogSimStackEntry->type)) == ((ssEntry->type)))
	 && ((((((self_in_CogSimStackEntry->type)) == SSBaseOffset)
	 || (((self_in_CogSimStackEntry->type)) == SSSpill))
	 && ((((self_in_CogSimStackEntry->offset)) == ((ssEntry->offset)))
	 && (((self_in_CogSimStackEntry->registerr)) == ((ssEntry->registerr)))))
	 || (((((self_in_CogSimStackEntry->type)) == SSRegister)
	 && (((self_in_CogSimStackEntry->registerr)) == ((ssEntry->registerr))))
	 || ((((self_in_CogSimStackEntry->type)) == SSConstant)
	 && (((self_in_CogSimStackEntry->constant)) == ((ssEntry->constant))))));
}


/*	Receiver is not a forwarder, except in blocks with no inst var access.
	For now we optimize only the case where receiver is accessed in a method. */

	/* CogSimStackEntry>>#mayBeAForwarder */
static NoDbgRegParms sqInt
mayBeAForwarder(SimStackEntry *self_in_CogSimStackEntry)
{
	if ((((self_in_CogSimStackEntry->type)) == SSRegister)
	 && (isNonForwarderReceiver((self_in_CogSimStackEntry->registerr)))) {
		return 0;
	}
	return ((self_in_CogSimStackEntry->type)) != SSConstant;
}

	/* CogSimStackEntry>>#popToReg: */
static NoDbgRegParms SimStackEntry *
popToReg(SimStackEntry *self_in_CogSimStackEntry, sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt baseReg;
    sqInt constant;
    sqInt offset;

	if ((self_in_CogSimStackEntry->spilled)) {
		/* PopR: */
		genoperand(PopR, reg);
	}
	else {
		switch ((self_in_CogSimStackEntry->type)) {
		case SSBaseOffset:
			offset = (self_in_CogSimStackEntry->offset);
			baseReg = (self_in_CogSimStackEntry->registerr);

			/* begin MoveMw:r:R: */
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, reg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			break;
		case SSConstant:
			constant = (self_in_CogSimStackEntry->constant);

			/* begin genMoveConstant:R: */
			if (/* shouldAnnotateObjectReference: */
				(isNonImmediate(constant))
			 && ((oopisGreaterThan(constant, classTableRootObj()))
			 || (oopisLessThan(constant, nilObject())))) {
				annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(MoveCwR, constant, reg)), constant);
			}
			else {
				/* begin MoveCq:R: */
				/* begin gen:quickConstant:operand: */
				anInstruction = genoperandoperand(MoveCqR, constant, reg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
				}
			}
			break;
		case SSRegister:
			if (reg != ((self_in_CogSimStackEntry->registerr))) {
				/* MoveR:R: */
				genoperandoperand(MoveRR, (self_in_CogSimStackEntry->registerr), reg);
			}
			else {
				/* Label */
				genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	return self_in_CogSimStackEntry;
}


/*	Answer a bit mask for the receiver's register, if any. */

	/* CogSimStackEntry>>#registerMask */
static NoDbgRegParms sqInt
registerMask(SimStackEntry *self_in_CogSimStackEntry)
{
	return ((((self_in_CogSimStackEntry->type)) == SSBaseOffset)
	 || (((self_in_CogSimStackEntry->type)) == SSRegister)
			? ((((self_in_CogSimStackEntry->registerr)) < 0) ? (((usqInt)(1)) >> (-((self_in_CogSimStackEntry->registerr)))) : (1ULL << ((self_in_CogSimStackEntry->registerr))))
			: 0);
}

	/* CogSimStackEntry>>#registerMaskOrNone */
static NoDbgRegParms sqInt
registerMaskOrNone(SimStackEntry *self_in_CogSimStackEntry)
{
	return (((self_in_CogSimStackEntry->type)) == SSRegister
			? ((((self_in_CogSimStackEntry->registerr)) < 0) ? (((usqInt)(1)) >> (-((self_in_CogSimStackEntry->registerr)))) : (1ULL << ((self_in_CogSimStackEntry->registerr))))
			: 0);
}

	/* CogSimStackEntry>>#registerOrNone */
static NoDbgRegParms sqInt
registerOrNone(SimStackEntry *self_in_CogSimStackEntry)
{
	return (((self_in_CogSimStackEntry->type)) == SSRegister
			? (self_in_CogSimStackEntry->registerr)
			: NoReg);
}

	/* CogSimStackEntry>>#storeToReg: */
static NoDbgRegParms SimStackEntry *
storeToReg(SimStackEntry *self_in_CogSimStackEntry, sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt baseReg;
    sqInt constant;
    sqInt offset;

	switch ((self_in_CogSimStackEntry->type)) {
	case SSBaseOffset:
	case SSSpill:
		offset = (self_in_CogSimStackEntry->offset);
		baseReg = (self_in_CogSimStackEntry->registerr);

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		break;
	case SSConstant:
		constant = (self_in_CogSimStackEntry->constant);

		/* begin genMoveConstant:R: */
		if (/* shouldAnnotateObjectReference: */
			(isNonImmediate(constant))
		 && ((oopisGreaterThan(constant, classTableRootObj()))
		 || (oopisLessThan(constant, nilObject())))) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(MoveCwR, constant, reg)), constant);
		}
		else {
			/* begin MoveCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(MoveCqR, constant, reg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
			}
		}
		break;
	case SSRegister:
		if (reg != ((self_in_CogSimStackEntry->registerr))) {
			/* MoveR:R: */
			genoperandoperand(MoveRR, (self_in_CogSimStackEntry->registerr), reg);
		}
		else {
			/* Label */
			genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	return self_in_CogSimStackEntry;
}

	/* CogSimStackNativeEntry>>#ensureIsMarkedAsSpilled */
static NoDbgRegParms CogSimStackNativeEntry *
ensureIsMarkedAsSpilled(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry)
{
	if (!((self_in_CogSimStackNativeEntry->spilled))) {
		switch ((self_in_CogSimStackNativeEntry->type)) {
		case SSNativeRegister:
		case SSConstantInt32:
		case SSConstantNativePointer:
			(self_in_CogSimStackNativeEntry->type) = SSSpillNative;
			break;
		case SSRegisterSingleFloat:
		case SSConstantFloat32:
			(self_in_CogSimStackNativeEntry->type) = SSSpillFloat32;
			break;
		case SSRegisterDoubleFloat:
		case SSConstantFloat64:
			(self_in_CogSimStackNativeEntry->type) = SSSpillFloat64;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	(self_in_CogSimStackNativeEntry->spilled) = 1;
	return self_in_CogSimStackNativeEntry;
}

	/* CogSimStackNativeEntry>>#ensureSpilledSP:scratchRegister: */
static NoDbgRegParms CogSimStackNativeEntry *
ensureSpilledSPscratchRegister(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry, sqInt spRegister, sqInt scratchRegister)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt quickConstant;
    sqInt sourceDPReg;
    sqInt sourceReg;

	if (!((self_in_CogSimStackNativeEntry->spilled))) {
		switch ((self_in_CogSimStackNativeEntry->type)) {
		case SSNativeRegister:
			sourceReg = (self_in_CogSimStackNativeEntry->registerr);
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveR:Mw:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, spRegister);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			(self_in_CogSimStackNativeEntry->type) = SSSpillNative;
			break;
		case SSRegisterSingleFloat:
			sourceDPReg = (self_in_CogSimStackNativeEntry->registerr);
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveRs:M32:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRsM32r, sourceDPReg, offset, spRegister);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			(self_in_CogSimStackNativeEntry->type) = SSSpillFloat32;
			break;
		case SSRegisterDoubleFloat:
			sourceDPReg = (self_in_CogSimStackNativeEntry->registerr);
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveRd:M64:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRdM64r, sourceDPReg, offset, spRegister);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			(self_in_CogSimStackNativeEntry->type) = SSSpillFloat64;
			break;
		case SSConstantFloat32:
			/* #MoveCw:R: #gen:literal:operand: */
			checkLiteralforInstruction(asIEEE32BitWord((self_in_CogSimStackNativeEntry->constantFloat32)), genoperandoperand(MoveCwR, asIEEE32BitWord((self_in_CogSimStackNativeEntry->constantFloat32)), scratchRegister));
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveR:M32:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRM32r, scratchRegister, offset, spRegister);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			(self_in_CogSimStackNativeEntry->type) = SSSpillFloat32;
			break;
		case SSConstantFloat64:
			/* #MoveCw:R: #gen:literal:operand: */
			checkLiteralforInstruction(asIEEE64BitWord((self_in_CogSimStackNativeEntry->constantFloat32)), genoperandoperand(MoveCwR, asIEEE64BitWord((self_in_CogSimStackNativeEntry->constantFloat32)), scratchRegister));
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveR:Mw:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRMwr, scratchRegister, offset, spRegister);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			(self_in_CogSimStackNativeEntry->type) = SSSpillFloat64;
			break;
		case SSConstantInt32:
			quickConstant = (self_in_CogSimStackNativeEntry->constantInt32);

			/* begin MoveCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(MoveCqR, quickConstant, scratchRegister);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
			}
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveR:Mw:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRMwr, scratchRegister, offset, spRegister);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			(self_in_CogSimStackNativeEntry->type) = SSSpillNative;
			break;
		case SSConstantNativePointer:
			/* #MoveCw:R: #gen:literal:operand: */
			checkLiteralforInstruction((self_in_CogSimStackNativeEntry->constantNativePointer), genoperandoperand(MoveCwR, (self_in_CogSimStackNativeEntry->constantNativePointer), scratchRegister));
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveR:Mw:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRMwr, scratchRegister, offset, spRegister);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			(self_in_CogSimStackNativeEntry->type) = SSSpillNative;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	(self_in_CogSimStackNativeEntry->spilled) = 1;
	return self_in_CogSimStackNativeEntry;
}


/*	Answer a bit mask for the receiver's register, if any. */

	/* CogSimStackNativeEntry>>#nativeFloatRegisterMask */
static NoDbgRegParms sqInt
nativeFloatRegisterMask(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry)
{
	return ((((self_in_CogSimStackNativeEntry->type)) == SSRegisterSingleFloat)
	 || (((self_in_CogSimStackNativeEntry->type)) == SSRegisterDoubleFloat)
			? ((((self_in_CogSimStackNativeEntry->registerr)) < 0) ? (((usqInt)(1)) >> (-((self_in_CogSimStackNativeEntry->registerr)))) : (1ULL << ((self_in_CogSimStackNativeEntry->registerr))))
			: 0);
}

	/* CogSimStackNativeEntry>>#nativeFloatRegisterOrNone */
static NoDbgRegParms sqInt
nativeFloatRegisterOrNone(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry)
{
	return ((((self_in_CogSimStackNativeEntry->type)) == SSRegisterSingleFloat)
	 || (((self_in_CogSimStackNativeEntry->type)) == SSRegisterDoubleFloat)
			? (self_in_CogSimStackNativeEntry->registerr)
			: NoReg);
}

	/* CogSimStackNativeEntry>>#nativePopToReg: */
static NoDbgRegParms CogSimStackNativeEntry *
nativePopToReg(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry, sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt quickConstant;

	if ((self_in_CogSimStackNativeEntry->spilled)) {
		loadNativeFramePointerInto(TempReg);
		switch ((self_in_CogSimStackNativeEntry->type)) {
		case SSSpillNative:
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveMw:r:R: */
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveMwrR, offset, TempReg, reg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			break;
		case SSSpillInt64:
			assert(BytesPerWord == 8);
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveMw:r:R: */
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveMwrR, offset, TempReg, reg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			break;
		case SSSpillFloat32:
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveM32:r:Rs: */
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveM32rRs, offset, TempReg, reg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			break;
		case SSSpillFloat64:
			offset = (-((self_in_CogSimStackNativeEntry->offset))) - 1;

			/* begin MoveM64:r:Rd: */
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveM64rRd, offset, TempReg, reg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	else {
		switch ((self_in_CogSimStackNativeEntry->type)) {
		case SSNativeRegister:
			if (reg != ((self_in_CogSimStackNativeEntry->registerr))) {
				/* MoveR:R: */
				genoperandoperand(MoveRR, (self_in_CogSimStackNativeEntry->registerr), reg);
			}
			break;
		case SSRegisterSingleFloat:
			if (reg != ((self_in_CogSimStackNativeEntry->registerr))) {
				/* MoveRs:Rs: */
				genoperandoperand(MoveRsRs, (self_in_CogSimStackNativeEntry->registerr), reg);
			}
			break;
		case SSRegisterDoubleFloat:
			if (reg != ((self_in_CogSimStackNativeEntry->registerr))) {
				/* MoveRd:Rd: */
				genoperandoperand(MoveRdRd, (self_in_CogSimStackNativeEntry->registerr), reg);
			}
			break;
		case SSConstantInt32:
			quickConstant = (self_in_CogSimStackNativeEntry->constantInt32);

			/* begin MoveCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(MoveCqR, quickConstant, reg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
			}
			break;
		case SSConstantNativePointer:
			/* #MoveCw:R: #gen:literal:operand: */
			checkLiteralforInstruction((self_in_CogSimStackNativeEntry->constantNativePointer), genoperandoperand(MoveCwR, (self_in_CogSimStackNativeEntry->constantNativePointer), reg));
			break;
		case SSConstantFloat32:
			/* MoveCf32:Rs: */
			genMoveCf32Rs(backEnd, (self_in_CogSimStackNativeEntry->constantFloat32), reg);
			break;
		case SSConstantFloat64:
			/* MoveCf64:Rd: */
			genMoveCf64Rd(backEnd, (self_in_CogSimStackNativeEntry->constantFloat64), reg);
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	return self_in_CogSimStackNativeEntry;
}


/*	Answer a bit mask for the receiver's register, if any. */

	/* CogSimStackNativeEntry>>#nativeRegisterMask */
static NoDbgRegParms sqInt
nativeRegisterMask(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry)
{
	return ((((((self_in_CogSimStackNativeEntry->type)) == SSBaseOffset)
	 || (((self_in_CogSimStackNativeEntry->type)) == SSNativeRegister))
	 || (((self_in_CogSimStackNativeEntry->type)) == SSRegisterSingleFloat))
	 || (((self_in_CogSimStackNativeEntry->type)) == SSRegisterDoubleFloat)
			? ((((self_in_CogSimStackNativeEntry->registerr)) < 0) ? (((usqInt)(1)) >> (-((self_in_CogSimStackNativeEntry->registerr)))) : (1ULL << ((self_in_CogSimStackNativeEntry->registerr))))
			: (((self_in_CogSimStackNativeEntry->type)) == SSRegisterPair
					? (((((self_in_CogSimStackNativeEntry->registerr)) < 0) ? (((usqInt)(1)) >> (-((self_in_CogSimStackNativeEntry->registerr)))) : (1ULL << ((self_in_CogSimStackNativeEntry->registerr))))) | (((((self_in_CogSimStackNativeEntry->registerSecond)) < 0) ? (((usqInt)(1)) >> (-((self_in_CogSimStackNativeEntry->registerSecond)))) : (1ULL << ((self_in_CogSimStackNativeEntry->registerSecond)))))
					: 0));
}

	/* CogSimStackNativeEntry>>#nativeRegisterOrNone */
static NoDbgRegParms sqInt
nativeRegisterOrNone(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry)
{
	return ((((self_in_CogSimStackNativeEntry->type)) == SSNativeRegister)
	 || (((self_in_CogSimStackNativeEntry->type)) == SSRegisterPair)
			? (self_in_CogSimStackNativeEntry->registerr)
			: NoReg);
}

	/* CogSimStackNativeEntry>>#nativeRegisterSecondOrNone */
static NoDbgRegParms sqInt
nativeRegisterSecondOrNone(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry)
{
	return (((self_in_CogSimStackNativeEntry->type)) == SSRegisterPair
			? (self_in_CogSimStackNativeEntry->registerSecond)
			: NoReg);
}

	/* CogSimStackNativeEntry>>#nativeStackPopToReg: */
static NoDbgRegParms CogSimStackNativeEntry *
nativeStackPopToReg(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry, sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	assert((self_in_CogSimStackNativeEntry->spilled));
	switch ((self_in_CogSimStackNativeEntry->type)) {
	case SSSpillNative:
		offset = -((self_in_CogSimStackNativeEntry->offset));

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		break;
	case SSSpillInt64:
		assert(BytesPerWord == 8);
		offset = -((self_in_CogSimStackNativeEntry->offset));

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		break;
	case SSSpillFloat32:
		offset = -((self_in_CogSimStackNativeEntry->offset));

		/* begin MoveM32:r:Rs: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rRs, offset, FPReg, reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		break;
	case SSSpillFloat64:
		offset = -((self_in_CogSimStackNativeEntry->offset));

		/* begin MoveM64:r:Rd: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM64rRd, offset, FPReg, reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	return self_in_CogSimStackNativeEntry;
}

	/* CogSimStackNativeEntry>>#spillingNeedsScratchRegister */
static NoDbgRegParms sqInt
spillingNeedsScratchRegister(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry)
{
	if (!((self_in_CogSimStackNativeEntry->spilled))) {
		switch ((self_in_CogSimStackNativeEntry->type)) {
		case SSConstantInt32:
		case SSConstantInt64:
		case SSConstantFloat32:
		case SSConstantFloat64:
		case SSConstantNativePointer:
			return 1;

		default:
			return 0;
		}
	}
	return 0;
}

	/* CogSimStackNativeEntry>>#stackSpillSize */
static NoDbgRegParms sqInt
stackSpillSize(CogSimStackNativeEntry *self_in_CogSimStackNativeEntry)
{
	switch ((self_in_CogSimStackNativeEntry->type)) {
	case SSConstantInt64:
	case SSConstantFloat64:
	case SSRegisterDoubleFloat:
	case SSRegisterPair:
	case SSSpillFloat64:
	case SSSpillInt64:
		return 8;

	default:
		return BytesPerOop;
	}
	return 0;
}

	/* CogSSBytecodeFixup>>#isBackwardBranchFixup */
static NoDbgRegParms char
isBackwardBranchFixup(BytecodeFixup *self_in_CogSSBytecodeFixup)
{
	return (self_in_CogSSBytecodeFixup->isTargetOfBackwardBranch);
}

	/* CogSSBytecodeFixup>>#isMergeFixup */
static NoDbgRegParms int
isMergeFixup(BytecodeFixup *self_in_CogSSBytecodeFixup)
{
	return (((usqInt)((self_in_CogSSBytecodeFixup->targetInstruction)))) == NeedsMergeFixupFlag;
}


/*	Allocate an unsharable Literal instruction for the literal and answer it. */

	/* OutOfLineLiteralsManager>>#allocateLiteral: */
static NoDbgRegParms AbstractInstruction *
allocateLiteral(sqInt aLiteral)
{
    AbstractInstruction *existingInst;
    sqInt i;
    sqInt initialNumLiterals;
    AbstractInstruction *litInst;
    AbstractInstruction *newInst;
    AbstractInstruction *newLiterals;

	if (nextLiteralIndex >= literalsSize) {
		initialNumLiterals = literalsSize + 8;

		/* begin allocateLiterals: */
		if (initialNumLiterals > literalsSize) {
			/* Must copy across state (not using realloc, cuz...) and
			   must also update existing instructions to refer to the new ones...
			   It's either this or modify all generation routines to be able to retry
			   with more literals after running out of literals. */
			newLiterals = calloc(initialNumLiterals, sizeof(CogAbstractInstruction));
			if (literals) {
				for (i = 0; i < nextLiteralIndex; i += 1) {
					existingInst = literalInstructionAt(i);
					newInst = (&(newLiterals[i]));
					cloneLiteralFrom(newInst, existingInst);
					assert(!((existingInst->dependent)));
					(existingInst->dependent = newInst);
				}
				for (i = 0; i < opcodeIndex; i += 1) {
					existingInst = abstractInstructionAt(i);
					if ((((existingInst->dependent)))
					 && (((((existingInst->dependent))->opcode)) == Literal)) {
						(existingInst->dependent = (((existingInst->dependent))->dependent));
					}
				}
			}
			free(literals);
			literals = newLiterals;
			literalsSize = initialNumLiterals;
		}
	}
	litInst = literalInstructionAt(nextLiteralIndex);
	initializeUniqueLiteral(litInst, aLiteral);

	/* Record the opcodeIndex of the first dependent instruction (the first instruction that references an out-of-line literal) */
	nextLiteralIndex += 1;
	if (firstOpcodeIndex > opcodeIndex) {
		firstOpcodeIndex = opcodeIndex - 1;
	}
	return litInst;
}


/*	A literal is in range if its opcode index is within
	outOfLineLiteralOpcodeLimit, or if its index has yet to be assigned. */

	/* OutOfLineLiteralsManager>>#literalInstructionInRange: */
static NoDbgRegParms sqInt
literalInstructionInRange(AbstractInstruction *litInst)
{
    sqInt opcodeIdx;

	/* begin literalOpcodeIndex */
	assert(((litInst->opcode)) == Literal);
	opcodeIdx = ((sqInt)(((litInst->operands))[2]));
	return ((((sqInt)opcodeIdx)) < 0)
	 || ((assert((getOpcodeIndex()) >= opcodeIdx),
	(opcodeIndex - opcodeIdx) < (outOfLineLiteralOpcodeLimit(backEnd))));
}

	/* OutOfLineLiteralsManagerFor64Bits>>#checkLiteral32:forInstruction: */
static NoDbgRegParms AbstractInstruction *
checkLiteral32forInstruction(sqInt literal, AbstractInstruction *anInstruction)
{
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(literal, 4));
	}
	return anInstruction;
}

	/* OutOfLineLiteralsManagerFor64Bits>>#checkLiteral:forInstruction: */
static NoDbgRegParms AbstractInstruction *
checkLiteralforInstruction(sqInt literal, AbstractInstruction *anInstruction)
{
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(literal, BytesPerOop));
	}
	return anInstruction;
}


/*	Output all pending literal instructions, making the originals dependents
	on the generated ones
	so that a later pass will copy the address of each generated literal inst
	to its original in literals,
	and hence allow the instruction using the literal to compute the correct
	address. 
	Override to segregate 64-bit and 32-bit literals */

	/* OutOfLineLiteralsManagerFor64Bits>>#dumpLiterals: */
static NoDbgRegParms sqInt
dumpLiterals(sqInt generateBranchAround)
{
    AbstractInstruction *cascade0;
    AbstractInstruction *cascade1;
    sqInt i;
    AbstractInstruction *jump;
    AbstractInstruction *litInst;

	jump = ((AbstractInstruction *) 0);
	if (generateBranchAround) {
		jump = genoperand(Jump, ((sqInt)0));
	}
	genoperand(AlignmentNops, 8 /* literalAlignment */);
	for (i = lastDumpedLiteralIndex; i < nextLiteralIndex; i += 1) {
		litInst = literalInstructionAt(i);
		if (((/* begin literalSize */
			assert(((litInst->opcode)) == Literal),
		(((litInst->operands))[1]
					? (((((litInst->operands))[1])) >> 1) & 15
					: BytesPerOop))) == 8) {
			cascade0 = genoperand(Literal, ((litInst->operands))[0]);
			(cascade0->dependent = litInst);
			setLiteralSize(cascade0, 8);

			/* begin setLiteralOpcodeIndex: */
			assert(((litInst->opcode)) == Literal);
			((litInst->operands))[2] = opcodeIndex;
		}
	}
	for (i = lastDumpedLiteralIndex; i < nextLiteralIndex; i += 1) {
		litInst = literalInstructionAt(i);
		if (((/* begin literalSize */
			assert(((litInst->opcode)) == Literal),
		(((litInst->operands))[1]
					? (((((litInst->operands))[1])) >> 1) & 15
					: BytesPerOop))) == 4) {
			cascade1 = genoperand(Literal, ((litInst->operands))[0]);
			(cascade1->dependent = litInst);
			setLiteralSize(cascade1, 4);

			/* begin setLiteralOpcodeIndex: */
			assert(((litInst->opcode)) == Literal);
			((litInst->operands))[2] = opcodeIndex;
		}
	}
	if (generateBranchAround) {
		jmpTarget(jump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	firstOpcodeIndex = opcodeIndex;
	lastDumpedLiteralIndex = nextLiteralIndex;
	return 0;
}


/*	Search for a Literal instruction that is in-range and answer it. Otherwise
	allocate a new sharable Literal instruction for the literal and answer it. */

	/* OutOfLineLiteralsManagerFor64Bits>>#locateLiteral:size: */
static NoDbgRegParms AbstractInstruction *
locateLiteralsize(sqInt aLiteral, sqInt litSize)
{
    AbstractInstruction *existingInst;
    sqInt i;
    sqInt initialNumLiterals;
    sqInt iSqInt;
    AbstractInstruction *litInst;
    AbstractInstruction *newInst;
    AbstractInstruction *newLiterals;

	for (i = 0; i < nextLiteralIndex; i += 1) {
		litInst = literalInstructionAt(i);
		if ((((/* begin literalSize */
			assert(((litInst->opcode)) == Literal),
		(((litInst->operands))[1]
					? (((((litInst->operands))[1])) >> 1) & 15
					: BytesPerOop))) == litSize)
		 && (((((litInst->operands))[0]) == aLiteral)
		 && (((/* begin isSharable */
			assert(((litInst->opcode)) == Literal),
		(((((litInst->operands))[1]) & 1) != 0)))
		 && (literalInstructionInRange(litInst))))) {
			return litInst;
		}
	}
	if (nextLiteralIndex >= literalsSize) {
		initialNumLiterals = literalsSize + 8;

		/* begin allocateLiterals: */
		if (initialNumLiterals > literalsSize) {
			/* Must copy across state (not using realloc, cuz...) and
			   must also update existing instructions to refer to the new ones...
			   It's either this or modify all generation routines to be able to retry
			   with more literals after running out of literals. */
			newLiterals = calloc(initialNumLiterals, sizeof(CogAbstractInstruction));
			if (literals) {
				for (iSqInt = 0; iSqInt < nextLiteralIndex; iSqInt += 1) {
					existingInst = literalInstructionAt(iSqInt);
					newInst = (&(newLiterals[iSqInt]));
					cloneLiteralFrom(newInst, existingInst);
					assert(!((existingInst->dependent)));
					(existingInst->dependent = newInst);
				}
				for (iSqInt = 0; iSqInt < opcodeIndex; iSqInt += 1) {
					existingInst = abstractInstructionAt(iSqInt);
					if ((((existingInst->dependent)))
					 && (((((existingInst->dependent))->opcode)) == Literal)) {
						(existingInst->dependent = (((existingInst->dependent))->dependent));
					}
				}
			}
			free(literals);
			literals = newLiterals;
			literalsSize = initialNumLiterals;
		}
	}
	litInst = literalInstructionAt(nextLiteralIndex);
	initializeSharableLiteral(litInst, aLiteral);
	setLiteralSize(litInst, litSize);

	/* Record the opcodeIndex of the first dependent instruction (the first instruction that references an out-of-line literal) */
	nextLiteralIndex += 1;
	if (firstOpcodeIndex > opcodeIndex) {
		firstOpcodeIndex = opcodeIndex - 1;
	}
	return litInst;
}

	/* SimpleStackBasedCogit>>#cogMethodHasExternalPrim: */
sqInt
cogMethodHasExternalPrim(CogMethod *aCogMethod)
{
    sqInt primIndex;

	primIndex = primitiveIndexOfMethodheader((aCogMethod->methodObject), (aCogMethod->methodHeader));
	return (primIndex == PrimNumberExternalCall)
	 || (primIndex == PrimNumberFFICall);
}

	/* SimpleStackBasedCogit>>#cogMethodHasMachineCodePrim: */
sqInt
cogMethodHasMachineCodePrim(CogMethod *aCogMethod)
{
    sqInt primIndex;

	primIndex = primitiveIndexOfMethodheader((aCogMethod->methodObject), (aCogMethod->methodHeader));
	return (((primIndex >= 1) && (primIndex <= MaxCompiledPrimitiveIndex)))
	 && ((((primitiveGeneratorTable[primIndex]).primitiveGenerator)));
}


/*	Compile the jump instruction(s) at the end of the method that dispatch to
	each block body.
 */

	/* SimpleStackBasedCogit>>#compileBlockDispatch */
static sqInt
compileBlockDispatch(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSkip;

	assert(blockCount > 0);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	blockEntryNoContextSwitch = anInstruction;

	/* Set OK to context switch flag to non-zero. */
	jumpSkip = genoperand(Jump, ((sqInt)0));
	blockEntryLabel = genoperandoperand(MoveRR, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jumpSkip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (blockCount > 1) {
		genLoadSlotsourceRegdestReg(ClosureStartPCIndex, ReceiverResultReg, TempReg);
	}
	compileBlockDispatchFromto(0, blockCount - 1);
	return 0;
}


/*	After pushing the temporaries but before the stack limit check a primitive
	method needs to fetch the error code, if any. If the primitive has failed,
	call the trampoline
	that will assign it to the last temp. */

	/* SimpleStackBasedCogit>>#compileGetErrorCode */
static void
compileGetErrorCode(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmpNoError;

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));
	flag("ask concrete code gen if move sets condition codes?");

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jmpNoError = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), ClassReg))));

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceReapAndResetErrorCodeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(jmpNoError, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
}

	/* SimpleStackBasedCogit>>#compileInterpreterPrimitive */
static sqInt
compileInterpreterPrimitive(void)
{
    sqInt flags;
    void (*primitiveRoutine)(void);

	flags = 0;
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, (&flags));
	if (((flags & PrimCallOnSmalltalkStack) != 0)) {
		return compileOnStackExternalPrimitiveflags(primitiveRoutine, flags);
	}
	return compileInterpreterPrimitiveflags(primitiveRoutine, flags);
}


/*	Compile a call to an interpreter primitive. Call the C routine with the
	usual stack-switching dance, test the primFailCode and then either
	return on success or continue to the method body. */

	/* SimpleStackBasedCogit>>#compileInterpreterPrimitive:flags: */
static NoDbgRegParms sqInt
compileInterpreterPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *continueAfterProfileSample;
    AbstractInstruction *jmp;
    AbstractInstruction *jumpToTakeSample;
    sqInt offset;
    sqInt reg;
    AbstractInstruction *skip;

	jumpToTakeSample = ((AbstractInstruction *) 0);
	assert(!((registerisInMask(VarBaseReg, ABICallerSavedRegisterMask))));
	genExternalizePointersForPrimitiveCall();

	/* begin genLoadCStackPointersForPrimCall */
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	if (recordPrimTraceForMethod(methodObj)) {
		genFastPrimTraceUsingand(ClassReg, SendNumArgsReg);
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveRAw, TempReg, primFailCodeAddress()));
	if (methodOrBlockNumArgs) {
		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, methodOrBlockNumArgs, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(methodOrBlockNumArgs, BytesPerOop));
		}
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(argumentCountAddress(), genoperandoperand(MoveRAw, TempReg, argumentCountAddress()));
	if (((flags & PrimCallNeedsNewMethod) != 0)) {
		genLoadNewMethod();
	}

	/* #PrefetchAw: #gen:literal: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperand(PrefetchAw, primFailCodeAddress()));
	if (((flags & PrimCallMayEndureCodeCompaction) != 0)) {

		/* The ceActivateFailingPrimitiveMethod: machinery can't handle framelessness. */
		needsFrame = 1;
		genMarshallNArgsargargargarg(backEnd, 0, null, null, null, null);

		/* #genSubstituteReturnAddress: #MoveCw:R: #gen:literal:operand: */
		checkLiteralforInstruction((((flags & PrimCallCollectsProfileSamples) != 0)
				? cePrimReturnEnterCogCodeProfiling
				: cePrimReturnEnterCogCode), genoperandoperand(MoveCwR, (((flags & PrimCallCollectsProfileSamples) != 0)
				? cePrimReturnEnterCogCodeProfiling
				: cePrimReturnEnterCogCode), LR));

		/* #JumpFullRT: #JumpFull: #gen:literal: */
		checkLiteralforInstruction(((sqInt)(((sqInt)primitiveRoutine))), genoperand(JumpFull, ((sqInt)(((sqInt)primitiveRoutine)))));
		return 0;
	}
	genMarshallNArgsargargargarg(backEnd, 0, null, null, null, null);

	/* #CallFullRT: #CallFull: #gen:literal: */
	checkLiteralforInstruction(((sqInt)primitiveRoutine), genoperand(CallFull, ((sqInt)primitiveRoutine)));

	/* genRemoveNArgsFromStack: */
	maybeCompileRetryOfonPrimitiveFailflags(primitiveRoutine, primitiveIndex, flags);
	genLoadStackPointersForPrimCall(backEnd, ClassReg);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));
	flag("ask concrete code gen if move sets condition codes?");

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* placing the test here attributes the tick to the primitive plus any checkForAndFollowForwardedPrimitiveState
	   scanning, but attributes all of a failing primitive to the current method (in ceStackOverflow: on frame build). */
	jmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (((flags & PrimCallCollectsProfileSamples) != 0)) {
		/* begin genCheckForProfileTimerTick: */
		reg = Arg0Reg;

		/* #MoveAw:R: #gen:literal:operand: */
		checkLiteralforInstruction(nextProfileTickAddress(), genoperandoperand(MoveAwR, nextProfileTickAddress(), Arg1Reg));
		anInstruction = genoperandoperand(CmpCqR, 0, Arg1Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		skip = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		gMovePerfCnt64RL(reg, (0));

		/* begin CmpR:R: */
		assert(!(0 /* (Arg1Reg = SPReg) */));
		genoperandoperand(CmpRR, Arg1Reg, reg);
		jumpToTakeSample = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	continueAfterProfileSample = genoperandoperandoperand(MoveMwrR, 0, SPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(continueAfterProfileSample)) {
		(continueAfterProfileSample->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* RetN: */
	genoperand(RetN, BytesPerWord);
	if (((flags & PrimCallCollectsProfileSamples) != 0)) {
		jmpTarget(jumpToTakeSample, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		genTakeProfileSample();
		genLoadStackPointerForPrimCall(backEnd, ClassReg);

		/* #MoveAw:R: #gen:literal:operand: */
		checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));

		/* Jump: */
		genoperand(Jump, ((sqInt)continueAfterProfileSample));
	}
	jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	offset = BytesPerWord * (methodOrBlockNumArgs);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	return 0;
}


/*	Compile a fast call of a C primitive using the current stack page,
	avoiding the stack switch except on failure.
	This convention still uses stackPointer and argumentCount to access
	operands. Push all operands to the stack,
	assign stackPointer, argumentCount, and zero primFailCode. Make the call
	(saving a LinkReg if required).
	Test for failure and return. On failure on Spur, if there is an accessor
	depth, assign framePointer and newMethod,
	do the stack switch, call checkForAndFollowForwardedPrimitiveState, and
	loop back if forwarders are found.
	Fall through to frame build. */

	/* SimpleStackBasedCogit>>#compileOnStackExternalPrimitive:flags: */
static NoDbgRegParms sqInt
compileOnStackExternalPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt calleeSavedRegisterMask;
    AbstractInstruction *continueAfterProfileSample;
    AbstractInstruction *jmpFail;
    AbstractInstruction *jumpToTakeSample;
    sqInt linkRegSaveRegister;
    sqInt offset;
    sqInt reg;
    AbstractInstruction *retry;
    AbstractInstruction *skip;
    AbstractInstruction *skip1;
    sqInt spRegSaveRegister;

	jumpToTakeSample = ((AbstractInstruction *) 0);
	assert(((flags & PrimCallOnSmalltalkStack) != 0));
	assert(!((registerisInMask(VarBaseReg, ABICallerSavedRegisterMask))));
	if (recordFastCCallPrimTraceForMethod(methodObj)) {
		genFastPrimTraceUsingand(ClassReg, SendNumArgsReg);
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveRAw, TempReg, primFailCodeAddress()));
	if (methodOrBlockNumArgs) {
		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, methodOrBlockNumArgs, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(methodOrBlockNumArgs, BytesPerOop));
		}
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(argumentCountAddress(), genoperandoperand(MoveRAw, TempReg, argumentCountAddress()));
	genExternalizeStackPointerForFastPrimitiveCall();
	calleeSavedRegisterMask = ((ABICalleeSavedRegisterMask | ((1U << ClassReg))) - ((1U << ClassReg)));
	linkRegSaveRegister = availableRegisterOrNoneIn(calleeSavedRegisterMask);
	assert(!((linkRegSaveRegister == NoReg)));

	/* MoveR:R: */
	genoperandoperand(MoveRR, LinkReg, linkRegSaveRegister);
	calleeSavedRegisterMask = ((calleeSavedRegisterMask | (((linkRegSaveRegister < 0) ? (((usqInt)(1)) >> (-linkRegSaveRegister)) : (1ULL << linkRegSaveRegister)))) - (((linkRegSaveRegister < 0) ? (((usqInt)(1)) >> (-linkRegSaveRegister)) : (1ULL << linkRegSaveRegister))));
	spRegSaveRegister = NoReg;
	if (!(((ABICalleeSavedRegisterMask & ((1U << SPReg))) != 0))) {
		spRegSaveRegister = availableRegisterOrNoneIn(calleeSavedRegisterMask);
		assert(!((spRegSaveRegister == NoReg)));

		/* MoveR:R: */
		genoperandoperand(MoveRR, SPReg, spRegSaveRegister);
	}
	retry = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (((flags & PrimCallOnSmalltalkStackAlign2x) != 0)) {
		gAndCqRR((-1 - (((BytesPerWord * 2) - 1))), SPReg, NativeSPReg);
	}
	else {
		genLoadNativeSPRegWithAlignedSPReg(backEnd);
	}
	genMarshallNArgsargargargarg(backEnd, 0, null, null, null, null);
	if (((!(flags & PrimCallIsExternalCall)))
	 && (isInImmediateBranchAndLinkRange(backEnd, maximumDistanceFromCodeZone(((sqInt)primitiveRoutine))))) {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ((sqInt)primitiveRoutine));
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* #CallFullRT: #CallFull: #gen:literal: */
		checkLiteralforInstruction(((sqInt)primitiveRoutine), genoperand(CallFull, ((sqInt)primitiveRoutine)));
	}

	/* genRemoveNArgsFromStack: */

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));
	if (spRegSaveRegister != NoReg) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, spRegSaveRegister, SPReg);
	}

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* Remember to restore the native stack pointer to point to the C stack,
	   otherwise the Smalltalk frames will get overwritten on an interrupt. */
	jmpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadCStackPointer(backEnd);
	if (((flags & PrimCallCollectsProfileSamples) != 0)) {
		/* begin genCheckForProfileTimerTick: */
		reg = Arg0Reg;

		/* #MoveAw:R: #gen:literal:operand: */
		checkLiteralforInstruction(nextProfileTickAddress(), genoperandoperand(MoveAwR, nextProfileTickAddress(), Arg1Reg));
		anInstruction = genoperandoperand(CmpCqR, 0, Arg1Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		skip1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		gMovePerfCnt64RL(reg, (0));

		/* begin CmpR:R: */
		assert(!(0 /* (Arg1Reg = SPReg) */));
		genoperandoperand(CmpRR, Arg1Reg, reg);
		jumpToTakeSample = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		jmpTarget(skip1, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}

	/* get result and restore retpc */
	continueAfterProfileSample = checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveAwR, stackPointerAddress(), TempReg));

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, TempReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	gAddCqRR(BytesPerWord, TempReg, SPReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, linkRegSaveRegister, LinkReg);

	/* RetN: */
	genoperand(RetN, 0);
	if (((flags & PrimCallCollectsProfileSamples) != 0)) {
		jmpTarget(jumpToTakeSample, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		genTakeProfileSample();

		/* Jump: */
		genoperand(Jump, ((sqInt)continueAfterProfileSample));
	}
	jmpTarget(jmpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if ((accessorDepthForPrimitiveMethod(methodObj)) >= 0) {

		/* Given that following primitive state to the accessor depth is recursive, we're asking for
		   trouble if we run the fixup on the Smalltalk stack page.  Run it on the full C stack instead.
		   This won't be a performance issue since primitive failure should be very rare. */
		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(framePointerAddress(), genoperandoperand(MoveRAw, FPReg, framePointerAddress()));

		/* #MoveCw:R: #gen:literal:operand: */
		checkLiteralforInstruction(((sqInt)primitiveRoutine), genoperandoperand(MoveCwR, ((sqInt)primitiveRoutine), TempReg));

		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(primitiveFunctionPointerAddress(), genoperandoperand(MoveRAw, TempReg, primitiveFunctionPointerAddress()));
		genLoadNewMethod();

		/* begin genLoadCStackPointersForPrimCall */
		if (cFramePointerInUse) {
			genLoadCStackPointers(backEnd);
		}
		else {
			genLoadCStackPointer(backEnd);
		}
		genMarshallNArgsargargargarg(backEnd, 0, 0, 0, 0, 0);
		if (isInImmediateBranchAndLinkRange(backEnd, maximumDistanceFromCodeZone(((usqIntptr_t)checkForAndFollowForwardedPrimitiveState)))) {
			/* begin CallRT: */
			abstractInstruction = genoperand(Call, ((usqIntptr_t)checkForAndFollowForwardedPrimitiveState));
			(abstractInstruction->annotation = IsRelativeCall);
		}
		else {
			/* #CallFullRT: #CallFull: #gen:literal: */
			checkLiteralforInstruction(((usqIntptr_t)checkForAndFollowForwardedPrimitiveState), genoperand(CallFull, ((usqIntptr_t)checkForAndFollowForwardedPrimitiveState)));
		}
		genLoadStackPointersForPrimCall(backEnd, ClassReg);

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 0, ABIResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		skip = genConditionalBranchoperand(JumpZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveRAw, TempReg, primFailCodeAddress()));

		/* Jump: */
		genoperand(Jump, ((sqInt)retry));
		jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	else {

		/* must reload SPReg to undo any alignment change, */
		if (((flags & PrimCallOnSmalltalkStackAlign2x) != 0)) {
			/* #MoveAw:R: #gen:literal:operand: */
			checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveAwR, stackPointerAddress(), SPReg));
		}
	}
	genLoadCStackPointer(backEnd);

	/* MoveR:R: */
	genoperandoperand(MoveRR, linkRegSaveRegister, LinkReg);
	if (((ABICallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)) {
		offset = (methodOrBlockNumArgs) * BytesPerWord;

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
	}
	return 0;
}


/*	Compile one method cache probe in an OpenPIC's lookup of selector.
	Answer the jump taken if the selector probe fails.
	The class tag of the receiver must be in SendNumArgsReg. ClassReg and
	TempReg are used as scratch registers.
	On a hit, the offset of the entry is in ClassReg. */

	/* SimpleStackBasedCogit>>#compileOpenPICMethodCacheProbeFor:withShift:baseRegOrNone: */
static NoDbgRegParms AbstractInstruction *
compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selector, sqInt shift, sqInt baseRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	maybeShiftClassTagRegisterForMethodCacheProbe(ClassReg);
	annotateobjRef(checkLiteralforInstruction(selector, genoperandoperand(XorCwR, selector, ClassReg)), selector);
	assert(shift <= (shiftForWord()));
	if (shift < (shiftForWord())) {
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - shift, ClassReg);
	}
	anInstruction = genoperandoperand(AndCqR, ((sqInt)((usqInt)(MethodCacheMask) << (shiftForWord()))), ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(((sqInt)((usqInt)(MethodCacheMask) << (shiftForWord()))), BytesPerOop));
	}
	if (baseRegOrNone == NoReg) {
		offset = (methodCacheAddress()) + ((((usqInt)(MethodCacheSelector) << (shiftForWord()))));

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
	}
	else {
		/* AddR:R: */
		genoperandoperand(AddRR, baseRegOrNone, ClassReg);

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, ((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord()))), ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord()))), BytesPerOop));
		}
	}
	annotateobjRef(checkLiteralforInstruction(selector, genoperandoperand(CmpCwR, selector, TempReg)), selector);
	jumpSelectorMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (baseRegOrNone == NoReg) {
		offset = (methodCacheAddress()) + ((((usqInt)(MethodCacheClass) << (shiftForWord()))));

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
	}
	else {
		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, ((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord()))), ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord()))), BytesPerOop));
		}
	}

	/* begin CmpR:R: */
	assert(!(0 /* (SendNumArgsReg = SPReg) */));
	genoperandoperand(CmpRR, SendNumArgsReg, TempReg);
	return jumpSelectorMiss;
}


/*	Compile the code for an open PIC. Perform a probe of the first-level
	method lookup cache followed by a call of ceSendFromInLineCacheMiss: if
	the probe fails. */

	/* SimpleStackBasedCogit>>#compileOpenPIC:numArgs: */
static NoDbgRegParms void
compileOpenPICnumArgs(sqInt selector, sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;

	/* begin preenMethodLabel */
	/* setLabelOffset: */
	((methodLabel->operands))[1] = 0;
	compilePICAbort(numArgs);
	entry = genGetClassTagOfintoscratchReg(ReceiverResultReg, SendNumArgsReg, TempReg);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 0, cacheBaseReg);

	/* Fetch the method.  The interpret trampoline requires the bytecoded method in SendNumArgsReg */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	offset = (cacheBaseReg == NoReg
				? (methodCacheAddress()) + ((((usqInt)(MethodCacheMethod) << (shiftForWord()))))
				: ((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))));

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	itsAHit = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(itsAHit)) {
		(itsAHit->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	jmpTarget(jumpBCMethod, picInterpretAbort);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(cmNoCheckEntryOffset, BytesPerOop));
	}

	/* JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 1, cacheBaseReg);

	/* JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 2, cacheBaseReg);

	/* JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	genSmalltalkToCStackSwitch(1);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), SendNumArgsReg))));
	compileCallFornumArgsargargargargresultRegregsToSave(ceSendFromInLineCacheMiss, 1, SendNumArgsReg, null, null, null, NoReg, 0 /* emptyRegisterMask */);
}


/*	Compile one method cache probe in a perform: primitive's lookup of
	selector. Answer the jump taken if the selector probe fails. */

	/* SimpleStackBasedCogit>>#compilePerformMethodCacheProbeFor:withShift:baseRegOrNone: */
static NoDbgRegParms AbstractInstruction *
compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selectorReg, sqInt shift, sqInt baseRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;

	/* MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	maybeShiftClassTagRegisterForMethodCacheProbe(ClassReg);

	/* XorR:R: */
	genoperandoperand(XorRR, selectorReg, ClassReg);
	assert(shift <= (shiftForWord()));
	if (shift < (shiftForWord())) {
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - shift, ClassReg);
	}
	anInstruction = genoperandoperand(AndCqR, ((sqInt)((usqInt)(MethodCacheMask) << (shiftForWord()))), ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(((sqInt)((usqInt)(MethodCacheMask) << (shiftForWord()))), BytesPerOop));
	}
	if (baseRegOrNone == NoReg) {
		offset = (methodCacheAddress()) + ((((usqInt)(MethodCacheSelector) << (shiftForWord()))));

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
	}
	else {
		/* AddR:R: */
		genoperandoperand(AddRR, baseRegOrNone, ClassReg);

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, ((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord()))), ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(((sqInt)((usqInt)(MethodCacheSelector) << (shiftForWord()))), BytesPerOop));
		}
	}

	/* begin CmpR:R: */
	assert(!((selectorReg == SPReg)));
	genoperandoperand(CmpRR, selectorReg, TempReg);
	jumpSelectorMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (baseRegOrNone == NoReg) {
		offset = (methodCacheAddress()) + ((((usqInt)(MethodCacheClass) << (shiftForWord()))));

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
	}
	else {
		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, ((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord()))), ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(((sqInt)((usqInt)(MethodCacheClass) << (shiftForWord()))), BytesPerOop));
		}
	}

	/* begin CmpR:R: */
	assert(!(0 /* (SendNumArgsReg = SPReg) */));
	genoperandoperand(CmpRR, SendNumArgsReg, TempReg);
	return jumpSelectorMiss;
}


/*	Compile a primitive. If possible, performance-critical primitives will
	be generated by their own routines (primitiveGenerator). Otherwise,
	if there is a primitive at all, we call the C routine with the usual
	stack-switching dance, test the primFailCode and then either return
	on success or continue to the method body. */

	/* SimpleStackBasedCogit>>#compilePrimitive */
static sqInt
compilePrimitive(void)
{
    AbstractInstruction *anInstruction;
    sqInt code;
    sqInt flags;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpNotSmallInteger;
    sqInt opcodeIndexAtPrimitive;
    PrimitiveDescriptor *primitiveDescriptor;
    void (*primitiveRoutine)(void);
    sqInt reg;

	flags = 0;
	primitiveDescriptor = ((PrimitiveDescriptor *) 0);
	if (!primitiveIndex) {
		return 0;
	}
	if ((((primitiveDescriptor = primitiveGeneratorOrNil())))
	 && ((((primitiveDescriptor->primitiveGenerator)))
	 && ((((primitiveDescriptor->primNumArgs)) < 0)
	 || (((primitiveDescriptor->primNumArgs)) == methodOrBlockNumArgs)))) {

		/* Note opcodeIndex so that any arg load instructions
		   for unimplemented primitives can be discarded. */
		opcodeIndexAtPrimitive = opcodeIndex;
		code = ((primitiveDescriptor->primitiveGenerator))();
		if ((code < 0)
		 && (code != UnimplementedPrimitive)) {

			/* Generator failed, so no point continuing... */
			return code;
		}
		if (code == UnfailingPrimitive) {
			return 0;
		}
		if ((code == CompletePrimitive)
		 && (!(/* methodUsesPrimitiveErrorCode:header: */
			((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
		 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))))) {
			return 0;
		}
		if (code == UnimplementedPrimitive) {
			opcodeIndex = opcodeIndexAtPrimitive;
		}
	}
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, (&flags));
	if ((primitiveRoutine == 0)
	 || (primitiveRoutine == (((void (*)(void)) primitiveFail)))) {
		return genFastPrimFail();
	}
	if ((primitiveRoutine == (((void (*)(void)) primitiveHighResClock)))
	 && (methodOrBlockNumArgs == 0)) {
		/* begin genPrimitiveHighResClock64 */
		reg = Arg0Reg;
		assert(registerisNotInMask(reg, registerMaskForandandand(ReceiverResultReg, Arg1Reg, Extra0Reg, Extra1Reg)));
		gMovePerfCnt64RL(reg, (0));
		gLogicalShiftRightCqRR((numSmallIntegerBits()) - 1, reg, Arg1Reg);

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 0, Arg1Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jumpNotSmallInteger = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		genConvertIntegerInRegtoSmallIntegerInReg(reg, ReceiverResultReg);

		/* genPrimReturn */
		if (methodOrBlockNumArgs <= (numRegArgs())) {
			/* RetN: */
			genoperand(RetN, 0);
		}
		else {
			/* RetN: */
			genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
		}
		jmpTarget(jumpNotSmallInteger, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		jumpFailAlloc = genAlloc64BitPositiveIntegerValueintoscratchRegscratchReg(reg, ReceiverResultReg, Extra0Reg, Extra1Reg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);

		/* genPrimReturn */
		if (methodOrBlockNumArgs <= (numRegArgs())) {
			/* RetN: */
			genoperand(RetN, 0);
		}
		else {
			/* RetN: */
			genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
		}
		jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		code = 0;
		if (code != UnimplementedPrimitive) {
			return code;
		}
	}
	if (((flags & PrimCallOnSmalltalkStack) != 0)) {
		return compileOnStackExternalPrimitiveflags(primitiveRoutine, flags);
	}
	return compileInterpreterPrimitiveflags(primitiveRoutine, flags);
}

	/* SimpleStackBasedCogit>>#extendedPushBytecode */
static sqInt
extendedPushBytecode(void)
{
    usqInt variableIndex;
    usqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (!variableType) {
		return genPushReceiverVariable(variableIndex);
	}
	if (variableType == 1) {
		return genPushTemporaryVariable(variableIndex);
	}
	if (variableType == 2) {
		return genPushLiteralIndex(variableIndex);
	}
	return genPushLiteralVariable(variableIndex);
}

	/* SimpleStackBasedCogit>>#extendedStoreAndPopBytecode */
static sqInt
extendedStoreAndPopBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    usqInt variableIndex;
    usqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (!variableType) {
		return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, variableIndex, /* ssTopNeedsStoreCheck */
			((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (/* shouldAnnotateObjectReference: */
			(isNonImmediate(((ssTop())->constant)))
		 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
		 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
	}
	if (variableType == 1) {
		genStorePopTemporaryVariable(1, variableIndex);
#    if IMMUTABILITY
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
#    endif // IMMUTABILITY

		return 0;
	}
	if (variableType == 3) {
		return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(1, variableIndex, /* ssTopNeedsStoreCheck */
			((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (/* shouldAnnotateObjectReference: */
			(isNonImmediate(((ssTop())->constant)))
		 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
		 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
	}
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#extendedStoreBytecode */
static sqInt
extendedStoreBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    usqInt variableIndex;
    usqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (!variableType) {
		return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(0, variableIndex, /* ssTopNeedsStoreCheck */
			((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (/* shouldAnnotateObjectReference: */
			(isNonImmediate(((ssTop())->constant)))
		 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
		 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
	}
	if (variableType == 1) {
		genStorePopTemporaryVariable(0, variableIndex);
#    if IMMUTABILITY
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
#    endif // IMMUTABILITY

		return 0;
	}
	if (variableType == 3) {
		return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(0, variableIndex, /* ssTopNeedsStoreCheck */
			((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (/* shouldAnnotateObjectReference: */
			(isNonImmediate(((ssTop())->constant)))
		 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
		 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
	}
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#frameOffsetOfNativeFrameMark */
static int
frameOffsetOfNativeFrameMark(void)
{
	return FoxMFReceiver - BytesPerWord;
}

	/* SimpleStackBasedCogit>>#frameOffsetOfNativeFramePointer */
static int
frameOffsetOfNativeFramePointer(void)
{
	return FoxMFReceiver - (BytesPerWord * 3);
}

	/* SimpleStackBasedCogit>>#frameOffsetOfNativeStackPointer */
static int
frameOffsetOfNativeStackPointer(void)
{
	return FoxMFReceiver - (BytesPerWord * 4);
}

	/* SimpleStackBasedCogit>>#frameOffsetOfPreviousNativeStackPointer */
static int
frameOffsetOfPreviousNativeStackPointer(void)
{
	return FoxMFReceiver - (BytesPerWord * 2);
}

	/* SimpleStackBasedCogit>>#frameOffsetOfTemporary: */
static NoDbgRegParms sqInt
frameOffsetOfTemporary(sqInt index)
{
	return /* frameOffsetOfTemporary:numArgs: */
		(index < methodOrBlockNumArgs
			? FoxCallerSavedIP + ((methodOrBlockNumArgs - index) * BytesPerWord)
			: (FoxMFReceiver - BytesPerWord) + ((methodOrBlockNumArgs - index) * BytesPerWord));
}


/*	Implemented with SistaCogit only */

	/* SimpleStackBasedCogit>>#genCallMappedInlinedPrimitive */
static sqInt
genCallMappedInlinedPrimitive(void)
{
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#genDoubleFailIfZeroArgRcvr:arg: */
static NoDbgRegParms AbstractInstruction *
genDoubleFailIfZeroArgRcvrarg(int rcvrReg, int argReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* ConvertR:Rd: */
	genoperandoperand(ConvertRRd, TempReg, DPFPReg2);

	/* CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg2, argReg);
	return gJumpFPEqual(0);
}


/*	Can use any of the first 32 literals for the selector and pass up to 7
	arguments. 
 */

	/* SimpleStackBasedCogit>>#genExtendedSendBytecode */
static sqInt
genExtendedSendBytecode(void)
{
	return genSendnumArgs(byte1 & 0x1F, ((usqInt)(byte1)) >> 5);
}

	/* SimpleStackBasedCogit>>#genExtendedSuperBytecode */
static sqInt
genExtendedSuperBytecode(void)
{
	return genSendSupernumArgs(byte1 & 0x1F, ((usqInt)(byte1)) >> 5);
}


/*	244		11110100	i i i i i i i i	Pop and Jump 0n False i i i i i i i i (+
	Extend B * 256, where Extend B >= 0)
 */

	/* SimpleStackBasedCogit>>#genExtJumpIfFalse */
static sqInt
genExtJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = byte1 + ((((usqInt)(extB) << 8)));
	assert(distance == (v4LongForwardBranchDistance(generatorAt(byte0), bytecodePC, ((extA != 0
		? 1
		: 0)) + ((extB != 0
		? 1
		: 0)), methodObj)));
	extB = 0;
	numExtB = 0;
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}


/*	243		11110011	i i i i i i i i	Pop and Jump 0n True i i i i i i i i (+
	Extend B * 256, where Extend B >= 0)
 */

	/* SimpleStackBasedCogit>>#genExtJumpIfTrue */
static sqInt
genExtJumpIfTrue(void)
{
    sqInt distance;
    sqInt target;

	distance = byte1 + ((((usqInt)(extB) << 8)));
	assert(distance == (v4LongForwardBranchDistance(generatorAt(byte0), bytecodePC, ((extA != 0
		? 1
		: 0)) + ((extB != 0
		? 1
		: 0)), methodObj)));
	extB = 0;
	numExtB = 0;
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(trueObject(), target);
}


/*	NewspeakV4: 221		11011101		Nop */
/*	SistaV1:		 91		01011011'		Nop */

	/* SimpleStackBasedCogit>>#genExtNopBytecode */
static sqInt
genExtNopBytecode(void)
{
	extA = (numExtB = (extB = 0));
	return 0;
}


/*	SistaV1:		233		11101001	iiiiiiii		Push Character #iiiiiiii (+ Extend A *
	256) 
 */

	/* SimpleStackBasedCogit>>#genExtPushCharacterBytecode */
static sqInt
genExtPushCharacterBytecode(void)
{
    sqInt literal;
    sqInt value;

	value = byte1 + ((((usqInt)(extA) << 8)));
	extA = 0;
	literal = characterObjectOf(value);

	/* begin genPushLiteral: */
	return ssPushConstant(literal);
}


/*	NewsqueakV4:	229		11100101	iiiiiiii	Push Integer #iiiiiiii (+ Extend B *
	256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
	SistaV1:		232		11101000	iiiiiiii	Push Integer #iiiiiiii (+ Extend B * 256,
	where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
 */

	/* SimpleStackBasedCogit>>#genExtPushIntegerBytecode */
static sqInt
genExtPushIntegerBytecode(void)
{
    sqInt value;

	value = byte1 + ((((usqInt)(extB) << 8)));
	extB = 0;
	numExtB = 0;
	return ssPushConstant((((usqInt)value << 3) | 1));
}


/*	228		11100100	i i i i i i i i	Push Literal #iiiiiiii (+ Extend A * 256) */

	/* SimpleStackBasedCogit>>#genExtPushLiteralBytecode */
static sqInt
genExtPushLiteralBytecode(void)
{
    sqInt index;

	index = byte1 + ((((usqInt)(extA) << 8)));
	extA = 0;
	return genPushLiteralIndex(index);
}


/*	227		11100011	i i i i i i i i	Push Literal Variable #iiiiiiii (+ Extend A
	* 256)
 */

	/* SimpleStackBasedCogit>>#genExtPushLiteralVariableBytecode */
static sqInt
genExtPushLiteralVariableBytecode(void)
{
    sqInt index;

	index = byte1 + ((((usqInt)(extA) << 8)));
	extA = 0;
	return genPushLiteralVariable(index);
}


/*	SistaV1: *	82			01010010			Push thisContext, (then Extend B = 1 => push
	thisProcess) 
 */

	/* SimpleStackBasedCogit>>#genExtPushPseudoVariable */
static sqInt
genExtPushPseudoVariable(void)
{
    sqInt ext;

	ext = extB;
	extB = 0;
	numExtB = 0;
	switch (ext) {
	case 0:
		return genPushActiveContextBytecode();

	default:
		return EncounteredUnknownBytecode;
	}
	return 0;
}


/*	226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A
	* 256)
 */

	/* SimpleStackBasedCogit>>#genExtPushReceiverVariableBytecode */
static sqInt
genExtPushReceiverVariableBytecode(void)
{
    sqInt index;

	index = byte1 + ((((usqInt)(extA) << 8)));
	extA = 0;
	return ((mclassCouldBeContext())
	 && (isReadMediatedContextInstVarIndex(index))
			? genPushMaybeContextReceiverVariable(index)
			: genPushReceiverVariable(index));
}


/*	238		11101110	i i i i i j j j	Send Literal Selector #iiiii (+ Extend A *
	32) with jjj (+ Extend B * 8) Arguments
 */

	/* SimpleStackBasedCogit>>#genExtSendBytecode */
static sqInt
genExtSendBytecode(void)
{
    sqInt litIndex;
    usqInt nArgs;

	litIndex = (((usqInt)(byte1)) >> 3) + ((((usqInt)(extA) << 5)));
	extA = 0;
	nArgs = (byte1 & 7) + ((((usqInt)(extB) << 3)));
	extB = 0;
	numExtB = 0;
	return genSendnumArgs(litIndex, nArgs);
}


/*	239		11101111	i i i i i j j j	Send To Superclass Literal Selector #iiiii
	(+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
 */

	/* SimpleStackBasedCogit>>#genExtSendSuperBytecode */
static sqInt
genExtSendSuperBytecode(void)
{
    int isDirected;
    sqInt litIndex;
    usqInt nArgs;

	if ((isDirected = extB >= 64)) {
		extB = extB & 0x3F;
	}
	litIndex = (((usqInt)(byte1)) >> 3) + ((((usqInt)(extA) << 5)));
	extA = 0;
	nArgs = (byte1 & 7) + ((((usqInt)(extB) << 3)));
	extB = 0;
	numExtB = 0;
	return (isDirected
			? genSendDirectedSupernumArgs(litIndex, nArgs)
			: genSendSupernumArgs(litIndex, nArgs));
}


/*	236		11101100	i i i i i i i i	Pop and Store Literal Variable #iiiiiiii (+
	Extend A * 256)
 */

	/* SimpleStackBasedCogit>>#genExtStoreAndPopLiteralVariableBytecode */
static sqInt
genExtStoreAndPopLiteralVariableBytecode(void)
{
    sqInt index;

	index = byte1 + ((((usqInt)(extA) << 8)));
	extA = 0;
	return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(1, index, /* ssTopNeedsStoreCheck */
		((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (/* shouldAnnotateObjectReference: */
		(isNonImmediate(((ssTop())->constant)))
	 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
	 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
}


/*	235		11101011	i i i i i i i i	Pop and Store Receiver Variable #iiiiiii (+
	Extend A * 256)
 */

	/* SimpleStackBasedCogit>>#genExtStoreAndPopReceiverVariableBytecode */
static sqInt
genExtStoreAndPopReceiverVariableBytecode(void)
{
    sqInt index;

	index = byte1 + ((((usqInt)(extA) << 8)));
	extA = 0;
	return ((mclassCouldBeContext())
	 && (isWriteMediatedContextInstVarIndex(index))
			? genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, index, /* ssTopNeedsStoreCheck */
				((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (/* shouldAnnotateObjectReference: */
				(isNonImmediate(((ssTop())->constant)))
			 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
			 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1)
			: genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, index, /* ssTopNeedsStoreCheck */
				((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (/* shouldAnnotateObjectReference: */
				(isNonImmediate(((ssTop())->constant)))
			 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
			 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1));
}


/*	233		11101001	i i i i i i i i	Store Literal Variable #iiiiiiii (+ Extend A
	* 256)
 */

	/* SimpleStackBasedCogit>>#genExtStoreLiteralVariableBytecode */
static sqInt
genExtStoreLiteralVariableBytecode(void)
{
    sqInt index;

	index = byte1 + ((((usqInt)(extA) << 8)));
	extA = 0;
	return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(0, index, /* ssTopNeedsStoreCheck */
		((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (/* shouldAnnotateObjectReference: */
		(isNonImmediate(((ssTop())->constant)))
	 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
	 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
}


/*	232		11101000	i i i i i i i i	Store Receiver Variable #iiiiiii (+ Extend A
	* 256)
 */

	/* SimpleStackBasedCogit>>#genExtStoreReceiverVariableBytecode */
static sqInt
genExtStoreReceiverVariableBytecode(void)
{
    sqInt index;

	index = byte1 + ((((usqInt)(extA) << 8)));
	extA = 0;
	return ((mclassCouldBeContext())
	 && (isWriteMediatedContextInstVarIndex(index))
			? genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(0, index, /* ssTopNeedsStoreCheck */
				((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (/* shouldAnnotateObjectReference: */
				(isNonImmediate(((ssTop())->constant)))
			 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
			 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1)
			: genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(0, index, /* ssTopNeedsStoreCheck */
				((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (/* shouldAnnotateObjectReference: */
				(isNonImmediate(((ssTop())->constant)))
			 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
			 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1));
}


/*	242		11110010	i i i i i i i i	Jump i i i i i i i i (+ Extend B * 256,
	where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
 */

	/* SimpleStackBasedCogit>>#genExtUnconditionalJump */
static sqInt
genExtUnconditionalJump(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt distance;
    sqInt target;

	distance = byte1 + ((((usqInt)(extB) << 8)));
	assert(distance == (v4LongBranchDistance(generatorAt(byte0), bytecodePC, ((extA != 0
		? 1
		: 0)) + ((extB != 0
		? 1
		: 0)), methodObj)));
	extB = 0;
	numExtB = 0;
	target = (distance + 2) + bytecodePC;
	if (distance < 0) {
		return genJumpBackTo(target);
	}
	genJumpTo(target);
	abstractInstruction = lastOpcode();

	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);
	return 0;
}

	/* SimpleStackBasedCogit>>#genFastPrimFail */
static sqInt
genFastPrimFail(void)
{
	primitiveIndex = 0;
	return UnfailingPrimitive;
}


/*	Support for compileInterpreterPrimitive. Generate inline code
	so as to record the primitive trace as fast as possible. */

	/* SimpleStackBasedCogit>>#genFastPrimTraceUsing:and: */
static NoDbgRegParms void
genFastPrimTraceUsingand(sqInt r1, sqInt r2)
{
    AbstractInstruction *anInstruction;
    sqInt offset;


	/* #MoveAb:R: #gen:literal:operand: */
	checkLiteralforInstruction(primTraceLogIndexAddress(), genoperandoperand(MoveAbR, primTraceLogIndexAddress(), r2));

	/* begin LoadEffectiveAddressMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, 1, r2, r1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* #MoveR:Ab: #gen:operand:literal: */
	checkLiteralforInstruction(primTraceLogIndexAddress(), genoperandoperand(MoveRAb, r1, primTraceLogIndexAddress()));
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), r1))));
	offset = offsetof(CogMethod, methodObject);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, r1, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* #MoveCw:R: #gen:literal:operand: */
	checkLiteralforInstruction(((sqInt)(primTraceLogAddress())), genoperandoperand(MoveCwR, ((sqInt)(primTraceLogAddress())), r1));

	/* MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, r2, r1);
}

	/* SimpleStackBasedCogit>>#genLoadNewMethod */
static void
genLoadNewMethod(void)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), ClassReg))));
	offset = offsetof(CogMethod, methodObject);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(newMethodAddress(), genoperandoperand(MoveRAw, TempReg, newMethodAddress()));
#  if LRPCheck
	if (checkingLongRunningPrimitives()) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(longRunningPrimitiveStopUsecsAddress(), genoperandoperand(MoveRAw, TempReg, longRunningPrimitiveStopUsecsAddress()));
	}
#  endif // LRPCheck
}

	/* SimpleStackBasedCogit>>#genLongJumpIfFalse */
static sqInt
genLongJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = v3LongForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}

	/* SimpleStackBasedCogit>>#genLongJumpIfTrue */
static sqInt
genLongJumpIfTrue(void)
{
    sqInt distance;
    sqInt target;

	distance = v3LongForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(trueObject(), target);
}


/*	230		11100110	i i i i i i i i	Push Temporary Variable #iiiiiiii */

	/* SimpleStackBasedCogit>>#genLongPushTemporaryVariableBytecode */
static sqInt
genLongPushTemporaryVariableBytecode(void)
{
	return genPushTemporaryVariable(byte1);
}


/*	237		11101101	i i i i i i i i	Pop and Store Temporary Variable #iiiiiiii */

	/* SimpleStackBasedCogit>>#genLongStoreAndPopTemporaryVariableBytecode */
static sqInt
genLongStoreAndPopTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(1, byte1);
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */

	/* SimpleStackBasedCogit>>#genLongStoreTemporaryVariableBytecode */
static sqInt
genLongStoreTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(0, byte1);
}

	/* SimpleStackBasedCogit>>#genLongUnconditionalBackwardJump */
static sqInt
genLongUnconditionalBackwardJump(void)
{
    sqInt distance;

	distance = v3LongBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	assert(distance < 0);
	return genJumpBackTo((distance + 2) + bytecodePC);
}

	/* SimpleStackBasedCogit>>#genLongUnconditionalForwardJump */
static sqInt
genLongUnconditionalForwardJump(void)
{
    sqInt distance;
    sqInt targetpc;

	distance = v3LongBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	assert(distance >= 0);
	targetpc = (distance + 2) + bytecodePC;
	return genJumpTo(targetpc);
}


/*	Compile the code for a probe of the first-level method cache for a perform
	primitive. The selector is assumed to be in Arg0Reg. Defer to
	adjustArgumentsForPerform: to
	adjust the arguments before the jump to the method. */
/*	N.B. Can't assume TempReg already contains the tag because a method can
	of course be invoked via the unchecked entry-point, e.g. as does perform:. */

	/* SimpleStackBasedCogit>>#genLookupForPerformNumArgs: */
static NoDbgRegParms sqInt
genLookupForPerformNumArgs(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBadNumArgs;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpInterpret;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;

	genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, SendNumArgsReg, 0);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 0, cacheBaseReg);

	/* Fetch the method, and check if it is cogged. */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	offset = (cacheBaseReg == NoReg
				? (methodCacheAddress()) + ((((usqInt)(MethodCacheMethod) << (shiftForWord()))))
				: ((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))));

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	itsAHit = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(itsAHit)) {
		(itsAHit->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);

	/* check the argument count; if it's wrong fall back on the interpreter primitive. */
	jumpInterpret = genJumpImmediate(ClassReg);

	/* begin genLoadcmNumArgsOf:into: */
	anInstruction = genoperandoperandoperand(MoveMbrR, BytesPerWord, ClassReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
	}

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, numArgs, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(numArgs, BytesPerOop));
	}

	/* Adjust arguments and jump to the method's unchecked entry-point. */
	jumpBadNumArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(cmNoCheckEntryOffset, BytesPerOop));
	}
	adjustArgumentsForPerform(numArgs);

	/* JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 1, cacheBaseReg);

	/* JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 2, cacheBaseReg);

	/* JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpInterpret, jmpTarget(jumpBadNumArgs, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return 0;
}


/*	If the objectMemory allows it, generates a quick constant move, else
	generates a word constant move
 */

	/* SimpleStackBasedCogit>>#genMoveConstant:R: */
static NoDbgRegParms AbstractInstruction *
genMoveConstantR(sqInt constant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	if (/* shouldAnnotateObjectReference: */
		(isNonImmediate(constant))
	 && ((oopisGreaterThan(constant, classTableRootObj()))
	 || (oopisLessThan(constant, nilObject())))) {
		return annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(MoveCwR, constant, reg)), constant);
	}
	else {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, constant, reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
		}
		return anInstruction;
	}
}

	/* SimpleStackBasedCogit>>#genMustBeBooleanTrampolineFor:called: */
static NoDbgRegParms usqInt
genMustBeBooleanTrampolineForcalled(sqInt boolean, char *trampolineName)
{
    AbstractInstruction *anInstruction;

	zeroOpcodeIndex();
	assert(!(shouldAnnotateObjectReference(boolean)));

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, boolean, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(boolean, BytesPerOop));
	}
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceSendMustBeBoolean, trampolineName, 1, TempReg, null, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 1);
}


/*	Implement 28-bit hashMultiply for SmallInteger and LargePositiveInteger
	receivers. 
 */

	/* SimpleStackBasedCogit>>#genPrimitiveHashMultiply */
static sqInt
genPrimitiveHashMultiply(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmpFailImm;
    AbstractInstruction *jmpFailNotPositiveLargeInt;

	if (mclassIsSmallInteger()) {
		genConvertSmallIntegerToIntegerInReg(ReceiverResultReg);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, HashMultiplyConstant, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(HashMultiplyConstant, BytesPerOop));
		}

		/* MulR:R: */
		genMulRR(backEnd, TempReg, ReceiverResultReg);

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, HashMultiplyMask, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(HashMultiplyMask, BytesPerOop));
		}
		genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);

		/* RetN: */
		genoperand(RetN, 0);
		return CompletePrimitive;
	}
	jmpFailImm = genJumpImmediate(ReceiverResultReg);
	genGetCompactClassIndexNonImmOfinto(ReceiverResultReg, ClassReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, ClassLargePositiveIntegerCompactIndex, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(ClassLargePositiveIntegerCompactIndex, BytesPerOop));
	}
	jmpFailNotPositiveLargeInt = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, ReceiverResultReg, ReceiverResultReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, HashMultiplyConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(HashMultiplyConstant, BytesPerOop));
	}

	/* MulR:R: */
	genMulRR(backEnd, TempReg, ReceiverResultReg);

	/* begin AndCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, HashMultiplyMask, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(HashMultiplyMask, BytesPerOop));
	}
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);

	/* RetN: */
	genoperand(RetN, 0);
	jmpTarget(jmpFailImm, jmpTarget(jmpFailNotPositiveLargeInt, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	Generate the substitute return code for an external or FFI primitive call.
	On success simply return, extracting numArgs from newMethod.
	On primitive failure call ceActivateFailingPrimitiveMethod: newMethod. */

	/* SimpleStackBasedCogit>>#genPrimReturnEnterCogCodeEnilopmart: */
static NoDbgRegParms void
genPrimReturnEnterCogCodeEnilopmart(sqInt profiling)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *continuePostSample;
    AbstractInstruction *jmpFail;
    AbstractInstruction *jmpSample;
    sqInt quickConstant;
    sqInt reg;
    AbstractInstruction *skip;

	continuePostSample = ((AbstractInstruction *) 0);
	jmpSample = ((AbstractInstruction *) 0);
	zeroOpcodeIndex();
	quickConstant = varBaseAddress;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));
	flag("ask concrete code gen if move sets condition codes?");

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	jmpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (profiling) {
		/* begin genCheckForProfileTimerTick: */
		reg = Arg0Reg;

		/* #MoveAw:R: #gen:literal:operand: */
		checkLiteralforInstruction(nextProfileTickAddress(), genoperandoperand(MoveAwR, nextProfileTickAddress(), Arg1Reg));
		anInstruction = genoperandoperand(CmpCqR, 0, Arg1Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		skip = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		gMovePerfCnt64RL(reg, (0));

		/* begin CmpR:R: */
		assert(!(0 /* (Arg1Reg = SPReg) */));
		genoperandoperand(CmpRR, Arg1Reg, reg);
		jmpSample = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		jmpTarget(skip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		continuePostSample = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	genLoadStackPointers(backEnd);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, SPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));

	/* RetN: */
	genoperand(RetN, BytesPerWord);
	jmpTarget(jmpFail, checkLiteralforInstruction(newMethodAddress(), genoperandoperand(MoveAwR, newMethodAddress(), SendNumArgsReg)));

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveAwR, cStackPointerAddress(), SPReg));
	compileCallFornumArgsargargargargresultRegregsToSave(ceActivateFailingPrimitiveMethod, 1, SendNumArgsReg, null, null, null, NoReg, 0 /* emptyRegisterMask */);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));
	genLoadStackPointers(backEnd);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, SPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* RetN: */
	genoperand(RetN, BytesPerWord);
	if (profiling) {

		/* Call ceTakeProfileSample: to record sample and then continue.  newMethod
		   should be up-to-date.  Need to save and restore the link reg around this call. */
		jmpTarget(jmpSample, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		genMarshallNArgsargargargarg(backEnd,
			
			1,
			(/* begin trampolineArgConstant: */
				assert(null >= 0),
			-2 - null),
			null,
			null,
			null);

		/* #CallFullRT: #CallFull: #gen:literal: */
		checkLiteralforInstruction(((usqInt)ceTakeProfileSample), genoperand(CallFull, ((usqInt)ceTakeProfileSample)));

		/* genRemoveNArgsFromStack: */

		/* Jump: */
		genoperand(Jump, ((sqInt)continuePostSample));
	}
}

	/* SimpleStackBasedCogit>>#genPushConstantFalseBytecode */
static sqInt
genPushConstantFalseBytecode(void)
{
	return ssPushConstant(falseObject());
}

	/* SimpleStackBasedCogit>>#genPushConstantNilBytecode */
static sqInt
genPushConstantNilBytecode(void)
{
	return ssPushConstant(nilObject());
}


/*	79			01001111		Push 1 */

	/* SimpleStackBasedCogit>>#genPushConstantOneBytecode */
static sqInt
genPushConstantOneBytecode(void)
{
	return ssPushConstant((((usqInt)1 << 3) | 1));
}

	/* SimpleStackBasedCogit>>#genPushConstantTrueBytecode */
static sqInt
genPushConstantTrueBytecode(void)
{
	return ssPushConstant(trueObject());
}


/*	78			01001110		Push 0 */

	/* SimpleStackBasedCogit>>#genPushConstantZeroBytecode */
static sqInt
genPushConstantZeroBytecode(void)
{
	return ssPushConstant((((usqInt)0 << 3) | 1));
}

	/* SimpleStackBasedCogit>>#genPushLiteralConstantBytecode */
static sqInt
genPushLiteralConstantBytecode(void)
{
	return genPushLiteralIndex(byte0 & 0x1F);
}


/*	16-31		0001 i i i i		Push Literal Variable #iiii */

	/* SimpleStackBasedCogit>>#genPushLiteralVariable16CasesBytecode */
static sqInt
genPushLiteralVariable16CasesBytecode(void)
{
	return genPushLiteralVariable(byte0 & 15);
}

	/* SimpleStackBasedCogit>>#genPushLiteralVariableBytecode */
static sqInt
genPushLiteralVariableBytecode(void)
{
	return genPushLiteralVariable(byte0 & 0x1F);
}

	/* SimpleStackBasedCogit>>#genPushQuickIntegerConstantBytecode */
static sqInt
genPushQuickIntegerConstantBytecode(void)
{
	return ssPushConstant((((usqInt)(byte0 - 117) << 3) | 1));
}

	/* SimpleStackBasedCogit>>#genPushReceiverVariableBytecode */
static sqInt
genPushReceiverVariableBytecode(void)
{
	return genPushReceiverVariable(byte0 & 15);
}

	/* SimpleStackBasedCogit>>#genPushTemporaryVariableBytecode */
static sqInt
genPushTemporaryVariableBytecode(void)
{
	return genPushTemporaryVariable(byte0 & 15);
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnConst */
sqInt
genQuickReturnConst(void)
{
    AbstractInstruction *anInstruction;
    sqInt constant;

	constant = quickPrimitiveConstantFor(primitiveIndex);

	/* begin genMoveConstant:R: */
	if (/* shouldAnnotateObjectReference: */
		(isNonImmediate(constant))
	 && ((oopisGreaterThan(constant, classTableRootObj()))
	 || (oopisLessThan(constant, nilObject())))) {
		annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(MoveCwR, constant, ReceiverResultReg)), constant);
	}
	else {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
		}
	}
	genUpArrowReturn();
	return UnfailingPrimitive;
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnInstVar */
sqInt
genQuickReturnInstVar(void)
{
    sqInt index;

	index = quickPrimitiveInstVarIndexFor(primitiveIndex);
	genLoadSlotsourceRegdestReg(index, ReceiverResultReg, ReceiverResultReg);
	genUpArrowReturn();
	return UnfailingPrimitive;
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnSelf */
sqInt
genQuickReturnSelf(void)
{
	genUpArrowReturn();
	return UnfailingPrimitive;
}

	/* SimpleStackBasedCogit>>#genReturnFalse */
static sqInt
genReturnFalse(void)
{
    AbstractInstruction *anInstruction;

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
	}
	return genUpArrowReturn();
}

	/* SimpleStackBasedCogit>>#genReturnNil */
static sqInt
genReturnNil(void)
{
    AbstractInstruction *anInstruction;

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}
	return genUpArrowReturn();
}

	/* SimpleStackBasedCogit>>#genReturnNilFromBlock */
static sqInt
genReturnNilFromBlock(void)
{
    AbstractInstruction *anInstruction;

	assert(inBlock > 0);

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}
	return genBlockReturn();
}

	/* SimpleStackBasedCogit>>#genReturnTrue */
static sqInt
genReturnTrue(void)
{
    AbstractInstruction *anInstruction;

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, trueObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(trueObject(), BytesPerOop));
	}
	return genUpArrowReturn();
}


/*	Can use any of the first 64 literals for the selector and pass up to 3
	arguments. 
 */

	/* SimpleStackBasedCogit>>#genSecondExtendedSendBytecode */
static sqInt
genSecondExtendedSendBytecode(void)
{
	return genSendnumArgs(byte1 & 0x3F, ((usqInt)(byte1)) >> 6);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector0ArgsBytecode */
static sqInt
genSendLiteralSelector0ArgsBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 0);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector1ArgBytecode */
static sqInt
genSendLiteralSelector1ArgBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 1);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector2ArgsBytecode */
static sqInt
genSendLiteralSelector2ArgsBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 2);
}

	/* SimpleStackBasedCogit>>#genShortJumpIfFalse */
static sqInt
genShortJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}

	/* SimpleStackBasedCogit>>#genShortJumpIfTrue */
static sqInt
genShortJumpIfTrue(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpIfto(trueObject(), target);
}

	/* SimpleStackBasedCogit>>#genShortUnconditionalJump */
static sqInt
genShortUnconditionalJump(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpTo(target);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorEqualsEquals */
static sqInt
genSpecialSelectorEqualsEquals(void)
{
	return genInlinedIdenticalOrNotIf(0);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorNotEqualsEquals */
static sqInt
genSpecialSelectorNotEqualsEquals(void)
{
	return genInlinedIdenticalOrNotIf(1);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorSend */
static sqInt
genSpecialSelectorSend(void)
{
    sqInt index;
    sqInt numArgs;

	index = byte0 - (/* begin firstSpecialSelectorBytecodeOffset */
	(bytecodeSetOffset == 0x100
		? AltFirstSpecialSelector + 0x100
		: FirstSpecialSelector));
	numArgs = specialSelectorNumArgs(index);
	return genSendnumArgs((-index) - 1, numArgs);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopReceiverVariableBytecode */
static sqInt
genStoreAndPopReceiverVariableBytecode(void)
{
	return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, byte0 & 7, /* ssTopNeedsStoreCheck */
		((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (/* shouldAnnotateObjectReference: */
		(isNonImmediate(((ssTop())->constant)))
	 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
	 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopRemoteTempLongBytecode */
static sqInt
genStoreAndPopRemoteTempLongBytecode(void)
{
	return genStorePopRemoteTempAtneedsStoreCheck(1, byte1, byte2, /* ssTopNeedsStoreCheck */
		((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (/* shouldAnnotateObjectReference: */
		(isNonImmediate(((ssTop())->constant)))
	 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
	 || (oopisLessThan(((ssTop())->constant), nilObject()))))));
}

	/* SimpleStackBasedCogit>>#genStoreAndPopTemporaryVariableBytecode */
static sqInt
genStoreAndPopTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(1, byte0 & 7);
}

	/* SimpleStackBasedCogit>>#genStoreRemoteTempLongBytecode */
static sqInt
genStoreRemoteTempLongBytecode(void)
{
	return genStorePopRemoteTempAtneedsStoreCheck(0, byte1, byte2, /* ssTopNeedsStoreCheck */
		((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (/* shouldAnnotateObjectReference: */
		(isNonImmediate(((ssTop())->constant)))
	 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
	 || (oopisLessThan(((ssTop())->constant), nilObject()))))));
}

	/* SimpleStackBasedCogit>>#genTakeProfileSample */
static void
genTakeProfileSample(void)
{
    AbstractInstruction *abstractInstruction;

	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), ClassReg))));
	genMarshallNArgsargargargarg(backEnd, 1, ClassReg, null, null, null);
	genLoadNativeSPRegWithAlignedSPReg(backEnd);
	if (isInImmediateBranchAndLinkRange(backEnd, maximumDistanceFromCodeZone(((sqInt)ceTakeProfileSample)))) {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ((usqIntptr_t)ceTakeProfileSample));
		(abstractInstruction->annotation = IsRelativeCall);
	}
	else {
		/* #CallFullRT: #CallFull: #gen:literal: */
		checkLiteralforInstruction(((usqIntptr_t)ceTakeProfileSample), genoperand(CallFull, ((usqIntptr_t)ceTakeProfileSample)));
	}

	/* genRemoveNArgsFromStack: */
	genLoadCStackPointer(backEnd);
}


/*	SistaV1: *	217		Trap */

	/* SimpleStackBasedCogit>>#genUnconditionalTrapBytecode */
static sqInt
genUnconditionalTrapBytecode(void)
{
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#loadNativeArgumentAddress:to: */
static NoDbgRegParms void
loadNativeArgumentAddressto(sqInt baseOffset, sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	offset = frameOffsetOfPreviousNativeStackPointer();

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, baseOffset - 1, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(baseOffset - 1, BytesPerOop));
	}
}

	/* SimpleStackBasedCogit>>#loadNativeFramePointerInto: */
static NoDbgRegParms void
loadNativeFramePointerInto(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	offset = frameOffsetOfNativeFramePointer();

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
}

	/* SimpleStackBasedCogit>>#loadNativeLocalAddress:to: */
static NoDbgRegParms void
loadNativeLocalAddressto(sqInt baseOffset, sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	offset = frameOffsetOfNativeFramePointer();

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, baseOffset - 1, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(baseOffset - 1, BytesPerOop));
	}
}


/*	Collect the branch and send data for cogMethod, storing it into arrayObj. */

	/* SimpleStackBasedCogit>>#mapPCDataFor:into: */
sqInt
mapPCDataForinto(CogMethod *cogMethod, sqInt arrayObj)
{
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    CogBlockMethod *cogMethod1;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    sqInt errCode;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    usqInt isInBlock;
    sqInt latestContinuation;
    sqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt startbcpc;
    sqInt targetPC;

	introspectionDataIndex = 0;
	introspectionData = arrayObj;
	if (!((cogMethod->stackCheckOffset))) {
		assert(introspectionDataIndex == 0);
		if ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock)) {
			storePointerUncheckedofObjectwithValue(0, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(1, introspectionData, (((usqInt)cbNoSwitchEntryOffset << 3) | 1));
			storePointerUncheckedofObjectwithValue(2, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(3, introspectionData, (((usqInt)cbEntryOffset << 3) | 1));
		}
		else {
			storePointerUncheckedofObjectwithValue(0, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(1, introspectionData, (((usqInt)cmEntryOffset << 3) | 1));
			storePointerUncheckedofObjectwithValue(2, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(3, introspectionData, (((usqInt)cmNoCheckEntryOffset << 3) | 1));
		}
		return 4;
	}
	cogMethod1 = ((CogBlockMethod *) cogMethod);
	startbcpc = startPCOfMethod((cogMethod->methodObject));

	/* begin mapFor:bcpc:performUntil:arg: */
	descriptor = ((BytecodeDescriptor *) 0);
	latestContinuation = 0;
	mapByte = 0;
	nextBcpc = 0;
	assert(((cogMethod1->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)cogMethod1)) + ((cogMethod1->stackCheckOffset));
	result = pcDataForAnnotationMcpcBcpcMethod(null, 0 + ((((usqInt)(HasBytecodePC) << 1))), ((char *) mcpc), startbcpc, ((void *)cogMethod));
	if (result) {
		errCode = result;
		goto l1;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if (((cogMethod1->cmType)) >= CMMethod) {
		isInBlock = (cogMethod1->cpicHasMNUCaseOrCMIsFullBlock);
		homeMethod = ((CogMethod *) cogMethod1);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;

		/* If the method has a primitive, skip it and the error code store, if any;
		   Logically. these come before the stack check and so must be ignored. */
		bsOffset = /* begin bytecodeSetOffsetForHeader: */
				(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
					? 0x100
					: 0);
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == ((cogMethod1->startpc)));
		homeMethod = cmHomeMethod(cogMethod1);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod1)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - (/* begin blockCreationBytecodeSizeForHeader: */
	(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
		? AltBlockCreationBytecodeSize
		: BlockCreationBytecodeSize));
		bsOffset = /* begin bytecodeSetOffsetForHeader: */
				(headerIndicatesAlternateBytecodeSet((homeMethod->methodHeader))
					? 0x100
					: 0);
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj)
		: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	enumeratingCogMethod = homeMethod;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask) * 4 /* codeGranularity */;
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							errCode = 0;
							goto l1;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							errCode = 0;
							goto l1;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)
		: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
								? nExts + 1
								: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
					 && ((/* begin isBackwardBranch:at:exts:in: */
						assert(((descriptor->spanFunction))),
					(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = pcDataForAnnotationMcpcBcpcMethod(descriptor, (isBackwardBranch
							? ((((usqInt)(annotation) << 1))) + 1
							: ((sqInt)((usqInt)(annotation) << 1))), ((char *) mcpc), (isBackwardBranch
							? bcpc - (2 * nExts)
							: bcpc), ((void *)cogMethod));
				if (result) {
					errCode = result;
					goto l1;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
							? nExts + 1
							: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < ((((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += ((((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* codeGranularity */;
			}
		}
		map -= 1;
	}
	errCode = 0;
l1:	/* end mapFor:bcpc:performUntil:arg: */;
	if (errCode) {
		assert(errCode == PrimErrNoMemory);
		return -1;
	}
	if ((cogMethod->blockEntryOffset)) {
		errCode = blockDispatchTargetsForperformarg(cogMethod, pcDataForBlockEntryMethod, ((sqInt)cogMethod));
		if (errCode) {
			assert(errCode == PrimErrNoMemory);
			return -1;
		}
	}
	return introspectionDataIndex;
}

	/* SimpleStackBasedCogit>>#numSpecialSelectors */
static sqInt
numSpecialSelectors(void)
{
	return (bytecodeSetOffset == 0x100
				? AltNumSpecialSelectors
				: NumSpecialSelectors);
}


/*	Collect the branch and send data for the block method starting at
	blockEntryMcpc, storing it into picData.
 */

	/* SimpleStackBasedCogit>>#pcDataForBlockEntry:Method: */
static NoDbgRegParms usqInt
pcDataForBlockEntryMethod(sqInt blockEntryMcpc, sqInt cogMethod)
{
	storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, nilObject());
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)(blockEntryMcpc - blockNoContextSwitchOffset) << 3) | 1));
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 2, introspectionData, nilObject());
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 3, introspectionData, (((usqInt)blockEntryMcpc << 3) | 1));
	introspectionDataIndex += 4;
	return 0;
}

	/* SimpleStackBasedCogit>>#pcDataFor:Annotation:Mcpc:Bcpc:Method: */
static NoDbgRegParms sqInt
pcDataForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg)
{
    sqInt actualBcpc;
    sqInt actualMcpc;

	if (!descriptor) {

		/* this is the stackCheck offset */
		assert(introspectionDataIndex == 0);
		if (((((CogMethod *) cogMethodArg))->cpicHasMNUCaseOrCMIsFullBlock)) {
			storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)cbNoSwitchEntryOffset << 3) | 1));
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 2, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 3, introspectionData, (((usqInt)cbEntryOffset << 3) | 1));
		}
		else {
			storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)cmEntryOffset << 3) | 1));
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 2, introspectionData, nilObject());
			storePointerUncheckedofObjectwithValue(introspectionDataIndex + 3, introspectionData, (((usqInt)cmNoCheckEntryOffset << 3) | 1));
		}
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 4, introspectionData, (((usqInt)(bcpc + 1) << 3) | 1));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 5, introspectionData, (((((((CogMethod *) cogMethodArg))->stackCheckOffset)) << 3) | 1));
		introspectionDataIndex += 6;
		return 0;
	}
	if ((((usqInt)(isBackwardBranchAndAnnotation)) >> 1) >= HasBytecodePC) {
		actualBcpc = (((isBackwardBranchAndAnnotation & 1) != 0)
					? bcpc + 1
					: (bcpc + ((descriptor->numBytes))) + 1);
		actualMcpc = (((usqInt)mcpc)) - (((usqInt)cogMethodArg));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, (((usqInt)actualBcpc << 3) | 1));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)actualMcpc << 3) | 1));
		introspectionDataIndex += 2;
	}
	return 0;
}


/*	If there is a generator for the current primitive then answer it;
	otherwise answer nil. */

	/* SimpleStackBasedCogit>>#primitiveGeneratorOrNil */
static PrimitiveDescriptor *
primitiveGeneratorOrNil(void)
{
    PrimitiveDescriptor *primitiveDescriptor;

	if (isQuickPrimitiveIndex(primitiveIndex)) {
		/* an unused one */
		primitiveDescriptor = (&(primitiveGeneratorTable[0]));
		(primitiveDescriptor->primitiveGenerator = quickPrimitiveGeneratorFor(primitiveIndex));
		return primitiveDescriptor;
	}
	if (((primitiveIndex >= 1) && (primitiveIndex <= MaxCompiledPrimitiveIndex))) {
		return (&(primitiveGeneratorTable[primitiveIndex]));
	}
	return null;
}

	/* SimpleStackBasedCogit>>#register:isInMask: */
static NoDbgRegParms int
registerisInMask(sqInt reg, sqInt mask)
{
	return ((mask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))) != 0);
}

	/* SimpleStackBasedCogit>>#register:isNotInMask: */
static NoDbgRegParms int
registerisNotInMask(sqInt reg, sqInt mask)
{
	return (!(mask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)))));
}

	/* SimpleStackBasedCogit>>#v3:Block:Code:Size: */
static NoDbgRegParms sqInt
v3BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts <= 0);
	return ((((usqInt)((fetchByteofObject(pc + 2, aMethodObj))) << 8))) + (fetchByteofObject(pc + 3, aMethodObj));
}


/*	Answer the distance of a two byte forward long jump. */

	/* SimpleStackBasedCogit>>#v3:LongForward:Branch:Distance: */
static NoDbgRegParms sqInt
v3LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return ((((fetchByteofObject(pc, aMethodObj)) & 3) << 8)) + (fetchByteofObject(pc + 1, aMethodObj));
}


/*	Answer the distance of a two byte forward long jump. */

	/* SimpleStackBasedCogit>>#v3:Long:Branch:Distance: */
static NoDbgRegParms sqInt
v3LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return ((((usqInt)((((fetchByteofObject(pc, aMethodObj)) & 7) - 4)) << 8))) + (fetchByteofObject(pc + 1, aMethodObj));
}


/*	N.B. This serves for both BlueBook/V3 and V4 short jumps. */

	/* SimpleStackBasedCogit>>#v3:ShortForward:Branch:Distance: */
static NoDbgRegParms sqInt
v3ShortForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return ((fetchByteofObject(pc, aMethodObj)) & 7) + 1;
}


/*	253		11111101 eei i i kkk	jjjjjjjj		Push Closure Num Copied iii (+ Ext A
	// 16 * 8) Num Args kkk (+ Ext A \\ 16 * 8) BlockSize jjjjjjjj (+ Ext B *
	256). ee = num extensions
 */

	/* SimpleStackBasedCogit>>#v4:Block:Code:Size: */
static NoDbgRegParms sqInt
v4BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
    sqInt byte;
    sqInt byteOne;
    sqInt extAValue;
    sqInt extBValue;
    sqInt extBValueSqInt;
    sqInt extByte;
    sqInt pcSqInt;

	/* If nExts < 0 it isn't known and we rely on the number of extensions encoded in the eeiiikkk byte. */
	byteOne = fetchByteofObject(pc + 1, aMethodObj);
	assert((nExts < 0)
	 || (nExts == (((usqInt)(byteOne)) >> 6)));

	/* begin parseV4Exts:priorTo:in:into: */
	extAValue = (extBValueSqInt = 0);
	pcSqInt = (pc - (((usqInt)(byteOne)) >> 6)) - (((usqInt)(byteOne)) >> 6);
	while (pcSqInt < pc) {
		byte = fetchByteofObject(pcSqInt, aMethodObj);
		pcSqInt += 1;
		extByte = fetchByteofObject(pcSqInt, aMethodObj);
		pcSqInt += 1;
		assert((byte == 224)
		 || (byte == 225));
		if (byte == 224) {
			extAValue = (((((usqInt)(extAValue) << 8)))) + extByte;
		}
		else {
			extBValueSqInt = ((extBValueSqInt == 0)
				 && (extByte > 0x7F)
						? extByte - 0x100
						: (((((usqInt)(extBValueSqInt) << 8)))) + extByte);
		}
	}
	extBValue = extBValueSqInt;
	return (fetchByteofObject(pc + 2, aMethodObj)) + ((((usqInt)(extBValue) << 8)));
}


/*	242		11110010	i i i i i i i i	Jump i i i i i i i i (+ Extend B * 256,
	where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
 */
/*	243		11110011	i i i i i i i i	Pop and Jump 0n True i i i i i i i i (+
	Extend A * 256)
 */
/*	244		11110100	i i i i i i i i	Pop and Jump 0n False i i i i i i i i (+
	Extend A * 256)
 */

	/* SimpleStackBasedCogit>>#v4:LongForward:Branch:Distance: */
static NoDbgRegParms sqInt
v4LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
    sqInt byte;
    sqInt extAValue;
    sqInt extBValue;
    sqInt extBValueSqInt;
    sqInt extByte;
    sqInt pcSqInt;

	assert(nExts >= 0);

	/* begin parseV4Exts:priorTo:in:into: */
	extAValue = (extBValueSqInt = 0);
	pcSqInt = (pc - nExts) - nExts;
	while (pcSqInt < pc) {
		byte = fetchByteofObject(pcSqInt, aMethodObj);
		pcSqInt += 1;
		extByte = fetchByteofObject(pcSqInt, aMethodObj);
		pcSqInt += 1;
		assert((byte == 224)
		 || (byte == 225));
		if (byte == 224) {
			extAValue = (((((usqInt)(extAValue) << 8)))) + extByte;
		}
		else {
			extBValueSqInt = ((extBValueSqInt == 0)
				 && (extByte > 0x7F)
						? extByte - 0x100
						: (((((usqInt)(extBValueSqInt) << 8)))) + extByte);
		}
	}
	extBValue = extBValueSqInt;
	return (fetchByteofObject(pc + 1, aMethodObj)) + ((((usqInt)(extBValue) << 8)));
}


/*	242		11110010	i i i i i i i i	Jump i i i i i i i i (+ Extend B * 256,
	where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
 */

	/* SimpleStackBasedCogit>>#v4:Long:Branch:Distance: */
static NoDbgRegParms sqInt
v4LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
    sqInt byte;
    sqInt extAValue;
    sqInt extBValue;
    sqInt extBValueSqInt;
    sqInt extByte;
    sqInt pcSqInt;

	assert(nExts >= 0);

	/* begin parseV4Exts:priorTo:in:into: */
	extAValue = (extBValueSqInt = 0);
	pcSqInt = (pc - nExts) - nExts;
	while (pcSqInt < pc) {
		byte = fetchByteofObject(pcSqInt, aMethodObj);
		pcSqInt += 1;
		extByte = fetchByteofObject(pcSqInt, aMethodObj);
		pcSqInt += 1;
		assert((byte == 224)
		 || (byte == 225));
		if (byte == 224) {
			extAValue = (((((usqInt)(extAValue) << 8)))) + extByte;
		}
		else {
			extBValueSqInt = ((extBValueSqInt == 0)
				 && (extByte > 0x7F)
						? extByte - 0x100
						: (((((usqInt)(extBValueSqInt) << 8)))) + extByte);
		}
	}
	extBValue = extBValueSqInt;
	return (fetchByteofObject(pc + 1, aMethodObj)) + ((((usqInt)(extBValue) << 8)));
}

	/* SistaMethodZone>>#getCogCodeZoneThreshold */
double
getCogCodeZoneThreshold(void)
{
	return thresholdRatio;
}

	/* SistaMethodZone>>#setCogCodeZoneThreshold: */
sqInt
setCogCodeZoneThreshold(double ratio)
{
	if (!((ratio >= 0.1)
		 && (ratio <= 1.0))) {
		return PrimErrBadArgument;
	}
	thresholdRatio = ratio;

	/* begin computeAllocationThreshold */
	allocationThreshold = ((((((usqInt)((limitAddress - baseAddress) * thresholdRatio))) + ((zoneAlignment()) - 1)) & ~7)) + baseAddress;
	return 0;
}


/*	Add a blockStart for an embedded block. For a binary tree walk block
	dispatch blocks must be compiled in pc/depth-first order but are scanned
	in breadth-first
	order, so do an insertion sort (which of course is really a bubble sort
	because we
	have to move everything higher to make room). */

	/* StackToRegisterMappingCogit>>#addBlockStartAt:numArgs:numCopied:span: */
static NoDbgRegParms BlockStart *
addBlockStartAtnumArgsnumCopiedspan(sqInt bytecodepc, sqInt numArgs, sqInt numCopied, sqInt span)
{
    BlockStart *blockStart;
    sqInt i;
    sqInt j;


	/* Transcript ensureCr; nextPutAll: 'addBlockStartAt: '; print: bytecodepc; cr; flush. */
	if (blockCount > 0) {
		i = blockCount - 1;
		while (1) {
			/* check for repeat addition during recompilation due to initialNil miscount. */
			blockStart = (&(blockStarts[i]));
			if (((blockStart->startpc)) == bytecodepc) {
				return blockStart;
			}
			if (!((((blockStart->startpc)) > bytecodepc)
			 && (i > 0))) break;
			i -= 1;
		}
		for (j = blockCount; j >= (i + 1); j += -1) {
			blockStarts[j] = (blockStarts[j - 1]);
		}
		blockStart = (&(blockStarts[i + 1]));
	}
	else {
		blockStart = (&(blockStarts[blockCount]));
	}
	blockCount += 1;
	(blockStart->startpc = bytecodepc);
	(blockStart->numArgs = numArgs);
	(blockStart->numCopied = numCopied);
	(blockStart->numInitialNils = 0);
	(blockStart->stackCheckLabel = null);
	(blockStart->hasInstVarRef = 0);
	(blockStart->span = span);
	return blockStart;
}


/*	e.g.	Receiver				Receiver	or	Receiver				Receiver	(RISC)
	Selector/Arg0	=>		Arg1			Selector/Arg0	=>		Arg1
	Arg1					Arg2			Arg1					Arg2
	Arg2					Arg3			Arg2			sp->	Arg3
	Arg3			sp->	retpc	sp->	Arg3
	sp->	retpc */
/*	Generate code to adjust the possibly stacked arguments immediately
	before jumping to a method looked up by a perform primitive. */

	/* StackToRegisterMappingCogit>>#adjustArgumentsForPerform: */
static NoDbgRegParms void
adjustArgumentsForPerform(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt index;
    sqInt offset;
    sqInt quickConstant;

	assert((numRegArgs()) <= 2);
	assert(numArgs >= 1);
	if (numArgs <= (numRegArgs())) {
		if (numArgs == 2) {
			/* MoveR:R: */
			genoperandoperand(MoveRR, Arg1Reg, Arg0Reg);
		}
		return;
	}
	if (((numRegArgs()) + 1) == numArgs) {
		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, SPReg, Arg1Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
		}
		quickConstant = (numArgs + 1) * BytesPerWord;

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, quickConstant, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}
		return;
	}
	for (index = (numArgs - 2); index >= 0; index += -1) {
		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, index * BytesPerWord, SPReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(index * BytesPerWord, BytesPerOop));
		}
		offset = (index + 1) * BytesPerWord;

		/* begin MoveR:Mw:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction1 = genoperandoperandoperand(MoveRMwr, TempReg, offset, SPReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteralsize(offset, BytesPerOop));
		}
	}

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
	}
}


/*	if there's a free register, use it */

	/* StackToRegisterMappingCogit>>#allocateFloatRegNotConflictingWith: */
static NoDbgRegParms sqInt
allocateFloatRegNotConflictingWith(sqInt regMask)
{
    sqInt reg;

	reg = availableFloatRegisterOrNoneFor(backEnd, (liveFloatRegisters()) | regMask);
	if (reg == NoReg) {

		/* No free register, choose one that does not conflict with regMask */
		reg = freeAnyFloatRegNotConflictingWith(regMask);
	}
	return reg;
}


/*	If the stack entry is already in a register not conflicting with regMask,
	answers it,
	else allocate a new register not conflicting with reg mask
 */

	/* StackToRegisterMappingCogit>>#allocateRegForStackEntryAt:notConflictingWith: */
static NoDbgRegParms sqInt
allocateRegForStackEntryAtnotConflictingWith(sqInt index, sqInt regMask)
{
    sqInt mask;
    CogSimStackEntry *stackEntry;

	stackEntry = ssValue(index);
	mask = registerMaskOrNone(stackEntry);
	if ((mask != 0)
	 && ((!(mask & regMask)))) {
		flag("TODO");
		return registerOrNone(stackEntry);
	}
	return allocateRegNotConflictingWith(regMask);
}


/*	if there's a free register, use it */

	/* StackToRegisterMappingCogit>>#allocateRegNotConflictingWith: */
static NoDbgRegParms sqInt
allocateRegNotConflictingWith(sqInt regMask)
{
    sqInt reg;

	reg = availableRegisterOrNoneFor(backEnd, (liveRegisters()) | regMask);
	if (reg == NoReg) {

		/* No free register, choose one that does not conflict with regMask */
		reg = freeAnyRegNotConflictingWith(regMask);
	}
	if (reg == ReceiverResultReg) {

		/* If we've allocated RcvrResultReg, it's not live anymore */
		voidReceiverResultRegContainsSelf();
	}
	return reg;
}

	/* StackToRegisterMappingCogit>>#anyReferencesToRegister:inTopNItems: */
static NoDbgRegParms sqInt
anyReferencesToRegisterinTopNItems(sqInt reg, sqInt n)
{
    sqInt i;
    sqInt regMask;

	regMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
	for (i = simStackPtr; i >= ((simStackPtr - n) + 1); i += -1) {
		if ((((registerMask(simStackAt(i))) & regMask) != 0)) {
			return 1;
		}
	}
	return 0;
}


/*	Store the smalltalk pointers */

	/* StackToRegisterMappingCogit>>#beginHighLevelCall: */
static NoDbgRegParms void
beginHighLevelCall(sqInt alignment)
{
    sqInt actualAlignment;
    AbstractInstruction *anInstruction;
    sqInt i;
    sqInt mask;
    sqInt offset;

	/* begin ssFlushAll */
	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= simStackPtr) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = simStackPtr + 1;
	}
	voidReceiverResultRegContainsSelf();
	genSaveStackPointers(backEnd);

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));
	genLoadCStackPointer(backEnd);
	offset = frameOffsetOfNativeFramePointer();

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, FPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, FPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}
	actualAlignment = ((alignment < BytesPerWord) ? BytesPerWord : alignment);
	if (actualAlignment > BytesPerWord) {
		mask = -actualAlignment;

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, mask, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(mask, BytesPerOop));
		}
	}
	currentCallCleanUpSize = 0;
}


/*	This is a static version of ceCallCogCodePopReceiverArg0Regs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* StackToRegisterMappingCogit>>#callCogCodePopReceiverArg0Regs */
void
callCogCodePopReceiverArg0Regs(void)
{
	realCECallCogCodePopReceiverArg0Regs();
}


/*	This is a static version of ceCallCogCodePopReceiverArg1Arg0Regs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* StackToRegisterMappingCogit>>#callCogCodePopReceiverArg1Arg0Regs */
void
callCogCodePopReceiverArg1Arg0Regs(void)
{
	realCECallCogCodePopReceiverArg1Arg0Regs();
}

	/* StackToRegisterMappingCogit>>#callSwitchToCStack */
static sqInt
callSwitchToCStack(void)
{
	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(cFramePointerAddress(), genoperandoperand(MoveAwR, cFramePointerAddress(), FPReg));
	return 0;
}


/*	Restore the link register */

	/* StackToRegisterMappingCogit>>#callSwitchToSmalltalkStack */
static void
callSwitchToSmalltalkStack(void)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	quickConstant = varBaseAddress;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));
	genLoadStackPointers(backEnd);
}


/*	Loop over bytecodes, dispatching to the generator for each bytecode,
	handling fixups in due course.
 */

	/* StackToRegisterMappingCogit>>#compileAbstractInstructionsFrom:through: */
static NoDbgRegParms sqInt
compileAbstractInstructionsFromthrough(sqInt start, sqInt end)
{
    BytecodeDescriptor *descriptor;
    BytecodeFixup *fixup;
    sqInt nExts;
    sqInt nextOpcodeIndex;
    sqInt result;

	traceSimStack();
	bytecodePC = start;
	nExts = (result = 0);
	descriptor = null;
	deadCode = 0;
	while (1) {
		maybeHaltIfDebugPC();
		mergeWithFixupIfRequired((fixup = fixupAt(bytecodePC)));
		descriptor = loadBytesAndGetDescriptor();
		nextOpcodeIndex = opcodeIndex;
		result = (deadCode
					? mapDeadDescriptorIfNeeded(descriptor)
					: ((descriptor->generator))());
		if (!result) {
			/* begin assertExtsAreConsumed: */
			if (!((descriptor->isExtension))) {
				assert((extA == 0)
				 && ((extB == 0)
				 && (numExtB == 0)));
			}
		}
		traceDescriptor(descriptor);
		traceSimStack();

		/* begin patchFixupTargetIfNeeded:nextOpcodeIndex: */
		if ((((((usqInt)((fixup->targetInstruction)))) >= NeedsNonMergeFixupFlag) && ((((usqInt)((fixup->targetInstruction)))) <= NeedsMergeFixupFlag))) {

			/* There is a fixup for this bytecode.  It must point to the first generated
			   instruction for this bytecode.  If there isn't one we need to add a label. */
			if (opcodeIndex == nextOpcodeIndex) {
				/* Label */
				genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			(fixup->targetInstruction = abstractInstructionAt(nextOpcodeIndex));
		}

		/* begin maybeDumpLiterals: */
		if ((/* mustDumpLiterals: */
			(opcodeIndex >= firstOpcodeIndex)
		 && ((opcodeIndex - firstOpcodeIndex) >= (outOfLineLiteralOpcodeLimit(backEnd))))
		 || ((/* isUnconditionalBranch */
			(isBranch(descriptor))
		 && (!(((descriptor->isBranchTrue))
		 || ((descriptor->isBranchFalse)))))
		 || ((descriptor->isReturn)))) {
			dumpLiterals(!((/* isUnconditionalBranch */
				(isBranch(descriptor))
			 && (!(((descriptor->isBranchTrue))
			 || ((descriptor->isBranchFalse)))))
			 || ((descriptor->isReturn))));
		}
		bytecodePC = (bytecodePC + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, bytecodePC, nExts, methodObj)
		: 0));
		if (!((result == 0)
		 && (bytecodePC <= end))) break;
		nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
	}

	/* begin checkEnoughOpcodes */
	if (opcodeIndex > numAbstractOpcodes) {
		error("Cog JIT internal error. Too many abstract opcodes.  Num opcodes heuristic is too optimistic.");
	}
	return result;
}

	/* StackToRegisterMappingCogit>>#compileBlockBodies */
static sqInt
compileBlockBodies(void)
{
    BlockStart *blockStart;
    sqInt compiledBlocksCount;
    sqInt initialCounterIndex;
    sqInt initialOpcodeIndex;
    sqInt initialStackPtr;
    sqInt (* const pushNilSizeFunction)(sqInt,sqInt) = squeakV3orSistaV1PushNilSizenumInitialNils;
    sqInt result;
    sqInt savedFirstOpcodeIndex;
    sqInt savedLastDumpedLiteralIndex;
    unsigned char savedNeedsFrame;
    sqInt savedNextLiteralIndex;
    sqInt savedNumArgs;
    sqInt savedNumTemps;

	initialStackPtr = 0;
	assert(blockCount > 0);
	savedNeedsFrame = needsFrame;
	savedNumArgs = methodOrBlockNumArgs;
	savedNumTemps = methodOrBlockNumTemps;
	inBlock = InVanillaBlock;
	compiledBlocksCount = 0;
	while (compiledBlocksCount < blockCount) {
		compilationPass = 1;
		blockStart = blockStartAt(compiledBlocksCount);
		if (((result = scanBlock(blockStart))) < 0) {
			return result;
		}
		initialOpcodeIndex = opcodeIndex;

		/* for SistaCogit */
		initialCounterIndex = 0 /* maybeCounterIndex */;

		/* begin saveForRecompile */
		savedFirstOpcodeIndex = firstOpcodeIndex;
		savedNextLiteralIndex = nextLiteralIndex;
		savedLastDumpedLiteralIndex = lastDumpedLiteralIndex;
		while (1) {
			compileBlockEntry(blockStart);
			initialStackPtr = simStackPtr;
			if (((result = compileAbstractInstructionsFromthrough(((blockStart->startpc)) + (pushNilSizeFunction(methodObj, ((blockStart->numInitialNils)))), (((blockStart->startpc)) + ((blockStart->span))) - 1))) < 0) {
				return result;
			}
			if (initialStackPtr == simStackPtr) break;
			assert((initialStackPtr > simStackPtr)
			 || (deadCode));

			/* for asserts */
			compilationPass += 1;
			(blockStart->numInitialNils = (((blockStart->numInitialNils)) + simStackPtr) - initialStackPtr);
			(((blockStart->fakeHeader))->dependent = null);
			reinitializeFixupsFromthrough(((blockStart->startpc)) + ((blockStart->numInitialNils)), (((blockStart->startpc)) + ((blockStart->span))) - 1);
			bzero(abstractOpcodes + initialOpcodeIndex,
									(opcodeIndex - initialOpcodeIndex) * sizeof(AbstractInstruction));
			opcodeIndex = initialOpcodeIndex;

			/* begin resetForRecompile */
			firstOpcodeIndex = savedFirstOpcodeIndex;
			nextLiteralIndex = savedNextLiteralIndex;
			lastDumpedLiteralIndex = savedLastDumpedLiteralIndex;
		}
		compiledBlocksCount += 1;
	}
	needsFrame = savedNeedsFrame;
	methodOrBlockNumArgs = savedNumArgs;
	methodOrBlockNumTemps = savedNumTemps;
	return 0;
}


/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. closure (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	Avoid use of SendNumArgsReg which is the flag determining whether
	context switch is allowed on stack-overflow. */
/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. Override to push the register receiver and
	register arguments, if any, and to correctly
	initialize the explicitly nilled/pushed temp entries (they are /not/ of
	type constant nil). */

	/* StackToRegisterMappingCogit>>#compileBlockFrameBuild: */
static NoDbgRegParms void
compileBlockFrameBuild(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *cascade0;
    sqInt i;
    sqInt ign;

	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);

	/* PushR: */
	genoperand(PushR, LinkReg);

	/* PushR: */
	genoperand(PushR, FPReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	cascade0 = (blockStart->fakeHeader);
	addDependent(cascade0, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)((blockStart->fakeHeader))), genoperand(PushCw, ((sqInt)((blockStart->fakeHeader)))))));

	/* setLabelOffset: */
	((cascade0->operands))[1] = MFMethodFlagIsBlockFlag;

	/* begin genPushConstant: */
	/* begin PushCq: */
	/* begin gen:quickConstant: */
	anInstruction = genoperand(PushCq, nilObject());
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}
	if ((blockStart->hasInstVarRef)) {

		/* Use ReceiverResultReg for Context to agree with store check trampoline */
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ClassReg, ReceiverResultReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, ReceiverResultReg, Arg0Reg);
		genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, ReceiverIndex, ReceiverResultReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	}
	else {
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ClassReg, Arg0Reg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, Arg0Reg, ReceiverResultReg);
	}

	/* PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = 0; i < ((blockStart->numCopied)); i += 1) {
		genLoadSlotsourceRegdestReg(i + ClosureFirstCopiedValueIndex, ClassReg, TempReg);

		/* PushR: */
		genoperand(PushR, TempReg);
	}
	(blockStart->stackCheckLabel = compileStackOverflowCheck(1));
	methodOrBlockNumTemps = (((blockStart->numArgs)) + ((blockStart->numCopied))) + ((blockStart->numInitialNils));
	initSimStackForFramefulMethod((blockStart->startpc));
	if (((blockStart->numInitialNils)) > 0) {
		if (((blockStart->numInitialNils)) > 1) {
			/* begin genMoveConstant:R: */
			/* begin MoveCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(MoveCqR, nilObject(), TempReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
			}
			for (ign = 1; ign <= ((blockStart->numInitialNils)); ign += 1) {
				/* PushR: */
				genoperand(PushR, TempReg);
			}
		}
		else {
			/* begin genPushConstant: */
			/* begin PushCq: */
			/* begin gen:quickConstant: */
			anInstruction = genoperand(PushCq, nilObject());
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
			}
		}
	}
}


/*	Make sure ReceiverResultReg holds the receiver, loaded from the closure,
	which is what is initially in ReceiverResultReg. We must annotate the
	first instruction in vanilla blocks so that
	findMethodForStartBcpc:inHomeMethod: can function. We need two annotations
	because the first is a fiducial. */
/*	Make sure ReceiverResultReg holds the receiver, loaded from
	the closure, which is what is initially in ReceiverResultReg */

	/* StackToRegisterMappingCogit>>#compileBlockFramelessEntry: */
static NoDbgRegParms void
compileBlockFramelessEntry(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;

	methodOrBlockNumTemps = (((blockStart->numArgs)) + ((blockStart->numCopied))) + ((blockStart->numInitialNils));
	initSimStackForFramelessBlock((blockStart->startpc));
	if ((blockStart->entryLabel)) {
		abstractInstruction = (blockStart->entryLabel);

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
	}
	if ((blockStart->hasInstVarRef)) {

		/* Use ReceiverResultReg for Context to agree with store check trampoline */
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, ReceiverResultReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, ReceiverResultReg, Arg0Reg);
		genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, ReceiverIndex, ReceiverResultReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	}
	else {
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, TempReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, TempReg, ReceiverResultReg);
	}
}

	/* StackToRegisterMappingCogit>>#compileCogFullBlockMethod: */
static NoDbgRegParms CogMethod *
compileCogFullBlockMethod(sqInt numCopied)
{
    sqInt allocBytes;
    sqInt fixupBytes;
    sqInt numBlocks;
    sqInt numBytecodes;
    sqInt numCleanBlocks;
    sqInt opcodeBytes;
    sqInt result;

	methodOrBlockNumTemps = tempCountOf(methodObj);
	setHasMovableLiteral(0);
	setHasYoungReferent(isYoungObject(methodObj));
	methodOrBlockNumArgs = argumentCountOf(methodObj);
	inBlock = InFullBlock;
	maxLitIndex = -1;
	assert((primitiveIndexOf(methodObj)) == 0);

	/* initial estimate.  Actual endPC is determined in scanMethod. */
	initialPC = startPCOfMethod(methodObj);
	endPC = numBytesOf(methodObj);
	numBytecodes = (endPC - initialPC) + 1;
	primitiveIndex = 0;

	/* begin allocateOpcodes:bytecodes:ifFail: */
	numAbstractOpcodes = (numBytecodes + 10) * 10 /* estimateOfAbstractOpcodesPerBytecodes */;
	opcodeBytes = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupBytes = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;

	/* Document the fact that the MaxStackAllocSize ensures that the number of abstract
	   opcodes fits in a 16 bit integer (e.g. CogBytecodeFixup's instructionIndex). */
	allocBytes = opcodeBytes + fixupBytes;
	assert((((sizeof(CogAbstractInstruction)) + (sizeof(CogBytecodeFixup))) * 0xC000) > MaxStackAllocSize);
	if (allocBytes > MaxStackAllocSize) {
		return ((CogMethod *) MethodTooBig);
		goto l1;
	}
	abstractOpcodes = alloca(allocBytes);
	bzero(abstractOpcodes, allocBytes);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeBytes));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
l1:	/* end allocateOpcodes:bytecodes:ifFail: */;
	flag("TODO");
	if (((numBlocks = scanMethod())) < 0) {
		return ((CogMethod *) numBlocks);
	}
	assert(numBlocks == 0);
	numCleanBlocks = scanForCleanBlocks();
	assert(numCleanBlocks == 0);
	allocateBlockStarts(numBlocks + numCleanBlocks);
	blockCount = 0;
	if (numCleanBlocks > 0) {
		addCleanBlockStarts();
	}
	blockEntryLabel = null;
	(methodLabel->dependent = null);
	if (((result = compileEntireFullBlockMethod(numCopied))) < 0) {
		return ((CogMethod *) result);
	}
	return generateCogFullBlock();
}

	/* StackToRegisterMappingCogit>>#compileCogMethod: */
static NoDbgRegParms CogMethod *
compileCogMethod(sqInt selector)
{
    sqInt allocBytes;
    int extra;
    sqInt fixupBytes;
    sqInt methodFoundInvalidPostScanRV;
    sqInt numBlocks;
    sqInt numBytecodes;
    sqInt numCleanBlocks;
    sqInt opcodeBytes;
    sqInt result;

	methodOrBlockNumTemps = tempCountOf(methodObj);
	setHasMovableLiteral(0);
	setHasYoungReferent((isYoungObject(methodObj))
	 || (isYoung(selector)));
	methodOrBlockNumArgs = argumentCountOf(methodObj);
	inBlock = 0;
	maxLitIndex = -1;
	extra = ((((primitiveIndex = primitiveIndexOf(methodObj))) > 0)
		 && (!(isQuickPrimitiveIndex(primitiveIndex)))
				? 30
				: 10);

	/* initial estimate.  Actual endPC is determined in scanMethod. */
	initialPC = startPCOfMethod(methodObj);
	endPC = (isQuickPrimitiveIndex(primitiveIndex)
				? initialPC - 1
				: numBytesOf(methodObj));
	numBytecodes = (endPC - initialPC) + 1;

	/* begin allocateOpcodes:bytecodes:ifFail: */
	numAbstractOpcodes = (numBytecodes + extra) * 10 /* estimateOfAbstractOpcodesPerBytecodes */;
	opcodeBytes = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupBytes = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;

	/* Document the fact that the MaxStackAllocSize ensures that the number of abstract
	   opcodes fits in a 16 bit integer (e.g. CogBytecodeFixup's instructionIndex). */
	allocBytes = opcodeBytes + fixupBytes;
	assert((((sizeof(CogAbstractInstruction)) + (sizeof(CogBytecodeFixup))) * 0xC000) > MaxStackAllocSize);
	if (allocBytes > MaxStackAllocSize) {
		return ((CogMethod *) MethodTooBig);
		goto l1;
	}
	abstractOpcodes = alloca(allocBytes);
	bzero(abstractOpcodes, allocBytes);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeBytes));

	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
l1:	/* end allocateOpcodes:bytecodes:ifFail: */;
	if (((numBlocks = scanMethod())) < 0) {
		return ((CogMethod *) numBlocks);
	}
	numCleanBlocks = scanForCleanBlocks();

	/* begin methodFoundInvalidPostScan */
	if (!needsFrame) {
		methodFoundInvalidPostScanRV = methodOrBlockNumTemps > methodOrBlockNumArgs;
		goto l2;
	}
	methodFoundInvalidPostScanRV = 0;
l2:	/* end methodFoundInvalidPostScan */;
	if (methodFoundInvalidPostScanRV) {
		return ((CogMethod *) ShouldNotJIT);
	}
	allocateBlockStarts(numBlocks + numCleanBlocks);
	blockCount = 0;
	if (numCleanBlocks > 0) {
		addCleanBlockStarts();
	}
	blockEntryLabel = null;
	(methodLabel->dependent = null);
	if (((result = compileEntireMethod())) < 0) {
		return ((CogMethod *) result);
	}
	return generateCogMethod(selector);
}


/*	Compile the abstract instructions for the entire method, including blocks. */
/*	Compile the abstract instructions for the entire method, including blocks. */

	/* StackToRegisterMappingCogit>>#compileEntireMethod */
static sqInt
compileEntireMethod(void)
{
    sqInt result;

	regArgsHaveBeenPushed = 0;

	/* begin preenMethodLabel */
	/* setLabelOffset: */
	((methodLabel->operands))[1] = 0;
	compileAbort();
	compileEntry();
	if (((result = compilePrimitive())) < 0) {
		return result;
	}
	compileFrameBuild();
	if (((result = compileMethodBody())) < 0) {
		return result;
	}
	if (!blockCount) {
		return 0;
	}
	if (((result = compileBlockBodies())) < 0) {
		return result;
	}
	return compileBlockDispatch();
}


/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. receiver (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	If there is a primitive and an error code the Nth temp is the error code.
	Ensure SendNumArgsReg is set early on (incidentally to nilObj) because
	it is the flag determining whether context switch is allowed on
	stack-overflow.  */
/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. Override to push the register receiver and
	register arguments, if any. */

	/* StackToRegisterMappingCogit>>#compileFrameBuild */
static void
compileFrameBuild(void)
{
    AbstractInstruction *anInstruction;
    sqInt i;
    sqInt toDoLimit;


#  if IMMUTABILITY
	if (useTwoPaths) {
		compileTwoPathFrameBuild();
		return;
	}
#  endif

	if (!needsFrame) {
		if (useTwoPaths) {
			compileTwoPathFramelessInit();
		}
		initSimStackForFramelessMethod(initialPC);
		return;
	}
	assert(!(useTwoPaths));
	genPushRegisterArgs();
	if (!needsFrame) {
		return;
	}

	/* PushR: */
	genoperand(PushR, LinkReg);

	/* PushR: */
	genoperand(PushR, FPReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperand(PushCw, ((sqInt)methodLabel)))));

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}

	/* PushR: */
	genoperand(PushR, SendNumArgsReg);

	/* PushR: */
	genoperand(PushR, ReceiverResultReg);
	toDoLimit = temporaryCountOfMethodHeader(methodHeader);
	for (i = (methodOrBlockNumArgs + 1); i <= toDoLimit; i += 1) {
		/* PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	if (/* methodUsesPrimitiveErrorCode:header: */
		((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))) {
		compileGetErrorCode();
	}
	stackCheckLabel = compileStackOverflowCheck(canContextSwitchIfActivatingheader(methodObj, methodHeader));
	initSimStackForFramefulMethod(initialPC);
}


/*	Make sure ReceiverResultReg holds the receiver, loaded from the closure,
	which is what is initially in ReceiverResultReg.  */
/*	Make sure ReceiverResultReg holds the receiver, loaded from
	the closure, which is what is initially in ReceiverResultReg */

	/* StackToRegisterMappingCogit>>#compileFullBlockFramelessEntry: */
static NoDbgRegParms void
compileFullBlockFramelessEntry(sqInt numCopied)
{
	initSimStackForFramelessBlock(initialPC);
	flag("TODO");
	genLoadSlotsourceRegdestReg(FullClosureReceiverIndex, ReceiverResultReg, Arg0Reg);
	genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, FullClosureReceiverIndex, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
}


/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. closure (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	Avoid use of SendNumArgsReg which is the flag determining whether
	context switch is allowed on stack-overflow. */

	/* StackToRegisterMappingCogit>>#compileFullBlockMethodFrameBuild: */
static NoDbgRegParms void
compileFullBlockMethodFrameBuild(sqInt numCopied)
{
    AbstractInstruction *anInstruction;
    sqInt i;
    sqInt toDoLimit;

	if (useTwoPaths) {

		/* method with only inst var store, we compile only slow path for now */
		useTwoPaths = 0;
#    if IMMUTABILITY
		needsFrame = 1;
#    endif

	}
	if (!needsFrame) {

		/* it is OK for numCopied to be non-zero provided that the block does not actually use the copied values.
		   There are some blocks like this, e.g. that simply reference copied values to mark them as used for Slang.
		   See e.g. CroquetPlugin>>#primitiveGatherEntropy which contains the block [bufPtr. bufSize. false],
		   which the bytecode compiler optimizes to [false]. */
		compileFullBlockFramelessEntry(numCopied);
		initSimStackForFramelessBlock(initialPC);
		return;
	}
	if (!needsFrame) {
		return;
	}

	/* PushR: */
	genoperand(PushR, LinkReg);

	/* PushR: */
	genoperand(PushR, FPReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperand(PushCw, ((sqInt)methodLabel)))));

	/* setLabelOffset: */
	((methodLabel->operands))[1] = MFMethodFlagIsBlockFlag;

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}

	/* PushR: */
	genoperand(PushR, SendNumArgsReg);
	flag("TODO");
	genLoadSlotsourceRegdestReg(FullClosureReceiverIndex, ClassReg, Arg0Reg);
	genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, FullClosureReceiverIndex, ReceiverResultReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);

	/* PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = 0; i < numCopied; i += 1) {
		genLoadSlotsourceRegdestReg(i + FullClosureFirstCopiedValueIndex, ClassReg, TempReg);

		/* PushR: */
		genoperand(PushR, TempReg);
	}
	toDoLimit = temporaryCountOfMethodHeader(methodHeader);
	for (i = ((methodOrBlockNumArgs + numCopied) + 1); i <= toDoLimit; i += 1) {
		/* PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	stackCheckLabel = compileStackOverflowCheck(1);
	initSimStackForFramefulMethod(initialPC);
}


/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. receiver (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	If there is a primitive and an error code the Nth temp is the error code.
	Ensure SendNumArgsReg is set early on (incidentally to nilObj) because
	it is the flag determining whether context switch is allowed on
	stack-overflow.  */
/*	We are in a method where the frame is needed *only* for instance variable
	store, typically a setter method.
	This case has 20% overhead with Immutability compared to setter without
	immutability because of the stack
	frame creation. We compile two path, one where the object is immutable,
	one where it isn't. At the beginning 
	of the frame build, we take one path or the other depending on the
	receiver mutability.
	
	Note: this specific case happens only where there are only instance
	variabel stores. We could do something
	similar for literal variable stores, but we don't as it's too uncommon.
 */

	/* StackToRegisterMappingCogit>>#compileTwoPathFrameBuild */
#if IMMUTABILITY
static void
compileTwoPathFrameBuild(void)
{
    AbstractInstruction *anInstruction;
    sqInt i;
    AbstractInstruction *jumpImmutable;
    AbstractInstruction *jumpOld;
    sqInt quickConstant;
    sqInt toDoLimit;

	assert(useTwoPaths);
	assert(blockCount == 0);
	jumpImmutable = genJumpImmutablescratchReg(ReceiverResultReg, TempReg);

	/* begin genJumpInOldSpace: */
	quickConstant = storeCheckBoundary();
	anInstruction = genoperandoperand(CmpCqR, quickConstant, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	assert(!needsFrame);
	initSimStackForFramelessMethod(initialPC);

	/* begin compileMethodBody */
	if (endPC < initialPC) {
		goto l1;
	}
	compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
l1:	/* end compileMethodBody */;

	/* reset because it impacts inst var store compilation */
	useTwoPaths = 0;
	needsFrame = 1;
	jmpTarget(jumpOld, jmpTarget(jumpImmutable, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genPushRegisterArgs();
	if (!needsFrame) {
		return;
	}

	/* PushR: */
	genoperand(PushR, LinkReg);

	/* PushR: */
	genoperand(PushR, FPReg);

	/* MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperand(PushCw, ((sqInt)methodLabel)))));

	/* begin genMoveConstant:R: */
	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(nilObject(), BytesPerOop));
	}

	/* PushR: */
	genoperand(PushR, SendNumArgsReg);

	/* PushR: */
	genoperand(PushR, ReceiverResultReg);
	toDoLimit = temporaryCountOfMethodHeader(methodHeader);
	for (i = (methodOrBlockNumArgs + 1); i <= toDoLimit; i += 1) {
		/* PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	if (/* methodUsesPrimitiveErrorCode:header: */
		((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))) {
		compileGetErrorCode();
	}
	stackCheckLabel = compileStackOverflowCheck(canContextSwitchIfActivatingheader(methodObj, methodHeader));
	initSimStackForFramefulMethod(initialPC);
}
#endif /* IMMUTABILITY */


/*	We are in a frameless method with at least two inst var stores. We compile
	two paths,
	one where the object is in new space, and one where it isn't. At the
	beginning 
	of the method, we take one path or the other depending on the receiver
	being in newSpace.
 */

	/* StackToRegisterMappingCogit>>#compileTwoPathFramelessInit */
static void
compileTwoPathFramelessInit(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpOld;
    sqInt quickConstant;

	assert(!(IMMUTABILITY));
	assert(!(needsFrame));
	assert(useTwoPaths);

	/* begin genJumpInOldSpace: */
	quickConstant = storeCheckBoundary();
	anInstruction = genoperandoperand(CmpCqR, quickConstant, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	initSimStackForFramelessMethod(initialPC);

	/* begin compileMethodBody */
	if (endPC < initialPC) {
		goto l1;
	}
	compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
l1:	/* end compileMethodBody */;

	/* reset because it impacts inst var store compilation */
	useTwoPaths = 0;
	jmpTarget(jumpOld, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
}

	/* StackToRegisterMappingCogit>>#cPICMissTrampolineFor: */
static NoDbgRegParms sqInt
cPICMissTrampolineFor(sqInt numArgs)
{
	return picMissTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}


/*	Replaces the Blue Book double-extended send [132], in which the first byte
	was wasted on 8 bits of argument count. 
	Here we use 3 bits for the operation sub-type (opType), and the remaining
	5 bits for argument count where needed. 
	The last byte give access to 256 instVars or literals. 
	See also secondExtendedSendBytecode
 */

	/* StackToRegisterMappingCogit>>#doubleExtendedDoAnythingBytecode */
static sqInt
doubleExtendedDoAnythingBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt opType;

	opType = ((usqInt)(byte1)) >> 5;
	if (!opType) {
		return genSendnumArgs(byte2, byte1 & 0x1F);
	}
	if (opType == 1) {
		return genSendSupernumArgs(byte2, byte1 & 0x1F);
	}
	switch (opType) {
	case 2:
		if (isReadMediatedContextInstVarIndex(byte2)) {
			genPushMaybeContextReceiverVariable(byte2);
		}
		else {
			genPushReceiverVariable(byte2);

			/* begin annotateInstructionForBytecode */
			abstractInstruction = (prevInstIsPCAnnotated()
						? gen(Nop)
						: genoperandoperand(Label, (labelCounter += 1), bytecodePC));

			/* begin annotateBytecode: */
			(abstractInstruction->annotation = HasBytecodePC);
			return 0;
		}
		break;
	case 3:
		genPushLiteralIndex(byte2);

		/* begin annotateInstructionForBytecode */
		abstractInstruction = (prevInstIsPCAnnotated()
					? gen(Nop)
					: genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		return 0;

	case 4:
		genPushLiteralVariable(byte2);
		break;
	case 7:
		/* genStorePop:LiteralVariable: */
		genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(0, byte2, /* ssTopNeedsStoreCheck */
			((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (/* shouldAnnotateObjectReference: */
			(isNonImmediate(((ssTop())->constant)))
		 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
		 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
#    if IMMUTABILITY

		/* genStorePop:LiteralVariable: annotates; don't annotate twice */
		return 0;
#    endif


	default:

		/* 5 & 6 */
		if (isWriteMediatedContextInstVarIndex(byte2)) {
			/* genStorePop:MaybeContextReceiverVariable: */
			genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(opType == 6, byte2, /* ssTopNeedsStoreCheck */
				((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (/* shouldAnnotateObjectReference: */
				(isNonImmediate(((ssTop())->constant)))
			 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
			 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
		}
		else {
			/* genStorePop:ReceiverVariable: */
			genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(opType == 6, byte2, /* ssTopNeedsStoreCheck */
				((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (/* shouldAnnotateObjectReference: */
				(isNonImmediate(((ssTop())->constant)))
			 && ((oopisGreaterThan(((ssTop())->constant), classTableRootObj()))
			 || (oopisLessThan(((ssTop())->constant), nilObject()))))), 1);
		}
#    if IMMUTABILITY

		/* genStorePop:...ReceiverVariable: annotate; don't annotate twice */
		return 0;
#    endif

;
	}
	assert(needsFrame);
	assert(!(prevInstIsPCAnnotated()));
	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#duplicateTopBytecode */
static sqInt
duplicateTopBytecode(void)
{
    SimStackEntry desc;

	/* begin ssTopDescriptor */
	desc = simStack[simStackPtr];
	return ssPushDesc(desc);
}

	/* StackToRegisterMappingCogit>>#endHighLevelCallWithCleanup */
static void
endHighLevelCallWithCleanup(void)
{
    AbstractInstruction *anInstruction;

	if (currentCallCleanUpSize > 0) {
		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, currentCallCleanUpSize, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(currentCallCleanUpSize, BytesPerOop));
		}
	}
	callSwitchToSmalltalkStack();
}

	/* StackToRegisterMappingCogit>>#endHighLevelCallWithoutCleanup */
static void
endHighLevelCallWithoutCleanup(void)
{
	callSwitchToSmalltalkStack();
}


/*	Make sure there's a flagged fixup at the target pc in fixups.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#ensureFixupAt: */
static NoDbgRegParms BytecodeFixup *
ensureFixupAt(sqInt targetPC)
{
    BytecodeFixup *fixup;

	/* begin fixupAt: */
	fixup = fixupAtIndex(targetPC - initialPC);
	traceFixupmerge(fixup, 1);
	if ((((usqInt)((fixup->targetInstruction)))) <= NeedsNonMergeFixupFlag) {

		/* convert a non-merge into a merge */
		/* begin becomeMergeFixup */
		(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);
		(fixup->simStackPtr = simStackPtr);
		(fixup->simNativeStackPtr = simNativeStackPtr);
		(fixup->simNativeStackSize = simNativeStackSize);
	}
	else {
		if ((fixup->isTargetOfBackwardBranch)) {

			/* this is the target of a backward branch and
			   so doesn't have a simStackPtr assigned yet. */
			(fixup->simStackPtr = simStackPtr);
			(fixup->simNativeStackPtr = simNativeStackPtr);
			(fixup->simNativeStackSize = simNativeStackSize);
		}
		else {
			assert(((fixup->simStackPtr)) == simStackPtr);
			assert(((fixup->simNativeStackPtr)) == simNativeStackPtr);
			assert(((fixup->simNativeStackSize)) == simNativeStackSize);
		}
	}
	return fixup;
}


/*	Make sure there's a flagged fixup at the target pc in fixups.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#ensureNonMergeFixupAt: */
static NoDbgRegParms BytecodeFixup *
ensureNonMergeFixupAt(sqInt targetPC)
{
    BytecodeFixup *fixup;

	/* begin fixupAt: */
	fixup = fixupAtIndex(targetPC - initialPC);
	traceFixupmerge(fixup, 1);
	if (!((fixup->targetInstruction))) {
		/* begin becomeNonMergeFixup */
		(fixup->targetInstruction) = ((AbstractInstruction *) NeedsNonMergeFixupFlag);
	}
	return fixup;
}

	/* StackToRegisterMappingCogit>>#ensureReceiverResultRegContainsSelf */
static void
ensureReceiverResultRegContainsSelf(void)
{
	if (needsFrame) {
		if (!((((simSelf())->liveRegister)) == ReceiverResultReg)) {
			/* begin ssAllocateRequiredReg: */
			ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
			storeToReg(simSelf(), ReceiverResultReg);
			((simSelf())->liveRegister = ReceiverResultReg);
		}
	}
	else {
		assert(((((simSelf())->type)) == SSRegister)
		 && (((((simSelf())->registerr)) == ReceiverResultReg)
		 && (receiverIsInReceiverResultReg())));
	}
}

	/* StackToRegisterMappingCogit>>#evaluate:at: */
static NoDbgRegParms void
evaluateat(BytecodeDescriptor *descriptor, sqInt pc)
{
	byte0 = fetchByteofObject(pc, methodObj);
	assert(descriptor == (generatorAt(bytecodeSetOffset + byte0)));
	loadSubsequentBytesForDescriptorat(descriptor, pc);
	((descriptor->generator))();
}


/*	Attempt to follow a branch to a pc. Handle branches to unconditional jumps
	and branches to push: aBoolean; conditional branch pairs. If the branch
	cannot be
	followed answer targetBytecodePC. It is not possible to follow jumps to
	conditional branches because the stack changes depth. That following is
	left to the genJumpIf:to:
	clients. */

	/* StackToRegisterMappingCogit>>#eventualTargetOf: */
static NoDbgRegParms sqInt
eventualTargetOf(sqInt targetBytecodePC)
{
    sqInt cond;
    sqInt currentTarget;
    BytecodeDescriptor *descriptor;
    sqInt nExts;
    sqInt nextPC;
    sqInt span;

	cond = 0;
	descriptor = ((BytecodeDescriptor *) 0);
	nextPC = (currentTarget = targetBytecodePC);
	while (1) {
		nExts = 0;
		while (1) {
			/* begin generatorForPC: */
			descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC, methodObj)));
			if ((descriptor->isReturn)) {
				return currentTarget;
			}
			if (!((descriptor->isExtension))) break;
			nExts += 1;
			nextPC += (descriptor->numBytes);
		}
		if (/* isUnconditionalBranch */
			(isBranch(descriptor))
		 && (!(((descriptor->isBranchTrue))
		 || ((descriptor->isBranchFalse))))) {
			span = ((descriptor->spanFunction))(descriptor, nextPC, nExts, methodObj);
			if (span < 0) {

				/* Do *not* follow backward branches; these are interrupt points and should not be elided. */
				return currentTarget;
			}
			nextPC = (nextPC + ((descriptor->numBytes))) + span;
		}
		else {
			if (((descriptor->generator)) == genPushConstantTrueBytecode) {
				cond = 1;
			}
			else {
				if (((descriptor->generator)) == genPushConstantFalseBytecode) {
					cond = 0;
				}
				else {
					return currentTarget;
				}
			}
			if (isBackwardBranchFixup(fixupAt(nextPC))) {
				return currentTarget;
			}
			nextPC = eventualTargetOf(nextPC + ((descriptor->numBytes)));
			nExts = 0;
			while (1) {
				/* begin generatorForPC: */
				descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC, methodObj)));
				if ((descriptor->isReturn)) {
					return currentTarget;
				}
				if (!((descriptor->isExtension))) break;
				nExts += 1;
				nextPC += (descriptor->numBytes);
			}
			if (!(isBranch(descriptor))) {
				return currentTarget;
			}
			if (/* isUnconditionalBranch */
				(isBranch(descriptor))
			 && (!(((descriptor->isBranchTrue))
			 || ((descriptor->isBranchFalse))))) {
				return currentTarget;
			}
			nextPC = (cond == ((descriptor->isBranchTrue))
						? (nextPC + ((descriptor->numBytes))) + (((descriptor->spanFunction))(descriptor, nextPC, nExts, methodObj))
						: nextPC + ((descriptor->numBytes)));
		}
		currentTarget = nextPC;
	}
	return 0;
}


/*	Spill the closest register on stack not conflicting with regMask. 
	Assertion Failure if regMask has already all the registers */

	/* StackToRegisterMappingCogit>>#freeAnyFloatRegNotConflictingWith: */
static NoDbgRegParms sqInt
freeAnyFloatRegNotConflictingWith(sqInt regMask)
{
    CogSimStackEntry *desc;
    sqInt index;
    sqInt reg;

	assert(needsFrame);
	reg = NoReg;
	index = ((simSpillBase < 0) ? 0 : simSpillBase);
	index = ((simNativeSpillBase < 0) ? 0 : simNativeSpillBase);
	while ((reg == NoReg)
	 && (index < simNativeStackPtr)) {
		desc = simNativeStackAt(index);
		if ((((desc->type)) == SSRegisterSingleFloat)
		 || (((desc->type)) == SSRegisterDoubleFloat)) {
			if (!(((regMask & (((((desc->registerr)) < 0) ? (((usqInt)(1)) >> (-((desc->registerr)))) : (1ULL << ((desc->registerr)))))) != 0))) {
				reg = (desc->registerr);
			}
		}
		index += 1;
	}
	assert(!((reg == NoReg)));
	ssAllocateRequiredFloatReg(reg);
	return reg;
}


/*	Spill the closest register on stack not conflicting with regMask. 
	Assertion Failure if regMask has already all the registers */

	/* StackToRegisterMappingCogit>>#freeAnyRegNotConflictingWith: */
static NoDbgRegParms sqInt
freeAnyRegNotConflictingWith(sqInt regMask)
{
    CogSimStackEntry *desc;
    sqInt index;
    sqInt reg;

	assert(needsFrame);
	reg = NoReg;
	index = ((simSpillBase < 0) ? 0 : simSpillBase);
	while ((reg == NoReg)
	 && (index < simStackPtr)) {
		desc = simStackAt(index);
		if (((desc->type)) == SSRegister) {
			if (!(((regMask & (((((desc->registerr)) < 0) ? (((usqInt)(1)) >> (-((desc->registerr)))) : (1ULL << ((desc->registerr)))))) != 0))) {
				reg = (desc->registerr);
			}
		}
		index += 1;
	}
	assert(!((reg == NoReg)));

	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg)), simStackPtr, simNativeStackPtr);
	return reg;
}


/*	Return from block, assuming result already loaded into ReceiverResultReg. */
/*	Return from block, assuming result already loaded into ReceiverResultReg. */

	/* StackToRegisterMappingCogit>>#genBlockReturn */
static sqInt
genBlockReturn(void)
{
	if (needsFrame) {
		/* MoveR:R: */
		genoperandoperand(MoveRR, FPReg, SPReg);

		/* PopR: */
		genoperand(PopR, FPReg);

		/* PopR: */
		genoperand(PopR, LinkReg);
	}

	/* RetN: */
	genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);

	/* can't fall through */
	deadCode = 1;
	return 0;
}


/*	Generate special versions of the ceCallCogCodePopReceiverAndClassRegs
	enilopmart that also pop register args from the stack to undo the pushing
	of register args in the abort/miss trampolines. */

	/* StackToRegisterMappingCogit>>#genCallPICEnilopmartNumArgs: */
static NoDbgRegParms void
(*genCallPICEnilopmartNumArgs(sqInt numArgs))(void)
{
    AbstractInstruction *anInstruction;
    sqInt endAddress;
    usqInt enilopmart;
    sqInt quickConstant;
    sqInt size;

	zeroOpcodeIndex();
	quickConstant = varBaseAddress;

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	genLoadStackPointers(backEnd);

	/* PopR: */
	genoperand(PopR, ClassReg);

	/* PopR: */
	genoperand(PopR, TempReg);

	/* PopR: */
	genoperand(PopR, LinkReg);
	if (numArgs > 0) {
		if (numArgs > 1) {
			/* PopR: */
			genoperand(PopR, Arg1Reg);
			assert((numRegArgs()) == 2);
		}

		/* PopR: */
		genoperand(PopR, Arg0Reg);
	}

	/* PopR: */
	genoperand(PopR, ReceiverResultReg);

	/* JumpR: */
	genoperand(JumpR, TempReg);
	computeMaximumSizes();
	size = generateInstructionsAt(methodZoneBase);
	endAddress = outputInstructionsAt(methodZoneBase);
	assert((methodZoneBase + size) == endAddress);
	enilopmart = methodZoneBase;
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	recordGeneratedRunTimeaddress(trampolineNamenumRegArgs("ceCallPIC", numArgs), enilopmart);
	return ((void (*)(void)) enilopmart);
}


/*	SistaV1:	**	248	(2)	11111000 iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii
	+ (jjjjj * 256) 
	m=1 means inlined primitive, no hard return after execution. 
	ss defines the unsafe operation set used to encode the operations. 
	(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations,
	other numbers are as yet used).
	See SistaCogit genCallPrimitiveBytecode, EncoderForSistaV1's class comment
	and StackInterpreter>>#callPrimitiveBytecode for more information. */

	/* StackToRegisterMappingCogit>>#genCallPrimitiveBytecode */
static sqInt
genCallPrimitiveBytecode(void)
{
    sqInt prim;
    usqInt primSet;

	if (byte2 < 128) {
		return (bytecodePC == initialPC
				? 0
				: EncounteredUnknownBytecode);
	}
	prim = ((((usqInt)((byte2 - 128)) << 8))) + byte1;
	primSet = (((usqInt)(prim)) >> 13) & 3;
	prim = prim & 0x1FFF;
	if (primSet == 1) {
		if (prim < 1000) {
			return genLowcodeNullaryInlinePrimitive(prim);
		}
		if (prim < 2000) {
			return genLowcodeUnaryInlinePrimitive(prim - 1000);
		}
		if (prim < 3000) {
			return genLowcodeBinaryInlinePrimitive(prim - 2000);
		}
		if (prim < 4000) {
			return genLowcodeTrinaryInlinePrimitive(prim - 3000);
		}
	}
	return EncounteredUnknownBytecode;
}


/*	Override to push the register receiver and register arguments, if any. */

	/* StackToRegisterMappingCogit>>#genExternalizePointersForPrimitiveCall */
static sqInt
genExternalizePointersForPrimitiveCall(void)
{
	genPushRegisterArgs();

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, LinkReg, instructionPointerAddress()));
	return genSaveStackPointers(backEnd);
}


/*	Override to push the register receiver and register arguments, if any. */

	/* StackToRegisterMappingCogit>>#genExternalizeStackPointerForFastPrimitiveCall */
static AbstractInstruction *
genExternalizeStackPointerForFastPrimitiveCall(void)
{
	genPushRegisterArgs();
	return checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveRAw, SPReg, stackPointerAddress()));
}


/*	Block compilation. At this point in the method create the block. Note its
	start and defer generating code for it until after the method and any
	other preceding
	blocks. The block's actual code will be compiled later. */
/*	253		11111101 eei i i kkk	jjjjjjjj		Push Closure Num Copied iii (+ Ext A
	// 16 * 8) Num Args kkk (+ Ext A \\ 16 * 8) BlockSize jjjjjjjj (+ Ext B *
	256). ee = num extensions
 */

	/* StackToRegisterMappingCogit>>#genExtPushClosureBytecode */
static sqInt
genExtPushClosureBytecode(void)
{
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt reg;
    sqInt startpc;

	assert(needsFrame);
	startpc = bytecodePC + (((generatorAt(byte0))->numBytes));
	addBlockStartAtnumArgsnumCopiedspan(startpc, (numArgs = (byte1 & 7) + ((extA % 16) * 8)), (numCopied = ((((usqInt)(byte1)) >> 3) & 7) + ((extA / 16) * 8)), byte2 + ((((usqInt)(extB) << 8))));
	extA = (numExtB = (extB = 0));

	/* begin genInlineClosure:numArgs:numCopied: */
	assert(getActiveContextAllocatesInMachineCode());
	voidReceiverResultRegContainsSelf();

	/* begin ssAllocateCallReg:and:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg)), simStackPtr, simNativeStackPtr);
	genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(startpc + 1, numArgs, numCopied, methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	for (i = 1; i <= numCopied; i += 1) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
		genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, (ClosureFirstCopiedValueIndex + numCopied) - i, ReceiverResultReg);
	}
	ssPushRegister(ReceiverResultReg);
	return 0;
}


/*	Full Block creation compilation. The block's actual code will be compiled
	separatedly. 
 */
/*	*	255		11111111	xxxxxxxx	siyyyyyy	push Closure Compiled block literal
	index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1
	ignoreOuterContext: i = 1
 */

	/* StackToRegisterMappingCogit>>#genExtPushFullClosureBytecode */
static sqInt
genExtPushFullClosureBytecode(void)
{
    sqInt compiledBlock;
    sqInt i;
    int ignoreContext;
    sqInt numCopied;
    int receiverIsOnStack;
    sqInt reg;

	assert(needsFrame);
	compiledBlock = getLiteral(byte1 + ((((usqInt)(extA) << 8))));
	extA = 0;
	numCopied = byte2 & (0x3F);
	receiverIsOnStack = ((byte2 & (128)) != 0);
	ignoreContext = ((byte2 & (64)) != 0);
	voidReceiverResultRegContainsSelf();

	/* begin ssAllocateCallReg:and:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg)), simStackPtr, simNativeStackPtr);
	genCreateFullClosurenumArgsnumCopiedignoreContextcontextNumArgslargeinBlock(compiledBlock, argumentCountOf(compiledBlock), numCopied, ignoreContext, methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	for (i = 1; i <= numCopied; i += 1) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
		genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, (FullClosureFirstCopiedValueIndex + numCopied) - i, ReceiverResultReg);
	}
	if (receiverIsOnStack) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
	}
	else {
		storeToReg(simSelf(), (reg = TempReg));
	}
	genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, FullClosureReceiverIndex, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
	return 0;
}


/*	Enilopmarts transfer control from C into machine code (backwards
	trampolines). 
 */
/*	Enilopmarts transfer control from C into machine code (backwards
	trampolines). Override to add version for generic and PIC-specific entry
	with reg args. */

	/* StackToRegisterMappingCogit>>#generateEnilopmarts */
static void
generateEnilopmarts(void)
{

#  if Debug
	/* begin genEnilopmartFor:forCall:called: */
	realCEEnterCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 0, "realCEEnterCogCodePopReceiverReg");
	ceEnterCogCodePopReceiverReg = enterCogCodePopReceiver;

	/* begin genEnilopmartFor:forCall:called: */
	realCECallCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 1, "realCECallCogCodePopReceiverReg");
	ceCallCogCodePopReceiverReg = callCogCodePopReceiver;

	/* begin genEnilopmartFor:and:forCall:called: */
	realCECallCogCodePopReceiverAndClassRegs = genEnilopmartForandandforCallcalled(ReceiverResultReg, ClassReg, NoReg, 1, "realCECallCogCodePopReceiverAndClassRegs");
	ceCallCogCodePopReceiverAndClassRegs = callCogCodePopReceiverAndClassRegs;
#  else // Debug
	/* begin genEnilopmartFor:forCall:called: */
	ceEnterCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 0, "ceEnterCogCodePopReceiverReg");
	ceCallCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 1, "ceCallCogCodePopReceiverReg");
	ceCallCogCodePopReceiverAndClassRegs = genEnilopmartForandandforCallcalled(ReceiverResultReg, ClassReg, NoReg, 1, "ceCallCogCodePopReceiverAndClassRegs");
#  endif // Debug

	genPrimReturnEnterCogCodeEnilopmart(0);
	cePrimReturnEnterCogCode = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(cePrimReturnEnterCogCode);
	recordGeneratedRunTimeaddress("cePrimReturnEnterCogCode", cePrimReturnEnterCogCode);
	genPrimReturnEnterCogCodeEnilopmart(1);
	cePrimReturnEnterCogCodeProfiling = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(cePrimReturnEnterCogCodeProfiling);
	recordGeneratedRunTimeaddress("cePrimReturnEnterCogCodeProfiling", cePrimReturnEnterCogCodeProfiling);
#  if Debug
	/* begin genEnilopmartFor:and:forCall:called: */
	realCECallCogCodePopReceiverArg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, NoReg, 1, "realCECallCogCodePopReceiverArg0Regs");
	ceCallCogCodePopReceiverArg0Regs = callCogCodePopReceiverArg0Regs;
	realCECallCogCodePopReceiverArg1Arg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, Arg1Reg, 1, "realCECallCogCodePopReceiverArg1Arg0Regs");
	ceCallCogCodePopReceiverArg1Arg0Regs = callCogCodePopReceiverArg1Arg0Regs;
#  else // Debug
	/* begin genEnilopmartFor:and:forCall:called: */
	ceCallCogCodePopReceiverArg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, NoReg, 1, "ceCallCogCodePopReceiverArg0Regs");
	ceCallCogCodePopReceiverArg1Arg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, Arg1Reg, 1, "ceCallCogCodePopReceiverArg1Arg0Regs");
#  endif // Debug

	ceCall0ArgsPIC = genCallPICEnilopmartNumArgs(0);
	ceCall1ArgsPIC = genCallPICEnilopmartNumArgs(1);
	ceCall2ArgsPIC = genCallPICEnilopmartNumArgs(2);
	assert((numRegArgs()) == 2);
}


/*	Size pc-dependent instructions and assign eventual addresses to all
	instructions. Answer the size of the code.
	Compute forward branches based on virtual address (abstract code starts at
	0), assuming that any branches branched over are long.
	Compute backward branches based on actual address.
	Reuse the fixups array to record the pc-dependent instructions that need
	to have
	their code generation postponed until after the others.
	
	Override to add handling for null branches (branches to the immediately
	following instruction) occasioned by StackToRegisterMapping's following of
	jumps.  */

	/* StackToRegisterMappingCogit>>#generateInstructionsAt: */
static NoDbgRegParms sqInt
generateInstructionsAt(sqInt eventualAbsoluteAddress)
{
    sqInt absoluteAddress;
    AbstractInstruction *abstractInstruction;
    BytecodeFixup *fixup;
    sqInt i;
    sqInt j;
    sqInt pcDependentIndex;

	absoluteAddress = eventualAbsoluteAddress;
	pcDependentIndex = 0;
	for (i = 0; i < opcodeIndex; i += 1) {
		/* N.B. if you want to break in resizing, break here, note the instruction index, back up to the
		   sender, restart, and step into computeMaximumSizes, breaking at this instruction's index. */
		abstractInstruction = abstractInstructionAt(i);
		maybeBreakGeneratingFromto(absoluteAddress, absoluteAddress + ((abstractInstruction->maxSize)));
		if (isPCDependent(abstractInstruction)) {
			sizePCDependentInstructionAt(abstractInstruction, absoluteAddress);
			if ((isJump(abstractInstruction))
			 && ((((i + 1) < opcodeIndex)
			 && ((((AbstractInstruction *) (((abstractInstruction->operands))[0]))) == (abstractInstructionAt(i + 1))))
			 || (((i + 2) < opcodeIndex)
			 && (((((AbstractInstruction *) (((abstractInstruction->operands))[0]))) == (abstractInstructionAt(i + 2)))
			 && ((((abstractInstructionAt(i + 1))->opcode)) == Nop))))) {
				(abstractInstruction->opcode = Nop);
				concretizeAt(abstractInstruction, absoluteAddress);
			}
			else {
				fixup = fixupAtIndex(pcDependentIndex);
				pcDependentIndex += 1;
				(fixup->instructionIndex = i);
			}
			absoluteAddress += (abstractInstruction->machineCodeSize);
		}
		else {
			/* N.B. if you want to break in resizing, break here, note the instruction index, back up to the
			   sender, restart, and step into computeMaximumSizes, breaking at this instruction's index. */
			absoluteAddress = concretizeAt(abstractInstruction, absoluteAddress);
			assert(((abstractInstruction->machineCodeSize)) == ((abstractInstruction->maxSize)));
		}
	}
	for (j = 0; j < pcDependentIndex; j += 1) {
		fixup = fixupAtIndex(j);
		abstractInstruction = abstractInstructionAt((fixup->instructionIndex));
		maybeBreakGeneratingFromto((abstractInstruction->address), (((abstractInstruction->address)) + ((abstractInstruction->maxSize))) - 1);
		concretizeAt(abstractInstruction, (abstractInstruction->address));
	}
	return absoluteAddress - eventualAbsoluteAddress;
}


/*	Generate the run-time entries for the various method and PIC entry misses
	and aborts.
	Read the class-side method trampolines for documentation on the various
	trampolines 
 */

	/* StackToRegisterMappingCogit>>#generateMissAbortTrampolines */
static void
generateMissAbortTrampolines(void)
{
    sqInt numArgs;
    sqInt toDoLimit;
    sqInt toDoLimit1;
    sqInt toDoLimit2;

	toDoLimit = (numRegArgs()) + 1;
	for (numArgs = 0; numArgs <= toDoLimit; numArgs += 1) {
		methodAbortTrampolines[numArgs] = (genMethodAbortTrampolineFor(numArgs));
	}
	toDoLimit1 = (numRegArgs()) + 1;
	for (numArgs = 0; numArgs <= toDoLimit1; numArgs += 1) {
		picAbortTrampolines[numArgs] = (genPICAbortTrampolineFor(numArgs));
	}
	toDoLimit2 = (numRegArgs()) + 1;
	for (numArgs = 0; numArgs <= toDoLimit2; numArgs += 1) {
		picMissTrampolines[numArgs] = (genPICMissTrampolineFor(numArgs));
	}
	ceReapAndResetErrorCodeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceReapAndResetErrorCodeFor, "ceReapAndResetErrorCodeTrampoline", 1, ClassReg, null, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 0);
}


/*	Override to generate code to push the register arg(s) for <= numRegArg
	arity sends.
 */

	/* StackToRegisterMappingCogit>>#generateSendTrampolines */
static void
generateSendTrampolines(void)
{
    sqInt numArgs;

	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		ordinarySendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(
	ceSendsupertonumArgs,
	numArgs,
	trampolineNamenumArgs("ceSend", numArgs),
	ClassReg,
	(/* begin trampolineArgConstant: */
		assert(0 >= 0),
	-2 - 0),
	ReceiverResultReg,
	/* numArgsOrSendNumArgsReg: */
		(numArgs <= (NumSendTrampolines - 2)
			? (/* begin trampolineArgConstant: */
				assert(numArgs >= 0),
			-2 - numArgs)
			: SendNumArgsReg)));
	}
	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		directedSuperSendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(ceSendabovetonumArgs, numArgs, trampolineNamenumArgs("ceDirectedSuperSend", numArgs), ClassReg, TempReg, ReceiverResultReg, /* numArgsOrSendNumArgsReg: */
	(numArgs <= (NumSendTrampolines - 2)
		? (/* begin trampolineArgConstant: */
			assert(numArgs >= 0),
		-2 - numArgs)
		: SendNumArgsReg)));
		directedSuperBindingSendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(ceSendaboveClassBindingtonumArgs, numArgs, trampolineNamenumArgs("ceDirectedSuperBindingSend", numArgs), ClassReg, TempReg, ReceiverResultReg, /* numArgsOrSendNumArgsReg: */
	(numArgs <= (NumSendTrampolines - 2)
		? (/* begin trampolineArgConstant: */
			assert(numArgs >= 0),
		-2 - numArgs)
		: SendNumArgsReg)));
	}
	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		superSendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(
	ceSendsupertonumArgs,
	numArgs,
	trampolineNamenumArgs("ceSuperSend", numArgs),
	ClassReg,
	(/* begin trampolineArgConstant: */
		assert(1 >= 0),
	-2 - 1),
	ReceiverResultReg,
	/* numArgsOrSendNumArgsReg: */
		(numArgs <= (NumSendTrampolines - 2)
			? (/* begin trampolineArgConstant: */
				assert(numArgs >= 0),
			-2 - numArgs)
			: SendNumArgsReg)));
	}
	firstSend = ordinarySendTrampolines[0];
	lastSend = superSendTrampolines[NumSendTrampolines - 1];
}


/*	Generate trampolines for tracing. In the simulator we can save a lot of
	time and avoid noise instructions in the lastNInstructions log by
	short-cutting these
	trampolines, but we need them in the real vm. */

	/* StackToRegisterMappingCogit>>#generateTracingTrampolines */
static void
generateTracingTrampolines(void)
{
	ceTraceLinkedSendTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceLinkedSend, "ceTraceLinkedSendTrampoline", 1, ReceiverResultReg, null, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
	ceTraceBlockActivationTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceBlockActivation, "ceTraceBlockActivationTrampoline", 0, null, null, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
	ceTraceStoreTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceStoreOfinto, "ceTraceStoreTrampoline", 2, TempReg, ReceiverResultReg, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
}

	/* StackToRegisterMappingCogit>>#genForwardersInlinedIdenticalOrNotIf: */
static NoDbgRegParms sqInt
genForwardersInlinedIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *anInstruction;
    sqInt argConstant;
    sqInt argNeedsReg;
    sqInt argReg;
    sqInt argRegSqInt;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt constant;
    BytecodeFixup *fixup;
    sqInt i;
    void *jumpTarget;
    AbstractInstruction *label;
    sqInt nExts;
    sqInt nextPC;
    sqInt nextPCSqInt;
    sqInt postBranchPC;
    sqInt postBranchPCSqInt;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrConstant;
    sqInt rcvrNeedsReg;
    sqInt rcvrReg;
    sqInt rcvrRegSqInt;
    sqInt reg;
    sqInt rNextSqInt;
    sqInt rTopSqInt;
    BytecodeFixup *self_in_CogBytecodeFixup;
    CogSimStackEntry *simStackEntry;
    sqInt targetBytecodePC;
    sqInt targetBytecodePCSqInt;
    sqInt topRegistersMask;
    sqInt unforwardArg;
    sqInt unforwardRcvr;

	unforwardRcvr = mayBeAForwarder(ssValue(1));
	unforwardArg = mayBeAForwarder(ssTop());
	if ((!unforwardRcvr)
	 && (!unforwardArg)) {
		return genVanillaInlinedIdenticalOrNotIf(orNot);
	}
	assert(unforwardArg
	 || (unforwardRcvr));
	simStackEntry = ssValue(1);

	/* begin isUnannotatableConstant: */
	rcvrConstant = (((simStackEntry->type)) == SSConstant)
		 && ((isImmediate((simStackEntry->constant)))
		 || (!(/* shouldAnnotateObjectReference: */
			(isNonImmediate((simStackEntry->constant)))
		 && ((oopisGreaterThan((simStackEntry->constant), classTableRootObj()))
		 || (oopisLessThan((simStackEntry->constant), nilObject()))))));
	simStackEntry = ssTop();

	/* begin isUnannotatableConstant: */
	argConstant = (((simStackEntry->type)) == SSConstant)
		 && ((isImmediate((simStackEntry->constant)))
		 || (!(/* shouldAnnotateObjectReference: */
			(isNonImmediate((simStackEntry->constant)))
		 && ((oopisGreaterThan((simStackEntry->constant), classTableRootObj()))
		 || (oopisLessThan((simStackEntry->constant), nilObject()))))));

	/* begin extractMaybeBranchDescriptorInto: */
	branchDescriptor1 = ((BytecodeDescriptor *) 0);
	primDescriptor = generatorAt(byte0);
	nextPCSqInt = bytecodePC + ((primDescriptor->numBytes));
	nExts = 0;
	while (1) {
		while (1) {
			/* begin generatorForPC: */
			branchDescriptor1 = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPCSqInt, methodObj)));
			if (!((branchDescriptor1->isExtension))) break;
			nExts += 1;
			nextPCSqInt += (branchDescriptor1->numBytes);
		}
		if (!(/* isUnconditionalBranch */
			(isBranch(branchDescriptor1))
		 && (!(((branchDescriptor1->isBranchTrue))
		 || ((branchDescriptor1->isBranchFalse)))))) break;
		nextPCSqInt = eventualTargetOf((nextPCSqInt + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPCSqInt, nExts, methodObj)));
	}
	targetBytecodePCSqInt = (postBranchPCSqInt = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePCSqInt = eventualTargetOf((nextPCSqInt + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPCSqInt, nExts, methodObj)));
		postBranchPCSqInt = eventualTargetOf(nextPCSqInt + ((branchDescriptor1->numBytes)));
	}
	else {
		nextPCSqInt = bytecodePC + ((primDescriptor->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPCSqInt;
	postBranchPC = postBranchPCSqInt;
	targetBytecodePC = targetBytecodePCSqInt;
	argNeedsReg = !argConstant;
	rcvrNeedsReg = !rcvrConstant;

	/* begin allocateEqualsEqualsRegistersArgNeedsReg:rcvrNeedsReg:into: */
	assert(argNeedsReg
	 || (rcvrNeedsReg));
	argRegSqInt = (rcvrRegSqInt = NoReg);
	if (argNeedsReg) {
		if (rcvrNeedsReg) {
			/* begin allocateRegForStackTopTwoEntriesInto: */
			topRegistersMask = 0;
			rTopSqInt = (rNextSqInt = NoReg);
			if ((registerOrNone(ssTop())) != NoReg) {
				rTopSqInt = registerOrNone(ssTop());
			}
			if ((registerOrNone(ssValue(1))) != NoReg) {
				reg = (rNextSqInt = registerOrNone(ssValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
			if (rTopSqInt == NoReg) {
				rTopSqInt = allocateRegNotConflictingWith(topRegistersMask);
			}
			if (rNextSqInt == NoReg) {
				rNextSqInt = allocateRegNotConflictingWith(((rTopSqInt < 0) ? (((usqInt)(1)) >> (-rTopSqInt)) : (1ULL << rTopSqInt)));
			}
			assert(!(((rTopSqInt == NoReg)
 || (rNextSqInt == NoReg))));
			argRegSqInt = rTopSqInt;
			rcvrRegSqInt = rNextSqInt;
			popToReg(ssTop(), argRegSqInt);
			popToReg(ssValue(1), rcvrRegSqInt);
		}
		else {
			argRegSqInt = allocateRegForStackEntryAtnotConflictingWith(0, 0);
			popToReg(ssTop(), argRegSqInt);
			if (((ssValue(1))->spilled)) {
				/* begin AddCq:R: */
				/* begin gen:quickConstant:operand: */
				anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
				}
			}
		}
	}
	else {
		assert(rcvrNeedsReg);
		assert(!((((ssTop())->spilled))));
		rcvrRegSqInt = allocateRegForStackEntryAtnotConflictingWith(1, 0);
		popToReg(ssValue(1), rcvrRegSqInt);
	}
	assert(!((argNeedsReg
 && (argRegSqInt == NoReg))));
	assert(!((rcvrNeedsReg
 && (rcvrRegSqInt == NoReg))));
	rcvrReg = rcvrRegSqInt;
	argReg = argRegSqInt;
	if (!(((branchDescriptor->isBranchTrue))
		 || ((branchDescriptor->isBranchFalse)))) {
		return genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(argConstant, rcvrConstant, argReg, rcvrReg, orNot);
	}

	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= (simStackPtr - 2)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 2)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 2))); i <= (simStackPtr - 2); i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = (simStackPtr - 2) + 1;
	}
	label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* begin genCmpArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	assert((argReg != NoReg)
	 || (rcvrReg != NoReg));
	if (argConstant) {
		constant = ((ssTop())->constant);

		/* begin genCmpConstant:R: */
		if (/* shouldAnnotateObjectReference: */
			(isNonImmediate(constant))
		 && ((oopisGreaterThan(constant, classTableRootObj()))
		 || (oopisLessThan(constant, nilObject())))) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, rcvrReg)), constant);
		}
		else {
			/* begin CmpCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(CmpCqR, constant, rcvrReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
			}
		}
	}
	else {
		if (rcvrConstant) {
			constant = ((ssValue(1))->constant);

			/* begin genCmpConstant:R: */
			if (/* shouldAnnotateObjectReference: */
				(isNonImmediate(constant))
			 && ((oopisGreaterThan(constant, classTableRootObj()))
			 || (oopisLessThan(constant, nilObject())))) {
				annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, argReg)), constant);
			}
			else {
				/* begin CmpCq:R: */
				/* begin gen:quickConstant:operand: */
				anInstruction = genoperandoperand(CmpCqR, constant, argReg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
				}
			}
		}
		else {
			/* begin CmpR:R: */
			assert(!((argReg == SPReg)));
			genoperandoperand(CmpRR, argReg, rcvrReg);
		}
	}
	ssPop(2);

	/* begin fixupAt: */
	self_in_CogBytecodeFixup = fixupAtIndex(nextPC - initialPC);
	if ((self_in_CogBytecodeFixup->targetInstruction)) {
		assert(!(deadCode));
	}
	else {

		/* The next instruction is dead.  we can skip it. */
		deadCode = 1;
		ensureFixupAt(targetBytecodePC);
		ensureFixupAt(postBranchPC);
	}
	if (orNot == ((branchDescriptor->isBranchTrue))) {

		/* a == b ifFalse: ... or a ~~ b ifTrue: ... jump on equal to post-branch pc */
		fixup = ensureNonMergeFixupAt(targetBytecodePC);
		jumpTarget = ensureNonMergeFixupAt(postBranchPC);

		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
	}
	else {

		/* orNot is true for ~~ */
		/* a == b ifTrue: ... or a ~~ b ifFalse: ... jump on equal to target pc */
		fixup = ensureNonMergeFixupAt(postBranchPC);
		jumpTarget = ensureNonMergeFixupAt(targetBytecodePC);

		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
	}
	if (unforwardArg
	 && (unforwardRcvr)) {
		/* genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(argReg, TempReg, label, 0);
	}
	genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder((unforwardRcvr
			? rcvrReg
			: argReg), TempReg, label, fixup);
	if (!deadCode) {
		ssPushConstant(trueObject());
	}
	return 0;
}


/*	Generates the machine code for #== in the case where the instruction is
	not followed by a branch
 */

	/* StackToRegisterMappingCogit>>#genIdenticalNoBranchArgIsConstant:rcvrIsConstant:argReg:rcvrReg:orNotIf: */
static NoDbgRegParms sqInt
genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(sqInt argIsConstant, sqInt rcvrIsConstant, sqInt argReg, sqInt rcvrRegOrNone, sqInt orNot)
{
    AbstractInstruction *anInstruction;
    sqInt constant;
    AbstractInstruction *jumpEqual;
    AbstractInstruction *jumpNotEqual;
    AbstractInstruction *label;
    sqInt resultReg;

	label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* begin genCmpArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	assert((argReg != NoReg)
	 || (rcvrRegOrNone != NoReg));
	if (argIsConstant) {
		constant = ((ssTop())->constant);

		/* begin genCmpConstant:R: */
		if (/* shouldAnnotateObjectReference: */
			(isNonImmediate(constant))
		 && ((oopisGreaterThan(constant, classTableRootObj()))
		 || (oopisLessThan(constant, nilObject())))) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, rcvrRegOrNone)), constant);
		}
		else {
			/* begin CmpCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(CmpCqR, constant, rcvrRegOrNone);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
			}
		}
	}
	else {
		if (rcvrIsConstant) {
			constant = ((ssValue(1))->constant);

			/* begin genCmpConstant:R: */
			if (/* shouldAnnotateObjectReference: */
				(isNonImmediate(constant))
			 && ((oopisGreaterThan(constant, classTableRootObj()))
			 || (oopisLessThan(constant, nilObject())))) {
				annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, argReg)), constant);
			}
			else {
				/* begin CmpCq:R: */
				/* begin gen:quickConstant:operand: */
				anInstruction = genoperandoperand(CmpCqR, constant, argReg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
				}
			}
		}
		else {
			/* begin CmpR:R: */
			assert(!((argReg == SPReg)));
			genoperandoperand(CmpRR, argReg, rcvrRegOrNone);
		}
	}
	ssPop(2);
	resultReg = (rcvrRegOrNone == NoReg
				? argReg
				: rcvrRegOrNone);
	jumpEqual = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	if (!argIsConstant) {
		/* genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(argReg, TempReg, label, 0);
	}
	if (!rcvrIsConstant) {
		/* genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(rcvrRegOrNone, TempReg, label, 0);
	}
	if (orNot) {
		/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, trueObject(), resultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(trueObject(), BytesPerOop));
		}
	}
	else {
		/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, falseObject(), resultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(falseObject(), BytesPerOop));
		}
	}
	jumpNotEqual = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpEqual, (orNot
			? genMoveConstantR(falseObject(), resultReg)
			: genMoveConstantR(trueObject(), resultReg)));
	jmpTarget(jumpNotEqual, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushRegister(resultReg);
	return 0;
}


/*	Decompose code generation for #== into a common constant-folding version,
	followed by a double dispatch through the objectRepresentation to a
	version that doesn't deal with forwarders and a version that does. */

	/* StackToRegisterMappingCogit>>#genInlinedIdenticalOrNotIf: */
static NoDbgRegParms sqInt
genInlinedIdenticalOrNotIf(sqInt orNot)
{
    BytecodeDescriptor *primDescriptor;
    sqInt result;

	primDescriptor = generatorAt(byte0);
	if ((isUnannotatableConstant(ssTop()))
	 && (isUnannotatableConstant(ssValue(1)))) {
		assert(!((primDescriptor->isMapped)));
		result = ((orNot
					? (((ssTop())->constant)) != (((ssValue(1))->constant))
					: (((ssTop())->constant)) == (((ssValue(1))->constant)))
					? trueObject()
					: falseObject());
		ssPop(2);
		return ssPushConstant(result);
	}
	return genForwardersInlinedIdenticalOrNotIf(orNot);
}

	/* StackToRegisterMappingCogit>>#genJumpBackTo: */
static NoDbgRegParms sqInt
genJumpBackTo(sqInt targetBytecodePC)
{
    AbstractInstruction *abstractInstruction;
    sqInt i;
    void *jumpTarget;

	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= simStackPtr) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = simStackPtr + 1;
	}

	/* can't fall through */
	deadCode = 1;

	/* #MoveAw:R: #gen:literal:operand: */
	checkLiteralforInstruction(stackLimitAddress(), genoperandoperand(MoveAwR, stackLimitAddress(), TempReg));

	/* begin CmpR:R: */
	assert(!(0 /* (TempReg = SPReg) */));
	genoperandoperand(CmpRR, TempReg, SPReg);

	/* begin fixupAt: */
	jumpTarget = fixupAtIndex(targetBytecodePC - initialPC);
	genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)jumpTarget));
	abstractInstruction = genoperand(Call, ceCheckForInterruptTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);

	/* begin fixupAt: */
	jumpTarget = fixupAtIndex(targetBytecodePC - initialPC);
	genoperand(Jump, ((sqInt)jumpTarget));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genJumpIf:to: */
static NoDbgRegParms sqInt
genJumpIfto(sqInt boolean, sqInt targetBytecodePC)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    CogSimStackEntry *desc;
    sqInt eventualTarget;
    BytecodeFixup *fixup;
    sqInt i;
    void *jumpTarget;
    AbstractInstruction *ok;
    sqInt quickConstant;

	eventualTarget = eventualTargetOf(targetBytecodePC);

	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= (simStackPtr - 1)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 1)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 1))); i < simStackPtr; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = (simStackPtr - 1) + 1;
	}
	desc = ssTop();
	ssPop(1);
	if (/* stackEntryIsBoolean: */
		(((desc->type)) == SSConstant)
	 && ((((desc->constant)) == (trueObject()))
	 || (((desc->constant)) == (falseObject())))) {

		/* Must arrange there's a fixup at the target whether it is jumped to or
		   not so that the simStackPtr can be kept correct. */
		/* Must annotate the bytecode for correct pc mapping. */
		fixup = ensureFixupAt(eventualTarget);
		abstractInstruction = (((desc->constant)) == boolean
					? genoperand(Jump, ((sqInt)fixup))
					: (prevInstIsPCAnnotated()
							? gen(Nop)
							: genoperandoperand(Label, (labelCounter += 1), bytecodePC)));

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		extA = 0;
		return 0;
	}
	popToReg(desc, TempReg);
	assert((objectAfter(falseObject())) == (trueObject()));

	/* begin genSubConstant:R: */
	if (/* shouldAnnotateObjectReference: */
		(isNonImmediate(boolean))
	 && ((oopisGreaterThan(boolean, classTableRootObj()))
	 || (oopisLessThan(boolean, nilObject())))) {
		annotateobjRef(checkLiteralforInstruction(boolean, genoperandoperand(SubCwR, boolean, TempReg)), TempReg);
	}
	else {
		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, boolean, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(boolean, BytesPerOop));
		}
	}
	jumpTarget = ensureFixupAt(eventualTarget);

	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
	if (((extA & 1) != 0)) {
		extA = 0;
		abstractInstruction = lastOpcode();

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		return 0;
	}
	extA = 0;
	quickConstant = (boolean == (falseObject())
				? (trueObject()) - (falseObject())
				: (falseObject()) - (trueObject()));

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	ok = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genCallMustBeBooleanFor(boolean);
	jmpTarget(ok, annotateBytecode(genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genJumpTo: */
static NoDbgRegParms sqInt
genJumpTo(sqInt targetBytecodePC)
{
    sqInt eventualTarget;
    BytecodeFixup *fixup;
    BytecodeDescriptor *generator;
    sqInt i;

	eventualTarget = eventualTargetOf(targetBytecodePC);
	if ((eventualTarget > bytecodePC)
	 && ((/* stackTopIsBoolean */
		(simStackPtr >= methodOrBlockNumArgs)
	 && (stackEntryIsBoolean(ssTop())))
	 && (isConditionalBranch(generator = generatorForPC(eventualTarget))))) {
		eventualTarget = (eventualTarget + ((generator->numBytes))) + ((((generator->isBranchTrue)) == ((((ssTop())->constant)) == (trueObject()))
		? ((generator->spanFunction))(generator, eventualTarget, 0, methodObj)
		: 0));
		ssPop(1);

		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		fixup = ensureFixupAt(eventualTarget);
		ssPop(-1);
	}
	else {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		fixup = ensureFixupAt(eventualTarget);
	}

	/* can't fall through */
	deadCode = 1;

	/* Jump: */
	genoperand(Jump, ((sqInt)fixup));
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeBinaryInlinePrimitive: */
static NoDbgRegParms sqInt
genLowcodeBinaryInlinePrimitive(sqInt prim)
{
    sqInt frResult;
    sqInt i;
    sqInt index;
    sqInt object;
    sqInt pointer;
    sqInt rOopTop;
    sqInt rResult;
    sqInt value;

	switch (prim) {
	case 0:
		/* begin genLowcodeByteSizeOf */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l1;
				}
			}
			goto l2;
l1:;
			rOopTop = NoReg;
l2:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcByteSizeOfto(object, value);
		return 0;

	case 1:
		/* begin genLowcodeFirstFieldPointer */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l3;
				}
			}
			goto l4;
l3:;
			rOopTop = NoReg;
l4:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcFirstFieldPointer(object);
		return 0;

	case 2:
		/* begin genLowcodeFirstIndexableFieldPointer */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l5;
				}
			}
			goto l6;
l5:;
			rOopTop = NoReg;
l6:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcFirstIndexableFieldPointer(object);
		return 0;

	case 3:
		/* begin genLowcodeIsBytes */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l7;
				}
			}
			goto l8;
l7:;
			rOopTop = NoReg;
l8:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcIsBytesto(object, value);
		return 0;

	case 4:
		/* begin genLowcodeIsFloatObject */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l9;
				}
			}
			goto l10;
l9:;
			rOopTop = NoReg;
l10:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcIsFloatObjectto(object, value);
		return 0;

	case 5:
		/* begin genLowcodeIsIndexable */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l11;
				}
			}
			goto l12;
l11:;
			rOopTop = NoReg;
l12:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcIsIndexableto(object, value);
		return 0;

	case 6:
		/* begin genLowcodeIsIntegerObject */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l13;
				}
			}
			goto l14;
l13:;
			rOopTop = NoReg;
l14:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcIsIntegerObjectto(object, value);
		return 0;

	case 7:
		/* begin genLowcodeIsPointers */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l15;
				}
			}
			goto l16;
l15:;
			rOopTop = NoReg;
l16:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcIsPointersto(object, value);
		return 0;

	case 8:
		/* begin genLowcodeIsWords */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l17;
				}
			}
			goto l18;
l17:;
			rOopTop = NoReg;
l18:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcIsWordsto(object, value);
		return 0;

	case 9:
		/* begin genLowcodeIsWordsOrBytes */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l19;
				}
			}
			goto l20;
l19:;
			rOopTop = NoReg;
l20:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcIsWordsOrBytesto(object, value);
		return 0;

	case 10:
		/* begin genLowcodeOopSmallIntegerToInt32 */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l21;
				}
			}
			goto l22;
l21:;
			rOopTop = NoReg;
l22:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		genConvertSmallIntegerToIntegerInReg(object);
		ssPushNativeRegister(object);
		return 0;

	case 11:
		/* begin genLowcodeOopSmallIntegerToInt64 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l23;
				}
			}
			goto l24;
l23:;
			rOopTop = NoReg;
l24:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		genConvertSmallIntegerToIntegerInReg(object);
		ssPushNativeRegister(object);
		return 0;

	case 12:
		/* begin genLowcodeOopToBoolean32 */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l25;
				}
			}
			goto l26;
l25:;
			rOopTop = NoReg;
l26:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		annotateobjRef(checkLiteralforInstruction(falseObject(), genoperandoperand(SubCwR, falseObject(), object)), falseObject());
		ssPushNativeRegister(object);
		return 0;

	case 13:
		/* begin genLowcodeOopToBoolean64 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l27;
				}
			}
			goto l28;
l27:;
			rOopTop = NoReg;
l28:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		annotateobjRef(checkLiteralforInstruction(falseObject(), genoperandoperand(SubCwR, falseObject(), object)), falseObject());
		ssPushNativeRegister(object);
		return 0;

	case 14:
		/* begin genLowcodeOopToFloat32 */
		/* begin allocateRegistersForLowcodeOopResultFloat: */
		rOopTop = NoReg;
		frResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l29;
				}
			}
			goto l30;
l29:;
			rOopTop = NoReg;
l30:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rOopTop == NoReg)
 || (frResult == NoReg))));
		object = rOopTop;
		value = frResult;
		popToReg(ssTop(), object);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOoptoFloat32(object, value);
		return 0;

	case 15:
		/* begin genLowcodeOopToFloat64 */
		/* begin allocateRegistersForLowcodeOopResultFloat: */
		rOopTop = NoReg;
		frResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l31;
				}
			}
			goto l32;
l31:;
			rOopTop = NoReg;
l32:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rOopTop == NoReg)
 || (frResult == NoReg))));
		object = rOopTop;
		value = frResult;
		popToReg(ssTop(), object);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOoptoFloat64(object, value);
		return 0;

	case 16:
		/* begin genLowcodeOopToInt32 */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l33;
				}
			}
			goto l34;
l33:;
			rOopTop = NoReg;
l34:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOopToInt32(object);
		return 0;

	case 17:
		/* begin genLowcodeOopToInt64 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l35;
				}
			}
			goto l36;
l35:;
			rOopTop = NoReg;
l36:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOopToInt64(object);
		return 0;

	case 18:
		/* begin genLowcodeOopToPointer */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l37;
				}
			}
			goto l38;
l37:;
			rOopTop = NoReg;
l38:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcOopToPointer(object);
		return 0;

	case 19:
		/* begin genLowcodeOopToPointerReinterpret */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l39;
				}
			}
			goto l40;
l39:;
			rOopTop = NoReg;
l40:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		pointer = rResult;
		popToReg(ssTop(), object);
		ssPop(1);
		ssPushNativeRegister(object);
		return 0;

	case 20:
		/* begin genLowcodeOopToUInt32 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l41;
				}
			}
			goto l42;
l41:;
			rOopTop = NoReg;
l42:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOopToUInt32(object);
		return 0;

	case 21:
		/* begin genLowcodeOopToUInt64 */
		/* begin allocateRegistersForLowcodeOopResultInteger: */
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l43;
				}
			}
			goto l44;
l43:;
			rOopTop = NoReg;
l44:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		object = rOopTop;
		value = rResult;
		popToReg(ssTop(), object);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcOopToUInt64(object);
		return 0;

	case 22:
		/* begin genLowcodePin */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l45;
				}
			}
			goto l46;
l45:;
			rOopTop = NoReg;
l46:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		abort();
		return 0;

	case 23:
		/* begin genLowcodeUnpin */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l47;
				}
			}
			goto l48;
l47:;
			rOopTop = NoReg;
l48:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		abort();
		return 0;

	default:
		return EncounteredUnknownBytecode;
	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeNullaryInlinePrimitive: */
static NoDbgRegParms sqInt
genLowcodeNullaryInlinePrimitive(sqInt prim)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *cont;
    sqInt floatValue;
    sqInt frTop;
    sqInt i;
    AbstractInstruction *inst;
    sqInt object;
    sqInt pointer;
    sqInt pointerClassLiteral;
    sqInt rResult;
    sqInt rTop;
    sqInt singleFloatValue;
    AbstractInstruction *trueJump;
    sqInt value;

	switch (prim) {
	case 0:
		/* begin genLowcodeBoolean32ToOop */
		/* begin allocateRegistersForLowcodeIntegerResultOop: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		object = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* False */
		trueJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		annotateobjRef(checkLiteralforInstruction(falseObject(), genoperandoperand(MoveCwR, falseObject(), value)), falseObject());

		/* True */
		cont = genoperand(Jump, ((sqInt)0));
		inst = checkLiteralforInstruction(trueObject(), genoperandoperand(MoveCwR, trueObject(), value));
		jmpTarget(trueJump, inst);
		annotateobjRef(inst, trueObject());
		jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushRegister(value);
		return 0;

	case 1:
		/* begin genLowcodeBoolean64ToOop */
		/* begin allocateRegistersForLowcodeIntegerResultOop: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		object = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* False */
		trueJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		annotateobjRef(checkLiteralforInstruction(falseObject(), genoperandoperand(MoveCwR, falseObject(), value)), falseObject());

		/* True */
		cont = genoperand(Jump, ((sqInt)0));
		inst = checkLiteralforInstruction(trueObject(), genoperandoperand(MoveCwR, trueObject(), value));
		jmpTarget(trueJump, inst);
		annotateobjRef(inst, trueObject());
		jmpTarget(cont, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushRegister(value);
		return 0;

	case 2:
		/* begin genLowcodeFloat32ToOop */
		/* begin allocateRegistersForLowcodeFloatResultOop: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		singleFloatValue = frTop;
		object = rResult;
		nativePopToReg(ssNativeTop(), singleFloatValue);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcFloat32toOop(singleFloatValue, object);
		return 0;

	case 3:
		/* begin genLowcodeFloat64ToOop */
		/* begin allocateRegistersForLowcodeFloatResultOop: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		floatValue = frTop;
		object = rResult;
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcFloat64toOop(floatValue, object);
		return 0;

	case 4:
		/* begin genLowcodeInt32ToOop */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInt32ToOop(value);
		return 0;

	case 5:
		/* begin genLowcodeInt64ToOop */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInt64ToOop(value);
		return 0;

	case 6:
		/* begin genLowcodePointerToOop */
		pointerClassLiteral = getLiteral(extA);
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		pointer = rTop;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcPointerToOopclass(pointer, pointerClassLiteral);
		extA = 0;
		return 0;

	case 7:
		/* begin genLowcodePointerToOopReinterprer */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		pointer = rTop;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		ssPushRegister(pointer);
		return 0;

	case 8:
		/* begin genLowcodeSmallInt32ToOop */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		genConvertIntegerToSmallIntegerInReg(value);
		ssPushRegister(value);
		return 0;

	case 9:
		/* begin genLowcodeUint32ToOop */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcUInt32ToOop(value);
		return 0;

	case 10:
		/* begin genLowcodeUint64ToOop */
		/* begin allocateRegistersForLowcodeIntegerResultOop: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		object = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcUInt64ToOop(value);
		return 0;

	default:
		return EncounteredUnknownBytecode;
	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeTrinaryInlinePrimitive: */
static NoDbgRegParms sqInt
genLowcodeTrinaryInlinePrimitive(sqInt prim)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *contJump;
    AbstractInstruction *falseJump;
    sqInt fieldIndex;
    sqInt first;
    sqInt i;
    sqInt index;
    sqInt object;
    sqInt oopTopRegisterMask;
    sqInt rOopNext;
    sqInt rOopTop;
    sqInt rResult;
    sqInt rTop;
    sqInt second;
    sqInt topRegisterMask;
    sqInt value;

	switch (prim) {
	case 0:
		/* begin genLowcodeOopEqual */
		/* begin allocateRegistersForLowcodeOop2ResultInteger: */
		rOopTop = (rOopNext = NoReg);
		rResult = NoReg;
		oopTopRegisterMask = 0;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l6;
				}
			}
			goto l8;
l6:;
			rOopTop = NoReg;
l8:;
		}
		if ((registerOrNone(ssValue(1))) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopNext = registerOrNone(ssValue(1));

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i < simStackPtr; i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopNext) {
					goto l5;
				}
			}
			goto l7;
l5:;
			rOopNext = NoReg;
l7:;
			if (rOopNext != NoReg) {
				oopTopRegisterMask = ((rOopNext < 0) ? (((usqInt)(1)) >> (-rOopNext)) : (1ULL << rOopNext));
			}
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(oopTopRegisterMask);
		}
		if (rOopNext == NoReg) {
			rOopNext = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		}
		rResult = allocateRegNotConflictingWith((1ULL << rOopTop) | (1ULL << rOopNext));
		assert(!(((rOopTop == NoReg)
 || ((rOopNext == NoReg)
 || (rResult == NoReg)))));
		second = rOopTop;
		first = rOopNext;
		value = rResult;
		popToReg(ssTop(), second);
		ssPop(1);
		popToReg(ssTop(), first);
		ssPop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 1:
		/* begin genLowcodeOopNotEqual */
		/* begin allocateRegistersForLowcodeOop2: */
		rOopTop = (rOopNext = NoReg);
		oopTopRegisterMask = 0;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l10;
				}
			}
			goto l12;
l10:;
			rOopTop = NoReg;
l12:;
		}
		if ((registerOrNone(ssValue(1))) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopNext = registerOrNone(ssValue(1));

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i < simStackPtr; i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopNext) {
					goto l9;
				}
			}
			goto l11;
l9:;
			rOopNext = NoReg;
l11:;
			if (rOopNext != NoReg) {
				oopTopRegisterMask = ((rOopNext < 0) ? (((usqInt)(1)) >> (-rOopNext)) : (1ULL << rOopNext));
			}
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(oopTopRegisterMask);
		}
		if (rOopNext == NoReg) {
			rOopNext = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		}
		assert(!(((rOopTop == NoReg)
 || (rOopNext == NoReg))));
		second = rOopTop;
		first = rOopNext;
		popToReg(ssTop(), second);
		ssPop(1);
		popToReg(ssTop(), first);
		ssPop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 2:
		/* begin genLowcodeStoreObjectField */
		fieldIndex = extA;
		rOopTop = (rOopNext = NoReg);
		oopTopRegisterMask = 0;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l1;
				}
			}
			goto l2;
l1:;
			rOopTop = NoReg;
l2:;
		}
		if ((registerOrNone(ssValue(1))) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopNext = registerOrNone(ssValue(1));

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i < simStackPtr; i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopNext) {
					goto l3;
				}
			}
			goto l4;
l3:;
			rOopNext = NoReg;
l4:;
			if (rOopNext != NoReg) {
				oopTopRegisterMask = ((rOopNext < 0) ? (((usqInt)(1)) >> (-rOopNext)) : (1ULL << rOopNext));
			}
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(oopTopRegisterMask);
		}
		if (rOopNext == NoReg) {
			rOopNext = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		}
		assert(!(((rOopTop == NoReg)
 || (rOopNext == NoReg))));
		value = rOopTop;
		object = rOopNext;
		popToReg(ssTop(), value);
		ssPop(1);
		popToReg(ssTop(), object);
		ssPop(1);
		genLcStoreobjectfield(value, object, fieldIndex);
		extA = 0;
		return 0;

	case 3:
		/* begin genLowcodeStoreObjectFieldAt */
		/* begin allocateRegistersForLowcodeIntegerOop2: */
		rTop = (rOopTop = (rOopNext = NoReg));
		oopTopRegisterMask = (topRegisterMask = 0);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			oopTopRegisterMask = ((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop));
		}
		if ((registerOrNone(ssTop())) != NoReg) {
			rOopTop = registerOrNone(ssTop());
			topRegisterMask = ((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop));
		}
		if ((registerOrNone(ssValue(1))) != NoReg) {
			rOopNext = registerOrNone(ssValue(1));
			topRegisterMask = topRegisterMask | (((rOopNext < 0) ? (((usqInt)(1)) >> (-rOopNext)) : (1ULL << rOopNext)));
			oopTopRegisterMask = oopTopRegisterMask | (((rOopNext < 0) ? (((usqInt)(1)) >> (-rOopNext)) : (1ULL << rOopNext)));
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegisterMask);
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(oopTopRegisterMask);
		}
		if (rOopNext == NoReg) {
			rOopNext = allocateRegNotConflictingWith((1ULL << rTop) | (1ULL << rOopTop));
		}
		assert(!(((rTop == NoReg)
 || ((rOopTop == NoReg)
 || (rOopNext == NoReg)))));
		fieldIndex = rTop;
		value = rOopTop;
		object = rOopNext;
		popToReg(ssTop(), value);
		ssPop(1);
		nativePopToReg(ssNativeTop(), fieldIndex);
		ssNativePop(1);
		popToReg(ssTop(), object);
		ssPop(1);
		genLcStoreobjectat(value, object, fieldIndex);
		return 0;

	default:
		return EncounteredUnknownBytecode;
	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive2: */
static NoDbgRegParms sqInt
genLowcodeUnaryInlinePrimitive2(sqInt prim)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt baseOffset;
    sqInt classOop;
    AbstractInstruction *contJump;
    sqInt doubleValue;
    AbstractInstruction *falseJump;
    sqInt fieldIndex;
    sqInt first;
    sqInt floatValue;
    sqInt frResult;
    sqInt frTop;
    sqInt i;
    sqInt index;
    sqInt indexableSize;
    sqInt int32Result;
    sqInt int64Result;
    sqInt object;
    sqInt pointer;
    sqInt pointerResult;
    sqInt reg;
    sqInt result;
    sqInt rNext;
    sqInt rOopResult;
    sqInt rOopTop;
    sqInt rResult;
    sqInt rTop;
    sqInt second;
    sqInt shiftAmount;
    sqInt topRegisterMask;
    sqInt topRegistersMask;
    sqInt value;

	switch (prim) {
	case 60:
		/* begin genLowcodeFloat64ToFloat32 */
		/* begin allocateRegistersForLowcodeFloat: */
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		floatValue = frTop;
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);

		/* ConvertRd:Rs: */
		genoperandoperand(ConvertRdRs, floatValue, floatValue);
		ssPushNativeRegisterSingleFloat(floatValue);
		return 0;

	case 61:
		/* begin genLowcodeFloat64ToInt32 */
		/* begin allocateRegistersForLowcodeFloatResultInteger: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		floatValue = frTop;
		int32Result = rResult;
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);

		/* ConvertRd:R: */
		genoperandoperand(ConvertRdR, floatValue, int32Result);
		ssPushNativeRegister(int32Result);
		return 0;

	case 0x3E:
		/* begin genLowcodeFloat64ToInt64 */
		/* begin allocateRegistersForLowcodeFloatResultInteger: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		floatValue = frTop;
		int64Result = rResult;
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);
		abort();
		return 0;

	case 0x3F:
		/* begin genLowcodeFloat64ToUInt32 */
		/* begin allocateRegistersForLowcodeFloatResultInteger: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		floatValue = frTop;
		int64Result = rResult;
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);

		/* ConvertRd:R: */
		genoperandoperand(ConvertRdR, floatValue, int64Result);
		ssPushNativeRegister(int64Result);
		return 0;

	case 64:
		/* begin genLowcodeFloat64ToUInt64 */
		/* begin allocateRegistersForLowcodeFloatResultInteger: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		floatValue = frTop;
		int64Result = rResult;
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);
		abort();
		return 0;

	case 65:
		/* begin genLowcodeFree */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		pointer = rTop;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		if (pointer != ReceiverResultReg) {
			/* MoveR:R: */
			genoperandoperand(MoveRR, pointer, ReceiverResultReg);
		}

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceFreeTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		return 0;

	case 66:
		/* begin genLowcodeInstantiateIndexable32Oop */
		/* begin allocateRegistersForLowcodeIntegerOopResultOop: */
		rTop = (rOopTop = NoReg);
		rOopResult = NoReg;
		topRegisterMask = 0;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if ((registerOrNone(ssTop())) != NoReg) {
			rOopTop = registerOrNone(ssTop());
			topRegisterMask = ((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop));
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegisterMask);
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		rOopResult = allocateRegNotConflictingWith((1ULL << rTop) | (1ULL << rOopTop));
		assert(!(((rTop == NoReg)
 || ((rOopTop == NoReg)
 || (rOopResult == NoReg)))));
		indexableSize = rTop;
		classOop = rOopTop;
		object = rOopResult;
		nativePopToReg(ssNativeTop(), indexableSize);
		ssNativePop(1);
		popToReg(ssTop(), classOop);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInstantiateOopindexableSize(classOop, indexableSize);
		return 0;

	case 67:
		/* begin genLowcodeInstantiateIndexableOop */
		indexableSize = extA;
		rOopTop = NoReg;
		rResult = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l1;
				}
			}
			goto l2;
l1:;
			rOopTop = NoReg;
l2:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop)));
		assert(!(((rOopTop == NoReg)
 || (rResult == NoReg))));
		classOop = rOopTop;
		object = rResult;
		popToReg(ssTop(), classOop);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInstantiateOopconstantIndexableSize(classOop, indexableSize);
		extA = 0;
		return 0;

	case 68:
		/* begin genLowcodeInstantiateOop */
		/* begin allocateRegistersForLowcodeOop: */
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l3;
				}
			}
			goto l4;
l3:;
			rOopTop = NoReg;
l4:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		classOop = rOopTop;
		popToReg(ssTop(), classOop);
		ssPop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genLcInstantiateOop(classOop);
		return 0;

	case 69:
		/* begin genLowcodeInt32Equal */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 70:
		/* begin genLowcodeInt32Great */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 71:
		/* begin genLowcodeInt32GreatEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpLess, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 72:
		/* begin genLowcodeInt32Less */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 73:
		/* begin genLowcodeInt32LessEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpGreater, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 74:
		/* begin genLowcodeInt32NotEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 75:
		/* begin genLowcodeInt32ToFloat32 */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		value = rTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* ConvertR:Rs: */
		genoperandoperand(ConvertRRs, value, result);
		ssPushNativeRegisterSingleFloat(result);
		return 0;

	case 76:
		/* begin genLowcodeInt32ToFloat64 */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		value = rTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* ConvertR:Rd: */
		genoperandoperand(ConvertRRd, value, result);
		ssPushNativeRegisterDoubleFloat(result);
		return 0;

	case 77:
		/* begin genLowcodeInt32ToPointer */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		ssPushNativeRegister(value);
		return 0;

	case 78:
		/* begin genLowcodeInt64Equal */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 79:
		/* begin genLowcodeInt64Great */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 80:
		/* begin genLowcodeInt64GreatEqual */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 81:
		/* begin genLowcodeInt64Less */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 82:
		/* begin genLowcodeInt64LessEqual */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 83:
		/* begin genLowcodeInt64NotEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 84:
		/* begin genLowcodeInt64ToFloat32 */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		value = rTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 85:
		/* begin genLowcodeInt64ToFloat64 */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		value = rTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 86:
		/* begin genLowcodeInt64ToPointer */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		ssPushNativeRegister(value);
		return 0;

	case 87:
		/* begin genLowcodeLeftShift32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		shiftAmount = rTop;
		value = rNext;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* LogicalShiftLeftR:R: */
		genoperandoperand(LogicalShiftLeftRR, shiftAmount, value);
		ssPushNativeRegister(value);
		return 0;

	case 88:
		/* begin genLowcodeLeftShift64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		shiftAmount = rTop;
		value = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 89:
		/* begin genLowcodeLoadArgumentAddress */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		pointer = rResult;
		loadNativeArgumentAddressto(baseOffset, pointer);
		ssPushNativeRegister(pointer);
		extA = 0;
		return 0;

	case 90:
		/* begin genLowcodeLoadArgumentFloat32 */
		baseOffset = extA;
		frResult = NoReg;
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((frResult == NoReg)));
		floatValue = frResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM32:r:Rs: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rRs, 0, TempReg, floatValue);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegisterSingleFloat(floatValue);
		extA = 0;
		return 0;

	case 91:
		/* begin genLowcodeLoadArgumentFloat64 */
		baseOffset = extA;
		frResult = NoReg;
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((frResult == NoReg)));
		doubleValue = frResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM64:r:Rd: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM64rRd, 0, TempReg, doubleValue);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegisterDoubleFloat(doubleValue);
		extA = 0;
		return 0;

	case 92:
		/* begin genLowcodeLoadArgumentInt16 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM16:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM16rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value, value);
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 93:
		/* begin genLowcodeLoadArgumentInt32 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM32:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 94:
		/* begin genLowcodeLoadArgumentInt64 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 95:
		/* begin genLowcodeLoadArgumentInt8 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM8:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM8rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, value, value);
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 96:
		/* begin genLowcodeLoadArgumentPointer */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		pointerResult = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, TempReg, pointerResult);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(pointerResult);
		extA = 0;
		return 0;

	case 97:
		/* begin genLowcodeLoadArgumentUInt16 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM16:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM16rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 98:
		/* begin genLowcodeLoadArgumentUInt32 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM32:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 99:
		/* begin genLowcodeLoadArgumentUInt64 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 100:
		/* begin genLowcodeLoadArgumentUInt8 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeArgumentAddressto(baseOffset, TempReg);

		/* begin MoveM8:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM8rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 101:
		/* begin genLowcodeLoadFloat32FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		pointer = rTop;
		value = frResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM32:r:Rs: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rRs, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegisterSingleFloat(value);
		return 0;

	case 102:
		/* begin genLowcodeLoadFloat64FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		pointer = rTop;
		value = frResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM64:r:Rd: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM64rRd, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegisterDoubleFloat(value);
		return 0;

	case 103:
		/* begin genLowcodeLoadInt16FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		value = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM16:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM16rR, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 104:
		/* begin genLowcodeLoadInt32FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		value = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM32:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rR, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 105:
		/* begin genLowcodeLoadInt64FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		value = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 106:
		/* begin genLowcodeLoadInt8FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		value = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM8:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM8rR, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 107:
		/* begin genLowcodeLoadLocalAddress */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		pointer = rResult;
		loadNativeLocalAddressto(baseOffset, pointer);
		ssPushNativeRegister(pointer);
		extA = 0;
		return 0;

	case 108:
		/* begin genLowcodeLoadLocalFloat32 */
		baseOffset = extA;
		frResult = NoReg;
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((frResult == NoReg)));
		floatValue = frResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM32:r:Rs: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rRs, 0, TempReg, floatValue);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegisterSingleFloat(floatValue);
		extA = 0;
		return 0;

	case 109:
		/* begin genLowcodeLoadLocalFloat64 */
		baseOffset = extA;
		frResult = NoReg;
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((frResult == NoReg)));
		doubleValue = frResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM64:r:Rd: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM64rRd, 0, TempReg, doubleValue);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegisterDoubleFloat(doubleValue);
		extA = 0;
		return 0;

	case 110:
		/* begin genLowcodeLoadLocalInt16 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM16:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM16rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value, value);
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 111:
		/* begin genLowcodeLoadLocalInt32 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM32:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 112:
		/* begin genLowcodeLoadLocalInt64 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 113:
		/* begin genLowcodeLoadLocalInt8 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM8:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM8rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}

		/* SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, value, value);
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 114:
		/* begin genLowcodeLoadLocalPointer */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		pointerResult = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, TempReg, pointerResult);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(pointerResult);
		extA = 0;
		return 0;

	case 115:
		/* begin genLowcodeLoadLocalUInt16 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM16:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM16rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 116:
		/* begin genLowcodeLoadLocalUInt32 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM32:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 117:
		/* begin genLowcodeLoadLocalUInt64 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 118:
		/* begin genLowcodeLoadLocalUInt8 */
		baseOffset = extA;
		rResult = NoReg;
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!((rResult == NoReg)));
		value = rResult;
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveM8:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM8rR, 0, TempReg, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		extA = 0;
		return 0;

	case 119:
		/* begin genLowcodeLoadObjectAt */
		/* begin allocateRegistersForLowcodeIntegerOop: */
		rTop = (rOopTop = NoReg);
		topRegisterMask = 0;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if ((registerOrNone(ssTop())) != NoReg) {
			rOopTop = registerOrNone(ssTop());
			topRegisterMask = ((rOopTop < 0) ? (((usqInt)(1)) >> (-rOopTop)) : (1ULL << rOopTop));
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegisterMask);
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rOopTop == NoReg))));
		fieldIndex = rTop;
		object = rOopTop;
		nativePopToReg(ssNativeTop(), fieldIndex);
		ssNativePop(1);
		popToReg(ssTop(), object);
		ssPop(1);
		genLcLoadObjectat(object, fieldIndex);
		return 0;

	default:
		return genLowcodeUnaryInlinePrimitive3(prim);
	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive3: */
static NoDbgRegParms sqInt
genLowcodeUnaryInlinePrimitive3(sqInt prim)
{
    AbstractInstruction *abstractInstruction;
    sqInt alignedSize;
    AbstractInstruction *anInstruction;
    sqInt base;
    sqInt constant;
    AbstractInstruction *contJump;
    sqInt dest;
    AbstractInstruction *falseJump;
    sqInt fieldIndex;
    sqInt first;
    sqInt frTop;
    sqInt i;
    sqInt index;
    sqInt nativeValueIndex;
    sqInt nextRegisterMask;
    sqInt object;
    sqInt offset;
    sqInt pointer;
    sqInt pointerResult;
    sqInt pointerValue;
    sqInt quickConstant;
    sqInt reg;
    sqInt registerID;
    sqInt result;
    sqInt rNext;
    sqInt rNextNext;
    sqInt rOopTop;
    sqInt rResult;
    sqInt rTop;
    sqInt second;
    sqInt size;
    sqInt sizeLow;
    sqInt source;
    sqInt topRegistersMask;
    sqInt value;

	switch (prim) {
	case 120:
		/* begin genLowcodeLoadObjectField */
		fieldIndex = extA;
		rOopTop = NoReg;
		if ((registerOrNone(ssTop())) != NoReg) {
			/* Ensure we are not using a duplicated register. */
			rOopTop = registerOrNone(ssTop());

			/* begin isOopRegister:usedBefore: */
			index = ((simSpillBase < 0) ? 0 : simSpillBase);
			for (i = index; i <= (simStackPtr); i += 1) {
				if ((registerOrNone(simStackAt(index))) == rOopTop) {
					goto l1;
				}
			}
			goto l2;
l1:;
			rOopTop = NoReg;
l2:;
		}
		if (rOopTop == NoReg) {
			rOopTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rOopTop == NoReg)));
		object = rOopTop;
		popToReg(ssTop(), object);
		ssPop(1);
		genLcLoadObjectfield(object, fieldIndex);
		extA = 0;
		return 0;

	case 121:
		/* begin genLowcodeLoadPointerFromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		pointerResult = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, pointer, pointerResult);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(pointerResult);
		return 0;

	case 122:
		/* begin genLowcodeLoadUInt16FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		value = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM16:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM16rR, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 123:
		/* begin genLowcodeLoadUInt32FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		value = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM32:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM32rR, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 0x7C:
		/* begin genLowcodeLoadUInt64FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		value = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM64:r:R: */
		assert(BytesPerWord == 8);
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 125:
		/* begin genLowcodeLoadUInt8FromMemory */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		value = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);

		/* begin MoveM8:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveM8rR, 0, pointer, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 0x7E:
		/* begin genLowcodeLocalFrameSize */
		size = extA;
		assert(needsFrame);

		/* Align the size to 16 bytes. */
		hasNativeFrame = 1;

		/* Mark the stack frame */
		alignedSize = (size + 15) & -16;
		annotateobjRef(gMoveCwR(splObj(LowcodeContextMark), TempReg), splObj(LowcodeContextMark));
		offset = frameOffsetOfNativeFrameMark();

		/* begin MoveR:Mw:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, FPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}

		/* #MoveAw:R: #gen:literal:operand: */
		checkLiteralforInstruction(nativeStackPointerAddress(), genoperandoperand(MoveAwR, nativeStackPointerAddress(), TempReg));

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, 1, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}
		offset = frameOffsetOfPreviousNativeStackPointer();

		/* begin MoveR:Mw:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, FPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}

		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, alignedSize, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(alignedSize, BytesPerOop));
		}
		offset = frameOffsetOfNativeFramePointer();

		/* begin MoveR:Mw:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, FPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		offset = frameOffsetOfNativeStackPointer();

		/* begin MoveR:Mw:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, FPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		quickConstant = 1 + (defaultNativeStackFrameSize());

		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, quickConstant, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
		}

		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(nativeStackPointerAddress(), genoperandoperand(MoveRAw, TempReg, nativeStackPointerAddress()));
		extA = 0;
		return 0;

	case 0x7F:
		/* begin genLowcodeLockRegisters */
		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		return 0;

	case 128:
		/* begin genLowcodeLockVM */
		abort();
		return 0;

	case 129:
		/* begin genLowcodeMalloc32 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		size = rTop;
		pointer = rResult;
		nativePopToReg(ssNativeTop(), size);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		if (size != ReceiverResultReg) {
			/* MoveR:R: */
			genoperandoperand(MoveRR, size, ReceiverResultReg);
		}

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceMallocTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);

		/* MoveR:R: */
		genoperandoperand(MoveRR, TempReg, pointer);
		ssPushNativeRegister(pointer);
		return 0;

	case 130:
		/* begin genLowcodeMalloc64 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		size = rTop;
		pointer = rResult;
		nativePopToReg(ssNativeTop(), size);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		if (size != ReceiverResultReg) {
			/* MoveR:R: */
			genoperandoperand(MoveRR, size, ReceiverResultReg);
		}

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceMallocTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);

		/* MoveR:R: */
		genoperandoperand(MoveRR, TempReg, pointer);
		ssPushNativeRegister(pointer);
		return 0;

	case 131:
		/* begin genLowcodeMemcpy32 */
		/* begin allocateRegistersForLowcodeInteger3: */
		rTop = (rNext = (rNextNext = NoReg));
		nativeValueIndex = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
					rNextNext = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex));
				}
				nativeValueIndex += 1;
			}
		}
		if (rNextNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
			}
		}
		if (rTop == NoReg) {
			nextRegisterMask = 0;
			if (rNext != NoReg) {
				nextRegisterMask = ((rNext < 0) ? (((usqInt)(1)) >> (-rNext)) : (1ULL << rNext));
			}
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			rTop = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNext == NoReg) {
			nextRegisterMask = ((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop));
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			rNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNextNext == NoReg) {
			nextRegisterMask = (1ULL << rTop) | (1ULL << rNext);
			rNextNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		assert(!(((rTop == NoReg)
 || ((rNext == NoReg)
 || (rNextNext == NoReg)))));
		size = rTop;
		source = rNext;
		dest = rNextNext;
		nativePopToReg(ssNativeTop(), size);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), source);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), dest);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genMemCopytosize(backEnd, source, dest, size);
		return 0;

	case 132:
		/* begin genLowcodeMemcpy64 */
		sizeLow = 0;
		rTop = (rNext = (rNextNext = NoReg));
		nativeValueIndex = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
					rNextNext = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex));
				}
				nativeValueIndex += 1;
			}
		}
		if (rNextNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
			}
		}
		if (rTop == NoReg) {
			nextRegisterMask = 0;
			if (rNext != NoReg) {
				nextRegisterMask = ((rNext < 0) ? (((usqInt)(1)) >> (-rNext)) : (1ULL << rNext));
			}
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			rTop = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNext == NoReg) {
			nextRegisterMask = ((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop));
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			rNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNextNext == NoReg) {
			nextRegisterMask = (1ULL << rTop) | (1ULL << rNext);
			rNextNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		assert(!(((rTop == NoReg)
 || ((rNext == NoReg)
 || (rNextNext == NoReg)))));
		size = rTop;
		source = rNext;
		dest = rNextNext;
		nativePopToReg(ssNativeTop(), size);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), source);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), dest);
		ssNativePop(1);

		/* begin ssFlushAll */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		voidReceiverResultRegContainsSelf();
		genMemCopytosize(backEnd, source, dest, sizeLow);
		return 0;

	case 133:
		/* begin genLowcodeMemcpyFixed */
		size = extA;
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		source = rTop;
		dest = rNext;
		nativePopToReg(ssNativeTop(), source);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), dest);
		ssNativePop(1);
		if (size == BytesPerWord) {
			/* begin MoveMw:r:R: */
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveMwrR, 0, source, TempReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
			}

			/* begin MoveR:Mw:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, 0, dest);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
			}
		}
		else {
			/* begin ssFlushAll */
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= simStackPtr) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = simStackPtr + 1;
			}
			voidReceiverResultRegContainsSelf();
			genMemCopytoconstantSize(backEnd, source, dest, size);
		}
		extA = 0;
		return 0;

	case 134:
		/* begin genLowcodeMoveFloat32ToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += BytesPerWord;
		extA = 0;
		return 0;

	case 135:
		/* begin genLowcodeMoveFloat64ToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += 8;
		extA = 0;
		return 0;

	case 136:
		/* begin genLowcodeMoveInt32ToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += BytesPerWord;
		extA = 0;
		return 0;

	case 137:
		/* begin genLowcodeMoveInt64ToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += 8;
		extA = 0;
		return 0;

	case 138:
		/* begin genLowcodeMovePointerToPhysical */
		nativeStackPopToReg(ssNativeTop(), extA);
		ssNativePop(1);
		currentCallCleanUpSize += BytesPerWord;
		extA = 0;
		return 0;

	case 139:
		/* begin genLowcodeMul32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* MulR:R: */
		genMulRR(backEnd, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 140:
		/* begin genLowcodeMul64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 141:
		/* begin genLowcodeNeg32 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* NegateR: */
		genoperand(NegateR, value);
		ssPushNativeRegister(value);
		return 0;

	case 142:
		/* begin genLowcodeNeg64 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* NegateR: */
		genoperand(NegateR, value);
		ssPushNativeRegister(value);
		return 0;

	case 143:
		/* begin genLowcodeNot32 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* NotR: */
		genoperand(NotR, value);
		ssPushNativeRegister(value);
		return 0;

	case 144:
		/* begin genLowcodeNot64 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* NotR: */
		genoperand(NotR, value);
		ssPushNativeRegister(value);
		return 0;

	case 145:
		/* begin genLowcodeOr32 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* OrR:R: */
		genoperandoperand(OrRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 146:
		/* begin genLowcodeOr64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* OrR:R: */
		genoperandoperand(OrRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 147:
		/* begin genLowcodePerformCallout */
		callSwitchToCStack();

		/* #MoveCw:R: #gen:literal:operand: */
		checkLiteralforInstruction(extA, genoperandoperand(MoveCwR, extA, TempReg));
		abstractInstruction = genoperand(Call, ceFFICalloutTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		extA = 0;
		return 0;

	case 148:
		/* begin genLowcodePerformCalloutIndirect */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);
		callSwitchToCStack();

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceFFICalloutTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		return 0;

	case 149:
		/* begin genLowcodePushCalloutResultFloat32 */
		cFloatResultToRs(backEnd, DPFPReg0);
		ssPushNativeRegisterSingleFloat(DPFPReg0);
		return 0;

	case 150:
		/* begin genLowcodePushCalloutResultFloat64 */
		cFloatResultToRd(backEnd, DPFPReg0);
		ssPushNativeRegisterDoubleFloat(DPFPReg0);
		return 0;

	case 151:
		/* begin genLowcodePushCalloutResultInt32 */
		/* MoveR:R: */
		genoperandoperand(MoveRR, ABIResultReg, ReceiverResultReg);
		ssPushNativeRegister(ReceiverResultReg);
		return 0;

	case 152:
		/* begin genLowcodePushCalloutResultInt64 */
		/* MoveR:R: */
		genoperandoperand(MoveRR, ABIResultReg, ReceiverResultReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, ABIResultReg, ReceiverResultReg);
		ssPushNativeRegister(ReceiverResultReg);
		return 0;

	case 153:
		/* begin genLowcodePushCalloutResultPointer */
		/* MoveR:R: */
		genoperandoperand(MoveRR, ABIResultReg, ReceiverResultReg);
		ssPushNativeRegister(ReceiverResultReg);
		return 0;

	case 161:
		/* begin genLowcodePlaftormCode */
		abort();
		return 0;

	case 162:
		/* begin genLowcodePointerAddConstantOffset */
		offset = extB;
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		base = rTop;
		nativePopToReg(ssNativeTop(), base);
		ssNativePop(1);

		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, offset, base);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
		ssPushNativeRegister(base);
		extB = 0;
		numExtB = 0;
		return 0;

	case 163:
		/* begin genLowcodePointerAddOffset32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		offset = rTop;
		base = rNext;
		nativePopToReg(ssNativeTop(), offset);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), base);
		ssNativePop(1);

		/* AddR:R: */
		genoperandoperand(AddRR, offset, base);
		ssPushNativeRegister(base);
		return 0;

	case 164:
		/* begin genLowcodePointerAddOffset64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		offset = rTop;
		base = rNext;
		nativePopToReg(ssNativeTop(), offset);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), base);
		ssNativePop(1);

		/* AddR:R: */
		genoperandoperand(AddRR, offset, base);
		ssPushNativeRegister(base);
		return 0;

	case 165:
		/* begin genLowcodePointerEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 166:
		/* begin genLowcodePointerNotEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpZero, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 167:
		/* begin genLowcodePointerToInt32 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		pointer = rTop;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		ssPushNativeRegister(pointer);
		return 0;

	case 168:
		/* begin genLowcodePointerToInt64 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointer = rTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		ssPushNativeRegister(pointer);
		return 0;

	case 169:
		/* begin genLowcodePopFloat32 */
		/* begin allocateRegistersForLowcodeFloat: */
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		value = frTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		return 0;

	case 170:
		/* begin genLowcodePopFloat64 */
		/* begin allocateRegistersForLowcodeFloat: */
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		value = frTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		return 0;

	case 171:
		/* begin genLowcodePopInt32 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		return 0;

	case 172:
		/* begin genLowcodePopInt64 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		return 0;

	case 173:
		/* begin genLowcodePopMultipleNative */
		ssPopNativeSize(extA);
		extA = 0;
		return 0;

	case 174:
		/* begin genLowcodePopPointer */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		pointerValue = rTop;
		nativePopToReg(ssNativeTop(), pointerValue);
		ssNativePop(1);
		return 0;

	case 175:
		/* begin genLowcodePushConstantUInt32 */
		constant = extA;
		ssPushNativeConstantInt32(constant);
		extA = 0;
		return 0;

	case 176:
		/* begin genLowcodePushConstantUInt64 */
		constant = extA;
		ssPushNativeConstantInt64(constant);
		extA = 0;
		return 0;

	case 177:
		/* begin genLowcodePushNullPointer */
		ssPushNativeConstantPointer(0);
		return 0;

	case 178:
		/* begin genLowcodePushOne32 */
		ssPushNativeConstantInt32(1);
		return 0;

	case 179:
		/* begin genLowcodePushOne64 */
		ssPushNativeConstantInt64(1);
		return 0;

	case 180:
		/* begin genLowcodePushOneFloat32 */
		ssPushNativeConstantFloat32(1.0);
		return 0;

	case 181:
		/* begin genLowcodePushOneFloat64 */
		ssPushNativeConstantFloat64(1.0);
		return 0;

	case 182:
		/* begin genLowcodePushPhysicalFloat32 */
		registerID = extA;
		abort();
		extA = 0;
		return 0;

	case 183:
		/* begin genLowcodePushPhysicalFloat64 */
		registerID = extA;
		abort();
		extA = 0;
		return 0;

	case 184:
		/* begin genLowcodePushPhysicalInt32 */
		registerID = extA;
		abort();
		extA = 0;
		return 0;

	case 185:
		/* begin genLowcodePushPhysicalInt64 */
		registerID = extA;
		abort();
		extA = 0;
		return 0;

	case 186:
		/* begin genLowcodePushPhysicalPointer */
		registerID = extA;
		abort();
		extA = 0;
		return 0;

	default:
		return genLowcodeUnaryInlinePrimitive4(prim);
	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive4: */
static NoDbgRegParms sqInt
genLowcodeUnaryInlinePrimitive4(sqInt prim)
{
    AbstractInstruction *anInstruction;
    sqInt baseOffset;
    AbstractInstruction *contJump;
    sqInt doubleValue;
    AbstractInstruction *falseJump;
    sqInt first;
    sqInt floatValue;
    sqInt frResult;
    sqInt frTop;
    sqInt memoryPointer;
    sqInt pointer;
    sqInt pointerValue;
    sqInt reg;
    sqInt result;
    sqInt rNext;
    sqInt rResult;
    sqInt rTop;
    sqInt second;
    sqInt shiftAmount;
    sqInt topRegistersMask;
    sqInt value;

	switch (prim) {
	case 187:
		/* begin genLowcodePushSessionIdentifier */
		ssPushNativeConstantInt32(getThisSessionID());
		return 0;

	case 188:
		/* begin genLowcodePushZero32 */
		ssPushNativeConstantInt32(0);
		return 0;

	case 189:
		/* begin genLowcodePushZero64 */
		ssPushNativeConstantInt64(0);
		return 0;

	case 190:
		/* begin genLowcodePushZeroFloat32 */
		ssPushNativeConstantFloat32(0.0);
		return 0;

	case 191:
		/* begin genLowcodePushZeroFloat64 */
		ssPushNativeConstantFloat64(0.0);
		return 0;

	case 192:
		/* begin genLowcodeRem32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		gDivRRQuoRem(second, first, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 193:
		/* begin genLowcodeRem64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 194:
		/* begin genLowcodeRightShift32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		shiftAmount = rTop;
		value = rNext;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* LogicalShiftRightR:R: */
		genoperandoperand(LogicalShiftRightRR, shiftAmount, value);
		ssPushNativeRegister(value);
		return 0;

	case 195:
		/* begin genLowcodeRightShift64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		shiftAmount = rTop;
		value = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 196:
		/* begin genLowcodeSignExtend32From16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 197:
		/* begin genLowcodeSignExtend32From8 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* SignExtend8R:R: */
		genoperandoperand(SignExtend8RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 198:
		/* begin genLowcodeSignExtend64From16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* SignExtend16R:R: */
		genoperandoperand(SignExtend16RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 199:
		/* begin genLowcodeSignExtend64From32 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* SignExtend32R:R: */
		genoperandoperand(SignExtend32RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 200:
		/* begin genLowcodeSignExtend64From8 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ZeroExtend16R:R: */
		genoperandoperand(ZeroExtend16RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 201:
		/* begin genLowcodeStoreFloat32ToMemory */
		/* begin allocateRegistersForLowcodeFloatInteger: */
		/* Integer registers */
		frTop = (rTop = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0);
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeValue(1));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0);
		}
		assert(!(((frTop == NoReg)
 || (rTop == NoReg))));
		floatValue = frTop;
		pointer = rTop;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), floatValue);
		ssNativePop(1);

		/* begin MoveRs:M32:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRsM32r, floatValue, 0, pointer);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		return 0;

	case 202:
		/* begin genLowcodeStoreFloat64ToMemory */
		/* begin allocateRegistersForLowcodeFloatInteger: */
		/* Integer registers */
		frTop = (rTop = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0);
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeValue(1));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0);
		}
		assert(!(((frTop == NoReg)
 || (rTop == NoReg))));
		doubleValue = frTop;
		pointer = rTop;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), doubleValue);
		ssNativePop(1);

		/* begin MoveRd:M64:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRdM64r, doubleValue, 0, pointer);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		return 0;

	case 203:
		/* begin genLowcodeStoreInt16ToMemory */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		pointer = rTop;
		value = rNext;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* MoveR:R: */
		genoperandoperand(MoveRR, value, TempReg);

		/* begin MoveR:M16:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRM16r, TempReg, 0, pointer);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		return 0;

	case 204:
		/* begin genLowcodeStoreInt32ToMemory */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		pointer = rTop;
		value = rNext;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin MoveR:M32:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRM32r, value, 0, pointer);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		return 0;

	case 205:
		/* begin genLowcodeStoreInt64ToMemory */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		pointer = rTop;
		value = rNext;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin MoveR:M64:r: */
		assert(BytesPerWord == 8);
		anInstruction = genoperandoperandoperand(MoveRMwr, value, 0, pointer);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		return 0;

	case 206:
		/* begin genLowcodeStoreInt8ToMemory */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		pointer = rTop;
		value = rNext;
		nativePopToReg(ssNativeTop(), pointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* MoveR:R: */
		genoperandoperand(MoveRR, value, TempReg);

		/* begin MoveR:M8:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRM8r, TempReg, 0, pointer);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		return 0;

	case 207:
		/* begin genLowcodeStoreLocalFloat32 */
		baseOffset = extA;
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		value = frTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveRs:M32:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRsM32r, value, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		extA = 0;
		return 0;

	case 208:
		/* begin genLowcodeStoreLocalFloat64 */
		baseOffset = extA;
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		value = frTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveRd:M64:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRdM64r, value, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		extA = 0;
		return 0;

	case 209:
		/* begin genLowcodeStoreLocalInt16 */
		baseOffset = extA;
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* MoveR:R: */
		genoperandoperand(MoveRR, value, TempReg);
		loadNativeLocalAddressto(baseOffset, value);

		/* begin MoveR:M16:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRM16r, TempReg, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		extA = 0;
		return 0;

	case 210:
		/* begin genLowcodeStoreLocalInt32 */
		baseOffset = extA;
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveR:M32:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRM32r, value, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		extA = 0;
		return 0;

	case 211:
		/* begin genLowcodeStoreLocalInt64 */
		baseOffset = extA;
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin MoveR:M64:r: */
		assert(BytesPerWord == 8);
		anInstruction = genoperandoperandoperand(MoveRMwr, value, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		extA = 0;
		return 0;

	case 212:
		/* begin genLowcodeStoreLocalInt8 */
		baseOffset = extA;
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* MoveR:R: */
		genoperandoperand(MoveRR, value, TempReg);
		loadNativeLocalAddressto(baseOffset, value);

		/* begin MoveR:M8:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRM8r, TempReg, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		extA = 0;
		return 0;

	case 213:
		/* begin genLowcodeStoreLocalPointer */
		baseOffset = extA;
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		pointerValue = rTop;
		nativePopToReg(ssNativeTop(), pointerValue);
		ssNativePop(1);
		loadNativeLocalAddressto(baseOffset, TempReg);

		/* begin MoveR:Mw:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRMwr, pointerValue, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		extA = 0;
		return 0;

	case 214:
		/* begin genLowcodeStorePointerToMemory */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		memoryPointer = rTop;
		pointerValue = rNext;
		nativePopToReg(ssNativeTop(), memoryPointer);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), pointerValue);
		ssNativePop(1);

		/* begin MoveR:Mw:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRMwr, pointerValue, 0, memoryPointer);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		return 0;

	case 215:
		/* begin genLowcodeSub32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* SubR:R: */
		genoperandoperand(SubRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 216:
		/* begin genLowcodeSub64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* SubR:R: */
		genoperandoperand(SubRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 217:
		/* begin genLowcodeTruncate32To16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, 0xFFFF, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0xFFFF, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 218:
		/* begin genLowcodeTruncate32To8 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, 0xFF, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0xFF, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 219:
		/* begin genLowcodeTruncate64To16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, 0xFFFF, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0xFFFF, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 220:
		/* begin genLowcodeTruncate64To32 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, 0xFFFFFFFFU, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0xFFFFFFFFU, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 221:
		/* begin genLowcodeTruncate64To8 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, 0xFF, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0xFF, BytesPerOop));
		}
		ssPushNativeRegister(value);
		return 0;

	case 222:
		/* begin genLowcodeUdiv32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		gDivRRQuoRem(second, first, first, second);
		ssPushNativeRegister(first);
		return 0;

	case 223:
		/* begin genLowcodeUdiv64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 224:
		/* begin genLowcodeUint32Great */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 225:
		/* begin genLowcodeUint32GreatEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpBelow, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 226:
		/* begin genLowcodeUint32Less */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 227:
		/* begin genLowcodeUint32LessEqual */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* begin CmpR:R: */
		assert(!((second == SPReg)));
		genoperandoperand(CmpRR, second, first);

		/* True result */
		falseJump = genConditionalBranchoperand(JumpAbove, ((sqInt)0));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, first);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(first);
		return 0;

	case 228:
		/* begin genLowcodeUint32ToFloat32 */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		value = rTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* ConvertR:Rs: */
		genoperandoperand(ConvertRRs, value, result);
		ssPushNativeRegisterSingleFloat(result);
		return 0;

	case 229:
		/* begin genLowcodeUint32ToFloat64 */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		value = rTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* ConvertR:Rd: */
		genoperandoperand(ConvertRRd, value, result);
		ssPushNativeRegisterDoubleFloat(result);
		return 0;

	case 230:
		/* begin genLowcodeUint64Great */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 231:
		/* begin genLowcodeUint64GreatEqual */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 232:
		/* begin genLowcodeUint64Less */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 233:
		/* begin genLowcodeUint64LessEqual */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 234:
		/* begin genLowcodeUint64ToFloat32 */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		value = rTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 235:
		/* begin genLowcodeUint64ToFloat64 */
		/* begin allocateRegistersForLowcodeIntegerResultFloat: */
		rTop = NoReg;
		frResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((rTop == NoReg)
 || (frResult == NoReg))));
		value = rTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 236:
		/* begin genLowcodeUmul32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* MulR:R: */
		genMulRR(backEnd, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 237:
		/* begin genLowcodeUmul64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 238:
		return 0 /* genLowcodeUnlockRegisters */;

	case 239:
		/* begin genLowcodeUnlockVM */
		abort();
		return 0;

	case 240:
		/* begin genLowcodeUrem32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		gDivRRQuoRem(second, first, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 241:
		/* begin genLowcodeUrem64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 242:
		/* begin genLowcodeXor32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* XorR:R: */
		genoperandoperand(XorRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 243:
		/* begin genLowcodeXor64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* XorR:R: */
		genoperandoperand(XorRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 244:
		/* begin genLowcodeZeroExtend32From16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ZeroExtend16R:R: */
		genoperandoperand(ZeroExtend16RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 245:
		/* begin genLowcodeZeroExtend32From8 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ZeroExtend8R:R: */
		genoperandoperand(ZeroExtend8RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 246:
		/* begin genLowcodeZeroExtend64From16 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ZeroExtend16R:R: */
		genoperandoperand(ZeroExtend16RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	default:
		return genLowcodeUnaryInlinePrimitive5(prim);
	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive5: */
static NoDbgRegParms sqInt
genLowcodeUnaryInlinePrimitive5(sqInt prim)
{
    sqInt result;
    sqInt rResult;
    sqInt rTop;
    sqInt value;

	switch (prim) {
	case 247:
		/* begin genLowcodeZeroExtend64From32 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ZeroExtend32R:R: */
		genoperandoperand(ZeroExtend32RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	case 0xF8:
		/* begin genLowcodeZeroExtend64From8 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		value = rTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* begin ZeroExtend8R:R: */
		genoperandoperand(ZeroExtend8RR, value, value);
		ssPushNativeRegister(value);
		return 0;

	default:
		return EncounteredUnknownBytecode;
	}
	return 0;
}


/*	Lowcode instruction generator dispatch */

	/* StackToRegisterMappingCogit>>#genLowcodeUnaryInlinePrimitive: */
static NoDbgRegParms sqInt
genLowcodeUnaryInlinePrimitive(sqInt prim)
{
    AbstractInstruction *abstractInstruction;
    sqInt alignment;
    AbstractInstruction *anInstruction;
    sqInt base;
    sqInt check;
    AbstractInstruction *contJump;
    sqInt dup2;
    sqInt expectedSession;
    AbstractInstruction *falseJump;
    sqInt first;
    sqInt frNext;
    sqInt frResult;
    sqInt frTop;
    sqInt function;
    sqInt index;
    sqInt nativeValueIndex;
    sqInt newValue;
    sqInt nextRegisterMask;
    sqInt offset;
    sqInt oldValue;
    sqInt pointerValue;
    sqInt reg;
    sqInt registerID;
    sqInt result;
    sqInt rNext;
    sqInt rNextNext;
    sqInt rNextNextNext;
    sqInt rResult;
    sqInt rTop;
    sqInt scale;
    sqInt second;
    sqInt shiftAmount;
    sqInt singleFloatValue;
    sqInt size;
    sqInt topRegistersMask;
    sqInt value;

	switch (prim) {
	case 0:
		/* begin genLowcodeAdd32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* AddR:R: */
		genoperandoperand(AddRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 1:
		/* begin genLowcodeAdd64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* AddR:R: */
		genoperandoperand(AddRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 2:
		/* begin genLowcodeAlloca32 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		size = rTop;
		nativePopToReg(ssNativeTop(), size);
		ssNativePop(1);

		/* #MoveAw:R: #gen:literal:operand: */
		checkLiteralforInstruction(nativeStackPointerAddress(), genoperandoperand(MoveAwR, nativeStackPointerAddress(), TempReg));

		/* SubR:R: */
		genoperandoperand(SubRR, size, TempReg);

		/* begin AndCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, -16, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(-16, BytesPerOop));
		}

		/* MoveR:R: */
		genoperandoperand(MoveRR, TempReg, size);

		/* #MoveR:Aw: #gen:operand:literal: */
		checkLiteralforInstruction(nativeStackPointerAddress(), genoperandoperand(MoveRAw, size, nativeStackPointerAddress()));
		ssPushNativeRegister(size);
		return 0;

	case 3:
		/* begin genLowcodeAlloca64 */
		/* begin allocateRegistersForLowcodeInteger: */
		rTop = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		assert(!((rTop == NoReg)));
		size = rTop;
		nativePopToReg(ssNativeTop(), size);
		ssNativePop(1);

		/* SubR:R: */
		genoperandoperand(SubRR, size, SPReg);

		/* MoveR:R: */
		genoperandoperand(MoveRR, SPReg, size);
		ssPushNativeRegister(size);
		return 0;

	case 4:
		/* begin genLowcodeAnd32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* AndR:R: */
		genoperandoperand(AndRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 5:
		/* begin genLowcodeAnd64 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* AndR:R: */
		genoperandoperand(AndRR, second, first);
		ssPushNativeRegister(first);
		return 0;

	case 6:
		/* begin genLowcodeArithmeticRightShift32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		shiftAmount = rTop;
		value = rNext;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* ArithmeticShiftRightR:R: */
		genoperandoperand(ArithmeticShiftRightRR, shiftAmount, value);
		ssPushNativeRegister(value);
		return 0;

	case 7:
		/* begin genLowcodeArithmeticRightShift64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		shiftAmount = rTop;
		value = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), shiftAmount);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 8:
		/* begin genLowcodeBeginCall */
		alignment = extA;
		beginHighLevelCall(alignment);
		extA = 0;
		return 0;

	case 9:
		/* begin genLowcodeCallArgumentFloat32 */
		nativeStackPopToReg(ssNativeTop(), DPFPReg0);
		ssNativePop(1);

		/* begin MoveRs:M32:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRsM32r, DPFPReg0, -BytesPerWord, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(-BytesPerWord, BytesPerOop));
		}

		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, BytesPerWord, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
		}
		currentCallCleanUpSize += BytesPerWord;
		return 0;

	case 10:
		/* begin genLowcodeCallArgumentFloat64 */
		nativeStackPopToReg(ssNativeTop(), DPFPReg0);
		ssNativePop(1);

		/* begin MoveRd:M64:r: */
		/* begin gen:operand:quickConstant:operand: */
		anInstruction = genoperandoperandoperand(MoveRdM64r, DPFPReg0, -8, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(-8, BytesPerOop));
		}

		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, 8, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(8, BytesPerOop));
		}
		currentCallCleanUpSize += 8;
		return 0;

	case 11:
		/* begin genLowcodeCallArgumentInt32 */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);

		/* PushR: */
		genoperand(PushR, TempReg);
		currentCallCleanUpSize += BytesPerWord;
		return 0;

	case 12:
		/* begin genLowcodeCallArgumentInt64 */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);

		/* PushR: */
		genoperand(PushR, TempReg);
		currentCallCleanUpSize += BytesPerWord;
		return 0;

	case 13:
		/* begin genLowcodeCallArgumentPointer */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);

		/* PushR: */
		genoperand(PushR, TempReg);
		currentCallCleanUpSize += BytesPerWord;
		return 0;

	case 14:
		/* begin genLowcodeCallArgumentSpace */
		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, extA, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(extA, BytesPerOop));
		}
		currentCallCleanUpSize += extA;
		extA = 0;
		return 0;

	case 15:
		/* begin genLowcodeCallArgumentStructure */
		nativeStackPopToReg(ssNativeTop(), TempReg);
		ssNativePop(1);

		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, extA, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(extA, BytesPerOop));
		}

		/* Copy the structure */
		currentCallCleanUpSize += extA;
		genMemCopytoconstantSize(backEnd, TempReg, SPReg, extA);
		extA = 0;
		return 0;

	case 16:
		/* begin genLowcodeCallInstruction */
		function = extA;
		abstractInstruction = genoperand(Call, function);
		(abstractInstruction->annotation = IsRelativeCall);
		extA = 0;
		return 0;

	case 17:
		/* begin genLowcodeCallPhysical */
		registerID = extA;

		/* CallR: */
		genoperand(CallR, registerID);
		extA = 0;
		return 0;

	case 18:
		/* begin genLowcodeCheckSessionIdentifier */
		expectedSession = extA;
		ssPushNativeConstantInt32((expectedSession == (getThisSessionID())
				? 1
				: 0));
		extA = 0;
		return 0;

	case 19:
		/* begin genLowcodeCompareAndSwap32 */
		/* begin allocateRegistersForLowcodeInteger3ResultInteger: */
		rTop = (rNext = (rNextNext = NoReg));
		nativeValueIndex = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
					rNextNext = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex));
				}
				nativeValueIndex += 1;
			}
		}
		if (rNextNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
			}
		}
		if (rTop == NoReg) {
			nextRegisterMask = 0;
			if (rNext != NoReg) {
				nextRegisterMask = ((rNext < 0) ? (((usqInt)(1)) >> (-rNext)) : (1ULL << rNext));
			}
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			rTop = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNext == NoReg) {
			nextRegisterMask = ((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop));
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			rNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNextNext == NoReg) {
			nextRegisterMask = (1ULL << rTop) | (1ULL << rNext);
			rNextNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		assert(!(((rTop == NoReg)
 || ((rNext == NoReg)
 || (rNextNext == NoReg)))));
		rResult = allocateRegNotConflictingWith(((1ULL << rTop) | (1ULL << rNext)) | (1ULL << rNextNext));
		assert(!((rResult == NoReg)));
		newValue = rTop;
		oldValue = rNext;
		check = rNextNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), newValue);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), oldValue);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), check);
		ssNativePop(1);
		abort();
		return 0;

	case 20:
		/* begin genLowcodeDiv32 */
		/* begin allocateRegistersForLowcodeInteger2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		gDivRRQuoRem(second, first, first, second);
		ssPushNativeRegister(first);
		return 0;

	case 21:
		/* begin genLowcodeDiv64 */
		/* begin allocateRegistersForLowcodeInteger2ResultInteger: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(1))) != NoReg) {
				reg = (rNext = nativeRegisterOrNone(ssNativeValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		rResult = allocateFloatRegNotConflictingWith((1ULL << rTop) | (1ULL << rNext));
		assert(!((rResult == NoReg)));
		second = rTop;
		first = rNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);
		abort();
		return 0;

	case 22:
		/* begin genLowcodeDuplicateFloat32 */
		/* begin allocateRegistersForLowcodeFloatResultFloat: */
		frTop = NoReg;

		/* Float argument */
		frResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		assert(!(((frTop == NoReg)
 || (frResult == NoReg))));
		value = frTop;
		dup2 = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* MoveRs:Rs: */
		genoperandoperand(MoveRsRs, value, dup2);
		ssPushNativeRegisterSingleFloat(value);
		ssPushNativeRegisterSingleFloat(dup2);
		return 0;

	case 23:
		/* begin genLowcodeDuplicateFloat64 */
		/* begin allocateRegistersForLowcodeFloatResultFloat: */
		frTop = NoReg;

		/* Float argument */
		frResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		assert(!(((frTop == NoReg)
 || (frResult == NoReg))));
		value = frTop;
		dup2 = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* MoveRd:Rd: */
		genoperandoperand(MoveRdRd, value, dup2);
		ssPushNativeRegisterDoubleFloat(value);
		ssPushNativeRegisterDoubleFloat(dup2);
		return 0;

	case 24:
		/* begin genLowcodeDuplicateInt32 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		dup2 = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* MoveR:R: */
		genoperandoperand(MoveRR, value, dup2);
		ssPushNativeRegister(value);
		ssPushNativeRegister(dup2);
		return 0;

	case 25:
		/* begin genLowcodeDuplicateInt64 */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		value = rTop;
		dup2 = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* MoveR:R: */
		genoperandoperand(MoveRR, value, dup2);
		ssPushNativeRegister(value);
		ssPushNativeRegister(dup2);
		return 0;

	case 26:
		/* begin genLowcodeDuplicatePointer */
		/* begin allocateRegistersForLowcodeIntegerResultInteger: */
		rTop = NoReg;
		rResult = NoReg;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
		}
		if (rTop == NoReg) {
			rTop = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		assert(!(((rTop == NoReg)
 || (rResult == NoReg))));
		pointerValue = rTop;
		dup2 = rResult;
		nativePopToReg(ssNativeTop(), pointerValue);
		ssNativePop(1);

		/* MoveR:R: */
		genoperandoperand(MoveRR, pointerValue, dup2);
		ssPushNativeRegister(pointerValue);
		ssPushNativeRegister(dup2);
		return 0;

	case 27:
		/* begin genLowcodeEffectiveAddress32 */
		/* begin allocateRegistersForLowcodeInteger4: */
		rTop = (rNext = (rNextNext = (rNextNextNext = NoReg)));
		nativeValueIndex = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
					rNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				}
				nativeValueIndex += 1;
			}
		}
		if (rNextNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
					rNextNextNext = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex));
				}
				nativeValueIndex += 1;
			}
		}
		if (rNextNextNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNextNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				nativeValueIndex += 1;
			}
		}
		if (rTop == NoReg) {
			nextRegisterMask = 0;
			if (rNext != NoReg) {
				nextRegisterMask = ((rNext < 0) ? (((usqInt)(1)) >> (-rNext)) : (1ULL << rNext));
			}
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			if (rNextNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNextNext < 0) ? (((usqInt)(1)) >> (-rNextNextNext)) : (1ULL << rNextNextNext)));
			}
			rTop = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNext == NoReg) {
			nextRegisterMask = ((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop));
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			if (rNextNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNextNext < 0) ? (((usqInt)(1)) >> (-rNextNextNext)) : (1ULL << rNextNextNext)));
			}
			rNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNextNext == NoReg) {
			nextRegisterMask = (1ULL << rTop) | (1ULL << rNext);
			if (rNextNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNextNext < 0) ? (((usqInt)(1)) >> (-rNextNextNext)) : (1ULL << rNextNextNext)));
			}
			rNextNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNextNextNext == NoReg) {
			nextRegisterMask = ((1ULL << rTop) | (1ULL << rNext)) | (1ULL << rNextNext);
			rNextNextNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		assert(!(((rTop == NoReg)
 || ((rNext == NoReg)
 || ((rNextNext == NoReg)
 || (rNextNextNext == NoReg))))));
		offset = rTop;
		scale = rNext;
		index = rNextNext;
		base = rNextNextNext;
		nativePopToReg(ssNativeTop(), offset);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), scale);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), index);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), base);
		ssNativePop(1);

		/* MulR:R: */
		genMulRR(backEnd, scale, index);

		/* AddR:R: */
		genoperandoperand(AddRR, index, base);

		/* AddR:R: */
		genoperandoperand(AddRR, offset, base);
		ssPushNativeRegister(base);
		return 0;

	case 28:
		/* begin genLowcodeEffectiveAddress64 */
		/* begin allocateRegistersForLowcodeInteger4ResultInteger: */
		rTop = (rNext = (rNextNext = (rNextNextNext = NoReg)));
		rResult = NoReg;
		nativeValueIndex = 1;
		if ((nativeRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeRegisterOrNone(ssNativeTop());
			if ((nativeRegisterSecondOrNone(ssNativeTop())) != NoReg) {
				rNext = nativeRegisterSecondOrNone(ssNativeTop());
			}
		}
		if (rNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
					rNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				}
				nativeValueIndex += 1;
			}
		}
		if (rNextNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				if ((nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
					rNextNextNext = nativeRegisterSecondOrNone(ssNativeValue(nativeValueIndex));
				}
				nativeValueIndex += 1;
			}
		}
		if (rNextNextNext == NoReg) {
			if ((nativeRegisterOrNone(ssNativeValue(nativeValueIndex))) != NoReg) {
				rNextNextNext = nativeRegisterOrNone(ssNativeValue(nativeValueIndex));
				nativeValueIndex += 1;
			}
		}
		if (rTop == NoReg) {
			nextRegisterMask = 0;
			if (rNext != NoReg) {
				nextRegisterMask = ((rNext < 0) ? (((usqInt)(1)) >> (-rNext)) : (1ULL << rNext));
			}
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			if (rNextNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNextNext < 0) ? (((usqInt)(1)) >> (-rNextNextNext)) : (1ULL << rNextNextNext)));
			}
			rTop = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNext == NoReg) {
			nextRegisterMask = ((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop));
			if (rNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNext < 0) ? (((usqInt)(1)) >> (-rNextNext)) : (1ULL << rNextNext)));
			}
			if (rNextNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNextNext < 0) ? (((usqInt)(1)) >> (-rNextNextNext)) : (1ULL << rNextNextNext)));
			}
			rNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNextNext == NoReg) {
			nextRegisterMask = (1ULL << rTop) | (1ULL << rNext);
			if (rNextNextNext != NoReg) {
				nextRegisterMask = nextRegisterMask | (((rNextNextNext < 0) ? (((usqInt)(1)) >> (-rNextNextNext)) : (1ULL << rNextNextNext)));
			}
			rNextNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		if (rNextNextNext == NoReg) {
			nextRegisterMask = ((1ULL << rTop) | (1ULL << rNext)) | (1ULL << rNextNext);
			rNextNextNext = allocateRegNotConflictingWith(nextRegisterMask);
		}
		assert(!(((rTop == NoReg)
 || ((rNext == NoReg)
 || ((rNextNext == NoReg)
 || (rNextNextNext == NoReg))))));
		rResult = allocateRegNotConflictingWith((((1ULL << rTop) | (1ULL << rNext)) | (1ULL << rNextNext)) | (1ULL << rNextNextNext));
		offset = rTop;
		scale = rNext;
		index = rNextNext;
		base = rNextNextNext;
		result = rResult;
		nativePopToReg(ssNativeTop(), offset);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), scale);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), index);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), base);
		ssNativePop(1);
		abort();
		return 0;

	case 29:
		/* begin genLowcodeEndCall */
		endHighLevelCallWithCleanup();
		return 0;

	case 30:
		/* begin genLowcodeEndCallNoCleanup */
		endHighLevelCallWithoutCleanup();
		return 0;

	case 0x1F:
		/* begin genLowcodeFloat32Add */
		/* begin allocateRegistersForLowcodeFloat2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (rNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (rTop == NoReg) {
			rTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateFloatRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* AddRs:Rs: */
		genoperandoperand(AddRsRs, second, first);
		ssPushNativeRegisterSingleFloat(first);
		return 0;

	case 32:
		/* begin genLowcodeFloat32Div */
		/* begin allocateRegistersForLowcodeFloat2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (rNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (rTop == NoReg) {
			rTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateFloatRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* DivRs:Rs: */
		genoperandoperand(DivRsRs, second, first);
		ssPushNativeRegisterSingleFloat(first);
		return 0;

	case 33:
		/* begin genLowcodeFloat32Equal */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second, first);

		/* True result */
		falseJump = gJumpFPNotEqual(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 34:
		/* begin genLowcodeFloat32Great */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second, first);

		/* True result */
		falseJump = gJumpFPLessOrEqual(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 35:
		/* begin genLowcodeFloat32GreatEqual */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second, first);

		/* True result */
		falseJump = gJumpFPLess(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 36:
		/* begin genLowcodeFloat32Less */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second, first);

		/* True result */
		falseJump = gJumpFPGreaterOrEqual(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 37:
		/* begin genLowcodeFloat32LessEqual */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second, first);

		/* True result */
		falseJump = gJumpFPGreater(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 38:
		/* begin genLowcodeFloat32Mul */
		/* begin allocateRegistersForLowcodeFloat2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (rNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (rTop == NoReg) {
			rTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateFloatRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* MulRs:Rs: */
		genoperandoperand(MulRsRs, second, first);
		ssPushNativeRegisterSingleFloat(first);
		return 0;

	case 39:
		/* begin genLowcodeFloat32Neg */
		/* begin allocateRegistersForLowcodeFloatResultFloat: */
		frTop = NoReg;

		/* Float argument */
		frResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		assert(!(((frTop == NoReg)
 || (frResult == NoReg))));
		value = frTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* XorRs:Rs: */
		genoperandoperand(XorRsRs, result, result);

		/* SubRs:Rs: */
		genoperandoperand(SubRsRs, value, result);
		ssPushNativeRegisterSingleFloat(result);
		return 0;

	case 40:
		/* begin genLowcodeFloat32NotEqual */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRs:Rs: */
		genoperandoperand(CmpRsRs, second, first);

		/* True result */
		falseJump = gJumpFPEqual(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 41:
		/* begin genLowcodeFloat32Sqrt */
		/* begin allocateRegistersForLowcodeFloat: */
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		value = frTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* SqrtRs: */
		genoperand(SqrtRs, value);
		ssPushNativeRegisterSingleFloat(value);
		return 0;

	case 42:
		/* begin genLowcodeFloat32Sub */
		/* begin allocateRegistersForLowcodeFloat2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (rNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (rTop == NoReg) {
			rTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateFloatRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* SubRs:Rs: */
		genoperandoperand(SubRsRs, second, first);
		ssPushNativeRegisterSingleFloat(first);
		return 0;

	case 43:
		/* begin genLowcodeFloat32ToFloat64 */
		/* begin allocateRegistersForLowcodeFloat: */
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		singleFloatValue = frTop;
		nativePopToReg(ssNativeTop(), singleFloatValue);
		ssNativePop(1);

		/* ConvertRs:Rd: */
		genoperandoperand(ConvertRsRd, singleFloatValue, singleFloatValue);
		ssPushNativeRegisterDoubleFloat(singleFloatValue);
		return 0;

	case 44:
		/* begin genLowcodeFloat32ToInt32 */
		/* begin allocateRegistersForLowcodeFloatResultInteger: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		value = frTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* ConvertRs:R: */
		genoperandoperand(ConvertRsR, value, result);
		ssPushNativeRegister(result);
		return 0;

	case 45:
		/* begin genLowcodeFloat32ToInt64 */
		/* begin allocateRegistersForLowcodeFloatResultInteger: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		value = frTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 46:
		/* begin genLowcodeFloat32ToUInt32 */
		/* begin allocateRegistersForLowcodeFloatResultInteger: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		value = frTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* ConvertRs:R: */
		genoperandoperand(ConvertRsR, value, result);
		ssPushNativeRegister(result);
		return 0;

	case 47:
		/* begin genLowcodeFloat32ToUInt64 */
		/* begin allocateRegistersForLowcodeFloatResultInteger: */
		frTop = NoReg;

		/* Float argument */
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		rResult = allocateRegNotConflictingWith(0 /* emptyRegisterMask */);
		assert(!(((frTop == NoReg)
 || (rResult == NoReg))));
		value = frTop;
		result = rResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);
		abort();
		return 0;

	case 48:
		/* begin genLowcodeFloat64Add */
		/* begin allocateRegistersForLowcodeFloat2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (rNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (rTop == NoReg) {
			rTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateFloatRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* AddRd:Rd: */
		genoperandoperand(AddRdRd, second, first);
		ssPushNativeRegisterDoubleFloat(first);
		return 0;

	case 49:
		/* begin genLowcodeFloat64Div */
		/* begin allocateRegistersForLowcodeFloat2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (rNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (rTop == NoReg) {
			rTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateFloatRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* DivRd:Rd: */
		genoperandoperand(DivRdRd, second, first);
		ssPushNativeRegisterDoubleFloat(first);
		return 0;

	case 50:
		/* begin genLowcodeFloat64Equal */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second, first);

		/* True result */
		falseJump = gJumpFPNotEqual(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 51:
		/* begin genLowcodeFloat64Great */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second, first);

		/* True result */
		falseJump = gJumpFPLessOrEqual(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 52:
		/* begin genLowcodeFloat64GreatEqual */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second, first);

		/* True result */
		falseJump = gJumpFPLess(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 53:
		/* begin genLowcodeFloat64Less */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second, first);

		/* True result */
		falseJump = gJumpFPGreaterOrEqual(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 54:
		/* begin genLowcodeFloat64LessEqual */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second, first);

		/* True result */
		falseJump = gJumpFPGreater(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 55:
		/* begin genLowcodeFloat64Mul */
		/* begin allocateRegistersForLowcodeFloat2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (rNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (rTop == NoReg) {
			rTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateFloatRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* MulRd:Rd: */
		genoperandoperand(MulRdRd, second, first);
		ssPushNativeRegisterDoubleFloat(first);
		return 0;

	case 56:
		/* begin genLowcodeFloat64Neg */
		/* begin allocateRegistersForLowcodeFloatResultFloat: */
		frTop = NoReg;

		/* Float argument */
		frResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(0 /* emptyRegisterMask */);
		}
		frResult = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		assert(!(((frTop == NoReg)
 || (frResult == NoReg))));
		value = frTop;
		result = frResult;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* XorRd:Rd: */
		genoperandoperand(XorRdRd, result, result);

		/* SubRd:Rd: */
		genoperandoperand(SubRdRd, value, result);
		ssPushNativeRegisterDoubleFloat(result);
		return 0;

	case 57:
		/* begin genLowcodeFloat64NotEqual */
		/* begin allocateRegistersForLowcodeFloat2ResultInteger: */
		topRegistersMask = 0;
		frTop = (frNext = NoReg);
		rResult = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (frNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (frNext == NoReg) {
			frNext = allocateFloatRegNotConflictingWith(((frTop < 0) ? (((usqInt)(1)) >> (-frTop)) : (1ULL << frTop)));
		}
		rResult = allocateRegNotConflictingWith(0);
		assert(!(((frTop == NoReg)
 || ((frNext == NoReg)
 || (rResult == NoReg)))));
		second = frTop;
		first = frNext;
		value = rResult;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* CmpRd:Rd: */
		genoperandoperand(CmpRdRd, second, first);

		/* True result */
		falseJump = gJumpFPEqual(0);

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 1, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
		}

		/* False result */
		contJump = genoperand(Jump, ((sqInt)0));
		jmpTarget(falseJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, 0, value);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
		}
		jmpTarget(contJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		ssPushNativeRegister(value);
		return 0;

	case 58:
		/* begin genLowcodeFloat64Sqrt */
		/* begin allocateRegistersForLowcodeFloat: */
		topRegistersMask = 0;
		frTop = NoReg;
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			frTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if (frTop == NoReg) {
			frTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		assert(!((frTop == NoReg)));
		value = frTop;
		nativePopToReg(ssNativeTop(), value);
		ssNativePop(1);

		/* SqrtRd: */
		genoperand(SqrtRd, value);
		ssPushNativeRegisterDoubleFloat(value);
		return 0;

	case 59:
		/* begin genLowcodeFloat64Sub */
		/* begin allocateRegistersForLowcodeFloat2: */
		topRegistersMask = 0;
		rTop = (rNext = NoReg);
		if ((nativeFloatRegisterOrNone(ssNativeTop())) != NoReg) {
			rTop = nativeFloatRegisterOrNone(ssNativeTop());
		}
		if ((nativeFloatRegisterOrNone(ssNativeValue(1))) != NoReg) {
			reg = (rNext = nativeFloatRegisterOrNone(ssNativeValue(1)));

			/* begin registerMaskFor: */
			topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
		}
		if (rTop == NoReg) {
			rTop = allocateFloatRegNotConflictingWith(topRegistersMask);
		}
		if (rNext == NoReg) {
			rNext = allocateFloatRegNotConflictingWith(((rTop < 0) ? (((usqInt)(1)) >> (-rTop)) : (1ULL << rTop)));
		}
		assert(!(((rTop == NoReg)
 || (rNext == NoReg))));
		second = rTop;
		first = rNext;
		nativePopToReg(ssNativeTop(), second);
		ssNativePop(1);
		nativePopToReg(ssNativeTop(), first);
		ssNativePop(1);

		/* SubRd:Rd: */
		genoperandoperand(SubRdRd, second, first);
		ssPushNativeRegisterDoubleFloat(first);
		return 0;

	default:
		return genLowcodeUnaryInlinePrimitive2(prim);
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#genMarshalledSend:numArgs:sendTable: */
static NoDbgRegParms sqInt
genMarshalledSendnumArgssendTable(sqInt selectorIndex, sqInt numArgs, sqInt *sendTable)
{
    AbstractInstruction *anInstruction;
    sqInt annotation;
    AbstractInstruction *instruction;

	assert(needsFrame);

	/* begin annotationForSendTable: */
	if (sendTable == ordinarySendTrampolines) {
		annotation = IsSendCall;
		goto l1;
	}
	if (sendTable == directedSuperSendTrampolines) {
		annotation = IsDirectedSuperSend;
		goto l1;
	}
	if (sendTable == directedSuperBindingSendTrampolines) {
		annotation = IsDirectedSuperBindingSend;
		goto l1;
	}
	assert(sendTable == superSendTrampolines);
	annotation = IsSuperSend;
l1:	/* end annotationForSendTable: */;
	if (/* annotationIsForUncheckedEntryPoint: */
		(annotation == IsSuperSend)
	 || (((annotation >= IsDirectedSuperSend) && (annotation <= IsDirectedSuperBindingSend)))) {
		/* begin genEnsureOopInRegNotForwarded:scratchReg: */
		instruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		genEnsureOopInRegNotForwardedscratchRegifForwarderifNotForwarder(ReceiverResultReg, TempReg, instruction, 0);
	}
	if (numArgs >= (NumSendTrampolines - 1)) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, numArgs, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(numArgs, BytesPerOop));
		}
	}
	if (((annotation >= IsDirectedSuperSend) && (annotation <= IsDirectedSuperBindingSend))) {
		/* begin genMoveConstant:R: */
		if (/* shouldAnnotateObjectReference: */
			(isNonImmediate(tempOop))
		 && ((oopisGreaterThan(tempOop, classTableRootObj()))
		 || (oopisLessThan(tempOop, nilObject())))) {
			annotateobjRef(checkLiteralforInstruction(tempOop, genoperandoperand(MoveCwR, tempOop, TempReg)), tempOop);
		}
		else {
			/* begin MoveCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(MoveCqR, tempOop, TempReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(tempOop, BytesPerOop));
			}
		}
	}
	genLoadInlineCacheWithSelector(selectorIndex);
	((genoperand(Call, sendTable[((numArgs < (NumSendTrampolines - 1)) ? numArgs : (NumSendTrampolines - 1))]))->annotation = annotation);

	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	return ssPushRegister(ReceiverResultReg);
}


/*	Generate the abort for a method. This abort performs either a call of
	ceSICMiss: to handle a single-in-line cache miss or a call of
	ceStackOverflow: to handle a
	stack overflow. It distinguishes the two by testing ResultReceiverReg. If
	the register is zero then this is a stack-overflow because a) the receiver
	has already
	been pushed and so can be set to zero before calling the abort, and b) the
	receiver must always contain an object (and hence be non-zero) on SIC
	miss.  */

	/* StackToRegisterMappingCogit>>#genMethodAbortTrampolineFor: */
static NoDbgRegParms usqInt
genMethodAbortTrampolineFor(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSICMiss;

	zeroOpcodeIndex();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}

	/* The abort sequence has pushed the LinkReg a second time - because a stack
	   overflow can only happen after building a frame, which pushes LinkReg anyway, and
	   we still need to push LinkReg in case we get to this routine from a sendMissAbort.
	   (On ARM there is a simpler way; use two separate abort calls since all instructions are 32-bits
	   but on x86 the zero receiver reg, call methodAbort sequence is smaller; we may fix this one day).
	   Overwrite that duplicate with the right one - the return address for the call to the abort trampoline.
	   The only reason it matters is an assert in ceStackOverflow: uses it */
	jumpSICMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, LinkReg, 0, SPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(0, BytesPerOop));
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceStackOverflow, 1, SendNumArgsReg, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg);
	jmpTarget(jumpSICMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genPushRegisterArgsForAbortMissNumArgs(backEnd, numArgs);
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceSICMiss, trampolineNamenumRegArgs("ceMethodAbort", numArgs), 1, ReceiverResultReg, null, null, null, 0 /* emptyRegisterMask */, 0, NoReg, 1);
}


/*	Generate the abort for a PIC. This abort performs either a call of
	ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged
	target or a call of ceMNUFromPICMNUMethod:receiver: to handle an
	MNU dispatch in a closed PIC. It distinguishes the two by testing
	ClassReg. If the register is zero then this is an MNU. */

	/* StackToRegisterMappingCogit>>#genPICAbortTrampolineFor: */
static NoDbgRegParms usqInt
genPICAbortTrampolineFor(sqInt numArgs)
{
	zeroOpcodeIndex();
	genPushRegisterArgsForAbortMissNumArgs(backEnd, numArgs);
	return genInnerPICAbortTrampoline(trampolineNamenumRegArgs("cePICAbort", numArgs));
}

	/* StackToRegisterMappingCogit>>#genPICMissTrampolineFor: */
static NoDbgRegParms usqInt
genPICMissTrampolineFor(sqInt numArgs)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCPICMissreceiver, trampolineNamenumRegArgs("cePICMiss", numArgs), 2, ClassReg, ReceiverResultReg, null, null, 0 /* emptyRegisterMask */, 1, NoReg, 1);
	return startAddress;
}

	/* StackToRegisterMappingCogit>>#genPopStackBytecode */
static sqInt
genPopStackBytecode(void)
{
    AbstractInstruction *anInstruction;

	if (((ssTop())->spilled)) {
		/* begin AddCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
		}
	}
	ssPop(1);
	return 0;
}


/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive. */
/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive.
	Override to push the register args first. */

	/* StackToRegisterMappingCogit>>#genPrimitiveClosureValue */
static sqInt
genPrimitiveClosureValue(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpFail1;
    AbstractInstruction *jumpFail2;
    AbstractInstruction *jumpFail3;
    AbstractInstruction *jumpFail4;
    AbstractInstruction *jumpFailNArgs;
    sqInt offset;
    void (*primitiveRoutine)(void);
    sqInt quickConstant;
    sqInt result;

	genPushRegisterArgs();
	genLoadSlotsourceRegdestReg(ClosureNumArgsIndex, ReceiverResultReg, TempReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)methodOrBlockNumArgs << 3) | 1), TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)methodOrBlockNumArgs << 3) | 1), BytesPerOop));
	}
	jumpFailNArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, ClassReg);
	jumpFail1 = genJumpImmediate(ClassReg);
	genGetCompactClassIndexNonImmOfinto(ClassReg, TempReg);
	genCmpClassMethodContextCompactIndexR(TempReg);

	/* We defer unforwarding the receiver to the prologue; scanning blocks
	   for inst var refs and only unforwarding if the block refers to inst vars. */
	jumpFail2 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(MethodIndex, ClassReg, SendNumArgsReg);
	jumpFail3 = genJumpImmediate(SendNumArgsReg);
	genGetFormatOfinto(SendNumArgsReg, TempReg);
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpFail4 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	offset = offsetof(CogMethod, blockEntryOffset);

	/* begin MoveM16:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveM16rR, offset, ClassReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* AddR:R: */
	genoperandoperand(AddRR, ClassReg, TempReg);
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, null);
	if (primitiveRoutine == primitiveClosureValueNoContextSwitch) {
		if (!blockNoContextSwitchOffset) {
			return NotFullyInitialized;
		}

		/* begin SubCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(SubCqR, blockNoContextSwitchOffset, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(blockNoContextSwitchOffset, BytesPerOop));
		}
	}

	/* JumpR: */
	genoperand(JumpR, TempReg);
	jmpTarget(jumpBCMethod, jmpTarget(jumpFail1, jmpTarget(jumpFail2, jmpTarget(jumpFail3, jmpTarget(jumpFail4, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	if (((result = compileInterpreterPrimitiveflags(primitiveRoutine, primitivePropertyFlagsnumArgs(primitiveIndex, methodOrBlockNumArgs)))) < 0) {
		return result;
	}
	jmpTarget(jumpFailNArgs, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive. */
/*	Override to push the register args first. */

	/* StackToRegisterMappingCogit>>#genPrimitiveFullClosureValue */
static sqInt
genPrimitiveFullClosureValue(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpFail4;
    AbstractInstruction *jumpFailImmediateMethod;
    AbstractInstruction *jumpFailNArgs;
    void (*primitiveRoutine)(void);
    sqInt quickConstant;
    sqInt result;

	genPushRegisterArgs();
	genLoadSlotsourceRegdestReg(ClosureNumArgsIndex, ReceiverResultReg, TempReg);

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)methodOrBlockNumArgs << 3) | 1), TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize((((usqInt)methodOrBlockNumArgs << 3) | 1), BytesPerOop));
	}

	/* We defer unforwarding the receiver to the prologue; scanning blocks
	   for inst var refs and only unforwarding if the block refers to inst vars. */
	jumpFailNArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(FullClosureCompiledBlockIndex, ReceiverResultReg, SendNumArgsReg);
	jumpFailImmediateMethod = genJumpImmediate(SendNumArgsReg);
	genGetFormatOfinto(SendNumArgsReg, TempReg);
	quickConstant = firstCompiledMethodFormat();

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}
	jumpFail4 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, null);
	quickConstant = (primitiveRoutine == primitiveFullClosureValueNoContextSwitch
				? fullBlockNoContextSwitchEntryOffset()
				: fullBlockEntryOffset());

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(quickConstant, BytesPerOop));
	}

	/* JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpBCMethod, jmpTarget(jumpFailImmediateMethod, jmpTarget(jumpFail4, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	if (((result = compileInterpreterPrimitiveflags(primitiveRoutine, primitivePropertyFlagsnumArgs(primitiveIndex, methodOrBlockNumArgs)))) < 0) {
		return result;
	}
	jmpTarget(jumpFailNArgs, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	Generate an in-line perform primitive. The lookup code requires the
	selector to be in Arg0Reg.
	adjustArgumentsForPerform: adjusts the arguments once
	genLookupForPerformNumArgs: has generated the code for the lookup. */

	/* StackToRegisterMappingCogit>>#genPrimitivePerform */
static sqInt
genPrimitivePerform(void)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	if (methodOrBlockNumArgs > (numRegArgs())) {
		offset = (methodOrBlockNumArgs - 1) * BytesPerWord;

		/* begin MoveMw:r:R: */
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
		}
	}
	return genLookupForPerformNumArgs(methodOrBlockNumArgs);
}


/*	Generate an in-line perform:withArguments: primitive. The lookup code
	requires the selector to be in Arg0Reg
	and the array to be in Arg1Reg. The primitive will only handle cases 0 to
	numRegArgs. Is it worth it you ask?
	Here are arguemnt count requencies for a short run of Croquet/Virtend
	which show that even for V3, with only
	one rtegister arg, it very much is (but we wimp out on V3 cuz of the
	complexity of checking the Array):
	[0] = 253743		52.5%
	[1] = 116117		24%/76.5%
	[2] = 99876		20.7%/97.2%
	[3] = 12837		2.7%/99.9%
	[4] = 209
	[5] = 84
	[6] = 2
	[7] = 313
	[8] = 0
	[9] = 0
	[10] = 0
	[11] = 1
	[12] = 0
	[13] = 0
	[14] = 0
	[15] = 0 */

	/* StackToRegisterMappingCogit>>#genPrimitivePerformWithArguments */
static sqInt
genPrimitivePerformWithArguments(void)
{
    AbstractInstruction *anInstruction;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBadNumArgs1;
    AbstractInstruction *jumpBadNumArgs2;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpImmArray;
    AbstractInstruction *jumpInterpret;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;

	/* begin genLookupForPerformWithArguments */
	jumpImmArray = genJumpImmediate(Arg1Reg);
	genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, SendNumArgsReg, 0);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 0, cacheBaseReg);

	/* Fetch the method, and check if it is cogged. */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	offset = (cacheBaseReg == NoReg
				? (methodCacheAddress()) + ((((usqInt)(MethodCacheMethod) << (shiftForWord()))))
				: ((sqInt)((usqInt)(MethodCacheMethod) << (shiftForWord()))));

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	itsAHit = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(itsAHit)) {
		(itsAHit->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);

	/* check the argument count; if it's wrong fall back on the interpreter primitive. */
	jumpInterpret = genJumpImmediate(ClassReg);

	/* begin genLoadcmNumArgsOf:into: */
	anInstruction = genoperandoperandoperand(MoveMbrR, BytesPerWord, ClassReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
	}
	genGetRawSlotSizeOfNonImminto(Arg1Reg, TempReg);

	/* begin CmpR:R: */
	assert(!(0 /* (TempReg = SPReg) */));
	genoperandoperand(CmpRR, TempReg, SendNumArgsReg);
	jumpBadNumArgs1 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));

	/* begin CmpCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, numRegArgs(), SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(numRegArgs(), BytesPerOop));
	}

	/* Fetch arguments and jump to the method's unchecked entry-point. */
	jumpBadNumArgs2 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	genFetchRegArgsForPerformWithArguments(TempReg);

	/* begin AddCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(cmNoCheckEntryOffset, BytesPerOop));
	}

	/* JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 1, cacheBaseReg);

	/* JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 2, cacheBaseReg);

	/* JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpImmArray, jmpTarget(jumpSelectorMiss, jmpTarget(jumpInterpret, jmpTarget(jumpBadNumArgs1, jmpTarget(jumpBadNumArgs2, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genPushActiveContextBytecode */
static sqInt
genPushActiveContextBytecode(void)
{
	assert(needsFrame);
	voidReceiverResultRegContainsSelf();

	/* begin ssAllocateCallReg:and:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg)), simStackPtr, simNativeStackPtr);
	genGetActiveContextNumArgslargeinBlock(methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	return ssPushRegister(ReceiverResultReg);
}


/*	Block compilation. At this point in the method create the block. Note its
	start and defer generating code for it until after the method and any
	other preceding
	blocks. The block's actual code will be compiled later. */
/*	143 10001111 llllkkkk jjjjjjjj iiiiiiii	Push Closure Num Copied llll Num
	Args kkkk BlockSize jjjjjjjjiiiiiiii */

	/* StackToRegisterMappingCogit>>#genPushClosureCopyCopiedValuesBytecode */
static sqInt
genPushClosureCopyCopiedValuesBytecode(void)
{
    sqInt i;
    usqInt numArgs;
    sqInt numCopied;
    sqInt reg;
    sqInt startpc;

	assert(needsFrame);
	startpc = bytecodePC + (((generatorAt(byte0))->numBytes));
	addBlockStartAtnumArgsnumCopiedspan(startpc, (numArgs = byte1 & 15), (numCopied = ((usqInt)(byte1)) >> 4), ((((usqInt)(byte2) << 8))) + byte3);

	/* begin genInlineClosure:numArgs:numCopied: */
	assert(getActiveContextAllocatesInMachineCode());
	voidReceiverResultRegContainsSelf();

	/* begin ssAllocateCallReg:and:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg) | (1U << SendNumArgsReg)) | (1U << ClassReg)), simStackPtr, simNativeStackPtr);
	genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(startpc + 1, numArgs, numCopied, methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	for (i = 1; i <= numCopied; i += 1) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
		genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, (ClosureFirstCopiedValueIndex + numCopied) - i, ReceiverResultReg);
	}
	ssPushRegister(ReceiverResultReg);
	return 0;
}


/*	<SmallInteger> */
/*	Override to avoid the BytecodeSetHasDirectedSuperSend check, which is
	unnecessary here given the simulation stack. */

	/* StackToRegisterMappingCogit>>#genPushLiteralIndex: */
static NoDbgRegParms sqInt
genPushLiteralIndex(sqInt literalIndex)
{
    sqInt literal;

	literal = getLiteral(literalIndex);
	return ssPushConstant(literal);
}

	/* StackToRegisterMappingCogit>>#genPushLiteralVariable: */
static NoDbgRegParms sqInt
genPushLiteralVariable(sqInt literalIndex)
{
    AbstractInstruction *anInstruction;
    sqInt association;
    sqInt bcpc;
    BytecodeDescriptor *descriptor1;
    sqInt eA;
    sqInt eB;
    sqInt freeReg;
    sqInt savedB0;
    sqInt savedB1;
    sqInt savedB2;
    sqInt savedB3;
    sqInt savedEA;
    sqInt savedEB;
    sqInt savedNEB;

	/* If followed by a directed super send bytecode, avoid generating any code yet.
	   The association will be passed to the directed send trampoline in a register
	   and fully dereferenced only when first linked.  It will be ignored in later sends. */
	association = getLiteral(literalIndex);
	assert(!(directedSendUsesBinding));

	/* begin nextDescriptorExtensionsAndNextPCInto: */
	descriptor1 = generatorAt(byte0);
	savedB0 = byte0;
	savedB1 = byte1;
	savedB2 = byte2;
	savedB3 = byte3;
	savedEA = extA;
	savedEB = extB;
	savedNEB = numExtB;
	bcpc = bytecodePC + ((descriptor1->numBytes));
	do {
		if (bcpc > endPC) {
			goto l1;
		}
		byte0 = (fetchByteofObject(bcpc, methodObj)) + bytecodeSetOffset;
		descriptor1 = generatorAt(byte0);
		loadSubsequentBytesForDescriptorat(descriptor1, bcpc);
		if (!((descriptor1->isExtension))) {
			eA = extA;
			eB = extB;
			extA = savedEA;
			extB = savedEB;
			numExtB = savedNEB;
			byte0 = savedB0;
			byte1 = savedB1;
			byte2 = savedB2;
			byte3 = savedB3;
			if (/* isDirectedSuper:extA:extB: */
				(descriptor1)
			 && ((((descriptor1->generator)) == genExtSendSuperBytecode)
			 && (eB >= 64))) {
				ssPushConstant(association);
				directedSendUsesBinding = 1;
				return 0;
			}
			goto l1;
		}
		((descriptor1->generator))();
		bcpc += (descriptor1->numBytes);
	} while(1);
l1:	/* end nextDescriptorExtensionsAndNextPCInto: */;

	/* N.B. Do _not_ use ReceiverResultReg to avoid overwriting receiver in assignment in frameless methods. */
	/* So far descriptors are not rich enough to describe the entire dereference so generate the register
	   load but don't push the result.  There is an order-of-evaluation issue if we defer the dereference. */
	freeReg = allocateRegNotConflictingWith(0);

	/* begin genMoveConstant:R: */
	if (/* shouldAnnotateObjectReference: */
		(isNonImmediate(association))
	 && ((oopisGreaterThan(association, classTableRootObj()))
	 || (oopisLessThan(association, nilObject())))) {
		annotateobjRef(checkLiteralforInstruction(association, genoperandoperand(MoveCwR, association, TempReg)), association);
	}
	else {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, association, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(association, BytesPerOop));
		}
	}
	genLoadSlotsourceRegdestReg(ValueIndex, TempReg, freeReg);
	ssPushRegister(freeReg);
	return 0;
}

	/* StackToRegisterMappingCogit>>#genPushMaybeContextReceiverVariable: */
static NoDbgRegParms sqInt
genPushMaybeContextReceiverVariable(sqInt slotIndex)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmpDone;
    AbstractInstruction *jmpSingle;

	/* begin ssAllocateCallReg:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg)) | ((1U << SendNumArgsReg))), simStackPtr, simNativeStackPtr);
	ensureReceiverResultRegContainsSelf();

	/* begin genPushMaybeContextSlotIndex: */
	assert(needsFrame);
	if (((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)) {

		/* We have no way of reloading ReceiverResultReg since we need the inst var value as the result. */
		voidReceiverResultRegContainsSelf();
	}
	if (slotIndex == InstructionPointerIndex) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(slotIndex, BytesPerOop));
		}

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceFetchContextInstVarTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		return ssPushRegister(SendNumArgsReg);
	}
	genLoadSlotsourceRegdestReg(SenderIndex, ReceiverResultReg, TempReg);
	jmpSingle = genJumpNotSmallInteger(TempReg);

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(slotIndex, BytesPerOop));
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceFetchContextInstVarTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jmpSingle, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genLoadSlotsourceRegdestReg(slotIndex, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jmpDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return ssPushRegister(SendNumArgsReg);
}

	/* StackToRegisterMappingCogit>>#genPushNewArrayBytecode */
static sqInt
genPushNewArrayBytecode(void)
{
    sqInt i;
    sqInt iSqInt;
    int popValues;
    usqInt size;

	assert(needsFrame);
	voidReceiverResultRegContainsSelf();
	if ((popValues = byte1 > 0x7F)) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (iSqInt = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); iSqInt <= simStackPtr; iSqInt += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(iSqInt), frameOffsetOfTemporary(iSqInt - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
	}
	else {
		/* begin ssAllocateCallReg:and: */
		ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << SendNumArgsReg)) | ((1U << ReceiverResultReg))), simStackPtr, simNativeStackPtr);
	}
	size = byte1 & 0x7F;
	if (!popValues) {
		if (tryCollapseTempVectorInitializationOfSize(size)) {
			return 0;
		}
	}
	genNewArrayOfSizeinitialized(size, !popValues);
	if (popValues) {
		for (i = (size - 1); i >= 0; i += -1) {
			/* PopR: */
			genoperand(PopR, TempReg);
			genStoreSourceRegslotIndexintoNewObjectInDestReg(TempReg, i, ReceiverResultReg);
		}
		ssPop(size);
	}
	return ssPushRegister(ReceiverResultReg);
}

	/* StackToRegisterMappingCogit>>#genPushReceiverBytecode */
static sqInt
genPushReceiverBytecode(void)
{
	if ((((simSelf())->liveRegister)) == ReceiverResultReg) {
		return ssPushRegister(ReceiverResultReg);
	}
	return ssPushDesc(ssSelfDescriptor());
}

	/* StackToRegisterMappingCogit>>#genPushReceiverVariable: */
static NoDbgRegParms sqInt
genPushReceiverVariable(sqInt index)
{
	ensureReceiverResultRegContainsSelf();
	return ssPushBaseoffset(ReceiverResultReg, slotOffsetOfInstVarIndex(index));
}


/*	Ensure that the register args are pushed before the retpc for methods with
	arity <= self numRegArgs.
 */
/*	This isn't as clumsy on a RISC. But putting the receiver and
	args above the return address means the CoInterpreter has a
	single machine-code frame format which saves us a lot of work. */

	/* StackToRegisterMappingCogit>>#genPushRegisterArgs */
static void
genPushRegisterArgs(void)
{
	if (!(regArgsHaveBeenPushed
		 || (methodOrBlockNumArgs > (numRegArgs())))) {
		genPushRegisterArgsForNumArgsscratchReg(backEnd, methodOrBlockNumArgs, SendNumArgsReg);
		regArgsHaveBeenPushed = 1;
	}
}

	/* StackToRegisterMappingCogit>>#genPushRemoteTempLongBytecode */
static sqInt
genPushRemoteTempLongBytecode(void)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt remoteTempReg;
    sqInt tempVectReg;

	tempVectReg = allocateRegNotConflictingWith(0);
	offset = frameOffsetOfTemporary(byte2);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, tempVectReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	remoteTempReg = availableRegisterOrNoneFor(backEnd, (liveRegisters()) | (((tempVectReg < 0) ? (((usqInt)(1)) >> (-tempVectReg)) : (1ULL << tempVectReg))));
	if (remoteTempReg == NoReg) {
		remoteTempReg = tempVectReg;
	}
	genLoadSlotsourceRegdestReg(byte1, tempVectReg, remoteTempReg);
	return ssPushRegister(remoteTempReg);
}


/*	If a frameless method (not a block), only argument temps can be accessed.
	This is assured by the use of needsFrameIfMod16GENumArgs: in pushTemp. */

	/* StackToRegisterMappingCogit>>#genPushTemporaryVariable: */
static NoDbgRegParms sqInt
genPushTemporaryVariable(sqInt index)
{
	assert((inBlock > 0)
	 || (needsFrame
	 || (index < methodOrBlockNumArgs)));
	return ssPushDesc(simStack[index + 1]);
}


/*	In a frameless method ReceiverResultReg already contains self.
	In a frameful method, ReceiverResultReg /may/ contain self. */

	/* StackToRegisterMappingCogit>>#genReturnReceiver */
static sqInt
genReturnReceiver(void)
{
	if (needsFrame) {
		if (!((((simSelf())->liveRegister)) == ReceiverResultReg)) {
			/* begin putSelfInReceiverResultReg */
			storeToReg(simSelf(), ReceiverResultReg);
		}
	}
	return genUpArrowReturn();
}

	/* StackToRegisterMappingCogit>>#genReturnTopFromBlock */
static sqInt
genReturnTopFromBlock(void)
{
	assert(inBlock > 0);
	popToReg(ssTop(), ReceiverResultReg);
	ssPop(1);
	return genBlockReturn();
}

	/* StackToRegisterMappingCogit>>#genReturnTopFromMethod */
static sqInt
genReturnTopFromMethod(void)
{
	popToReg(ssTop(), ReceiverResultReg);
	ssPop(1);
	return genUpArrowReturn();
}

	/* StackToRegisterMappingCogit>>#genSendDirectedSuper:numArgs: */
static NoDbgRegParms sqInt
genSendDirectedSupernumArgs(sqInt selectorIndex, sqInt numArgs)
{
    sqInt result;

	assert((((ssTop())->type)) == SSConstant);
	tempOop = ((ssTop())->constant);
	ssPop(1);
	marshallSendArguments(numArgs);
	result = genMarshalledSendnumArgssendTable(selectorIndex, numArgs, (directedSendUsesBinding
				? directedSuperBindingSendTrampolines
				: directedSuperSendTrampolines));
	directedSendUsesBinding = 0;
	return result;
}

	/* StackToRegisterMappingCogit>>#genSendSuper:numArgs: */
static NoDbgRegParms sqInt
genSendSupernumArgs(sqInt selectorIndex, sqInt numArgs)
{
	marshallSendArguments(numArgs);
	return genMarshalledSendnumArgssendTable(selectorIndex, numArgs, superSendTrampolines);
}


/*	Generate a trampoline with four arguments.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* StackToRegisterMappingCogit>>#genSendTrampolineFor:numArgs:called:arg:arg:arg:arg: */
static NoDbgRegParms usqInt
genSendTrampolineFornumArgscalledargargargarg(void *aRoutine, sqInt numArgs, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3)
{
    sqInt routine;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	routine = ceDereferenceSelectorIndex;
	if (routine) {

		/* Explicitly save LinkReg via ExtraReg2; it's presumably faster than pushing/popping */
		/* MoveR:R: */
		genoperandoperand(MoveRR, LinkReg, Extra2Reg);

		/* Call: */
		genoperand(Call, routine);

		/* MoveR:R: */
		genoperandoperand(MoveRR, Extra2Reg, LinkReg);
	}
	genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 4, regOrConst0, regOrConst1, regOrConst2, regOrConst3, 0 /* emptyRegisterMask */, 1, NoReg, 1);
	return startAddress;
}

	/* StackToRegisterMappingCogit>>#genSend:numArgs: */
static NoDbgRegParms sqInt
genSendnumArgs(sqInt selectorIndex, sqInt numArgs)
{
	marshallSendArguments(numArgs);
	return genMarshalledSendnumArgssendTable(selectorIndex, numArgs, ordinarySendTrampolines);
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorArithmetic */
static sqInt
genSpecialSelectorArithmetic(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt argInt;
    int argIsConst;
    sqInt argIsInt;
    sqInt i;
    sqInt index;
    AbstractInstruction *jumpContinue;
    AbstractInstruction *jumpNotSmallInts;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrInt;
    int rcvrIsConst;
    sqInt rcvrIsInt;
    sqInt result;

	primDescriptor = generatorAt(byte0);
	argIsInt = ((argIsConst = (((ssTop())->type)) == SSConstant))
		 && ((((((argInt = ((ssTop())->constant)))) & 7) == 1));
	rcvrIsInt = (((rcvrIsConst = (((ssValue(1))->type)) == SSConstant))
		 && ((((((rcvrInt = ((ssValue(1))->constant)))) & 7) == 1)))
		 || ((mclassIsSmallInteger())
		 && (isSameEntryAs(ssValue(1), simSelf())));
	if (argIsInt
	 && (rcvrIsInt
	 && (rcvrIsConst))) {
		rcvrInt = (rcvrInt >> 3);
		argInt = (argInt >> 3);
		switch ((primDescriptor->opcode)) {
		case AddRR:
			result = rcvrInt + argInt;
			break;
		case SubRR:
			result = rcvrInt - argInt;
			break;
		case AndRR:
			result = rcvrInt & argInt;
			break;
		case OrRR:
			result = rcvrInt | argInt;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		if (isIntegerValue(result)) {

			/* Must annotate the bytecode for correct pc mapping. */
			ssPop(2);
			return ssPushAnnotatedConstant((((usqInt)result << 3) | 1));
		}
		return genSpecialSelectorSend();
	}
	if ((rcvrIsConst
	 && (!rcvrIsInt))
	 || (argIsConst
	 && (!argIsInt))) {
		return genSpecialSelectorSend();
	}
	if (!(argIsInt
		 || (rcvrIsInt))) {
		return genSpecialSelectorSend();
	}
	if (argIsInt) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= (simStackPtr - 2)) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 2)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 2))); i <= (simStackPtr - 2); i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = (simStackPtr - 2) + 1;
		}
		popToReg(ssValue(1), ReceiverResultReg);
		ssPop(2);
	}
	else {
		marshallSendArguments(1);
	}
	jumpNotSmallInts = (!(rcvrIsInt
 && (argIsInt))
				? (argIsInt
						? genJumpNotSmallInteger(ReceiverResultReg)
						: (rcvrIsInt
								? genJumpNotSmallInteger(Arg0Reg)
								: genJumpNotSmallIntegersInandscratch(ReceiverResultReg, Arg0Reg, TempReg)))
				: 0);
	switch ((primDescriptor->opcode)) {
	case AddRR:
		if (argIsInt) {
			/* begin AddCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(AddCqR, argInt - ConstZero, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(argInt - ConstZero, BytesPerOop));
			}

			/* overflow; must undo the damage before continuing */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));

			/* begin SubCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(SubCqR, argInt - ConstZero, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(argInt - ConstZero, BytesPerOop));
			}
		}
		else {
			genRemoveSmallIntegerTagsInScratchReg(ReceiverResultReg);

			/* AddR:R: */
			genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);

			/* overflow; must undo the damage before continuing */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			if (rcvrIsInt
			 && (rcvrIsConst)) {
				/* begin MoveCq:R: */
				/* begin gen:quickConstant:operand: */
				anInstruction = genoperandoperand(MoveCqR, rcvrInt, ReceiverResultReg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteralsize(rcvrInt, BytesPerOop));
				}
			}
			else {
				/* SubR:R: */
				genoperandoperand(SubRR, Arg0Reg, ReceiverResultReg);
				genSetSmallIntegerTagsIn(ReceiverResultReg);
			}
		}
		break;
	case SubRR:
		if (argIsInt) {
			/* begin SubCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(SubCqR, argInt - ConstZero, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(argInt - ConstZero, BytesPerOop));
			}

			/* overflow; must undo the damage before continuing */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));

			/* begin AddCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(AddCqR, argInt - ConstZero, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(argInt - ConstZero, BytesPerOop));
			}
		}
		else {
			genRemoveSmallIntegerTagsInScratchReg(Arg0Reg);

			/* SubR:R: */
			genoperandoperand(SubRR, Arg0Reg, ReceiverResultReg);

			/* overflow; must undo the damage before continuing */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));

			/* AddR:R: */
			genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
			genSetSmallIntegerTagsIn(Arg0Reg);
		}
		break;
	case AndRR:
		if (argIsInt) {
			/* begin AndCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(AndCqR, argInt, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(argInt, BytesPerOop));
			}
		}
		else {
			/* AndR:R: */
			genoperandoperand(AndRR, Arg0Reg, ReceiverResultReg);
		}
		jumpContinue = (jumpNotSmallInts
					? genoperand(Jump, ((sqInt)0))
					: 0);
		break;
	case OrRR:
		if (argIsInt) {
			/* begin OrCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(OrCqR, argInt, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(argInt, BytesPerOop));
			}
		}
		else {
			/* OrR:R: */
			genoperandoperand(OrRR, Arg0Reg, ReceiverResultReg);
		}
		jumpContinue = (jumpNotSmallInts
					? genoperand(Jump, ((sqInt)0))
					: 0);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	if (jumpNotSmallInts) {
		jmpTarget(jumpNotSmallInts, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	else {
		if (!jumpContinue) {

			/* overflow cannot happen */
			/* begin annotateInstructionForBytecode */
			abstractInstruction = (prevInstIsPCAnnotated()
						? gen(Nop)
						: genoperandoperand(Label, (labelCounter += 1), bytecodePC));

			/* begin annotateBytecode: */
			(abstractInstruction->annotation = HasBytecodePC);
			ssPushRegister(ReceiverResultReg);
			return 0;
		}
	}
	if (argIsInt) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, argInt, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(argInt, BytesPerOop));
		}
	}
	index = byte0 - (/* begin firstSpecialSelectorBytecodeOffset */
	(bytecodeSetOffset == 0x100
		? AltFirstSpecialSelector + 0x100
		: FirstSpecialSelector));
	genMarshalledSendnumArgssendTable((-index) - 1, 1, ordinarySendTrampolines);
	jmpTarget(jumpContinue, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorClass */
static sqInt
genSpecialSelectorClass(void)
{
    sqInt requiredReg1;
    sqInt topReg;

	topReg = registerOrNone(ssTop());
	ssPop(1);
	if ((topReg == NoReg)
	 || (topReg == ClassReg)) {
		requiredReg1 = (topReg = SendNumArgsReg);

		/* begin ssAllocateRequiredReg:and: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((((requiredReg1 < 0) ? (((usqInt)(1)) >> (-requiredReg1)) : (1ULL << requiredReg1))) | ((1U << ClassReg)), simStackPtr, simNativeStackPtr);
	}
	else {
		/* begin ssAllocateRequiredReg: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr, simNativeStackPtr);
	}
	ssPush(1);
	popToReg(ssTop(), topReg);
	genGetClassObjectOfintoscratchRegmayBeAForwarder(topReg, ClassReg, TempReg, mayBeAForwarder(ssTop()));
	ssPop(1);
	return ssPushRegister(ClassReg);
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorComparison */
static sqInt
genSpecialSelectorComparison(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt argInt;
    sqInt argIsIntConst;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt i;
    sqInt index;
    sqInt inlineCAB;
    AbstractInstruction *jumpNotSmallInts;
    void *jumpTarget;
    sqInt nExts;
    sqInt nextPC;
    sqInt nextPCSqInt;
    sqInt postBranchPC;
    sqInt postBranchPCSqInt;
    BytecodeDescriptor *primDescriptor;
    BytecodeDescriptor *primDescriptor1;
    int rcvrIsConst;
    sqInt rcvrIsInt;
    sqInt targetBytecodePC;
    sqInt targetPC;

	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= (simStackPtr - 2)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 2)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 2))); i <= (simStackPtr - 2); i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = (simStackPtr - 2) + 1;
	}
	primDescriptor = generatorAt(byte0);
	argIsIntConst = ((((ssTop())->type)) == SSConstant)
		 && ((((((argInt = ((ssTop())->constant)))) & 7) == 1));
	rcvrIsInt = (((rcvrIsConst = (((ssValue(1))->type)) == SSConstant))
		 && (((((((ssValue(1))->constant))) & 7) == 1)))
		 || ((mclassIsSmallInteger())
		 && (isSameEntryAs(ssValue(1), simSelf())));
	if (argIsIntConst
	 && (rcvrIsInt
	 && (rcvrIsConst))) {
		return genStaticallyResolvedSpecialSelectorComparison();
	}

	/* begin extractMaybeBranchDescriptorInto: */
	branchDescriptor1 = ((BytecodeDescriptor *) 0);
	primDescriptor1 = generatorAt(byte0);
	nextPCSqInt = bytecodePC + ((primDescriptor1->numBytes));
	nExts = 0;
	while (1) {
		while (1) {
			/* begin generatorForPC: */
			branchDescriptor1 = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPCSqInt, methodObj)));
			if (!((branchDescriptor1->isExtension))) break;
			nExts += 1;
			nextPCSqInt += (branchDescriptor1->numBytes);
		}
		if (!(/* isUnconditionalBranch */
			(isBranch(branchDescriptor1))
		 && (!(((branchDescriptor1->isBranchTrue))
		 || ((branchDescriptor1->isBranchFalse)))))) break;
		nextPCSqInt = eventualTargetOf((nextPCSqInt + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPCSqInt, nExts, methodObj)));
	}
	targetBytecodePC = (postBranchPCSqInt = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC = eventualTargetOf((nextPCSqInt + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPCSqInt, nExts, methodObj)));
		postBranchPCSqInt = eventualTargetOf(nextPCSqInt + ((branchDescriptor1->numBytes)));
	}
	else {
		nextPCSqInt = bytecodePC + ((primDescriptor1->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPCSqInt;
	postBranchPC = postBranchPCSqInt;
	targetPC = targetBytecodePC;

	/* Further, only interested in inlining = and ~= if there's a SmallInteger constant involved.
	   The relational operators successfully statically predict SmallIntegers; the equality operators do not. */
	inlineCAB = ((branchDescriptor->isBranchTrue))
		 || ((branchDescriptor->isBranchFalse));
	if (inlineCAB
	 && ((((primDescriptor->opcode)) == JumpZero)
	 || (((primDescriptor->opcode)) == JumpNonZero))) {
		inlineCAB = argIsIntConst
			 || (rcvrIsInt);
	}
	if (!inlineCAB) {
		return genSpecialSelectorSend();
	}
	if (argIsIntConst) {
		popToReg(ssValue(1), ReceiverResultReg);
		ssPop(2);
	}
	else {
		marshallSendArguments(1);
	}
	jumpNotSmallInts = (!(rcvrIsInt
 && (argIsIntConst))
				? (argIsIntConst
						? genJumpNotSmallInteger(ReceiverResultReg)
						: (rcvrIsInt
								? genJumpNotSmallInteger(Arg0Reg)
								: genJumpNotSmallIntegersInandscratch(ReceiverResultReg, Arg0Reg, TempReg)))
				: 0);
	if (argIsIntConst) {
		/* begin CmpCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, argInt, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(argInt, BytesPerOop));
		}
	}
	else {
		/* begin CmpR:R: */
		assert(!(0 /* (Arg0Reg = SPReg) */));
		genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	}
	genConditionalBranchoperand(((branchDescriptor->isBranchTrue)
			? (primDescriptor->opcode)
			: inverseBranchFor((primDescriptor->opcode))), ((usqInt)(ensureNonMergeFixupAt(targetPC))));
	jumpTarget = ensureNonMergeFixupAt(postBranchPC);

	/* begin Jump: */
	genoperand(Jump, ((sqInt)jumpTarget));
	if (!jumpNotSmallInts) {
		/* begin annotateInstructionForBytecode */
		abstractInstruction = (prevInstIsPCAnnotated()
					? gen(Nop)
					: genoperandoperand(Label, (labelCounter += 1), bytecodePC));

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		ensureFixupAt(postBranchPC);
		ensureFixupAt(targetPC);
		deadCode = 1;
		return 0;
	}
	jmpTarget(jumpNotSmallInts, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (argIsIntConst) {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, argInt, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(argInt, BytesPerOop));
		}
	}
	index = byte0 - (/* begin firstSpecialSelectorBytecodeOffset */
	(bytecodeSetOffset == 0x100
		? AltFirstSpecialSelector + 0x100
		: FirstSpecialSelector));
	return genMarshalledSendnumArgssendTable((-index) - 1, 1, ordinarySendTrampolines);
}


/*	Assumes both operands are ints */

	/* StackToRegisterMappingCogit>>#genStaticallyResolvedSpecialSelectorComparison */
static sqInt
genStaticallyResolvedSpecialSelectorComparison(void)
{
    sqInt argInt;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrInt;
    int result;

	primDescriptor = generatorAt(byte0);
	argInt = ((ssTop())->constant);
	rcvrInt = ((ssValue(1))->constant);
	switch ((primDescriptor->opcode)) {
	case JumpLess:
		result = rcvrInt < argInt;
		break;
	case JumpLessOrEqual:
		result = rcvrInt <= argInt;
		break;
	case JumpGreater:
		result = rcvrInt > argInt;
		break;
	case JumpGreaterOrEqual:
		result = rcvrInt >= argInt;
		break;
	case JumpZero:
		result = rcvrInt == argInt;
		break;
	case JumpNonZero:
		result = rcvrInt != argInt;
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	ssPop(2);
	return ssPushAnnotatedConstant((result
			? trueObject()
			: falseObject()));
}


/*	We need a frame because the association has to be in ReceiverResultReg for
	the various trampolines
	and ReceiverResultReg holds only the receiver in frameless methods.
 */

	/* StackToRegisterMappingCogit>>#genStorePop:LiteralVariable:needsStoreCheck:needsImmutabilityCheck: */
static NoDbgRegParms sqInt
genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt litVarIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    AbstractInstruction *anInstruction;
    sqInt association;
    sqInt i;
    sqInt topReg;

	assert(needsFrame);

	/* begin genLoadLiteralVariable:in: */
	association = getLiteral(litVarIndex);
	voidReceiverResultRegContainsSelf();

	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
	if (/* shouldAnnotateObjectReference: */
		(isNonImmediate(association))
	 && ((oopisGreaterThan(association, classTableRootObj()))
	 || (oopisLessThan(association, nilObject())))) {
		annotateobjRef(checkLiteralforInstruction(association, genoperandoperand(MoveCwR, association, ReceiverResultReg)), association);
	}
	else {
		/* begin MoveCq:R: */
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, association, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteralsize(association, BytesPerOop));
		}
	}

	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
#  if IMMUTABILITY
	if (needsImmCheck) {
		/* begin ssAllocateRequiredReg:upThrough: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr - 1, simNativeStackPtr);
		ssStoreAndReplacePoptoReg(popBoolean, ClassReg);

		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		return genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(ClassReg, ValueIndex, ReceiverResultReg, TempReg, needsStoreCheck, 0);
	}
#  endif // IMMUTABILITY

	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, ValueIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheck);
}


/*	The reason we need a frame here is that assigning to an inst var of a
	context may
	involve wholesale reorganization of stack pages, and the only way to
	preserve the
	execution state of an activation in that case is if it has a frame. */

	/* StackToRegisterMappingCogit>>#genStorePop:MaybeContextReceiverVariable:needsStoreCheck:needsImmutabilityCheck: */
static NoDbgRegParms sqInt
genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt i;
    AbstractInstruction *immutabilityFailure;
    AbstractInstruction *mutableJump;

	assert(needsFrame);
	ssFlushUpThroughReceiverVariable(slotIndex);
	ensureReceiverResultRegContainsSelf();

	/* begin genGenericStorePop:MaybeContextSlotIndex:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
	immutabilityFailure = ((AbstractInstruction *) 0);
	assert(needsFrame);
#  if IMMUTABILITY
	if (needsImmCheck) {
		mutableJump = genJumpMutablescratchReg(ReceiverResultReg, TempReg);

		/* begin genStoreTrampolineCall: */
		assert(IMMUTABILITY);
		if (slotIndex >= (NumStoreTrampolines - 1)) {
			/* begin MoveCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(MoveCqR, slotIndex, TempReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(slotIndex, BytesPerOop));
			}

			/* begin CallRT: */
			abstractInstruction = genoperand(Call, ceStoreTrampolines[NumStoreTrampolines - 1]);
			(abstractInstruction->annotation = IsRelativeCall);
		}
		else {
			/* begin CallRT: */
			abstractInstruction = genoperand(Call, ceStoreTrampolines[slotIndex]);
			(abstractInstruction->annotation = IsRelativeCall);
		}
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);

		/* begin putSelfInReceiverResultReg */
		storeToReg(simSelf(), ReceiverResultReg);
		immutabilityFailure = genoperand(Jump, ((sqInt)0));
		jmpTarget(mutableJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
#  endif // IMMUTABILITY

	ssPop(1);

	/* begin ssAllocateCallReg:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ClassReg)) | ((1U << SendNumArgsReg))), simStackPtr, simNativeStackPtr);
	ssPush(1);
	genLoadSlotsourceRegdestReg(SenderIndex, ReceiverResultReg, TempReg);
	ssStoreAndReplacePoptoReg(popBoolean, ClassReg);

	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= simStackPtr) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = simStackPtr + 1;
	}

	/* begin MoveCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(slotIndex, BytesPerOop));
	}

	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceStoreContextInstVarTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
#  if IMMUTABILITY
	if (needsImmCheck) {
		jmpTarget(immutabilityFailure, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
#  endif

	return 0;
}

	/* StackToRegisterMappingCogit>>#genStorePop:ReceiverVariable:needsStoreCheck:needsImmutabilityCheck: */
static NoDbgRegParms sqInt
genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    sqInt i;
    sqInt needsImmCheckSqInt;
    sqInt needsStoreCheckSqInt;
    sqInt topReg;

	ssFlushUpThroughReceiverVariable(slotIndex);
	ensureReceiverResultRegContainsSelf();
	needsStoreCheckSqInt = (!useTwoPaths)
		 && (needsStoreCheck);
	needsImmCheckSqInt = needsImmCheck
		 && (!useTwoPaths);

	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
#  if IMMUTABILITY
	if (needsImmCheckSqInt) {
		/* begin ssAllocateRequiredReg:upThrough: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr - 1, simNativeStackPtr);
		ssStoreAndReplacePoptoReg(popBoolean, ClassReg);

		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		return genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(ClassReg, slotIndex, ReceiverResultReg, TempReg, needsStoreCheckSqInt, 1);
	}
#  endif // IMMUTABILITY

	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, slotIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheckSqInt);
}


/*	The only reason we assert needsFrame here is that in a frameless method
	ReceiverResultReg must and does contain only self, but the ceStoreCheck
	trampoline expects the target of the store to be in ReceiverResultReg. So
	in a frameless method we would have a conflict between the receiver and
	the temote temp store, unless we we smart enough to realise that
	ReceiverResultReg was unused after the literal variable store, unlikely
	given that methods return self by default. */

	/* StackToRegisterMappingCogit>>#genStorePop:RemoteTemp:At:needsStoreCheck: */
static NoDbgRegParms sqInt
genStorePopRemoteTempAtneedsStoreCheck(sqInt popBoolean, sqInt slotIndex, sqInt remoteTempIndex, sqInt needsStoreCheck)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt topReg;

	assert(needsFrame);

	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
	voidReceiverResultRegContainsSelf();
	offset = frameOffsetOfTemporary(remoteTempIndex);

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
#  if IMMUTABILITY
#  endif

	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, slotIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheck);
}

	/* StackToRegisterMappingCogit>>#genStorePop:TemporaryVariable: */
static NoDbgRegParms sqInt
genStorePopTemporaryVariable(sqInt popBoolean, sqInt tempIndex)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt reg;

	ssFlushUpThroughTemporaryVariable(tempIndex);
	reg = ssStorePoptoPreferredReg(popBoolean, TempReg);
	offset = frameOffsetOfTemporary(tempIndex);

	/* begin MoveR:Mw:r: */
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, reg, offset, FPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}
	((simStackAt(tempIndex + 1))->bcptr = bytecodePC);
	return 0;
}


/*	Generate a method return from within a method or a block.
	Frameless method activation looks like
	CISCs (x86):
	receiver
	args
	sp->	ret pc.
	RISCs (ARM):
	receiver
	args
	ret pc in LR.
	A fully framed activation is described in CoInterpreter
	class>initializeFrameIndices. Return pops receiver and arguments off the
	stack. Callee pushes the result. */

	/* StackToRegisterMappingCogit>>#genUpArrowReturn */
static sqInt
genUpArrowReturn(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt offset;

	/* can't fall through */
	deadCode = 1;
	if (inBlock > 0) {
		assert(needsFrame);

		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}

		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceNonLocalReturnTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		return 0;
	}
	if (
#  if IMMUTABILITY
		needsFrame
			 && (!useTwoPaths)
#  else
		needsFrame
#  endif
		) {
		if (hasNativeFrame) {
			leaveNativeFrame();
		}

		/* MoveR:R: */
		genoperandoperand(MoveRR, FPReg, SPReg);

		/* PopR: */
		genoperand(PopR, FPReg);

		/* PopR: */
		genoperand(PopR, LinkReg);

		/* RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	else {
		offset = ((methodOrBlockNumArgs > (numRegArgs()))
			 || (regArgsHaveBeenPushed)
					? (methodOrBlockNumArgs + 1) * BytesPerWord
					: 0);

		/* begin RetN: */
		genoperand(RetN, offset);
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#genVanillaInlinedIdenticalOrNotIf: */
static NoDbgRegParms sqInt
genVanillaInlinedIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *anInstruction;
    int argIsConstant;
    sqInt argNeedsReg;
    sqInt argReg;
    sqInt argRegSqInt;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt constant;
    sqInt i;
    void *jumpTarget;
    sqInt nExts;
    sqInt nextPC;
    sqInt nextPCSqInt;
    sqInt postBranchPC;
    sqInt postBranchPCSqInt;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrIsConstant;
    sqInt rcvrNeedsReg;
    sqInt rcvrReg;
    sqInt rcvrRegSqInt;
    sqInt reg;
    sqInt rNextSqInt;
    sqInt rTopSqInt;
    BytecodeFixup *self_in_CogBytecodeFixup;
    sqInt targetBytecodePC;
    sqInt targetPC;
    sqInt topRegistersMask;

	/* begin extractMaybeBranchDescriptorInto: */
	branchDescriptor1 = ((BytecodeDescriptor *) 0);
	primDescriptor = generatorAt(byte0);
	nextPCSqInt = bytecodePC + ((primDescriptor->numBytes));
	nExts = 0;
	while (1) {
		while (1) {
			/* begin generatorForPC: */
			branchDescriptor1 = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPCSqInt, methodObj)));
			if (!((branchDescriptor1->isExtension))) break;
			nExts += 1;
			nextPCSqInt += (branchDescriptor1->numBytes);
		}
		if (!(/* isUnconditionalBranch */
			(isBranch(branchDescriptor1))
		 && (!(((branchDescriptor1->isBranchTrue))
		 || ((branchDescriptor1->isBranchFalse)))))) break;
		nextPCSqInt = eventualTargetOf((nextPCSqInt + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPCSqInt, nExts, methodObj)));
	}
	targetBytecodePC = (postBranchPCSqInt = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC = eventualTargetOf((nextPCSqInt + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPCSqInt, nExts, methodObj)));
		postBranchPCSqInt = eventualTargetOf(nextPCSqInt + ((branchDescriptor1->numBytes)));
	}
	else {
		nextPCSqInt = bytecodePC + ((primDescriptor->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPCSqInt;
	postBranchPC = postBranchPCSqInt;
	targetPC = targetBytecodePC;

	/* They can't be both constants to use correct machine opcodes.
	   However annotable constants can't be resolved statically, hence we need to careful. */
	argIsConstant = (((ssTop())->type)) == SSConstant;
	rcvrIsConstant = (!argIsConstant)
		 && ((((ssValue(1))->type)) == SSConstant);
	argNeedsReg = !argIsConstant;
	rcvrNeedsReg = !rcvrIsConstant;

	/* begin allocateEqualsEqualsRegistersArgNeedsReg:rcvrNeedsReg:into: */
	assert(argNeedsReg
	 || (rcvrNeedsReg));
	argRegSqInt = (rcvrRegSqInt = NoReg);
	if (argNeedsReg) {
		if (rcvrNeedsReg) {
			/* begin allocateRegForStackTopTwoEntriesInto: */
			topRegistersMask = 0;
			rTopSqInt = (rNextSqInt = NoReg);
			if ((registerOrNone(ssTop())) != NoReg) {
				rTopSqInt = registerOrNone(ssTop());
			}
			if ((registerOrNone(ssValue(1))) != NoReg) {
				reg = (rNextSqInt = registerOrNone(ssValue(1)));

				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1ULL << reg));
			}
			if (rTopSqInt == NoReg) {
				rTopSqInt = allocateRegNotConflictingWith(topRegistersMask);
			}
			if (rNextSqInt == NoReg) {
				rNextSqInt = allocateRegNotConflictingWith(((rTopSqInt < 0) ? (((usqInt)(1)) >> (-rTopSqInt)) : (1ULL << rTopSqInt)));
			}
			assert(!(((rTopSqInt == NoReg)
 || (rNextSqInt == NoReg))));
			argRegSqInt = rTopSqInt;
			rcvrRegSqInt = rNextSqInt;
			popToReg(ssTop(), argRegSqInt);
			popToReg(ssValue(1), rcvrRegSqInt);
		}
		else {
			argRegSqInt = allocateRegForStackEntryAtnotConflictingWith(0, 0);
			popToReg(ssTop(), argRegSqInt);
			if (((ssValue(1))->spilled)) {
				/* begin AddCq:R: */
				/* begin gen:quickConstant:operand: */
				anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteralsize(BytesPerWord, BytesPerOop));
				}
			}
		}
	}
	else {
		assert(rcvrNeedsReg);
		assert(!((((ssTop())->spilled))));
		rcvrRegSqInt = allocateRegForStackEntryAtnotConflictingWith(1, 0);
		popToReg(ssValue(1), rcvrRegSqInt);
	}
	assert(!((argNeedsReg
 && (argRegSqInt == NoReg))));
	assert(!((rcvrNeedsReg
 && (rcvrRegSqInt == NoReg))));
	rcvrReg = rcvrRegSqInt;
	argReg = argRegSqInt;
	if (!(((branchDescriptor->isBranchTrue))
		 || ((branchDescriptor->isBranchFalse)))) {
		return genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(argIsConstant, rcvrIsConstant, argReg, rcvrReg, orNot);
	}

	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= (simStackPtr - 2)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 2)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 2))); i <= (simStackPtr - 2); i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = (simStackPtr - 2) + 1;
	}

	/* begin genCmpArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	assert((argReg != NoReg)
	 || (rcvrReg != NoReg));
	if (argIsConstant) {
		constant = ((ssTop())->constant);

		/* begin genCmpConstant:R: */
		if (/* shouldAnnotateObjectReference: */
			(isNonImmediate(constant))
		 && ((oopisGreaterThan(constant, classTableRootObj()))
		 || (oopisLessThan(constant, nilObject())))) {
			annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, rcvrReg)), constant);
		}
		else {
			/* begin CmpCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(CmpCqR, constant, rcvrReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
			}
		}
	}
	else {
		if (rcvrIsConstant) {
			constant = ((ssValue(1))->constant);

			/* begin genCmpConstant:R: */
			if (/* shouldAnnotateObjectReference: */
				(isNonImmediate(constant))
			 && ((oopisGreaterThan(constant, classTableRootObj()))
			 || (oopisLessThan(constant, nilObject())))) {
				annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(CmpCwR, constant, argReg)), constant);
			}
			else {
				/* begin CmpCq:R: */
				/* begin gen:quickConstant:operand: */
				anInstruction = genoperandoperand(CmpCqR, constant, argReg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteralsize(constant, BytesPerOop));
				}
			}
		}
		else {
			/* begin CmpR:R: */
			assert(!((argReg == SPReg)));
			genoperandoperand(CmpRR, argReg, rcvrReg);
		}
	}
	ssPop(2);

	/* begin fixupAt: */
	self_in_CogBytecodeFixup = fixupAtIndex(nextPC - initialPC);
	if ((self_in_CogBytecodeFixup->targetInstruction)) {
		assert(!(deadCode));
	}
	else {

		/* The next instruction is dead.  we can skip it. */
		deadCode = 1;
		ensureFixupAt(targetPC);
		ensureFixupAt(postBranchPC);
	}
	if (orNot == ((branchDescriptor->isBranchTrue))) {

		/* a == b ifFalse: ... or a ~~ b ifTrue: ... jump on equal to post-branch pc */
		ensureNonMergeFixupAt(targetPC);
		jumpTarget = ensureNonMergeFixupAt(postBranchPC);

		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
		jumpTarget = ensureNonMergeFixupAt(targetPC);

		/* begin Jump: */
		genoperand(Jump, ((sqInt)jumpTarget));
	}
	else {

		/* orNot is true for ~~ */
		/* a == b ifTrue: ... or a ~~ b ifFalse: ... jump on equal to target pc */
		jumpTarget = ensureNonMergeFixupAt(targetPC);

		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
		jumpTarget = ensureNonMergeFixupAt(postBranchPC);

		/* begin Jump: */
		genoperand(Jump, ((sqInt)jumpTarget));
	}
	if (!deadCode) {
		ssPushConstant(trueObject());
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#initSimStackForFramefulMethod: */
static NoDbgRegParms void
initSimStackForFramefulMethod(sqInt startpc)
{
    CogSimStackEntry *cascade0;
    CogSimStackEntry *desc;
    sqInt i;

	/* N.B. Includes num args */
	simStackPtr = methodOrBlockNumTemps;
	simSpillBase = methodOrBlockNumTemps + 1;
	simNativeSpillBase = (simNativeStackPtr = -1);
	simNativeStackSize = 0;
	cascade0 = simSelf();
	(cascade0->type = SSBaseOffset);
	(cascade0->spilled = 1);
	(cascade0->registerr = FPReg);
	(cascade0->offset = FoxMFReceiver);
	(cascade0->liveRegister = NoReg);
	for (i = 1; i <= methodOrBlockNumArgs; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = FPReg);
		(desc->offset = FoxCallerSavedIP + (((methodOrBlockNumArgs - i) + 1) * BytesPerWord));
		(desc->bcptr = startpc);
	}
	for (i = (methodOrBlockNumArgs + 1); i <= simStackPtr; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = FPReg);
		(desc->offset = FoxMFReceiver - ((i - methodOrBlockNumArgs) * BytesPerWord));
		(desc->bcptr = startpc);
	}
}


/*	The register receiver (the closure itself) and args are pushed by the
	closure value primitive(s)
	and hence a frameless block has all arguments and copied values pushed to
	the stack. However,
	the method receiver (self) is put in the ReceiverResultReg by the block
	entry. 
 */

	/* StackToRegisterMappingCogit>>#initSimStackForFramelessBlock: */
static NoDbgRegParms void
initSimStackForFramelessBlock(sqInt startpc)
{
    CogSimStackEntry *cascade0;
    CogSimStackEntry *desc;
    sqInt i;

	cascade0 = simSelf();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = ReceiverResultReg);
	(cascade0->liveRegister = ReceiverResultReg);
	assert(methodOrBlockNumTemps >= methodOrBlockNumArgs);
	for (i = 1; i <= methodOrBlockNumTemps; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = SPReg);
		(desc->offset = (methodOrBlockNumArgs - i) * BytesPerWord);
		(desc->bcptr = startpc);
	}

	/* N.B. Includes num args */
	simStackPtr = methodOrBlockNumTemps;
	simSpillBase = methodOrBlockNumTemps + 1;
	simNativeSpillBase = (simNativeStackPtr = -1);
	simNativeStackSize = 0;
}

	/* StackToRegisterMappingCogit>>#initSimStackForFramelessMethod: */
static NoDbgRegParms void
initSimStackForFramelessMethod(sqInt startpc)
{
    CogSimStackEntry *cascade0;
    CogSimStackEntry *desc;
    sqInt i;

	cascade0 = simSelf();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = ReceiverResultReg);
	(cascade0->liveRegister = ReceiverResultReg);
	assert(methodOrBlockNumTemps == methodOrBlockNumArgs);
	assert((numRegArgs()) <= 2);
	if (((methodOrBlockNumArgs >= 1) && (methodOrBlockNumArgs <= (numRegArgs())))) {
		desc = simStackAt(1);
		(desc->type = SSRegister);
		(desc->spilled = 0);
		(desc->registerr = Arg0Reg);
		(desc->bcptr = startpc);
		if (methodOrBlockNumArgs > 1) {
			desc = simStackAt(2);
			(desc->type = SSRegister);
			(desc->spilled = 0);
			(desc->registerr = Arg1Reg);
			(desc->bcptr = startpc);
		}
	}
	else {
		for (i = 1; i <= methodOrBlockNumArgs; i += 1) {
			desc = simStackAt(i);
			(desc->type = SSBaseOffset);
			(desc->registerr = SPReg);
			(desc->spilled = 1);
			(desc->offset = (methodOrBlockNumArgs - i) * BytesPerWord);
			(desc->bcptr = startpc);
		}
	}
	simStackPtr = methodOrBlockNumArgs;
	simSpillBase = methodOrBlockNumArgs + 1;
	simNativeSpillBase = (simNativeStackPtr = -1);
	simNativeStackSize = 0;
}


/*	Do not inline (inBlock access) */

	/* StackToRegisterMappingCogit>>#isNonForwarderReceiver: */
static NoDbgRegParms sqInt
isNonForwarderReceiver(sqInt reg)
{
	return ((((simSelf())->liveRegister)) == ReceiverResultReg)
	 && ((inBlock == 0)
	 && (reg == ReceiverResultReg));
}

	/* StackToRegisterMappingCogit>>#leaveNativeFrame */
static void
leaveNativeFrame(void)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	assert(needsFrame);
	offset = frameOffsetOfPreviousNativeStackPointer();

	/* begin MoveMw:r:R: */
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
	}

	/* begin SubCq:R: */
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, 1, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteralsize(1, BytesPerOop));
	}

	/* #MoveR:Aw: #gen:operand:literal: */
	checkLiteralforInstruction(nativeStackPointerAddress(), genoperandoperand(MoveRAw, TempReg, nativeStackPointerAddress()));
}

	/* StackToRegisterMappingCogit>>#liveFloatRegisters */
static sqInt
liveFloatRegisters(void)
{
    sqInt i;
    sqInt regsSet;

	regsSet = 0;
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= simStackPtr; i += 1) {
		regsSet = regsSet | (floatRegisterMask(simStackAt(i)));
	}
	for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= simNativeStackPtr; i += 1) {
		regsSet = regsSet | (nativeFloatRegisterMask(simNativeStackAt(i)));
	}
	return regsSet;
}

	/* StackToRegisterMappingCogit>>#liveRegisters */
static sqInt
liveRegisters(void)
{
    sqInt i;
    sqInt regsSet;

	if (needsFrame) {
		regsSet = 0;
	}
	else {
		regsSet = (1U << ReceiverResultReg);
		if ((methodOrBlockNumArgs <= (numRegArgs()))
		 && (methodOrBlockNumArgs > 0)) {
			regsSet = regsSet | ((1U << Arg0Reg));
			if (methodOrBlockNumArgs > 1) {
				regsSet = regsSet | ((1U << Arg1Reg));
			}
		}
	}
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= simStackPtr; i += 1) {
		regsSet = regsSet | (registerMask(simStackAt(i)));
	}
	for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= simNativeStackPtr; i += 1) {
		regsSet = regsSet | (nativeRegisterMask(simNativeStackAt(i)));
	}
	return regsSet;
}


/*	insert nops for dead code that is mapped so that bc 
	to mc mapping is not many to one */

	/* StackToRegisterMappingCogit>>#mapDeadDescriptorIfNeeded: */
static NoDbgRegParms sqInt
mapDeadDescriptorIfNeeded(BytecodeDescriptor *descriptor)
{
    AbstractInstruction *abstractInstruction;

	flag("annotateInstruction");
	if (((descriptor->isMapped))
	 || ((inBlock > 0)
	 && ((descriptor->isMappedInBlock)))) {
		abstractInstruction = gen(Nop);

		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
	}
	return 0;
}


/*	Spill everything on the simulated stack that needs spilling (that below
	receiver and arguments).
	Marshall receiver and arguments to stack and/or registers depending on arg
	count. If the args don't fit in registers push receiver and args (spill
	everything), but still assign
	the receiver to ReceiverResultReg. */

	/* StackToRegisterMappingCogit>>#marshallSendArguments: */
static NoDbgRegParms void
marshallSendArguments(sqInt numArgs)
{
    sqInt anyRefs;
    CogSimStackEntry *cascade0;
    sqInt i;
    sqInt numSpilled;

	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	ssNativeFlushTo(simNativeStackPtr);
	if (simSpillBase <= ((simStackPtr - numArgs) - 1)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < ((simStackPtr - numArgs) - 1)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : ((simStackPtr - numArgs) - 1))); i < (simStackPtr - numArgs); i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = ((simStackPtr - numArgs) - 1) + 1;
	}
	if (numArgs > (numRegArgs())) {

		/* If there are no spills and no references to ReceiverResultReg
		   the fetch of ReceiverResultReg from the stack can be avoided
		   by assigning directly to ReceiverResultReg and pushing it. */
		numSpilled = numberOfSpillsInTopNItems(numArgs + 1);
		anyRefs = anyReferencesToRegisterinTopNItems(ReceiverResultReg, numArgs + 1);
		if ((numSpilled > 0)
		 || (anyRefs)) {
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= simStackPtr) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = simStackPtr + 1;
			}
			storeToReg(simStackAt(simStackPtr - numArgs), ReceiverResultReg);
		}
		else {
			cascade0 = simStackAt(simStackPtr - numArgs);
			storeToReg(cascade0, ReceiverResultReg);
			(cascade0->type = SSRegister);
			(cascade0->registerr = ReceiverResultReg);

			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= simStackPtr) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = simStackPtr + 1;
			}
		}
	}
	else {

		/* Move the args to the register arguments, being careful to do
		   so last to first so e.g. previous contents don't get overwritten.
		   Also check for any arg registers in use by other args. */
		if (numArgs > 0) {
			if (numArgs > 1) {
				/* begin ssAllocateRequiredReg:upThrough: */
				ssAllocateRequiredRegMaskupThroughupThroughNative((1U << Arg0Reg), simStackPtr - 2, simNativeStackPtr);
				ssAllocateRequiredRegMaskupThroughupThroughNative((1U << Arg1Reg), simStackPtr - 1, simNativeStackPtr);
			}
			else {
				/* begin ssAllocateRequiredReg:upThrough: */
				ssAllocateRequiredRegMaskupThroughupThroughNative((1U << Arg0Reg), simStackPtr - 1, simNativeStackPtr);
			}
		}
		if (numArgs > 1) {
			popToReg(simStackAt(simStackPtr), Arg1Reg);
		}
		if (numArgs > 0) {
			popToReg(simStackAt((simStackPtr - numArgs) + 1), Arg0Reg);
		}
		popToReg(simStackAt(simStackPtr - numArgs), ReceiverResultReg);
	}
	ssPop(numArgs + 1);
}


/*	For assert checking; or rather for avoiding assert fails when dealing with
	the hack for block temps in the SqueakV3PlusClosures bytecode set.
 */

	/* StackToRegisterMappingCogit>>#maybeCompilingFirstPassOfBlockWithInitialPushNil */
static sqInt
maybeCompilingFirstPassOfBlockWithInitialPushNil(void)
{
	return (inBlock == InVanillaBlock)
	 && ((methodOrBlockNumTemps > methodOrBlockNumArgs)
	 && (compilationPass == 1));
}


/*	If this bytecode has a fixup, some kind of merge needs to be done. There
	are 4 cases:
	1) the bytecode has no fixup (fixup isNotAFixup)
	do nothing
	2) the bytecode has a non merge fixup
	the fixup has needsNonMergeFixup.
	The code generating non merge fixup (currently only special selector code)
	is responsible
	for the merge so no need to do it.
	We set deadCode to false as the instruction can be reached from jumps.
	3) the bytecode has a merge fixup, but execution flow *cannot* fall
	through to the merge point.
	the fixup has needsMergeFixup and deadCode = true.
	ignores the current simStack as it does not mean anything 
	restores the simStack to the state the jumps to the merge point expects it
	to be.
	4) the bytecode has a merge fixup and execution flow *can* fall through to
	the merge point.
	the fixup has needsMergeFixup and deadCode = false.
	flushes the stack to the stack pointer so the fall through execution path
	simStack is 
	in the state the merge point expects it to be. 
	restores the simStack to the state the jumps to the merge point expects it
	to be.
	
	In addition, if this is a backjump merge point, we patch the fixup to hold
	the current simStackPtr 
	for later assertions. */

	/* StackToRegisterMappingCogit>>#mergeWithFixupIfRequired: */
static NoDbgRegParms sqInt
mergeWithFixupIfRequired(BytecodeFixup *fixup)
{
    CogSimStackEntry *cascade0;
    sqInt i;

	/* begin assertCorrectSimStackPtr */
	assert((simSpillBase >= methodOrBlockNumTemps)
	 || ((maybeCompilingFirstPassOfBlockWithInitialPushNil())
	 && (simSpillBase > methodOrBlockNumArgs)));
	if (needsFrame
	 && (simSpillBase > 0)) {
		assert(((((simStackAt(simSpillBase - 1))->spilled)) == 1)
		 || ((maybeCompilingFirstPassOfBlockWithInitialPushNil())
		 && (simSpillBase > methodOrBlockNumArgs)));
		assert((simSpillBase > simStackPtr)
		 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	}
	if (!((fixup->targetInstruction))) {
		return 0;
	}
	if ((((usqInt)((fixup->targetInstruction)))) == NeedsNonMergeFixupFlag) {
		deadCode = 0;
		return 0;
	}
	assert(isMergeFixup(fixup));
	traceMerge(fixup);
	if (deadCode) {

		/* case 3 */
		/* Would like to assert fixup simStackPtr >= methodOrBlockNumTemps
		   but can't because of the initialNils hack. */
		assert((((fixup->simStackPtr)) >= methodOrBlockNumTemps)
		 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
		simStackPtr = (fixup->simStackPtr);
		simNativeStackPtr = (fixup->simNativeStackPtr);
		simNativeStackSize = (fixup->simNativeStackSize);
	}
	else {

		/* case 4 */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
	}
	deadCode = 0;
	if ((fixup->isTargetOfBackwardBranch)) {
		(fixup->simStackPtr = simStackPtr);
		(fixup->simNativeStackPtr = simNativeStackPtr);
		(fixup->simNativeStackSize = simNativeStackSize);
	}
	(fixup->targetInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	assert(simStackPtr == ((fixup->simStackPtr)));
	assert(simNativeStackPtr == ((fixup->simNativeStackPtr)));
	assert(simNativeStackSize == ((fixup->simNativeStackSize)));

	/* begin restoreSimStackAtMergePoint: */
	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	for (i = (methodOrBlockNumTemps + 1); i <= simStackPtr; i += 1) {
		cascade0 = simStackAt(i);
		(cascade0->type = SSSpill);
		(cascade0->offset = FoxMFReceiver - ((i - methodOrBlockNumArgs) * BytesPerOop));
		(cascade0->registerr = FPReg);
		(cascade0->spilled = 1);
	}
	simSpillBase = simStackPtr + 1;
	for (i = 0; i <= simNativeStackPtr; i += 1) {
		ensureIsMarkedAsSpilled(simNativeStackAt(i));
	}
	simNativeSpillBase = simNativeStackPtr + 1;
	return 0;
}

	/* StackToRegisterMappingCogit>>#methodAbortTrampolineFor: */
static NoDbgRegParms sqInt
methodAbortTrampolineFor(sqInt numArgs)
{
	return methodAbortTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}

	/* StackToRegisterMappingCogit>>#needsFrameIfMod16GENumArgs: */
static NoDbgRegParms sqInt
needsFrameIfMod16GENumArgs(sqInt stackDelta)
{
	return (byte0 % 16) >= methodOrBlockNumArgs;
}


/*	As of August 2013, the code generator can't deal with spills in frameless
	methods (the
	issue is to do with the stack offset to get at an argument, which is
	changed when there's a spill).
	In e.g. TextColor>>#dominates: other ^other class == self class the second
	send of class
	needs also rto allocate a register that the first one used, but the first
	one's register can't be
	spilled. So avoid this by only allowing class to be sent if the stack
	contains a single element. */

	/* StackToRegisterMappingCogit>>#needsFrameIfStackGreaterThanOne: */
static NoDbgRegParms sqInt
needsFrameIfStackGreaterThanOne(sqInt stackDelta)
{
	return stackDelta > 1;
}

	/* StackToRegisterMappingCogit>>#numberOfSpillsInTopNItems: */
static NoDbgRegParms sqInt
numberOfSpillsInTopNItems(sqInt n)
{
    sqInt i;

	for (i = simStackPtr; i >= ((simStackPtr - n) + 1); i += -1) {
		if ((((simStackAt(i))->type)) == SSSpill) {
			return n - (simStackPtr - i);
		}
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#picAbortTrampolineFor: */
static NoDbgRegParms sqInt
picAbortTrampolineFor(sqInt numArgs)
{
	return picAbortTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}

	/* StackToRegisterMappingCogit>>#prevInstIsPCAnnotated */
static sqInt
prevInstIsPCAnnotated(void)
{
    sqInt prevIndex;
    AbstractInstruction *prevInst;

	if (!(opcodeIndex > 0)) {
		return 0;
	}
	prevIndex = opcodeIndex - 1;
	while (1) {
		if (prevIndex <= 0) {
			return 0;
		}
		prevInst = abstractInstructionAt(prevIndex);
		if (((!((prevInst->annotation))
			? 0
			: (prevInst->annotation))) >= HasBytecodePC) {
			return 1;
		}
		if (!(((prevInst->opcode)) == Label)) break;
		prevIndex -= 1;
	}
	return 0;
}


/*	Used to mark ReceiverResultReg as dead or not containing simSelf.
	Used when the simStack has already been flushed, e.g. for sends. */

	/* StackToRegisterMappingCogit>>#receiverIsInReceiverResultReg */
static int
receiverIsInReceiverResultReg(void)
{
	return (((simSelf())->liveRegister)) == ReceiverResultReg;
}


/*	When a block must be recompiled due to overestimating the
	numInitialNils fixups must be restored, which means rescannning
	since backward branches need their targets initialized. */

	/* StackToRegisterMappingCogit>>#reinitializeFixupsFrom:through: */
static NoDbgRegParms void
reinitializeFixupsFromthrough(sqInt start, sqInt end)
{
    BytecodeDescriptor *descriptor;
    sqInt distance;
    BytecodeFixup *fixup;
    sqInt nExts;
    sqInt pc;
    BytecodeFixup *self_in_CogSSBytecodeFixup;
    sqInt targetPC;

	pc = start;
	nExts = 0;
	while (pc <= end) {
		/* begin fixupAt: */
		self_in_CogSSBytecodeFixup = fixupAtIndex(pc - initialPC);
		(self_in_CogSSBytecodeFixup->targetInstruction) = 0;
		(self_in_CogSSBytecodeFixup->simStackPtr) = 0;
		(self_in_CogSSBytecodeFixup->simNativeStackPtr) = ((self_in_CogSSBytecodeFixup->simNativeStackSize) = 0);
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((isBranch(descriptor))
		 && ((/* begin isBackwardBranch:at:exts:in: */
			assert(((descriptor->spanFunction))),
		(((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)) < 0))) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;

			/* begin initializeFixupAt: */
			/* begin fixupAt: */
			fixup = fixupAtIndex(targetPC - initialPC);
			(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);

			/* begin setIsBackwardBranchFixup */
			(fixup->isTargetOfBackwardBranch) = 1;
		}
		if ((descriptor->isBlockCreation)) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			pc = (pc + ((descriptor->numBytes))) + distance;
		}
		else {
			pc += (descriptor->numBytes);
		}
		nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
	}
}


/*	Scan the block to determine if the block needs a frame or not */

	/* StackToRegisterMappingCogit>>#scanBlock: */
static NoDbgRegParms sqInt
scanBlock(BlockStart *blockStart)
{
    BytecodeDescriptor *descriptor;
    sqInt end;
    sqInt framelessStackDelta;
    sqInt nExts;
    sqInt numPushNils;
    sqInt (* const numPushNilsFunction)(struct _BytecodeDescriptor *,sqInt,sqInt,sqInt) = squeakV3orSistaV1NumPushNils;
    sqInt pc;
    sqInt pushingNils;

	needsFrame = 0;
	hasNativeFrame = 0;
	prevBCDescriptor = null;
	methodOrBlockNumArgs = (blockStart->numArgs);
	inBlock = InVanillaBlock;
	pc = (blockStart->startpc);
	end = ((blockStart->startpc)) + ((blockStart->span));
	framelessStackDelta = (nExts = (extA = (numExtB = (extB = 0))));
	pushingNils = 1;
	while (pc < end) {
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((descriptor->isExtension)) {
			loadSubsequentBytesForDescriptorat(descriptor, pc);
			((descriptor->generator))();
		}
		if (!needsFrame) {
			if ((!((descriptor->needsFrameFunction)))
			 || (((descriptor->needsFrameFunction))(framelessStackDelta))) {
				needsFrame = 1;
			}
			else {
				framelessStackDelta += (descriptor->stackDelta);
			}
		}

		/* begin maybeNoteDescriptor:blockStart: */
		if ((descriptor->isInstVarRef)) {
			(blockStart->hasInstVarRef = 1);
		}
		if (pushingNils
		 && (!((descriptor->isExtension)))) {

			/* Count the initial number of pushed nils acting as temp initializers.  We can't tell
			   whether an initial pushNil is an operand reference or a temp initializer, except
			   when the pushNil is a jump target (has a fixup), which never happens:
			   self systemNavigation browseAllSelect:
			   [:m| | ebc |
			   (ebc := m embeddedBlockClosures
			   select: [:ea| ea decompile statements first isMessage]
			   thenCollect: [:ea| ea decompile statements first selector]) notEmpty
			   and: [(#(whileTrue whileFalse whileTrue: whileFalse:) intersection: ebc) notEmpty]]
			   or if the bytecode set has a push multiple nils bytecode.  We simply count initial nils.
			   Rarely we may end up over-estimating.  We will correct by checking the stack depth
			   at the end of the block in compileBlockBodies. */
			if (((numPushNils = numPushNilsFunction(descriptor, pc, nExts, methodObj))) > 0) {
				assert(((descriptor->numBytes)) == 1);
				(blockStart->numInitialNils = ((blockStart->numInitialNils)) + numPushNils);
			}
			else {
				pushingNils = 0;
			}
		}
		pc = (pc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
		? ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)
		: 0));
		if ((descriptor->isExtension)) {
			nExts += 1;
		}
		else {
			nExts = (extA = (numExtB = (extB = 0)));
		}
		prevBCDescriptor = descriptor;
	}
	if (!needsFrame) {
		assert((framelessStackDelta >= 0)
		 && (((blockStart->numInitialNils)) >= framelessStackDelta));
		(blockStart->numInitialNils = ((blockStart->numInitialNils)) - framelessStackDelta);
	}
	return 0;
}


/*	Scan the method (and all embedded blocks) to determine
	- what the last bytecode is; extra bytes at the end of a method are used
	to encode things like source pointers or temp names
	- if the method needs a frame or not
	- what are the targets of any backward branches.
	- how many blocks it creates
	Answer the block count or on error a negative error code */

	/* StackToRegisterMappingCogit>>#scanMethod */
static sqInt
scanMethod(void)
{
    BytecodeDescriptor *descriptor;
    sqInt distance;
    BytecodeFixup *fixup;
    sqInt framelessStackDelta;
    sqInt latestContinuation;
    sqInt nExts;
    sqInt numBlocks;
    sqInt pc;
    sqInt seenInstVarStore;
    sqInt targetPC;

	needsFrame = (useTwoPaths = (seenInstVarStore = 0));
	hasNativeFrame = 0;
	prevBCDescriptor = null;
	if ((primitiveIndex > 0)
	 && (isQuickPrimitiveIndex(primitiveIndex))) {
		return 0;
	}
	pc = (latestContinuation = initialPC);
	numBlocks = (framelessStackDelta = (nExts = (extA = (numExtB = (extB = 0)))));
	while (pc <= endPC) {
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((descriptor->isExtension)) {
			if (((descriptor->opcode)) == Nop) {

				/* unknown bytecode tag; see Cogit class>>#generatorTableFrom: */
				return EncounteredUnknownBytecode;
			}
			loadSubsequentBytesForDescriptorat(descriptor, pc);
			((descriptor->generator))();
		}
		if (((descriptor->isReturn))
		 && (pc >= latestContinuation)) {
			endPC = pc;
		}
		if (!needsFrame) {
			if ((!((descriptor->needsFrameFunction)))
			 || (((descriptor->needsFrameFunction))(framelessStackDelta))) {

				/* With immutability we win simply by avoiding a frame build if the receiver is young and not immutable. */
#        if IMMUTABILITY
				if ((descriptor->is1ByteInstVarStore)) {
					useTwoPaths = 1;
				}
				else {
					needsFrame = 1;
					useTwoPaths = 0;
				}
#        else // IMMUTABILITY
				needsFrame = 1;
				useTwoPaths = 0;
#        endif

			}
			else {
				/* Without immutability we win if there are two or more stores and the receiver is new. */
				framelessStackDelta += (descriptor->stackDelta);
#        if IMMUTABILITY
#        else
				if ((descriptor->is1ByteInstVarStore)) {
					if (seenInstVarStore) {
						useTwoPaths = 1;
					}
					else {
						seenInstVarStore = 1;
					}
				}
#        endif // IMMUTABILITY

			}
		}
		if (isBranch(descriptor)) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			if ((/* begin isBackwardBranch:at:exts:in: */
				assert(((descriptor->spanFunction))),
			(((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)) < 0)) {
				/* begin initializeFixupAt: */
				/* begin fixupAt: */
				fixup = fixupAtIndex(targetPC - initialPC);
				(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);

				/* begin setIsBackwardBranchFixup */
				(fixup->isTargetOfBackwardBranch) = 1;
			}
			else {
				latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
			}
		}
		if ((descriptor->isBlockCreation)) {
			numBlocks += 1;
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
		}
		pc += (descriptor->numBytes);
		nExts = ((descriptor->isExtension)
					? nExts + 1
					: (extA = (numExtB = (extB = 0))));
		prevBCDescriptor = descriptor;
	}
	return numBlocks;
}

	/* StackToRegisterMappingCogit>>#squeakV3orSistaV1PushNilSize:numInitialNils: */
static NoDbgRegParms sqInt
squeakV3orSistaV1PushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils)
{
	return (methodUsesAlternateBytecodeSet(aMethodObj),
	numInitialNils);
}

	/* StackToRegisterMappingCogit>>#squeakV3orSistaV1:Num:Push:Nils: */
static NoDbgRegParms sqInt
squeakV3orSistaV1NumPushNils(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	return (/* v3:Num:Push:Nils: */
		(((descriptor->generator)) == genPushConstantNilBytecode
			? 1
			: 0));
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredFloatRegMask:upThrough:upThroughNative: */
static NoDbgRegParms void
ssAllocateRequiredFloatRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr)
{
    sqInt i;
    sqInt iSqInt;
    sqInt lastRequired;
    sqInt lastRequiredNative;
    sqInt liveRegs;

	lastRequired = -1;

	/* compute live regs while noting the last occurrence of required regs.
	   If these are not free we must spill from simSpillBase to last occurrence.
	   Note we are conservative here; we could allocate FPReg in frameless methods. */
	lastRequiredNative = -1;
	liveRegs = NoReg;
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= stackPtr; i += 1) {
		liveRegs = liveRegs | (registerMask(simStackAt(i)));
		if (0) {
			lastRequired = i;
		}
	}
	assert(lastRequiredNative == simNativeStackPtr);
	for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= nativeStackPtr; i += 1) {
		liveRegs = liveRegs | (nativeRegisterMask(simNativeStackAt(i)));
		if (0) {
			lastRequiredNative = i;
		}
	}
	if (liveRegs & requiredRegsMask) {

		/* Some live, must spill */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= lastRequired) {
			for (iSqInt = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < lastRequired) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : lastRequired)); iSqInt <= lastRequired; iSqInt += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(iSqInt), frameOffsetOfTemporary(iSqInt - 1), FPReg);
			}
			simSpillBase = lastRequired + 1;
		}
		assert(((liveFloatRegisters()) & requiredRegsMask) == 0);
	}
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredFloatReg: */
static NoDbgRegParms void
ssAllocateRequiredFloatReg(sqInt requiredReg)
{
	ssAllocateRequiredFloatRegMaskupThroughupThroughNative(((requiredReg < 0) ? (((usqInt)(1)) >> (-requiredReg)) : (1ULL << requiredReg)), simStackPtr, simNativeStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredRegMask:upThrough:upThroughNative: */
static NoDbgRegParms void
ssAllocateRequiredRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr)
{
    sqInt i;
    sqInt iSqInt;
    sqInt lastRequired;
    sqInt lastRequiredNative;
    sqInt liveRegs;

	lastRequired = -1;

	/* compute live regs while noting the last occurrence of required regs.
	   If these are not free we must spill from simSpillBase to last occurrence.
	   Note we are conservative here; we could allocate FPReg in frameless methods. */
	lastRequiredNative = -1;
	liveRegs = (1U << FPReg) | (1U << SPReg);
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= stackPtr; i += 1) {
		liveRegs = liveRegs | (registerMask(simStackAt(i)));
		if ((((registerMask(simStackAt(i))) & requiredRegsMask) != 0)) {
			lastRequired = i;
		}
	}
	assert(nativeStackPtr == simNativeStackPtr);
	for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= nativeStackPtr; i += 1) {
		liveRegs = liveRegs | (nativeRegisterMask(simNativeStackAt(i)));
		if ((((nativeRegisterMask(simNativeStackAt(i))) & requiredRegsMask) != 0)) {
			lastRequiredNative = i;
		}
	}
	if (((liveRegs & requiredRegsMask) != 0)) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= lastRequired) {
			for (iSqInt = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < lastRequired) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : lastRequired)); iSqInt <= lastRequired; iSqInt += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(iSqInt), frameOffsetOfTemporary(iSqInt - 1), FPReg);
			}
			simSpillBase = lastRequired + 1;
		}
		assert(!(((((liveRegisters()) & requiredRegsMask) != 0))));
	}
}


/*	Any occurrences on the stack of the value being stored (which is the top
	of stack)
	must be flushed, and hence any values colder than them stack. */

	/* StackToRegisterMappingCogit>>#ssFlushUpThroughReceiverVariable: */
static NoDbgRegParms void
ssFlushUpThroughReceiverVariable(sqInt slotIndex)
{
    CogSimStackEntry *desc;
    sqInt i;
    sqInt index;

	ssNativeFlushTo(simNativeStackPtr);

	/* begin ssFlushUpThrough: */
	assert(simSpillBase >= 0);
	for (index = (simStackPtr - 1); index >= simSpillBase; index += -1) {
		if (((desc = simStackAt(index)),
		(((desc->type)) == SSBaseOffset)
			 && ((((desc->registerr)) == ReceiverResultReg)
			 && (((desc->offset)) == (slotOffsetOfInstVarIndex(slotIndex)))))) {
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= index) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = index + 1;
			}
			goto l1;
		}
	}
l1:	/* end ssFlushUpThrough: */;
}


/*	Any occurrences on the stack of the value being stored (which is the top
	of stack)
	must be flushed, and hence any values colder than them stack. */

	/* StackToRegisterMappingCogit>>#ssFlushUpThroughTemporaryVariable: */
static NoDbgRegParms void
ssFlushUpThroughTemporaryVariable(sqInt tempIndex)
{
    CogSimStackEntry *desc;
    sqInt i;
    sqInt index;
    sqInt offset;

	ssNativeFlushTo(simNativeStackPtr);
	offset = ((simStackAt(tempIndex + 1))->offset);
	assert(offset == (frameOffsetOfTemporary(tempIndex)));

	/* begin ssFlushUpThrough: */
	assert(simSpillBase >= 0);
	for (index = (simStackPtr - 1); index >= simSpillBase; index += -1) {
		if (((desc = simStackAt(index)),
		(((desc->type)) == SSBaseOffset)
			 && ((((desc->registerr)) == FPReg)
			 && (((desc->offset)) == offset)))) {
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			ssNativeFlushTo(simNativeStackPtr);
			if (simSpillBase <= index) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = index + 1;
			}
			goto l1;
		}
	}
l1:	/* end ssFlushUpThrough: */;
}

	/* StackToRegisterMappingCogit>>#ssNativeFlushTo: */
static NoDbgRegParms void
ssNativeFlushTo(sqInt index)
{
    sqInt allocatedScratchRegister;
    AbstractInstruction *anInstruction;
    sqInt i;
    sqInt loadedPointer;
    sqInt offset;

	if (simNativeSpillBase <= index) {
		loadedPointer = 0;
		allocatedScratchRegister = 0;
		for (i = (((simNativeSpillBase < 0) ? 0 : simNativeSpillBase)); i <= index; i += 1) {
			if (!loadedPointer) {
				offset = frameOffsetOfNativeFramePointer();

				/* begin MoveMw:r:R: */
				/* begin gen:quickConstant:operand:operand: */
				anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, TempReg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
				}
				loadedPointer = 1;
			}
			if ((spillingNeedsScratchRegister(simNativeStackAt(i)))
			 && (!allocatedScratchRegister)) {
				/* PushR: */
				genoperand(PushR, FPReg);
				allocatedScratchRegister = 1;
			}
			ensureSpilledSPscratchRegister(simNativeStackAt(i), TempReg, FPReg);
		}
		simNativeSpillBase = index + 1;
		if (allocatedScratchRegister) {
			/* PopR: */
			genoperand(PopR, FPReg);
		}
		if (loadedPointer) {
			/* begin SubCq:R: */
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(SubCqR, simNativeStackSize, TempReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(simNativeStackSize, BytesPerOop));
			}
			offset = frameOffsetOfNativeStackPointer();

			/* begin MoveR:Mw:r: */
			/* begin gen:operand:quickConstant:operand: */
			anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, offset, FPReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteralsize(offset, BytesPerOop));
			}
		}
	}
}

	/* StackToRegisterMappingCogit>>#ssNativePop: */
static NoDbgRegParms void
ssNativePop(sqInt n)
{
	assert((simNativeStackPtr - n) >= -1);
	simNativeStackPtr -= n;
	if (simNativeStackPtr >= 0) {
		simNativeStackSize = ((ssNativeTop())->offset);
	}
	else {
		simNativeStackSize = 0;
	}
}

	/* StackToRegisterMappingCogit>>#ssNativePush: */
static NoDbgRegParms void
ssNativePush(sqInt n)
{
	simNativeStackPtr += n;
}

	/* StackToRegisterMappingCogit>>#ssNativeTop */
static CogSimStackNativeEntry *
ssNativeTop(void)
{
	assert(simNativeStackPtr >= 0);
	return simNativeStackAt(simNativeStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssNativeValue: */
static NoDbgRegParms CogSimStackNativeEntry *
ssNativeValue(sqInt n)
{
	return simNativeStackAt(simNativeStackPtr - n);
}

	/* StackToRegisterMappingCogit>>#ssPopNativeSize: */
static NoDbgRegParms void
ssPopNativeSize(sqInt popSize)
{
    sqInt popCount;
    sqInt poppingSize;
    sqInt stackPosition;

	poppingSize = 0;
	stackPosition = simNativeStackPtr;
	while ((poppingSize < popSize)
	 && (stackPosition >= 0)) {
		poppingSize += stackSpillSize(simNativeStackAt(stackPosition));
		stackPosition -= 1;
	}
	assert(poppingSize == popSize);
	popCount = simNativeStackPtr - stackPosition;
	ssNativePop(popCount);
}

	/* StackToRegisterMappingCogit>>#ssPop: */
static NoDbgRegParms void
ssPop(sqInt n)
{
    sqInt i;
    sqInt toDoLimit;

	assert(((simStackPtr - n) >= methodOrBlockNumTemps)
	 || (((!needsFrame)
	 && ((simStackPtr - n) >= 0))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil())));
	simStackPtr -= n;

	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	toDoLimit = (((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr);
	for (i = (methodOrBlockNumTemps + 1); i <= toDoLimit; i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
}

	/* StackToRegisterMappingCogit>>#ssPushAnnotatedConstant: */
static NoDbgRegParms sqInt
ssPushAnnotatedConstant(sqInt literal)
{
    AbstractInstruction *abstractInstruction;

	ssPushConstant(literal);

	/* begin annotateInstructionForBytecode */
	abstractInstruction = (prevInstIsPCAnnotated()
				? gen(Nop)
				: genoperandoperand(Label, (labelCounter += 1), bytecodePC));

	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushBase:offset: */
static NoDbgRegParms sqInt
ssPushBaseoffset(sqInt reg, sqInt offset)
{
    CogSimStackEntry *cascade0;
    sqInt i;
    sqInt toDoLimit;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSBaseOffset);
	(cascade0->spilled = 0);
	(cascade0->registerr = reg);
	(cascade0->offset = offset);
	(cascade0->bcptr = bytecodePC);

	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	toDoLimit = (((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr);
	for (i = (methodOrBlockNumTemps + 1); i <= toDoLimit; i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushConstant: */
static NoDbgRegParms sqInt
ssPushConstant(sqInt literal)
{
    CogSimStackEntry *cascade0;
    sqInt i;
    sqInt toDoLimit;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSConstant);
	(cascade0->spilled = 0);
	(cascade0->constant = literal);
	(cascade0->bcptr = bytecodePC);

	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	toDoLimit = (((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr);
	for (i = (methodOrBlockNumTemps + 1); i <= toDoLimit; i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushDesc: */
static NoDbgRegParms sqInt
ssPushDesc(SimStackEntry simStackEntry)
{
    sqInt i;
    sqInt toDoLimit;

	if (((simStackEntry.type)) == SSSpill) {
		(simStackEntry.type = SSBaseOffset);
	}
	(simStackEntry.spilled = 0);
	(simStackEntry.bcptr = bytecodePC);
	simStack[(simStackPtr += 1)] = simStackEntry;

	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	toDoLimit = (((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr);
	for (i = (methodOrBlockNumTemps + 1); i <= toDoLimit; i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantFloat32: */
static NoDbgRegParms sqInt
ssPushNativeConstantFloat32(float aFloat32)
{
    CogSimStackNativeEntry *cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;

	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantFloat32);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantFloat32 = aFloat32);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantFloat64: */
static NoDbgRegParms sqInt
ssPushNativeConstantFloat64(double aFloat64)
{
    CogSimStackNativeEntry *cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += 8;

	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantFloat64);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantFloat64 = aFloat64);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantInt32: */
static NoDbgRegParms sqInt
ssPushNativeConstantInt32(sqInt anInt32)
{
    CogSimStackNativeEntry *cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;

	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantInt32);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantInt32 = anInt32);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantInt64: */
static NoDbgRegParms sqInt
ssPushNativeConstantInt64(sqLong anInt64)
{
    CogSimStackNativeEntry *cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += 8;

	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantInt64);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantInt64 = anInt64);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeConstantPointer: */
static NoDbgRegParms sqInt
ssPushNativeConstantPointer(sqInt aNativePointer)
{
    CogSimStackNativeEntry *cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;

	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSConstantNativePointer);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->constantNativePointer = aNativePointer);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeRegisterDoubleFloat: */
static NoDbgRegParms sqInt
ssPushNativeRegisterDoubleFloat(sqInt reg)
{
    CogSimStackNativeEntry *cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += 8;

	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSRegisterDoubleFloat);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeRegisterSingleFloat: */
static NoDbgRegParms sqInt
ssPushNativeRegisterSingleFloat(sqInt reg)
{
    CogSimStackNativeEntry *cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;

	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSRegisterSingleFloat);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushNativeRegister: */
static NoDbgRegParms sqInt
ssPushNativeRegister(sqInt reg)
{
    CogSimStackNativeEntry *cascade0;

	ssNativePush(1);
	if (simNativeSpillBase > simNativeStackPtr) {
		simNativeSpillBase = ((simNativeStackPtr < 0) ? 0 : simNativeStackPtr);
	}
	simNativeStackSize += BytesPerWord;

	/* begin ssNativeTop */
	assert(simNativeStackPtr >= 0);
	cascade0 = simNativeStackAt(simNativeStackPtr);
	(cascade0->type = SSNativeRegister);
	(cascade0->spilled = 0);
	(cascade0->offset = simNativeStackSize);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushRegister: */
static NoDbgRegParms sqInt
ssPushRegister(sqInt reg)
{
    CogSimStackEntry *cascade0;
    sqInt i;
    sqInt toDoLimit;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);

	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	toDoLimit = (((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr);
	for (i = (methodOrBlockNumTemps + 1); i <= toDoLimit; i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPush: */
static NoDbgRegParms void
ssPush(sqInt n)
{
	simStackPtr += n;
}

	/* StackToRegisterMappingCogit>>#ssSelfDescriptor */
static SimStackEntry
ssSelfDescriptor(void)
{
	return simStack[0];
}


/*	In addition to ssStorePop:toReg:, if this is a store and not
	a popInto I change the simulated stack to use the register 
	for the top value */

	/* StackToRegisterMappingCogit>>#ssStoreAndReplacePop:toReg: */
static NoDbgRegParms void
ssStoreAndReplacePoptoReg(sqInt popBoolean, sqInt reg)
{
    char topSpilled;

	topSpilled = ((ssTop())->spilled);
	ssStorePoptoReg(popBoolean
	 || (topSpilled), reg);
	if (!popBoolean) {
		if (!topSpilled) {
			ssPop(1);
		}
		ssPushRegister(reg);
	}
}


/*	Store or pop the top simulated stack entry to a register.
	Use preferredReg if the entry is not itself a register.
	Answer the actual register the result ends up in. */

	/* StackToRegisterMappingCogit>>#ssStorePop:toPreferredReg: */
static NoDbgRegParms sqInt
ssStorePoptoPreferredReg(sqInt popBoolean, sqInt preferredReg)
{
    sqInt actualReg;

	actualReg = preferredReg;
	if ((((ssTop())->type)) == SSRegister) {
		assert(!(((ssTop())->spilled)));
		actualReg = ((ssTop())->registerr);
	}
	ssStorePoptoReg(popBoolean, actualReg);
	return actualReg;
}


/*	Store or pop the top simulated stack entry to a register.
	N.B.: popToReg: and storeToReg: does not generate anything if 
	it moves a register to the same register. */

	/* StackToRegisterMappingCogit>>#ssStorePop:toReg: */
static NoDbgRegParms void
ssStorePoptoReg(sqInt popBoolean, sqInt reg)
{
	if (popBoolean) {
		popToReg(ssTop(), reg);
		ssPop(1);
	}
	else {
		storeToReg(ssTop(), reg);
	}
}

	/* StackToRegisterMappingCogit>>#ssTop */
static CogSimStackEntry *
ssTop(void)
{
	return simStackAt(simStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssValue: */
static NoDbgRegParms CogSimStackEntry *
ssValue(sqInt n)
{
	return simStackAt(simStackPtr - n);
}

	/* StackToRegisterMappingCogit>>#stackEntryIsBoolean: */
static NoDbgRegParms sqInt
stackEntryIsBoolean(CogSimStackEntry *simStackEntry)
{
	return (((simStackEntry->type)) == SSConstant)
	 && ((((simStackEntry->constant)) == (trueObject()))
	 || (((simStackEntry->constant)) == (falseObject())));
}


/*	Answer if the stack is valid up to, but not including, simSpillBase. */

	/* StackToRegisterMappingCogit>>#tempsValidAndVolatileEntriesSpilled */
static sqInt
tempsValidAndVolatileEntriesSpilled(void)
{
    sqInt culprit;
    sqInt i;

	culprit = 0;
	for (i = 1; i <= methodOrBlockNumTemps; i += 1) {
		if (!(((((simStackAt(i))->type)) == SSBaseOffset)
			 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()))) {
			if (!culprit) {
				culprit = i;
			}
			return 0;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i < simSpillBase; i += 1) {
		if (!(((simStackAt(i))->spilled))) {
			if (!culprit) {
				culprit = i;
			}
			return 0;
		}
	}
	return 1;
}


/*	If the sequence of bytecodes is
	push: (Array new: 1)
	popIntoTemp: tempIndex
	pushConstant: const or pushTemp: n
	popIntoTemp: 0 inVectorAt: tempIndex
	collapse this into
	tempAt: tempIndex put: {const or temp}
	and answer true, otherwise answer false.
	One might think that we should look for a sequence of more than
	one pushes and pops but this is extremely rare.
	Exclude pushRcvr: n to avoid potential complications with context inst
	vars.  */

	/* StackToRegisterMappingCogit>>#tryCollapseTempVectorInitializationOfSize: */
static NoDbgRegParms sqInt
tryCollapseTempVectorInitializationOfSize(sqInt slots)
{
    sqInt pc;
    BytecodeDescriptor *pushArrayDesc;
    BytecodeDescriptor *pushValueDesc;
    sqInt reg;
    sqInt remoteTempIndex;
    BytecodeDescriptor *storeArrayDesc;
    BytecodeDescriptor *storeValueDesc;
    usqInt tempIndex;

	if (slots != 1) {
		return 0;
	}

	/* begin generatorForPC: */
	pushArrayDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(bytecodePC, methodObj)));
	assert(((pushArrayDesc->generator)) == genPushNewArrayBytecode);
	pc = bytecodePC + ((pushArrayDesc->numBytes));

	/* begin generatorForPC: */
	storeArrayDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
	if (((storeArrayDesc->generator)) == genStoreAndPopTemporaryVariableBytecode) {
		tempIndex = (fetchByteofObject(bytecodePC + ((pushArrayDesc->numBytes)), methodObj)) & 7;
	}
	else {
		if (!(((storeArrayDesc->generator)) == genLongStoreAndPopTemporaryVariableBytecode)) {
			return 0;
		}
		tempIndex = fetchByteofObject((bytecodePC + ((pushArrayDesc->numBytes))) + 1, methodObj);
	}
	pc = (bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes));

	/* begin generatorForPC: */
	pushValueDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
	if (!((((pushValueDesc->generator)) == genPushLiteralConstantBytecode)
		 || ((((pushValueDesc->generator)) == genPushQuickIntegerConstantBytecode)
		 || (((pushValueDesc->generator)) == genPushTemporaryVariableBytecode)))) {
		return 0;
	}
	pc = ((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes));

	/* begin generatorForPC: */
	storeValueDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
	remoteTempIndex = fetchByteofObject((((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes))) + 2, methodObj);
	if (!((((storeValueDesc->generator)) == genStoreAndPopRemoteTempLongBytecode)
		 && (tempIndex == remoteTempIndex))) {
		return 0;
	}
	genNewArrayOfSizeinitialized(1, 0);
	evaluateat(pushValueDesc, (bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes)));
	reg = ssStorePoptoPreferredReg(1, TempReg);
	genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, 0, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
	evaluateat(storeArrayDesc, bytecodePC + ((pushArrayDesc->numBytes)));

	/* + pushArrayDesc numBytes this gets added by nextBytecodePCFor:at:exts:in: */
	bytecodePC = ((bytecodePC + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes))) + ((storeValueDesc->numBytes));
	return 1;
}

	/* StackToRegisterMappingCogit>>#violatesEnsureSpilledSpillAssert */
static sqInt
violatesEnsureSpilledSpillAssert(void)
{
	return 1;
}


/*	Used when ReceiverResultReg is allocated for other than simSelf, and
	there may be references to ReceiverResultReg which need to be spilled. */

	/* StackToRegisterMappingCogit>>#voidReceiverResultRegContainsSelf */
static void
voidReceiverResultRegContainsSelf(void)
{
    sqInt i;
    sqInt iSqInt;
    sqInt spillIndex;

	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	spillIndex = 0;
	for (i = ((((methodOrBlockNumTemps + 1) < simSpillBase) ? simSpillBase : (methodOrBlockNumTemps + 1))); i <= simStackPtr; i += 1) {
		if ((registerOrNone(simStackAt(i))) == ReceiverResultReg) {
			spillIndex = i;
		}
	}
	if (spillIndex > 0) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		ssNativeFlushTo(simNativeStackPtr);
		if (simSpillBase <= spillIndex) {
			for (iSqInt = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < spillIndex) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : spillIndex)); iSqInt <= spillIndex; iSqInt += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(iSqInt), frameOffsetOfTemporary(iSqInt - 1), FPReg);
			}
			simSpillBase = spillIndex + 1;
		}
	}
}
