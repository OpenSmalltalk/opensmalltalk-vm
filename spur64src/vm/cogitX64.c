/* Automatically generated by
	CCodeGenerator VMMaker.oscog-eem.1722 uuid: e5c44d63-ba75-4cd1-bf4e-c92c4232bbfe
   from
	StackToRegisterMappingCogit VMMaker.oscog-eem.1722 uuid: e5c44d63-ba75-4cd1-bf4e-c92c4232bbfe
 */
static char __buildInfo[] = "StackToRegisterMappingCogit VMMaker.oscog-eem.1722 uuid: e5c44d63-ba75-4cd1-bf4e-c92c4232bbfe " __DATE__ ;
char *__cogitBuildInfo = __buildInfo;



#include <stddef.h>
#include "sq.h"
#include "sqCogStackAlignment.h"
#include "dispdbg.h"
#include "cogmethod.h"
#if COGMTVM
#include "cointerpmt.h"
#else
#include "cointerp.h"
#endif
#include "cogit.h"


/*** Constants ***/
#define ABI SysV
#define AddCqR 95
#define AddCwR 103
#define AddRdRd 110
#define AddRR 89
#define AlignmentNops 3
#define AltBlockCreationBytecodeSize 3
#define AltFirstSpecialSelector 80
#define AltNumSpecialSelectors 32
#define AndCqR 97
#define AndCqRR 108
#define AndCwR 105
#define AndRR 91
#define AnnotationShift 5
#define Arg0Reg 7
#define Arg1Reg 6
#define ArithmeticShiftRightCqR 80
#define ArithmeticShiftRightRR 81
#define BadRegisterSet 1
#define BlockCreationBytecodeSize 4
#define BytecodeSetHasDirectedSuperSend 0
#define Call 6
#define CallFull 7
#define CDQ 116
#define ClassArrayCompactIndex 51
#define ClassBlockClosureCompactIndex 37
#define ClassFloatCompactIndex 34
#define ClassMethodContextCompactIndex 36
#define ClassReg 1
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CMBlock 3
#define CMClosedPIC 4
#define CMFree 1
#define CMMaxUsageCount 7
#define CMMethod 2
#define CMOpenPIC 5
#define CmpC32R 102
#define CmpCqR 94
#define CmpCwR 101
#define CmpRdRd 109
#define CmpRR 88
#define CompletePrimitive 4
#define ConstZero 1
#define ConvertRRd 115
#define Debug DEBUGVM
#define DisplacementMask 0x1F
#define DisplacementX2N 0
#define DivRdRd 113
#define DPFPReg0 0
#define DPFPReg1 1
#define DPFPReg2 2
#define EncounteredUnknownBytecode -6
#define Fill32 4
#define FirstAnnotation 64
#define FirstJump 11
#define FirstShortJump 15
#define FirstSpecialSelector 176
#define FoxCallerSavedIP 8
#define FoxMethod -8
#define FoxMFReceiver -24
#define FoxSavedFP 0
#define FoxThisContext -16
#define FPReg 5
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define HasBytecodePC 4
#define HeaderIndex 0
#define IDIVR 117
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 0
#endif
#define IMULRR 118
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define InsufficientCodeSpace -2
#define IsAbsPCReference 3
#define IsAnnotationExtension 1
#define IsDirectedSuperSend 9
#define IsDisplacementX2N 0
#define IsNSDynamicSuperSend null
#define IsNSImplicitReceiverSend null
#define IsNSSelfSend null
#define IsNSSendCall null
#define IsObjectReference 2
#define IsRelativeCall 5
#define IsSendCall 7
#define IsSuperSend 8
#define Jump 15
#define JumpAbove 30
#define JumpAboveOrEqual 29
#define JumpBelow 28
#define JumpBelowOrEqual 31
#define JumpCarry 22
#define JumpFPEqual 32
#define JumpFPGreater 36
#define JumpFPGreaterOrEqual 37
#define JumpFPLess 34
#define JumpFPLessOrEqual 35
#define JumpFPNotEqual 33
#define JumpFPOrdered 38
#define JumpFPUnordered 39
#define JumpFull 11
#define JumpGreater 26
#define JumpGreaterOrEqual 25
#define JumpLess 24
#define JumpLessOrEqual 27
#define JumpLong 12
#define JumpLongNonZero 14
#define JumpLongZero 13
#define JumpNegative 18
#define JumpNoCarry 23
#define JumpNonNegative 19
#define JumpNonZero 17
#define JumpNoOverflow 21
#define JumpOverflow 20
#define JumpR 9
#define JumpZero 16
#define Label 1
#define LargeContextSlots 62
#define LastJump 39
#undef LinkReg
#define Literal 2
#define LiteralStart 1
#define LoadEffectiveAddressMwrR 77
#define LogicalShiftLeftCqR 84
#define LogicalShiftLeftRR 85
#define LogicalShiftRightCqR 82
#define LogicalShiftRightRR 83
#define MapEnd 0
#define MaxCompiledPrimitiveIndex 555
#define MaxMethodSize 65535
#define MaxNegativeErrorCode -8
#define MaxNumArgs 15
#define MaxStackAllocSize 1572864
#define MaxStackCheckOffset 0xFFF
#define MaxX2NDisplacement 992
#define MethodCacheClass 2
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCacheSelector 1
#define MethodIndex 3
#define MethodTooBig -4
#define MFMethodFlagHasContextFlag 1
#define MFMethodFlagIsBlockFlag 2
#define ModReg 3
#define ModRegInd 0
#define ModRegRegDisp32 2
#define ModRegRegDisp8 1
#define MoveAbR 43
#define MoveAwR 41
#define MoveC32R 65
#define MoveCqR 63
#define MoveCwR 64
#define MoveM16rR 51
#define MoveM64rRd 70
#define MoveMbrR 59
#define MoveMwrR 45
#define MoveRAb 44
#define MoveRAw 42
#define MoveRdM64r 71
#define MoveRdR 68
#define MoveRdRd 69
#define MoveRM16r 52
#define MoveRMbr 60
#define MoveRMwr 46
#define MoveRR 40
#define MoveRRd 67
#define MoveRX32rR 58
#define MoveRXbrR 62
#define MoveRXwrR 48
#define MoveX32rRR 57
#define MoveXbrRR 61
#define MoveXwrRR 47
#define MULTIPLEBYTECODESETS 0
#define MulRdRd 112
#define NegateR 79
#define NewspeakVM 0
#define Nop 5
#define NoReg -1
#define NotFullyInitialized -1
#define NumObjRefsInRuntime 0
#define NumOopsPerNSC 6
#define NumSendTrampolines 4
#define NumSpecialSelectors 32
#define NumTrampolines 54
#define OrCqR 98
#define OrCwR 106
#define OrRR 92
#undef PCReg
#define PopR 72
#define PrefetchAw 76
#define PrimCallCollectsProfileSamples 8
#define PrimCallDoNotJIT 32
#define PrimCallMayCallBack 4
#define PrimCallNeedsNewMethod 1
#define PrimCallNeedsPrimitiveFunction 2
#define PrimErrWritePastObject 17
#define PushCq 74
#define PushCw 75
#define PushR 73
#define R10 10
#define R11 11
#define R12 12
#define R13 13
#define R15 15
#define R8 8
#define R9 9
#define RAX 0
#define RBP 5
#define RBX 3
#define RCX 1
#define RDI 7
#define RDX 2
#define ReceiverIndex 5
#define ReceiverResultReg 2
#define RetN 8
#define RISCTempReg 8
#define RotateLeftCqR 86
#define RotateRightCqR 87
#define RSI 6
#define RSP 4
#define Scratch0Reg 10
#define Scratch1Reg 11
#define SelectorCannotInterpret 34
#define SelectorDoesNotUnderstand 20
#define SenderIndex 0
#define SendNumArgsReg 9
#define ShouldNotJIT -8
#define SIB1 0
#define SIB4 2
#define SIB8 3
#define SistaVM 0
#define SmallContextSlots 22
#define SPReg 4
#define SpecialSelectors 23
#define SqrtRd 114
#define SSBaseOffset 1
#define SSConstant 2
#define SSRegister 3
#define SSSpill 4
#define StackPointerIndex 2
#define Stop 10
#define SubCqR 96
#define SubCwR 104
#define SubRdRd 111
#define SubRR 90
#define TempReg 0
#define TstCqR 99
#define UnfailingPrimitive 3
#define UnimplementedPrimitive -7
#define ValueIndex 1
#define VarBaseReg 3
#define XCHGRR 128
#define XorCwR 107
#define XorRR 93
#define YoungSelectorInPIC -5

typedef struct _AbstractInstruction {
	unsigned char	opcode;
	unsigned char	machineCodeSize;
	unsigned char	maxSize;
	unsigned char	annotation;
	unsigned long		operands [3];
	unsigned long	address;
	struct _AbstractInstruction *dependent;
	unsigned char		machineCode [14];
 } AbstractInstruction;

#define CogInLineLiteralsX64Compiler AbstractInstruction
#define CogX64Compiler AbstractInstruction
#define CogAbstractInstruction AbstractInstruction


typedef struct {
	AbstractInstruction *fakeHeader;
	AbstractInstruction *fillInstruction;
	sqInt	numArgs;
	sqInt	numCopied;
	sqInt	numInitialNils;
	sqInt	startpc;
	AbstractInstruction *entryLabel;
	AbstractInstruction *stackCheckLabel;
	sqInt	span;
	sqInt	hasInstVarRef;
 } BlockStart;

#define CogBlockStart BlockStart


typedef struct _BytecodeDescriptor {
	sqInt (*generator )(void);
	sqInt (*spanFunction )(struct _BytecodeDescriptor *,sqInt,sqInt,sqInt);
	sqInt (*needsFrameFunction )(sqInt);
	signed char	stackDelta;
	unsigned char	opcode;
	unsigned char	numBytes;
	unsigned		isBranchTrue : 1;
	unsigned		isBranchFalse : 1;
	unsigned		isReturn : 1;
	unsigned		isBlockCreation : 1;
	unsigned		isMapped : 1;
	unsigned		isMappedInBlock : 1;
	unsigned		isExtension : 1;
	unsigned		isInstVarRef : 1;
 } BytecodeDescriptor;

#define CogBytecodeDescriptor BytecodeDescriptor


typedef struct {
	sqInt (*primitiveGenerator )(void);
	sqInt	primNumArgs;
 } PrimitiveDescriptor;

#define CogPrimitiveDescriptor PrimitiveDescriptor


typedef struct {
	AbstractInstruction *targetInstruction;
	sqInt	instructionIndex;
	sqInt	simStackPtr;
 } BytecodeFixup;

#define CogSSBytecodeFixup BytecodeFixup
#define CogBytecodeFixup BytecodeFixup


typedef struct {
	char	type;
	char	spilled;
	char	annotateUse;
	sqInt	registerr;
	sqInt	offset;
	sqInt	constant;
	sqInt	bcptr;
 } CogSimStackEntry;


typedef struct {
	sqInt	isReceiverResultRegLive;
	CogSimStackEntry *ssEntry;
 } CogSSOptStatus;



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

static AbstractInstruction * NoDbgRegParms addDependent(AbstractInstruction * self_in_addDependent, AbstractInstruction *anInstruction);
static sqInt NoDbgRegParms availableRegisterOrNoneFor(AbstractInstruction * self_in_availableRegisterOrNoneFor, sqInt liveRegsMask);
static AbstractInstruction * NoDbgRegParms cloneLiteralFrom(AbstractInstruction * self_in_cloneLiteralFrom, AbstractInstruction *existingLiteral);
static sqInt NoDbgRegParms concretizeAt(AbstractInstruction * self_in_concretizeAt, sqInt actualAddress);
static AbstractInstruction * NoDbgRegParms genWriteCResultIntoReg(AbstractInstruction * self_in_genWriteCResultIntoReg, sqInt abstractRegister);
static AbstractInstruction * NoDbgRegParms getJmpTarget(AbstractInstruction * self_in_getJmpTarget);
static sqInt NoDbgRegParms inCurrentCompilation(AbstractInstruction * self_in_inCurrentCompilation, sqInt operand);
static AbstractInstruction * NoDbgRegParms initializeSharableLiteral(AbstractInstruction * self_in_initializeSharableLiteral, sqInt literal);
static AbstractInstruction * NoDbgRegParms initializeUniqueLiteral(AbstractInstruction * self_in_initializeUniqueLiteral, sqInt literal);
static sqInt NoDbgRegParms isAFixup(AbstractInstruction * self_in_isAFixup, void *fixupOrAddress);
static sqInt NoDbgRegParms isJump(AbstractInstruction * self_in_isJump);
static usqInt NoDbgRegParms labelOffset(AbstractInstruction * self_in_labelOffset);
static AbstractInstruction * NoDbgRegParms relocateJumpLongBeforeFollowingAddressby(AbstractInstruction * self_in_relocateJumpLongBeforeFollowingAddressby, sqInt pc, sqInt delta);
static AbstractInstruction * NoDbgRegParms relocateJumpLongConditionalBeforeFollowingAddressby(AbstractInstruction * self_in_relocateJumpLongConditionalBeforeFollowingAddressby, sqInt pc, sqInt delta);
static AbstractInstruction * NoDbgRegParms resolveJumpTarget(AbstractInstruction * self_in_resolveJumpTarget);
static sqInt NoDbgRegParms rewriteConditionalJumpLongAttarget(AbstractInstruction * self_in_rewriteConditionalJumpLongAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static sqInt NoDbgRegParms setLabelOffset(AbstractInstruction * self_in_setLabelOffset, sqInt aValue);
static AbstractInstruction * NoDbgRegParms updateLabel(AbstractInstruction * self_in_updateLabel, AbstractInstruction *labelInstruction);
static CogMethod * NoDbgRegParms cmHomeMethod(CogBlockMethod * self_in_cmHomeMethod);
static sqInt NoDbgRegParms isBranch(BytecodeDescriptor * self_in_isBranch);
static sqInt NoDbgRegParms isUnconditionalBranch(BytecodeDescriptor * self_in_isUnconditionalBranch);
static sqInt NoDbgRegParms computeSizeOfArithCqR(AbstractInstruction * self_in_computeSizeOfArithCqR);
static sqInt NoDbgRegParms computeSizeOfArithCwR(AbstractInstruction * self_in_computeSizeOfArithCwR);
static usqInt NoDbgRegParms concretizeArithCwR(AbstractInstruction * self_in_concretizeArithCwR, sqInt x64opcode);
static usqInt NoDbgRegParms concretizeMoveCwR(AbstractInstruction * self_in_concretizeMoveCwR);
static usqInt NoDbgRegParms inlineCacheTagAt(AbstractInstruction * self_in_inlineCacheTagAt, sqInt callSiteReturnAddress);
static sqInt NoDbgRegParms isPCDependent(AbstractInstruction * self_in_isPCDependent);
static usqInt NoDbgRegParms literal32BeforeFollowingAddress(AbstractInstruction * self_in_literal32BeforeFollowingAddress, sqInt followingAddress);
static sqInt NoDbgRegParms literalBeforeFollowingAddress(AbstractInstruction * self_in_literalBeforeFollowingAddress, sqInt followingAddress);
static sqInt NoDbgRegParms loadLiteralByteSize(AbstractInstruction * self_in_loadLiteralByteSize);
static usqInt NoDbgRegParms sizePCDependentInstructionAt(AbstractInstruction * self_in_sizePCDependentInstructionAt, sqInt eventualAbsoluteAddress);
static AbstractInstruction * NoDbgRegParms storeLiteralbeforeFollowingAddress(AbstractInstruction * self_in_storeLiteralbeforeFollowingAddress, sqInt literal, sqInt followingAddress);
static AbstractInstruction * NoDbgRegParms gAddCqR(sqInt quickConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gAddRR(sqInt reg1, sqInt reg2);
static AbstractInstruction * NoDbgRegParms gAndCqR(sqInt quickConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gAndCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static AbstractInstruction * NoDbgRegParms gArithmeticShiftRightRR(sqInt reg1, sqInt reg2);
extern sqInt abortOffset(void);
static sqInt NoDbgRegParms abstractInstructionfollows(AbstractInstruction *theAbstractInstruction, AbstractInstruction *anAbstractInstruction);
static void addCleanBlockStarts(void);
extern void addCogMethodsToHeapMap(void);
static sqInt NoDbgRegParms addressIsInCurrentCompilation(sqInt address);
static sqInt NoDbgRegParms addressIsInFixups(AbstractInstruction *address);
static sqInt NoDbgRegParms addressIsInInstructions(AbstractInstruction *address);
static sqInt NoDbgRegParms addressOfEndOfCaseinCPIC(sqInt n, CogMethod *cPIC);
static sqInt NoDbgRegParms alignUptoRoutineBoundary(sqInt anAddress);
static sqInt allMachineCodeObjectReferencesValid(void);
static sqInt allMethodsHaveCorrectHeader(void);
static AbstractInstruction * NoDbgRegParms annotateAbsolutePCRef(AbstractInstruction *abstractInstruction);
static AbstractInstruction * NoDbgRegParms annotateBytecode(AbstractInstruction *abstractInstruction);
static AbstractInstruction * NoDbgRegParms annotateobjRef(AbstractInstruction *abstractInstruction, sqInt anOop);
static void NoDbgRegParms assertSaneJumpTarget(AbstractInstruction *jumpTarget);
static sqInt NoDbgRegParms blockCreationBytecodeSizeForHeader(sqInt aMethodHeader);
static sqInt NoDbgRegParms blockDispatchTargetsForperformarg(CogMethod *cogMethod, usqInt (*binaryFunction)(sqInt mcpc, sqInt arg), sqInt arg);
extern sqInt bytecodePCForstartBcpcin(sqInt mcpc, sqInt startbcpc, CogBlockMethod *cogMethod);
static AbstractInstruction * NoDbgRegParms gCall(sqInt callTarget);
static AbstractInstruction * NoDbgRegParms gCmpCqR(sqInt quickConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gCmpCwR(sqInt wordConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gCmpRR(sqInt reg1, sqInt reg2);
extern void callCogCodePopReceiver(void);
extern void callCogCodePopReceiverAndClassRegs(void);
extern sqInt ceCPICMissreceiver(CogMethod *cPIC, sqInt receiver);
extern sqInt ceSICMiss(sqInt receiver);
extern void checkAssertsEnabledInCogit(void);
static sqInt NoDbgRegParms checkIfValidOopRefAndTargetpccogMethod(sqInt annotation, char *mcpc, sqInt cogMethod);
static sqInt NoDbgRegParms checkIfValidOopRefpccogMethod(sqInt annotation, char *mcpc, sqInt cogMethod);
extern sqInt checkIntegrityOfObjectReferencesInCode(sqInt gcModes);
static sqInt NoDbgRegParms checkMaybeObjRefInClosedPIC(sqInt maybeObject);
static sqInt NoDbgRegParms checkValidObjectReferencesInClosedPIC(CogMethod *cPIC);
static sqInt NoDbgRegParms closedPICRefersToUnmarkedObject(CogMethod *cPIC);
extern char * codeEntryFor(char *address);
extern char * codeEntryNameFor(char *address);
extern sqInt cogCodeBase(void);
extern sqInt cogCodeConstituents(void);
static sqInt NoDbgRegParms cogExtendPICCaseNMethodtagisMNUCase(CogMethod *cPIC, sqInt caseNMethod, sqInt caseNTag, sqInt isMNUCase);
extern void cogitPostGCAction(sqInt gcMode);
extern sqInt cogMethodDoesntLookKosher(CogMethod *cogMethod);
extern CogMethod * cogMNUPICSelectorreceivermethodOperandnumArgs(sqInt selector, sqInt rcvr, sqInt methodOperand, sqInt numArgs);
static CogMethod * NoDbgRegParms cogOpenPICSelectornumArgs(sqInt selector, sqInt numArgs);
static CogMethod * NoDbgRegParms cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase(sqInt selector, sqInt numArgs, CogMethod *case0CogMethod, sqInt case1MethodOrNil, sqInt case1Tag, sqInt isMNUCase);
extern CogMethod * cogselector(sqInt aMethodObj, sqInt aSelectorOop);
extern void compactCogCompiledCode(void);
static AbstractInstruction * compileAbort(void);
static sqInt NoDbgRegParms compileBlockDispatchFromto(sqInt lowBlockStartIndex, sqInt highBlockStartIndex);
static void NoDbgRegParms compileBlockEntry(BlockStart *blockStart);
static void NoDbgRegParms compileCallFornumArgsargargargargresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask);
static AbstractInstruction * compileCPICEntry(void);
static void compileEntry(void);
static sqInt compileMethodBody(void);
static sqInt NoDbgRegParms compilePICAbort(sqInt numArgs);
static void NoDbgRegParms compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone);
static void computeEntryOffsets(void);
static void computeMaximumSizes(void);
static sqInt NoDbgRegParms configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(CogMethod *cPIC, CogMethod *case0CogMethod, sqInt case1Method, sqInt case1Tag, sqInt isMNUCase, sqInt numArgs, sqInt addrDelta);
static sqInt NoDbgRegParms configureMNUCPICmethodOperandnumArgsdelta(CogMethod *cPIC, sqInt methodOperand, sqInt numArgs, sqInt addrDelta);
static sqInt NoDbgRegParms cPICHasForwardedClass(CogMethod *cPIC);
static sqInt NoDbgRegParms cPICHasFreedTargets(CogMethod *cPIC);
static sqInt cPICPrototypeCaseOffset(void);
static sqInt NoDbgRegParms cPICHasTarget(CogMethod *cPIC, CogMethod *targetMethod);
static AbstractInstruction * NoDbgRegParms gDivRRQuoRem(sqInt rDivisor, sqInt rDividend, sqInt rQuotient, sqInt rRemainder);
extern sqInt defaultCogCodeSize(void);
static sqInt NoDbgRegParms deltaToSkipPrimAndErrorStoreInheader(sqInt aMethodObj, sqInt aMethodHeader);
static sqInt NoDbgRegParms endPCOf(sqInt aMethod);
extern void enterCogCodePopReceiver(void);
static sqInt NoDbgRegParms expectedClosedPICPrototype(CogMethod *cPIC);
static sqInt NoDbgRegParms fillInBlockHeadersAt(sqInt startAddress);
static CogMethod * NoDbgRegParms fillInMethodHeadersizeselector(CogMethod *method, sqInt size, sqInt selector);
static usqInt NoDbgRegParms findBlockMethodWithEntrystartBcpc(sqInt blockEntryMcpc, sqInt startBcpc);
static sqInt NoDbgRegParms findMapLocationForMcpcinMethod(sqInt targetMcpc, CogMethod *cogMethod);
extern CogBlockMethod * findMethodForStartBcpcinHomeMethod(sqInt startbcpc, CogMethod *cogMethod);
static sqInt NoDbgRegParms findIsBackwardBranchMcpcBcpcMatchingMcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranch, char *mcpc, sqInt bcpc, void *targetMcpc);
extern void followForwardedLiteralsIn(CogMethod *cogMethod);
extern void followForwardedMethods(void);
static sqInt NoDbgRegParms followMaybeObjRefInClosedPICAt(sqInt mcpc);
static sqInt NoDbgRegParms followMethodReferencesInClosedPIC(CogMethod *cPIC);
static void freePICsWithFreedTargets(void);
extern void freeUnmarkedMachineCode(void);
static sqInt genCheckForInterruptsTrampoline(void);
static AbstractInstruction * NoDbgRegParms genConditionalBranchoperand(sqInt opcode, sqInt operandOne);
static void (*genEnilopmartForandandforCallcalled(sqInt regArg1, sqInt regArg2OrNone, sqInt regArg3OrNone, sqInt forCall, char *trampolineName))(void) ;
static void NoDbgRegParms genEnilopmartReturn(sqInt forCall);
static void NoDbgRegParms generateCaptureCStackPointers(sqInt captureFramePointer);
static void generateClosedPICPrototype(void);
static CogMethod * NoDbgRegParms generateCogMethod(sqInt selector);
static sqInt NoDbgRegParms generateInstructionsAt(sqInt eventualAbsoluteAddress);
static sqInt NoDbgRegParms generateMapAtstart(sqInt addressOrNull, sqInt startAddress);
static void generateOpenPICPrototype(void);
static void generateRunTimeTrampolines(void);
static void generateStackPointerCapture(void);
static void generateTrampolines(void);
static void genGetLeafCallStackPointer(void);
static sqInt NoDbgRegParms genInnerPICAbortTrampoline(char *name);
static sqInt genLoadCStackPointersForPrimCall(void);
static void NoDbgRegParms genLoadInlineCacheWithSelector(sqInt selectorIndex);
static sqInt genNonLocalReturnTrampoline(void);
static sqInt NoDbgRegParms genReturnTrampolineForcalledarg(void *aRoutine, char *aString, sqInt regOrConst0);
static sqInt NoDbgRegParms genSmalltalkToCStackSwitch(sqInt pushLinkReg);
static sqInt NoDbgRegParms genTrampolineForcalled(void *aRoutine, char *aString);
static sqInt NoDbgRegParms genTrampolineForcalledargargarg(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2);
static sqInt NoDbgRegParms genTrampolineForcalledargargargresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt resultReg);
static sqInt NoDbgRegParms genTrampolineForcalledargargregsToSave(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regMask);
static sqInt NoDbgRegParms genTrampolineForcalledargargresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt resultReg);
static sqInt NoDbgRegParms genTrampolineForcalledargregsToSave(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regMask);
static sqInt NoDbgRegParms genTrampolineForcalledargregsToSaveresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regMask, sqInt resultReg);
static sqInt NoDbgRegParms genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean);
static sqInt NoDbgRegParms genTrampolineForcalledregsToSave(void *aRoutine, char *aString, sqInt regMask);
static AbstractInstruction * NoDbgRegParms gen(sqInt opcode);
static AbstractInstruction * NoDbgRegParms genoperand(sqInt opcode, sqInt operand);
static AbstractInstruction * NoDbgRegParms genoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo);
static AbstractInstruction * NoDbgRegParms genoperandoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo, sqInt operandThree);
static sqInt NoDbgRegParms getLiteral(sqInt litIndex);
static sqInt NoDbgRegParms incrementUsageOfTargetIfLinkedSendmcpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static sqInt NoDbgRegParms indexForSelectorinat(sqInt selector, CogMethod *cogMethod, sqInt mcpc);
static sqInt initialClosedPICUsageCount(void);
static void initializeBackend(void);
extern void initializeCodeZoneFromupTo(sqInt startAddress, sqInt endAddress);
static sqInt initialMethodUsageCount(void);
static sqInt initialOpenPICUsageCount(void);
static sqInt NoDbgRegParms inlineCacheValueForSelectorinat(sqInt selector, sqInt aCogMethod, sqInt mcpc);
static sqInt NoDbgRegParms inverseBranchFor(sqInt opcode);
static sqInt NoDbgRegParms isBackwardBranchatextsin(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms isPCMappedAnnotation(sqInt annotation);
extern sqInt isPCWithinMethodZone(void *address);
extern sqInt isSendReturnPC(sqInt retpc);
static AbstractInstruction * NoDbgRegParms gJumpFPEqual(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpFPGreaterOrEqual(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpFPGreater(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpFPNotEqual(void *jumpTarget);
static AbstractInstruction * NoDbgRegParms gJumpNonZero(void *jumpTarget);
static AbstractInstruction * gLabel(void);
static AbstractInstruction * NoDbgRegParms gLogicalShiftLeftCqR(sqInt quickConstant, sqInt reg);
static AbstractInstruction * lastOpcode(void);
extern void linkSendAtintooffsetreceiver(sqInt callSiteReturnAddress, CogMethod *sendingMethod, CogMethod *targetMethod, sqInt theEntryOffset, sqInt receiver);
static void NoDbgRegParms loadSubsequentBytesForDescriptorat(BytecodeDescriptor *descriptor, sqInt pc);
static AbstractInstruction * NoDbgRegParms gMoveAwR(sqInt address, sqInt reg);
static AbstractInstruction * NoDbgRegParms gMoveCwR(sqInt wordConstant, sqInt reg);
static AbstractInstruction * NoDbgRegParms gMoveRMwr(sqInt sourceReg, sqInt offset, sqInt baseReg);
static AbstractInstruction * NoDbgRegParms gMoveRR(sqInt reg1, sqInt reg2);
static sqInt NoDbgRegParms mapEndFor(CogMethod *cogMethod);
static sqInt NoDbgRegParms mapForperformUntilarg(CogMethod *cogMethod, sqInt (*functionSymbol)(sqInt annotation, char *mcpc, sqInt arg), sqInt arg);
static sqInt NoDbgRegParms mapObjectReferencesInClosedPIC(CogMethod *cPIC);
static void mapObjectReferencesInGeneratedRuntime(void);
static void mapObjectReferencesInMachineCodeForBecome(void);
static void mapObjectReferencesInMachineCodeForFullGC(void);
static void mapObjectReferencesInMachineCodeForYoungGC(void);
extern void mapObjectReferencesInMachineCode(sqInt gcMode);
extern void markAndTraceMachineCodeOfMarkedMethods(void);
static void markAndTraceObjectReferencesInGeneratedRuntime(void);
static sqInt NoDbgRegParms markAndTraceOrFreeCogMethodfirstVisit(CogMethod *cogMethod, sqInt firstVisit);
static sqInt NoDbgRegParms markAndTraceOrFreePICTargetin(sqInt entryPoint, CogMethod *cPIC);
static sqInt NoDbgRegParms markLiteralsAndUnlinkIfUnmarkedSendpcmethod(sqInt annotation, char *mcpc, sqInt cogMethod);
static sqInt NoDbgRegParms markLiteralspcmethod(sqInt annotation, char *mcpc, sqInt cogMethod);
extern void markMethodAndReferents(CogBlockMethod *aCogMethod);
extern usqInt maxCogMethodAddress(void);
static sqInt maybeAllocAndInitIRCs(void);
static sqInt NoDbgRegParms maybeFreeCogMethodDoesntLookKosher(CogMethod *cogMethod);
static void NoDbgRegParms maybeMarkCountersIn(CogMethod *cogMethod);
static sqInt mclassIsSmallInteger(void);
extern usqInt mcPCForBackwardBranchstartBcpcin(sqInt bcpc, sqInt startbcpc, CogBlockMethod *cogMethod);
static sqInt NoDbgRegParms methodhasSameCodeAscheckPenultimate(sqInt methodA, sqInt methodB, sqInt comparePenultimateLiteral);
extern sqInt minCogMethodAddress(void);
extern sqInt mnuOffset(void);
static AbstractInstruction * NoDbgRegParms gNegateR(sqInt reg);
static sqInt NoDbgRegParms needsFrameIfImmutability(sqInt stackDelta);
static sqInt NoDbgRegParms needsFrameIfInBlock(sqInt stackDelta);
static sqInt NoDbgRegParms needsFrameNever(sqInt stackDelta);
static sqInt NoDbgRegParms noAssertMethodClassAssociationOf(sqInt methodPointer);
static sqInt noCogMethodsMaximallyMarked(void);
static sqInt NoDbgRegParms noTargetsFreeInClosedPIC(sqInt cPIC);
static sqInt NoDbgRegParms outputInstructionsAt(sqInt startAddress);
static sqInt NoDbgRegParms outputInstructionsForGeneratedRuntimeAt(sqInt startAddress);
static AbstractInstruction * NoDbgRegParms gPushCw(sqInt wordConstant);
extern sqInt patchToOpenPICFornumArgsreceiver(sqInt selector, sqInt numArgs, sqInt receiver);
static sqInt picAbortDiscriminatorValue(void);
static sqInt picInterpretAbortOffset(void);
static AbstractInstruction * previousInstruction(void);
extern void printCogMethodFor(void *address);
extern void printPCMapPairsFor(CogMethod *cogMethod);
extern void printTrampolineTable(void);
static sqInt processorHasDivQuoRemAndMClassIsSmallInteger(void);
static sqInt processorHasMultiplyAndMClassIsSmallInteger(void);
static AbstractInstruction * NoDbgRegParms gRotateRightCqR(sqInt quickConstant, sqInt reg);
static void NoDbgRegParms recordGeneratedRunTimeaddress(char *aString, sqInt address);
extern sqInt recordPrimTraceFunc(void);
static void recordRunTimeObjectReferences(void);
static sqInt NoDbgRegParms registerMaskFor(sqInt reg);
static sqInt NoDbgRegParms registerMaskForand(sqInt reg1, sqInt reg2);
static void NoDbgRegParms relocateCallsAndSelfReferencesInMethod(CogMethod *cogMethod);
static void NoDbgRegParms relocateCallsInClosedPIC(CogMethod *cPIC);
static sqInt NoDbgRegParms relocateIfCallOrMethodReferencemcpcdelta(sqInt annotation, char *mcpc, sqInt refDelta);
static sqInt NoDbgRegParms remapIfObjectRefpchasYoung(sqInt annotation, char *mcpc, sqInt hasYoungPtr);
static sqInt NoDbgRegParms remapMaybeObjRefInClosedPICAt(sqInt mcpc);
static void NoDbgRegParms rewriteCPICCaseAttagobjReftarget(sqInt followingAddress, sqInt newTag, sqInt newObjRef, sqInt newTarget);
static AbstractInstruction * NoDbgRegParms gSubCwR(sqInt wordConstant, sqInt reg);
static sqInt scanForCleanBlocks(void);
extern void setBreakMethod(sqInt anObj);
extern void setPostCompileHook(void (*aFunction)(CogMethod *));
extern void setSelectorOfto(CogMethod *cogMethod, sqInt aSelectorOop);
static sqInt NoDbgRegParms spanForCleanBlockStartingAt(sqInt startPC);
static AbstractInstruction * NoDbgRegParms gTstCqR(sqInt quickConstant, sqInt reg);
extern sqInt traceLinkedSendOffset(void);
static sqInt NoDbgRegParms trampolineArgConstant(sqInt booleanOrInteger);
static char * NoDbgRegParms trampolineNamenumArgs(char *routinePrefix, sqInt numArgs);
static char * NoDbgRegParms trampolineNamenumRegArgs(char *routinePrefix, sqInt numArgs);
static sqInt unknownBytecode(void);
extern void unlinkAllSends(void);
static sqInt NoDbgRegParms unlinkIfFreeOrLinkedSendpcof(sqInt annotation, char *mcpc, sqInt theSelector);
static sqInt NoDbgRegParms unlinkIfInvalidClassSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static sqInt NoDbgRegParms unlinkIfLinkedSendToFreepcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static sqInt NoDbgRegParms unlinkIfLinkedSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static sqInt NoDbgRegParms unlinkIfLinkedSendpcto(sqInt annotation, char *mcpc, sqInt theCogMethod);
extern void unlinkSendsLinkedForInvalidClasses(void);
extern void unlinkSendsOfisMNUSelector(sqInt selector, sqInt isMNUSelector);
extern void unlinkSendsToFree(void);
extern void unlinkSendsToandFreeIf(sqInt targetMethodObject, sqInt freeIfTrue);
static AbstractInstruction * NoDbgRegParms gXorCwR(sqInt wordConstant, sqInt reg);
static void zeroOpcodeIndex(void);
extern void addAllToYoungReferrers(void);
static void NoDbgRegParms addToOpenPICList(CogMethod *anOpenPIC);
static void NoDbgRegParms addToYoungReferrers(CogMethod *cogMethod);
static sqInt alignment(void);
static sqInt NoDbgRegParms allocate(sqInt numBytes);
static void clearCogCompiledCode(void);
static void compactCompiledCode(void);
static void NoDbgRegParms ensureInYoungReferrers(CogMethod *cogMethod);
extern void freeMethod(CogMethod *cogMethod);
static void freeOlderMethodsForCompaction(void);
static sqInt kosherYoungReferrers(void);
static void NoDbgRegParms manageFromto(sqInt theStartAddress, sqInt theLimitAddress);
extern CogMethod * methodFor(void *address);
static sqInt numMethods(void);
extern sqInt numMethodsOfType(sqInt cogMethodType);
static sqInt NoDbgRegParms occurrencesInYoungReferrers(CogMethod *cogMethod);
static CogMethod * NoDbgRegParms openPICWithSelector(sqInt aSelector);
static void planCompaction(void);
extern void printCogMethods(void);
extern void printCogMethodsOfType(sqInt cmType);
extern void printCogMethodsWithMethod(sqInt methodOop);
extern void printCogMethodsWithPrimitive(sqInt primIdx);
extern void printCogMethodsWithSelector(sqInt selectorOop);
extern void printCogYoungReferrers(void);
extern void printOpenPICList(void);
static sqInt pruneYoungReferrers(void);
static sqInt relocateAndPruneYoungReferrers(void);
static sqInt relocateMethodsPreCompaction(void);
static sqInt NoDbgRegParms removeFromOpenPICList(CogMethod *anOpenPIC);
static void voidYoungReferrersPostTenureAll(void);
extern char * whereIsMaybeCodeThing(sqInt anOop);
static sqInt NoDbgRegParms checkValidObjectReference(sqInt anOop);
static AbstractInstruction * NoDbgRegParms genCmpClassFloatCompactIndexR(sqInt reg);
static AbstractInstruction * NoDbgRegParms genCmpClassMethodContextCompactIndexR(sqInt reg);
static sqInt NoDbgRegParms genGetMethodHeaderOfintoscratch(sqInt methodReg, sqInt headerReg, sqInt scratchReg);
static sqInt NoDbgRegParms genLoadSlotsourceRegdestReg(sqInt index, sqInt sourceReg, sqInt destReg);
static sqInt genPrimitiveAdd(void);
static sqInt genPrimitiveAsFloat(void);
static sqInt genPrimitiveBitAnd(void);
static sqInt genPrimitiveBitOr(void);
static sqInt genPrimitiveBitShift(void);
static sqInt genPrimitiveBitXor(void);
static sqInt genPrimitiveClass(void);
static sqInt genPrimitiveDiv(void);
static sqInt genPrimitiveDivide(void);
static sqInt genPrimitiveEqual(void);
static sqInt genPrimitiveFloatAdd(void);
static sqInt genPrimitiveFloatDivide(void);
static sqInt genPrimitiveFloatEqual(void);
static sqInt genPrimitiveFloatGreaterOrEqual(void);
static sqInt genPrimitiveFloatGreaterThan(void);
static sqInt genPrimitiveFloatLessOrEqual(void);
static sqInt genPrimitiveFloatLessThan(void);
static sqInt genPrimitiveFloatMultiply(void);
static sqInt genPrimitiveFloatNotEqual(void);
static sqInt genPrimitiveFloatSquareRoot(void);
static sqInt genPrimitiveFloatSubtract(void);
static sqInt genPrimitiveGreaterOrEqual(void);
static sqInt genPrimitiveGreaterThan(void);
static sqInt genPrimitiveIdentical(void);
static sqInt genPrimitiveLessOrEqual(void);
static sqInt genPrimitiveLessThan(void);
static sqInt genPrimitiveMod(void);
static sqInt genPrimitiveMultiply(void);
static sqInt genPrimitiveNewMethod(void);
static sqInt genPrimitiveNotEqual(void);
static sqInt genPrimitiveNotIdentical(void);
static sqInt genPrimitiveQuo(void);
static sqInt genPrimitiveSmallFloatAdd(void);
static sqInt genPrimitiveSmallFloatDivide(void);
static sqInt genPrimitiveSmallFloatEqual(void);
static sqInt genPrimitiveSmallFloatGreaterOrEqual(void);
static sqInt genPrimitiveSmallFloatGreaterThan(void);
static sqInt genPrimitiveSmallFloatLessOrEqual(void);
static sqInt genPrimitiveSmallFloatLessThan(void);
static sqInt genPrimitiveSmallFloatMultiply(void);
static sqInt genPrimitiveSmallFloatNotEqual(void);
static sqInt genPrimitiveSmallFloatSquareRoot(void);
static sqInt genPrimitiveSmallFloatSubtract(void);
static sqInt genPrimitiveSubtract(void);
static sqInt NoDbgRegParms genSmallIntegerComparison(sqInt jumpOpcode);
static sqInt NoDbgRegParms genSmallIntegerComparisonorDoubleComparisoninvert(sqInt jumpOpcode, AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt invertComparison);
static sqInt NoDbgRegParms isUnannotatableConstant(CogSimStackEntry *simStackEntry);
static sqInt NoDbgRegParms genAddSmallIntegerTagsTo(sqInt aRegister);
static AbstractInstruction * NoDbgRegParms genAllocFloatValueintoscratchRegscratchReg(sqInt dpreg, sqInt resultReg, sqInt scratch1, sqInt scratch2);
static sqInt NoDbgRegParms genClearAndSetSmallIntegerTagsIn(sqInt scratchReg);
static sqInt NoDbgRegParms genConvertBitsToSmallFloatInscratch(sqInt reg, sqInt scratch);
static void NoDbgRegParms genConvertCharacterToSmallIntegerInReg(sqInt reg);
static sqInt NoDbgRegParms genConvertIntegerToSmallIntegerInReg(sqInt reg);
static sqInt NoDbgRegParms genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(sqInt reg, sqInt scratch);
static void NoDbgRegParms genConvertSmallIntegerToCharacterInReg(sqInt reg);
static sqInt NoDbgRegParms genConvertSmallIntegerToIntegerInReg(sqInt reg);
static sqInt NoDbgRegParms genFetchIndexRegisterfrominto(sqInt indexReg, sqInt tableObj, sqInt destReg);
static sqInt NoDbgRegParms genFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed);
static sqInt NoDbgRegParms genFloatComparisoninvertboxed(AbstractInstruction *(*jumpOpcodeGenerator)(void *), sqInt invertComparison, sqInt rcvrBoxed);
static sqInt NoDbgRegParms genGetHashFieldNonImmOfasSmallIntegerInto(sqInt instReg, sqInt destReg);
static sqInt NoDbgRegParms genGetHashFieldNonImmOfinto(sqInt instReg, sqInt destReg);
static AbstractInstruction * NoDbgRegParms genGetInlineCacheClassTagFromintoforEntry(sqInt sourceReg, sqInt destReg, sqInt forEntry);
static sqInt NoDbgRegParms genGetOverflowSlotsOfinto(sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms genGetSmallFloatValueOfscratchinto(sqInt oopReg, sqInt scratch, sqInt dpReg);
static AbstractInstruction * NoDbgRegParms genJumpIsSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg);
static AbstractInstruction * NoDbgRegParms genJumpNotCharacter(sqInt reg);
static AbstractInstruction * NoDbgRegParms genJumpNotSmallFloatValueBitsscratch(sqInt reg, sqInt exponent);
static AbstractInstruction * NoDbgRegParms genJumpNotSmallFloat(sqInt reg);
static AbstractInstruction * NoDbgRegParms genJumpNotSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg);
static AbstractInstruction * NoDbgRegParms genJumpNotSmallInteger(sqInt reg);
static AbstractInstruction * NoDbgRegParms genJumpSmallInteger(sqInt aRegister);
static sqInt genPrimitiveAt(void);
static sqInt genPrimitiveAtPut(void);
static sqInt genPrimitiveIdentityHash(void);
static sqInt genPrimitiveImmediateAsInteger(void);
static sqInt genPrimitiveNew(void);
static sqInt genPrimitiveNewWithArg(void);
static sqInt genPrimitiveStringAt(void);
static sqInt genPrimitiveStringAtPut(void);
static sqInt NoDbgRegParms genRemoveSmallIntegerTagsInScratchReg(sqInt scratchReg);
static sqInt NoDbgRegParms genShiftAwaySmallIntegerTagsInScratchReg(sqInt scratchReg);
static sqInt NoDbgRegParms getLiteralCountOfplusOneinBytesintoscratch(sqInt methodReg, sqInt plusOne, sqInt inBytes, sqInt litCountReg, sqInt scratchReg);
static sqInt NoDbgRegParms inlineCacheTagForInstance(sqInt oop);
static sqInt log2BytesPerWord(void);
static void maybeGenerateSelectorIndexDereferenceRoutine(void);
static sqInt numSmallIntegerBits(void);
static sqInt numSmallIntegerTagBits(void);
static sqInt NoDbgRegParms validInlineCacheTag(sqInt classIndexOrTagPattern);
static sqInt NoDbgRegParms cacheTagIsMarked(sqInt cacheTag);
static sqInt NoDbgRegParms checkValidOopReference(sqInt anOop);
static sqInt NoDbgRegParms couldBeObject(sqInt literal);
static sqInt NoDbgRegParms genActiveContextTrampolineLargeinBlockcalled(sqInt isLarge, sqInt isInBlock, char *aString);
static sqInt NoDbgRegParms genConvertCharacterToCodeInReg(sqInt reg);
static sqInt NoDbgRegParms genConvertIntegerToCharacterInReg(sqInt reg);
static sqInt NoDbgRegParms genCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock);
static sqInt NoDbgRegParms genEnsureObjInRegNotForwardedscratchReg(sqInt reg, sqInt scratch);
static sqInt NoDbgRegParms genEnsureOopInRegNotForwardedscratchReg(sqInt reg, sqInt scratch);
static sqInt NoDbgRegParms genEnsureOopInRegNotForwardedscratchRegjumpBackTo(sqInt reg, sqInt scratch, AbstractInstruction *instruction);
static sqInt NoDbgRegParms genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(sqInt reg, sqInt scratch, sqInt index, sqInt objReg);
static void generateObjectRepresentationTrampolines(void);
static sqInt NoDbgRegParms genGetActiveContextLargeinBlock(sqInt isLarge, sqInt isInBlock);
static sqInt NoDbgRegParms genGetActiveContextNumArgslargeinBlock(sqInt numArgs, sqInt isLargeContext, sqInt isInBlock);
static sqInt NoDbgRegParms genGetBitsofFormatByteOfinto(sqInt mask, sqInt sourceReg, sqInt destReg);
static sqInt NoDbgRegParms genGetClassIndexOfNonImminto(sqInt sourceReg, sqInt destReg);
static sqInt NoDbgRegParms genGetClassObjectOfClassIndexintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static sqInt NoDbgRegParms genGetClassObjectOfintoscratchReginstRegIsReceiver(sqInt instReg, sqInt destReg, sqInt scratchReg, sqInt instRegIsReceiver);
static AbstractInstruction * NoDbgRegParms genGetClassTagOfintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static sqInt NoDbgRegParms genGetCompactClassIndexNonImmOfinto(sqInt instReg, sqInt destReg);
static sqInt NoDbgRegParms genGetDoubleValueOfinto(sqInt srcReg, sqInt destFPReg);
static sqInt NoDbgRegParms genGetFormatOfinto(sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(sqInt sourceReg, sqInt destReg, sqInt scratchRegOrNone);
static sqInt NoDbgRegParms genGetNumSlotsOfinto(sqInt srcReg, sqInt destReg);
static sqInt NoDbgRegParms genGetRawSlotSizeOfNonImminto(sqInt sourceReg, sqInt destReg);
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms genJumpBaseHeaderImmutable(sqInt baseHeaderReg);
#endif /* IMMUTABILITY */
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms genJumpBaseHeaderMutable(sqInt baseHeaderReg);
#endif /* IMMUTABILITY */
static AbstractInstruction * NoDbgRegParms genJumpImmediate(sqInt aRegister);
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms genJumpMutablescratchReg(sqInt sourceReg, sqInt scratchReg);
#endif /* IMMUTABILITY */
static sqInt NoDbgRegParms genNewArrayOfSizeinitialized(sqInt size, sqInt initialized);
static sqInt NoDbgRegParms genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock);
static sqInt genPrimitiveAsCharacter(void);
static sqInt NoDbgRegParms genPrimitiveIdenticalOrNotIf(sqInt orNot);
static sqInt genPrimitiveObjectAt(void);
static sqInt genPrimitiveSize(void);
static sqInt NoDbgRegParms genSetSmallIntegerTagsIn(sqInt scratchReg);
static sqInt genStoreCheckContextReceiverTrampoline(void);
static sqInt NoDbgRegParms genStoreCheckReceiverRegvalueRegscratchReginFrame(sqInt destReg, sqInt valueReg, sqInt scratchReg, sqInt inFrame);
static sqInt NoDbgRegParms genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt inFrame, sqInt needsStoreCheck);
static sqInt NoDbgRegParms genStoreSourceRegslotIndexintoNewObjectInDestReg(sqInt sourceReg, sqInt index, sqInt destReg);
static sqInt getActiveContextAllocatesInMachineCode(void);
static sqInt NoDbgRegParms inlineCacheTagIsYoung(sqInt cacheTag);
static AbstractInstruction * NoDbgRegParms jumpNotCharacterUnsignedValueInRegister(sqInt reg);
static sqInt NoDbgRegParms markAndTraceLiteralinatpc(sqInt literal, CogMethod *cogMethodOrNil, usqInt address);
static void NoDbgRegParms markAndTraceLiteralinat(sqInt literal, CogMethod *cogMethod, sqInt *address);
static void NoDbgRegParms markAndTraceUpdatedLiteralin(sqInt objOop, CogMethod *cogMethodOrNil);
static sqInt NoDbgRegParms maybeCompileRetryonPrimitiveFail(AbstractInstruction *retryInst, sqInt primIndex);
static sqInt numCharacterBits(void);
extern sqInt numRegArgs(void);
static sqInt NoDbgRegParms remapObject(sqInt objOop);
static sqInt NoDbgRegParms remapOop(sqInt objOop);
static sqInt NoDbgRegParms shouldAnnotateObjectReference(sqInt anOop);
static sqInt NoDbgRegParms slotOffsetOfInstVarIndex(sqInt index);
static CogSimStackEntry * NoDbgRegParms ensureSpilledAtfrom(CogSimStackEntry * self_in_ensureSpilledAtfrom, sqInt baseOffset, sqInt baseRegister);
static CogSimStackEntry * NoDbgRegParms mergeAtfrom(CogSimStackEntry * self_in_mergeAtfrom, sqInt baseOffset, sqInt baseRegister);
static CogSimStackEntry * NoDbgRegParms popToReg(CogSimStackEntry * self_in_popToReg, sqInt reg);
static sqInt NoDbgRegParms registerMask(CogSimStackEntry * self_in_registerMask);
static sqInt NoDbgRegParms registerOrNone(CogSimStackEntry * self_in_registerOrNone);
static CogSimStackEntry * NoDbgRegParms storeToReg(CogSimStackEntry * self_in_storeToReg, sqInt reg);
static sqInt NoDbgRegParms callerSavedRegisterMask(AbstractInstruction * self_in_callerSavedRegisterMask);
static sqInt NoDbgRegParms callFullTargetFromReturnAddress(AbstractInstruction * self_in_callFullTargetFromReturnAddress, sqInt callSiteReturnAddress);
static sqInt NoDbgRegParms callInstructionByteSize(AbstractInstruction * self_in_callInstructionByteSize);
static sqInt NoDbgRegParms callTargetFromReturnAddress(AbstractInstruction * self_in_callTargetFromReturnAddress, sqInt callSiteReturnAddress);
static sqInt NoDbgRegParms cmpC32RTempByteSize(AbstractInstruction * self_in_cmpC32RTempByteSize);
static sqInt NoDbgRegParms computeMaximumSize(AbstractInstruction * self_in_computeMaximumSize);
static sqInt NoDbgRegParms computeShiftRRSize(AbstractInstruction * self_in_computeShiftRRSize);
static usqInt NoDbgRegParms concretizeArithCqRWithROraxOpcode(AbstractInstruction * self_in_concretizeArithCqRWithROraxOpcode, sqInt regOpcode, sqInt raxOpcode);
static usqInt NoDbgRegParms concretizeFill32(AbstractInstruction * self_in_concretizeFill32);
static usqInt NoDbgRegParms concretizeMoveRX32rR(AbstractInstruction * self_in_concretizeMoveRX32rR);
static usqInt NoDbgRegParms concretizeMoveX32rRR(AbstractInstruction * self_in_concretizeMoveX32rRR);
static usqInt NoDbgRegParms concretizeOpRR(AbstractInstruction * self_in_concretizeOpRR, sqInt x64opcode);
static usqInt NoDbgRegParms concretizePrefetchAw(AbstractInstruction * self_in_concretizePrefetchAw);
static usqInt NoDbgRegParms concretizeReverseOpRR(AbstractInstruction * self_in_concretizeReverseOpRR, sqInt x64opcode);
static usqInt NoDbgRegParms concretizeXCHGRR(AbstractInstruction * self_in_concretizeXCHGRR);
static void NoDbgRegParms dispatchConcretize(AbstractInstruction * self_in_dispatchConcretize);
static sqInt NoDbgRegParms fullCallsAreRelative(AbstractInstruction * self_in_fullCallsAreRelative);
static AbstractInstruction * NoDbgRegParms genDivRRQuoRem(AbstractInstruction * self_in_genDivRRQuoRem, sqInt abstractRegDivisor, sqInt abstractRegDividend, sqInt abstractRegQuotient, sqInt abstractRegRemainder);
static sqInt NoDbgRegParms genLoadCStackPointer(AbstractInstruction * self_in_genLoadCStackPointer);
static sqInt NoDbgRegParms genLoadCStackPointers(AbstractInstruction * self_in_genLoadCStackPointers);
static sqInt NoDbgRegParms genLoadStackPointers(AbstractInstruction * self_in_genLoadStackPointers);
static AbstractInstruction * NoDbgRegParms genMulRR(AbstractInstruction * self_in_genMulRR, sqInt regSource, sqInt regDest);
static AbstractInstruction * NoDbgRegParms genPushRegisterArgsForAbortMissNumArgs(AbstractInstruction * self_in_genPushRegisterArgsForAbortMissNumArgs, sqInt numArgs);
static AbstractInstruction * NoDbgRegParms genPushRegisterArgsForNumArgsscratchReg(AbstractInstruction * self_in_genPushRegisterArgsForNumArgsscratchReg, sqInt numArgs, sqInt scratchReg);
static sqInt NoDbgRegParms genRemoveNArgsFromStack(AbstractInstruction * self_in_genRemoveNArgsFromStack, sqInt n);
static sqInt NoDbgRegParms genRestoreRegsExcept(AbstractInstruction * self_in_genRestoreRegsExcept, sqInt preservedReg);
static sqInt NoDbgRegParms genRestoreRegs(AbstractInstruction * self_in_genRestoreRegs, sqInt regMask);
static sqInt NoDbgRegParms genSaveRegs(AbstractInstruction * self_in_genSaveRegs, sqInt regMask);
static sqInt NoDbgRegParms genSaveStackPointers(AbstractInstruction * self_in_genSaveStackPointers);
static AbstractInstruction * NoDbgRegParms genSubstituteReturnAddress(AbstractInstruction * self_in_genSubstituteReturnAddress, sqInt retpc);
static sqInt NoDbgRegParms instructionSizeAt(AbstractInstruction * self_in_instructionSizeAt, sqInt pc);
static sqInt NoDbgRegParms is32BitSignedImmediate(AbstractInstruction * self_in_is32BitSignedImmediate, sqInt a64BitUnsignedOperand);
static sqInt NoDbgRegParms isAddressRelativeToVarBase(AbstractInstruction * self_in_isAddressRelativeToVarBase, usqInt varAddress);
static sqInt NoDbgRegParms isCallPrecedingReturnPC(AbstractInstruction * self_in_isCallPrecedingReturnPC, sqInt mcpc);
static sqInt NoDbgRegParms isJumpAt(AbstractInstruction * self_in_isJumpAt, sqInt pc);
static sqInt NoDbgRegParms isQuick(AbstractInstruction * self_in_isQuick, unsigned long operand);
static sqInt NoDbgRegParms isSignExtendedFourByteValue(AbstractInstruction * self_in_isSignExtendedFourByteValue, sqInt unsigned64BitValue);
static sqInt NoDbgRegParms isWithinMwOffsetRange(AbstractInstruction * self_in_isWithinMwOffsetRange, sqInt anAddress);
static AbstractInstruction * NoDbgRegParms jmpTarget(AbstractInstruction * self_in_jmpTarget, AbstractInstruction *anAbstractInstruction);
static sqInt NoDbgRegParms jumpLongByteSize(AbstractInstruction * self_in_jumpLongByteSize);
static sqInt NoDbgRegParms jumpLongConditionalByteSize(AbstractInstruction * self_in_jumpLongConditionalByteSize);
static sqInt NoDbgRegParms jumpLongTargetBeforeFollowingAddress(AbstractInstruction * self_in_jumpLongTargetBeforeFollowingAddress, sqInt mcpc);
static usqInt NoDbgRegParms jumpTargetPCAt(AbstractInstruction * self_in_jumpTargetPCAt, sqInt pc);
static sqInt NoDbgRegParms leafCallStackPointerDelta(AbstractInstruction * self_in_leafCallStackPointerDelta);
static sqInt NoDbgRegParms loadPICLiteralByteSize(AbstractInstruction * self_in_loadPICLiteralByteSize);
static usqInt NoDbgRegParms machineCodeAt(AbstractInstruction * self_in_machineCodeAt, sqInt anOffset);
static sqInt NoDbgRegParms machineCodeBytes(AbstractInstruction * self_in_machineCodeBytes);
static sqInt NoDbgRegParms modRMRO(AbstractInstruction * self_in_modRMRO, sqInt mod, sqInt regMode, sqInt regOpcode);
static sqInt NoDbgRegParms numIntRegArgs(AbstractInstruction * self_in_numIntRegArgs);
static AbstractInstruction * NoDbgRegParms padIfPossibleWithStopsFromto(AbstractInstruction * self_in_padIfPossibleWithStopsFromto, sqInt startAddr, sqInt endAddr);
static AbstractInstruction * NoDbgRegParms relocateCallBeforeReturnPCby(AbstractInstruction * self_in_relocateCallBeforeReturnPCby, sqInt retpc, sqInt delta);
static AbstractInstruction * NoDbgRegParms relocateMethodReferenceBeforeAddressby(AbstractInstruction * self_in_relocateMethodReferenceBeforeAddressby, sqInt pc, sqInt delta);
static sqInt NoDbgRegParms rewriteCallAttarget(AbstractInstruction * self_in_rewriteCallAttarget, usqInt callSiteReturnAddress, usqInt callTargetAddress);
static sqInt NoDbgRegParms rewriteCallFullAttarget(AbstractInstruction * self_in_rewriteCallFullAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static sqInt NoDbgRegParms rewriteCPICJumpAttarget(AbstractInstruction * self_in_rewriteCPICJumpAttarget, usqInt addressFollowingJump, usqInt jumpTargetAddress);
static sqInt NoDbgRegParms rewriteInlineCacheAttagtarget(AbstractInstruction * self_in_rewriteInlineCacheAttagtarget, usqInt callSiteReturnAddress, sqInt cacheTag, usqInt callTargetAddress);
static AbstractInstruction * NoDbgRegParms rewriteInlineCacheTagat(AbstractInstruction * self_in_rewriteInlineCacheTagat, sqInt cacheTag, sqInt callSiteReturnAddress);
static sqInt NoDbgRegParms rewriteJumpFullAttarget(AbstractInstruction * self_in_rewriteJumpFullAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static sqInt NoDbgRegParms rexRxb(AbstractInstruction * self_in_rexRxb, sqInt reg, sqInt sibReg, sqInt fieldReg);
static sqInt NoDbgRegParms rexwrxb(AbstractInstruction * self_in_rexwrxb, sqInt width64, sqInt reg, sqInt sibReg, sqInt fieldReg);
static sqInt NoDbgRegParms setsConditionCodesFor(AbstractInstruction * self_in_setsConditionCodesFor, sqInt aConditionalJumpOpcode);
static sqInt NoDbgRegParms sizeHasModrmat(AbstractInstruction * self_in_sizeHasModrmat, sqInt op, sqInt pc);
static sqInt NoDbgRegParms sizeImmediateGroup1at(AbstractInstruction * self_in_sizeImmediateGroup1at, sqInt op, sqInt pc);
static AbstractInstruction * NoDbgRegParms stopsFromto(AbstractInstruction * self_in_stopsFromto, sqInt startAddr, sqInt endAddr);
static AbstractInstruction * NoDbgRegParms storeLiteral32beforeFollowingAddress(AbstractInstruction * self_in_storeLiteral32beforeFollowingAddress, sqInt literal, sqInt followingAddress);
static sqInt NoDbgRegParms sib(AbstractInstruction * self_in_sib, sqInt scale, sqInt indexReg, sqInt baseReg);
static sqInt NoDbgRegParms twoByteInstructionSizeAt(AbstractInstruction * self_in_twoByteInstructionSizeAt, sqInt pc);
static sqInt NoDbgRegParms zoneCallsAreRelative(AbstractInstruction * self_in_zoneCallsAreRelative);
static sqInt compileBlockDispatch(void);
static void compileGetErrorCode(void);
static sqInt NoDbgRegParms compileInterpreterPrimitive(void (*primitiveRoutine)(void));
static AbstractInstruction * NoDbgRegParms compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selector, sqInt shift, sqInt baseRegOrNone);
static void NoDbgRegParms compileOpenPICnumArgs(sqInt selector, sqInt numArgs);
static AbstractInstruction * NoDbgRegParms compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selectorReg, sqInt shift, sqInt baseRegOrNone);
static sqInt compilePrimitive(void);
static sqInt extendedPushBytecode(void);
static sqInt extendedStoreAndPopBytecode(void);
static sqInt extendedStoreBytecode(void);
static sqInt NoDbgRegParms frameOffsetOfTemporary(sqInt index);
static sqInt genBlockReturn(void);
static AbstractInstruction * NoDbgRegParms genDoubleFailIfZeroArgRcvrarg(sqInt rcvrReg, sqInt argReg);
static sqInt genExtendedSendBytecode(void);
static sqInt genExtendedSuperBytecode(void);
static sqInt genFastPrimFail(void);
static void NoDbgRegParms genFastPrimTraceUsingand(sqInt r1, sqInt r2);
static sqInt genLongJumpIfFalse(void);
static sqInt genLongJumpIfTrue(void);
static sqInt genLongStoreAndPopTemporaryVariableBytecode(void);
static sqInt genLongUnconditionalBackwardJump(void);
static sqInt genLongUnconditionalForwardJump(void);
static sqInt NoDbgRegParms genLookupForPerformNumArgs(sqInt numArgs);
static AbstractInstruction * NoDbgRegParms genMoveFalseR(sqInt reg);
static AbstractInstruction * NoDbgRegParms genMoveTrueR(sqInt reg);
static sqInt NoDbgRegParms genMustBeBooleanTrampolineForcalled(sqInt boolean, char *trampolineName);
static void NoDbgRegParms genPrimReturnEnterCogCodeEnilopmart(sqInt profiling);
static sqInt genPushClosureTempsBytecode(void);
static sqInt genPushConstantFalseBytecode(void);
static sqInt genPushConstantNilBytecode(void);
static sqInt genPushConstantTrueBytecode(void);
static sqInt genPushLiteralConstantBytecode(void);
static sqInt NoDbgRegParms genPushLiteralIndex(sqInt literalIndex);
static sqInt genPushLiteralVariableBytecode(void);
static sqInt genPushQuickIntegerConstantBytecode(void);
static sqInt genPushReceiverVariableBytecode(void);
static sqInt genPushTemporaryVariableBytecode(void);
extern sqInt genQuickReturnConst(void);
extern sqInt genQuickReturnInstVar(void);
extern sqInt genQuickReturnSelf(void);
static sqInt genReturnFalse(void);
static sqInt genReturnNil(void);
static sqInt genReturnTrue(void);
static sqInt genSecondExtendedSendBytecode(void);
static sqInt genSendLiteralSelector0ArgsBytecode(void);
static sqInt genSendLiteralSelector1ArgBytecode(void);
static sqInt genSendLiteralSelector2ArgsBytecode(void);
static sqInt genShortJumpIfFalse(void);
static sqInt genShortUnconditionalJump(void);
static sqInt genSpecialSelectorSend(void);
static sqInt genStoreAndPopReceiverVariableBytecode(void);
static sqInt genStoreAndPopRemoteTempLongBytecode(void);
static sqInt genStoreAndPopTemporaryVariableBytecode(void);
static sqInt genStoreRemoteTempLongBytecode(void);
static void maybeCompileAllocFillerCheck(void);
static sqInt numSpecialSelectors(void);
static PrimitiveDescriptor * primitiveGeneratorOrNil(void);
extern void recordCallOffsetIn(CogMethod *cogMethod);
static sqInt NoDbgRegParms registerisInMask(sqInt reg, sqInt mask);
static sqInt returnRegForStoreCheck(void);
extern void rewritePrimInvocationInto(CogMethod *cogMethod, void (*primFunctionPointer)(void));
static sqInt NoDbgRegParms v3BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v3LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v3LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt NoDbgRegParms v3ShortForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
extern void voidCogCompiledCode(void);
static BlockStart * NoDbgRegParms addBlockStartAtnumArgsnumCopiedspan(sqInt bytecodepc, sqInt numArgs, sqInt numCopied, sqInt span);
static void NoDbgRegParms adjustArgumentsForPerform(sqInt numArgs);
static sqInt NoDbgRegParms allocateRegForStackEntryAtnotConflictingWith(sqInt index, sqInt regMask);
static sqInt NoDbgRegParms allocateRegNotConflictingWith(sqInt regMask);
static void NoDbgRegParms annotateBytecodeIfAnnotated(CogSimStackEntry *aSimStackEntry);
static sqInt NoDbgRegParms anyReferencesToRegisterinTopNItems(sqInt reg, sqInt n);
extern void callCogCodePopReceiverArg0Regs(void);
extern void callCogCodePopReceiverArg1Arg0Regs(void);
static sqInt NoDbgRegParms compileAbstractInstructionsFromthrough(sqInt start, sqInt end);
static sqInt compileBlockBodies(void);
static void NoDbgRegParms compileBlockFrameBuild(BlockStart *blockStart);
static void NoDbgRegParms compileBlockFramelessEntry(BlockStart *blockStart);
static CogMethod * NoDbgRegParms compileCogMethod(sqInt selector);
static sqInt compileEntireMethod(void);
static void compileFrameBuild(void);
static sqInt NoDbgRegParms cPICMissTrampolineFor(sqInt numArgs);
static sqInt doubleExtendedDoAnythingBytecode(void);
static sqInt duplicateTopBytecode(void);
static BytecodeFixup * NoDbgRegParms ensureFixupAt(sqInt targetIndex);
static BytecodeFixup * NoDbgRegParms ensureNonMergeFixupAt(sqInt targetIndex);
static void ensureReceiverResultRegContainsSelf(void);
static void NoDbgRegParms evaluateat(BytecodeDescriptor *descriptor, sqInt pc);
static sqInt NoDbgRegParms freeAnyRegNotConflictingWith(sqInt regMask);
static void (*genCallPICEnilopmartNumArgs(sqInt numArgs))(void) ;
static sqInt genCallPrimitiveBytecode(void);
static sqInt NoDbgRegParms genEqualsEqualsNoBranchArgIsConstantrcvrIsConstantargRegrcvrReg(sqInt argIsConstant, sqInt rcvrIsConstant, sqInt argReg, sqInt rcvrRegOrNone);
static sqInt genExternalizePointersForPrimitiveCall(void);
static void generateEnilopmarts(void);
static void generateMissAbortTrampolines(void);
static void generateSendTrampolines(void);
static void generateTracingTrampolines(void);
static sqInt NoDbgRegParms genJumpBackTo(sqInt targetBytecodePC);
static sqInt NoDbgRegParms genJumpIfto(sqInt boolean, sqInt targetBytecodePC);
static sqInt NoDbgRegParms genJumpTo(sqInt targetBytecodePC);
static sqInt NoDbgRegParms genMarshalledSendnumArgssendTable(sqInt selectorIndex, sqInt numArgs, sqInt *sendTable);
static sqInt NoDbgRegParms genMethodAbortTrampolineFor(sqInt numArgs);
static sqInt NoDbgRegParms genPICAbortTrampolineFor(sqInt numArgs);
static sqInt NoDbgRegParms genPICMissTrampolineFor(sqInt numArgs);
static sqInt genPopStackBytecode(void);
static sqInt genPrimitiveClosureValue(void);
static sqInt genPrimitivePerform(void);
static sqInt genPushActiveContextBytecode(void);
static sqInt genPushClosureCopyCopiedValuesBytecode(void);
static sqInt NoDbgRegParms genPushLiteralVariable(sqInt literalIndex);
static sqInt NoDbgRegParms genPushLiteral(sqInt literal);
static sqInt NoDbgRegParms genPushMaybeContextReceiverVariable(sqInt slotIndex);
static sqInt genPushNewArrayBytecode(void);
static sqInt genPushReceiverBytecode(void);
static sqInt NoDbgRegParms genPushReceiverVariable(sqInt index);
static void genPushRegisterArgs(void);
static sqInt genPushRemoteTempLongBytecode(void);
static sqInt NoDbgRegParms genPushTemporaryVariable(sqInt index);
static sqInt genReturnReceiver(void);
static sqInt genReturnTopFromBlock(void);
static sqInt genReturnTopFromMethod(void);
static sqInt NoDbgRegParms genSendSupernumArgs(sqInt selectorIndex, sqInt numArgs);
static sqInt NoDbgRegParms genSendTrampolineFornumArgscalledargargargarg(void *aRoutine, sqInt numArgs, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3);
static sqInt NoDbgRegParms genSendnumArgs(sqInt selectorIndex, sqInt numArgs);
static sqInt genSpecialSelectorArithmetic(void);
static sqInt genSpecialSelectorClass(void);
static sqInt genSpecialSelectorComparison(void);
static sqInt genSpecialSelectorEqualsEquals(void);
static sqInt genSpecialSelectorEqualsEqualsWithForwarders(void);
static sqInt genStaticallyResolvedSpecialSelectorComparison(void);
static sqInt NoDbgRegParms genStorePopLiteralVariable(sqInt popBoolean, sqInt litVarIndex);
static sqInt NoDbgRegParms genStorePopMaybeContextReceiverVariable(sqInt popBoolean, sqInt slotIndex);
static sqInt NoDbgRegParms genStorePopReceiverVariable(sqInt popBoolean, sqInt slotIndex);
static sqInt NoDbgRegParms genStorePopRemoteTempAt(sqInt popBoolean, sqInt slotIndex, sqInt remoteTempIndex);
static sqInt NoDbgRegParms genStorePopTemporaryVariable(sqInt popBoolean, sqInt tempIndex);
static sqInt genUpArrowReturn(void);
static BytecodeFixup * NoDbgRegParms initializeFixupAt(sqInt targetIndex);
static void NoDbgRegParms initSimStackForFramefulMethod(sqInt startpc);
static void NoDbgRegParms initSimStackForFramelessBlock(sqInt startpc);
static void NoDbgRegParms initSimStackForFramelessMethod(sqInt startpc);
static sqInt liveRegisters(void);
static void NoDbgRegParms marshallSendArguments(sqInt numArgs);
static void NoDbgRegParms mergeafterContinuation(BytecodeFixup *fixup, sqInt mergeWithContinuation);
static sqInt NoDbgRegParms methodAbortTrampolineFor(sqInt numArgs);
static sqInt NoDbgRegParms needsFrameIfMod16GENumArgs(sqInt stackDelta);
static sqInt NoDbgRegParms needsFrameIfStackGreaterThanOne(sqInt stackDelta);
static sqInt NoDbgRegParms numberOfSpillsInTopNItems(sqInt n);
static sqInt NoDbgRegParms picAbortTrampolineFor(sqInt numArgs);
static sqInt prevInstIsPCAnnotated(void);
static sqInt NoDbgRegParms pushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils);
static void NoDbgRegParms reinitializeFixupsFromthrough(sqInt start, sqInt end);
static void NoDbgRegParms scanBlock(BlockStart *blockStart);
static sqInt scanMethod(void);
static void NoDbgRegParms ssAllocateCallReg(sqInt requiredReg);
static void NoDbgRegParms ssAllocateCallRegand(sqInt requiredReg1, sqInt requiredReg2);
static void NoDbgRegParms ssAllocateCallRegandand(sqInt requiredReg1, sqInt requiredReg2, sqInt requiredReg3);
static void NoDbgRegParms ssAllocateRequiredRegMaskupThrough(sqInt requiredRegsMask, sqInt stackPtr);
static void NoDbgRegParms ssAllocateRequiredReg(sqInt requiredReg);
static void NoDbgRegParms ssAllocateRequiredRegand(sqInt requiredReg1, sqInt requiredReg2);
static void NoDbgRegParms ssAllocateRequiredRegupThrough(sqInt requiredReg, sqInt stackPtr);
static void NoDbgRegParms ssFlushTo(sqInt index);
static void NoDbgRegParms ssFlushUpThroughReceiverVariable(sqInt slotIndex);
static void NoDbgRegParms ssFlushUpThroughTemporaryVariable(sqInt tempIndex);
static void NoDbgRegParms ssPop(sqInt n);
static sqInt NoDbgRegParms ssPushAnnotatedConstant(sqInt literal);
static sqInt NoDbgRegParms ssPushBaseoffset(sqInt reg, sqInt offset);
static sqInt NoDbgRegParms ssPushConstant(sqInt literal);
static sqInt NoDbgRegParms ssPushDesc(CogSimStackEntry simStackEntry);
static sqInt NoDbgRegParms ssPushRegister(sqInt reg);
static void NoDbgRegParms ssPush(sqInt n);
static void NoDbgRegParms ssStoreAndReplacePoptoReg(sqInt popBoolean, sqInt reg);
static sqInt NoDbgRegParms ssStorePoptoPreferredReg(sqInt popBoolean, sqInt preferredReg);
static void NoDbgRegParms ssStorePoptoReg(sqInt popBoolean, sqInt reg);
static CogSimStackEntry * ssTop(void);
static CogSimStackEntry ssTopDescriptor(void);
static CogSimStackEntry * NoDbgRegParms ssValue(sqInt n);
static sqInt NoDbgRegParms tryCollapseTempVectorInitializationOfSize(sqInt slots);
static void updateSimSpillBase(void);
static sqInt NoDbgRegParms v3PushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils);
static sqInt NoDbgRegParms v3NumPushNils(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);


/*** Variables ***/
static AbstractInstruction * abstractOpcodes;
static AbstractInstruction aMethodLabel;
static AbstractInstruction * const backEnd = &aMethodLabel;
static usqInt baseAddress;
static sqInt blockCount;
static AbstractInstruction * blockEntryLabel;
static AbstractInstruction * blockEntryNoContextSwitch;
sqInt blockNoContextSwitchOffset;
static BlockStart * blockStarts;
static sqInt breakBlock;
static sqInt breakMethod;
sqInt breakPC;
static sqInt byte0;
static sqInt byte1;
static sqInt byte2;
static sqInt byte3;
static sqInt bytecodePC;
static sqInt bytecodeSetOffset;
void * CFramePointer;
void * CStackPointer;
static sqInt callerSavedRegMask;
sqInt ceBaseFrameReturnTrampoline;
void (*ceCall0ArgsPIC)(void);
void (*ceCall1ArgsPIC)(void);
void (*ceCall2ArgsPIC)(void);
void (*ceCallCogCodePopReceiverAndClassRegs)(void);
void (*ceCallCogCodePopReceiverArg0Regs)(void);
void (*ceCallCogCodePopReceiverArg1Arg0Regs)(void);
void (*ceCallCogCodePopReceiverReg)(void);
static sqInt ceCannotAssignToWithIndexTrampoline;
sqInt ceCannotResumeTrampoline;
void (*ceCaptureCStackPointers)(void);
static unsigned long (*ceCheckFeaturesFunction)(void);
sqInt ceCheckForInterruptTrampoline;
static sqInt ceCPICMissTrampoline;
static sqInt ceDereferenceSelectorIndex;
void (*ceEnterCogCodePopReceiverReg)(void);
static sqInt ceFetchContextInstVarTrampoline;
static void (*ceFlushICache)(unsigned long from, unsigned long to);
unsigned long (*ceGetFP)(void);
unsigned long (*ceGetSP)(void);
static sqInt ceLargeActiveContextInBlockTrampoline;
static sqInt ceLargeActiveContextInMethodTrampoline;
static sqInt ceMethodAbortTrampoline;
static sqInt ceNonLocalReturnTrampoline;
static sqInt cePICAbortTrampoline;
static sqInt cePrimReturnEnterCogCode;
static sqInt cePrimReturnEnterCogCodeProfiling;
sqInt ceReturnToInterpreterTrampoline;
static sqInt ceScheduleScavengeTrampoline;
static sqInt ceSendMustBeBooleanAddFalseTrampoline;
static sqInt ceSendMustBeBooleanAddTrueTrampoline;
static sqInt ceSmallActiveContextInBlockTrampoline;
static sqInt ceSmallActiveContextInMethodTrampoline;
static sqInt ceStoreCheckContextReceiverTrampoline;
static sqInt ceStoreCheckTrampoline;
static sqInt ceStoreContextInstVarTrampoline;
static sqInt ceTraceBlockActivationTrampoline;
static sqInt ceTraceLinkedSendTrampoline;
static sqInt ceTraceStoreTrampoline;
unsigned long (*ceTryLockVMOwner)(void);
void (*ceUnlockVMOwner)(void);
sqInt cFramePointerInUse;
static sqInt closedPICSize;
sqInt cmEntryOffset;
sqInt cmNoCheckEntryOffset;
static sqInt codeBase;
static sqInt codeModified;
static sqInt compilationTrace;
static sqInt cPICCaseSize;
static sqInt cPICEndOfCodeOffset;
static sqInt cPICEndSize;
static sqInt cPICPrototype;
static sqInt deadCode;
static sqInt debugFixupBreaks;
static sqInt debugOpcodeIndices;
unsigned long debugPrimCallStackOffset;
static sqInt directedSuperSendTrampolines[NumSendTrampolines];
static sqInt disassemblingMethod;
static AbstractInstruction * endCPICCase0;
static sqInt endPC;
static AbstractInstruction * entry;
static sqInt enumeratingCogMethod;
static sqInt expectedFPAlignment;
static sqInt expectedSPAlignment;
static sqInt extA;
static sqInt extB;
static sqInt externalPrimCallOffsets[MaxNumArgs + 1];
static sqInt externalPrimJumpOffsets[MaxNumArgs + 1];
static sqInt externalSetPrimOffsets[MaxNumArgs + 1];
static sqInt firstCPICCaseOffset;
static sqInt firstSend;
static BytecodeFixup * fixups;
static BytecodeDescriptor generatorTable[256] = {
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushReceiverBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantTrueBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantFalseBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantNilBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genReturnReceiver, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 },
	{ genReturnTrue, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 },
	{ genReturnFalse, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 },
	{ genReturnNil, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 },
	{ genReturnTopFromMethod, 0, needsFrameIfInBlock, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 },
	{ genReturnTopFromBlock, 0, needsFrameNever, -1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0 },
	{ extendedPushBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1 },
	{ extendedStoreBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ extendedStoreAndPopBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1 },
	{ genExtendedSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ doubleExtendedDoAnythingBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genExtendedSuperBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1 },
	{ genSecondExtendedSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genPopStackBytecode, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ duplicateTopBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushActiveContextBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushNewArrayBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genCallPrimitiveBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushClosureCopyCopiedValuesBytecode, v3BlockCodeSize, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AddRR, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, SubRR, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLess, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreater, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLessOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreaterOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpZero, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpNonZero, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AndRR, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, OrRR, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorClass, 0, needsFrameIfStackGreaterThanOne, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }
};
static sqInt guardPageSize;
static sqInt hasYoungReferent;
static sqInt inBlock;
static sqInt initialPC;
static int labelCounter;
static sqInt lastSend;
static usqInt limitAddress;
static sqInt maxCPICCases;
static sqInt maxLitIndex;
static sqInt methodAbortTrampolines[4];
static sqInt methodBytesFreedSinceLastCompaction;
static sqInt methodCount;
static sqInt methodHeader;
static AbstractInstruction * const methodLabel = &aMethodLabel;
static sqInt methodObj;
static sqInt methodOrBlockNumArgs;
static sqInt methodOrBlockNumTemps;
static sqInt methodZoneBase;
static unsigned long minValidCallAddress;
sqInt missOffset;
static usqInt mzFreeStart;
static sqInt needsFrame;
static AbstractInstruction * noCheckEntry;
static sqInt numAbstractOpcodes;
static usqInt objectReferencesInRuntime[NumObjRefsInRuntime];
static sqInt opcodeIndex;
static CogMethod *openPICList = 0;
static sqInt openPICSize;
static CogSSOptStatus optStatus;
static sqInt ordinarySendTrampolines[NumSendTrampolines];
static sqInt picAbortTrampolines[4];
static AbstractInstruction * picInterpretAbort;
static sqInt picMissTrampolines[4];
static void (*postCompileHook)(CogMethod *);
static BytecodeDescriptor * prevBCDescriptor;
static AbstractInstruction * primInvokeInstruction;
static sqInt primitiveIndex;
static AbstractInstruction * primSetFunctionLabel;
void (*realCECallCogCodePopReceiverAndClassRegs)(void);
void (*realCECallCogCodePopReceiverArg0Regs)(void);
void (*realCECallCogCodePopReceiverArg1Arg0Regs)(void);
void (*realCECallCogCodePopReceiverReg)(void);
void (*realCEEnterCogCodePopReceiverReg)(void);
static sqInt regArgsHaveBeenPushed;
static sqInt runtimeObjectRefIndex;
static AbstractInstruction * sendMiss;
static CogSimStackEntry simSelf;
static sqInt simSpillBase;
static CogSimStackEntry simStack[77];
static sqInt simStackPtr;
static AbstractInstruction * stackCheckLabel;
static AbstractInstruction * stackOverflowCall;
static sqInt superSendTrampolines[NumSendTrampolines];
static sqInt tempOop;
int traceFlags = 8 /* prim trace log on by default */;
sqInt traceStores;
static char *trampolineAddresses[NumTrampolines*2];
static sqInt trampolineTableIndex;
static usqInt unpairedMethodList;
static usqInt youngReferrers;


/*** Macros ***/
#define cPICNumCases stackCheckOffset
#define cPICNumCasesHack hack hack hack i.e. the getter macro does all the work
#define abstractInstructionAt(index) (&abstractOpcodes[index])
#define allocateBlockStarts(numBlocks) do { \
		blockStarts = (numBlocks) ? alloca(sizeof(BlockStart) * (numBlocks)) : 0; \
} while (0)
#define backEnd() backEnd
#define blockAlignment(self) 8
#define blockStartAt(index) (&blockStarts[index])
#define breakOnImplicitReceiver() (traceFlags & 64)
#define callerSavedRegMask() callerSavedRegMask
#define ceBaseFrameReturnPC() ceBaseFrameReturnTrampoline
#define ceCannotResumePC() ((usqInt)ceCannotResumeTrampoline)
#define ceCheckFeatures() ceCheckFeaturesFunction()
#define ceReturnToInterpreterPC() ((usqInt)ceReturnToInterpreterTrampoline)
#define cFramePointerAddress() ((unsigned long)&CFramePointer)
#define compileSendTrace() (traceFlags & 2)
#define cr() putchar('\n')
#define cStackPointerAddress() ((unsigned long)&CStackPointer)
#define entryOffset() cmEntryOffset
#define generatorAt(index) (&generatorTable[index])
#define getCFramePointer() CFramePointer
#define getCStackPointer() CStackPointer
#define getIsObjectReference() 2
#define halt() warning("halt")
#define haltmsg(msg) warning("halt: " msg)
#define interpretOffset() missOffset
#define methodLabel() methodLabel
#define methodZoneBase() methodZoneBase
#define minCallAddress() minValidCallAddress
#define noCheckEntryOffset() cmNoCheckEntryOffset
#define noContextSwitchBlockEntryOffset() blockNoContextSwitchOffset
#define notYetImplemented() warning("not yet implemented")
#define printNum(n) printf("%ld", (long) n)
#define printOnTrace() (traceFlags & 1)
#define print(aString) printf(aString)
#define recordBlockTrace() (traceFlags & 4)
#define recordEventTrace() (traceFlags & 16)
#define recordOverflowTrace() (traceFlags & 32)
#define recordPrimTrace() (traceFlags & 8)
#define recordSendTrace() (traceFlags & 2)
#define reportError(n) warning("compilation error")
#define setCFramePointer(theFP) (CFramePointer = (void *)(theFP))
#define setCStackPointer(theSP) (CStackPointer = (void *)(theSP))
#define tryLockVMOwner() (ceTryLockVMOwner() != 0)
#define unlockVMOwner() ceUnlockVMOwner()
#define nextOpenPIC methodObject
#define nextOpenPICHack hack hack hack i.e. the getter macro does all the work
#define freeStart() mzFreeStart
#define limitZony() ((CogMethod *)mzFreeStart)
#define methodBytesFreedSinceLastCompaction() methodBytesFreedSinceLastCompaction
#define roundUpLength(numBytes) ((numBytes) + 7 & -8)
#define youngReferrers() youngReferrers
#define maybeConstant(sse) ((sse)->constant)
#define flushICacheFromto(me,startAddress,endAddress) 0
#define numberOfSaveableRegisters(self) 14
#define unalignedLong32At(inst,byteAddress) long32At(byteAddress)
#define unalignedLong32Atput(inst,byteAddress,aWord) long32Atput(byteAddress,aWord)
#define unalignedLongAt(byteAddress) longAt(byteAddress)
#define unalignedLongAtput(byteAddress,aWord) longAtput(byteAddress,aWord)
#define fixupAt(index) (&fixups[index])
#define simStackAt(index) (simStack + (index))
#define traceDescriptor(ign) 0
#define traceFixup(ign) 0
#define traceMerge(ign) 0
#define traceSimStack() 0
#define traceSpill(ign) 0
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))


	/* CogAbstractInstruction>>#addDependent: */
static AbstractInstruction * NoDbgRegParms
addDependent(AbstractInstruction * self_in_addDependent, AbstractInstruction *anInstruction)
{
	if (!(((self_in_addDependent->dependent)) == null)) {
		(anInstruction->dependent = (self_in_addDependent->dependent));
	}
	return ((self_in_addDependent->dependent) = anInstruction);
}


/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them. */

	/* CogAbstractInstruction>>#availableRegisterOrNoneFor: */
static sqInt NoDbgRegParms
availableRegisterOrNoneFor(AbstractInstruction * self_in_availableRegisterOrNoneFor, sqInt liveRegsMask)
{
	flag("searching physical registers that are not assigned to abstract registers first will do a better job and allocate with fewer conflicts.  But this will be much easier if we use the same range for concrete and abstract registers (0-N) and simply number abstract registers the same as their corresponding concrete registers.");
	if (!(liveRegsMask & (1LL << Arg1Reg))) {
		return Arg1Reg;
	}
	if (!(liveRegsMask & (1LL << Arg0Reg))) {
		return Arg0Reg;
	}
	if (!(liveRegsMask & (1LL << SendNumArgsReg))) {
		return SendNumArgsReg;
	}
	if (!(liveRegsMask & (1LL << ClassReg))) {
		return ClassReg;
	}
	if (!(liveRegsMask & (1LL << ReceiverResultReg))) {
		return ReceiverResultReg;
	}
	return NoReg;
}


/*	For out-of-line literal support, clone a literal from a literal. */

	/* CogAbstractInstruction>>#cloneLiteralFrom: */
static AbstractInstruction * NoDbgRegParms
cloneLiteralFrom(AbstractInstruction * self_in_cloneLiteralFrom, AbstractInstruction *existingLiteral)
{
	assert((((existingLiteral->opcode)) == Literal)
	 && ((((self_in_cloneLiteralFrom->dependent)) == null)
	 && (((self_in_cloneLiteralFrom->address)) == null)));
	(self_in_cloneLiteralFrom->opcode) = Literal;
	(self_in_cloneLiteralFrom->annotation) = (existingLiteral->annotation);
	((self_in_cloneLiteralFrom->operands))[0] = (((existingLiteral->operands))[0]);
	((self_in_cloneLiteralFrom->operands))[1] = (((existingLiteral->operands))[1]);
	((self_in_cloneLiteralFrom->operands))[2] = (((existingLiteral->operands))[2]);
	return self_in_cloneLiteralFrom;
}


/*	Generate concrete machine code for the instruction at actualAddress,
	setting machineCodeSize, and answer the following address. */

	/* CogAbstractInstruction>>#concretizeAt: */
static sqInt NoDbgRegParms
concretizeAt(AbstractInstruction * self_in_concretizeAt, sqInt actualAddress)
{
	(self_in_concretizeAt->address) = actualAddress;
	dispatchConcretize(self_in_concretizeAt);
	assert((((self_in_concretizeAt->maxSize)) == null)
	 || (((self_in_concretizeAt->maxSize)) >= ((self_in_concretizeAt->machineCodeSize))));
	return actualAddress + ((self_in_concretizeAt->machineCodeSize));
}

	/* CogAbstractInstruction>>#genWriteCResultIntoReg: */
static AbstractInstruction * NoDbgRegParms
genWriteCResultIntoReg(AbstractInstruction * self_in_genWriteCResultIntoReg, sqInt abstractRegister)
{
    sqInt cResultReg;

	cResultReg = RAX;
	if (abstractRegister != cResultReg) {
		genoperandoperand(MoveRR, cResultReg, abstractRegister);
	}
	return self_in_genWriteCResultIntoReg;
}


/*	Get the target of a jump instruction. Jumps have the target in the first
	operand. 
 */

	/* CogAbstractInstruction>>#getJmpTarget */
static AbstractInstruction * NoDbgRegParms
getJmpTarget(AbstractInstruction * self_in_getJmpTarget)
{
	return ((AbstractInstruction *) (((self_in_getJmpTarget->operands))[0]));
}


/*	Answer if operand is in the current compilation; and henced could be a
	candidate for pc-relative addressing.
 */

	/* CogAbstractInstruction>>#inCurrentCompilation: */
static sqInt NoDbgRegParms
inCurrentCompilation(AbstractInstruction * self_in_inCurrentCompilation, sqInt operand)
{
	return ((addressIsInInstructions(((AbstractInstruction *) operand)))
	 || ((((AbstractInstruction *) operand)) == (methodLabel())))
	 || (addressIsInCurrentCompilation(operand));
}


/*	For out-of-line literal support, initialize a sharable literal. */

	/* CogAbstractInstruction>>#initializeSharableLiteral: */
static AbstractInstruction * NoDbgRegParms
initializeSharableLiteral(AbstractInstruction * self_in_initializeSharableLiteral, sqInt literal)
{
	(self_in_initializeSharableLiteral->opcode) = Literal;

	/* separate := nil for Slang */
	(self_in_initializeSharableLiteral->annotation) = null;
	(self_in_initializeSharableLiteral->address) = null;
	(self_in_initializeSharableLiteral->dependent) = null;
	((self_in_initializeSharableLiteral->operands))[0] = literal;
	((self_in_initializeSharableLiteral->operands))[1] = 1;
	((self_in_initializeSharableLiteral->operands))[2] = -1;
	return self_in_initializeSharableLiteral;
}


/*	For out-of-line literal support, initialize an unsharable literal. */

	/* CogAbstractInstruction>>#initializeUniqueLiteral: */
static AbstractInstruction * NoDbgRegParms
initializeUniqueLiteral(AbstractInstruction * self_in_initializeUniqueLiteral, sqInt literal)
{
	(self_in_initializeUniqueLiteral->opcode) = Literal;

	/* separate := nil for Slang */
	(self_in_initializeUniqueLiteral->annotation) = null;
	(self_in_initializeUniqueLiteral->address) = null;
	(self_in_initializeUniqueLiteral->dependent) = null;
	((self_in_initializeUniqueLiteral->operands))[0] = literal;
	((self_in_initializeUniqueLiteral->operands))[1] = 0;
	((self_in_initializeUniqueLiteral->operands))[2] = -1;
	return self_in_initializeUniqueLiteral;
}

	/* CogAbstractInstruction>>#isAFixup: */
static sqInt NoDbgRegParms
isAFixup(AbstractInstruction * self_in_isAFixup, void *fixupOrAddress)
{
	return addressIsInFixups(fixupOrAddress);
}

	/* CogAbstractInstruction>>#isJump */
static sqInt NoDbgRegParms
isJump(AbstractInstruction * self_in_isJump)
{
	return ((((self_in_isJump->opcode)) >= FirstJump) && (((self_in_isJump->opcode)) <= LastJump));
}


/*	Hack: To arrange that the block method field pushed in a block entry has
	its MFMethodFlagIsBlockFlag bit set we provide labels with an offset. The
	offset for the fakeHeader reference is MFMethodFlagIsBlockFlag. See
	compileBlockFrameBuild: */

	/* CogAbstractInstruction>>#labelOffset */
static usqInt NoDbgRegParms
labelOffset(AbstractInstruction * self_in_labelOffset)
{
	return ((self_in_labelOffset->operands))[1];
}


/*	We assume here that calls and jumps look the same as regards their
	displacement. This works on at least x86, ARM and x86_64. Processors on
	which that isn't the
	case can override as necessary. */

	/* CogAbstractInstruction>>#relocateJumpLongBeforeFollowingAddress:by: */
static AbstractInstruction * NoDbgRegParms
relocateJumpLongBeforeFollowingAddressby(AbstractInstruction * self_in_relocateJumpLongBeforeFollowingAddressby, sqInt pc, sqInt delta)
{
	relocateCallBeforeReturnPCby(self_in_relocateJumpLongBeforeFollowingAddressby, pc, delta);
	return self_in_relocateJumpLongBeforeFollowingAddressby;
}


/*	Relocate a long conditional jump before pc. Default to relocating a
	non-conditional jump.
	Processors that have different formats for conditional and unconditional
	jumps override. */

	/* CogAbstractInstruction>>#relocateJumpLongConditionalBeforeFollowingAddress:by: */
static AbstractInstruction * NoDbgRegParms
relocateJumpLongConditionalBeforeFollowingAddressby(AbstractInstruction * self_in_relocateJumpLongConditionalBeforeFollowingAddressby, sqInt pc, sqInt delta)
{
	relocateJumpLongBeforeFollowingAddressby(self_in_relocateJumpLongConditionalBeforeFollowingAddressby, pc, delta);
	return self_in_relocateJumpLongConditionalBeforeFollowingAddressby;
}

	/* CogAbstractInstruction>>#resolveJumpTarget */
static AbstractInstruction * NoDbgRegParms
resolveJumpTarget(AbstractInstruction * self_in_resolveJumpTarget)
{
    BytecodeFixup *fixup;

	assert(isJump(self_in_resolveJumpTarget));
	fixup = ((BytecodeFixup *) (((self_in_resolveJumpTarget->operands))[0]));
	if (isAFixup(self_in_resolveJumpTarget, fixup)) {
		assert(addressIsInInstructions((fixup->targetInstruction)));
		jmpTarget(self_in_resolveJumpTarget, (fixup->targetInstruction));
	}
	return self_in_resolveJumpTarget;
}


/*	Rewrite a conditional jump long to jump to target. This version defaults
	to using
	rewriteJumpLongAt:, which works for many ISAs. Subclasses override if
	necessary.  */

	/* CogAbstractInstruction>>#rewriteConditionalJumpLongAt:target: */
static sqInt NoDbgRegParms
rewriteConditionalJumpLongAttarget(AbstractInstruction * self_in_rewriteConditionalJumpLongAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteCallAttarget(self_in_rewriteConditionalJumpLongAttarget, callSiteReturnAddress, callTargetAddress);
}


/*	Hack: To arrange that the block method field pushed in a block entry has
	its MFMethodFlagIsBlockFlag bit set we provide labels with an offset. The
	offset for the fakeHeader reference is MFMethodFlagIsBlockFlag. See
	compileBlockFrameBuild: */

	/* CogAbstractInstruction>>#setLabelOffset: */
static sqInt NoDbgRegParms
setLabelOffset(AbstractInstruction * self_in_setLabelOffset, sqInt aValue)
{
	return ((self_in_setLabelOffset->operands))[1] = aValue;
}


/*	Update an instruction that depends on a label outside
	of generated code (e.g. a method or block header). */

	/* CogAbstractInstruction>>#updateLabel: */
static AbstractInstruction * NoDbgRegParms
updateLabel(AbstractInstruction * self_in_updateLabel, AbstractInstruction *labelInstruction)
{
	assert((((self_in_updateLabel->opcode)) == MoveCwR)
	 || (((self_in_updateLabel->opcode)) == PushCw));
	((self_in_updateLabel->operands))[0] = (((labelInstruction->address)) + (labelOffset(labelInstruction)));
	return self_in_updateLabel;
}

	/* CogBlockMethod>>#cmHomeMethod */
static CogMethod * NoDbgRegParms
cmHomeMethod(CogBlockMethod * self_in_cmHomeMethod)
{
	return ((CogMethod *) ((((usqInt)self_in_cmHomeMethod)) - ((self_in_cmHomeMethod->homeOffset))));
}

	/* CogBytecodeDescriptor>>#isBranch */
static sqInt NoDbgRegParms
isBranch(BytecodeDescriptor * self_in_isBranch)
{
	return (((self_in_isBranch->spanFunction)) != null)
	 && (!((self_in_isBranch->isBlockCreation)));
}

	/* CogBytecodeDescriptor>>#isUnconditionalBranch */
static sqInt NoDbgRegParms
isUnconditionalBranch(BytecodeDescriptor * self_in_isUnconditionalBranch)
{
	return (isBranch(self_in_isUnconditionalBranch))
	 && (!(((self_in_isUnconditionalBranch->isBranchTrue))
 || ((self_in_isUnconditionalBranch->isBranchFalse))));
}


/*	With CqR we assume constants are 32-bits or less. */

	/* CogInLineLiteralsX64Compiler>>#computeSizeOfArithCqR */
static sqInt NoDbgRegParms
computeSizeOfArithCqR(AbstractInstruction * self_in_computeSizeOfArithCqR)
{
	if (isQuick(self_in_computeSizeOfArithCqR, ((self_in_computeSizeOfArithCqR->operands))[0])) {
		return 4;
	}
	if (isSignExtendedFourByteValue(self_in_computeSizeOfArithCqR, ((self_in_computeSizeOfArithCqR->operands))[0])) {
		return ((((self_in_computeSizeOfArithCqR->operands))[1]) == RAX
			? 6
			: 7);
	}
	return 10 + 3;
}

	/* CogInLineLiteralsX64Compiler>>#computeSizeOfArithCwR */
static sqInt NoDbgRegParms
computeSizeOfArithCwR(AbstractInstruction * self_in_computeSizeOfArithCwR)
{
	return 10 + 3;
}

	/* CogInLineLiteralsX64Compiler>>#concretizeArithCwR: */
static usqInt NoDbgRegParms
concretizeArithCwR(AbstractInstruction * self_in_concretizeArithCwR, sqInt x64opcode)
{
    unsigned long reg;
    sqInt reverse;
    unsigned long value;

	value = ((self_in_concretizeArithCwR->operands))[0];
	reg = ((self_in_concretizeArithCwR->operands))[1];

	/* Tst & Cmp; backwards */
	reverse = (x64opcode == 133)
	 || (x64opcode == 57);
	((self_in_concretizeArithCwR->machineCode))[0] = (rexRxb(self_in_concretizeArithCwR, RISCTempReg, 0, RISCTempReg));
	((self_in_concretizeArithCwR->machineCode))[1] = (184 + (RISCTempReg & 7));
	((self_in_concretizeArithCwR->machineCode))[2] = (value & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[3] = ((((usqInt) value) >> 8) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[4] = ((((usqInt) value) >> 16) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[5] = ((((usqInt) value) >> 24) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[6] = ((((usqInt) value) >> 32) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[7] = ((((usqInt) value) >> 40) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[8] = ((((usqInt) value) >> 48) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[9] = ((((usqInt) value) >> 56) & 0xFF);
	((self_in_concretizeArithCwR->machineCode))[10] = ((reverse
	? rexRxb(self_in_concretizeArithCwR, RISCTempReg, 0, reg)
	: rexRxb(self_in_concretizeArithCwR, reg, 0, RISCTempReg)));
	((self_in_concretizeArithCwR->machineCode))[11] = x64opcode;
	((self_in_concretizeArithCwR->machineCode))[12] = ((reverse
	? modRMRO(self_in_concretizeArithCwR, ModReg, reg, RISCTempReg)
	: modRMRO(self_in_concretizeArithCwR, ModReg, RISCTempReg, reg)));
	return ((self_in_concretizeArithCwR->machineCodeSize) = 13);
}


/*	Will get inlined into concretizeAt: switch. */

	/* CogInLineLiteralsX64Compiler>>#concretizeMoveCwR */
static usqInt NoDbgRegParms
concretizeMoveCwR(AbstractInstruction * self_in_concretizeMoveCwR)
{
    unsigned long offset;
    unsigned long reg;
    unsigned long value;

	value = ((self_in_concretizeMoveCwR->operands))[0];
	reg = ((self_in_concretizeMoveCwR->operands))[1];
	if ((addressIsInInstructions(((AbstractInstruction *) value)))
	 || ((((AbstractInstruction *) value)) == (methodLabel()))) {
		value = ((((AbstractInstruction *) value))->address);
	}
	if (addressIsInCurrentCompilation(value)) {
		offset = value - (((self_in_concretizeMoveCwR->address)) + 7);
		((self_in_concretizeMoveCwR->machineCode))[0] = (rexRxb(self_in_concretizeMoveCwR, reg, 0, 0));
		((self_in_concretizeMoveCwR->machineCode))[1] = 141;
		((self_in_concretizeMoveCwR->machineCode))[2] = (modRMRO(self_in_concretizeMoveCwR, ModRegInd, 5, reg));
		((self_in_concretizeMoveCwR->machineCode))[3] = (offset & 0xFF);
		((self_in_concretizeMoveCwR->machineCode))[4] = ((((usqInt) offset) >> 8) & 0xFF);
		((self_in_concretizeMoveCwR->machineCode))[5] = ((((usqInt) offset) >> 16) & 0xFF);
		((self_in_concretizeMoveCwR->machineCode))[6] = ((((usqInt) offset) >> 24) & 0xFF);
		return ((self_in_concretizeMoveCwR->machineCodeSize) = 7);
	}
	((self_in_concretizeMoveCwR->machineCode))[0] = (rexRxb(self_in_concretizeMoveCwR, 0, 0, reg));
	((self_in_concretizeMoveCwR->machineCode))[1] = (184 + (reg & 7));
	((self_in_concretizeMoveCwR->machineCode))[2] = (value & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[3] = ((((usqInt) value) >> 8) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[4] = ((((usqInt) value) >> 16) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[5] = ((((usqInt) value) >> 24) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[6] = ((((usqInt) value) >> 32) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[7] = ((((usqInt) value) >> 40) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[8] = ((((usqInt) value) >> 48) & 0xFF);
	((self_in_concretizeMoveCwR->machineCode))[9] = ((((usqInt) value) >> 56) & 0xFF);
	if (((self_in_concretizeMoveCwR->opcode)) == MoveCqR) {
		return ((self_in_concretizeMoveCwR->machineCodeSize) = 10);
	}
	((self_in_concretizeMoveCwR->machineCode))[10] = 144;
	assert((modRMRO(self_in_concretizeMoveCwR, ModReg, 0, 0)) > 144);
	return ((self_in_concretizeMoveCwR->machineCodeSize) = 11);
}


/*	Answer the inline cache tag for the return address of a send. */

	/* CogInLineLiteralsX64Compiler>>#inlineCacheTagAt: */
static usqInt NoDbgRegParms
inlineCacheTagAt(AbstractInstruction * self_in_inlineCacheTagAt, sqInt callSiteReturnAddress)
{
	return literal32BeforeFollowingAddress(self_in_inlineCacheTagAt, callSiteReturnAddress - 5);
}


/*	Answer if the receiver is a pc-dependent instruction. */

	/* CogInLineLiteralsX64Compiler>>#isPCDependent */
static sqInt NoDbgRegParms
isPCDependent(AbstractInstruction * self_in_isPCDependent)
{
	return (isJump(self_in_isPCDependent))
	 || (((self_in_isPCDependent->opcode)) == AlignmentNops);
}


/*	Answer the 32-bit literal embedded in the instruction immediately
	preceding followingAddress.
 */

	/* CogInLineLiteralsX64Compiler>>#literal32BeforeFollowingAddress: */
static usqInt NoDbgRegParms
literal32BeforeFollowingAddress(AbstractInstruction * self_in_literal32BeforeFollowingAddress, sqInt followingAddress)
{
	return ((unsigned int) (unalignedLong32At(self_in_literal32BeforeFollowingAddress, followingAddress - 4)));
}


/*	Answer the literal embedded in the instruction immediately preceding
	followingAddress. This is used in the MoveCwR, PushCwR and CmpCwR cases;
	these are distinguished by a
	nop following the literal load in MoveCwR, a 16r50 + reg ending the
	PushCwR sequence, and
	a (self mod: ModReg RM: rX RO: rY) ending the CmpCwR sequence, which is at
	least 16rC0. */

	/* CogInLineLiteralsX64Compiler>>#literalBeforeFollowingAddress: */
static sqInt NoDbgRegParms
literalBeforeFollowingAddress(AbstractInstruction * self_in_literalBeforeFollowingAddress, sqInt followingAddress)
{
    sqInt base;
    sqInt lastByte;

	lastByte = byteAt(followingAddress - 1);

	/* ArithCwR */
	base = followingAddress - ((lastByte <= 144
	? (lastByte == 144
			? 9
			: 10)
	: 11));
	return unalignedLongAt(base);
}

	/* CogInLineLiteralsX64Compiler>>#loadLiteralByteSize */
static sqInt NoDbgRegParms
loadLiteralByteSize(AbstractInstruction * self_in_loadLiteralByteSize)
{
	return 11;
}


/*	Size a jump and set its address. The target may be another instruction
	or an absolute address. On entry the address inst var holds our virtual
	address. On exit address is set to eventualAbsoluteAddress, which is
	where this instruction will be output. The span of a jump to a following
	instruction is therefore between that instruction's address and this
	instruction's address ((which are both still their virtual addresses), but
	the span of a jump to a preceding instruction or to an absolute address is
	between that instruction's address (which by now is its eventual absolute
	address) or absolute address and eventualAbsoluteAddress. */

	/* CogInLineLiteralsX64Compiler>>#sizePCDependentInstructionAt: */
static usqInt NoDbgRegParms
sizePCDependentInstructionAt(AbstractInstruction * self_in_sizePCDependentInstructionAt, sqInt eventualAbsoluteAddress)
{
    AbstractInstruction *abstractInstruction;
    unsigned long alignment;
    unsigned long maximumSpan;
    unsigned long target;

	if (((self_in_sizePCDependentInstructionAt->opcode)) == AlignmentNops) {
		(self_in_sizePCDependentInstructionAt->address) = eventualAbsoluteAddress;
		alignment = ((self_in_sizePCDependentInstructionAt->operands))[0];
		return ((self_in_sizePCDependentInstructionAt->machineCodeSize) = ((eventualAbsoluteAddress + (alignment - 1)) & (-alignment)) - eventualAbsoluteAddress);
	}
	assert(isJump(self_in_sizePCDependentInstructionAt));
	target = ((self_in_sizePCDependentInstructionAt->operands))[0];
	abstractInstruction = ((AbstractInstruction *) target);
	if ((addressIsInInstructions(abstractInstruction))
	 || (abstractInstruction == (methodLabel()))) {
		maximumSpan = ((abstractInstruction->address)) - (((abstractInstructionfollows(self_in_sizePCDependentInstructionAt, abstractInstruction)
	? eventualAbsoluteAddress
	: (self_in_sizePCDependentInstructionAt->address))) + 2);
	}
	else {
		maximumSpan = target - (eventualAbsoluteAddress + 2);
	}
	(self_in_sizePCDependentInstructionAt->address) = eventualAbsoluteAddress;
	if (((self_in_sizePCDependentInstructionAt->opcode)) >= FirstShortJump) {
		(self_in_sizePCDependentInstructionAt->machineCodeSize) = (isQuick(self_in_sizePCDependentInstructionAt, maximumSpan)
			? 2
			: (((self_in_sizePCDependentInstructionAt->opcode)) == Jump
					? 5
					: 6));
	}
	else {
		
		switch ((self_in_sizePCDependentInstructionAt->opcode)) {
		case JumpLong:
			(self_in_sizePCDependentInstructionAt->machineCodeSize) = 5;

			break;
		case JumpFull:
			(self_in_sizePCDependentInstructionAt->machineCodeSize) = 12;

			break;
		case JumpLongZero:
		case JumpLongNonZero:
			(self_in_sizePCDependentInstructionAt->machineCodeSize) = 6;

			break;
		default:
			error("Case not found and no otherwise clause");
			(self_in_sizePCDependentInstructionAt->machineCodeSize) = -1;
		}
	}
	return (self_in_sizePCDependentInstructionAt->machineCodeSize);
}


/*	Rewrite the literal in the instruction immediately preceding
	followingAddress. This is used in the MoveCwR, PushCwR and CmpCwR cases;
	these are distinguished by a
	nop following the literal load in MoveCwR, a 16r50 + reg ending the
	PushCwR sequence, and
	a (self mod: ModReg RM: rX RO: rY) ending the CmpCwR sequence, which is at
	least 16rC0. */

	/* CogInLineLiteralsX64Compiler>>#storeLiteral:beforeFollowingAddress: */
static AbstractInstruction * NoDbgRegParms
storeLiteralbeforeFollowingAddress(AbstractInstruction * self_in_storeLiteralbeforeFollowingAddress, sqInt literal, sqInt followingAddress)
{
    sqInt base;
    sqInt lastByte;

	lastByte = byteAt(followingAddress - 1);

	/* ArithCwR */
	base = followingAddress - ((lastByte <= 144
	? (lastByte == 144
			? 9
			: 10)
	: 11));
	unalignedLongAtput(base, literal);
	return self_in_storeLiteralbeforeFollowingAddress;
}

	/* Cogit>>#AddCq:R: */
static AbstractInstruction * NoDbgRegParms
gAddCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, reg);
	return anInstruction;
}

	/* Cogit>>#AddR:R: */
static AbstractInstruction * NoDbgRegParms
gAddRR(sqInt reg1, sqInt reg2)
{
	return genoperandoperand(AddRR, reg1, reg2);
}

	/* Cogit>>#AndCq:R: */
static AbstractInstruction * NoDbgRegParms
gAndCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, reg);
	return anInstruction;
}

	/* Cogit>>#AndCq:R:R: */
static AbstractInstruction * NoDbgRegParms
gAndCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *first;

	if (srcReg == destReg) {
		/* begin gen:quickConstant:operand: */
		anInstruction1 = genoperandoperand(AndCqR, quickConstant, destReg);
		return anInstruction1;
	}
	first = genoperandoperand(MoveRR, srcReg, destReg);
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(AndCqR, quickConstant, destReg);
	return first;
}

	/* Cogit>>#ArithmeticShiftRightR:R: */
static AbstractInstruction * NoDbgRegParms
gArithmeticShiftRightRR(sqInt reg1, sqInt reg2)
{
	return genoperandoperand(ArithmeticShiftRightRR, reg1, reg2);
}

	/* Cogit>>#abortOffset */
sqInt
abortOffset(void)
{
	return missOffset;
}

	/* Cogit>>#abstractInstruction:follows: */
static sqInt NoDbgRegParms
abstractInstructionfollows(AbstractInstruction *theAbstractInstruction, AbstractInstruction *anAbstractInstruction)
{
	return theAbstractInstruction > anAbstractInstruction;
}

	/* Cogit>>#addCleanBlockStarts */
static void
addCleanBlockStarts(void)
{
    sqInt i;
    sqInt iLimiT;
    sqInt lit;
    sqInt startPCOrNil;

	for (i = 1, iLimiT = (literalCountOf(methodObj)); i <= iLimiT; i += 1) {
		lit = fetchPointerofObject(i, methodObj);
		startPCOrNil = startPCOrNilOfLiteralin(lit, methodObj);
		if (!(startPCOrNil == null)) {
			maxLitIndex = ((maxLitIndex < i) ? i : maxLitIndex);
			addBlockStartAtnumArgsnumCopiedspan(startPCOrNil - 1, argumentCountOfClosure(lit), copiedValueCountOfClosure(lit), spanForCleanBlockStartingAt(startPCOrNil - 1));
		}
	}
}


/*	Perform an integrity/leak check using the heapMap.
	Set a bit at each cog method's header. */

	/* Cogit>>#addCogMethodsToHeapMap */
void
addCogMethodsToHeapMap(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethod) {
			heapMapAtWordPut(cogMethod, 1);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* Cogit>>#addressIsInCurrentCompilation: */
static sqInt NoDbgRegParms
addressIsInCurrentCompilation(sqInt address)
{
	return ((((usqInt)address)) >= ((methodLabel->address)))
	 && ((((usqInt)address)) < (youngReferrers()));
}

	/* Cogit>>#addressIsInFixups: */
static sqInt NoDbgRegParms
addressIsInFixups(AbstractInstruction *address)
{
	return address >= (AbstractInstruction *)&fixups[0] && address < (AbstractInstruction *)&fixups[numAbstractOpcodes];
}

	/* Cogit>>#addressIsInInstructions: */
static sqInt NoDbgRegParms
addressIsInInstructions(AbstractInstruction *address)
{
	return !((unsigned)(address) & BytesPerWord-1) \
				&& (address) >= &abstractOpcodes[0] \
				&& (address) < &abstractOpcodes[opcodeIndex];
}


/*	calculate the end of the n'th case statement - which is complicated
	because we have case 1 right at the top of our CPIC and then build up from
	the last one. Yes I know this sounds strange, but trust me - I'm an
	Engineer, we do things backwards all the emit
 */

	/* Cogit>>#addressOfEndOfCase:inCPIC: */
static sqInt NoDbgRegParms
addressOfEndOfCaseinCPIC(sqInt n, CogMethod *cPIC)
{
	assert((n >= 1)
	 && (n <= maxCPICCases));
	return (n == 1
		? (((sqInt)cPIC)) + firstCPICCaseOffset
		: ((((sqInt)cPIC)) + firstCPICCaseOffset) + (((maxCPICCases + 1) - n) * cPICCaseSize));
}

	/* Cogit>>#alignUptoRoutineBoundary: */
static sqInt NoDbgRegParms
alignUptoRoutineBoundary(sqInt anAddress)
{
	return (((anAddress + 7) | 7) - 7);
}


/*	Check that all methods have valid selectors, and that all linked sends are
	to valid targets and have valid cache tags
 */

	/* Cogit>>#allMachineCodeObjectReferencesValid */
static sqInt
allMachineCodeObjectReferencesValid(void)
{
    CogMethod *cogMethod;
    sqInt ok;

	ok = 1;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) != CMFree) {
			if (!(asserta(checkValidOopReference((cogMethod->selector))))) {
				ok = 0;
			}
			if (!(asserta((cogMethodDoesntLookKosher(cogMethod)) == 0))) {
				ok = 0;
			}
		}
		if ((((cogMethod->cmType)) == CMMethod)
		 || (((cogMethod->cmType)) == CMOpenPIC)) {
			if (!(asserta((mapForperformUntilarg(cogMethod, checkIfValidOopRefAndTargetpccogMethod, ((sqInt)cogMethod))) == 0))) {
				ok = 0;
			}
		}
		if (((cogMethod->cmType)) == CMClosedPIC) {
			if (!(asserta(noTargetsFreeInClosedPIC(cogMethod)))) {
				ok = 0;
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return ok;
}

	/* Cogit>>#allMethodsHaveCorrectHeader */
static sqInt
allMethodsHaveCorrectHeader(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethod) {
			if (!(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()))) {
				return 0;
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return 1;
}

	/* Cogit>>#annotateAbsolutePCRef: */
static AbstractInstruction * NoDbgRegParms
annotateAbsolutePCRef(AbstractInstruction *abstractInstruction)
{
	(abstractInstruction->annotation = IsAbsPCReference);
	return abstractInstruction;
}

	/* Cogit>>#annotateBytecode: */
static AbstractInstruction * NoDbgRegParms
annotateBytecode(AbstractInstruction *abstractInstruction)
{
	(abstractInstruction->annotation = HasBytecodePC);
	return abstractInstruction;
}

	/* Cogit>>#annotate:objRef: */
static AbstractInstruction * NoDbgRegParms
annotateobjRef(AbstractInstruction *abstractInstruction, sqInt anOop)
{
	if (shouldAnnotateObjectReference(anOop)) {
		if (isYoungObject(anOop)) {
			hasYoungReferent = 1;
		}
		(abstractInstruction->annotation = IsObjectReference);
	}
	return abstractInstruction;
}

	/* Cogit>>#assertSaneJumpTarget: */
static void NoDbgRegParms
assertSaneJumpTarget(AbstractInstruction *jumpTarget)
{
	assert((closedPICSize == null)
	 || ((openPICSize == null)
	 || ((addressIsInInstructions(jumpTarget))
	 || ((((((usqInt)jumpTarget)) >= codeBase) && ((((usqInt)jumpTarget)) <= ((((sqInt)(limitZony()))) + (((closedPICSize < openPICSize) ? openPICSize : closedPICSize)))))))));
}

	/* Cogit>>#blockCreationBytecodeSizeForHeader: */
static sqInt NoDbgRegParms
blockCreationBytecodeSizeForHeader(sqInt aMethodHeader)
{
	return 
#  if MULTIPLEBYTECODESETS
		(headerIndicatesAlternateBytecodeSet(aMethodHeader)
				? AltBlockCreationBytecodeSize
				: BlockCreationBytecodeSize)
#  else /* MULTIPLEBYTECODESETS */
		BlockCreationBytecodeSize
#  endif /* MULTIPLEBYTECODESETS */
		;
}


/*	Evaluate binaryFunction with the block start mcpc and supplied arg for
	each entry in the block dispatch. If the function answers non-zero answer
	the value
	it answered. Used to update back-references to the home method in
	compaction.  */

	/* Cogit>>#blockDispatchTargetsFor:perform:arg: */
static sqInt NoDbgRegParms
blockDispatchTargetsForperformarg(CogMethod *cogMethod, usqInt (*binaryFunction)(sqInt mcpc, sqInt arg), sqInt arg)
{
    sqInt blockEntry;
    sqInt end;
    sqInt pc;
    sqInt result;
    usqInt targetpc;

	if (((cogMethod->blockEntryOffset)) == 0) {
		return null;
	}
	blockEntry = ((cogMethod->blockEntryOffset)) + (((sqInt)cogMethod));
	pc = blockEntry;
	end = (mapEndFor(cogMethod)) - 1;
	while (pc < end) {
		if (isJumpAt(backEnd, pc)) {
			targetpc = jumpTargetPCAt(backEnd, pc);
			if (targetpc < blockEntry) {
				result = binaryFunction(targetpc, arg);
				if (result != 0) {
					return result;
				}
			}
		}
		pc += instructionSizeAt(backEnd, pc);
	}
	return 0;
}


/*	Answer the zero-relative bytecode pc matching the machine code pc argument
	in cogMethod, given the start of the bytecodes for cogMethod's block or
	method object. */

	/* Cogit>>#bytecodePCFor:startBcpc:in: */
sqInt
bytecodePCForstartBcpcin(sqInt mcpc, sqInt startbcpc, CogBlockMethod *cogMethod)
{
    sqInt aMethodHeader;
    sqInt aMethodHeader1;
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    sqInt map;
    sqInt mapByte;
    usqInt mcpc1;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt targetPC;

	latestContinuation = 0;
	/* begin mapFor:bcpc:performUntil:arg: */
	assert(((cogMethod->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc1 = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	result = findIsBackwardBranchMcpcBcpcMatchingMcpc(null, 0, (((char *) mcpc1)), startbcpc, (((void *)mcpc)));
	if (result != 0) {
		return result;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if (((cogMethod->cmType)) == CMMethod) {
		isInBlock = 0;
		homeMethod = ((CogMethod *) cogMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		assert(((((usqInt) (byteAt(map))) >> AnnotationShift) == IsAbsPCReference)
		 || (((((usqInt) (byteAt(map))) >> AnnotationShift) == IsObjectReference)
		 || (((((usqInt) (byteAt(map))) >> AnnotationShift) == IsRelativeCall)
		 || ((((usqInt) (byteAt(map))) >> AnnotationShift) == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader = (homeMethod->methodHeader);
		bsOffset = 
#    if MULTIPLEBYTECODESETS
			(headerIndicatesAlternateBytecodeSet(aMethodHeader)
						? 256
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == ((cogMethod->startpc)));
		homeMethod = cmHomeMethod(cogMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		assert(((((usqInt) (byteAt(map))) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt) (byteAt(map))) >> AnnotationShift) == IsDisplacementX2N));
		while ((((usqInt) (byteAt(map))) >> AnnotationShift) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - (blockCreationBytecodeSizeForHeader((homeMethod->methodHeader)));
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader1 = (homeMethod->methodHeader);
		bsOffset = 
#    if MULTIPLEBYTECODESETS
			(headerIndicatesAlternateBytecodeSet(aMethodHeader1)
						? 256
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj)
	: 0));
		bcpc = startbcpc;
	}

	/* Now skip up through the bytecode pc map entry for the stack check. */
	nExts = 0;
	while ((((usqInt) (byteAt(map))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt) mapByte) >> AnnotationShift;
			mcpc1 += (mapByte & DisplacementMask);
			if ((annotation >= IsSendCall)
			 || ((annotation == HasBytecodePC)
			 || (0))) {
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							return 0;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							return 0;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && (isBackwardBranchatextsin(descriptor, bcpc, nExts, aMethodObj));
				result = findIsBackwardBranchMcpcBcpcMatchingMcpc(descriptor, isBackwardBranch, (((char *) mcpc1)), bcpc, (((void *)mcpc)));
				if (result != 0) {
					return result;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt) mapByte) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt) mapByte) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
				mcpc1 += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
			}
		}
		map -= 1;
	}
	return 0;
}

	/* Cogit>>#Call: */
static AbstractInstruction * NoDbgRegParms
gCall(sqInt callTarget)
{
	return genoperand(Call, callTarget);
}

	/* Cogit>>#CmpCq:R: */
static AbstractInstruction * NoDbgRegParms
gCmpCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, reg);
	return anInstruction;
}

	/* Cogit>>#CmpCw:R: */
static AbstractInstruction * NoDbgRegParms
gCmpCwR(sqInt wordConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(CmpCwR, wordConstant, reg);
	return anInstruction;
}

	/* Cogit>>#CmpR:R: */
static AbstractInstruction * NoDbgRegParms
gCmpRR(sqInt reg1, sqInt reg2)
{
	return genoperandoperand(CmpRR, reg1, reg2);
}


/*	This is a static version of ceCallCogCodePopReceiverReg
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* Cogit>>#callCogCodePopReceiver */
void
callCogCodePopReceiver(void)
{
	realCECallCogCodePopReceiverReg();
	error("what??");

}


/*	This is a static version of ceCallCogCodePopReceiverAndClassRegs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* Cogit>>#callCogCodePopReceiverAndClassRegs */
void
callCogCodePopReceiverAndClassRegs(void)
{
	realCECallCogCodePopReceiverAndClassRegs();
}


/*	Code entry closed PIC miss. A send has fallen
	through a closed (finite) polymorphic inline cache.
	Either extend it or patch the send site to an open PIC.
	The stack looks like:
	receiver
	args
	sp=>	sender return address */

	/* Cogit>>#ceCPICMiss:receiver: */
sqInt
ceCPICMissreceiver(CogMethod *cPIC, sqInt receiver)
{
    sqInt cacheTag;
    sqInt errorSelectorOrNil;
    sqInt errsel;
    sqInt method;
    sqInt methodOrSelectorIndex;
    sqInt newTargetMethodOrNil;
    sqInt outerReturn;
    sqInt result;
    sqInt selector;

	if (isOopForwarded(receiver)) {
		return ceSendFromInLineCacheMiss(cPIC);
	}
	outerReturn = stackTop();
	assert(!(((inlineCacheTagAt(backEnd, outerReturn)) == (picAbortDiscriminatorValue()))));
	if (((cPIC->cPICNumCases)) < maxCPICCases) {
		/* begin lookup:for:methodAndErrorSelectorInto: */
		selector = (cPIC->selector);
		methodOrSelectorIndex = lookupOrdinaryreceiver(selector, receiver);
		if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
			if (!(isOopCompiledMethod(methodOrSelectorIndex))) {
				newTargetMethodOrNil = methodOrSelectorIndex;
				errorSelectorOrNil = SelectorCannotInterpret;

				goto l1;
			}
			if ((!(methodHasCogMethod(methodOrSelectorIndex)))
			 && (methodShouldBeCogged(methodOrSelectorIndex))) {

				/* We assume cog:selector: will *not* reclaim the method zone */
				cogselector(methodOrSelectorIndex, selector);
			}
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = null;

			goto l1;
		}
		if (methodOrSelectorIndex == SelectorDoesNotUnderstand) {
			methodOrSelectorIndex = lookupMNUreceiver(splObj(SelectorDoesNotUnderstand), receiver);
			if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
				assert(isOopCompiledMethod(methodOrSelectorIndex));
				if ((!(methodHasCogMethod(methodOrSelectorIndex)))
				 && (methodShouldBeCogged(methodOrSelectorIndex))) {

					/* We assume cog:selector: will *not* reclaim the method zone */
					cogselector(methodOrSelectorIndex, splObj(SelectorDoesNotUnderstand));
				}
				newTargetMethodOrNil = methodOrSelectorIndex;
				errorSelectorOrNil = SelectorDoesNotUnderstand;

				goto l1;
			}
			newTargetMethodOrNil = null;
			errorSelectorOrNil = SelectorDoesNotUnderstand;

			goto l1;
		}
		newTargetMethodOrNil = null;
		errorSelectorOrNil = methodOrSelectorIndex;

	l1:	/* end lookup:for:methodAndErrorSelectorInto: */;
	}
	else {
		newTargetMethodOrNil = (errorSelectorOrNil = null);
	}
	assert(outerReturn == (stackTop()));
	cacheTag = inlineCacheTagForInstance(receiver);
	if ((((cPIC->cPICNumCases)) >= maxCPICCases)
	 || (((errorSelectorOrNil != null)
	 && (errorSelectorOrNil != SelectorDoesNotUnderstand))
	 || ((newTargetMethodOrNil == null)
	 || (isYoung(newTargetMethodOrNil))))) {
		result = patchToOpenPICFornumArgsreceiver((cPIC->selector), (cPIC->cmNumArgs), receiver);
		assert(!result);
		return ceSendFromInLineCacheMiss(cPIC);
	}
	cogExtendPICCaseNMethodtagisMNUCase(cPIC, newTargetMethodOrNil, cacheTag, errorSelectorOrNil == SelectorDoesNotUnderstand);
	executeCogPICfromLinkedSendWithReceiverandCacheTag(cPIC, receiver, inlineCacheTagAt(backEnd, outerReturn));
	return null;
}


/*	An in-line cache check in a method has failed. The failing entry check has
	jumped to the ceMethodAbort abort call at the start of the method which
	has called this routine.
	If possible allocate a closed PIC for the current and existing classes.
	The stack looks like:
	receiver
	args
	sender return address
	sp=>	ceMethodAbort call return address
	So we can find the method that did the failing entry check at
	ceMethodAbort call return address - missOffset
	and we can find the send site from the outer return address. */

	/* Cogit>>#ceSICMiss: */
sqInt
ceSICMiss(sqInt receiver)
{
    sqInt cacheTag;
    sqInt entryPoint;
    sqInt errorSelectorOrNil;
    sqInt errsel;
    sqInt extent;
    usqInt innerReturn;
    sqInt method;
    sqInt methodOrSelectorIndex;
    sqInt newTargetMethodOrNil;
    usqInt outerReturn;
    CogMethod *pic;
    sqInt result;
    sqInt selector;
    CogMethod *targetMethod;


	/* Whether we can relink to a PIC or not we need to pop off the inner return and identify the target method. */
	innerReturn = ((usqInt)(popStack()));
	targetMethod = ((CogMethod *) (innerReturn - missOffset));
	if (isOopForwarded(receiver)) {
		return ceSendFromInLineCacheMiss(targetMethod);
	}
	outerReturn = ((usqInt)(stackTop()));
	assert(((outerReturn >= methodZoneBase) && (outerReturn <= (freeStart()))));
	entryPoint = callTargetFromReturnAddress(backEnd, outerReturn);
	assert(((targetMethod->selector)) != (nilObject()));
	assert(((((sqInt)targetMethod)) + cmEntryOffset) == entryPoint);
	/* begin lookup:for:methodAndErrorSelectorInto: */
	selector = (targetMethod->selector);
	methodOrSelectorIndex = lookupOrdinaryreceiver(selector, receiver);
	if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
		if (!(isOopCompiledMethod(methodOrSelectorIndex))) {
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = SelectorCannotInterpret;

			goto l1;
		}
		if ((!(methodHasCogMethod(methodOrSelectorIndex)))
		 && (methodShouldBeCogged(methodOrSelectorIndex))) {

			/* We assume cog:selector: will *not* reclaim the method zone */
			cogselector(methodOrSelectorIndex, selector);
		}
		newTargetMethodOrNil = methodOrSelectorIndex;
		errorSelectorOrNil = null;

		goto l1;
	}
	if (methodOrSelectorIndex == SelectorDoesNotUnderstand) {
		methodOrSelectorIndex = lookupMNUreceiver(splObj(SelectorDoesNotUnderstand), receiver);
		if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
			assert(isOopCompiledMethod(methodOrSelectorIndex));
			if ((!(methodHasCogMethod(methodOrSelectorIndex)))
			 && (methodShouldBeCogged(methodOrSelectorIndex))) {

				/* We assume cog:selector: will *not* reclaim the method zone */
				cogselector(methodOrSelectorIndex, splObj(SelectorDoesNotUnderstand));
			}
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = SelectorDoesNotUnderstand;

			goto l1;
		}
		newTargetMethodOrNil = null;
		errorSelectorOrNil = SelectorDoesNotUnderstand;

		goto l1;
	}
	newTargetMethodOrNil = null;
	errorSelectorOrNil = methodOrSelectorIndex;

l1:	/* end lookup:for:methodAndErrorSelectorInto: */;
	assert(outerReturn == (stackTop()));
	cacheTag = inlineCacheTagForInstance(receiver);
	if (((errorSelectorOrNil != null)
	 && (errorSelectorOrNil != SelectorDoesNotUnderstand))
	 || (((inlineCacheTagAt(backEnd, outerReturn)) == 0)
	 || ((newTargetMethodOrNil == null)
	 || (isYoung(newTargetMethodOrNil))))) {
		result = patchToOpenPICFornumArgsreceiver((targetMethod->selector), (targetMethod->cmNumArgs), receiver);
		assert(!result);
		return ceSendFromInLineCacheMiss(targetMethod);
	}
	pic = openPICWithSelector((targetMethod->selector));
	if (!(pic)) {

		/* otherwise attempt to create a closed PIC for the two cases. */
		pic = cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase((targetMethod->selector), (targetMethod->cmNumArgs), targetMethod, newTargetMethodOrNil, cacheTag, errorSelectorOrNil == SelectorDoesNotUnderstand);
		if ((((((sqInt)pic)) >= MaxNegativeErrorCode) && ((((sqInt)pic)) <= -1))) {

			/* For some reason the PIC couldn't be generated, most likely a lack of code memory.
			   Continue as if this is an unlinked send. */
			if ((((sqInt)pic)) == InsufficientCodeSpace) {
				callForCogCompiledCodeCompaction();
			}
			return ceSendFromInLineCacheMiss(targetMethod);
		}
		flushICacheFromto(processor, ((usqInt)pic), (((usqInt)pic)) + closedPICSize);
	}
	extent = (((pic->cmType)) == CMOpenPIC
		? rewriteInlineCacheAttagtarget(backEnd, outerReturn, inlineCacheValueForSelectorinat((targetMethod->selector), mframeHomeMethodExport(), outerReturn), (((sqInt)pic)) + cmEntryOffset)
		: rewriteCallAttarget(backEnd, outerReturn, (((sqInt)pic)) + cmEntryOffset));
	flushICacheFromto(processor, (((usqInt)outerReturn)) - extent, ((usqInt)outerReturn));
	executeCogPICfromLinkedSendWithReceiverandCacheTag(pic, receiver, inlineCacheTagAt(backEnd, outerReturn));
	return null;
}

	/* Cogit>>#checkAssertsEnabledInCogit */
void
checkAssertsEnabledInCogit(void)
{
    sqInt assertsAreEnabledInCogit;

	assertsAreEnabledInCogit = 0;
	assert(assertsAreEnabledInCogit);
}


/*	Check for a valid object reference, if any, at a map entry. Answer a code
	unique to each error for debugging. */

	/* Cogit>>#checkIfValidOopRefAndTarget:pc:cogMethod: */
static sqInt NoDbgRegParms
checkIfValidOopRefAndTargetpccogMethod(sqInt annotation, char *mcpc, sqInt cogMethod)
{
    sqInt cacheTag;
    usqInt cacheTag1;
    sqInt entryPoint;
    sqInt entryPoint1;
    sqInt literal;
    sqInt offset;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt tagCouldBeObj;
    sqInt tagCouldBeObject;
    sqInt targetMethod;
    CogMethod *targetMethod1;

	if (annotation == IsObjectReference) {
		literal = literalBeforeFollowingAddress(backEnd, ((usqInt)mcpc));
		if (!(asserta(checkValidOopReference(literal)))) {
			return 1;
		}
		if ((couldBeObject(literal))
		 && (isReallyYoungObject(literal))) {
			if (!(asserta(((((CogMethod *) cogMethod))->cmRefersToYoung)))) {
				return 2;
			}
		}
	}
	if (annotation >= IsSendCall) {
		if (!(asserta((((((CogMethod *) cogMethod))->cmType)) == CMMethod))) {
			return 3;
		}
		/* begin offsetCacheTagAndCouldBeObjectAt:annotation:into: */
		cacheTag1 = inlineCacheTagAt(backEnd, ((sqInt)mcpc));

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj = 0;
		if (tagCouldBeObj) {
			if (couldBeObject(cacheTag1)) {
				if (!(asserta(checkValidOopReference(cacheTag1)))) {
					return 4;
				}
			}
			else {
				if (!(asserta(validInlineCacheTag(cacheTag1)))) {
					return 5;
				}
			}
			if ((couldBeObject(cacheTag1))
			 && (isReallyYoungObject(cacheTag1))) {
				if (!(asserta(((((CogMethod *) cogMethod))->cmRefersToYoung)))) {
					return 6;
				}
			}
		}
		else {
			if (!(asserta(validInlineCacheTag(cacheTag1)))) {
				return 7;
			}
		}

		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send; find which kind. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				targetMethod1 = ((CogMethod *) (entryPoint - cmEntryOffset));
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				targetMethod1 = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
				sendTable1 = superSendTrampolines;



			}
			if (!(asserta((((targetMethod1->cmType)) == CMMethod)
				 || ((((targetMethod1->cmType)) == CMClosedPIC)
				 || (((targetMethod1->cmType)) == CMOpenPIC))))) {
				return 8;
			}

		}
	}
	return 0;
}


/*	Check for a valid object reference, if any, at a map entry. Answer a code
	unique to each error for debugging. */

	/* Cogit>>#checkIfValidOopRef:pc:cogMethod: */
static sqInt NoDbgRegParms
checkIfValidOopRefpccogMethod(sqInt annotation, char *mcpc, sqInt cogMethod)
{
    sqInt entryPoint;
    sqInt literal;
    sqInt off;
    sqInt offset;
    sqInt offset1;
    usqInt selectorOrCacheTag;
    sqInt *sendTable;
    sqInt table;

	if (annotation == IsObjectReference) {
		literal = literalBeforeFollowingAddress(backEnd, ((usqInt)mcpc));
		if (!(checkValidOopReference(literal))) {
			print("object ref leak in CM ");
			printHex(((sqInt)cogMethod));
			print(" @ ");
			printHex(((sqInt)mcpc));
			cr();
			return 1;
		}
	}
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint <= methodZoneBase) {
			offset = entryPoint;
		}
		else {
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable = superSendTrampolines;



			}
			offset = offset1;

		}
		selectorOrCacheTag = inlineCacheTagAt(backEnd, ((sqInt)mcpc));
		if ((entryPoint > methodZoneBase)
		 && ((offset != cmNoCheckEntryOffset)
		 && ((((((CogMethod *) (entryPoint - offset)))->cmType)) != CMOpenPIC))) {

			/* linked non-super send, cacheTag is a cacheTag */
			if (!(validInlineCacheTag(selectorOrCacheTag))) {
				print("cache tag leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" @ ");
				printHex(((sqInt)mcpc));
				cr();
				return 1;
			}
		}
		else {

			/* unlinked send or super send; cacheTag is a selector unless 64-bit, in which case it is an index. */
					}
	}
	return 0;
}


/*	Answer if all references to objects in machine-code are valid. */

	/* Cogit>>#checkIntegrityOfObjectReferencesInCode: */
sqInt
checkIntegrityOfObjectReferencesInCode(sqInt gcModes)
{
    CogMethod *cogMethod;
    sqInt count;
    sqInt ok;

	cogMethod = ((CogMethod *) methodZoneBase);
	ok = 1;
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) != CMFree) {
			if ((cogMethod->cmRefersToYoung)) {
				if (((count = occurrencesInYoungReferrers(cogMethod))) != 1) {
					print("young referrer CM ");
					printHex(((sqInt)cogMethod));
					if (count == 0) {
						print(" is not in youngReferrers");
						cr();
					}
					else {
						print(" is in youngReferrers ");
						printNum(count);
						print(" times!");
						cr();
					}
					ok = 0;
				}
			}
			if (!(checkValidOopReference((cogMethod->selector)))) {
				print("object leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" selector");
				cr();
				ok = 0;
			}
			if (((cogMethod->cmType)) == CMMethod) {
				assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
				if (!(checkValidObjectReference((cogMethod->methodObject)))) {
					print("object leak in CM ");
					printHex(((sqInt)cogMethod));
					print(" methodObject");
					cr();
					ok = 0;
				}
				if (!(isOopCompiledMethod((cogMethod->methodObject)))) {
					print("non-method in CM ");
					printHex(((sqInt)cogMethod));
					print(" methodObject");
					cr();
					ok = 0;
				}
				if ((mapForperformUntilarg(cogMethod, checkIfValidOopRefpccogMethod, ((sqInt)cogMethod))) != 0) {
					ok = 0;
				}
				if (((isYoungObject((cogMethod->methodObject)))
				 || (isYoung((cogMethod->selector))))
				 && (!((cogMethod->cmRefersToYoung)))) {
					print("CM ");
					printHex(((sqInt)cogMethod));
					print(" refers to young but not marked as such");
					cr();
					ok = 0;
				}

			}
			else {
				if (((cogMethod->cmType)) == CMClosedPIC) {
					if (!(checkValidObjectReferencesInClosedPIC(cogMethod))) {
						ok = 0;
					}
				}
				else {
					if (((cogMethod->cmType)) == CMOpenPIC) {
						if ((mapForperformUntilarg(cogMethod, checkIfValidOopRefpccogMethod, ((sqInt)cogMethod))) != 0) {
							ok = 0;
						}
					}
				}
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return ok;
}

	/* Cogit>>#checkMaybeObjRefInClosedPIC: */
static sqInt NoDbgRegParms
checkMaybeObjRefInClosedPIC(sqInt maybeObject)
{
	if (maybeObject == 0) {
		return 1;
	}
	if (!(couldBeObject(maybeObject))) {
		return 1;
	}
	return checkValidObjectReference(maybeObject);
}

	/* Cogit>>#checkValidObjectReferencesInClosedPIC: */
static sqInt NoDbgRegParms
checkValidObjectReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt ok;
    sqInt pc;

	ok = 1;

	/* first we check the obj ref at the beginning of the CPIC */
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	if (!(checkMaybeObjRefInClosedPIC(literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)))))) {
		print("object leak in CPIC ");
		printHex(((sqInt)cPIC));
		print(" @ ");
		printHex(pc - (jumpLongByteSize(backEnd)));
		cr();
		ok = 0;
	}

	/* For each case we check any object reference at the end address - sizeof(conditional instruction) and then increment the end address by case size */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (!(checkMaybeObjRefInClosedPIC(literalBeforeFollowingAddress(backEnd, (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))))) {
			print("object leak in CPIC ");
			printHex(((sqInt)cPIC));
			print(" @ ");
			printHex(pc - (jumpLongConditionalByteSize(backEnd)));
			cr();
			ok = 0;
		}
		pc += cPICCaseSize;
	}
	return ok;
}


/*	Answer if the ClosedPIC refers to any unmarked objects or freed/freeable
	target methods,
	applying markAndTraceOrFreeCogMethod:firstVisit: to those targets to
	determine if freed/freeable.
 */

	/* Cogit>>#closedPICRefersToUnmarkedObject: */
static sqInt NoDbgRegParms
closedPICRefersToUnmarkedObject(CogMethod *cPIC)
{
    sqInt i;
    usqInt object;
    sqInt pc;

	if (!((isImmediate((cPIC->selector)))
		 || (isMarked((cPIC->selector))))) {
		return 1;
	}
	pc = addressOfEndOfCaseinCPIC(1, cPIC);
	if (couldBeObject((object = literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)))))) {
		if (!(isMarked(object))) {
			return 1;
		}
	}
	if (markAndTraceOrFreePICTargetin(jumpLongTargetBeforeFollowingAddress(backEnd, pc), cPIC)) {
		return 1;
	}
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (couldBeObject((object = literalBeforeFollowingAddress(backEnd, (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))))) {
			if (!(isMarked(object))) {
				return 1;
			}
		}
		if (markAndTraceOrFreePICTargetin(jumpLongTargetBeforeFollowingAddress(backEnd, pc), cPIC)) {
			return 1;
		}
	}
	return 0;
}

	/* Cogit>>#codeEntryFor: */
char *
codeEntryFor(char *address)
{
    sqInt i;

	for (i = 0; i <= (trampolineTableIndex - 3); i += 2) {
		if (((address >= (trampolineAddresses[i + 1])) && (address <= ((trampolineAddresses[i + 3]) - 1)))) {
			return trampolineAddresses[i + 1];
		}
	}
	return null;
}

	/* Cogit>>#codeEntryNameFor: */
char *
codeEntryNameFor(char *address)
{
    sqInt i;

	for (i = 0; i <= (trampolineTableIndex - 3); i += 2) {
		if (((address >= (trampolineAddresses[i + 1])) && (address <= ((trampolineAddresses[i + 3]) - 1)))) {
			return trampolineAddresses[i];
		}
	}
	return null;
}

	/* Cogit>>#cogCodeBase */
sqInt
cogCodeBase(void)
{
	return codeBase;
}


/*	Answer the contents of the code zone as an array of pair-wise element,
	address in ascending address order.
	Answer a string for a runtime routine or abstract label (beginning, end,
	etc), a CompiledMethod for a CMMethod,
	or a selector (presumably a Symbol) for a PIC. */

	/* Cogit>>#cogCodeConstituents */
sqInt
cogCodeConstituents(void)
{
    CogMethod *cogMethod;
    sqInt constituents;
    sqInt count;
    sqInt i;
    sqInt label;
    sqInt value;


	/* + 3 for start, freeStart and end */
	count = (trampolineTableIndex / 2) + 3;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) != CMFree) {
			count += 1;
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	constituents = instantiateClassindexableSize(classArray(), count * 2);
	if (!(constituents)) {
		return constituents;
	}
	pushRemappableOop(constituents);
	if ((((label = stringForCString("CogCode"))) == null)
	 || (((value = positive64BitIntegerFor(codeBase))) == null)) {
		return null;
	}
	storePointerUncheckedofObjectwithValue(0, topRemappableOop(), label);
	storePointerUncheckedofObjectwithValue(1, topRemappableOop(), value);
	for (i = 0; i < trampolineTableIndex; i += 2) {
		if ((((label = stringForCString(trampolineAddresses[i]))) == null)
		 || (((value = positive64BitIntegerFor(((usqInt)(trampolineAddresses[i + 1]))))) == null)) {
			popRemappableOop();
			return null;
		}
		storePointerUncheckedofObjectwithValue(2 + i, topRemappableOop(), label);
		storePointerUncheckedofObjectwithValue(3 + i, topRemappableOop(), value);
	}
	count = trampolineTableIndex + 2;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) != CMFree) {
			storePointerUncheckedofObjectwithValue(count, topRemappableOop(), (((cogMethod->cmType)) == CMMethod
				? (cogMethod->methodObject)
				: (cogMethod->selector)));
			if (!((value = positive64BitIntegerFor(((usqInt)cogMethod))))) {
				popRemappableOop();
				return null;
			}
			storePointerUncheckedofObjectwithValue(count + 1, topRemappableOop(), value);
			count += 2;
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if ((((label = stringForCString("CCFree"))) == null)
	 || (((value = positive64BitIntegerFor(mzFreeStart))) == null)) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(count, topRemappableOop(), label);
	storePointerUncheckedofObjectwithValue(count + 1, topRemappableOop(), value);
	if ((((label = stringForCString("CCEnd"))) == null)
	 || (((value = positive64BitIntegerFor(limitAddress))) == null)) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(count + 2, topRemappableOop(), label);
	storePointerUncheckedofObjectwithValue(count + 3, topRemappableOop(), value);
	constituents = popRemappableOop();
	beRootIfOld(constituents);
	return constituents;
}


/*	Extend the cPIC with the supplied case. If caseNMethod is cogged dispatch
	direct to
	its unchecked entry-point. If caseNMethod is not cogged, jump to the fast
	interpreter dispatch, and if isMNUCase then dispatch to fast MNU
	invocation and mark the cPIC as
	having the MNU case for cache flushing. */

	/* Cogit>>#cogExtendPIC:CaseNMethod:tag:isMNUCase: */
static sqInt NoDbgRegParms
cogExtendPICCaseNMethodtagisMNUCase(CogMethod *cPIC, sqInt caseNMethod, sqInt caseNTag, sqInt isMNUCase)
{
    sqInt address;
    sqInt operand;
    sqInt target;

	compilationBreakpointisMNUCase((cPIC->selector), numBytesOf((cPIC->selector)), isMNUCase);
	assert(!(inlineCacheTagIsYoung(caseNTag)));
	assert((caseNMethod != null)
	 && (!(isYoung(caseNMethod))));
	if ((!isMNUCase)
	 && (methodHasCogMethod(caseNMethod))) {

		/* this isn't an MNU and we have an already cogged method to jump to */
		operand = 0;
		target = (((sqInt)(cogMethodOf(caseNMethod)))) + cmNoCheckEntryOffset;
	}
	else {
		operand = caseNMethod;
		if (isMNUCase) {

			/* this is an MNU so tag the CPIC header and setup a jump to the MNUAbort */
			(cPIC->cpicHasMNUCase = 1);
			target = (((sqInt)cPIC)) + (sizeof(CogMethod));
		}
		else {

			/* setup a jump to the interpretAborth so we can cog the target method */
			target = (((sqInt)cPIC)) + (picInterpretAbortOffset());
		}
	}
	address = addressOfEndOfCaseinCPIC(((cPIC->cPICNumCases)) + 1, cPIC);
	rewriteCPICCaseAttagobjReftarget(address, caseNTag, operand, target);
	/* begin rewriteCPIC:caseJumpTo: */
	rewriteCPICJumpAttarget(backEnd, (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - 11, address - cPICCaseSize);
	flushICacheFromto(processor, ((usqInt)cPIC), (((usqInt)cPIC)) + closedPICSize);
	(cPIC->cPICNumCases = ((cPIC->cPICNumCases)) + 1);
	return 0;
}

	/* Cogit>>#cogitPostGCAction: */
void
cogitPostGCAction(sqInt gcMode)
{
	assert(allMethodsHaveCorrectHeader());
	assert(((gcMode & (GCModeFull + GCModeNewSpace)) == 0)
	 || (kosherYoungReferrers()));
}


/*	Check that the header fields onf a non-free method are consistent with
	the type. Answer 0 if it is ok, otherwise answer a code for the error. */

	/* Cogit>>#cogMethodDoesntLookKosher: */
sqInt
cogMethodDoesntLookKosher(CogMethod *cogMethod)
{
	if (((((cogMethod->blockSize)) & (BytesPerWord - 1)) != 0)
	 || ((((cogMethod->blockSize)) < (sizeof(CogMethod)))
	 || (((cogMethod->blockSize)) >= 32768))) {
		return 1;
	}
	if (((cogMethod->cmType)) == CMFree) {
		return 2;
	}
	if (((cogMethod->cmType)) == CMMethod) {
		if (!((((((cogMethod->methodHeader))) & 7) == 1))) {
			return 11;
		}
		if (!(couldBeObject((cogMethod->methodObject)))) {
			return 12;
		}
		if ((((cogMethod->stackCheckOffset)) > 0)
		 && (((cogMethod->stackCheckOffset)) < cmNoCheckEntryOffset)) {
			return 13;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		if (((cogMethod->blockSize)) != openPICSize) {
			return 21;
		}
		if (((cogMethod->methodHeader)) != 0) {
			return 22;
		}
		if (((cogMethod->objectHeader)) >= 0) {
			if ((((cogMethod->methodObject)) != 0)
			 && ((((cogMethod->methodObject)) < methodZoneBase)
			 || ((((cogMethod->methodObject)) > ((freeStart()) - openPICSize))
			 || (((((cogMethod->methodObject)) & (BytesPerWord - 1)) != 0)
			 || ((((((CogMethod *) ((cogMethod->methodObject))))->cmType)) != CMOpenPIC))))) {
				return 23;
			}
		}
		if (((cogMethod->stackCheckOffset)) != 0) {
			return 24;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		if (((cogMethod->blockSize)) != closedPICSize) {
			return 0x1F;
		}
		if (!(((((cogMethod->cPICNumCases)) >= 1) && (((cogMethod->cPICNumCases)) <= maxCPICCases)))) {
			return 32;
		}
		if (((cogMethod->methodHeader)) != 0) {
			return 33;
		}
		if (((cogMethod->methodObject)) != 0) {
			return 34;
		}
		return 0;
	}
	return 9;
}


/*	Attempt to create a one-case PIC for an MNU.
	The tag for the case is at the send site and so doesn't need to be
	generated. 
 */

	/* Cogit>>#cogMNUPICSelector:receiver:methodOperand:numArgs: */
CogMethod *
cogMNUPICSelectorreceivermethodOperandnumArgs(sqInt selector, sqInt rcvr, sqInt methodOperand, sqInt numArgs)
{
    CogMethod *pic;
    sqInt startAddress;

	if ((isYoung(selector))
	 || ((inlineCacheTagForInstance(rcvr)) == 0)) {
		return 0;
	}
	compilationBreakpointisMNUCase(selector, numBytesOf(selector), 1);
	assert(endCPICCase0 != null);
	startAddress = allocate(closedPICSize);
	if (startAddress == 0) {
		callForCogCompiledCodeCompaction();
		return 0;
	}
	memcpy(startAddress, cPICPrototype, closedPICSize);
	configureMNUCPICmethodOperandnumArgsdelta(((CogMethod *) startAddress), methodOperand, numArgs, startAddress - cPICPrototype);
	/* begin fillInCPICHeader:numArgs:numCases:hasMNUCase:selector: */
	pic = ((CogMethod *) startAddress);
	assert(!(isYoung(selector)));
	(pic->cmType = CMClosedPIC);
	(pic->objectHeader = 0);
	(pic->blockSize = closedPICSize);
	(pic->methodObject = 0);
	(pic->methodHeader = 0);
	(pic->selector = selector);
	(pic->cmNumArgs = numArgs);
	(pic->cmRefersToYoung = 0);
	(pic->cmUsageCount = initialClosedPICUsageCount());
	(pic->cpicHasMNUCase = 1);
	(pic->cPICNumCases = 1);
	(pic->blockEntryOffset = 0);
	assert(((pic->cmType)) == CMClosedPIC);
	assert(((pic->selector)) == selector);
	assert(((pic->cmNumArgs)) == numArgs);
	assert(((pic->cPICNumCases)) == 1);
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)pic)) + missOffset)) == (picAbortTrampolineFor(numArgs)));
	assert(closedPICSize == (roundUpLength(closedPICSize)));
	flushICacheFromto(processor, ((usqInt)pic), (((usqInt)pic)) + closedPICSize);
	/* begin maybeEnableSingleStep */
	return pic;
}


/*	Create an Open PIC. Temporarily create a direct call of
	ceSendFromOpenPIC:. Should become a probe of the first-level method lookup
	cache followed by a
	call of ceSendFromOpenPIC: if the probe fails. */

	/* Cogit>>#cogOpenPICSelector:numArgs: */
static CogMethod * NoDbgRegParms
cogOpenPICSelectornumArgs(sqInt selector, sqInt numArgs)
{
    sqInt codeSize;
    sqInt end;
    sqInt fixupSize;
    sqInt mapSize;
    sqInt opcodeSize;
    CogMethod *pic;
    sqInt startAddress;

	compilationBreakpointisMNUCase(selector, numBytesOf(selector), 0);
	startAddress = allocate(openPICSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	(methodLabel->address = startAddress);
	(methodLabel->dependent = null);
	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 100;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;
	compileOpenPICnumArgs(selector, numArgs);
	computeMaximumSizes();
	concretizeAt(methodLabel, startAddress);
	codeSize = generateInstructionsAt(startAddress + (sizeof(CogMethod)));
	mapSize = generateMapAtstart((startAddress + openPICSize) - 1, startAddress + cmNoCheckEntryOffset);
	assert((((entry->address)) - startAddress) == cmEntryOffset);
	assert(((roundUpLength((sizeof(CogMethod)) + codeSize)) + (roundUpLength(mapSize))) <= openPICSize);
	end = outputInstructionsAt(startAddress + (sizeof(CogMethod)));
	/* begin fillInOPICHeader:numArgs:selector: */
	pic = ((CogMethod *) startAddress);
	(pic->cmType = CMOpenPIC);
	(pic->objectHeader = 0);
	(pic->blockSize = openPICSize);
	addToOpenPICList(pic);
	(pic->methodHeader = 0);
	(pic->selector = selector);
	(pic->cmNumArgs = numArgs);
	if ((pic->cmRefersToYoung = isYoung(selector))) {
		addToYoungReferrers(pic);
	}
	(pic->cmUsageCount = initialOpenPICUsageCount());
	(pic->cpicHasMNUCase = 0);
	(pic->cPICNumCases = 0);
	(pic->blockEntryOffset = 0);
	assert(((pic->cmType)) == CMOpenPIC);
	assert(((pic->selector)) == selector);
	assert(((pic->cmNumArgs)) == numArgs);
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)pic)) + missOffset)) == (picAbortTrampolineFor(numArgs)));
	assert(openPICSize == (roundUpLength(openPICSize)));
	flushICacheFromto(processor, ((usqInt)pic), (((usqInt)pic)) + openPICSize);
	/* begin maybeEnableSingleStep */
	return pic;
}


/*	Attempt to create a two-case PIC for case0CogMethod and
	case1Method,case1Tag. The tag for case0CogMethod is at the send site and
	so doesn't need to be generated.
	case1Method may be any of
	- a Cog method; link to its unchecked entry-point
	- a CompiledMethod; link to ceInterpretMethodFromPIC:
	- a CompiledMethod; link to ceMNUFromPICMNUMethod:receiver: */

	/* Cogit>>#cogPICSelector:numArgs:Case0Method:Case1Method:tag:isMNUCase: */
static CogMethod * NoDbgRegParms
cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase(sqInt selector, sqInt numArgs, CogMethod *case0CogMethod, sqInt case1MethodOrNil, sqInt case1Tag, sqInt isMNUCase)
{
    CogMethod *pic;
    sqInt startAddress;

	if (isYoung(selector)) {
		return ((CogMethod *) YoungSelectorInPIC);
	}
	compilationBreakpointisMNUCase(selector, numBytesOf(selector), isMNUCase);
	startAddress = allocate(closedPICSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	memcpy(startAddress, cPICPrototype, closedPICSize);
	configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(((CogMethod *) startAddress), case0CogMethod, case1MethodOrNil, case1Tag, isMNUCase, numArgs, startAddress - cPICPrototype);
	/* begin fillInCPICHeader:numArgs:numCases:hasMNUCase:selector: */
	pic = ((CogMethod *) startAddress);
	assert(!(isYoung(selector)));
	(pic->cmType = CMClosedPIC);
	(pic->objectHeader = 0);
	(pic->blockSize = closedPICSize);
	(pic->methodObject = 0);
	(pic->methodHeader = 0);
	(pic->selector = selector);
	(pic->cmNumArgs = numArgs);
	(pic->cmRefersToYoung = 0);
	(pic->cmUsageCount = initialClosedPICUsageCount());
	(pic->cpicHasMNUCase = isMNUCase);
	(pic->cPICNumCases = 2);
	(pic->blockEntryOffset = 0);
	assert(((pic->cmType)) == CMClosedPIC);
	assert(((pic->selector)) == selector);
	assert(((pic->cmNumArgs)) == numArgs);
	assert(((pic->cPICNumCases)) == 2);
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)pic)) + missOffset)) == (picAbortTrampolineFor(numArgs)));
	assert(closedPICSize == (roundUpLength(closedPICSize)));
	flushICacheFromto(processor, ((usqInt)pic), (((usqInt)pic)) + closedPICSize);
	/* begin maybeEnableSingleStep */
	return pic;
}


/*	Attempt to produce a machine code method for the bytecode method
	object aMethodObj. N.B. If there is no code memory available do *NOT*
	attempt to reclaim the method zone. Certain clients (e.g. ceSICMiss:)
	depend on the zone remaining constant across method generation. */

	/* Cogit>>#cog:selector: */
CogMethod *
cogselector(sqInt aMethodObj, sqInt aSelectorOop)
{
    CogMethod *cogMethod;

	assert(!((methodHasCogMethod(aMethodObj))));

	compilationBreakpointisMNUCase(aSelectorOop, lengthOf(aSelectorOop), 0);
	if (aMethodObj == breakMethod) {
		haltmsg("Compilation of breakMethod");
	}
	if (methodUsesAlternateBytecodeSet(aMethodObj)) {
		if ((numElementsIn(generatorTable)) <= 256) {
			return null;
		}
		bytecodeSetOffset = 256;
	}
	else {
		bytecodeSetOffset = 0;
	}
	ensureNoForwardedLiteralsIn(aMethodObj);
	methodObj = aMethodObj;
	methodHeader = methodHeaderOf(aMethodObj);
	cogMethod = compileCogMethod(aSelectorOop);
	if ((((((sqInt)cogMethod)) >= MaxNegativeErrorCode) && ((((sqInt)cogMethod)) <= -1))) {
		if ((((sqInt)cogMethod)) == InsufficientCodeSpace) {
			callForCogCompiledCodeCompaction();
		}
		return null;
	}
	return cogMethod;
}

	/* Cogit>>#compactCogCompiledCode */
void
compactCogCompiledCode(void)
{
	assert(noCogMethodsMaximallyMarked());
	markActiveMethodsAndReferents();
	freeOlderMethodsForCompaction();
	freePICsWithFreedTargets();
	planCompaction();
	updateStackZoneReferencesToCompiledCodePreCompaction();
	relocateMethodsPreCompaction();
	compactCompiledCode();
	assert(allMethodsHaveCorrectHeader());
	assert(kosherYoungReferrers());
	stopsFromto(backEnd, freeStart(), (youngReferrers()) - 1);
	flushICacheFromto(processor, ((usqInt)methodZoneBase), ((usqInt)(youngReferrers())));
}


/*	The start of a CogMethod has a call to a run-time abort routine that
	either handles an in-line cache failure or a stack overflow. The routine
	selects the
	path depending on ReceiverResultReg; if zero it takes the stack overflow
	path; if nonzero the in-line cache miss path. Neither of these paths
	returns. The abort routine must be called; In the callee the method is
	located by
	adding the relevant offset to the return address of the call.
	
	N.B. This code must match that in compilePICAbort: so that the offset of
	the return address of the call is the same in methods and closed PICs. */

	/* Cogit>>#compileAbort */
static AbstractInstruction *
compileAbort(void)
{
    AbstractInstruction *anInstruction;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, ReceiverResultReg);
	stackOverflowCall = anInstruction;
	return (sendMiss = gCall(methodAbortTrampolineFor(methodOrBlockNumArgs)));

}

	/* Cogit>>#compileBlockDispatchFrom:to: */
static sqInt NoDbgRegParms
compileBlockDispatchFromto(sqInt lowBlockStartIndex, sqInt highBlockStartIndex)
{
    AbstractInstruction *anInstruction;
    BlockStart *blockStart;
    sqInt halfWay;
    AbstractInstruction *jmp;
    void *jumpTarget;
    void *jumpTarget1;
    void *jumpTarget2;
    sqInt quickConstant;

	if (lowBlockStartIndex == highBlockStartIndex) {
		blockStart = blockStartAt(lowBlockStartIndex);
		/* begin Jump: */
		jumpTarget = (blockStart->entryLabel);
		genoperand(Jump, ((sqInt)jumpTarget));
		return null;
	}
	halfWay = (highBlockStartIndex + lowBlockStartIndex) / 2;
	assert(((halfWay >= lowBlockStartIndex) && (halfWay <= highBlockStartIndex)));

	/* N.B. FLAGS := TempReg - startpc */
	blockStart = blockStartAt(halfWay);
	/* begin CmpCq:R: */
	quickConstant = (((((blockStart->startpc)) + 1) << 3) | 1);
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (lowBlockStartIndex == halfWay) {
		/* begin JumpLessOrEqual: */
		jumpTarget1 = (blockStart->entryLabel);
		genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)jumpTarget1));
		compileBlockDispatchFromto(halfWay + 1, highBlockStartIndex);
		return null;
	}
	if ((halfWay + 1) == highBlockStartIndex) {
		blockStart = blockStartAt(highBlockStartIndex);
		/* begin JumpGreater: */
		jumpTarget2 = (blockStart->entryLabel);
		genConditionalBranchoperand(JumpGreater, ((sqInt)jumpTarget2));
		return compileBlockDispatchFromto(lowBlockStartIndex, halfWay);
	}
	/* begin JumpGreater: */
	jmp = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	compileBlockDispatchFromto(lowBlockStartIndex, halfWay);
	if (halfWay == highBlockStartIndex) {
		blockStart = blockStartAt(highBlockStartIndex);
		jmpTarget(jmp, (blockStart->entryLabel));
	}
	else {
		jmpTarget(jmp, gLabel());
		compileBlockDispatchFromto(halfWay + 1, highBlockStartIndex);
	}
	return 0;
}


/*	Compile a block's entry. This looks like a dummy CogBlockMethod header
	(for frame parsing)
	followed by either a frame build, if a frame is required, or nothing. The
	CogMethodHeader's objectHeader field is a back pointer to the method, but
	this can't be filled in until code generation. */

	/* Cogit>>#compileBlockEntry: */
static void NoDbgRegParms
compileBlockEntry(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    sqInt alignment;

	/* begin AlignmentNops: */
	alignment = blockAlignment();
	genoperand(AlignmentNops, alignment);
	(blockStart->fakeHeader = gLabel());
	
	switch (sizeof(CogBlockMethod)) {
	case 8:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		break;
	case 12:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		break;
	case 16:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		/* begin Fill32: */
		genoperand(Fill32, 0);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	(blockStart->entryLabel = gLabel());
	if (needsFrame) {
		compileBlockFrameBuild(blockStart);
		if (recordBlockTrace()) {
			/* begin CallRT: */
			abstractInstruction = genoperand(Call, ceTraceBlockActivationTrampoline);
			(abstractInstruction->annotation = IsRelativeCall);
		}
	}
	else {
		compileBlockFramelessEntry(blockStart);
	}
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. */

	/* Cogit>>#compileCallFor:numArgs:arg:arg:arg:arg:resultReg:regsToSave: */
static void NoDbgRegParms
compileCallFornumArgsargargargargresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    sqInt callTarget;
    const int cStackAlignment = STACK_ALIGN_BYTES;
    sqInt delta;
    usqInt numRegsPushed;
    usqInt regMaskCopy;
    sqInt regsToSave;
    sqInt wordsPushedModAlignment;

	regsToSave = (resultRegOrNone == NoReg
		? regMask
		: ((regMask | (1LL << resultRegOrNone)) - (1LL << resultRegOrNone)));
	if (cStackAlignment > BytesPerWord) {
		/* begin genAlignCStackSavingRegisters:numArgs:wordAlignment: */
		regMaskCopy = ((usqInt)regsToSave);
		numRegsPushed = 0;
		while (regMaskCopy != 0) {
			numRegsPushed += regMaskCopy & 1;
			regMaskCopy = ((usqInt) regMaskCopy >> 1);
		}
		if ((numRegsPushed == 0)
		 && ((numIntRegArgs(((AbstractInstruction *) backEnd))) >= numArgs)) {
			goto l1;
		}
		wordsPushedModAlignment = (numRegsPushed + numArgs) % (cStackAlignment / BytesPerWord);
		if (wordsPushedModAlignment != 0) {
			delta = (cStackAlignment / BytesPerWord) - wordsPushedModAlignment;
			/* begin SubCq:R: */
			anInstruction = genoperandoperand(SubCqR, delta * BytesPerWord, SPReg);
		}
	l1:	/* end genAlignCStackSavingRegisters:numArgs:wordAlignment: */;
	}
	genSaveRegs(backEnd, regsToSave);
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	if (numArgs == 0) {
		((AbstractInstruction *) backEnd);
		goto l15;
	}
	if (regOrConst0 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction6 = genoperandoperand(MoveCqR, -2 - regOrConst0, RDI);
	}
	else {
		if (regOrConst0 != RDI) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst0, RDI);
		}
	}
	if (numArgs == 1) {
		((AbstractInstruction *) backEnd);
		goto l15;
	}
	if (regOrConst1 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction1 = genoperandoperand(MoveCqR, -2 - regOrConst1, RSI);
	}
	else {
		if (regOrConst1 != RSI) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst1, RSI);
		}
	}
	if (numArgs == 2) {
		((AbstractInstruction *) backEnd);
		goto l15;
	}
	
#  if ABI == SysV
	if (regOrConst2 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction2 = genoperandoperand(MoveCqR, -2 - regOrConst2, RDX);
	}
	else {
		if (regOrConst2 != RDX) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst2, RDX);
		}
	}
	if (numArgs == 3) {
		((AbstractInstruction *) backEnd);
		goto l15;
	}
	if (regOrConst3 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction3 = genoperandoperand(MoveCqR, -2 - regOrConst3, RCX);
	}
	else {
		if (regOrConst3 != RCX) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst3, RCX);
		}
	}

#  endif /* ABI == SysV */

	
#  if ABI == MSVC
	if (regOrConst2 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction4 = genoperandoperand(MoveCqR, -2 - regOrConst2, R8);
	}
	else {
		if (regOrConst2 != R8) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst2, R8);
		}
	}
	if (numArgs == 3) {
		((AbstractInstruction *) backEnd);
		goto l15;
	}
	if (regOrConst3 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction5 = genoperandoperand(MoveCqR, -2 - regOrConst3, R9);
	}
	else {
		if (regOrConst3 != R9) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst3, R9);
		}
	}

#  endif /* ABI == MSVC */

	assert(numArgs <= 4);
	((AbstractInstruction *) backEnd);
l15:	/* end genMarshallNArgs:arg:arg:arg:arg: */;
	/* begin CallFullRT: */
	callTarget = ((usqInt)aRoutine);
	/* begin CallFull: */
	anInstruction7 = genoperand(CallFull, callTarget);

	if (resultRegOrNone != NoReg) {
		genWriteCResultIntoReg(backEnd, resultRegOrNone);
	}
	if (numArgs > 0) {
		genRemoveNArgsFromStack(backEnd, numArgs);
	}
	genRestoreRegs(backEnd, regsToSave);
}


/*	Compile the cache tag computation and the first comparison. Answer the
	address of that comparison. */

	/* Cogit>>#compileCPICEntry */
static AbstractInstruction *
compileCPICEntry(void)
{
	entry = genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, TempReg, 1);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, ClassReg, TempReg);
	/* begin JumpNonZero: */
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}


/*	The entry code to a method checks that the class of the current receiver
	matches that in the inline cache. Other non-obvious elements are that its
	alignment must be
	different from the alignment of the noCheckEntry so that the method map
	machinery can distinguish normal and super sends (super sends bind to the
	noCheckEntry).  */

	/* Cogit>>#compileEntry */
static void
compileEntry(void)
{
    AbstractInstruction *abstractInstruction;

	entry = genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, TempReg, 1);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, ClassReg, TempReg);
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)sendMiss));
	/* begin Label */
	noCheckEntry = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (compileSendTrace()) {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceTraceLinkedSendTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);

	}
}


/*	Compile the top-level method body. */

	/* Cogit>>#compileMethodBody */
static sqInt
compileMethodBody(void)
{
	if (endPC < initialPC) {
		return 0;
	}
	return compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
}


/*	The start of a PIC has a call to a run-time abort routine that either
	handles a dispatch to an
	interpreted method or a dispatch of an MNU case. The routine selects the
	path by testing
	ClassReg, which holds the inline cache tag; if equal to the
	picAbortDiscriminatorValue (zero)
	it takes the MNU path; if nonzero the dispatch to interpreter path.
	Neither of these paths
	returns. The abort routine must be called; In the callee the PIC is
	located by adding the
	relevant offset to the return address of the call.
	
	N.B. This code must match that in compileAbort so that the offset of the
	return address of
	the call is the same in methods and closed PICs. */

	/* Cogit>>#compilePICAbort: */
static sqInt NoDbgRegParms
compilePICAbort(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    sqInt callTarget1;
    AbstractInstruction * picMNUAbort;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, ClassReg);
	picMNUAbort = anInstruction;
	/* begin Call: */
	callTarget1 = picAbortTrampolineFor(numArgs);
	picInterpretAbort = genoperand(Call, callTarget1);

	return 0;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg: */
static void NoDbgRegParms
compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsargargargargresultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, regMask);
	genLoadStackPointers(backEnd);
	/* begin RetN: */
	genoperand(RetN, 0);

}


/*	Generate the entry code for a method to determine cmEntryOffset and
	cmNoCheckEntryOffset. We
	need cmNoCheckEntryOffset up front to be able to generate the map starting
	from cmNoCheckEntryOffset */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#computeEntryOffsets */
static void
computeEntryOffsets(void)
{
    sqInt checkedEntryAlignment;
    sqInt entryPointMask;
    sqInt fixupSize;
    sqInt opcodeSize;
    AbstractInstruction *sendMissCall;
    sqInt uncheckedEntryAlignment;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 24;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;
	methodOrBlockNumArgs = 0;
	sendMissCall = compileAbort();
	compileEntry();
	computeMaximumSizes();
	generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	cmEntryOffset = ((entry->address)) - methodZoneBase;
	cmNoCheckEntryOffset = ((noCheckEntry->address)) - methodZoneBase;
	missOffset = (((sendMissCall->address)) + ((sendMissCall->machineCodeSize))) - methodZoneBase;
	entryPointMask = BytesPerWord - 1;
	while ((cmEntryOffset & entryPointMask) == (cmNoCheckEntryOffset & entryPointMask)) {
		entryPointMask = (entryPointMask + entryPointMask) + 1;
	}
	if (entryPointMask >= (roundUpLength(1))) {
		error("cannot differentiate checked and unchecked entry-points with current cog method alignment");
	}
	checkedEntryAlignment = cmEntryOffset & entryPointMask;
	uncheckedEntryAlignment = cmNoCheckEntryOffset & entryPointMask;
	assert(checkedEntryAlignment != uncheckedEntryAlignment);
}


/*	This pass assigns maximum sizes to all abstract instructions and
	eliminates jump fixups.
	It hence assigns the maximum address an instruction will occur at which
	allows the next
	pass to conservatively size jumps. */

	/* Cogit>>#computeMaximumSizes */
static void
computeMaximumSizes(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt relativeAddress;

	relativeAddress = 0;
	for (i = 0; i < opcodeIndex; i += 1) {
		abstractInstruction = abstractInstructionAt(i);
		(abstractInstruction->address = relativeAddress);
		(abstractInstruction->maxSize = computeMaximumSize(abstractInstruction));
		relativeAddress += (abstractInstruction->maxSize);
	}
}


/*	Configure a copy of the prototype CPIC for a two-case PIC for 
	case0CogMethod and
	case1Method
	case1Tag.
	The tag for case0CogMethod is at the send site and so doesn't need to be
	generated. case1Method may be any of
	- a Cog method; jump to its unchecked entry-point
	- a CompiledMethod; jump to the ceInterpretFromPIC trampoline
	- nil; call ceMNUFromPIC
	addDelta is the address change from the prototype to the new CPIC
	location, needed
	because the loading of the CPIC label at the end may use a literal instead
	of a pc relative load. */
/*	self disassembleFrom: cPIC asInteger + (self sizeof: CogMethod) to: cPIC
	asInteger + closedPICSize
 */

	/* Cogit>>#configureCPIC:Case0:Case1Method:tag:isMNUCase:numArgs:delta: */
static sqInt NoDbgRegParms
configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(CogMethod *cPIC, CogMethod *case0CogMethod, sqInt case1Method, sqInt case1Tag, sqInt isMNUCase, sqInt numArgs, sqInt addrDelta)
{
    sqInt caseEndAddress;
    sqInt jumpTargetAddress;
    sqInt operand;
    sqInt pc;
    sqInt targetEntry;

	assert(case1Method != null);
	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + missOffset, picAbortTrampolineFor(numArgs));
	assert(!(inlineCacheTagIsYoung(case1Tag)));
	if ((!isMNUCase)
	 && (methodHasCogMethod(case1Method))) {
		operand = 0;
		targetEntry = (((sqInt)(cogMethodOf(case1Method)))) + cmNoCheckEntryOffset;
	}
	else {

		/* We do not scavenge PICs, hence we cannot cache the MNU method if it is in new space. */
		operand = ((case1Method == null)
		 || (isYoungObject(case1Method))
			? 0
			: case1Method);
		targetEntry = (case1Method == null
			? (((sqInt)cPIC)) + (sizeof(CogMethod))
			: (((sqInt)cPIC)) + (picInterpretAbortOffset()));
	}
	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + firstCPICCaseOffset, (((sqInt)case0CogMethod)) + cmNoCheckEntryOffset);

	/* update the cpic case */
	caseEndAddress = addressOfEndOfCaseinCPIC(2, cPIC);
	rewriteCPICCaseAttagobjReftarget(caseEndAddress, case1Tag, operand, ((sqInt)((isMNUCase
	? (((sqInt)cPIC)) + (sizeof(CogMethod))
	: targetEntry))));
	/* begin relocateMethodReferenceBeforeAddress:by: */
	pc = ((((sqInt)cPIC)) + cPICEndOfCodeOffset) - (jumpLongByteSize(backEnd));
	assert((((byteAt(pc - 6)) == 141)
	 && (((byteAt(pc - 5)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7))))
	 || (((byteAt(pc - 8)) == 141)
	 && (((byteAt(pc - 7)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7)))));
	((AbstractInstruction *) backEnd);
	/* begin rewriteJumpLongAt:target: */
	jumpTargetAddress = cPICMissTrampolineFor(numArgs);
	rewriteCallAttarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + cPICEndOfCodeOffset, jumpTargetAddress);
	return 0;
}


/*	Configure a copy of the prototype CPIC for a one-case MNU CPIC that calls
	ceMNUFromPIC for
	case0Tag The tag for case0 is at the send site and so doesn't need to be
	generated. addDelta is the address change from the prototype to the new
	CPIC location, needed
	because the loading of the CPIC label at the end may be a literal instead
	of a pc-relative load. */
/*	adjust the jump at missOffset, the ceAbortXArgs */

	/* Cogit>>#configureMNUCPIC:methodOperand:numArgs:delta: */
static sqInt NoDbgRegParms
configureMNUCPICmethodOperandnumArgsdelta(CogMethod *cPIC, sqInt methodOperand, sqInt numArgs, sqInt addrDelta)
{
    sqInt jumpTargetAddress;
    sqInt jumpTargetAddress1;
    sqInt operand;
    sqInt pc;
    sqInt target;

	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + missOffset, picAbortTrampolineFor(numArgs));

	/* set the jump to the case0 method */
	operand = ((methodOperand == null)
	 || (isYoungObject(methodOperand))
		? 0
		: methodOperand);
	/* begin rewriteJumpLongAt:target: */
	jumpTargetAddress = (((sqInt)cPIC)) + (sizeof(CogMethod));
	rewriteCallAttarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + firstCPICCaseOffset, jumpTargetAddress);
	storeLiteralbeforeFollowingAddress(backEnd, operand, ((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd)));
	/* begin rewriteJumpLongAt:target: */
	jumpTargetAddress1 = cPICMissTrampolineFor(numArgs);
	rewriteCallAttarget(((AbstractInstruction *) backEnd), (((sqInt)cPIC)) + cPICEndOfCodeOffset, jumpTargetAddress1);
	/* begin relocateMethodReferenceBeforeAddress:by: */
	pc = ((((sqInt)cPIC)) + cPICEndOfCodeOffset) - (jumpLongByteSize(backEnd));
	assert((((byteAt(pc - 6)) == 141)
	 && (((byteAt(pc - 5)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7))))
	 || (((byteAt(pc - 8)) == 141)
	 && (((byteAt(pc - 7)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7)))));
	((AbstractInstruction *) backEnd);
	/* begin rewriteCPIC:caseJumpTo: */
	target = addressOfEndOfCaseinCPIC(2, cPIC);
	rewriteCPICJumpAttarget(backEnd, (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - 11, target);
	return 0;
}


/*	The first case in a CPIC doesn't have a class reference so we need only
	step over actually usd subsequent cases.
 */

	/* Cogit>>#cPICHasForwardedClass: */
static sqInt NoDbgRegParms
cPICHasForwardedClass(CogMethod *cPIC)
{
    usqInt classIndex;
    sqInt i;
    sqInt pc;


	/* start by finding the address of the topmost case, the cPICNumCases'th one */
	pc = (addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC)) - (jumpLongConditionalByteSize(backEnd));
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		classIndex = literal32BeforeFollowingAddress(backEnd, pc);
		if (isForwardedClassIndex(classIndex)) {
			return 1;
		}
		pc += cPICCaseSize;
	}
	return 0;
}


/*	scan the CPIC for target methods that have been freed. */

	/* Cogit>>#cPICHasFreedTargets: */
static sqInt NoDbgRegParms
cPICHasFreedTargets(CogMethod *cPIC)
{
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    CogMethod *targetMethod;

	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);

		if (!(((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
			 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint))))) {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert((((targetMethod->cmType)) == CMMethod)
			 || (((targetMethod->cmType)) == CMFree));
			if (((targetMethod->cmType)) == CMFree) {
				return 1;
			}
		}
	}
	return 0;
}


/*	Whimsey; we want 16rCA5E10 + cPICPrototypeCaseOffset to be somewhere in
	the middle of the zone.
 */

	/* Cogit>>#cPICPrototypeCaseOffset */
static sqInt
cPICPrototypeCaseOffset(void)
{
	return ((methodZoneBase + (youngReferrers())) / 2) - 13262352;
}


/*	Are any of the jumps from this CPIC to targetMethod? */

	/* Cogit>>#cPIC:HasTarget: */
static sqInt NoDbgRegParms
cPICHasTarget(CogMethod *cPIC, CogMethod *targetMethod)
{
    sqInt i;
    sqInt pc;
    usqInt target;

	target = (((usqInt)targetMethod)) + cmNoCheckEntryOffset;

	/* Since this is a fast test doing simple compares we don't need to care that some
	   cases have nonsense addresses in there. Just zip on through. */
	/* First jump is unconditional; subsequent ones are conditional */
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	if (target == (jumpLongTargetBeforeFollowingAddress(backEnd, pc))) {
		return 1;
	}
	for (i = 2; i <= maxCPICCases; i += 1) {
		pc += cPICCaseSize;
		if (target == (jumpLongTargetBeforeFollowingAddress(backEnd, pc))) {
			return 1;
		}
	}
	return 0;
}


/*	Division is a little weird on some processors. Defer to the backEnd
	to allow it to generate any special code it may need to. */

	/* Cogit>>#DivR:R:Quo:Rem: */
static AbstractInstruction * NoDbgRegParms
gDivRRQuoRem(sqInt rDivisor, sqInt rDividend, sqInt rQuotient, sqInt rRemainder)
{
	genDivRRQuoRem(backEnd, rDivisor, rDividend, rQuotient, rRemainder);
	return abstractInstructionAt(opcodeIndex - 1);
}


/*	Return the default number of bytes to allocate for native code at startup.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file. */

	/* Cogit>>#defaultCogCodeSize */
sqInt
defaultCogCodeSize(void)
{
	return 1024 * 1400;
}


/*	Answer the number of bytecodes to skip to get to the first bytecode
	past the primitive call and any store of the error code. */

	/* Cogit>>#deltaToSkipPrimAndErrorStoreIn:header: */
static sqInt NoDbgRegParms
deltaToSkipPrimAndErrorStoreInheader(sqInt aMethodObj, sqInt aMethodHeader)
{
	return (((primitiveIndexOfMethodheader(aMethodObj, aMethodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(aMethodHeader)) == (fetchByteofObject(initialPC + (sizeOfCallPrimitiveBytecode(aMethodHeader)), aMethodObj)))
		? (sizeOfCallPrimitiveBytecode(aMethodHeader)) + (sizeOfLongStoreTempBytecode(aMethodHeader))
		: 0);
}

	/* Cogit>>#endPCOf: */
static sqInt NoDbgRegParms
endPCOf(sqInt aMethod)
{
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt end;
    sqInt latestContinuation;
    sqInt nExts;
    sqInt pc;
    sqInt prim;
    sqInt targetPC;

	pc = (latestContinuation = startPCOfMethod(aMethod));
	if (((prim = primitiveIndexOf(aMethod))) > 0) {
		if (isQuickPrimitiveIndex(prim)) {
			return pc - 1;
		}
	}
	bsOffset = 
#  if MULTIPLEBYTECODESETS
		(methodUsesAlternateBytecodeSet(aMethod)
				? 256
				: 0)
#  else /* MULTIPLEBYTECODESETS */
		0
#  endif /* MULTIPLEBYTECODESETS */
		;
	nExts = 0;
	end = numBytesOf(aMethod);
	while (pc <= end) {
		byte = fetchByteofObject(pc, aMethod);
		descriptor = generatorAt(byte + bsOffset);
		if (((descriptor->isReturn))
		 && (pc >= latestContinuation)) {
			end = pc;
		}
		if ((isBranch(descriptor))
		 || ((descriptor->isBlockCreation))) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, aMethod);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
			if ((descriptor->isBlockCreation)) {
				pc += distance;
			}
		}
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
		pc += (descriptor->numBytes);
	}
	return end;
}


/*	This is a static version of ceEnterCogCodePopReceiverReg
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* Cogit>>#enterCogCodePopReceiver */
void
enterCogCodePopReceiver(void)
{
	realCEEnterCogCodePopReceiverReg();
	error("what??");

}


/*	Use asserts to check if the ClosedPICPrototype is as expected from
	compileClosedPICPrototype, and can be updated as required via
	rewriteCPICCaseAt:tag:objRef:target:. If all asserts pass, answer
	0, otherwise answer a bit mask identifying all the errors. */
/*	self disassembleFrom: methodZoneBase + (self sizeof: CogMethod) to:
	methodZoneBase + closedPICSize
 */

	/* Cogit>>#expectedClosedPICPrototype: */
static sqInt NoDbgRegParms
expectedClosedPICPrototype(CogMethod *cPIC)
{
    usqInt classTag;
    usqInt classTagPC;
    sqInt entryPoint;
    sqInt errors;
    sqInt i;
    usqInt methodObjPC;
    sqInt object;
    usqInt pc;

	errors = 0;

	/* First jump is unconditional; subsequent ones are conditional */
	pc = (((usqInt)cPIC)) + firstCPICCaseOffset;
	object = literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)));
	if (!(asserta(object == 99282957))) {
		errors = 1;
	}
	entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
	if (!(asserta(entryPoint == ((cPICPrototypeCaseOffset()) + 13262352)))) {
		errors += 2;
	}
	for (i = 1; i < maxCPICCases; i += 1) {

		/* verify information in case is as expected. */
		pc += cPICCaseSize;
		methodObjPC = (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd));
		object = literalBeforeFollowingAddress(backEnd, methodObjPC);
		if (!(asserta(object == (195929424 + i)))) {
			errors = errors | 4;
		}
		classTagPC = pc - (jumpLongConditionalByteSize(backEnd));
		classTag = literal32BeforeFollowingAddress(backEnd, classTagPC);
		if (!(asserta(classTag == (3133021973ULL + i)))) {
			errors = errors | 8;
		}
		entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		if (!(asserta(entryPoint == (((cPICPrototypeCaseOffset()) + 13262352) + (i * 16))))) {
			errors = errors | 16;
		}
		rewriteCPICCaseAttagobjReftarget(pc, classTag ^ 1515870810, object ^ 2779096485ULL, entryPoint ^ 5614160);
		object = literalBeforeFollowingAddress(backEnd, methodObjPC);
		if (!(asserta(object == ((195929424 + i) ^ 2779096485ULL)))) {
			errors = errors | 32;
		}
		classTag = literal32BeforeFollowingAddress(backEnd, classTagPC);
		if (!(asserta(classTag == ((3133021973ULL + i) ^ 1515870810)))) {
			errors = errors | 64;
		}
		entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		if (!(asserta(entryPoint == ((((cPICPrototypeCaseOffset()) + 13262352) + (i * 16)) ^ 5614160)))) {
			errors = errors | 128;
		}
		rewriteCPICCaseAttagobjReftarget(pc, classTag ^ 1515870810, object ^ 2779096485ULL, entryPoint ^ 5614160);
	}
	entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, (pc + cPICEndSize));
	if (!(asserta(entryPoint == (cPICMissTrampolineFor(0))))) {
		errors += 256;
	}
	return errors;
}


/*	Fill in the block headers now we know the exact layout of the code. */

	/* Cogit>>#fillInBlockHeadersAt: */
static sqInt NoDbgRegParms
fillInBlockHeadersAt(sqInt startAddress)
{
    CogBlockMethod *blockHeader;
    BlockStart *blockStart;
    sqInt i;

	if (!(needsFrame
		 && (blockCount > 0))) {
		return null;
	}
	if (blockNoContextSwitchOffset == null) {
		blockNoContextSwitchOffset = ((blockEntryLabel->address)) - ((blockEntryNoContextSwitch->address));
	}
	else {
		assert(blockNoContextSwitchOffset == (((blockEntryLabel->address)) - ((blockEntryNoContextSwitch->address))));
	}
	for (i = 0; i < blockCount; i += 1) {
		blockStart = blockStartAt(i);
		blockHeader = ((CogBlockMethod *) ((((blockStart->fakeHeader))->address)));
		(blockHeader->homeOffset = ((((blockStart->fakeHeader))->address)) - startAddress);
		(blockHeader->startpc = (blockStart->startpc));
		(blockHeader->cmType = CMBlock);
		(blockHeader->cmNumArgs = (blockStart->numArgs));
		(blockHeader->cbUsesInstVars = (blockStart->hasInstVarRef));
		(blockHeader->stackCheckOffset = (((blockStart->stackCheckLabel)) == null
			? 0
			: ((((blockStart->stackCheckLabel))->address)) - ((((blockStart->fakeHeader))->address))));
	}
	return 0;
}

	/* Cogit>>#fillInMethodHeader:size:selector: */
static CogMethod * NoDbgRegParms
fillInMethodHeadersizeselector(CogMethod *method, sqInt size, sqInt selector)
{
    CogMethod *originalMethod;
    sqInt rawHeader;

	(method->cmType = CMMethod);
	(method->objectHeader = nullHeaderForMachineCodeMethod());
	(method->blockSize = size);
	(method->methodObject = methodObj);

	/* If the method has already been cogged (e.g. Newspeak accessors) then
	   leave the original method attached to its cog method, but get the right header. */
	rawHeader = rawHeaderOf(methodObj);
	if (isCogMethodReference(rawHeader)) {
		originalMethod = ((CogMethod *) rawHeader);
		assert(((originalMethod->blockSize)) == size);
		assert(methodHeader == ((originalMethod->methodHeader)));
			}
	else {
		rawHeaderOfput(methodObj, ((sqInt)method));
			}
	(method->methodHeader = methodHeader);
	(method->selector = selector);
	(method->cmNumArgs = argumentCountOfMethodHeader(methodHeader));
	if ((method->cmRefersToYoung = hasYoungReferent)) {
		addToYoungReferrers(method);
	}
	(method->cmUsageCount = initialMethodUsageCount());
	(method->cpicHasMNUCase = 0);
	(method->cmUsesPenultimateLit = maxLitIndex >= ((literalCountOfMethodHeader(methodHeader)) - 2));
	(method->blockEntryOffset = (blockEntryLabel != null
		? ((blockEntryLabel->address)) - (((sqInt)method))
		: 0));
	if (needsFrame) {
		if (!((((stackCheckLabel->address)) - (((sqInt)method))) <= MaxStackCheckOffset)) {
			error("too much code for stack check offset");
		}
	}
	(method->stackCheckOffset = (needsFrame
		? ((stackCheckLabel->address)) - (((sqInt)method))
		: 0));
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)method)) + missOffset)) == (methodAbortTrampolineFor((method->cmNumArgs))));
	assert(size == (roundUpLength(size)));
	flushICacheFromto(processor, ((usqInt)method), (((usqInt)method)) + size);
	/* begin maybeEnableSingleStep */
	return method;
}

	/* Cogit>>#findBlockMethodWithEntry:startBcpc: */
static usqInt NoDbgRegParms
findBlockMethodWithEntrystartBcpc(sqInt blockEntryMcpc, sqInt startBcpc)
{
    CogBlockMethod *cogBlockMethod;

	cogBlockMethod = ((CogBlockMethod *) (blockEntryMcpc - (sizeof(CogBlockMethod))));
	if (((cogBlockMethod->startpc)) == startBcpc) {
		return ((usqInt)cogBlockMethod);
	}
	return 0;
}

	/* Cogit>>#findMapLocationForMcpc:inMethod: */
static sqInt NoDbgRegParms
findMapLocationForMcpcinMethod(sqInt targetMcpc, CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;

	mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	if (mcpc == targetMcpc) {
		return map;
	}
	while (((mapByte = byteAt(map))) != MapEnd) {
		annotation = ((usqInt) mapByte) >> AnnotationShift;
		if (annotation != IsAnnotationExtension) {
			mcpc += 1 * ((annotation == IsDisplacementX2N
	? ((long)(mapByte - DisplacementX2N)) << AnnotationShift
	: mapByte & DisplacementMask));
		}
		if (mcpc >= targetMcpc) {
			assert(mcpc == targetMcpc);
			if (annotation == IsDisplacementX2N) {
				map -= 1;
				mapByte = byteAt(map);
				annotation = ((usqInt) mapByte) >> AnnotationShift;
				assert(annotation > IsAnnotationExtension);
			}
			return map;
		}
		map -= 1;
	}
	return 0;
}


/*	Find the CMMethod or CMBlock that has zero-relative startbcpc as its first
	bytecode pc.
	As this is for cannot resume processing and/or conversion to machine-code
	on backward
	branch, it doesn't have to be fast. Enumerate block returns and map to
	bytecode pcs. */

	/* Cogit>>#findMethodForStartBcpc:inHomeMethod: */
CogBlockMethod *
findMethodForStartBcpcinHomeMethod(sqInt startbcpc, CogMethod *cogMethod)
{
	assert(((cogMethod->cmType)) == CMMethod);
	if (startbcpc == (startPCOfMethodHeader((cogMethod->methodHeader)))) {
		return ((CogBlockMethod *) cogMethod);
	}
	assert(((cogMethod->blockEntryOffset)) != 0);
	return ((CogBlockMethod *) (blockDispatchTargetsForperformarg(cogMethod, findBlockMethodWithEntrystartBcpc, startbcpc)));
}


/*	Machine code addresses map to the following bytecode for all bytecodes
	except backward branches, where they map to the backward branch itself.
	This is so that loops continue, rather than terminate prematurely. */

	/* Cogit>>#find:IsBackwardBranch:Mcpc:Bcpc:MatchingMcpc: */
static sqInt NoDbgRegParms
findIsBackwardBranchMcpcBcpcMatchingMcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranch, char *mcpc, sqInt bcpc, void *targetMcpc)
{
	return (targetMcpc == mcpc
		? ((descriptor == null)
			 || (isBackwardBranch)
				? bcpc
				: bcpc + ((descriptor->numBytes)))
		: 0);
}

	/* Cogit>>#followForwardedLiteralsIn: */
void
followForwardedLiteralsIn(CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	assert(!(isForwarded((cogMethod->methodObject))));
	if (shouldRemapOop((cogMethod->selector))) {
		(cogMethod->selector = remapObj((cogMethod->selector)));
		if (isYoung((cogMethod->selector))) {
			ensureInYoungReferrers(cogMethod);
		}
	}
	/* begin mapFor:performUntil:arg: */
	mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;

	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {

			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask);
			if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = remapIfObjectRefpchasYoung(annotation, (((char *) mcpc)), 0);
			if (result != 0) {
				goto l1;
			}
		}
		else {
			if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
				mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
			}
		}
		map -= 1;
	}
l1:	/* end mapFor:performUntil:arg: */;
}

	/* Cogit>>#followForwardedMethods */
void
followForwardedMethods(void)
{
    CogMethod *cogMethod;
    sqInt freedPIC;

	freedPIC = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethod) {
			if (isForwarded((cogMethod->methodObject))) {
				(cogMethod->methodObject = followForwarded((cogMethod->methodObject)));
				if (isYoungObject((cogMethod->methodObject))) {
					ensureInYoungReferrers(cogMethod);
				}
			}
		}
		if (((cogMethod->cmType)) == CMClosedPIC) {
			if (followMethodReferencesInClosedPIC(cogMethod)) {
				freedPIC = 1;
				freeMethod(cogMethod);
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedPIC) {
		unlinkSendsToFree();
	}
}


/*	Follow a potential object reference from a closed PIC.
	This may be a method reference or null.
	Answer if the followed literal is young.
	'mcpc' refers to the jump/branch instruction at the end of
	each cpic case */

	/* Cogit>>#followMaybeObjRefInClosedPICAt: */
static sqInt NoDbgRegParms
followMaybeObjRefInClosedPICAt(sqInt mcpc)
{
    sqInt object;
    sqInt subject;

	object = literalBeforeFollowingAddress(backEnd, mcpc);
	if (!(couldBeObject(object))) {
		return 0;
	}
	if (!(isForwarded(object))) {
		return isYoungObject(object);
	}
	subject = followForwarded(object);
	storeLiteralbeforeFollowingAddress(backEnd, subject, mcpc);
	codeModified = 1;
	return isYoungObject(subject);
}


/*	Remap all object references in the closed PIC. Answer if any references
	are young.
	Set codeModified if any modifications are made. */

	/* Cogit>>#followMethodReferencesInClosedPIC: */
static sqInt NoDbgRegParms
followMethodReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt pc;
    sqInt refersToYoung;


	/* first we check the potential method oop load at the beginning of the CPIC */
	pc = addressOfEndOfCaseinCPIC(1, cPIC);

	/* We find the end address of the cPICNumCases'th case and can then just step forward by the case size thereafter */
	refersToYoung = followMaybeObjRefInClosedPICAt(pc - (jumpLongByteSize(backEnd)));

	/* Next we check the potential potential method oop load for each case. */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (followMaybeObjRefInClosedPICAt((pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))) {
			refersToYoung = 1;
		}
		pc += cPICCaseSize;
	}
	return refersToYoung;
}

	/* Cogit>>#freePICsWithFreedTargets */
static void
freePICsWithFreedTargets(void)
{
    CogMethod *cogMethod;
    sqInt count;

	cogMethod = ((CogMethod *) methodZoneBase);
	count = 0;
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) == CMClosedPIC)
		 && (cPICHasFreedTargets(cogMethod))) {
			(cogMethod->cmType = CMFree);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		count += 1;
	}
	assert(count == (numMethods()));
}


/*	Free machine-code methods whose compiled methods are unmarked
	and open PICs whose selectors are not marked, and closed PICs that
	refer to unmarked objects. */

	/* Cogit>>#freeUnmarkedMachineCode */
void
freeUnmarkedMachineCode(void)
{
    CogMethod *cogMethod;
    sqInt freedMethod;

	freedMethod = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) == CMMethod)
		 && (!(isMarked((cogMethod->methodObject))))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		if ((((cogMethod->cmType)) == CMOpenPIC)
		 && ((!(isImmediate((cogMethod->selector))))
		 && (!(isMarked((cogMethod->selector)))))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		if ((((cogMethod->cmType)) == CMClosedPIC)
		 && (closedPICRefersToUnmarkedObject(cogMethod))) {
			freedMethod = 1;
			freeMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedMethod) {
		unlinkSendsToFree();
	}
}

	/* Cogit>>#genCheckForInterruptsTrampoline */
static sqInt
genCheckForInterruptsTrampoline(void)
{
    sqInt address1;
    AbstractInstruction *anInstruction1;

	zeroOpcodeIndex();
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin MoveR:Aw: */
	address1 = instructionPointerAddress();
	/* begin gen:operand:literal: */
	anInstruction1 = genoperandoperand(MoveRAw, TempReg, address1);

	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCheckForInterrupts, "ceCheckForInterruptsTrampoline", 0, null, null, null, null, 0, 0, NoReg, 1);
}

	/* Cogit>>#genConditionalBranch:operand: */
static AbstractInstruction * NoDbgRegParms
genConditionalBranchoperand(sqInt opcode, sqInt operandOne)
{
    AbstractInstruction *branch;
    AbstractInstruction * self_in_noteFollowingConditionalBranch;

	/* begin noteFollowingConditionalBranch: */
	self_in_noteFollowingConditionalBranch = previousInstruction();
	branch = genoperand(opcode, operandOne);
	return branch;
}


/*	An enilopmart (the reverse of a trampoline) is a piece of code that makes
	the system-call-like transition from the C runtime into generated machine
	code. The desired arguments and entry-point are pushed on a stackPage's
	stack. The enilopmart pops off the values to be loaded into registers and
	then executes a return instruction to pop off the entry-point and jump to
	it. 
	BEFORE				AFTER			(stacks grow down)
	whatever			stackPointer ->	whatever
	target address =>	reg1 = reg1val, etc
	reg1val				pc = target address
	reg2val
	stackPointer ->	reg3val */

	/* Cogit>>#genEnilopmartFor:and:and:forCall:called: */
static void (*genEnilopmartForandandforCallcalled(sqInt regArg1, sqInt regArg2OrNone, sqInt regArg3OrNone, sqInt forCall, char *trampolineName))(void)

{
    AbstractInstruction *anInstruction;
    sqInt endAddress;
    sqInt enilopmart;
    sqInt quickConstant;
    sqInt size;

	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);

	genLoadStackPointers(backEnd);
	if (regArg3OrNone != NoReg) {
		/* begin PopR: */
		genoperand(PopR, regArg3OrNone);
	}
	if (regArg2OrNone != NoReg) {
		/* begin PopR: */
		genoperand(PopR, regArg2OrNone);
	}
	/* begin PopR: */
	genoperand(PopR, regArg1);
	genEnilopmartReturn(forCall);
	computeMaximumSizes();
	size = generateInstructionsAt(methodZoneBase);
	endAddress = outputInstructionsAt(methodZoneBase);
	assert((methodZoneBase + size) == endAddress);
	enilopmart = methodZoneBase;
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	recordGeneratedRunTimeaddress(trampolineName, enilopmart);
	return ((void (*)(void)) enilopmart);
}


/*	An enilopmart (the reverse of a trampoline) is a piece of code that makes
	the system-call-like transition from the C runtime into generated machine
	code. At the point the enilopmart enters machine code via a return
	instruction, any argument registers have been loaded with their values and
	the stack, if
	for call, looks like
	ret pc
	stackPointer ->	target address
	
	and if not for call, looks like
	whatever
	stackPointer ->	target address
	
	If forCall and running on a CISC, ret pc must be left on the stack. If
	forCall and
	running on a RISC, ret pc must be popped into LinkReg. In either case,
	target address must be removed from the stack and jumped/returned to. */

	/* Cogit>>#genEnilopmartReturn: */
static void NoDbgRegParms
genEnilopmartReturn(sqInt forCall)
{
	/* begin RetN: */
	genoperand(RetN, 0);

}


/*	Generate the routine that writes the current values of the C frame and
	stack pointers into
	variables. These are used to establish the C stack in trampolines back
	into the C run-time.
	
	This is a presumptuous quick hack for x86. It is presumptuous for two
	reasons. Firstly
	the system's frame and stack pointers may differ from those we use in
	generated code,
	e.g. on register-rich RISCs. Secondly the ABI may not support a simple
	frameless call
	as written here (for example 128-bit stack alignment on Mac OS X). */

	/* Cogit>>#generateCaptureCStackPointers: */
static void NoDbgRegParms
generateCaptureCStackPointers(sqInt captureFramePointer)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    sqInt fixupSize;
    sqInt opcodeSize;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt startAddress;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 32;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;

	/* Must happen first; value may be used in accessing any of the following addresses */
	startAddress = methodZoneBase;
	/* begin PushR: */
	genoperand(PushR, VarBaseReg);
	/* begin MoveCq:R: */
	quickConstant1 = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(MoveCqR, quickConstant1, VarBaseReg);

	if (captureFramePointer) {
		/* begin MoveR:Aw: */
		address = cFramePointerAddress();
		/* begin gen:operand:literal: */
		anInstruction2 = genoperandoperand(MoveRAw, FPReg, address);
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SPReg, TempReg);
	/* begin AddCq:R: */
	quickConstant = (leafCallStackPointerDelta(backEnd)) + BytesPerWord;
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, TempReg);
	/* begin MoveR:Aw: */
	address1 = cStackPointerAddress();
	/* begin gen:operand:literal: */
	anInstruction3 = genoperandoperand(MoveRAw, TempReg, address1);

	/* begin PopR: */
	genoperand(PopR, VarBaseReg);

	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	flushICacheFromto(processor, ((usqInt)startAddress), ((usqInt)methodZoneBase));
	recordGeneratedRunTimeaddress("ceCaptureCStackPointers", startAddress);
	ceCaptureCStackPointers = ((void (*)(void)) startAddress);
}


/*	Generate the prototype ClosedPIC to determine how much space as full PIC
	takes. When we first allocate a closed PIC it only has one or two cases
	and we want to grow it.
	So we have to determine how big a full one is before hand. */

	/* Cogit>>#generateClosedPICPrototype */
static void
generateClosedPICPrototype(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    CogMethod *cPIC;
    AbstractInstruction * cPICEndOfCodeLabel;
    sqInt endAddress;
    AbstractInstruction * endCPICCase1;
    sqInt fixupSize;
    sqInt h;
    AbstractInstruction *jumpNext;
    sqInt jumpTarget;
    sqInt jumpTarget1;
    sqInt jumpTarget2;
    sqInt literal;
    sqInt numArgs;
    sqInt opcode;
    sqInt opcodeSize;
    sqInt wordConstant;


	/* stack allocate the various collections so that they
	   are effectively garbage collected on return. */
	maxCPICCases = 6;
	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = maxCPICCases * 9;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;
	(methodLabel->address = methodZoneBase);
	(methodLabel->dependent = null);
	/* begin compileClosedPICPrototype */
	compilePICAbort((numArgs = 0));

	/* At the end of the entry code we need to jump to the first case code, which is actually the last chunk.
	   On each entension we must update this jump to move back one case. */
	/* 16r5EAF00D is the method oop, or 0, for the 1st case. */
	jumpNext = compileCPICEntry();
	/* begin MoveUniqueCw:R: */
	anInstruction2 = genoperandoperand(MoveCwR, 99282957, SendNumArgsReg);
	/* begin JumpLong: */
	jumpTarget1 = (cPICPrototypeCaseOffset()) + 13262352;
	genoperand(JumpLong, jumpTarget1);
	/* begin Label */
	endCPICCase0 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	for (h = 1; h < maxCPICCases; h += 1) {
		if (h == (maxCPICCases - 1)) {
			jmpTarget(jumpNext, gLabel());
		}
		/* begin MoveUniqueCw:R: */
		anInstruction1 = genoperandoperand(MoveCwR, 195929424 + h, SendNumArgsReg);
		/* begin CmpC32:R: */
		opcode = CmpC32R;
		/* begin checkLiteral:forInstruction: */
		literal = 3133021973ULL + h;
		anInstruction = genoperandoperand(opcode, 3133021973ULL + h, TempReg);
		/* begin JumpLongZero: */
		jumpTarget = ((cPICPrototypeCaseOffset()) + 13262352) + (h * 16);
		genConditionalBranchoperand(JumpLongZero, ((sqInt)jumpTarget));
		if (h == 1) {
			/* begin Label */
			endCPICCase1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
	}
	/* begin MoveCw:R: */
	wordConstant = (methodLabel->address);
	/* begin gen:literal:operand: */
	anInstruction3 = genoperandoperand(MoveCwR, wordConstant, ClassReg);
	/* begin JumpLong: */
	jumpTarget2 = cPICMissTrampolineFor(numArgs);
	genoperand(JumpLong, jumpTarget2);
	/* begin Label */
	cPICEndOfCodeLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	computeMaximumSizes();
	cPIC = ((CogMethod *) methodZoneBase);
	closedPICSize = (sizeof(CogMethod)) + (generateInstructionsAt(methodZoneBase + (sizeof(CogMethod))));
	endAddress = outputInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	assert((methodZoneBase + closedPICSize) == endAddress);
	firstCPICCaseOffset = ((endCPICCase0->address)) - methodZoneBase;
	cPICEndOfCodeOffset = ((cPICEndOfCodeLabel->address)) - methodZoneBase;
	cPICCaseSize = ((endCPICCase1->address)) - ((endCPICCase0->address));
	cPICEndSize = closedPICSize - (((maxCPICCases - 1) * cPICCaseSize) + firstCPICCaseOffset);
	closedPICSize = roundUpLength(closedPICSize);
	assert(((picInterpretAbort->address)) == (((methodLabel->address)) + (picInterpretAbortOffset())));
	assert((expectedClosedPICPrototype(cPIC)) == 0);
	storeLiteralbeforeFollowingAddress(backEnd, 0, ((endCPICCase0->address)) - (jumpLongByteSize(backEnd)));
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	cPICPrototype = cPIC;
}


/*	We handle jump sizing simply. First we make a pass that asks each
	instruction to compute its maximum size. Then we make a pass that
	sizes jumps based on the maxmimum sizes. Then we make a pass
	that fixes up jumps. When fixing up a jump the jump is not allowed to
	choose a smaller offset but must stick to the size set in the second pass. */

	/* Cogit>>#generateCogMethod: */
static CogMethod * NoDbgRegParms
generateCogMethod(sqInt selector)
{
    sqInt codeSize;
    sqInt headerSize;
    sqInt mapSize;
    CogMethod *method;
    sqInt result;
    sqInt startAddress;
    sqInt totalSize;

	headerSize = sizeof(CogMethod);
	(methodLabel->address = freeStart());
	computeMaximumSizes();
	concretizeAt(methodLabel, freeStart());
	codeSize = generateInstructionsAt(((methodLabel->address)) + headerSize);
	mapSize = generateMapAtstart(null, ((methodLabel->address)) + cmNoCheckEntryOffset);
	totalSize = roundUpLength((headerSize + codeSize) + mapSize);
	if (totalSize > MaxMethodSize) {
		return ((CogMethod *) MethodTooBig);
	}
	startAddress = allocate(totalSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	assert((startAddress + cmEntryOffset) == ((entry->address)));
	assert((startAddress + cmNoCheckEntryOffset) == ((noCheckEntry->address)));
	result = outputInstructionsAt(startAddress + headerSize);
	assert(((startAddress + headerSize) + codeSize) == result);
	padIfPossibleWithStopsFromto(backEnd, result, (startAddress + totalSize) - mapSize);
	generateMapAtstart((startAddress + totalSize) - 1, startAddress + cmNoCheckEntryOffset);
	fillInBlockHeadersAt(startAddress);
	method = fillInMethodHeadersizeselector(((CogMethod *) startAddress), totalSize, selector);
	if (!(postCompileHook == null)) {
		postCompileHook(method);
		postCompileHook = null;
	}
	return method;
}


/*	Size pc-dependent instructions and assign eventual addresses to all
	instructions. Answer the size of the code.
	Compute forward branches based on virtual address (abstract code starts at
	0), assuming that any branches branched over are long.
	Compute backward branches based on actual address.
	Reuse the fixups array to record the pc-dependent instructions that need
	to have
	their code generation postponed until after the others. */

	/* Cogit>>#generateInstructionsAt: */
static sqInt NoDbgRegParms
generateInstructionsAt(sqInt eventualAbsoluteAddress)
{
    sqInt absoluteAddress;
    AbstractInstruction *abstractInstruction;
    BytecodeFixup *fixup;
    sqInt i;
    sqInt j;
    sqInt pcDependentIndex;

	absoluteAddress = eventualAbsoluteAddress;
	pcDependentIndex = 0;
	for (i = 0; i < opcodeIndex; i += 1) {
		abstractInstruction = abstractInstructionAt(i);
		if (isPCDependent(abstractInstruction)) {
			sizePCDependentInstructionAt(abstractInstruction, absoluteAddress);
			fixup = fixupAt(pcDependentIndex);
			pcDependentIndex += 1;
			(fixup->instructionIndex = i);
			absoluteAddress += (abstractInstruction->machineCodeSize);
		}
		else {
			absoluteAddress = concretizeAt(abstractInstruction, absoluteAddress);
		}
	}
	for (j = 0; j < pcDependentIndex; j += 1) {
		fixup = fixupAt(j);
		abstractInstruction = abstractInstructionAt((fixup->instructionIndex));
		concretizeAt(abstractInstruction, (abstractInstruction->address));
	}
	return absoluteAddress - eventualAbsoluteAddress;
}


/*	Generate the method map at addressrNull (or compute it if addressOrNull is
	null). Answer the length of the map in byes. Each entry in the map is in
	two parts. In the
	least signficant bits are a displacement of how far from the start or
	previous entry,
	unless it is an IsAnnotationExtension byte, in which case those bits are
	the extension.
	In the most signficant bits are the type of annotation at the point
	reached. A null
	byte ends the map. */

	/* Cogit>>#generateMapAt:start: */
static sqInt NoDbgRegParms
generateMapAtstart(sqInt addressOrNull, sqInt startAddress)
{
    unsigned char annotation;
    sqInt delta;
    sqInt i;
    AbstractInstruction *instruction;
    sqInt length;
    sqInt location;
    sqInt mapEntry;
    sqInt maxDelta;
    usqInt mcpc;

	length = 0;
	location = startAddress;
	for (i = 0; i < opcodeIndex; i += 1) {
		instruction = abstractInstructionAt(i);
		annotation = (instruction->annotation);
		if (!(annotation == null)) {
			mcpc = ((instruction->address)) + ((instruction->machineCodeSize));
			while (((delta = (mcpc - location) / 1)) > DisplacementMask) {
				maxDelta = (((((delta < MaxX2NDisplacement) ? delta : MaxX2NDisplacement)) | DisplacementMask) - DisplacementMask);
				assert((((usqInt) maxDelta) >> AnnotationShift) <= DisplacementMask);
				if (!(addressOrNull == null)) {
					/* begin addToMap:instruction:byte:at:for: */
					byteAtput(addressOrNull - length, (((usqInt) maxDelta) >> AnnotationShift) + DisplacementX2N);
				}
				location += maxDelta;
				length += 1;
			}
			if (!(addressOrNull == null)) {
				mapEntry = delta + (((long)(((annotation < IsSendCall) ? annotation : IsSendCall))) << AnnotationShift);
				/* begin addToMap:instruction:byte:at:for: */
				byteAtput(addressOrNull - length, mapEntry);
			}
			location += delta;
			length += 1;
			if (annotation > IsSendCall) {

				/* Add the necessary IsAnnotationExtension */
				if (!(addressOrNull == null)) {
					mapEntry = (((long)IsAnnotationExtension) << AnnotationShift) + (annotation - IsSendCall);
					/* begin addToMap:instruction:byte:at:for: */
					byteAtput(addressOrNull - length, mapEntry);
				}
				length += 1;
			}
		}
	}
	if (!(addressOrNull == null)) {
		/* begin addToMap:instruction:byte:at:for: */
		byteAtput(addressOrNull - length, MapEnd);
	}
	return length + 1;
}


/*	Generate the prototype ClosedPIC to determine how much space as full PIC
	takes. When we first allocate a closed PIC it only has one or two cases
	and we want to grow it.
	So we have to determine how big a full one is before hand. */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#generateOpenPICPrototype */
static void
generateOpenPICPrototype(void)
{
    sqInt codeSize;
    sqInt fixupSize;
    sqInt mapSize;
    sqInt opcodeSize;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 100;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;
	(methodLabel->address = methodZoneBase);
	(methodLabel->dependent = null);
	compileOpenPICnumArgs(specialSelector(0), 2);
	computeMaximumSizes();
	concretizeAt(methodLabel, methodZoneBase);
	codeSize = generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	mapSize = generateMapAtstart(null, methodZoneBase + cmNoCheckEntryOffset);
	openPICSize = (roundUpLength((sizeof(CogMethod)) + codeSize)) + (roundUpLength(mapSize));
}


/*	Generate the run-time entries at the base of the native code zone and
	update the base.
 */

	/* Cogit>>#generateRunTimeTrampolines */
static void
generateRunTimeTrampolines(void)
{
	ceSendMustBeBooleanAddFalseTrampoline = genMustBeBooleanTrampolineForcalled(falseObject(), "ceSendMustBeBooleanAddFalseTrampoline");
	ceSendMustBeBooleanAddTrueTrampoline = genMustBeBooleanTrampolineForcalled(trueObject(), "ceSendMustBeBooleanAddTrueTrampoline");
	ceNonLocalReturnTrampoline = genNonLocalReturnTrampoline();
	ceCheckForInterruptTrampoline = genCheckForInterruptsTrampoline();
	ceFetchContextInstVarTrampoline = genTrampolineForcalledargargresult(ceContextinstVar, "ceFetchContextInstVarTrampoline", ReceiverResultReg, SendNumArgsReg, SendNumArgsReg);
	ceStoreContextInstVarTrampoline = genTrampolineForcalledargargargresult(ceContextinstVarvalue, "ceStoreContextInstVarTrampoline", ReceiverResultReg, SendNumArgsReg, ClassReg, ReceiverResultReg);

	/* These two are unusual; they are reached by return instructions. */
	ceCannotResumeTrampoline = genTrampolineForcalled(ceCannotResume, "ceCannotResumeTrampoline");
	ceBaseFrameReturnTrampoline = genReturnTrampolineForcalledarg(ceBaseFrameReturn, "ceBaseFrameReturnTrampoline", ReceiverResultReg);
	ceReturnToInterpreterTrampoline = genReturnTrampolineForcalledarg(ceReturnToInterpreter, "ceReturnToInterpreterTrampoline", ReceiverResultReg);
}


/*	Generate a routine ceCaptureCStackPointers that will capture the C stack
	pointer, and, if it is in use, the C frame pointer. These are used in
	trampolines to call
	run-time routines in the interpreter from machine-code. */

	/* Cogit>>#generateStackPointerCapture */
static void
generateStackPointerCapture(void)
{
    sqInt oldMethodZoneBase;
    sqInt oldTrampolineTableIndex;


	/* For the benefit of the following assert, assume the minimum at first. */
	cFramePointerInUse = 0;
	assertCStackWellAligned();
	oldMethodZoneBase = methodZoneBase;
	oldTrampolineTableIndex = trampolineTableIndex;
	generateCaptureCStackPointers(1);
	ceCaptureCStackPointers();
	if (!((cFramePointerInUse = isCFramePointerInUse()))) {
		methodZoneBase = oldMethodZoneBase;
		trampolineTableIndex = oldTrampolineTableIndex;
		generateCaptureCStackPointers(0);
	}
	assertCStackWellAligned();
}


/*	Generate the run-time entries and exits at the base of the native code
	zone and update the base.
	Read the class-side method trampolines for documentation on the various
	trampolines 
 */

	/* Cogit>>#generateTrampolines */
static void
generateTrampolines(void)
{
    sqInt fixupSize;
    sqInt methodZoneStart;
    sqInt opcodeSize;

	methodZoneStart = methodZoneBase;
	(methodLabel->address = methodZoneStart);
	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 80;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;
	hasYoungReferent = 0;
	maybeGenerateSelectorIndexDereferenceRoutine();
	generateSendTrampolines();
	generateMissAbortTrampolines();
	generateObjectRepresentationTrampolines();
	generateRunTimeTrampolines();
	generateEnilopmarts();
	generateTracingTrampolines();
	recordGeneratedRunTimeaddress("methodZoneBase", methodZoneBase);
	flushICacheFromto(processor, ((usqInt)methodZoneStart), ((usqInt)methodZoneBase));
}


/*	Generate a routine that answers the stack pointer immedately
	after a leaf call, used for checking stack pointer alignment. */

	/* Cogit>>#genGetLeafCallStackPointer */
static void
genGetLeafCallStackPointer(void)
{
    AbstractInstruction *anInstruction;
    sqInt fixupSize;
    sqInt opcodeSize;
    sqInt quickConstant;
    sqInt startAddress;

	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 4;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;
	startAddress = methodZoneBase;
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, FPReg, RAX);
	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceGetFP", startAddress);
	ceGetFP = ((unsigned long (*)(void)) startAddress);
	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SPReg, RAX);
	/* begin AddCq:R: */
	quickConstant = leafCallStackPointerDelta(backEnd);
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, RAX);

	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceGetSP", startAddress);
	ceGetSP = ((unsigned long (*)(void)) startAddress);
}


/*	Generate the abort for a PIC. This abort performs either a call of
	ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged target
	or a call of ceMNUFromPICMNUMethod:receiver: to handle an MNU dispatch
	in a closed PIC. It distinguishes the two by testing ClassReg. If the
	register is zero then this is an MNU.
	
	This poses a problem in 32-bit Spur, where zero is the cache tag for
	immediate characters (tag pattern 2r10) because SmallIntegers have tag
	patterns 2r11
	and 2r01, so anding with 1 reduces these to 0 & 1. We solve the ambiguity
	by patching send sites with a 0 cache tag to open PICs instead of closed
	PICs.  */

	/* Cogit>>#genInnerPICAbortTrampoline: */
static sqInt NoDbgRegParms
genInnerPICAbortTrampoline(char *name)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpMNUCase;

	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpZero: */
	jumpMNUCase = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceInterpretMethodFromPICreceiver, 2, SendNumArgsReg, ReceiverResultReg, null, null, 0, 0, NoReg);
	jmpTarget(jumpMNUCase, gLabel());
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceMNUFromPICMNUMethodreceiver, name, 2, SendNumArgsReg, ReceiverResultReg, null, null, 0, 0, NoReg, 1);
}

	/* Cogit>>#genLoadCStackPointersForPrimCall */
static sqInt
genLoadCStackPointersForPrimCall(void)
{
    sqInt address;
    sqInt address1;
    sqInt address2;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;

	if (debugPrimCallStackOffset == 0) {
		/* begin MoveAw:R: */
		address = cStackPointerAddress();
		/* begin gen:literal:operand: */
		anInstruction = genoperandoperand(MoveAwR, address, SPReg);
	}
	else {
		/* begin MoveAw:R: */
		address1 = cStackPointerAddress();
		/* begin gen:literal:operand: */
		anInstruction1 = genoperandoperand(MoveAwR, address1, TempReg);
		/* begin SubCq:R: */
		anInstruction2 = genoperandoperand(SubCqR, debugPrimCallStackOffset, TempReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, TempReg, SPReg);
	}
	if (cFramePointerInUse) {
		/* begin MoveAw:R: */
		address2 = cFramePointerAddress();
		/* begin gen:literal:operand: */
		anInstruction3 = genoperandoperand(MoveAwR, address2, FPReg);
	}
	return 0;
}


/*	The in-line cache for a send is implemented as a constant load into
	ClassReg. We always use a 32-bit load, even in 64-bits.
	
	In the initial (unlinked) state the in-line cache is notionally loaded
	with the selector.
	But since in 64-bits an arbitrary selector oop won't fit in a 32-bit
	constant load, we
	instead load the cache with the selector's index, either into the literal
	frame of the
	current method, or into the special selector array. Negative values are
	1-relative indices into the special selector array.
	
	When a send is linked, the load of the selector, or selector index, is
	overwritten with a
	load of the receiver's class, or class tag. Hence, the 64-bit VM is
	currently constrained
	to use class indices as cache tags. If out-of-line literals are used,
	distinct caches /must
	not/ share acche locations, for if they do, send cacheing will be confused
	by the sharing.
	Hence we use the MoveUniqueC32:R: instruction that will not share literal
	locations.  */

	/* Cogit>>#genLoadInlineCacheWithSelector: */
static void NoDbgRegParms
genLoadInlineCacheWithSelector(sqInt selectorIndex)
{
    AbstractInstruction *anInstruction;
    sqInt cacheValue;
    sqInt opcode;

	assert((selectorIndex < 0
		? (((-selectorIndex) >= 1) && ((-selectorIndex) <= (numSpecialSelectors())))
		: ((selectorIndex >= 0) && (selectorIndex <= ((literalCountOf(methodObj)) - 1)))));
	cacheValue = selectorIndex;

	/* begin MoveUniqueC32:R: */
	opcode = MoveC32R;
	/* begin uniqueLiteral:forInstruction: */
	anInstruction = genoperandoperand(opcode, cacheValue, ClassReg);
}

	/* Cogit>>#genNonLocalReturnTrampoline */
static sqInt
genNonLocalReturnTrampoline(void)
{
    sqInt address1;
    AbstractInstruction *anInstruction1;

	zeroOpcodeIndex();
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin MoveR:Aw: */
	address1 = instructionPointerAddress();
	/* begin gen:operand:literal: */
	anInstruction1 = genoperandoperand(MoveRAw, TempReg, address1);

	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNonLocalReturn, "ceNonLocalReturnTrampoline", 1, ReceiverResultReg, null, null, null, 0, 0, NoReg, 1);
}


/*	Generate a trampoline for a routine used as a return address, that has one
	argument. Hack: a negative value indicates an abstract register, a
	non-negative value indicates a constant. */

	/* Cogit>>#genReturnTrampolineFor:called:arg: */
static sqInt NoDbgRegParms
genReturnTrampolineForcalledarg(void *aRoutine, char *aString, sqInt regOrConst0)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 1, regOrConst0, null, null, null, 0, 0, NoReg, 0);
}


/*	If the client requires, then on an ARM-like RISC processor, the return
	address needs to
	be pushed to the stack so that the interpreter sees the same stack layout
	as on CISC.
 */

	/* Cogit>>#genSmalltalkToCStackSwitch: */
static sqInt NoDbgRegParms
genSmalltalkToCStackSwitch(sqInt pushLinkReg)
{
	genSaveStackPointers(backEnd);
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	return 0;
}


/*	Generate a trampoline with no arguments */

	/* Cogit>>#genTrampolineFor:called: */
static sqInt NoDbgRegParms
genTrampolineForcalled(void *aRoutine, char *aString)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 0, null, null, null, null, 0, 1, NoReg, 0);
}


/*	Generate a trampoline with three arguments.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:arg:arg: */
static sqInt NoDbgRegParms
genTrampolineForcalledargargarg(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 3, regOrConst0, regOrConst1, regOrConst2, null, 0, 1, NoReg, 0);
}


/*	Generate a trampoline with two arguments that answers a result.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:arg:arg:result: */
static sqInt NoDbgRegParms
genTrampolineForcalledargargargresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt resultReg)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 3, regOrConst0, regOrConst1, regOrConst2, null, 0, 1, resultReg, 0);
}


/*	Generate a trampoline with two arguments.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:arg:regsToSave: */
static sqInt NoDbgRegParms
genTrampolineForcalledargargregsToSave(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regMask)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 2, regOrConst0, regOrConst1, null, null, regMask, 1, NoReg, 0);
}


/*	Generate a trampoline with two arguments that answers a result.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:arg:result: */
static sqInt NoDbgRegParms
genTrampolineForcalledargargresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt resultReg)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 2, regOrConst0, regOrConst1, null, null, 0, 1, resultReg, 0);
}


/*	Generate a trampoline with one argument.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:regsToSave: */
static sqInt NoDbgRegParms
genTrampolineForcalledargregsToSave(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regMask)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 1, regOrConst0, null, null, null, regMask, 1, NoReg, 0);
}


/*	Generate a trampoline with one argument that answers a result.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:arg:regsToSave:result: */
static sqInt NoDbgRegParms
genTrampolineForcalledargregsToSaveresult(void *aRoutine, char *aString, sqInt regOrConst0, sqInt regMask, sqInt resultReg)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 1, regOrConst0, null, null, null, regMask, 1, resultReg, 0);
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg:appendOpcodes: */
static sqInt NoDbgRegParms
genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean)
{
    sqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate a trampoline with no arguments */

	/* Cogit>>#genTrampolineFor:called:regsToSave: */
static sqInt NoDbgRegParms
genTrampolineForcalledregsToSave(void *aRoutine, char *aString, sqInt regMask)
{
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 0, null, null, null, null, regMask, 1, NoReg, 0);
}


/*	<Integer> */

	/* Cogit>>#gen: */
static AbstractInstruction * NoDbgRegParms
gen(sqInt opcode)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand: */
static AbstractInstruction * NoDbgRegParms
genoperand(sqInt opcode, sqInt operand)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operand;
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand:operand: */
static AbstractInstruction * NoDbgRegParms
genoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operandOne;
	((abstractInstruction->operands))[1] = operandTwo;
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand:operand:operand: */
static AbstractInstruction * NoDbgRegParms
genoperandoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo, sqInt operandThree)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operandOne;
	((abstractInstruction->operands))[1] = operandTwo;
	((abstractInstruction->operands))[2] = operandThree;
	return abstractInstruction;
}

	/* Cogit>>#getLiteral: */
static sqInt NoDbgRegParms
getLiteral(sqInt litIndex)
{
	if (maxLitIndex < litIndex) {
		maxLitIndex = litIndex;
	}
	return literalofMethod(litIndex, methodObj);
}

	/* Cogit>>#incrementUsageOfTargetIfLinkedSend:mcpc:ignored: */
static sqInt NoDbgRegParms
incrementUsageOfTargetIfLinkedSendmcpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt sendTable;
    sqInt *sendTable1;
    CogMethod * targetMethod;
    CogMethod *targetMethod1;

	if (annotation >= IsSendCall) {
		assert(annotation != IsNSSendCall);
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				targetMethod1 = ((CogMethod *) (entryPoint - cmEntryOffset));
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				targetMethod1 = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
				sendTable1 = superSendTrampolines;



			}
			if (((targetMethod1->cmUsageCount)) < (CMMaxUsageCount / 2)) {
				(targetMethod1->cmUsageCount = ((targetMethod1->cmUsageCount)) + 1);
			}

		}
	}
	return 0;
}


/*	Answer the value to put in an inline-cache that is being loaded with the
	selector. Usually this is simply the selector, but in 64-bits the cache is
	only 32-bits wide
	and so the cache is loaded with the index of the selector. */

	/* Cogit>>#indexForSelector:in:at: */
static sqInt NoDbgRegParms
indexForSelectorinat(sqInt selector, CogMethod *cogMethod, sqInt mcpc)
{
    sqInt i;
    sqInt iLimiT;
    sqInt methodOop;

	assert(((((usqInt)mcpc)) > (((usqInt)cogMethod)))
	 && (mcpc < ((((usqInt)cogMethod)) + ((cogMethod->blockSize)))));
	for (i = 0; i < NumSpecialSelectors; i += 1) {
		if (selector == (specialSelector(i))) {
			return -1 - i;
		}
	}

	/* Then search the method's literal frame... open code fetchPointer:ofObject: for speed... */
	methodOop = (cogMethod->methodObject);
	for (i = LiteralStart, iLimiT = (literalCountOfMethodHeader((cogMethod->methodHeader))); i <= iLimiT; i += 1) {
		if ((longAt(((i * BytesPerOop) + BaseHeaderSize) + methodOop)) == selector) {
			assert(selector == (literalofMethod(i - 1, methodOop)));
			return i - 1;
		}
	}
	error("could not find selector in method when unlinking send site");
	return 0;
}


/*	Answer a usage count that reflects likely long-term usage. */

	/* Cogit>>#initialClosedPICUsageCount */
static sqInt
initialClosedPICUsageCount(void)
{
	return CMMaxUsageCount / 2;
}

	/* Cogit>>#initializeBackend */
static void
initializeBackend(void)
{
	(methodLabel->machineCodeSize = 0);
	(methodLabel->opcode = Label);
	((methodLabel->operands))[0] = 0;
	((methodLabel->operands))[1] = 0;
	callerSavedRegMask = callerSavedRegisterMask(backEnd);
	assert(((registerMaskFor(VarBaseReg)) & callerSavedRegMask) == 0);

}

	/* Cogit>>#initializeCodeZoneFrom:upTo: */
void
initializeCodeZoneFromupTo(sqInt startAddress, sqInt endAddress)
{
    sqInt fixupSize;
    sqInt numberOfAbstractOpcodes;
    sqInt opcodeSize;
    sqInt startAddress1;

	initializeBackend();
	stopsFromto(backEnd, startAddress, endAddress - 1);
	sqMakeMemoryExecutableFromTo(startAddress, endAddress);
	codeBase = (methodZoneBase = startAddress);
	minValidCallAddress = (((((codeBase < (interpretAddress())) ? codeBase : (interpretAddress()))) < (primitiveFailAddress())) ? (((codeBase < (interpretAddress())) ? codeBase : (interpretAddress()))) : (primitiveFailAddress()));
	manageFromto(methodZoneBase, endAddress);
	/* begin maybeGenerateCheckFeatures */
	/* begin maybeGenerateICacheFlush */
	/* begin generateVMOwnerLockFunctions */
	
#  if COGMTVM
	/* begin allocateOpcodes:bytecodes: */
	numberOfAbstractOpcodes = numLowLevelLockOpcodes(backEnd);
	numAbstractOpcodes = numberOfAbstractOpcodes;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;
	zeroOpcodeIndex();
	startAddress1 = methodZoneBase;
	generateLowLevelTryLock(backEnd, vmOwnerLockAddress());
	outputInstructionsForGeneratedRuntimeAt(startAddress1);
	recordGeneratedRunTimeaddress("ceTryLockVMOwner", startAddress1);
	ceTryLockVMOwner = ((unsigned long (*)(void)) startAddress1);
	zeroOpcodeIndex();
	initialPC = 0;
	endPC = numAbstractOpcodes - 1;
	startAddress1 = methodZoneBase;
	generateLowLevelUnlock(backEnd, vmOwnerLockAddress());
	outputInstructionsForGeneratedRuntimeAt(startAddress1);
	recordGeneratedRunTimeaddress("ceUnlockVMOwner", startAddress1);
	ceUnlockVMOwner = ((void (*)(void)) startAddress1);

#  endif /* COGMTVM */

	genGetLeafCallStackPointer();
	generateStackPointerCapture();
	generateTrampolines();
	computeEntryOffsets();
	generateClosedPICPrototype();
	manageFromto(methodZoneBase, endAddress);
	generateOpenPICPrototype();
}


/*	Answer a usage count that reflects likely long-term usage.
	Answer 1 for non-primitives or quick primitives (inst var accessors),
	2 for methods with interpreter primitives, and 3 for compiled primitives. */

	/* Cogit>>#initialMethodUsageCount */
static sqInt
initialMethodUsageCount(void)
{
	if ((primitiveIndex == 1)
	 || (isQuickPrimitiveIndex(primitiveIndex))) {
		return 1;
	}
	if (!(primitiveGeneratorOrNil())) {
		return 2;
	}
	return 3;
}


/*	Answer a usage count that reflects likely long-term usage. */

	/* Cogit>>#initialOpenPICUsageCount */
static sqInt
initialOpenPICUsageCount(void)
{
	return CMMaxUsageCount - 1;
}


/*	Answer the value to put in an inline-cache that is being loaded with the
	selector. Usually this is simply the selector, but in 64-bits the cache is
	only 32-bits wide
	and so the cache is loaded with the index of the selector. */

	/* Cogit>>#inlineCacheValueForSelector:in:at: */
static sqInt NoDbgRegParms
inlineCacheValueForSelectorinat(sqInt selector, sqInt aCogMethod, sqInt mcpc)
{
	return indexForSelectorinat(selector, aCogMethod, mcpc);
}

	/* Cogit>>#inverseBranchFor: */
static sqInt NoDbgRegParms
inverseBranchFor(sqInt opcode)
{
	
	switch (opcode) {
	case JumpLongZero:
		return JumpLongNonZero;

	case JumpLongNonZero:
		return JumpLongZero;

	case JumpZero:
		return JumpNonZero;

	case JumpNonZero:
		return JumpZero;

	case JumpNegative:
		return JumpNonNegative;

	case JumpNonNegative:
		return JumpNegative;

	case JumpOverflow:
		return JumpNoOverflow;

	case JumpNoOverflow:
		return JumpOverflow;

	case JumpCarry:
		return JumpNoCarry;

	case JumpNoCarry:
		return JumpCarry;

	case JumpLess:
		return JumpGreaterOrEqual;

	case JumpGreaterOrEqual:
		return JumpLess;

	case JumpGreater:
		return JumpLessOrEqual;

	case JumpLessOrEqual:
		return JumpGreater;

	case JumpBelow:
		return JumpAboveOrEqual;

	case JumpAboveOrEqual:
		return JumpBelow;

	case JumpAbove:
		return JumpBelowOrEqual;

	case JumpBelowOrEqual:
		return JumpAbove;

	default:
		error("Case not found and no otherwise clause");
	}
	error("invalid opcode for inverse");
	return 0;
}


/*	Answer if the branch bytecode with the given descriptor is a backward
	branch. 
 */

	/* Cogit>>#isBackwardBranch:at:exts:in: */
static sqInt NoDbgRegParms
isBackwardBranchatextsin(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(((descriptor->spanFunction)) != null);
	return (((descriptor->spanFunction))(descriptor, pc, nExts, aMethodObj)) < 0;
}

	/* Cogit>>#isPCMappedAnnotation: */
static sqInt NoDbgRegParms
isPCMappedAnnotation(sqInt annotation)
{
	return (annotation >= IsSendCall)
	 || ((annotation == HasBytecodePC)
	 || (0));
}

	/* Cogit>>#isPCWithinMethodZone: */
sqInt
isPCWithinMethodZone(void *address)
{
	return (((((usqInt)address)) >= methodZoneBase) && ((((usqInt)address)) <= (freeStart())));
}


/*	Answer if the instruction preceding retpc is a call instruction. */

	/* Cogit>>#isSendReturnPC: */
sqInt
isSendReturnPC(sqInt retpc)
{
    sqInt target;

	if (!(isCallPrecedingReturnPC(backEnd, retpc))) {
		return 0;
	}
	target = callTargetFromReturnAddress(backEnd, retpc);
	return (((target >= firstSend) && (target <= lastSend)))
	 || (((target >= methodZoneBase) && (target <= (freeStart()))));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPEqual: */
static AbstractInstruction * NoDbgRegParms
gJumpFPEqual(void *jumpTarget)
{
    AbstractInstruction *jumpToTarget;
    AbstractInstruction *jumpUnordered;

	/* begin genJumpFPEqual: */
	jumpUnordered = gen(JumpFPUnordered);
	jumpToTarget = genoperand(JumpFPEqual, ((sqInt)jumpTarget));
	jmpTarget(jumpUnordered, gLabel());
	return jumpToTarget;
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPGreaterOrEqual: */
static AbstractInstruction * NoDbgRegParms
gJumpFPGreaterOrEqual(void *jumpTarget)
{
	/* begin genJumpFPGreaterOrEqual: */
	return genoperand(JumpFPGreaterOrEqual, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPGreater: */
static AbstractInstruction * NoDbgRegParms
gJumpFPGreater(void *jumpTarget)
{
	/* begin genJumpFPGreater: */
	return genoperand(JumpFPGreater, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPNotEqual: */
static AbstractInstruction * NoDbgRegParms
gJumpFPNotEqual(void *jumpTarget)
{
    AbstractInstruction *jumpToTarget;
    AbstractInstruction *jumpUnordered;

	/* begin genJumpFPNotEqual: */
	jumpToTarget = genoperand(JumpFPNotEqual, ((sqInt)jumpTarget));
	jumpUnordered = genoperand(JumpFPUnordered, ((sqInt)jumpTarget));
	addDependent(jumpToTarget, jumpUnordered);
	return jumpToTarget;
}

	/* Cogit>>#JumpNonZero: */
static AbstractInstruction * NoDbgRegParms
gJumpNonZero(void *jumpTarget)
{
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)jumpTarget));
}

	/* Cogit>>#Label */
static AbstractInstruction *
gLabel(void)
{
	return genoperandoperand(Label, (labelCounter += 1), bytecodePC);
}

	/* Cogit>>#LogicalShiftLeftCq:R: */
static AbstractInstruction * NoDbgRegParms
gLogicalShiftLeftCqR(sqInt quickConstant, sqInt reg)
{
	return genoperandoperand(LogicalShiftLeftCqR, quickConstant, reg);
}

	/* Cogit>>#lastOpcode */
static AbstractInstruction *
lastOpcode(void)
{
	assert(opcodeIndex > 0);
	return abstractInstructionAt(opcodeIndex - 1);
}

	/* Cogit>>#linkSendAt:in:to:offset:receiver: */
void
linkSendAtintooffsetreceiver(sqInt callSiteReturnAddress, CogMethod *sendingMethod, CogMethod *targetMethod, sqInt theEntryOffset, sqInt receiver)
{
    sqInt address;
    sqInt extent;
    sqInt inlineCacheTag;

	assert((theEntryOffset == cmEntryOffset)
	 || (theEntryOffset == cmNoCheckEntryOffset));
	assert(((callSiteReturnAddress >= methodZoneBase) && (callSiteReturnAddress <= (freeStart()))));
	inlineCacheTag = (theEntryOffset == cmNoCheckEntryOffset
		? (targetMethod->selector)
		: inlineCacheTagForInstance(receiver));
	address = (((sqInt)targetMethod)) + theEntryOffset;
	extent = rewriteInlineCacheAttagtarget(backEnd, callSiteReturnAddress, inlineCacheTag, address);
	flushICacheFromto(processor, (((usqInt)callSiteReturnAddress)) - extent, ((usqInt)callSiteReturnAddress));
}

	/* Cogit>>#loadSubsequentBytesForDescriptor:at: */
static void NoDbgRegParms
loadSubsequentBytesForDescriptorat(BytecodeDescriptor *descriptor, sqInt pc)
{
	if (((descriptor->numBytes)) > 1) {
		byte1 = fetchByteofObject(pc + 1, methodObj);
		if (((descriptor->numBytes)) > 2) {
			byte2 = fetchByteofObject(pc + 2, methodObj);
			if (((descriptor->numBytes)) > 3) {
				byte3 = fetchByteofObject(pc + 3, methodObj);
				if (((descriptor->numBytes)) > 4) {
					notYetImplemented();
				}
			}
		}
	}
}

	/* Cogit>>#MoveAw:R: */
static AbstractInstruction * NoDbgRegParms
gMoveAwR(sqInt address, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveAwR, address, reg);
	return anInstruction;
}

	/* Cogit>>#MoveCw:R: */
static AbstractInstruction * NoDbgRegParms
gMoveCwR(sqInt wordConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveCwR, wordConstant, reg);
	return anInstruction;
}

	/* Cogit>>#MoveR:Mw:r: */
static AbstractInstruction * NoDbgRegParms
gMoveRMwr(sqInt sourceReg, sqInt offset, sqInt baseReg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, baseReg);
	return anInstruction;
}

	/* Cogit>>#MoveR:R: */
static AbstractInstruction * NoDbgRegParms
gMoveRR(sqInt reg1, sqInt reg2)
{
	return genoperandoperand(MoveRR, reg1, reg2);
}


/*	Answer the address of the null byte at the end of the method map. */

	/* Cogit>>#mapEndFor: */
static sqInt NoDbgRegParms
mapEndFor(CogMethod *cogMethod)
{
    sqInt end;

	end = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	while ((byteAt(end)) != MapEnd) {
		end -= 1;
		assert(end > ((((sqInt)cogMethod)) + cmNoCheckEntryOffset));
	}
	return end;
}


/*	Unlinking/GC/Disassembly support */

	/* Cogit>>#mapFor:performUntil:arg: */
static sqInt NoDbgRegParms
mapForperformUntilarg(CogMethod *cogMethod, sqInt (*functionSymbol)(sqInt annotation, char *mcpc, sqInt arg), sqInt arg)
{
    sqInt annotation;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;

	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {

			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask);
			if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = functionSymbol(annotation, (((char *) mcpc)), arg);
			if (result != 0) {
				return result;
			}
		}
		else {
			if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
				mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
			}
		}
		map -= 1;
	}
	return 0;
}


/*	Remap all object references in the closed PIC. Answer if any references
	are young.
	Set codeModified if any modifications are made. */

	/* Cogit>>#mapObjectReferencesInClosedPIC: */
static sqInt NoDbgRegParms
mapObjectReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt pc;
    sqInt refersToYoung;


	/* first we check the potential method oop load at the beginning of the CPIC */
	pc = addressOfEndOfCaseinCPIC(1, cPIC);

	/* We find the end address of the cPICNumCases'th case and can then just step forward by the case size thereafter */
	refersToYoung = remapMaybeObjRefInClosedPICAt(pc - (jumpLongByteSize(backEnd)));

	/* Next we check the potential class ref in the compare instruction, and the potential method oop load for each case. */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (remapMaybeObjRefInClosedPICAt((pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))) {
			refersToYoung = 1;
		}
		pc += cPICCaseSize;
	}
	return refersToYoung;
}


/*	Update all references to objects in the generated runtime. */

	/* Cogit>>#mapObjectReferencesInGeneratedRuntime */
static void
mapObjectReferencesInGeneratedRuntime(void)
{
    sqInt i;
    sqInt literal;
    sqInt mappedLiteral;
    usqInt mcpc;

	for (i = 0; i < runtimeObjectRefIndex; i += 1) {
		mcpc = objectReferencesInRuntime[i];
		literal = literalBeforeFollowingAddress(backEnd, mcpc);
		mappedLiteral = remapObject(literal);
		if (mappedLiteral != literal) {
			/* begin storeLiteral:atAnnotatedAddress:using: */
			storeLiteralbeforeFollowingAddress(((AbstractInstruction *) backEnd), mappedLiteral, mcpc);
			codeModified = 1;
		}
	}
}


/*	Update all references to objects in machine code for a become.
	Unlike incrementalGC or fullGC a method that does not refer to young may
	refer to young as a result of the become operation. Unlike incrementalGC
	or fullGC the reference from a Cog method to its methodObject *must not*
	change since the two are two halves of the same object. */

	/* Cogit>>#mapObjectReferencesInMachineCodeForBecome */
static void
mapObjectReferencesInMachineCodeForBecome(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedPIC;
    sqInt hasYoungObj;
    sqInt hasYoungObjPtr;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt remappedMethod;
    sqInt result;
    sqInt val;

	val = 0;
	hasYoungObj = 0;
	hasYoungObjPtr = ((sqInt)((&hasYoungObj)));
	codeModified = (freedPIC = 0);
	mapObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		assert(!hasYoungObj);
		if (((cogMethod->cmType)) != CMFree) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			(cogMethod->selector = remapOop((cogMethod->selector)));
			if (((cogMethod->cmType)) == CMClosedPIC) {
				if ((isYoung((cogMethod->selector)))
				 || (mapObjectReferencesInClosedPIC(cogMethod))) {
					freedPIC = 1;
					freeMethod(cogMethod);
				}
			}
			else {
				if (isYoung((cogMethod->selector))) {
					hasYoungObj = 1;
				}
				if (((cogMethod->cmType)) == CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					remappedMethod = remapOop((cogMethod->methodObject));
					if (remappedMethod != ((cogMethod->methodObject))) {
						if (methodHasCogMethod(remappedMethod)) {
							error("attempt to become two cogged methods");
						}
						if (!(withoutForwardingOnandwithsendToCogit((cogMethod->methodObject), remappedMethod, (cogMethod->cmUsesPenultimateLit), methodhasSameCodeAscheckPenultimate))) {
							error("attempt to become cogged method into different method");
						}
						if ((rawHeaderOf((cogMethod->methodObject))) == (((sqInt)cogMethod))) {
							rawHeaderOfput((cogMethod->methodObject), (cogMethod->methodHeader));
							(cogMethod->methodHeader = rawHeaderOf(remappedMethod));
							(cogMethod->methodObject = remappedMethod);
							rawHeaderOfput(remappedMethod, ((sqInt)cogMethod));
						}
						else {
							assert((noAssertMethodClassAssociationOf((cogMethod->methodObject))) == (nilObject()));
							(cogMethod->methodHeader = rawHeaderOf(remappedMethod));
							(cogMethod->methodObject = remappedMethod);
						}
					}
					if (isYoung((cogMethod->methodObject))) {
						hasYoungObj = 1;
					}
				}
				/* begin mapFor:performUntil:arg: */
				mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;

				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {

						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask);
						if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, (((char *) mcpc)), hasYoungObjPtr);
						if (result != 0) {
							goto l1;
						}
					}
					else {
						if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
							mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
						}
					}
					map -= 1;
				}
			l1:	/* end mapFor:performUntil:arg: */;
				if (hasYoungObj) {
					ensureInYoungReferrers(cogMethod);
					hasYoungObj = 0;
				}
				else {
					(cogMethod->cmRefersToYoung = 0);
				}
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (freedPIC) {
		unlinkSendsToFree();
	}
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(processor, ((usqInt)codeBase), ((usqInt)(limitZony())));
	}
}


/*	Update all references to objects in machine code for a full gc. Since
	the current (New)ObjectMemory GC makes everything old in a full GC
	a method not referring to young will not refer to young afterwards */

	/* Cogit>>#mapObjectReferencesInMachineCodeForFullGC */
static void
mapObjectReferencesInMachineCodeForFullGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	codeModified = 0;
	mapObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) != CMFree) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			(cogMethod->selector = remapOop((cogMethod->selector)));
			if (((cogMethod->cmType)) == CMClosedPIC) {
				assert(!((cogMethod->cmRefersToYoung)));
				mapObjectReferencesInClosedPIC(cogMethod);
			}
			else {
				if (((cogMethod->cmType)) == CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					(cogMethod->methodObject = remapOop((cogMethod->methodObject)));
				}
				/* begin mapFor:performUntil:arg: */
				mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;

				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {

						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask);
						if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, (((char *) mcpc)), 0);
						if (result != 0) {
							goto l1;
						}
					}
					else {
						if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
							mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
						}
					}
					map -= 1;
				}
			l1:	/* end mapFor:performUntil:arg: */;
							}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(processor, ((usqInt)codeBase), ((usqInt)(limitZony())));
	}
}


/*	Update all references to objects in machine code for either a Spur
	scavenging gc
	or a Squeak V3 incremental GC. Avoid scanning all code by using the
	youngReferrers list. In a young gc a method referring to young may no
	longer refer to young, but a
	method not referring to young cannot and will not refer to young
	afterwards.  */

	/* Cogit>>#mapObjectReferencesInMachineCodeForYoungGC */
static void
mapObjectReferencesInMachineCodeForYoungGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt hasYoungObj;
    sqInt hasYoungObjPtr;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    usqInt pointer;
    sqInt result;
    sqInt val;

	val = 0;
	hasYoungObj = 0;
	hasYoungObjPtr = ((sqInt)((&hasYoungObj)));
	codeModified = 0;
	pointer = youngReferrers();
	while (pointer < limitAddress) {
		assert(!hasYoungObj);
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (((cogMethod->cmType)) == CMFree) {
			assert(!((cogMethod->cmRefersToYoung)));
		}
		else {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			if ((cogMethod->cmRefersToYoung)) {
				assert((((cogMethod->cmType)) == CMMethod)
				 || (((cogMethod->cmType)) == CMOpenPIC));
				(cogMethod->selector = remapOop((cogMethod->selector)));
				if (isYoung((cogMethod->selector))) {
					hasYoungObj = 1;
				}
				if (((cogMethod->cmType)) == CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					(cogMethod->methodObject = remapOop((cogMethod->methodObject)));
					if (isYoung((cogMethod->methodObject))) {
						hasYoungObj = 1;
					}
				}
				/* begin mapFor:performUntil:arg: */
				mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				enumeratingCogMethod = cogMethod;

				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {

						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask);
						if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, (((char *) mcpc)), hasYoungObjPtr);
						if (result != 0) {
							goto l1;
						}
					}
					else {
						if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
							mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
						}
					}
					map -= 1;
				}
			l1:	/* end mapFor:performUntil:arg: */;
				if (hasYoungObj) {
					hasYoungObj = 0;
				}
				else {
					(cogMethod->cmRefersToYoung = 0);
				}
			}
		}
		pointer += BytesPerWord;
	}
	pruneYoungReferrers();
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(processor, ((usqInt)methodZoneBase), ((usqInt)(limitZony())));
	}
}


/*	Update all references to objects in machine code. */

	/* Cogit>>#mapObjectReferencesInMachineCode: */
void
mapObjectReferencesInMachineCode(sqInt gcMode)
{
	
	switch (gcMode) {
	case GCModeNewSpace:
		mapObjectReferencesInMachineCodeForYoungGC();
		break;
	case GCModeFull:
		mapObjectReferencesInMachineCodeForFullGC();
		break;
	case GCModeBecome:
		mapObjectReferencesInMachineCodeForBecome();
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	if (!(asserta((freeStart()) <= (youngReferrers())))) {
		error("youngReferrers list overflowed");
	}
}


/*	Mark objects in machine-code of marked methods (or open PICs with marked
	selectors). 
 */

	/* Cogit>>#markAndTraceMachineCodeOfMarkedMethods */
void
markAndTraceMachineCodeOfMarkedMethods(void)
{
    sqInt annotation;
    sqInt annotation1;
    CogMethod *cogMethod;
    sqInt map;
    sqInt map1;
    sqInt mapByte;
    sqInt mapByte1;
    sqInt mcpc;
    sqInt mcpc1;
    sqInt result;
    sqInt result1;
    sqInt val;
    sqInt val1;

	val = 0;
	val1 = 0;
	if (leakCheckFullGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	codeModified = 0;
	markAndTraceObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) == CMMethod)
		 && (isMarked((cogMethod->methodObject)))) {
			/* begin markAndTraceLiteralsIn: */
			assert(((((cogMethod->cmType)) == CMMethod)
			 && (isMarked((cogMethod->methodObject))))
			 || ((((cogMethod->cmType)) == CMOpenPIC)
			 && ((isImmediate((cogMethod->selector)))
			 || (isMarked((cogMethod->selector))))));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));
			maybeMarkCountersIn(cogMethod);
			/* begin maybeMarkIRCsIn: */
			/* begin mapFor:performUntil:arg: */
			mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;

			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = markLiteralspcmethod(annotation, (((char *) mcpc)), (((sqInt)cogMethod)));
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
						mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
					}
				}
				map -= 1;
			}
		l1:	/* end mapFor:performUntil:arg: */;
		}
		if ((((cogMethod->cmType)) == CMOpenPIC)
		 && ((isImmediate((cogMethod->selector)))
		 || (isMarked((cogMethod->selector))))) {
			/* begin markAndTraceLiteralsIn: */
			assert(((((cogMethod->cmType)) == CMMethod)
			 && (isMarked((cogMethod->methodObject))))
			 || ((((cogMethod->cmType)) == CMOpenPIC)
			 && ((isImmediate((cogMethod->selector)))
			 || (isMarked((cogMethod->selector))))));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));
			maybeMarkCountersIn(cogMethod);
			/* begin maybeMarkIRCsIn: */
			/* begin mapFor:performUntil:arg: */
			mcpc1 = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
			map1 = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;

			while (((mapByte1 = byteAt(map1))) != MapEnd) {
				if (mapByte1 >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc1 += (mapByte1 & DisplacementMask);
					if ((((annotation1 = ((usqInt) mapByte1) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt) ((mapByte1 = byteAt(map1 - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation1 += mapByte1 & DisplacementMask;
						map1 -= 1;
					}
					result1 = markLiteralspcmethod(annotation1, (((char *) mcpc1)), (((sqInt)cogMethod)));
					if (result1 != 0) {
						goto l2;
					}
				}
				else {
					if (mapByte1 < (((long)IsAnnotationExtension) << AnnotationShift)) {
						mcpc1 += (((long)(mapByte1 - DisplacementX2N)) << AnnotationShift);
					}
				}
				map1 -= 1;
			}
		l2:	/* end mapFor:performUntil:arg: */;
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (leakCheckFullGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	if (codeModified) {

		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(processor, ((usqInt)methodZoneBase), ((usqInt)(limitZony())));
	}
}


/*	Mark and trace any object references in the generated run-time. */

	/* Cogit>>#markAndTraceObjectReferencesInGeneratedRuntime */
static void
markAndTraceObjectReferencesInGeneratedRuntime(void)
{
    sqInt i;
    sqInt literal;
    usqInt mcpc;

	for (i = 0; i < runtimeObjectRefIndex; i += 1) {
		mcpc = objectReferencesInRuntime[i];
		literal = literalBeforeFollowingAddress(backEnd, mcpc);
		markAndTraceLiteralinatpc(literal, ((CogMethod *) null), ((usqInt)mcpc));
	}
}


/*	Mark and trace objects in the argument and free if it is appropriate.
	Answer if the method has been freed. firstVisit is a hint used to avoid
	scanning methods we've already seen. False positives are fine.
	For a CMMethod this
	frees if the bytecode method isnt marked,
	marks and traces object literals and selectors,
	unlinks sends to targets that should be freed.
	For a CMClosedPIC this
	frees if it refers to anything that should be freed or isn't marked.
	For a CMOpenPIC this
	frees if the selector isn't marked. */
/*	this recurses at most one level down */

	/* Cogit>>#markAndTraceOrFreeCogMethod:firstVisit: */
static sqInt NoDbgRegParms
markAndTraceOrFreeCogMethodfirstVisit(CogMethod *cogMethod, sqInt firstVisit)
{
    sqInt annotation;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    sqInt val;

	val = 0;
	if (((cogMethod->cmType)) == CMFree) {
		return 1;
	}
	assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
	if (((cogMethod->cmType)) == CMMethod) {
		if (!(isMarked((cogMethod->methodObject)))) {
			freeMethod(cogMethod);
			return 1;
		}
		if (firstVisit) {
			/* begin markLiteralsAndUnlinkUnmarkedSendsIn: */
			assert(((cogMethod->cmType)) == CMMethod);
			assert(isMarked((cogMethod->methodObject)));
			markAndTraceLiteralinat((cogMethod->selector), cogMethod, (&((cogMethod->selector))));
			maybeMarkCountersIn(cogMethod);
			/* begin maybeMarkIRCsIn: */
			/* begin mapFor:performUntil:arg: */
			mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;

			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = markLiteralsAndUnlinkIfUnmarkedSendpcmethod(annotation, (((char *) mcpc)), (((sqInt)cogMethod)));
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
						mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
					}
				}
				map -= 1;
			}
		l1:	/* end mapFor:performUntil:arg: */;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		if (!(closedPICRefersToUnmarkedObject(cogMethod))) {
			return 0;
		}
		freeMethod(cogMethod);
		return 1;
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		if (isMarked((cogMethod->selector))) {
			return 0;
		}
		freeMethod(cogMethod);
		return 1;
	}
	assert((((cogMethod->cmType)) == CMMethod)
	 || ((((cogMethod->cmType)) == CMClosedPIC)
	 || (((cogMethod->cmType)) == CMOpenPIC)));
	return 0;
}


/*	If entryPoint is that of some method, then mark and trace objects in it
	and free if it is appropriate.
	Answer if the method has been freed. */

	/* Cogit>>#markAndTraceOrFreePICTarget:in: */
static sqInt NoDbgRegParms
markAndTraceOrFreePICTargetin(sqInt entryPoint, CogMethod *cPIC)
{
    CogMethod *targetMethod;

	assert((entryPoint > methodZoneBase)
	 && (entryPoint < (freeStart())));
	if (((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
	 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {
		return 0;
	}
	targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
	assert((((targetMethod->cmType)) == CMMethod)
	 || (((targetMethod->cmType)) == CMFree));
	return markAndTraceOrFreeCogMethodfirstVisit(targetMethod, (((usqInt)targetMethod)) > (((usqInt)cPIC)));
}


/*	Mark and trace literals. Unlink sends that have unmarked cache tags or
	targets. 
 */

	/* Cogit>>#markLiteralsAndUnlinkIfUnmarkedSend:pc:method: */
static sqInt NoDbgRegParms
markLiteralsAndUnlinkIfUnmarkedSendpcmethod(sqInt annotation, char *mcpc, sqInt cogMethod)
{
    sqInt cacheTag;
    usqInt cacheTag1;
    sqInt cacheTagMarked;
    sqInt entryPoint;
    sqInt entryPoint1;
    sqInt literal;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt tagCouldBeObj;
    sqInt tagCouldBeObj1;
    CogMethod * targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;
    sqInt val;

	literal = 0;
	val = 0;
	if (annotation == IsObjectReference) {
		literal = literalBeforeFollowingAddress(backEnd, ((usqInt)mcpc));
		if (markAndTraceLiteralinatpc(literal, ((CogMethod *) cogMethod), ((usqInt)mcpc))) {
			codeModified = 1;
		}
	}
	if (annotation >= IsSendCall) {
		/* begin offsetCacheTagAndCouldBeObjectAt:annotation:into: */
		cacheTag1 = inlineCacheTagAt(backEnd, ((sqInt)mcpc));

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 0;
		cacheTagMarked = tagCouldBeObj1
		 && (cacheTagIsMarked(cacheTag1));
		if (entryPoint1 > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				targetMethod1 = ((CogMethod *) (entryPoint1 - cmEntryOffset));
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				targetMethod1 = ((CogMethod *) (entryPoint1 - cmNoCheckEntryOffset));
				sendTable1 = superSendTrampolines;



			}
			if ((!cacheTagMarked)
			 || (markAndTraceOrFreeCogMethodfirstVisit(targetMethod1, (((usqInt)targetMethod1)) > (((usqInt)mcpc))))) {

				/* Either the cacheTag is unmarked (e.g. new class) or the target
				   has been freed (because it is unmarked), so unlink the send. */
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorinat((targetMethod1->selector), enumeratingCogMethod, mcpc), unlinkedRoutine);
				codeModified = 1;
				markAndTraceLiteralinat((targetMethod1->selector), targetMethod1, (&((targetMethod1->selector))));
			}

		}
		else {

			/* cacheTag is selector */
					}

	}
	return 0;
}


/*	Mark and trace literals.
	Additionally in Newspeak, void push implicits that have unmarked classes. */

	/* Cogit>>#markLiterals:pc:method: */
static sqInt NoDbgRegParms
markLiteralspcmethod(sqInt annotation, char *mcpc, sqInt cogMethod)
{
    sqInt cacheTag;
    usqInt cacheTag1;
    sqInt entryPoint;
    sqInt entryPoint1;
    sqInt literal;
    sqInt tagCouldBeObj;
    sqInt tagCouldBeObj1;

	literal = 0;
	if (annotation == IsObjectReference) {
		literal = literalBeforeFollowingAddress(backEnd, ((usqInt)mcpc));
		if (markAndTraceLiteralinatpc(literal, ((CogMethod *) cogMethod), ((usqInt)mcpc))) {
			codeModified = 1;
		}
	}
	if (annotation >= IsSendCall) {
		/* begin offsetCacheTagAndCouldBeObjectAt:annotation:into: */
		cacheTag1 = inlineCacheTagAt(backEnd, ((sqInt)mcpc));

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 0;
		if (tagCouldBeObj1) {
					}

	}
	return 0;
}

	/* Cogit>>#markMethodAndReferents: */
void
markMethodAndReferents(CogBlockMethod *aCogMethod)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	assert((((aCogMethod->cmType)) == CMMethod)
	 || (((aCogMethod->cmType)) == CMBlock));
	cogMethod = (((aCogMethod->cmType)) == CMMethod
		? ((CogMethod *) aCogMethod)
		: cmHomeMethod(aCogMethod));
	(cogMethod->cmUsageCount = CMMaxUsageCount);
	/* begin mapFor:performUntil:arg: */
	mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;

	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {

			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask);
			if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = incrementUsageOfTargetIfLinkedSendmcpcignored(annotation, (((char *) mcpc)), 0);
			if (result != 0) {
				goto l1;
			}
		}
		else {
			if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
				mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
			}
		}
		map -= 1;
	}
l1:	/* end mapFor:performUntil:arg: */;
}

	/* Cogit>>#maxCogMethodAddress */
usqInt
maxCogMethodAddress(void)
{
	return ((usqInt)(limitZony()));
}


/*	If this is the Newspeak VM and the objectRepresentation supports pinning
	then allocate space for the implicit receiver caches on the heap. */

	/* Cogit>>#maybeAllocAndInitIRCs */
static sqInt
maybeAllocAndInitIRCs(void)
{
	return 1;

}


/*	Check that the header fields are consistent with the type.
	Answer 0 if it is ok, otherwise answer a code for the error. */

	/* Cogit>>#maybeFreeCogMethodDoesntLookKosher: */
static sqInt NoDbgRegParms
maybeFreeCogMethodDoesntLookKosher(CogMethod *cogMethod)
{
    sqInt result;

	result = cogMethodDoesntLookKosher(cogMethod);
	return (result == 2
		? 0
		: result);
}


/*	In SIsta Spur counters are held on the heap in pinned objects which must
	be marked
	to avoid them being garbage collected. This is the hook through which that
	happens. 
 */

	/* Cogit>>#maybeMarkCountersIn: */
static void NoDbgRegParms
maybeMarkCountersIn(CogMethod *cogMethod)
{
}

	/* Cogit>>#mclassIsSmallInteger */
static sqInt
mclassIsSmallInteger(void)
{
	return (methodClassOf(methodObj)) == (classSmallInteger());
}


/*	Answer the absolute machine code pc matching the zero-relative
	bytecode pc of a backward branch in cogMethod, given the start
	of the bytecodes for cogMethod's block or method object. */

	/* Cogit>>#mcPCForBackwardBranch:startBcpc:in: */
usqInt
mcPCForBackwardBranchstartBcpcin(sqInt bcpc, sqInt startbcpc, CogBlockMethod *cogMethod)
{
    sqInt aMethodHeader;
    sqInt aMethodHeader1;
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc1;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    sqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt targetPC;

	latestContinuation = 0;
	/* begin mapFor:bcpc:performUntil:arg: */
	assert(((cogMethod->stackCheckOffset)) > 0);

	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	result = 0;
	if (result != 0) {
		return result;
	}

	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc1 = startbcpc;
	if (((cogMethod->cmType)) == CMMethod) {
		isInBlock = 0;
		homeMethod = ((CogMethod *) cogMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		assert(((((usqInt) (byteAt(map))) >> AnnotationShift) == IsAbsPCReference)
		 || (((((usqInt) (byteAt(map))) >> AnnotationShift) == IsObjectReference)
		 || (((((usqInt) (byteAt(map))) >> AnnotationShift) == IsRelativeCall)
		 || ((((usqInt) (byteAt(map))) >> AnnotationShift) == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader = (homeMethod->methodHeader);
		bsOffset = 
#    if MULTIPLEBYTECODESETS
			(headerIndicatesAlternateBytecodeSet(aMethodHeader)
						? 256
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		bcpc1 += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc1 == ((cogMethod->startpc)));
		homeMethod = cmHomeMethod(cogMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		assert(((((usqInt) (byteAt(map))) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt) (byteAt(map))) >> AnnotationShift) == IsDisplacementX2N));
		while ((((usqInt) (byteAt(map))) >> AnnotationShift) != HasBytecodePC) {
			map -= 1;
		}

		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc1 = startbcpc - (blockCreationBytecodeSizeForHeader((homeMethod->methodHeader)));
		/* begin bytecodeSetOffsetForHeader: */
		aMethodHeader1 = (homeMethod->methodHeader);
		bsOffset = 
#    if MULTIPLEBYTECODESETS
			(headerIndicatesAlternateBytecodeSet(aMethodHeader1)
						? 256
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		byte = (fetchByteofObject(bcpc1, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc1 + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc1, -1, aMethodObj)
	: 0));
		bcpc1 = startbcpc;
	}

	/* Now skip up through the bytecode pc map entry for the stack check. */
	nExts = 0;
	while ((((usqInt) (byteAt(map))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {

		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt) mapByte) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask);
			if ((annotation >= IsSendCall)
			 || ((annotation == HasBytecodePC)
			 || (0))) {
				while (1) {
					byte = (fetchByteofObject(bcpc1, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc1 >= endbcpc) {
							return 0;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc1 >= latestContinuation)) {
							return 0;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc1, nExts, aMethodObj);
							targetPC = (bcpc1 + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc1 + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc1, nExts, aMethodObj)
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc1 = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && (isBackwardBranchatextsin(descriptor, bcpc1, nExts, aMethodObj));
				result = (isBackwardBranch
				 && ((((sqInt)(((void *)bcpc)))) == bcpc1)
					? ((sqInt)(((char *) mcpc)))
					: 0);
				if (result != 0) {
					return result;
				}
				bcpc1 = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt) mapByte) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt) mapByte) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
				mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
			}
		}
		map -= 1;
	}
	return 0;
}


/*	For the purposes of become: see if the two methods are similar, i.e. can
	be safely becommed.
	This is pretty strict. All literals and bytecodes must be identical. Only
	trailer bytes and header
	flags can differ. */

	/* Cogit>>#method:hasSameCodeAs:checkPenultimate: */
static sqInt NoDbgRegParms
methodhasSameCodeAscheckPenultimate(sqInt methodA, sqInt methodB, sqInt comparePenultimateLiteral)
{
    sqInt bi;
    sqInt endPCA;
    sqInt headerA;
    sqInt headerB;
    sqInt li;
    sqInt numLitsA;

	headerA = methodHeaderOf(methodA);
	headerB = methodHeaderOf(methodB);
	numLitsA = literalCountOfMethodHeader(headerA);
	endPCA = endPCOf(methodA);
	if (((argumentCountOfMethodHeader(headerA)) != (argumentCountOfMethodHeader(headerB)))
	 || (((temporaryCountOfMethodHeader(headerA)) != (temporaryCountOfMethodHeader(headerB)))
	 || (((primitiveIndexOfMethodheader(methodA, headerA)) != (primitiveIndexOfMethodheader(methodB, headerB)))
	 || ((numLitsA != (literalCountOfMethodHeader(headerB)))
	 || (endPCA > (numBytesOf(methodB))))))) {
		return 0;
	}
	for (li = 1; li < numLitsA; li += 1) {
		if ((fetchPointerofObject(li, methodA)) != (fetchPointerofObject(li, methodB))) {
			if ((li < (numLitsA - 1))
			 || (comparePenultimateLiteral)) {
				return 0;
			}
		}
	}
	for (bi = (startPCOfMethod(methodA)); bi <= endPCA; bi += 1) {
		if ((fetchByteofObject(bi, methodA)) != (fetchByteofObject(bi, methodB))) {
			return 0;
		}
	}
	return 1;
}

	/* Cogit>>#minCogMethodAddress */
sqInt
minCogMethodAddress(void)
{
	return methodZoneBase;
}

	/* Cogit>>#mnuOffset */
sqInt
mnuOffset(void)
{
	return missOffset;
}

	/* Cogit>>#NegateR: */
static AbstractInstruction * NoDbgRegParms
gNegateR(sqInt reg)
{
	return genoperand(NegateR, reg);
}

	/* Cogit>>#needsFrameIfImmutability: */
static sqInt NoDbgRegParms
needsFrameIfImmutability(sqInt stackDelta)
{
	return IMMUTABILITY;
}

	/* Cogit>>#needsFrameIfInBlock: */
static sqInt NoDbgRegParms
needsFrameIfInBlock(sqInt stackDelta)
{
	return inBlock;
}

	/* Cogit>>#needsFrameNever: */
static sqInt NoDbgRegParms
needsFrameNever(sqInt stackDelta)
{
	return 0;
}

	/* Cogit>>#noAssertMethodClassAssociationOf: */
static sqInt NoDbgRegParms
noAssertMethodClassAssociationOf(sqInt methodPointer)
{
	return literalofMethod((literalCountOfMethodHeader(noAssertHeaderOf(methodPointer))) - 1, methodPointer);
}


/*	Check that no method is maximally marked. A maximal mark is an indication
	the method has been scanned to increase the usage count of its referent
	methods.  */

	/* Cogit>>#noCogMethodsMaximallyMarked */
static sqInt
noCogMethodsMaximallyMarked(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) != CMFree)
		 && (((cogMethod->cmUsageCount)) == CMMaxUsageCount)) {
			return 0;
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return 1;
}


/*	Answer if all targets in the PIC are in-use methods. */

	/* Cogit>>#noTargetsFreeInClosedPIC: */
static sqInt NoDbgRegParms
noTargetsFreeInClosedPIC(sqInt cPIC)
{
	return !(cPICHasFreedTargets(cPIC));
}


/*	Store the generated machine code, answering the last address */

	/* Cogit>>#outputInstructionsAt: */
static sqInt NoDbgRegParms
outputInstructionsAt(sqInt startAddress)
{
    sqInt absoluteAddress;
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt j;

	absoluteAddress = startAddress;
	for (i = 0; i < opcodeIndex; i += 1) {
		abstractInstruction = abstractInstructionAt(i);
		assert(((abstractInstruction->address)) == absoluteAddress);
		/* begin outputMachineCodeAt: */
		for (j = 0; j < ((abstractInstruction->machineCodeSize)); j += 1) {
			byteAtput(absoluteAddress + j, ((abstractInstruction->machineCode))[j]);
		}
		absoluteAddress += (abstractInstruction->machineCodeSize);
	}
	return absoluteAddress;
}


/*	Output instructions generated for one of the generated run-time routines,
	a trampoline, etc
 */

	/* Cogit>>#outputInstructionsForGeneratedRuntimeAt: */
static sqInt NoDbgRegParms
outputInstructionsForGeneratedRuntimeAt(sqInt startAddress)
{
    sqInt endAddress;
    sqInt size;

	computeMaximumSizes();
	(methodLabel->address = startAddress);
	size = generateInstructionsAt(startAddress);
	endAddress = outputInstructionsAt(startAddress);
	assert((startAddress + size) == endAddress);
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	return startAddress;
}

	/* Cogit>>#PushCw: */
static AbstractInstruction * NoDbgRegParms
gPushCw(sqInt wordConstant)
{
    AbstractInstruction *anInstruction;

	/* begin gen:literal: */
	anInstruction = genoperand(PushCw, wordConstant);
	return anInstruction;
}


/*	Code entry closed PIC full or miss to an instance of a young class or to a
	young target method.
	Attempt to patch the send site to an open PIC. Answer if the attempt
	succeeded; in fact it will
	only return if the attempt failed.
	The stack looks like:
	receiver
	args
	sp=>	sender return address */

	/* Cogit>>#patchToOpenPICFor:numArgs:receiver: */
sqInt
patchToOpenPICFornumArgsreceiver(sqInt selector, sqInt numArgs, sqInt receiver)
{
    sqInt extent;
    CogMethod *oPIC;
    sqInt outerReturn;


	/* See if an Open PIC is already available. */
	outerReturn = stackTop();
	oPIC = openPICWithSelector(selector);
	if (!(oPIC)) {

		/* otherwise attempt to create an Open PIC. */
		oPIC = cogOpenPICSelectornumArgs(selector, numArgs);
		if ((((((sqInt)oPIC)) >= MaxNegativeErrorCode) && ((((sqInt)oPIC)) <= -1))) {

			/* For some reason the PIC couldn't be generated, most likely a lack of code memory. */
			if ((((sqInt)oPIC)) == InsufficientCodeSpace) {
				callForCogCompiledCodeCompaction();
			}
			return 0;
		}
	}
	extent = rewriteInlineCacheAttagtarget(backEnd, outerReturn, inlineCacheValueForSelectorinat(selector, mframeHomeMethodExport(), outerReturn), (((sqInt)oPIC)) + cmEntryOffset);
	flushICacheFromto(processor, (((usqInt)outerReturn)) - extent, ((usqInt)outerReturn));
	flushICacheFromto(processor, ((usqInt)oPIC), (((usqInt)oPIC)) + openPICSize);
	executeCogMethodfromLinkedSendWithReceiver(oPIC, receiver);
	return 1;
}


/*	This value is used to decide between MNU processing
	or interpretation in the closed PIC aborts. */

	/* Cogit>>#picAbortDiscriminatorValue */
static sqInt
picAbortDiscriminatorValue(void)
{
	return 0;
}


/*	Answer the start of the abort sequence for invoking the interpreter in a
	closed PIC.
 */

	/* Cogit>>#picInterpretAbortOffset */
static sqInt
picInterpretAbortOffset(void)
{
	return (interpretOffset()) - (callInstructionByteSize(backEnd));
}

	/* Cogit>>#previousInstruction */
static AbstractInstruction *
previousInstruction(void)
{
	assert(opcodeIndex > 0);
	return abstractInstructionAt(opcodeIndex - 1);
}

	/* Cogit>>#printCogMethodFor: */
void
printCogMethodFor(void *address)
{
    CogMethod *cogMethod;

	cogMethod = methodFor(address);
	if (cogMethod == 0) {
		print("not a method");
		cr();
	}
	else {
		printCogMethod(cogMethod);
	}
}

	/* Cogit>>#printPCMapPairsFor: */
void
printPCMapPairsFor(CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt value;

	mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	while (((mapByte = byteAt(map))) != MapEnd) {
		annotation = ((usqInt) mapByte) >> AnnotationShift;
		if (annotation == IsAnnotationExtension) {
			value = (mapByte & DisplacementMask) + IsSendCall;
		}
		else {
			value = annotation;
			mcpc += 1 * ((annotation == IsDisplacementX2N
	? ((long)(mapByte - DisplacementX2N)) << AnnotationShift
	: mapByte & DisplacementMask));
		}
		printHexnp(map);
		print(": ");
		printf("%02x", mapByte);
		printChar(' ');
		printNum(annotation);
		print(" (");
		
		switch (value) {
		case IsDisplacementX2N:
			print("IsDisplacementX2N");
			break;
		case IsAnnotationExtension:
			print("IsAnnotationExtension");
			break;
		case IsObjectReference:
			print("IsObjectReference");
			break;
		case IsAbsPCReference:
			print("IsAbsPCReference");
			break;
		case HasBytecodePC:
			print("HasBytecodePC");
			break;
		case IsRelativeCall:
			print("IsRelativeCall");
			break;
		case IsSendCall:
			print("IsSendCall");
			break;
		case IsSuperSend:
			print("IsSuperSend");
			break;
		case IsDirectedSuperSend:
			print("IsDirectedSuperSend");
			break;
		default:
			print("??? ");
			printHexnp(value);

		}

		print(") ");
		printHexnp(mapByte & DisplacementMask);
		printChar(' ');
		putchar('@');
		printHex(mcpc);
		cr();
		flush();
		map -= 1;
	}
}

	/* Cogit>>#printTrampolineTable */
void
printTrampolineTable(void)
{
    sqInt i;

	for (i = 0; i < trampolineTableIndex; i += 2) {
		printHex(((sqInt)(trampolineAddresses[i + 1])));
		print(": ");
		print(((char *) (trampolineAddresses[i])));
		cr();
	}
}

	/* Cogit>>#processorHasDivQuoRemAndMClassIsSmallInteger */
static sqInt
processorHasDivQuoRemAndMClassIsSmallInteger(void)
{
	return mclassIsSmallInteger();
}

	/* Cogit>>#processorHasMultiplyAndMClassIsSmallInteger */
static sqInt
processorHasMultiplyAndMClassIsSmallInteger(void)
{
	return mclassIsSmallInteger();
}

	/* Cogit>>#RotateRightCq:R: */
static AbstractInstruction * NoDbgRegParms
gRotateRightCqR(sqInt quickConstant, sqInt reg)
{
	return genoperandoperand(RotateRightCqR, quickConstant, reg);
}

	/* Cogit>>#recordGeneratedRunTime:address: */
static void NoDbgRegParms
recordGeneratedRunTimeaddress(char *aString, sqInt address)
{
	trampolineAddresses[trampolineTableIndex] = aString;
	trampolineAddresses[trampolineTableIndex + 1] = (((char *) address));
	trampolineTableIndex += 2;
}


/*	This one for C support code. */

	/* Cogit>>#recordPrimTraceFunc */
sqInt
recordPrimTraceFunc(void)
{
	return recordPrimTrace();
}

	/* Cogit>>#recordRunTimeObjectReferences */
static void
recordRunTimeObjectReferences(void)
{
    sqInt i;
    AbstractInstruction *instruction;

	for (i = 0; i < opcodeIndex; i += 1) {
		instruction = abstractInstructionAt(i);
		if (((instruction->annotation)) == IsObjectReference) {
			assert(runtimeObjectRefIndex < NumObjRefsInRuntime);
			assert(!hasYoungReferent);
			if (hasYoungReferent) {
				error("attempt to generate run-time routine containing young object reference.  Cannot initialize Cogit run-time.");
			}
			objectReferencesInRuntime[runtimeObjectRefIndex] = (((usqInt)(((instruction->address)) + ((instruction->machineCodeSize)))));
			runtimeObjectRefIndex += 1;
		}
	}
}

	/* Cogit>>#registerMaskFor: */
static sqInt NoDbgRegParms
registerMaskFor(sqInt reg)
{
	return 1LL << reg;
}

	/* Cogit>>#registerMaskFor:and: */
static sqInt NoDbgRegParms
registerMaskForand(sqInt reg1, sqInt reg2)
{
	return (1LL << reg1) | (1LL << reg2);
}

	/* Cogit>>#relocateCallsAndSelfReferencesInMethod: */
static void NoDbgRegParms
relocateCallsAndSelfReferencesInMethod(CogMethod *cogMethod)
{
    sqInt annotation;
    sqLong callDelta;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqLong refDelta;
    sqInt result;

	refDelta = (cogMethod->objectHeader);
	callDelta = refDelta;
	assert((((cogMethod->cmType)) == CMMethod)
	 || (((cogMethod->cmType)) == CMOpenPIC));
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)cogMethod)) + missOffset)) == ((((cogMethod->cmType)) == CMMethod
		? methodAbortTrampolineFor((cogMethod->cmNumArgs))
		: picAbortTrampolineFor((cogMethod->cmNumArgs)))));
	relocateCallBeforeReturnPCby(backEnd, (((sqInt)cogMethod)) + missOffset, -callDelta);
	/* begin mapFor:performUntil:arg: */
	mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	enumeratingCogMethod = cogMethod;

	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {

			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask);
			if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = relocateIfCallOrMethodReferencemcpcdelta(annotation, (((char *) mcpc)), refDelta);
			if (result != 0) {
				goto l1;
			}
		}
		else {
			if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
				mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
			}
		}
		map -= 1;
	}
l1:	/* end mapFor:performUntil:arg: */;
}

	/* Cogit>>#relocateCallsInClosedPIC: */
static void NoDbgRegParms
relocateCallsInClosedPIC(CogMethod *cPIC)
{
    sqLong callDelta;
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    sqInt pc1;
    sqLong refDelta;
    CogMethod *targetMethod;

	refDelta = (cPIC->objectHeader);
	callDelta = refDelta;
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)cPIC)) + missOffset)) == (picAbortTrampolineFor((cPIC->cmNumArgs))));
	relocateCallBeforeReturnPCby(backEnd, (((sqInt)cPIC)) + missOffset, -callDelta);
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);

		if (((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
		 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {

			/* Interpret/MNU */
					}
		else {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert(((targetMethod->cmType)) == CMMethod);
			if (i == 1) {
				relocateJumpLongBeforeFollowingAddressby(backEnd, pc, -(callDelta - ((targetMethod->objectHeader))));
			}
			else {
				relocateJumpLongConditionalBeforeFollowingAddressby(backEnd, pc, -(callDelta - ((targetMethod->objectHeader))));
			}
		}
	}
	assert(((cPIC->cPICNumCases)) > 0);
	/* begin relocateMethodReferenceBeforeAddress:by: */
	pc1 = (addressOfEndOfCaseinCPIC(2, cPIC)) + 7;
	assert((((byteAt(pc1 - 6)) == 141)
	 && (((byteAt(pc1 - 5)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7))))
	 || (((byteAt(pc1 - 8)) == 141)
	 && (((byteAt(pc1 - 7)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7)))));
	((AbstractInstruction *) backEnd);
	relocateJumpLongBeforeFollowingAddressby(backEnd, (((sqInt)cPIC)) + cPICEndOfCodeOffset, -callDelta);
}

	/* Cogit>>#relocateIfCallOrMethodReference:mcpc:delta: */
static sqInt NoDbgRegParms
relocateIfCallOrMethodReferencemcpcdelta(sqInt annotation, char *mcpc, sqInt refDelta)
{
    sqInt callDelta;
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt pc;
    sqInt sendTable;
    sqInt *sendTable1;
    CogMethod *targetMethod;
    sqInt unlinkedRoutine;

	callDelta = refDelta;
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint <= methodZoneBase) {

			/* send is not linked; just relocate */
			relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -callDelta);
			return 0;
		}
		/* begin offsetAndSendTableFor:annotation:into: */
		if (annotation == IsSendCall) {
			offset1 = cmEntryOffset;
			sendTable1 = ordinarySendTrampolines;
		}
		else {
			assert(annotation == IsSuperSend);
			offset1 = cmNoCheckEntryOffset;
			sendTable1 = superSendTrampolines;



		}
		targetMethod = ((CogMethod *) (entryPoint - offset1));
		if (((targetMethod->cmType)) != CMFree) {

			/* send target not freed; just relocate. */
			relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -(callDelta - ((targetMethod->objectHeader))));
			return 0;
		}
		unlinkedRoutine = sendTable1[((((targetMethod->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod->cmNumArgs)) : (NumSendTrampolines - 1))];
		unlinkedRoutine -= callDelta;
		rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorinat((targetMethod->selector), enumeratingCogMethod, mcpc), unlinkedRoutine);
		return 0;

	}
	if (annotation == IsRelativeCall) {
		relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -callDelta);
		return 0;
	}
	if (annotation == IsAbsPCReference) {
		/* begin relocateMethodReferenceBeforeAddress:by: */
		pc = ((sqInt)mcpc);
		assert((((byteAt(pc - 6)) == 141)
		 && (((byteAt(pc - 5)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7))))
		 || (((byteAt(pc - 8)) == 141)
		 && (((byteAt(pc - 7)) | (modRMRO(((AbstractInstruction *) backEnd), 0, 0, 7))) == (modRMRO(((AbstractInstruction *) backEnd), ModRegInd, 5, 7)))));
		((AbstractInstruction *) backEnd);
	}
	return 0;
}

	/* Cogit>>#remapIfObjectRef:pc:hasYoung: */
static sqInt NoDbgRegParms
remapIfObjectRefpchasYoung(sqInt annotation, char *mcpc, sqInt hasYoungPtr)
{
    sqInt cacheTag;
    usqInt cacheTag1;
    sqInt entryPoint;
    sqInt entryPoint1;
    sqInt ignored;
    sqInt literal;
    sqInt mappedCacheTag;
    sqInt mappedLiteral;
    sqInt *sendTable;
    sqInt tagCouldBeObj;
    sqInt tagCouldBeObj1;
    CogMethod *targetMethod;
    CogMethod *targetMethod1;

	if (annotation == IsObjectReference) {
		literal = literalBeforeFollowingAddress(backEnd, ((usqInt)mcpc));
		if (couldBeObject(literal)) {
			mappedLiteral = remapObject(literal);
			if (literal != mappedLiteral) {
				/* begin storeLiteral:atAnnotatedAddress:using: */
				storeLiteralbeforeFollowingAddress(((AbstractInstruction *) backEnd), mappedLiteral, ((usqInt)mcpc));
				codeModified = 1;
			}
			if ((hasYoungPtr != 0)
			 && (isYoung(mappedLiteral))) {
				(((sqInt *) hasYoungPtr))[0] = 1;
			}
		}
	}
	if (annotation >= IsSendCall) {
		/* begin offsetCacheTagAndCouldBeObjectAt:annotation:into: */
		cacheTag1 = inlineCacheTagAt(backEnd, ((sqInt)mcpc));

		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 0;
		if (tagCouldBeObj1
		 && (couldBeObject(cacheTag1))) {
			mappedCacheTag = remapObject(cacheTag1);
			if (cacheTag1 != mappedCacheTag) {
				rewriteInlineCacheTagat(backEnd, mappedCacheTag, ((usqInt)mcpc));
				codeModified = 1;
			}
			if ((hasYoungPtr != 0)
			 && (isYoung(mappedCacheTag))) {
				(((sqInt *) hasYoungPtr))[0] = 1;
			}
		}
		if (hasYoungPtr != 0) {

			/* Since the unlinking routines may rewrite the cacheTag to the send's selector, and
			   since they don't have the cogMethod to hand and can't add it to youngReferrers,
			   the method must remain in youngReferrers if the targetMethod's selector is young. */
			if (entryPoint1 > methodZoneBase) {

				/* It's a linked send. */
				/* begin targetMethodAndSendTableFor:annotation:into: */
				if (annotation == IsSendCall) {
					targetMethod1 = ((CogMethod *) (entryPoint1 - cmEntryOffset));
					sendTable = ordinarySendTrampolines;
				}
				else {
					assert(annotation == IsSuperSend);
					targetMethod1 = ((CogMethod *) (entryPoint1 - cmNoCheckEntryOffset));
					sendTable = superSendTrampolines;



				}
				if (isYoung((targetMethod1->selector))) {
					(((sqInt *) hasYoungPtr))[0] = 1;
				}

			}
		}

	}
	return 0;
}


/*	Remap a potential object reference from a closed PIC.
	This may be an object reference, an inline cache tag or null.
	Answer if the updated literal is young.
	mcpc is the address of the next instruction following either
	the load of the method literal or the compare of the class tag. */

	/* Cogit>>#remapMaybeObjRefInClosedPICAt: */
static sqInt NoDbgRegParms
remapMaybeObjRefInClosedPICAt(sqInt mcpc)
{
    sqInt object;
    sqInt subject;

	object = literalBeforeFollowingAddress(backEnd, mcpc);
	if (!(couldBeObject(object))) {
		return 0;
	}
	subject = remapOop(object);
	if (object != subject) {
		storeLiteralbeforeFollowingAddress(backEnd, subject, mcpc);
		codeModified = 1;
	}
	return isYoungObject(subject);
}


/*	Rewrite the three values involved in a CPIC case. Used by the initialize &
	extend CPICs.
	c.f. expectedClosedPICPrototype: */
/*	write the obj ref/operand via the second ldr */

	/* Cogit>>#rewriteCPICCaseAt:tag:objRef:target: */
static void NoDbgRegParms
rewriteCPICCaseAttagobjReftarget(sqInt followingAddress, sqInt newTag, sqInt newObjRef, sqInt newTarget)
{
    sqInt classTagPC;
    sqInt methodObjPC;

	methodObjPC = (followingAddress - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd));
	storeLiteralbeforeFollowingAddress(backEnd, newObjRef, methodObjPC);

	/* rewite the tag via the first ldr */
	classTagPC = followingAddress - (jumpLongConditionalByteSize(backEnd));
	storeLiteral32beforeFollowingAddress(backEnd, newTag, classTagPC);
	rewriteConditionalJumpLongAttarget(backEnd, followingAddress, newTarget);
}

	/* Cogit>>#SubCw:R: */
static AbstractInstruction * NoDbgRegParms
gSubCwR(sqInt wordConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(SubCwR, wordConstant, reg);
	return anInstruction;
}


/*	Answer the number of clean blocks found in the literal frame */

	/* Cogit>>#scanForCleanBlocks */
static sqInt
scanForCleanBlocks(void)
{
    sqInt i;
    sqInt iLimiT;
    sqInt lit;
    sqInt numCleanBlocks;
    sqInt startPCOrNil;

	numCleanBlocks = 0;
	for (i = 1, iLimiT = (literalCountOf(methodObj)); i <= iLimiT; i += 1) {
		lit = fetchPointerofObject(i, methodObj);
		startPCOrNil = startPCOrNilOfLiteralin(lit, methodObj);
		if (!(startPCOrNil == null)) {
			numCleanBlocks += 1;
		}
	}
	return numCleanBlocks;
}

	/* Cogit>>#setBreakMethod: */
void
setBreakMethod(sqInt anObj)
{
	breakMethod = anObj;
}

	/* Cogit>>#setPostCompileHook: */
void
setPostCompileHook(void (*aFunction)(CogMethod *))
{
	postCompileHook = aFunction;
}


/*	If a method is compiled to machine code via a block entry it won't have a
	selector. A subsequent send can find the method and hence fill in the
	selector. 
 */
/*	self disassembleMethod: cogMethod */

	/* Cogit>>#setSelectorOf:to: */
void
setSelectorOfto(CogMethod *cogMethod, sqInt aSelectorOop)
{
	compilationBreakpointisMNUCase(aSelectorOop, numBytesOf(aSelectorOop), 0);
	assert(((cogMethod->cmType)) == CMMethod);
	(cogMethod->selector = aSelectorOop);
	if (isYoung(aSelectorOop)) {
		ensureInYoungReferrers(cogMethod);
	}
}

	/* Cogit>>#spanForCleanBlockStartingAt: */
static sqInt NoDbgRegParms
spanForCleanBlockStartingAt(sqInt startPC)
{
    BytecodeDescriptor *descriptor;
    sqInt end;
    sqInt pc;

	pc = startPC;
	end = numBytesOf(methodObj);
	while (pc <= end) {
		descriptor = generatorAt((fetchByteofObject(pc, methodObj)) + bytecodeSetOffset);
		pc += (descriptor->numBytes);
		if ((descriptor->isReturn)) {
			return pc - startPC;
		}
	}
	error("couldn't locate end of clean block");
	return 0;
}

	/* Cogit>>#TstCq:R: */
static AbstractInstruction * NoDbgRegParms
gTstCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, reg);
	return anInstruction;
}

	/* Cogit>>#traceLinkedSendOffset */
sqInt
traceLinkedSendOffset(void)
{
	return (cmNoCheckEntryOffset + (callInstructionByteSize(backEnd))) + (0);
}


/*	Encode true and false and 0 to N such that they can't be confused for
	register numbers (including NoReg)
	and can be tested for by isTrampolineArgConstant: and decoded by
	trampolineArgValue: 
 */

	/* Cogit>>#trampolineArgConstant: */
static sqInt NoDbgRegParms
trampolineArgConstant(sqInt booleanOrInteger)
{
	assert(booleanOrInteger >= 0);
	return -2 - booleanOrInteger;
}

	/* Cogit>>#trampolineName:numArgs: */
static char * NoDbgRegParms
trampolineNamenumArgs(char *routinePrefix, sqInt numArgs)
{
    char *theString;

	/* begin trampolineName:numArgs:limit: */
	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, (numArgs <= (NumSendTrampolines - 2)
		? '0' + numArgs
		: 'N'));
	return theString;
}

	/* Cogit>>#trampolineName:numRegArgs: */
static char * NoDbgRegParms
trampolineNamenumRegArgs(char *routinePrefix, sqInt numArgs)
{
    char *theString;

	/* begin trampolineName:numArgs:limit: */
	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, (numArgs <= 2
		? '0' + numArgs
		: 'N'));
	return theString;
}

	/* Cogit>>#unknownBytecode */
static sqInt
unknownBytecode(void)
{
	return EncounteredUnknownBytecode;
}


/*	Unlink all sends in cog methods. */

	/* Cogit>>#unlinkAllSends */
void
unlinkAllSends(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!(methodZoneBase)) {
		return;
	}
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;

			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendpcignored(annotation, (((char *) mcpc)), 0);
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
						mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
					}
				}
				map -= 1;
			}
		l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if (((cogMethod->cmType)) != CMFree) {
				freeMethod(cogMethod);
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	flushICacheFromto(processor, ((usqInt)methodZoneBase), ((usqInt)(limitZony())));
}

	/* Cogit>>#unlinkIfFreeOrLinkedSend:pc:of: */
static sqInt NoDbgRegParms
unlinkIfFreeOrLinkedSendpcof(sqInt annotation, char *mcpc, sqInt theSelector)
{
    sqInt entryPoint;
    sqInt sendTable;
    sqInt *sendTable1;
    CogMethod * targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				targetMethod1 = ((CogMethod *) (entryPoint - cmEntryOffset));
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				targetMethod1 = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
				sendTable1 = superSendTrampolines;



			}
			if ((((targetMethod1->cmType)) == CMFree)
			 || (((targetMethod1->selector)) == theSelector)) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorinat((targetMethod1->selector), enumeratingCogMethod, mcpc), unlinkedRoutine);
				codeModified = 1;
			}

		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfInvalidClassSend:pc:ignored: */
static sqInt NoDbgRegParms
unlinkIfInvalidClassSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send, but maybe a super send or linked to an OpenPIC, in which case the cache tag will be a selector.... */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				targetMethod1 = ((CogMethod *) (entryPoint - cmEntryOffset));
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				targetMethod1 = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
				sendTable1 = superSendTrampolines;



			}
			if (!(((annotation == IsSuperSend)
				 || (0))
				 || (((targetMethod1->cmType)) == CMOpenPIC))) {
				if (!(isValidClassTag(inlineCacheTagAt(backEnd, ((sqInt)mcpc))))) {
					/* begin unlinkSendAt:targetMethod:sendTable: */
					unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
					rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorinat((targetMethod1->selector), enumeratingCogMethod, mcpc), unlinkedRoutine);
					codeModified = 1;
				}
			}

		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSendToFree:pc:ignored: */
static sqInt NoDbgRegParms
unlinkIfLinkedSendToFreepcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				targetMethod1 = ((CogMethod *) (entryPoint - cmEntryOffset));
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				targetMethod1 = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
				sendTable1 = superSendTrampolines;



			}
			if (((targetMethod1->cmType)) == CMFree) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorinat((targetMethod1->selector), enumeratingCogMethod, mcpc), unlinkedRoutine);
				codeModified = 1;
			}

		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSend:pc:ignored: */
static sqInt NoDbgRegParms
unlinkIfLinkedSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				targetMethod1 = ((CogMethod *) (entryPoint - cmEntryOffset));
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				targetMethod1 = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
				sendTable1 = superSendTrampolines;



			}
			/* begin unlinkSendAt:targetMethod:sendTable: */
			unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
			rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorinat((targetMethod1->selector), enumeratingCogMethod, mcpc), unlinkedRoutine);
			codeModified = 1;

		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSend:pc:to: */
static sqInt NoDbgRegParms
unlinkIfLinkedSendpcto(sqInt annotation, char *mcpc, sqInt theCogMethod)
{
    sqInt entryPoint;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {

			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				targetMethod1 = ((CogMethod *) (entryPoint - cmEntryOffset));
				sendTable1 = ordinarySendTrampolines;
			}
			else {
				assert(annotation == IsSuperSend);
				targetMethod1 = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
				sendTable1 = superSendTrampolines;



			}
			if ((((sqInt)targetMethod1)) == theCogMethod) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorinat((targetMethod1->selector), enumeratingCogMethod, mcpc), unlinkedRoutine);
				codeModified = 1;
			}

		}
	}
	return 0;
}


/*	Unlink all sends in cog methods whose class tag is that of a forwarded
	class. 
 */

	/* Cogit>>#unlinkSendsLinkedForInvalidClasses */
void
unlinkSendsLinkedForInvalidClasses(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedPIC;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!(methodZoneBase)) {
		return;
	}
	cogMethod = ((CogMethod *) methodZoneBase);
	codeModified = (freedPIC = 0);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;

			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfInvalidClassSendpcignored(annotation, (((char *) mcpc)), 0);
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
						mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
					}
				}
				map -= 1;
			}
		l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if ((((cogMethod->cmType)) == CMClosedPIC)
			 && (cPICHasForwardedClass(cogMethod))) {
				freeMethod(cogMethod);
				freedPIC = 1;
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedPIC) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {

			/* After possibly updating inline caches we need to flush the icache. */
			flushICacheFromto(processor, ((usqInt)methodZoneBase), ((usqInt)(limitZony())));
		}
	}
}


/*	Unlink all sends in cog methods. Free all Closed PICs with the selector,
	or with an MNU case if isMNUSelector. First check if any method actually
	has the selector; if not there can't be any linked send to it. This
	routine (including descendents) is performance critical. It contributes
	perhaps 30% of entire execution time in Compiler recompileAll. */

	/* Cogit>>#unlinkSendsOf:isMNUSelector: */
void
unlinkSendsOfisMNUSelector(sqInt selector, sqInt isMNUSelector)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt mustScanAndUnlink;
    sqInt result;

	if (!(methodZoneBase)) {
		return;
	}
	cogMethod = ((CogMethod *) methodZoneBase);
	mustScanAndUnlink = 0;
	if (isMNUSelector) {
		while (cogMethod < (limitZony())) {
			if (((cogMethod->cmType)) != CMFree) {
				if ((cogMethod->cpicHasMNUCase)) {
					assert(((cogMethod->cmType)) == CMClosedPIC);
					freeMethod(cogMethod);
					mustScanAndUnlink = 1;
				}
				else {
					if (((cogMethod->selector)) == selector) {
						mustScanAndUnlink = 1;
						if (((cogMethod->cmType)) == CMClosedPIC) {
							freeMethod(cogMethod);
						}
					}
				}
			}
			cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	}
	else {
		while (cogMethod < (limitZony())) {
			if ((((cogMethod->cmType)) != CMFree)
			 && (((cogMethod->selector)) == selector)) {
				mustScanAndUnlink = 1;
				if (((cogMethod->cmType)) == CMClosedPIC) {
					freeMethod(cogMethod);
				}
			}
			cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	}
	if (!mustScanAndUnlink) {
		return;
	}
	codeModified = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;

			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfFreeOrLinkedSendpcof(annotation, (((char *) mcpc)), selector);
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
						mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
					}
				}
				map -= 1;
			}
		l1:	/* end mapFor:performUntil:arg: */;
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (codeModified) {

		/* After possibly updating inline caches we need to flush the icache. */
		flushICacheFromto(processor, ((usqInt)methodZoneBase), ((usqInt)(limitZony())));
	}
}


/*	Unlink all sends in cog methods to free methods and/or pics. */

	/* Cogit>>#unlinkSendsToFree */
void
unlinkSendsToFree(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!(methodZoneBase)) {
		return;
	}
	codeModified = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;

			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendToFreepcignored(annotation, (((char *) mcpc)), 0);
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
						mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
					}
				}
				map -= 1;
			}
		l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				assert(noTargetsFreeInClosedPIC(cogMethod));
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (codeModified) {

		/* After possibly updating inline caches we need to flush the icache. */
		flushICacheFromto(processor, ((usqInt)methodZoneBase), ((usqInt)(limitZony())));
	}
}


/*	Unlink all sends in cog methods to a particular target method.
	If targetMethodObject isn't actually a method (perhaps being
	used via invokeAsMethod) then there's nothing to do. */

	/* Cogit>>#unlinkSendsTo:andFreeIf: */
void
unlinkSendsToandFreeIf(sqInt targetMethodObject, sqInt freeIfTrue)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedPIC;
    sqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *targetMethod;

	if (!((isOopCompiledMethod(targetMethodObject))
		 && (methodHasCogMethod(targetMethodObject)))) {
		return;
	}
	targetMethod = cogMethodOf(targetMethodObject);
	if (!(methodZoneBase)) {
		return;
	}
	codeModified = (freedPIC = 0);
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((sqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			enumeratingCogMethod = cogMethod;

			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {

					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask);
					if ((((annotation = ((usqInt) mapByte) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt) ((mapByte = byteAt(map - 1)))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendpcto(annotation, (((char *) mcpc)), (((sqInt)targetMethod)));
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((long)IsAnnotationExtension) << AnnotationShift)) {
						mcpc += (((long)(mapByte - DisplacementX2N)) << AnnotationShift);
					}
				}
				map -= 1;
			}
		l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if ((((cogMethod->cmType)) == CMClosedPIC)
			 && (cPICHasTarget(cogMethod, targetMethod))) {
				freeMethod(cogMethod);
				freedPIC = 1;
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freeIfTrue) {
		freeMethod(targetMethod);
	}
	if (freedPIC) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {

			/* After possibly updating inline caches we need to flush the icache. */
			flushICacheFromto(processor, ((usqInt)methodZoneBase), ((usqInt)(limitZony())));
		}
	}
}

	/* Cogit>>#XorCw:R: */
static AbstractInstruction * NoDbgRegParms
gXorCwR(sqInt wordConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(XorCwR, wordConstant, reg);
	return anInstruction;
}


/*	Access for the object representations when they need to prepend code to
	trampolines. 
 */

	/* Cogit>>#zeroOpcodeIndex */
static void
zeroOpcodeIndex(void)
{
	opcodeIndex = 0;
}

	/* CogMethodZone>>#addAllToYoungReferrers */
void
addAllToYoungReferrers(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) == CMMethod)
		 || (((cogMethod->cmType)) == CMOpenPIC)) {
			ensureInYoungReferrers(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* CogMethodZone>>#addToOpenPICList: */
static void NoDbgRegParms
addToOpenPICList(CogMethod *anOpenPIC)
{
	assert(((anOpenPIC->cmType)) == CMOpenPIC);
	assert((openPICList == null)
	 || (((openPICList->cmType)) == CMOpenPIC));
	(anOpenPIC->nextOpenPIC = ((usqInt)openPICList));
	openPICList = anOpenPIC;
}

	/* CogMethodZone>>#addToYoungReferrers: */
static void NoDbgRegParms
addToYoungReferrers(CogMethod *cogMethod)
{
	assert(youngReferrers <= limitAddress);
	assert((occurrencesInYoungReferrers(cogMethod)) == 0);
	assert((cogMethod->cmRefersToYoung));
	assert((youngReferrers <= limitAddress)
	 && (youngReferrers >= (limitAddress - (methodCount * BytesPerWord))));
	if (!(asserta((limitAddress - (methodCount * BytesPerWord)) >= mzFreeStart))) {
		error("no room on youngReferrers list");
	}
	youngReferrers -= BytesPerWord;
	longAtput(youngReferrers, ((usqInt)cogMethod));
}

	/* CogMethodZone>>#alignment */
static sqInt
alignment(void)
{
	return 8;
}

	/* CogMethodZone>>#allocate: */
static sqInt NoDbgRegParms
allocate(sqInt numBytes)
{
    usqInt allocation;
    sqInt roundedBytes;

	roundedBytes = (numBytes + 7) & -8;
	if ((mzFreeStart + roundedBytes) >= (limitAddress - (methodCount * BytesPerWord))) {
		return 0;
	}
	allocation = mzFreeStart;
	mzFreeStart += roundedBytes;
	methodCount += 1;
	return allocation;
}


/*	Free all methods */

	/* CogMethodZone>>#clearCogCompiledCode */
static void
clearCogCompiledCode(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) == CMMethod) {
			freeMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	manageFromto(baseAddress, limitAddress);
}

	/* CogMethodZone>>#compactCompiledCode */
static void
compactCompiledCode(void)
{
    unsigned short bytes;
    CogMethod *dest;
    sqLong objectHeaderValue;
    CogMethod *source;

	objectHeaderValue = nullHeaderForMachineCodeMethod();
	source = ((CogMethod *) baseAddress);
	openPICList = null;
	methodCount = 0;
	while ((source < (limitZony()))
	 && (((source->cmType)) != CMFree)) {
		assert((cogMethodDoesntLookKosher(source)) == 0);
		(source->objectHeader = objectHeaderValue);
		if (((source->cmUsageCount)) > 0) {
			(source->cmUsageCount = ((source->cmUsageCount)) / 2);
		}
		if (((source->cmType)) == CMOpenPIC) {
			(source->nextOpenPIC = ((usqInt)openPICList));
			openPICList = source;
		}
		methodCount += 1;
		source = ((CogMethod *) (roundUpLength((((sqInt)source)) + ((source->blockSize)))));
	}
	if (source >= (limitZony())) {
		haltmsg("no free methods; cannot compact.");
		return;
	}
	dest = source;
	while (source < (limitZony())) {
		assert((maybeFreeCogMethodDoesntLookKosher(source)) == 0);
		bytes = (source->blockSize);
		if (((source->cmType)) != CMFree) {
			methodCount += 1;
			memmove(dest, source, bytes);
			(dest->objectHeader = objectHeaderValue);
			if (((dest->cmType)) == CMMethod) {

				/* For non-Newspeak there should be a one-to-one mapping between bytecoded and
				   cog methods.  For Newspeak not necessarily, but only for anonymous accessors. */
				/* Only update the original method's header if it is referring to this CogMethod. */
				if ((((sqInt)(rawHeaderOf((dest->methodObject))))) == (((sqInt)source))) {
					rawHeaderOfput((dest->methodObject), ((sqInt)dest));
				}
				else {
					assert((noAssertMethodClassAssociationOf((dest->methodObject))) == (nilObject()));
									}
			}
			else {
				if (((dest->cmType)) == CMOpenPIC) {
					(dest->nextOpenPIC = ((usqInt)openPICList));
					openPICList = dest;
				}
			}
			if (((dest->cmUsageCount)) > 0) {
				(dest->cmUsageCount = ((dest->cmUsageCount)) / 2);
			}
			dest = ((CogMethod *) ((((usqInt)dest)) + bytes));
		}
		source = ((CogMethod *) ((((usqInt)source)) + bytes));
	}
	mzFreeStart = ((usqInt)dest);
	methodBytesFreedSinceLastCompaction = 0;
}

	/* CogMethodZone>>#ensureInYoungReferrers: */
static void NoDbgRegParms
ensureInYoungReferrers(CogMethod *cogMethod)
{
	if (!((cogMethod->cmRefersToYoung))) {
		assert((occurrencesInYoungReferrers(cogMethod)) == 0);
		(cogMethod->cmRefersToYoung = 1);
		addToYoungReferrers(cogMethod);
	}
}

	/* CogMethodZone>>#freeMethod: */
void
freeMethod(CogMethod *cogMethod)
{
	assert(((cogMethod->cmType)) != CMFree);
	assert(((cogMethodDoesntLookKosher(cogMethod)) == 0)
	 || (((cogMethodDoesntLookKosher(cogMethod)) == 23)
	 && ((((((CogMethod *) ((cogMethod->methodObject))))->cmType)) == CMFree)));
	if (((cogMethod->cmType)) == CMMethod) {

		/* For non-Newspeak there should ne a one-to-one mapping between bytecoded and
		   cog methods.  For Newspeak not necessarily, but only for anonymous accessors. */
		/* Only reset the original method's header if it is referring to this CogMethod. */
		if ((((sqInt)(rawHeaderOf((cogMethod->methodObject))))) == (((sqInt)cogMethod))) {
			rawHeaderOfput((cogMethod->methodObject), (cogMethod->methodHeader));
					}
		else {
			assert((noAssertMethodClassAssociationOf((cogMethod->methodObject))) == (nilObject()));
					}
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		removeFromOpenPICList(cogMethod);
	}
	(cogMethod->cmRefersToYoung = 0);
	(cogMethod->cmType = CMFree);
	methodBytesFreedSinceLastCompaction += (cogMethod->blockSize);
}


/*	Free methods, preferring older methods for compaction, up to some
	fraction, currently a quarter.
 */

	/* CogMethodZone>>#freeOlderMethodsForCompaction */
static void
freeOlderMethodsForCompaction(void)
{
    sqInt amountToFree;
    sqInt cascade0;
    sqInt cascade1;
    CogMethod *cogMethod;
    sqInt freeableUsage;
    usqInt freedSoFar;
    usqInt initialFreeSpace;
    usqInt zoneSize;

	zoneSize = limitAddress - baseAddress;
	initialFreeSpace = (limitAddress - mzFreeStart) + methodBytesFreedSinceLastCompaction;
	freedSoFar = initialFreeSpace;

	/* 4 needs to be e.g. a start-up parameter */
	amountToFree = zoneSize / 4;
	freeableUsage = 0;
	do {
		cogMethod = ((CogMethod *) baseAddress);
		while (((((usqInt)cogMethod)) < mzFreeStart)
		 && (freedSoFar < amountToFree)) {
			if ((((cogMethod->cmType)) != CMFree)
			 && (((cogMethod->cmUsageCount)) <= freeableUsage)) {
				freeMethod(cogMethod);
				freedSoFar += (cogMethod->blockSize);
			}
			cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	} while((freedSoFar < amountToFree)
		 && (((freeableUsage += 1)) < CMMaxUsageCount));
	}


/*	Answer that all entries in youngReferrers are in-use and have the
	cmRefersToYoung flag set.
	Used to check that the youngreferrers pruning routines work correctly. */

	/* CogMethodZone>>#kosherYoungReferrers */
static sqInt
kosherYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt pointer;

	if ((youngReferrers > limitAddress)
	 || (youngReferrers < mzFreeStart)) {
		return 0;
	}
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!((((cogMethod->cmType)) != CMFree)
			 && ((cogMethod->cmRefersToYoung)))) {
			return 0;
		}
		pointer += BytesPerWord;
	}
	return 1;
}

	/* CogMethodZone>>#manageFrom:to: */
static void NoDbgRegParms
manageFromto(sqInt theStartAddress, sqInt theLimitAddress)
{
	mzFreeStart = (baseAddress = theStartAddress);
	youngReferrers = (limitAddress = theLimitAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;
}

	/* CogMethodZone>>#methodFor: */
CogMethod *
methodFor(void *address)
{
    CogMethod *cogMethod;
    CogMethod *nextMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((cogMethod < (limitZony()))
	 && ((((usqInt)cogMethod)) <= (((usqInt)address)))) {
		nextMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		if (nextMethod == cogMethod) {
			return 0;
		}
		if (((((usqInt)address)) >= (((usqInt)cogMethod)))
		 && ((((usqInt)address)) < (((usqInt)nextMethod)))) {
			return cogMethod;
		}
		cogMethod = nextMethod;
	}
	return 0;
}

	/* CogMethodZone>>#numMethods */
static sqInt
numMethods(void)
{
	return methodCount;
}

	/* CogMethodZone>>#numMethodsOfType: */
sqInt
numMethodsOfType(sqInt cogMethodType)
{
    CogMethod *cogMethod;
    sqInt n;

	n = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == cogMethodType) {
			n += 1;
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return n;
}

	/* CogMethodZone>>#occurrencesInYoungReferrers: */
static sqInt NoDbgRegParms
occurrencesInYoungReferrers(CogMethod *cogMethod)
{
    sqInt count;
    usqInt pointer;

	assert(youngReferrers <= limitAddress);
	count = 0;
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		if ((((sqInt)cogMethod)) == (longAt(pointer))) {
			count += 1;
		}
		pointer += BytesPerWord;
	}
	return count;
}

	/* CogMethodZone>>#openPICWithSelector: */
static CogMethod * NoDbgRegParms
openPICWithSelector(sqInt aSelector)
{
    CogMethod *openPIC;

	openPIC = openPICList;
	do {
		if ((openPIC == null)
		 || (((openPIC->selector)) == aSelector)) {
			return openPIC;
		}
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	} while(1);
	return 0;
}


/*	Some methods have been freed. Compute how much each survivor needs to
	move during the ensuing compaction and record it in the objectHeader
	field. 
	For Sista, where we want PICs to last so they can be observed, we need to
	keep PICs unless
	they are definitely unused. So we need to identify unused PICs. So in
	planCompact, zero the
	usage counts of all PICs, saving the actual usage count in
	blockEntryOffset. Then in
	relocateMethodsPreCompaction (actually in
	relocateIfCallOrMethodReference:mcpc:delta:) restore the usage counts of
	used PICs. Finally in compactCompiledCode, clear the blockEntryOffset
	of the unused PICs; they will then have a zero count and be reclaimed in
	the next code compaction. */

	/* CogMethodZone>>#planCompaction */
static void
planCompaction(void)
{
    CogMethod *cogMethod;
    sqInt delta;

	delta = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) == CMFree) {
			delta -= (cogMethod->blockSize);
		}
		else {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			(cogMethod->objectHeader = delta);
					}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* CogMethodZone>>#printCogMethods */
void
printCogMethods(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		printCogMethod(cogMethod);
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* CogMethodZone>>#printCogMethodsOfType: */
void
printCogMethodsOfType(sqInt cmType)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == cmType) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* CogMethodZone>>#printCogMethodsWithMethod: */
void
printCogMethodsWithMethod(sqInt methodOop)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) != CMFree)
		 && (((cogMethod->methodObject)) == methodOop)) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* CogMethodZone>>#printCogMethodsWithPrimitive: */
void
printCogMethodsWithPrimitive(sqInt primIdx)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) != CMFree)
		 && (primIdx == (primitiveIndexOfMethodheader((cogMethod->methodObject), (cogMethod->methodHeader))))) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* CogMethodZone>>#printCogMethodsWithSelector: */
void
printCogMethodsWithSelector(sqInt selectorOop)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) != CMFree)
		 && (((cogMethod->selector)) == selectorOop)) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* CogMethodZone>>#printCogYoungReferrers */
void
printCogYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt pointer;

	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!((cogMethod->cmRefersToYoung))) {
			print("*");
		}
		if (((cogMethod->cmType)) == CMFree) {
			print("!");
		}
		if (!(((cogMethod->cmRefersToYoung))
			 && (((cogMethod->cmType)) != CMFree))) {
			print(" ");
		}
		printCogMethod(cogMethod);
		pointer += BytesPerWord;
	}
}

	/* CogMethodZone>>#printOpenPICList */
void
printOpenPICList(void)
{
    CogMethod *openPIC;

	openPIC = openPICList;
	while (!(openPIC == null)) {
		printCogMethod(openPIC);
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	}
}

	/* CogMethodZone>>#pruneYoungReferrers */
static sqInt
pruneYoungReferrers(void)
{
    usqInt dest;
    usqInt next;
    usqInt source;

	assert(youngReferrers <= limitAddress);
	if (youngReferrers == limitAddress) {
		return null;
	}
	dest = limitAddress;
	while (1) {
		next = dest - BytesPerWord;
		if (!((next >= youngReferrers)
		 && (((((CogMethod *) (longAt(next))))->cmRefersToYoung)))) break;
		dest = next;
	}
	assert(dest >= youngReferrers);
	source = dest - BytesPerWord;
	while (source >= youngReferrers) {
		if (((((CogMethod *) (longAt(source))))->cmRefersToYoung)) {
			assert(source < (dest - BytesPerWord));
			longAtput((dest -= BytesPerWord), longAt(source));
		}
		source -= BytesPerWord;
	}
	youngReferrers = dest;
	assert(kosherYoungReferrers());
	return 0;
}

	/* CogMethodZone>>#relocateAndPruneYoungReferrers */
static sqInt
relocateAndPruneYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt dest;
    usqInt next;
    usqInt source;

	assert(youngReferrers <= limitAddress);
	if (youngReferrers == limitAddress) {
		return null;
	}
	dest = limitAddress;
	while (1) {
		next = dest - BytesPerWord;
		if (!((next >= youngReferrers)
		 && (((((cogMethod = ((CogMethod *) (longAt(next))))->cmType)) != CMFree)
		 && ((cogMethod->cmRefersToYoung))))) break;
		if (((cogMethod->objectHeader)) != 0) {
			longAtput(next, (((sqInt)cogMethod)) + ((cogMethod->objectHeader)));
		}
		dest = next;
	}
	assert(dest >= youngReferrers);
	source = dest - BytesPerWord;
	while (source >= youngReferrers) {
		cogMethod = ((CogMethod *) (longAt(source)));
		if ((((cogMethod->cmType)) != CMFree)
		 && ((cogMethod->cmRefersToYoung))) {
			assert(source < (dest - BytesPerWord));
			if (((cogMethod->objectHeader)) != 0) {
				cogMethod = ((CogMethod *) ((((sqInt)cogMethod)) + (((sqInt)((cogMethod->objectHeader))))));
			}
			longAtput((dest -= BytesPerWord), ((sqInt)cogMethod));
		}
		source -= BytesPerWord;
	}
	youngReferrers = dest;
	return 0;
}


/*	All surviving methods have had the amount they are going to relocate by
	stored in their objectHeader fields. Relocate all relative calls so that
	after the compaction of both the method containing each call and the call
	target the calls invoke the same target. */

	/* CogMethodZone>>#relocateMethodsPreCompaction */
static sqInt
relocateMethodsPreCompaction(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) != CMFree) {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				relocateCallsInClosedPIC(cogMethod);
			}
			else {
				relocateCallsAndSelfReferencesInMethod(cogMethod);
			}
		}
		cogMethod = ((CogMethod *) (roundUpLength((((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	relocateAndPruneYoungReferrers();
	return 1;
}

	/* CogMethodZone>>#removeFromOpenPICList: */
static sqInt NoDbgRegParms
removeFromOpenPICList(CogMethod *anOpenPIC)
{
    CogMethod *prevPIC;

	assert(((anOpenPIC->cmType)) == CMOpenPIC);
	if (anOpenPIC == openPICList) {

		/* N.B. Use self rather than coInterpreter to avoid attempting to cast nil.
		   Conversion to CogMethod done in the nextOpenPIC accessor. */
		openPICList = ((CogMethod *) ((anOpenPIC->nextOpenPIC)));
		return null;
	}
	prevPIC = openPICList;
	do {
		assert((prevPIC != null)
		 && (((prevPIC->cmType)) == CMOpenPIC));
		if (((prevPIC->nextOpenPIC)) == (((sqInt)anOpenPIC))) {
			(prevPIC->nextOpenPIC = (anOpenPIC->nextOpenPIC));
			return null;
		}
		prevPIC = ((CogMethod *) ((prevPIC->nextOpenPIC)));
	} while(1);
	return 0;
}

	/* CogMethodZone>>#voidYoungReferrersPostTenureAll */
static void
voidYoungReferrersPostTenureAll(void)
{
    CogMethod *cogMethod;
    usqInt pointer;

	assert(youngReferrers <= limitAddress);
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (((cogMethod->cmType)) != CMFree) {
			(cogMethod->cmRefersToYoung = 0);
		}
		pointer += BytesPerWord;
	}
	youngReferrers = limitAddress;
}

	/* CogMethodZone>>#whereIsMaybeCodeThing: */
char *
whereIsMaybeCodeThing(sqInt anOop)
{
	if (oopisGreaterThanOrEqualToandLessThan(anOop, codeBase, limitAddress)) {
		if (oopisLessThan(anOop, methodZoneBase)) {
			return " is in generated runtime";
		}
		if (oopisLessThan(anOop, mzFreeStart)) {
			return " is in generated methods";
		}
		if (oopisLessThan(anOop, youngReferrers)) {
			return " is in code zone";
		}
		return " is in young referrers";
	}
	return null;
}

	/* CogObjectRepresentation>>#checkValidObjectReference: */
static sqInt NoDbgRegParms
checkValidObjectReference(sqInt anOop)
{
	return (!(isImmediate(anOop)))
	 && ((heapMapAtWord(pointerForOop(anOop))) != 0);
}

	/* CogObjectRepresentation>>#genCmpClassFloatCompactIndexR: */
static AbstractInstruction * NoDbgRegParms
genCmpClassFloatCompactIndexR(sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, ClassFloatCompactIndex, reg);
	return anInstruction;
}

	/* CogObjectRepresentation>>#genCmpClassMethodContextCompactIndexR: */
static AbstractInstruction * NoDbgRegParms
genCmpClassMethodContextCompactIndexR(sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, reg);
	return anInstruction;
}


/*	Get the method header (first word) of a CompiledMethod into headerReg.
	Deal with the method possibly being cogged. */

	/* CogObjectRepresentation>>#genGetMethodHeaderOf:into:scratch: */
static sqInt NoDbgRegParms
genGetMethodHeaderOfintoscratch(sqInt methodReg, sqInt headerReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jumpNotCogged;
    sqInt offset;

	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, methodReg, headerReg);
	/* begin genJumpSmallInteger:scratchReg: */
	jumpNotCogged = genJumpSmallInteger(headerReg);
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodHeader);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, offset, headerReg, headerReg);
	jmpTarget(jumpNotCogged, gLabel());
	return 0;
}

	/* CogObjectRepresentation>>#genLoadSlot:sourceReg:destReg: */
static sqInt NoDbgRegParms
genLoadSlotsourceRegdestReg(sqInt index, sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, (index * BytesPerWord) + BaseHeaderSize, sourceReg, destReg);
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveAdd */
static sqInt
genPrimitiveAdd(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(ClassReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, ReceiverResultReg, ClassReg);
	/* begin JumpOverflow: */
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, gLabel()));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveAsFloat */
static sqInt
genPrimitiveAsFloat(void)
{
    AbstractInstruction *jumpFailAlloc;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, TempReg, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpFailAlloc, gLabel());
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveBitAnd */
static sqInt
genPrimitiveBitAnd(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin AndR:R: */
	genoperandoperand(AndRR, Arg0Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotSI, gLabel());
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitOr */
static sqInt
genPrimitiveBitOr(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin OrR:R: */
	genoperandoperand(OrRR, Arg0Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotSI, gLabel());
	return CompletePrimitive;
}


/*	rTemp := rArg0
	rClass := tTemp
	rTemp := rTemp & 1
	jz nonInt
	rClass >>= 1
	cmp 0,rClass
	jge neg
	cmp 31,rClass // numSmallIntegerBits, jge for sign
	jge tooBig
	rTemp := rReceiver
	rTemp <<= rClass
	rTemp >>= rClass (arithmetic)
	cmp rTemp,rReceiver
	jnz ovfl
	rReceiver := rReceiver - 1
	rReceiver := rReceiver <<= rClass
	rReceiver := rReceiver + 1
	ret
	neg:
	rClass := 0 - rClass
	cmp 31,rClass // numSmallIntegerBits
	jge inRange
	rClass := 31
	inRange
	rReceiver := rReceiver >>= rClass.
	rReceiver := rReceiver | smallIntegerTags.
	ret
	ovfl
	tooBig
	nonInt:
	fail
 */

	/* CogObjectRepresentation>>#genPrimitiveBitShift */
static sqInt
genPrimitiveBitShift(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *jumpInRange;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;
    AbstractInstruction *jumpTooBig;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpNegative))) {
		/* begin CmpCq:R: */
		anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	}
	/* begin JumpNegative: */
	jumpNegative = genConditionalBranchoperand(JumpNegative, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant = numSmallIntegerBits();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant, ClassReg);
	/* begin JumpGreaterOrEqual: */
	jumpTooBig = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	/* begin LogicalShiftLeftR:R: */
	genoperandoperand(LogicalShiftLeftRR, ClassReg, TempReg);
	/* begin ArithmeticShiftRightR:R: */
	genoperandoperand(ArithmeticShiftRightRR, ClassReg, TempReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, TempReg, ReceiverResultReg);
	/* begin JumpNonZero: */
	jumpOvfl = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genRemoveSmallIntegerTagsInScratchReg(ReceiverResultReg);
	/* begin LogicalShiftLeftR:R: */
	genoperandoperand(LogicalShiftLeftRR, ClassReg, ReceiverResultReg);
	genAddSmallIntegerTagsTo(ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNegative, gNegateR(ClassReg));
	/* begin CmpCq:R: */
	quickConstant1 = numSmallIntegerBits();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant1, ClassReg);
	/* begin JumpLessOrEqual: */
	jumpInRange = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin MoveCq:R: */
	quickConstant2 = numSmallIntegerBits();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(MoveCqR, quickConstant2, ClassReg);
	jmpTarget(jumpInRange, gArithmeticShiftRightRR(ClassReg, ReceiverResultReg));
	genClearAndSetSmallIntegerTagsIn(ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotSI, jmpTarget(jumpTooBig, jmpTarget(jumpOvfl, gLabel())));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitXor */
static sqInt
genPrimitiveBitXor(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(Arg0Reg);
	/* begin XorR:R: */
	genoperandoperand(XorRR, Arg0Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotSI, gLabel());
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveClass */
static sqInt
genPrimitiveClass(void)
{
    sqInt reg;
    sqInt reg1;

	reg = ReceiverResultReg;
	if (methodOrBlockNumArgs > 0) {
		if (methodOrBlockNumArgs > 1) {
			return UnimplementedPrimitive;
		}
		/* begin genLoadArgAtDepth:into: */
		reg1 = (reg = Arg0Reg);
		assert(0 < (numRegArgs()));
	}
	if ((genGetClassObjectOfintoscratchReginstRegIsReceiver(reg, ReceiverResultReg, TempReg, reg == ReceiverResultReg)) == BadRegisterSet) {
		genGetClassObjectOfintoscratchReginstRegIsReceiver(reg, ClassReg, TempReg, reg == ReceiverResultReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	return UnfailingPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveDiv */
static sqInt
genPrimitiveDiv(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *convert;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpIsSI;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpSameSign;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	}
	/* begin JumpZero: */
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction2 = genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpZero: */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction1 = genoperandoperand(CmpCqR, 0, Arg1Reg);
	}
	/* begin JumpGreaterOrEqual: */
	jumpSameSign = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin SubCq:R: */
	anInstruction3 = genoperandoperand(SubCqR, 1, TempReg);
	jmpTarget(jumpSameSign, (convert = gLabel()));
	genConvertIntegerToSmallIntegerInReg(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpExact, gLabel());
	jumpIsSI = genJumpIsSmallIntegerValuescratch(TempReg, Arg1Reg);
	jmpTarget(jumpIsSI, convert);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, gLabel()));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveDivide */
static sqInt
genPrimitiveDivide(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpInexact;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOverflow;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	/* begin JumpZero: */
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpNonZero: */
	jumpInexact = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	jumpOverflow = genJumpNotSmallIntegerValuescratch(TempReg, Arg1Reg);
	genConvertIntegerToSmallIntegerInReg(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpOverflow, jmpTarget(jumpInexact, jmpTarget(jumpZero, jmpTarget(jumpNotSI, gLabel()))));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveEqual */
static sqInt
genPrimitiveEqual(void)
{
	return genSmallIntegerComparisonorDoubleComparisoninvert(JumpZero, gJumpFPEqual, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatAdd */
static sqInt
genPrimitiveFloatAdd(void)
{
	return genFloatArithmeticpreOpCheckboxed(AddRdRd, null, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatDivide */
static sqInt
genPrimitiveFloatDivide(void)
{
	return genFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatEqual */
static sqInt
genPrimitiveFloatEqual(void)
{
	return genFloatComparisoninvertboxed(gJumpFPEqual, 0, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatGreaterOrEqual */
static sqInt
genPrimitiveFloatGreaterOrEqual(void)
{
	return genFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 0, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatGreaterThan */
static sqInt
genPrimitiveFloatGreaterThan(void)
{
	return genFloatComparisoninvertboxed(gJumpFPGreater, 0, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatLessOrEqual */
static sqInt
genPrimitiveFloatLessOrEqual(void)
{
	return genFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 1, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatLessThan */
static sqInt
genPrimitiveFloatLessThan(void)
{
	return genFloatComparisoninvertboxed(gJumpFPGreater, 1, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatMultiply */
static sqInt
genPrimitiveFloatMultiply(void)
{
	return genFloatArithmeticpreOpCheckboxed(MulRdRd, null, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatNotEqual */
static sqInt
genPrimitiveFloatNotEqual(void)
{
	return genFloatComparisoninvertboxed(gJumpFPNotEqual, 0, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveFloatSquareRoot */
static sqInt
genPrimitiveFloatSquareRoot(void)
{
    AbstractInstruction *jumpFailAlloc;

	genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	/* begin SqrtRd: */
	genoperand(SqrtRd, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpFailAlloc, gLabel());
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveFloatSubtract */
static sqInt
genPrimitiveFloatSubtract(void)
{
	return genFloatArithmeticpreOpCheckboxed(SubRdRd, null, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveGreaterOrEqual */
static sqInt
genPrimitiveGreaterOrEqual(void)
{
	return genSmallIntegerComparisonorDoubleComparisoninvert(JumpGreaterOrEqual, gJumpFPGreaterOrEqual, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveGreaterThan */
static sqInt
genPrimitiveGreaterThan(void)
{
	return genSmallIntegerComparisonorDoubleComparisoninvert(JumpGreater, gJumpFPGreater, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveIdentical */
static sqInt
genPrimitiveIdentical(void)
{
	return genPrimitiveIdenticalOrNotIf(0);
}

	/* CogObjectRepresentation>>#genPrimitiveLessOrEqual */
static sqInt
genPrimitiveLessOrEqual(void)
{
	return genSmallIntegerComparisonorDoubleComparisoninvert(JumpLessOrEqual, gJumpFPGreaterOrEqual, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveLessThan */
static sqInt
genPrimitiveLessThan(void)
{
	return genSmallIntegerComparisonorDoubleComparisoninvert(JumpLess, gJumpFPGreater, 1);
}

	/* CogObjectRepresentation>>#genPrimitiveMod */
static sqInt
genPrimitiveMod(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpSameSign;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(ClassReg);
	/* begin JumpZero: */
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, Arg1Reg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genRemoveSmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction1 = genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpZero: */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction = genoperandoperand(CmpCqR, 0, Arg1Reg);
	}
	/* begin JumpGreaterOrEqual: */
	jumpSameSign = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ClassReg);
	jmpTarget(jumpSameSign, jmpTarget(jumpExact, gLabel()));
	genSetSmallIntegerTagsIn(ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, gLabel()));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveMultiply */
static sqInt
genPrimitiveMultiply(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(processorHasMultiplyAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	genRemoveSmallIntegerTagsInScratchReg(Arg1Reg);
	/* begin MulR:R: */
	genMulRR(backEnd, Arg1Reg, ClassReg);
	/* begin JumpOverflow: */
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	genSetSmallIntegerTagsIn(ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, gLabel()));
	return CompletePrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveNewMethod */
static sqInt
genPrimitiveNewMethod(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveNotEqual */
static sqInt
genPrimitiveNotEqual(void)
{
	return genSmallIntegerComparisonorDoubleComparisoninvert(JumpNonZero, gJumpFPNotEqual, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveNotIdentical */
static sqInt
genPrimitiveNotIdentical(void)
{
	return genPrimitiveIdenticalOrNotIf(1);
}

	/* CogObjectRepresentation>>#genPrimitiveQuo */
static sqInt
genPrimitiveQuo(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *convert;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpIsSI;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	}
	/* begin JumpZero: */
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction1 = genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpZero: */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin Label */
	convert = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerToSmallIntegerInReg(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpExact, gLabel());
	jumpIsSI = genJumpIsSmallIntegerValuescratch(TempReg, Arg1Reg);
	jmpTarget(jumpIsSI, convert);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, gLabel()));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatAdd */
static sqInt
genPrimitiveSmallFloatAdd(void)
{
	return genFloatArithmeticpreOpCheckboxed(AddRdRd, null, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatDivide */
static sqInt
genPrimitiveSmallFloatDivide(void)
{
	return genFloatArithmeticpreOpCheckboxed(DivRdRd, genDoubleFailIfZeroArgRcvrarg, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatEqual */
static sqInt
genPrimitiveSmallFloatEqual(void)
{
	return genFloatComparisoninvertboxed(gJumpFPEqual, 0, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatGreaterOrEqual */
static sqInt
genPrimitiveSmallFloatGreaterOrEqual(void)
{
	return genFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 0, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatGreaterThan */
static sqInt
genPrimitiveSmallFloatGreaterThan(void)
{
	return genFloatComparisoninvertboxed(gJumpFPGreater, 0, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatLessOrEqual */
static sqInt
genPrimitiveSmallFloatLessOrEqual(void)
{
	return genFloatComparisoninvertboxed(gJumpFPGreaterOrEqual, 1, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatLessThan */
static sqInt
genPrimitiveSmallFloatLessThan(void)
{
	return genFloatComparisoninvertboxed(gJumpFPGreater, 1, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatMultiply */
static sqInt
genPrimitiveSmallFloatMultiply(void)
{
	return genFloatArithmeticpreOpCheckboxed(MulRdRd, null, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatNotEqual */
static sqInt
genPrimitiveSmallFloatNotEqual(void)
{
	return genFloatComparisoninvertboxed(gJumpFPNotEqual, 0, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatSquareRoot */
static sqInt
genPrimitiveSmallFloatSquareRoot(void)
{
    AbstractInstruction *jumpFailAlloc;

	genGetSmallFloatValueOfscratchinto(ReceiverResultReg, SendNumArgsReg, DPFPReg0);
	/* begin SqrtRd: */
	genoperand(SqrtRd, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpFailAlloc, gLabel());
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveSmallFloatSubtract */
static sqInt
genPrimitiveSmallFloatSubtract(void)
{
	return genFloatArithmeticpreOpCheckboxed(SubRdRd, null, 0);
}

	/* CogObjectRepresentation>>#genPrimitiveSubtract */
static sqInt
genPrimitiveSubtract(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, Arg0Reg, TempReg);
	/* begin JumpOverflow: */
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	genAddSmallIntegerTagsTo(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, gLabel()));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genSmallIntegerComparison: */
static sqInt NoDbgRegParms
genSmallIntegerComparison(sqInt jumpOpcode)
{
    AbstractInstruction *anInstruction;
    sqInt constant;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpTrue;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpFail = genJumpNotSmallInteger(Arg0Reg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpTrue = genConditionalBranchoperand(jumpOpcode, 0);
	/* begin genMoveFalseR: */
	constant = falseObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, ReceiverResultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpTrue, genMoveTrueR(ReceiverResultReg));
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpFail, gLabel());
	return CompletePrimitive;
}


/*	Stack looks like
	return address */

	/* CogObjectRepresentation>>#genSmallIntegerComparison:orDoubleComparison:invert: */
static sqInt NoDbgRegParms
genSmallIntegerComparisonorDoubleComparisoninvert(sqInt jumpOpcode, AbstractInstruction *(*jumpFPOpcodeGenerator)(void *), sqInt invertComparison)
{
    AbstractInstruction *anInstruction;
    sqInt constant;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpNonInt;
    sqInt r;

	r = genSmallIntegerComparison(jumpOpcode);
	if (r < 0) {
		return r;
	}
	
#  if defined(DPFPReg0)

	/* Fall through on non-SmallInteger argument.  Argument may be a Float : let us check or fail */
	jumpNonInt = genJumpImmediate(Arg0Reg);

	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertSmallIntegerToIntegerInReg(ReceiverResultReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, ReceiverResultReg, DPFPReg0);
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	if (invertComparison) {

		/* May need to invert for NaNs */
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}

	/* FP jumps are a little weird */
	jumpCond = jumpFPOpcodeGenerator(0);
	/* begin genMoveFalseR: */
	constant = falseObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, ReceiverResultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpCond, genMoveTrueR(ReceiverResultReg));
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNonInt, jmpTarget(jumpFail, gLabel()));


#  endif /* defined(DPFPReg0) */

	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#isUnannotatableConstant: */
static sqInt NoDbgRegParms
isUnannotatableConstant(CogSimStackEntry *simStackEntry)
{
	return (((simStackEntry->type)) == SSConstant)
	 && (!(shouldAnnotateObjectReference((simStackEntry->constant))));
}

	/* CogObjectRepresentationFor64BitSpur>>#genAddSmallIntegerTagsTo: */
static sqInt NoDbgRegParms
genAddSmallIntegerTagsTo(sqInt aRegister)
{
    AbstractInstruction *anInstruction;

	/* begin AddCq:R: */
	anInstruction = genoperandoperand(AddCqR, 1, aRegister);
	return 0;
}


/*	Override to answer a SmallFloat64 if possible. */

	/* CogObjectRepresentationFor64BitSpur>>#genAllocFloatValue:into:scratchReg:scratchReg: */
static AbstractInstruction * NoDbgRegParms
genAllocFloatValueintoscratchRegscratchReg(sqInt dpreg, sqInt resultReg, sqInt scratch1, sqInt scratch2)
{
    sqInt address;
    sqInt address1;
    sqInt allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpFail1;
    AbstractInstruction *jumpMerge;
    AbstractInstruction *jumpNotSF;
    usqLong newFloatHeader;
    sqInt quickConstant;

	/* begin MoveRd:R: */
	assert(BytesPerWord == 8);
	genoperandoperand(MoveRdR, dpreg, resultReg);
	jumpNotSF = genJumpNotSmallFloatValueBitsscratch(resultReg, scratch1);
	genConvertBitsToSmallFloatInscratch(resultReg, scratch1);
	/* begin Jump: */
	jumpMerge = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpNotSF, gLabel());
	allocSize = BaseHeaderSize + (sizeof(double));
	newFloatHeader = headerForSlotsformatclassIndex((sizeof(double)) / BytesPerWord, firstLongFormat(), ClassFloatCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	/* begin gen:literal:operand: */
	anInstruction1 = genoperandoperand(MoveAwR, address, resultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	anInstruction2 = genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratch1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, scratch1);
	/* begin JumpAboveOrEqual: */
	jumpFail1 = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	/* begin gen:operand:literal: */
	anInstruction3 = genoperandoperand(MoveRAw, scratch1, address1);
	/* begin genStoreHeader:intoNewInstance:using: */
	anInstruction4 = genoperandoperand(MoveCqR, newFloatHeader, scratch1);
	/* begin MoveR:Mw:r: */
	anInstruction5 = genoperandoperandoperand(MoveRMwr, scratch1, 0, resultReg);
	/* begin MoveRd:M64:r: */
	anInstruction6 = genoperandoperandoperand(MoveRdM64r, dpreg, BaseHeaderSize, resultReg);
	jumpFail = jumpFail1;
	jmpTarget(jumpMerge, gLabel());
	return jumpFail;
}


/*	Set the SmallInteger tag bits when the tag bits may be filled with
	garbage. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genClearAndSetSmallIntegerTagsIn: */
static sqInt NoDbgRegParms
genClearAndSetSmallIntegerTagsIn(sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt quickConstant;

	/* begin AndCq:R: */
	quickConstant = -1 - (tagMask());
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratchReg);
	/* begin OrCq:R: */
	anInstruction1 = genoperandoperand(OrCqR, 1, scratchReg);
	return 0;
}


/*	Convert the in-SmallFloat64-range floating point value in integer register
	into a tagged SmallFloat64 oop.
	c.f. Spur64BitMemoryManager>>smallFloatObjectOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertBitsToSmallFloatIn:scratch: */
static sqInt NoDbgRegParms
genConvertBitsToSmallFloatInscratch(sqInt reg, sqInt scratch)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *jumpZero;
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin RotateLeftCq:R: */
	genoperandoperand(RotateLeftCqR, 1, reg);
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 1, reg);
	/* begin JumpBelowOrEqual: */
	jumpZero = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin SubCq:R: */
	quickConstant1 = ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(SubCqR, quickConstant1, reg);
	jmpTarget(jumpZero, gLogicalShiftLeftCqR(numTagBits(), reg));
	/* begin AddCq:R: */
	quickConstant = smallFloatTag();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AddCqR, quickConstant, reg);
	return 0;
}


/*	Convert the Character in reg to a SmallInteger, assuming
	the Character's value is a valid character. */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertCharacterToSmallIntegerInReg: */
static void NoDbgRegParms
genConvertCharacterToSmallIntegerInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin SubCq:R: */
	quickConstant = (characterTag()) - (smallIntegerTag());
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, quickConstant, reg);
}

	/* CogObjectRepresentationFor64BitSpur>>#genConvertIntegerToSmallIntegerInReg: */
static sqInt NoDbgRegParms
genConvertIntegerToSmallIntegerInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin LogicalShiftLeftCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, reg);
	/* begin AddCq:R: */
	anInstruction = genoperandoperand(AddCqR, 1, reg);
	return 0;
}


/*	Convert the SmallFloat in reg to its identityHash as a SmallInteger.
	Rotate the sign bit from bit 3 (zero-relative) to the sign bit. 
	c.f. Spur64BitMemoryManager>>rotatedFloatBitsOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallFloatToSmallFloatHashAsIntegerInReg:scratch: */
static sqInt NoDbgRegParms
genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(sqInt reg, sqInt scratch)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;
    sqInt quickConstant1;

	assert(((((usqInt) (smallFloatTag())) >> 1) - (smallIntegerTag())) == (smallIntegerTag()));
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 1, reg);
	gAndCqRR(1LL << ((numTagBits()) - 1), reg, scratch);
	/* begin SubR:R: */
	genoperandoperand(SubRR, scratch, reg);
	/* begin SubCq:R: */
	quickConstant1 = (((usqInt) (smallFloatTag())) >> 1) - (smallIntegerTag());
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, quickConstant1, reg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant = 0x3F - ((numTagBits()) - 1);
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, scratch);
	/* begin OrR:R: */
	genoperandoperand(OrRR, scratch, reg);
	return 0;
}


/*	Convert the SmallInteger in reg to a Character, assuming
	the SmallInteger's value is a valid character. */

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallIntegerToCharacterInReg: */
static void NoDbgRegParms
genConvertSmallIntegerToCharacterInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin AddCq:R: */
	quickConstant = (characterTag()) - (smallIntegerTag());
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant, reg);
}

	/* CogObjectRepresentationFor64BitSpur>>#genConvertSmallIntegerToIntegerInReg: */
static sqInt NoDbgRegParms
genConvertSmallIntegerToIntegerInReg(sqInt reg)
{
    sqInt quickConstant;

	/* begin ArithmeticShiftRightCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, reg);
	return 0;
}


/*	indexReg contains the 1-relative index of an element in tableObj.
	Since BaseHeaderSize = BytesPerOop we can use it as a
	zero-relative index from the beginning of the object. */

	/* CogObjectRepresentationFor64BitSpur>>#genFetchIndexRegister:from:into: */
static sqInt NoDbgRegParms
genFetchIndexRegisterfrominto(sqInt indexReg, sqInt tableObj, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	assert(indexReg != destReg);
	/* begin genMoveConstant:R: */
	if (shouldAnnotateObjectReference(tableObj)) {
		annotateobjRef(gMoveCwR(tableObj, destReg), tableObj);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, tableObj, destReg);
	}
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, indexReg, destReg, destReg);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genFloatArithmetic:preOpCheck:boxed: */
static sqInt NoDbgRegParms
genFloatArithmeticpreOpCheckboxed(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg), sqInt rcvrBoxed)
{
    AbstractInstruction *doOp;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFailCheck;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;
    AbstractInstruction *jumpNotSmallInteger;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	/* begin Label */
	doOp = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (!(preOpCheckOrNil == null)) {
		jumpFailCheck = preOpCheckOrNil(DPFPReg0, DPFPReg1);
	}
	genoperandoperand(arithmeticOperator, DPFPReg1, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotSmallFloat, gLabel());
	jumpNotSmallInteger = genJumpNotSmallInteger(Arg0Reg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, Arg1Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpNotSmallInteger, gLabel());
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, jmpTarget(jumpNotSmallInteger, jmpTarget(jumpFailAlloc, gLabel()))));
	if (!(preOpCheckOrNil == null)) {
		jmpTarget(jumpFailCheck, getJmpTarget(jumpFailAlloc));
	}
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genFloatComparison:invert:boxed: */
static sqInt NoDbgRegParms
genFloatComparisoninvertboxed(AbstractInstruction *(*jumpOpcodeGenerator)(void *), sqInt invertComparison, sqInt rcvrBoxed)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction * compare;
    sqInt constant;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction *jumpNotBoxedFloat;
    AbstractInstruction *jumpNotSmallFloat;
    AbstractInstruction *jumpNotSmallInteger;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	if (rcvrBoxed) {
		genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	}
	else {
		genGetSmallFloatValueOfscratchinto(ReceiverResultReg, TempReg, DPFPReg0);
	}
	jumpNotSmallFloat = genJumpNotSmallFloat(Arg0Reg);
	genGetSmallFloatValueOfscratchinto(Arg0Reg, TempReg, DPFPReg1);
	if (invertComparison) {

		/* May need to invert for NaNs */
		/* begin CmpRd:Rd: */
		compare = genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		/* begin CmpRd:Rd: */
		compare = genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}

	/* FP jumps are a little weird */
	jumpCond = jumpOpcodeGenerator(0);
	/* begin genMoveFalseR: */
	constant = falseObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, ReceiverResultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpCond, genMoveTrueR(ReceiverResultReg));
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotSmallFloat, gLabel());
	jumpNotSmallInteger = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, Arg0Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)compare));
	jmpTarget(jumpNotSmallInteger, gLabel());
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* begin JumpNonZero: */
	jumpNotBoxedFloat = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)compare));
	jmpTarget(jumpImmediate, jmpTarget(jumpNotBoxedFloat, gLabel()));
	return CompletePrimitive;
}


/*	Fetch the instance's identity hash into destReg, encoded as a
	SmallInteger. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genGetHashFieldNonImmOf:asSmallIntegerInto: */
static sqInt NoDbgRegParms
genGetHashFieldNonImmOfasSmallIntegerInto(sqInt instReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	/* begin MoveMw:r:R: */
	anInstruction2 = genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = (identityHashFullWordShift()) - (numTagBits());
	genoperandoperand(LogicalShiftRightCqR, quickConstant, destReg);
	/* begin AndCq:R: */
	quickConstant1 = ((long)(identityHashHalfWordMask())) << (numTagBits());
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant1, destReg);
	/* begin AddCq:R: */
	quickConstant2 = smallIntegerTag();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AddCqR, quickConstant2, destReg);
	return 0;
}


/*	Fetch the instance's identity hash into destReg, unencoded. */

	/* CogObjectRepresentationFor64BitSpur>>#genGetHashFieldNonImmOf:into: */
static sqInt NoDbgRegParms
genGetHashFieldNonImmOfinto(sqInt instReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 32, destReg);
	/* begin AndCq:R: */
	quickConstant = identityHashHalfWordMask();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	return 0;
}


/*	Extract the inline cache tag for the object in sourceReg into destReg. The
	inline cache tag for a given object is the value loaded in inline caches
	to distinguish
	objects of different classes. In Spur this is either the tags for
	immediates, or
	the receiver's classIndex. Answer the label for the start of the sequence. */

	/* CogObjectRepresentationFor64BitSpur>>#genGetInlineCacheClassTagFrom:into:forEntry: */
static AbstractInstruction * NoDbgRegParms
genGetInlineCacheClassTagFromintoforEntry(sqInt sourceReg, sqInt destReg, sqInt forEntry)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *entryLabel;
    AbstractInstruction *jumpImm;
    sqInt quickConstant;

	if (forEntry) {
		/* begin AlignmentNops: */
		genoperand(AlignmentNops, BytesPerWord);
	}
	/* begin Label */
	entryLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	gAndCqRR(tagMask(), sourceReg, destReg);
	/* begin JumpNonZero: */
	jumpImm = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	flag("endianness");
	/* begin MoveMw:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, sourceReg, destReg);
	/* begin AndCq:R: */
	quickConstant = classIndexMask();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	jmpTarget(jumpImm, gLabel());
	return entryLabel;
}

	/* CogObjectRepresentationFor64BitSpur>>#genGetOverflowSlotsOf:into: */
static sqInt NoDbgRegParms
genGetOverflowSlotsOfinto(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, -BaseHeaderSize, srcReg, destReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 8, destReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, 8, destReg);
	return 0;
}


/*	Convert the SmallFloat oop in ooppReg into the corresponding float value
	in dpReg.
	c.f. Spur64BitMemoryManager>>smallFloatBitsOf: */

	/* CogObjectRepresentationFor64BitSpur>>#genGetSmallFloatValueOf:scratch:into: */
static sqInt NoDbgRegParms
genGetSmallFloatValueOfscratchinto(sqInt oopReg, sqInt scratch, sqInt dpReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jumpSFZero;
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, oopReg, scratch);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(LogicalShiftRightCqR, quickConstant, scratch);
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 1, scratch);
	/* begin JumpLessOrEqual: */
	jumpSFZero = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant1 = ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AddCqR, quickConstant1, scratch);
	jmpTarget(jumpSFZero, gRotateRightCqR(1, scratch));
	/* begin MoveR:Rd: */
	assert(BytesPerWord == 8);
	genoperandoperand(MoveRRd, scratch, dpReg);
	return 0;
}


/*	Generate a test for aRegister containing an integer value in the
	SmallInteger range, and a jump if so, answering the jump.
	c.f. Spur64BitMemoryManager>>isIntegerValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpIsSmallIntegerValue:scratch: */
static AbstractInstruction * NoDbgRegParms
genJumpIsSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt quickConstant;
    sqInt quickConstant1;

	return (/* begin MoveR:R: */
		genoperandoperand(MoveRR, aRegister, scratchReg),
		/* begin ArithmeticShiftRightCq:R: */
		(quickConstant = 64 - (numTagBits())),
		genoperandoperand(ArithmeticShiftRightCqR, quickConstant, scratchReg),
		/* begin AddCq:R: */
		(anInstruction = genoperandoperand(AddCqR, 1, scratchReg)),
		/* begin AndCq:R: */
		(quickConstant1 = (1LL << ((numTagBits()) + 1)) - 1),
		/* begin gen:quickConstant:operand: */
		(anInstruction1 = genoperandoperand(AndCqR, quickConstant1, scratchReg)),
		/* begin CmpCq:R: */
		(anInstruction2 = genoperandoperand(CmpCqR, 1, scratchReg)),
		/* begin JumpLessOrEqual: */
		genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0)));
}


/*	Generate a compare and branch to test if aRegister contains other than a
	Character. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotCharacter: */
static AbstractInstruction * NoDbgRegParms
genJumpNotCharacter(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	return (/* begin TstCq:R: */
		(quickConstant = characterTag()),
		/* begin gen:quickConstant:operand: */
		(anInstruction = genoperandoperand(TstCqR, quickConstant, reg)),
		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)0)));
}


/*	Generate a test to check that the integer register contains a floating
	point value within the SmallFloat64 range,
	and answer the jump. c.f. Spur64BitMemoryManager>>isSmallFloatValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallFloatValueBits:scratch: */
static AbstractInstruction * NoDbgRegParms
genJumpNotSmallFloatValueBitsscratch(sqInt reg, sqInt exponent)
{
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpMaxExponent;
    AbstractInstruction *jumpMinExponent;
    AbstractInstruction *jumpTest;
    AbstractInstruction *jumpZeroMantissa;
    sqInt quickConstant;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;

	flag("if we combine the exponent range test with the conversion to tagged representation we test for a zero exponent only once. further, if we extract tags once into a scratch on the input side we test for immediates, SmallInteger and SmallFloat using the same intermediate result.  so to do is to move fp arithmetic into the object representations");
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, reg, exponent);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 1, exponent);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = (smallFloatMantissaBits()) + 1;
	genoperandoperand(LogicalShiftRightCqR, quickConstant, exponent);

	/* begin CmpCq:R: */
	quickConstant2 = smallFloatExponentOffset();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant2, exponent);
	/* begin JumpLessOrEqual: */
	jumpMinExponent = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = 0xFF + (smallFloatExponentOffset());
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant3, exponent);
	/* begin JumpLessOrEqual: */
	jumpMaxExponent = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin Jump: */
	jumpFail = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpMinExponent, gTstCqR((1LL << (smallFloatMantissaBits())) - 1, reg));
	/* begin JumpZero: */
	jumpZeroMantissa = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = smallFloatExponentOffset();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(CmpCqR, quickConstant4, exponent);
	/* begin Jump: */
	jumpTest = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpZeroMantissa, gCmpCqR(0, exponent));
	jmpTarget(jumpTest, gJumpNonZero(jumpFail));
	jmpTarget(jumpMaxExponent, gLabel());
	return jumpFail;
}


/*	Generate a compare and branch to test if aRegister contains other than a
	SmallFloat. Answer the jump. */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallFloat: */
static AbstractInstruction * NoDbgRegParms
genJumpNotSmallFloat(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	return (/* begin TstCq:R: */
		(quickConstant = smallFloatTag()),
		/* begin gen:quickConstant:operand: */
		(anInstruction = genoperandoperand(TstCqR, quickConstant, reg)),
		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)0)));
}


/*	Generate a test for aRegister containing an integer value outside the
	SmallInteger range, and a jump if so, answering the jump.
	c.f. Spur64BitMemoryManager>>isIntegerValue: */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallIntegerValue:scratch: */
static AbstractInstruction * NoDbgRegParms
genJumpNotSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt quickConstant;
    sqInt quickConstant1;

	return (/* begin MoveR:R: */
		genoperandoperand(MoveRR, aRegister, scratchReg),
		/* begin ArithmeticShiftRightCq:R: */
		(quickConstant = 64 - (numTagBits())),
		genoperandoperand(ArithmeticShiftRightCqR, quickConstant, scratchReg),
		/* begin AddCq:R: */
		(anInstruction = genoperandoperand(AddCqR, 1, scratchReg)),
		/* begin AndCq:R: */
		(quickConstant1 = (1LL << ((numTagBits()) + 1)) - 1),
		/* begin gen:quickConstant:operand: */
		(anInstruction1 = genoperandoperand(AndCqR, quickConstant1, scratchReg)),
		/* begin CmpCq:R: */
		(anInstruction2 = genoperandoperand(CmpCqR, 1, scratchReg)),
		/* begin JumpGreater: */
		genConditionalBranchoperand(JumpGreater, ((sqInt)0)));
}


/*	Generate a compare and branch to test if aRegister contains other than a
	SmallInteger. 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpNotSmallInteger: */
static AbstractInstruction * NoDbgRegParms
genJumpNotSmallInteger(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	return (/* begin TstCq:R: */
		(quickConstant = smallIntegerTag()),
		/* begin gen:quickConstant:operand: */
		(anInstruction = genoperandoperand(TstCqR, quickConstant, reg)),
		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)0)));
}


/*	Generate a compare and branch to test if aRegister contains a
	SmallInteger. Answer the jump, or UnimplementedOperation if this cannot be
	done with
	a single register. */

	/* CogObjectRepresentationFor64BitSpur>>#genJumpSmallInteger: */
static AbstractInstruction * NoDbgRegParms
genJumpSmallInteger(sqInt aRegister)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	return (/* begin TstCq:R: */
		(quickConstant = smallIntegerTag()),
		/* begin gen:quickConstant:operand: */
		(anInstruction = genoperandoperand(TstCqR, quickConstant, aRegister)),
		/* begin JumpNonZero: */
		genConditionalBranchoperand(JumpNonZero, ((sqInt)0)));
}


/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveAt */
static sqInt
genPrimitiveAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction14;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    AbstractInstruction *convertToIntAndReturn;
    sqInt formatReg;
    AbstractInstruction *jumpArrayOutOfBounds;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpFixedFieldsOutOfBounds;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction * jumpIsArray;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsMethod;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction * jumpIsWords;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfBounds;
    sqInt literal;
    AbstractInstruction *methodInBounds;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    sqInt quickConstant9;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin SubCq:R: */
	anInstruction = genoperandoperand(SubCqR, 1, Arg1Reg);
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	quickConstant = firstByteFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = arrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpZero: */
	jumpIsArray = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin JumpBelow: */
	jumpNotIndexable = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = weakArrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(CmpCqR, quickConstant2, formatReg);
	/* begin JumpBelowOrEqual: */
	jumpHasFixedFields = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = firstShortFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction4 = genoperandoperand(CmpCqR, quickConstant3, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstLongFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction5 = genoperandoperand(CmpCqR, quickConstant4, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsWords = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	jmpTarget(jumpNotIndexable, gLabel());
	/* begin Jump: */
	jumpNotIndexable = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsArray, gCmpRR(Arg1Reg, ClassReg));
	/* begin JumpBelowOrEqual: */
	jumpArrayOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant5 = ((usqInt) BaseHeaderSize) >> (shiftForWord());
	/* begin gen:quickConstant:operand: */
	anInstruction6 = genoperandoperand(AddCqR, quickConstant5, Arg1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsBytes, gLogicalShiftLeftCqR(shiftForWord(), ClassReg));
	gAndCqRR(BytesPerWord - 1, formatReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant6 = firstCompiledMethodFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction7 = genoperandoperand(CmpCqR, quickConstant6, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	literal = BaseHeaderSize;
	anInstruction8 = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	methodInBounds = anInstruction8;
	
	/* formatReg already contains a value <= 16r1f, so no need to zero it */
	/* begin MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, formatReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, formatReg, ReceiverResultReg);

	/* begin Label */
	convertToIntAndReturn = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, ClassReg));
	/* begin AndCq:R: */
	anInstruction9 = genoperandoperand(AndCqR, 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveM16:r:R: */
	anInstruction10 = genoperandoperandoperand(MoveM16rR, BaseHeaderSize, ReceiverResultReg, ReceiverResultReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpIsWords, gCmpRR(Arg1Reg, ClassReg));
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant7 = ((usqInt) BaseHeaderSize) >> ((shiftForWord()) - 1);
	/* begin gen:quickConstant:operand: */
	anInstruction11 = genoperandoperand(AddCqR, quickConstant7, Arg1Reg);
	/* begin MoveX32r:R:R: */
	genoperandoperandoperand(MoveX32rRR, Arg1Reg, ReceiverResultReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)convertToIntAndReturn));
	jmpTarget(jumpHasFixedFields, gAndCqR(classIndexMask(), TempReg));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, formatReg);
	/* begin CmpCq:R: */
	anInstruction12 = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	/* begin JumpZero: */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(formatReg, Scratch0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Scratch0Reg, formatReg);
	genConvertSmallIntegerToIntegerInReg(formatReg);
	/* begin AndCq:R: */
	quickConstant8 = fixedFieldsOfClassFormatMask();
	/* begin gen:quickConstant:operand: */
	anInstruction13 = genoperandoperand(AndCqR, quickConstant8, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpFixedFieldsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, formatReg, Arg1Reg);
	/* begin AddCq:R: */
	quickConstant9 = ((usqInt) BaseHeaderSize) >> (shiftForWord());
	/* begin gen:quickConstant:operand: */
	anInstruction14 = genoperandoperand(AddCqR, quickConstant9, Arg1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsMethod, gLabel());
	getLiteralCountOfplusOneinBytesintoscratch(ReceiverResultReg, 1, 1, ClassReg, TempReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelow: */
	genConditionalBranchoperand(JumpBelow, ((sqInt)methodInBounds));
	jmpTarget(jumpFixedFieldsOutOfBounds, jmpTarget(jumpArrayOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpNotIndexable, jmpTarget(jumpIsContext, jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, gLabel())))))))));
	return 0;
}


/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveAtPut */
static sqInt
genPrimitiveAtPut(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction14;
    AbstractInstruction *anInstruction15;
    AbstractInstruction *anInstruction16;
    AbstractInstruction *anInstruction17;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt formatReg;
    AbstractInstruction *jumpArrayOutOfBounds;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpBytesOutOfRange;
    AbstractInstruction * jumpFixedFieldsOutOfBounds;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImmediate;
    AbstractInstruction * jumpImmutable;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction * jumpIsCompiledMethod;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction * jumpNonSmallIntegerValue;
    AbstractInstruction *jumpNotIndexableBits;
    AbstractInstruction *jumpNotIndexablePointers;
    AbstractInstruction * jumpNotPointers;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpShortsOutOfRange;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfRange;
    AbstractInstruction *methodInBounds;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;

	/* begin genLoadArgAtDepth:into: */
	assert(1 < (numRegArgs()));
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpImmediate = genJumpImmediate(ReceiverResultReg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin SubCq:R: */
	anInstruction16 = genoperandoperand(SubCqR, 1, Arg0Reg);
	
#  if IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	jumpImmutable = genJumpBaseHeaderImmutable(TempReg);

#  else /* IMMUTABILITY */
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);

#  endif /* IMMUTABILITY */

	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	quickConstant = weakArrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	/* begin JumpAbove: */
	jumpNotPointers = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genStoreCheckReceiverRegvalueRegscratchReginFrame(ReceiverResultReg, Arg1Reg, TempReg, 0);
	/* begin CmpCq:R: */
	quickConstant1 = arrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpBelow: */
	jumpNotIndexablePointers = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin JumpNonZero: */
	jumpHasFixedFields = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpArrayOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	anInstruction2 = genoperandoperand(AddCqR, ((usqInt) BaseHeaderSize) >> (shiftForWord()), Arg0Reg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, Arg1Reg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpHasFixedFields, gLabel());
	genGetClassIndexOfNonImminto(ReceiverResultReg, formatReg);
	/* begin CmpCq:R: */
	anInstruction3 = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, formatReg);
	/* begin JumpZero: */
	jumpIsContext = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(formatReg, Scratch0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Scratch0Reg, formatReg);
	genConvertSmallIntegerToIntegerInReg(formatReg);
	/* begin AndCq:R: */
	quickConstant2 = fixedFieldsOfClassFormatMask();
	/* begin gen:quickConstant:operand: */
	anInstruction4 = genoperandoperand(AndCqR, quickConstant2, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin AddCq:R: */
	anInstruction5 = genoperandoperand(AddCqR, ((usqInt) BaseHeaderSize) >> (shiftForWord()), formatReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpFixedFieldsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, formatReg, Arg0Reg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, Arg1Reg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotPointers, gLabel());
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNonSmallIntegerValue = genJumpNotSmallInteger(Arg1Reg);
	/* begin CmpCq:R: */
	quickConstant3 = firstByteFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction6 = genoperandoperand(CmpCqR, quickConstant3, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstShortFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction7 = genoperandoperand(CmpCqR, quickConstant4, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = firstLongFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction8 = genoperandoperand(CmpCqR, quickConstant5, formatReg);
	/* begin JumpBelow: */
	jumpNotIndexableBits = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CmpCq:R: */
	anInstruction9 = genoperandoperand(CmpCqR, (((sqInt)0xFFFFFFFFULL << 3) | 1), Arg1Reg);
	/* begin JumpAbove: */
	jumpWordsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, ClassReg);
	/* begin AndCq:R: */
	anInstruction10 = genoperandoperand(AndCqR, (BytesPerWord / 4) - 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddCq:R: */
	anInstruction11 = genoperandoperand(AddCqR, ((usqInt) BaseHeaderSize) >> ((shiftForWord()) - 1), Arg0Reg);
	/* begin MoveR:X32r:R: */
	genoperandoperandoperand(MoveRX32rR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsBytes, gCmpCqR((((sqInt)0xFF << 3) | 1), Arg1Reg));
	/* begin JumpAbove: */
	jumpBytesOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), ClassReg);
	gAndCqRR(BytesPerWord - 1, formatReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, TempReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant6 = firstCompiledMethodFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction12 = genoperandoperand(CmpCqR, quickConstant6, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsCompiledMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	methodInBounds = genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddCq:R: */
	anInstruction13 = genoperandoperand(AddCqR, BaseHeaderSize, Arg0Reg);
	/* begin MoveR:Xbr:R: */
	genoperandoperandoperand(MoveRXbrR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsShorts, gCmpCqR((((sqInt)0xFFFF << 3) | 1), Arg1Reg));
	/* begin JumpAbove: */
	jumpShortsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 1, ClassReg);
	/* begin AndCq:R: */
	anInstruction14 = genoperandoperand(AndCqR, (BytesPerWord / 2) - 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:M16:r: */
	anInstruction17 = genoperandoperandoperand(MoveRM16r, TempReg, BaseHeaderSize, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsCompiledMethod, gLabel());
	getLiteralCountOfplusOneinBytesintoscratch(ReceiverResultReg, 1, 1, ClassReg, TempReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelow: */
	genConditionalBranchoperand(JumpBelow, ((sqInt)methodInBounds));
	jmpTarget(jumpIsContext, jmpTarget(jumpNotIndexableBits, jmpTarget(jumpBytesOutOfRange, jmpTarget(jumpShortsOutOfRange, jmpTarget(jumpWordsOutOfRange, jmpTarget(jumpIsCompiledMethod, jmpTarget(jumpArrayOutOfBounds, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpNotIndexablePointers, jmpTarget(jumpNonSmallIntegerValue, jmpTarget(jumpFixedFieldsOutOfBounds, gLabel())))))))))))));
	
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, getJmpTarget(jumpIsContext));

#  endif /* IMMUTABILITY */

	/* begin AddCq:R: */
	anInstruction15 = genoperandoperand(AddCqR, 1, Arg0Reg);
	genConvertIntegerToSmallIntegerInReg(Arg0Reg);
	jmpTarget(jumpBadIndex, jmpTarget(jumpImmediate, gLabel()));
	return 0;
}


/*	Arguably we should fail for immediates, but so far no one has complained,
	so... 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveIdentityHash */
static sqInt
genPrimitiveIdentityHash(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jumpImm;
    AbstractInstruction *jumpNotCharacter;
    AbstractInstruction *jumpNotSet;
    sqInt quickConstant;
    AbstractInstruction * ret;


	/* uses TstCqR */
	jumpImm = genJumpImmediate(ReceiverResultReg);
	genGetHashFieldNonImmOfasSmallIntegerInto(ReceiverResultReg, TempReg);
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, ConstZero, TempReg);
	/* begin JumpZero: */
	jumpNotSet = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	ret = genoperand(RetN, 0);
	jmpTarget(jumpImm, gAndCqRR(tagMask(), ReceiverResultReg, TempReg));
	/* begin CmpCq:R: */
	quickConstant = characterTag();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpNonZero: */
	jumpNotCharacter = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertCharacterToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	ret = genoperand(RetN, 0);
	jmpTarget(jumpNotCharacter, gCmpCqR(smallFloatTag(), TempReg));
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)ret));
	genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(ReceiverResultReg, TempReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotSet, gLabel());
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveImmediateAsInteger */
static sqInt
genPrimitiveImmediateAsInteger(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpNotCharacter;
    sqInt quickConstant;
    AbstractInstruction * ret;

	gAndCqRR(tagMask(), ReceiverResultReg, TempReg);
	/* begin CmpCq:R: */
	quickConstant = characterTag();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpNonZero: */
	jumpNotCharacter = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertCharacterToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	ret = genoperand(RetN, 0);
	jmpTarget(jumpNotCharacter, gCmpCqR(smallFloatTag(), TempReg));
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)ret));
	genConvertSmallFloatToSmallFloatHashAsIntegerInRegscratch(ReceiverResultReg, TempReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	return UnfailingPrimitive;
}


/*	Implement primitiveNew for convenient cases:
	- the receiver has a hash
	- the receiver is fixed size (excluding ephemerons to save instructions &
	miniscule time)
	- single word header/num slots < numSlotsMask
	- the result fits in eden (actually below scavengeThreshold)
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveNew */
static sqInt
genPrimitiveNew(void)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt byteSizeReg;
    AbstractInstruction *fillLoop;
    sqInt fillReg;
    sqInt headerReg;
    sqInt instSpecReg;
    AbstractInstruction *jumpHasSlots;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpTooBig;
    AbstractInstruction *jumpUnhashed;
    AbstractInstruction *jumpVariableOrEphemeron;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    AbstractInstruction *skip;

	if (methodOrBlockNumArgs != 0) {
		return UnimplementedPrimitive;
	}

	/* inst spec will hold class's instance specification, then byte size and finally end of new object. */
	headerReg = (fillReg = SendNumArgsReg);

	/* get freeStart as early as possible so as not to wait later... */
	instSpecReg = (byteSizeReg = ClassReg);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveAwR, address, Arg1Reg);
	genGetHashFieldNonImmOfinto(ReceiverResultReg, headerReg);
	/* begin JumpZero: */
	jumpUnhashed = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, ReceiverResultReg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = fixedFieldsFieldWidth();
	genoperandoperand(LogicalShiftRightCqR, quickConstant, TempReg);
	/* begin AndCq:R: */
	quickConstant1 = formatMask();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant1, TempReg);
	/* begin AndCq:R: */
	quickConstant2 = fixedFieldsOfClassFormatMask();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(AndCqR, quickConstant2, instSpecReg);
	/* begin CmpCq:R: */
	quickConstant3 = nonIndexablePointerFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(CmpCqR, quickConstant3, TempReg);
	/* begin JumpAbove: */
	jumpVariableOrEphemeron = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = numSlotsMask();
	/* begin gen:quickConstant:operand: */
	anInstruction4 = genoperandoperand(CmpCqR, quickConstant4, instSpecReg);
	/* begin JumpAboveOrEqual: */
	jumpTooBig = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	quickConstant5 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant5, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant6 = numSlotsFullShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant6, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin CmpCq:R: */
	anInstruction5 = genoperandoperand(CmpCqR, 0, byteSizeReg);
	/* begin JumpNonZero: */
	jumpHasSlots = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveCq:R: */
	anInstruction6 = genoperandoperand(MoveCqR, BaseHeaderSize * 2, byteSizeReg);
	/* begin Jump: */
	skip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasSlots, gAddCqR(BaseHeaderSize / BytesPerWord, byteSizeReg));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	jmpTarget(skip, gAddRR(Arg1Reg, byteSizeReg));
	/* begin CmpCq:R: */
	quickConstant7 = getScavengeThreshold();
	/* begin gen:quickConstant:operand: */
	anInstruction7 = genoperandoperand(CmpCqR, quickConstant7, byteSizeReg);
	/* begin JumpAboveOrEqual: */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	/* begin gen:operand:literal: */
	anInstruction8 = genoperandoperand(MoveRAw, byteSizeReg, address1);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveR:Mw:r: */
	anInstruction9 = genoperandoperandoperand(MoveRMwr, headerReg, 0, Arg1Reg);
	/* begin LoadEffectiveAddressMw:r:R: */
	anInstruction10 = genoperandoperandoperand(LoadEffectiveAddressMwrR, BaseHeaderSize, ReceiverResultReg, Arg1Reg);
	/* begin MoveCq:R: */
	quickConstant8 = nilObject();
	/* begin gen:quickConstant:operand: */
	anInstruction11 = genoperandoperand(MoveCqR, quickConstant8, fillReg);
	/* begin MoveR:Mw:r: */
	anInstruction12 = genoperandoperandoperand(MoveRMwr, fillReg, 0, Arg1Reg);
	fillLoop = anInstruction12;
	/* begin AddCq:R: */
	anInstruction13 = genoperandoperand(AddCqR, 8, Arg1Reg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, byteSizeReg);
	/* begin JumpAbove: */
	genConditionalBranchoperand(JumpAbove, ((sqInt)fillLoop));
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpUnhashed, jmpTarget(jumpVariableOrEphemeron, jmpTarget(jumpTooBig, jmpTarget(jumpNoSpace, gLabel()))));
	return 0;
}


/*	Implement primitiveNewWithArg for convenient cases:
	- the receiver has a hash
	- the receiver is variable and not compiled method
	- single word header/num slots < numSlotsMask
	- the result fits in eden
	See superclass method for dynamic frequencies of formats.
	For the moment we implement only arrayFormat, firstByteFormat &
	firstLongFormat 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveNewWithArg */
static sqInt
genPrimitiveNewWithArg(void)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction14;
    AbstractInstruction *anInstruction15;
    AbstractInstruction *anInstruction16;
    AbstractInstruction *anInstruction17;
    AbstractInstruction *anInstruction18;
    AbstractInstruction *anInstruction19;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction20;
    AbstractInstruction *anInstruction21;
    AbstractInstruction *anInstruction22;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt byteSizeReg;
    AbstractInstruction *fillLoop;
    sqInt fillReg;
    sqInt headerReg;
    sqInt instSpecReg;
    AbstractInstruction *jumpArrayFormat;
    AbstractInstruction *jumpArrayTooBig;
    AbstractInstruction *jumpByteFormat;
    AbstractInstruction *jumpBytePrepDone;
    AbstractInstruction *jumpByteTooBig;
    AbstractInstruction *jumpFailCuzFixed;
    AbstractInstruction *jumpHasSlots;
    AbstractInstruction *jumpLongPrepDone;
    AbstractInstruction *jumpLongTooBig;
    AbstractInstruction *jumpNElementsNonInt;
    AbstractInstruction *jumpNoSpace;
    AbstractInstruction *jumpUnhashed;
    sqInt literal;
    sqInt literal1;
    sqInt literal2;
    sqInt maxSlots;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant10;
    sqInt quickConstant11;
    sqInt quickConstant12;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;
    sqInt quickConstant7;
    sqInt quickConstant8;
    sqInt quickConstant9;
    AbstractInstruction *skip;

	if (methodOrBlockNumArgs != 1) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));

	/* Assume there's an available scratch register on 64-bit machines.  This holds the saved numFixedFields and then the value to fill with */
	headerReg = SendNumArgsReg;
	fillReg = Scratch0Reg;
	assert(fillReg > 0);

	/* The max slots we'll allocate here are those for a single header */
	instSpecReg = (byteSizeReg = ClassReg);

	/* get freeStart as early as possible so as not to wait later... */
	maxSlots = (numSlotsMask()) - 1;
	/* begin MoveAw:R: */
	address = freeStartAddress();
	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveAwR, address, Arg1Reg);
	genGetHashFieldNonImmOfinto(ReceiverResultReg, headerReg);
	/* begin JumpZero: */
	jumpUnhashed = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpNElementsNonInt = genJumpNotSmallInteger(Arg0Reg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, ReceiverResultReg, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant = (fixedFieldsFieldWidth()) + (numSmallIntegerTagBits());
	genoperandoperand(LogicalShiftRightCqR, quickConstant, instSpecReg);
	/* begin AndCq:R: */
	quickConstant1 = formatMask();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant1, instSpecReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant2 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant2, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, fillReg);
	genConvertSmallIntegerToIntegerInReg(fillReg);
	/* begin CmpCq:R: */
	quickConstant3 = arrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant3, instSpecReg);
	/* begin JumpZero: */
	jumpArrayFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstByteFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(CmpCqR, quickConstant4, instSpecReg);
	/* begin JumpZero: */
	jumpByteFormat = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = firstLongFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction4 = genoperandoperand(CmpCqR, quickConstant5, instSpecReg);
	/* begin JumpNonZero: */
	jumpFailCuzFixed = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin CmpCq:R: */
	literal = (((maxSlots * 2) << 3) | 1);
	anInstruction5 = genoperandoperand(CmpCqR, (((maxSlots * 2) << 3) | 1), Arg0Reg);
	/* begin JumpAbove: */
	jumpLongTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	anInstruction6 = genoperandoperand(MoveCqR, BytesPerWord / 4, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	/* begin AndCq:R: */
	quickConstant6 = (BytesPerWord / 4) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction7 = genoperandoperand(AndCqR, quickConstant6, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant7 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant7, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin AddCq:R: */
	quickConstant8 = (BytesPerWord / 4) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction8 = genoperandoperand(AddCqR, quickConstant8, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, (shiftForWord()) - 2, instSpecReg);
	/* begin MoveCq:R: */
	anInstruction9 = genoperandoperand(MoveCqR, 0, fillReg);
	/* begin Jump: */
	jumpLongPrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpByteFormat, gCmpCqR((((maxSlots * BytesPerWord) << 3) | 1), Arg0Reg));
	/* begin JumpAbove: */
	jumpByteTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	anInstruction10 = genoperandoperand(MoveCqR, BytesPerWord, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, instSpecReg, TempReg);
	/* begin AndCq:R: */
	literal1 = BytesPerWord - 1;
	anInstruction11 = genoperandoperand(AndCqR, BytesPerWord - 1, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant9 = formatShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant9, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin AddCq:R: */
	literal2 = BytesPerWord - 1;
	anInstruction12 = genoperandoperand(AddCqR, BytesPerWord - 1, instSpecReg);
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, shiftForWord(), instSpecReg);
	/* begin MoveCq:R: */
	anInstruction13 = genoperandoperand(MoveCqR, 0, fillReg);
	/* begin Jump: */
	jumpBytePrepDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpArrayFormat, gCmpCqR(((maxSlots << 3) | 1), Arg0Reg));
	/* begin JumpAbove: */
	jumpArrayTooBig = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, fillReg, instSpecReg);
	/* begin MoveCq:R: */
	quickConstant12 = nilObject();
	/* begin gen:quickConstant:operand: */
	anInstruction14 = genoperandoperand(MoveCqR, quickConstant12, fillReg);
	jmpTarget(jumpBytePrepDone, jmpTarget(jumpLongPrepDone, gLabel()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instSpecReg, TempReg);
	/* begin LogicalShiftLeftCq:R: */
	quickConstant10 = numSlotsFullShift();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant10, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, TempReg, headerReg);
	/* begin CmpCq:R: */
	anInstruction15 = genoperandoperand(CmpCqR, 0, byteSizeReg);
	/* begin JumpNonZero: */
	jumpHasSlots = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveCq:R: */
	anInstruction16 = genoperandoperand(MoveCqR, BaseHeaderSize * 2, byteSizeReg);
	/* begin Jump: */
	skip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasSlots, gAddCqR(BaseHeaderSize / BytesPerWord, byteSizeReg));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), byteSizeReg);
	jmpTarget(skip, gAddRR(Arg1Reg, byteSizeReg));
	/* begin CmpCq:R: */
	quickConstant11 = getScavengeThreshold();
	/* begin gen:quickConstant:operand: */
	anInstruction17 = genoperandoperand(CmpCqR, quickConstant11, byteSizeReg);
	/* begin JumpAboveOrEqual: */
	jumpNoSpace = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	/* begin gen:operand:literal: */
	anInstruction18 = genoperandoperand(MoveRAw, byteSizeReg, address1);
	/* begin MoveR:Mw:r: */
	anInstruction19 = genoperandoperandoperand(MoveRMwr, headerReg, 0, ReceiverResultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	anInstruction20 = genoperandoperandoperand(LoadEffectiveAddressMwrR, BaseHeaderSize, ReceiverResultReg, Arg1Reg);
	/* begin MoveR:Mw:r: */
	anInstruction21 = genoperandoperandoperand(MoveRMwr, fillReg, 0, Arg1Reg);
	fillLoop = anInstruction21;
	/* begin AddCq:R: */
	anInstruction22 = genoperandoperand(AddCqR, 8, Arg1Reg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, byteSizeReg);
	/* begin JumpAbove: */
	genConditionalBranchoperand(JumpAbove, ((sqInt)fillLoop));
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNoSpace, jmpTarget(jumpUnhashed, jmpTarget(jumpFailCuzFixed, jmpTarget(jumpArrayTooBig, jmpTarget(jumpByteTooBig, jmpTarget(jumpLongTooBig, jmpTarget(jumpNElementsNonInt, gLabel())))))));
	return 0;
}


/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveStringAt */
static sqInt
genPrimitiveStringAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    AbstractInstruction *done;
    sqInt formatReg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpWordsDone;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordTooBig;
    sqInt literal;
    sqInt literal1;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin SubCq:R: */
	anInstruction1 = genoperandoperand(SubCqR, 1, Arg1Reg);
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);
	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	quickConstant = firstByteFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant, formatReg);
	/* begin JumpGreaterOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = firstShortFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpGreaterOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = firstLongFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction4 = genoperandoperand(CmpCqR, quickConstant2, formatReg);
	/* begin JumpLess: */
	jumpNotIndexable = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, ClassReg);
	/* begin AndCq:R: */
	quickConstant3 = (BytesPerWord / 4) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction5 = genoperandoperand(AndCqR, quickConstant3, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	quickConstant4 = ((usqInt) BaseHeaderSize) >> ((shiftForWord()) - 1);
	/* begin gen:quickConstant:operand: */
	anInstruction6 = genoperandoperand(AddCqR, quickConstant4, Arg1Reg);
	/* begin MoveX32r:R:R: */
	genoperandoperandoperand(MoveX32rRR, Arg1Reg, ReceiverResultReg, TempReg);
	jumpWordTooBig = jumpNotCharacterUnsignedValueInRegister(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	/* begin Jump: */
	jumpWordsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsBytes, gLogicalShiftLeftCqR(shiftForWord(), ClassReg));
	/* begin AndCq:R: */
	literal = BytesPerWord - 1;
	anInstruction7 = genoperandoperand(AndCqR, BytesPerWord - 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	literal1 = BaseHeaderSize;
	anInstruction8 = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	/* begin MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin AndCq:R: */
	anInstruction = genoperandoperand(AndCqR, 0xFF, ReceiverResultReg);

	jmpTarget(jumpWordsDone, (done = gLabel()));
	genConvertIntegerToCharacterInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, ClassReg));
	/* begin AndCq:R: */
	quickConstant5 = (BytesPerWord / 2) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction9 = genoperandoperand(AndCqR, quickConstant5, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg1Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg1Reg, ReceiverResultReg);
	/* begin MoveM16:r:R: */
	anInstruction10 = genoperandoperandoperand(MoveM16rR, BaseHeaderSize, ReceiverResultReg, ReceiverResultReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)done));
	jmpTarget(jumpWordTooBig, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, jmpTarget(jumpNotIndexable, jmpTarget(jumpBadIndex, gLabel()))))));
	return CompletePrimitive;
}


/*	c.f. StackInterpreter>>stSizeOf: SpurMemoryManager>>lengthOf:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationFor64BitSpur>>#genPrimitiveStringAtPut */
static sqInt
genPrimitiveStringAtPut(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt formatReg;
    AbstractInstruction *jumpBadArg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBytesOutOfBounds;
    AbstractInstruction *jumpBytesOutOfRange;
    AbstractInstruction * jumpImmutable;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction * jumpIsCompiledMethod;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction * jumpNotString;
    AbstractInstruction *jumpShortsOutOfBounds;
    AbstractInstruction *jumpShortsOutOfRange;
    AbstractInstruction *jumpWordsOutOfBounds;
    AbstractInstruction *jumpWordsOutOfRange;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;

	/* begin genLoadArgAtDepth:into: */
	assert(1 < (numRegArgs()));
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	jumpBadArg = genJumpNotCharacter(Arg1Reg);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin SubCq:R: */
	anInstruction11 = genoperandoperand(SubCqR, 1, Arg0Reg);
	
#  if IMMUTABILITY
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), TempReg);
	jumpImmutable = genJumpBaseHeaderImmutable(TempReg);

#  else /* IMMUTABILITY */
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, (formatReg = SendNumArgsReg), NoReg);

#  endif /* IMMUTABILITY */

	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	quickConstant = firstLongFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, formatReg);
	/* begin JumpBelow: */
	jumpNotString = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = firstCompiledMethodFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant1, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsCompiledMethod = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = firstByteFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant2, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = firstShortFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(CmpCqR, quickConstant3, formatReg);
	/* begin JumpAboveOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = characterObjectOf((1LL << (numCharacterBits())) - 1);
	/* begin gen:quickConstant:operand: */
	anInstruction4 = genoperandoperand(CmpCqR, quickConstant4, Arg1Reg);
	/* begin JumpAbove: */
	jumpWordsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 2, ClassReg);
	/* begin AndCq:R: */
	anInstruction5 = genoperandoperand(AndCqR, (BytesPerWord / 4) - 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpWordsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);
	/* begin AddCq:R: */
	anInstruction6 = genoperandoperand(AddCqR, ((usqInt) BaseHeaderSize) >> ((shiftForWord()) - 1), Arg0Reg);
	/* begin MoveR:X32r:R: */
	genoperandoperandoperand(MoveRX32rR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsShorts, gCmpCqR(characterObjectOf(0xFFFF), Arg1Reg));
	/* begin JumpAbove: */
	jumpShortsOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - 1, ClassReg);
	/* begin AndCq:R: */
	anInstruction7 = genoperandoperand(AndCqR, (BytesPerWord / 2) - 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpShortsOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:M16:r: */
	anInstruction12 = genoperandoperandoperand(MoveRM16r, TempReg, BaseHeaderSize, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpIsBytes, gCmpCqR(characterObjectOf(0xFF), Arg1Reg));
	/* begin JumpAbove: */
	jumpBytesOutOfRange = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), ClassReg);
	/* begin AndCq:R: */
	anInstruction8 = genoperandoperand(AndCqR, BytesPerWord - 1, formatReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, formatReg, ClassReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, Arg0Reg, ClassReg);
	/* begin JumpBelowOrEqual: */
	jumpBytesOutOfBounds = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, TempReg);
	genConvertCharacterToCodeInReg(TempReg);
	/* begin AddCq:R: */
	anInstruction9 = genoperandoperand(AddCqR, BaseHeaderSize, Arg0Reg);
	/* begin MoveR:Xbr:R: */
	genoperandoperandoperand(MoveRXbrR, TempReg, Arg0Reg, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg1Reg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotString, jmpTarget(jumpBytesOutOfRange, jmpTarget(jumpShortsOutOfRange, jmpTarget(jumpWordsOutOfRange, jmpTarget(jumpIsCompiledMethod, jmpTarget(jumpBytesOutOfBounds, jmpTarget(jumpShortsOutOfBounds, jmpTarget(jumpWordsOutOfBounds, gLabel()))))))));
	
#  if IMMUTABILITY
	jmpTarget(jumpImmutable, getJmpTarget(jumpNotString));

#  endif /* IMMUTABILITY */

	/* begin AddCq:R: */
	anInstruction10 = genoperandoperand(AddCqR, 1, Arg0Reg);
	genConvertIntegerToSmallIntegerInReg(Arg0Reg);
	jmpTarget(jumpBadArg, jmpTarget(jumpBadIndex, gLabel()));
	return CompletePrimitive;
}

	/* CogObjectRepresentationFor64BitSpur>>#genRemoveSmallIntegerTagsInScratchReg: */
static sqInt NoDbgRegParms
genRemoveSmallIntegerTagsInScratchReg(sqInt scratchReg)
{
    AbstractInstruction *anInstruction;

	/* begin SubCq:R: */
	anInstruction = genoperandoperand(SubCqR, 1, scratchReg);
	return 0;
}

	/* CogObjectRepresentationFor64BitSpur>>#genShiftAwaySmallIntegerTagsInScratchReg: */
static sqInt NoDbgRegParms
genShiftAwaySmallIntegerTagsInScratchReg(sqInt scratchReg)
{
    sqInt quickConstant;

	/* begin ArithmeticShiftRightCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, scratchReg);
	return 0;
}


/*	Get the literal count of a CompiledMethod into headerReg, plus one if
	requested. If inBytes is true, scale the count by the word size. Deal with
	the possibility of
	the method being cogged. */

	/* CogObjectRepresentationFor64BitSpur>>#getLiteralCountOf:plusOne:inBytes:into:scratch: */
static sqInt NoDbgRegParms
getLiteralCountOfplusOneinBytesintoscratch(sqInt methodReg, sqInt plusOne, sqInt inBytes, sqInt litCountReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;

	genGetMethodHeaderOfintoscratch(methodReg, litCountReg, scratchReg);
	assert((1LL << (numTagBits())) == BytesPerWord);
	if (inBytes) {
		/* begin AndCq:R: */
		quickConstant = ((long)(alternateHeaderNumLiteralsMask())) << (numTagBits());
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AndCqR, quickConstant, litCountReg);
	}
	else {
		/* begin LogicalShiftRightCq:R: */
		quickConstant1 = numTagBits();
		genoperandoperand(LogicalShiftRightCqR, quickConstant1, litCountReg);
		/* begin AndCq:R: */
		quickConstant2 = alternateHeaderNumLiteralsMask();
		/* begin gen:quickConstant:operand: */
		anInstruction1 = genoperandoperand(AndCqR, quickConstant2, litCountReg);
	}
	if (plusOne) {
		/* begin AddCq:R: */
		quickConstant3 = (inBytes
			? LiteralStart * BytesPerWord
			: LiteralStart);
		/* begin gen:quickConstant:operand: */
		anInstruction2 = genoperandoperand(AddCqR, quickConstant3, litCountReg);
	}
	return 0;
}


/*	Answer the relevant inline cache tag for an instance.
	c.f. getInlineCacheClassTagFrom:into: & inlineCacheTagForClass: */

	/* CogObjectRepresentationFor64BitSpur>>#inlineCacheTagForInstance: */
static sqInt NoDbgRegParms
inlineCacheTagForInstance(sqInt oop)
{
	return (isImmediate(oop)
		? oop & (tagMask())
		: classIndexOf(oop));
}

	/* CogObjectRepresentationFor64BitSpur>>#log2BytesPerWord */
static sqInt
log2BytesPerWord(void)
{
	return 3;
}


/*	Generate the routine that converts selector indices into selector objects.
	It is called from the send trampolines.
	If the selector index is negative, convert it into a positive index into
	the special selectors array and index that. Otherwise, index the current
	method.  */

	/* CogObjectRepresentationFor64BitSpur>>#maybeGenerateSelectorIndexDereferenceRoutine */
static void
maybeGenerateSelectorIndexDereferenceRoutine(void)
{
    sqInt address;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNotBlock;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;

	zeroOpcodeIndex();
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	/* begin JumpLess: */
	jumpNegative = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin MoveMw:r:R: */
	anInstruction4 = genoperandoperandoperand(MoveMwrR, FoxMethod, FPReg, Scratch0Reg);
	/* begin AddCq:R: */
	anInstruction1 = genoperandoperand(AddCqR, 2, ClassReg);
	/* begin TstCq:R: */
	anInstruction5 = genoperandoperand(TstCqR, MFMethodFlagIsBlockFlag, Scratch0Reg);
	/* begin JumpZero: */
	jumpNotBlock = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin AndCq:R: */
	quickConstant = -(alignment());
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(AndCqR, quickConstant, Scratch0Reg);
	/* begin MoveM16:r:R: */
	anInstruction6 = genoperandoperandoperand(MoveM16rR, 0, Scratch0Reg, Scratch1Reg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, Scratch1Reg, Scratch0Reg);
	jmpTarget(jumpNotBlock, gLabel());
	/* begin AndCq:R: */
	quickConstant1 = -(alignment());
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(AndCqR, quickConstant1, Scratch0Reg);
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodObject);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction7 = genoperandoperandoperand(MoveMwrR, offset, Scratch0Reg, Scratch1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, ClassReg, Scratch1Reg, ClassReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNegative, gLabel());
	/* begin NegateR: */
	genoperand(NegateR, ClassReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 1, ClassReg);
	/* begin MoveAw:R: */
	address = specialObjectsArrayAddress();
	/* begin gen:literal:operand: */
	anInstruction8 = genoperandoperand(MoveAwR, address, Scratch0Reg);
	/* begin SubCq:R: */
	anInstruction9 = genoperandoperand(SubCqR, 1, ClassReg);
	/* begin MoveMw:r:R: */
	anInstruction10 = genoperandoperandoperand(MoveMwrR, (SpecialSelectors + 1) * BytesPerWord, Scratch0Reg, Scratch1Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, ClassReg, Scratch1Reg, ClassReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	ceDereferenceSelectorIndex = methodZoneBase();
	outputInstructionsForGeneratedRuntimeAt(ceDereferenceSelectorIndex);
	recordGeneratedRunTimeaddress("ceDereferenceSelectorIndex", ceDereferenceSelectorIndex);
	recordRunTimeObjectReferences();
}

	/* CogObjectRepresentationFor64BitSpur>>#numSmallIntegerBits */
static sqInt
numSmallIntegerBits(void)
{
	return 61;
}

	/* CogObjectRepresentationFor64BitSpur>>#numSmallIntegerTagBits */
static sqInt
numSmallIntegerTagBits(void)
{
	return 3;
}


/*	The three valid tag patterns are 1 (SmallInteger), 2 (Character) and 3
	(SmallFloat64). 
 */

	/* CogObjectRepresentationFor64BitSpur>>#validInlineCacheTag: */
static sqInt NoDbgRegParms
validInlineCacheTag(sqInt classIndexOrTagPattern)
{
	return ((classIndexOrTagPattern >= 1)
	 && (classIndexOrTagPattern <= 3))
	 || ((classAtIndex(classIndexOrTagPattern)) != null);
}


/*	Answer if the cacheTag is not unmarked, i.e. answer true for compact class
	indices and immediates; only answer false for unmarked objects. In Spur
	linked send cache tags are class indices so effectively they're always
	marked.  */

	/* CogObjectRepresentationForSpur>>#cacheTagIsMarked: */
static sqInt NoDbgRegParms
cacheTagIsMarked(sqInt cacheTag)
{
	return 1;
}

	/* CogObjectRepresentationForSpur>>#checkValidOopReference: */
static sqInt NoDbgRegParms
checkValidOopReference(sqInt anOop)
{
	return (isImmediate(anOop))
	 || ((heapMapAtWord(pointerForOop(anOop))) != 0);
}

	/* CogObjectRepresentationForSpur>>#couldBeObject: */
static sqInt NoDbgRegParms
couldBeObject(sqInt literal)
{
	return (isNonImmediate(literal))
	 && (oopisGreaterThanOrEqualTo(literal, startOfMemory()));
}


/*	Create a trampoline to answer the active context that will
	answer it if a frame is already married, and create it otherwise.
	Assume numArgs is in SendNumArgsReg and ClassReg is free. */

	/* CogObjectRepresentationForSpur>>#genActiveContextTrampolineLarge:inBlock:called: */
static sqInt NoDbgRegParms
genActiveContextTrampolineLargeinBlockcalled(sqInt isLarge, sqInt isInBlock, char *aString)
{
    sqInt startAddress;

	startAddress = methodZoneBase();
	zeroOpcodeIndex();
	genGetActiveContextLargeinBlock(isLarge, isInBlock);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(aString, startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}

	/* CogObjectRepresentationForSpur>>#genConvertCharacterToCodeInReg: */
static sqInt NoDbgRegParms
genConvertCharacterToCodeInReg(sqInt reg)
{
    sqInt quickConstant;

	/* begin LogicalShiftRightCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(LogicalShiftRightCqR, quickConstant, reg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genConvertIntegerToCharacterInReg: */
static sqInt NoDbgRegParms
genConvertIntegerToCharacterInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;
    sqInt quickConstant1;

	/* begin LogicalShiftLeftCq:R: */
	quickConstant = numTagBits();
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, reg);
	/* begin AddCq:R: */
	quickConstant1 = characterTag();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AddCqR, quickConstant1, reg);
	return 0;
}


/*	Create a closure with the given startpc, numArgs and numCopied
	within a context with ctxtNumArgs, large if isLargeCtxt that is in a
	block if isInBlock. If numCopied > 0 pop those values off the stack. */

	/* CogObjectRepresentationForSpur>>#genCreateClosureAt:numArgs:numCopied:contextNumArgs:large:inBlock: */
static sqInt NoDbgRegParms
genCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock)
{
    AbstractInstruction *anInstruction;
    sqInt i;

	genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(bcpc, numArgs, numCopied, ctxtNumArgs, isLargeCtxt, isInBlock);
	for (i = 1; i <= numCopied; i += 1) {
		/* begin PopR: */
		genoperand(PopR, TempReg);
		/* begin MoveR:Mw:r: */
		anInstruction = genoperandoperandoperand(MoveRMwr, TempReg, (((numCopied - i) + ClosureFirstCopiedValueIndex) * BytesPerOop) + BaseHeaderSize, ReceiverResultReg);
	}
	return 0;
}


/*	Make sure that the object in reg is not forwarded. This routine assumes
	the object will
	never be forwarded to an immediate, as it is used to unforward literal
	variables (associations). 
	Use the fact that isForwardedObjectClassIndexPun is a power of two to save
	an instruction. */

	/* CogObjectRepresentationForSpur>>#genEnsureObjInRegNotForwarded:scratchReg: */
static sqInt NoDbgRegParms
genEnsureObjInRegNotForwardedscratchReg(sqInt reg, sqInt scratch)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *loop;
    AbstractInstruction *ok;
    sqInt quickConstant;

	assert(reg != scratch);
	/* begin Label */
	loop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin MoveMw:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, reg, scratch);
	/* begin AndCq:R: */
	quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratch);
	/* begin JumpNonZero: */
	ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, reg, reg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)loop));
	jmpTarget(ok, gLabel());
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genEnsureOopInRegNotForwarded:scratchReg: */
static sqInt NoDbgRegParms
genEnsureOopInRegNotForwardedscratchReg(sqInt reg, sqInt scratch)
{
	return genEnsureOopInRegNotForwardedscratchRegjumpBackTo(reg, scratch, gLabel());
}

	/* CogObjectRepresentationForSpur>>#genEnsureOopInRegNotForwarded:scratchReg:jumpBackTo: */
static sqInt NoDbgRegParms
genEnsureOopInRegNotForwardedscratchRegjumpBackTo(sqInt reg, sqInt scratch, AbstractInstruction *instruction)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *finished;
    AbstractInstruction *imm;
    AbstractInstruction *ok;
    sqInt quickConstant;

	/* begin genEnsureOopInRegNotForwarded:scratchReg:ifForwarder:ifNotForwarder: */
	assert(reg != scratch);

	/* notionally
	   self genGetClassIndexOfNonImm: reg into: scratch.
	   cogit CmpCq: objectMemory isForwardedObjectClassIndexPun R: TempReg.
	   but the following is an instruction shorter: */
	imm = genJumpImmediate(reg);
	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, reg, scratch);
	/* begin AndCq:R: */
	quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant, scratch);
	/* begin JumpNonZero: */
	ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, reg, reg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)(((void *) instruction))));
	/* begin Label */
	finished = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	jmpTarget(imm, jmpTarget(ok, finished));
	return 0;
}


/*	Make sure that the oop in reg is not forwarded, updating the slot in
	objReg with the value.
 */

	/* CogObjectRepresentationForSpur>>#genEnsureOopInRegNotForwarded:scratchReg:updatingSlot:in: */
static sqInt NoDbgRegParms
genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(sqInt reg, sqInt scratch, sqInt index, sqInt objReg)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *imm;
    AbstractInstruction *loop;
    AbstractInstruction *ok;
    sqInt quickConstant;


	/* Open-code
	   self genEnsureOopInRegNotForwarded: reg
	   scratchReg: scratch
	   updatingMw: index * objectMemory wordSize + objectMemory baseHeaderSize
	   r: objReg.
	   to avoid calling the store check unless the receiver is forwarded. */
	assert((reg != scratch)
	 && (objReg != scratch));
	/* begin Label */
	loop = genoperandoperand(Label, (labelCounter += 1), bytecodePC);

	/* notionally
	   self genGetClassIndexOfNonImm: reg into: scratch.
	   cogit CmpCq: objectMemory isForwardedObjectClassIndexPun R: TempReg.
	   but the following is an instruction shorter: */
	imm = genJumpImmediate(reg);
	/* begin MoveMw:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, reg, scratch);
	/* begin AndCq:R: */
	quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, scratch);
	/* begin JumpNonZero: */
	ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, reg, reg);
	/* begin MoveR:Mw:r: */
	anInstruction2 = genoperandoperandoperand(MoveRMwr, reg, (index * BytesPerWord) + BaseHeaderSize, objReg);
	assert((reg == Arg0Reg)
	 && ((scratch == TempReg)
	 && (objReg == ReceiverResultReg)));
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceStoreCheckContextReceiverTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)loop));
	jmpTarget(ok, jmpTarget(imm, gLabel()));
	return 0;
}


/*	Do the store check. Answer the argument for the benefit of the code
	generator; ReceiverResultReg may be caller-saved and hence smashed by this
	call. Answering
	it allows the code generator to reload ReceiverResultReg cheaply.
	In Spur the only thing we leave to the run-time is adding the receiver to
	the remembered set and setting its isRemembered bit. */

	/* CogObjectRepresentationForSpur>>#generateObjectRepresentationTrampolines */
static void
generateObjectRepresentationTrampolines(void)
{
	
#  if IMMUTABILITY

	/* c.f. genImmutableCheck:slotIndex:sourceReg:scratchReg:popBoolean:needRestoreRcvr: */
	ceCannotAssignToWithIndexTrampoline = genTrampolineForcalledargargarg(ceCannotAssignTowithIndexvalueToAssign, "ceCannotAssignToWithIndexTrampoline", ReceiverResultReg, TempReg, ClassReg);

#  endif /* IMMUTABILITY */

	ceStoreCheckTrampoline = genTrampolineForcalledargregsToSaveresult(remember, "ceStoreCheckTrampoline", ReceiverResultReg, (((callerSavedRegMask()) | (1LL << ReceiverResultReg)) - (1LL << ReceiverResultReg)), returnRegForStoreCheck());
	ceStoreCheckContextReceiverTrampoline = genStoreCheckContextReceiverTrampoline();
	ceScheduleScavengeTrampoline = genTrampolineForcalledregsToSave(ceScheduleScavenge, "ceScheduleScavengeTrampoline", callerSavedRegMask());
	ceSmallActiveContextInMethodTrampoline = genActiveContextTrampolineLargeinBlockcalled(0, 0, "ceSmallMethodContext");
	ceSmallActiveContextInBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(0, 1, "ceSmallBlockContext");
	ceLargeActiveContextInMethodTrampoline = genActiveContextTrampolineLargeinBlockcalled(1, 0, "ceLargeMethodContext");
	ceLargeActiveContextInBlockTrampoline = genActiveContextTrampolineLargeinBlockcalled(1, 1, "ceLargeBlockContext");
}


/*	Create a trampoline to answer the active context that will
	answer it if a frame is already married, and create it otherwise.
	Assume numArgs is in SendNumArgsReg and ClassReg is free. */

	/* CogObjectRepresentationForSpur>>#genGetActiveContextLarge:inBlock: */
static sqInt NoDbgRegParms
genGetActiveContextLargeinBlock(sqInt isLarge, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction14;
    AbstractInstruction *anInstruction15;
    AbstractInstruction *anInstruction16;
    AbstractInstruction *anInstruction17;
    AbstractInstruction *anInstruction18;
    AbstractInstruction *anInstruction19;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction20;
    AbstractInstruction *anInstruction21;
    AbstractInstruction *anInstruction22;
    AbstractInstruction *anInstruction23;
    AbstractInstruction *anInstruction24;
    AbstractInstruction *anInstruction25;
    AbstractInstruction *anInstruction26;
    AbstractInstruction *anInstruction27;
    AbstractInstruction *anInstruction28;
    AbstractInstruction *anInstruction29;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction30;
    AbstractInstruction *anInstruction31;
    AbstractInstruction *anInstruction32;
    AbstractInstruction *anInstruction33;
    AbstractInstruction *anInstruction34;
    AbstractInstruction *anInstruction35;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt constant;
    AbstractInstruction *continuation;
    AbstractInstruction *exit;
    usqLong header;
    AbstractInstruction *jumpNeedScavenge;
    AbstractInstruction *jumpSingle;
    AbstractInstruction *loopHead;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt slotSize;


	/* load the flag; stash it in both TempReg & ClassReg; do the compare (a prime candidated for use of AndCq:R:R:) */
	/* begin MoveMw:r:R: */
	anInstruction6 = genoperandoperandoperand(MoveMwrR, FoxMethod, FPReg, ClassReg);
	gAndCqRR(MFMethodFlagHasContextFlag, ClassReg, TempReg);
	/* begin JumpZero: */
	jumpSingle = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	anInstruction7 = genoperandoperandoperand(MoveMwrR, FoxThisContext, FPReg, ReceiverResultReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpSingle, gLabel());
	/* begin OrCq:R: */
	anInstruction8 = genoperandoperand(OrCqR, MFMethodFlagHasContextFlag, ClassReg);
	/* begin MoveR:Mw:r: */
	anInstruction9 = genoperandoperandoperand(MoveRMwr, ClassReg, FoxMethod, FPReg);
	if (isInBlock) {
		/* begin SubCq:R: */
		anInstruction = genoperandoperand(SubCqR, 3, ClassReg);
		/* begin MoveM16:r:R: */
		anInstruction1 = genoperandoperandoperand(MoveM16rR, 0, ClassReg, TempReg);
		/* begin SubR:R: */
		genoperandoperand(SubRR, TempReg, ClassReg);
	}
	else {
		/* begin SubCq:R: */
		anInstruction2 = genoperandoperand(SubCqR, 1, ClassReg);
	}
	slotSize = (isLarge
		? LargeContextSlots
		: SmallContextSlots);
	header = headerForSlotsformatclassIndex(slotSize, indexablePointersFormat(), ClassMethodContextCompactIndex);
	flag("endianness");
	/* begin MoveAw:R: */
	address = freeStartAddress();
	/* begin gen:literal:operand: */
	anInstruction10 = genoperandoperand(MoveAwR, address, ReceiverResultReg);
	/* begin genStoreHeader:intoNewInstance:using: */
	anInstruction11 = genoperandoperand(MoveCqR, header, TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction12 = genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	/* begin AddCq:R: */
	quickConstant1 = smallObjectBytesForSlots(slotSize);
	/* begin gen:quickConstant:operand: */
	anInstruction13 = genoperandoperand(AddCqR, quickConstant1, TempReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	/* begin gen:operand:literal: */
	anInstruction14 = genoperandoperand(MoveRAw, TempReg, address1);
	/* begin CmpCq:R: */
	quickConstant2 = getScavengeThreshold();
	/* begin gen:quickConstant:operand: */
	anInstruction15 = genoperandoperand(CmpCqR, quickConstant2, TempReg);
	/* begin JumpAboveOrEqual: */
	jumpNeedScavenge = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	continuation = genoperandoperand(MoveRR, FPReg, TempReg);
	genSetSmallIntegerTagsIn(TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction16 = genoperandoperandoperand(MoveRMwr, TempReg, BaseHeaderSize + (SenderIndex * BytesPerOop), ReceiverResultReg);
	/* begin MoveMw:r:R: */
	anInstruction17 = genoperandoperandoperand(MoveMwrR, FoxSavedFP, FPReg, TempReg);
	genSetSmallIntegerTagsIn(TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction18 = genoperandoperandoperand(MoveRMwr, TempReg, BaseHeaderSize + (InstructionPointerIndex * BytesPerOop), ReceiverResultReg);
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodObject);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction19 = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction20 = genoperandoperandoperand(MoveRMwr, TempReg, BaseHeaderSize + (MethodIndex * BytesPerWord), ReceiverResultReg);
	/* begin MoveR:Mw:r: */
	anInstruction21 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, FoxThisContext, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, FPReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SPReg, TempReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant3 = log2BytesPerWord();
	genoperandoperand(LogicalShiftRightCqR, quickConstant3, TempReg);
	/* begin SubCq:R: */
	quickConstant4 = 4;
	/* begin gen:quickConstant:operand: */
	anInstruction22 = genoperandoperand(SubCqR, quickConstant4, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, SendNumArgsReg, TempReg);
	genConvertIntegerToSmallIntegerInReg(TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction23 = genoperandoperandoperand(MoveRMwr, TempReg, BaseHeaderSize + (StackPointerIndex * BytesPerOop), ReceiverResultReg);
	if (isInBlock) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, SendNumArgsReg, TempReg);
		/* begin AddCq:R: */
		anInstruction3 = genoperandoperand(AddCqR, 2, TempReg);
		/* begin MoveXwr:R:R: */
		genoperandoperandoperand(MoveXwrRR, TempReg, FPReg, TempReg);
	}
	else {
		/* begin genMoveConstant:R: */
		constant = nilObject();
		if (shouldAnnotateObjectReference(constant)) {
			annotateobjRef(gMoveCwR(constant, TempReg), constant);
		}
		else {
			/* begin MoveCq:R: */
			anInstruction35 = genoperandoperand(MoveCqR, constant, TempReg);
		}
	}
	/* begin MoveR:Mw:r: */
	anInstruction24 = genoperandoperandoperand(MoveRMwr, TempReg, BaseHeaderSize + (ClosureIndex * BytesPerOop), ReceiverResultReg);
	/* begin MoveMw:r:R: */
	anInstruction25 = genoperandoperandoperand(MoveMwrR, FoxMFReceiver, FPReg, TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction26 = genoperandoperandoperand(MoveRMwr, TempReg, BaseHeaderSize + (ReceiverIndex * BytesPerOop), ReceiverResultReg);
	/* begin MoveCq:R: */
	anInstruction27 = genoperandoperand(MoveCqR, 1, ClassReg);
	/* begin CmpR:R: */
	loopHead = genoperandoperand(CmpRR, SendNumArgsReg, ClassReg);
	/* begin JumpGreater: */
	exit = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, ClassReg, TempReg);
	/* begin AddCq:R: */
	anInstruction28 = genoperandoperand(AddCqR, 2, TempReg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, TempReg, FPReg, TempReg);
	/* begin AddCq:R: */
	anInstruction29 = genoperandoperand(AddCqR, ReceiverIndex + (BaseHeaderSize / BytesPerWord), ClassReg);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, ClassReg, ReceiverResultReg);
	/* begin SubCq:R: */
	anInstruction30 = genoperandoperand(SubCqR, (ReceiverIndex + (BaseHeaderSize / BytesPerWord)) - 1, ClassReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)loopHead));
	jmpTarget(exit, gLabel());
	/* begin MoveCq:R: */
	quickConstant = nilObject();
	/* begin gen:quickConstant:operand: */
	anInstruction4 = genoperandoperand(MoveCqR, quickConstant, TempReg);

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, FPReg, ClassReg);
	/* begin AddCq:R: */
	anInstruction31 = genoperandoperand(AddCqR, FoxMFReceiver, ClassReg);
	/* begin AddCq:R: */
	anInstruction32 = genoperandoperand(AddCqR, (ReceiverIndex + 1) + (BaseHeaderSize / BytesPerWord), SendNumArgsReg);
	/* begin SubCq:R: */
	anInstruction33 = genoperandoperand(SubCqR, BytesPerWord, ClassReg);
	loopHead = anInstruction33;
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, SPReg, ClassReg);
	/* begin JumpBelowOrEqual: */
	exit = genConditionalBranchoperand(JumpBelowOrEqual, ((sqInt)0));

	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, SendNumArgsReg, ReceiverResultReg);
	/* begin AddCq:R: */
	anInstruction34 = genoperandoperand(AddCqR, 1, SendNumArgsReg);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)loopHead));
	jmpTarget(exit, gLabel());
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNeedScavenge, gLabel());
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);

	/* begin Jump: */
	genoperand(Jump, ((sqInt)continuation));
	return 0;
}


/*	Get the active context into ReceiverResultReg, creating it if necessary. */

	/* CogObjectRepresentationForSpur>>#genGetActiveContextNumArgs:large:inBlock: */
static sqInt NoDbgRegParms
genGetActiveContextNumArgslargeinBlock(sqInt numArgs, sqInt isLargeContext, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt routine;

	routine = (isLargeContext
		? (isInBlock
				? ceLargeActiveContextInBlockTrampoline
				: ceLargeActiveContextInMethodTrampoline)
		: (isInBlock
				? ceSmallActiveContextInBlockTrampoline
				: ceSmallActiveContextInMethodTrampoline));
	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, numArgs, SendNumArgsReg);
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, routine);
	(abstractInstruction->annotation = IsRelativeCall);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genGetBits:ofFormatByteOf:into: */
static sqInt NoDbgRegParms
genGetBitsofFormatByteOfinto(sqInt mask, sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;

	flag("endianness");
	/* begin MoveMb:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMbrR, 3, sourceReg, destReg);
	/* begin AndCq:R: */
	anInstruction = genoperandoperand(AndCqR, mask, destReg);
	return 0;
}


/*	Fetch the instance's class index into destReg. */

	/* CogObjectRepresentationForSpur>>#genGetClassIndexOfNonImm:into: */
static sqInt NoDbgRegParms
genGetClassIndexOfNonImminto(sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, sourceReg, destReg);
	/* begin AndCq:R: */
	quickConstant = classIndexMask();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, destReg);
	return 0;
}


/*	Fetch the class object whose index is in instReg into destReg.
	It is non-obvious, but the Cogit assumes loading a class does not involve
	a runtime call, so do not call classAtIndex: */

	/* CogObjectRepresentationForSpur>>#genGetClassObjectOfClassIndex:into:scratchReg: */
static sqInt NoDbgRegParms
genGetClassObjectOfClassIndexintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	assert(instReg != destReg);
	assert(instReg != scratchReg);
	assert(destReg != scratchReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instReg, scratchReg);
	/* begin LogicalShiftRightCq:R: */
	quickConstant1 = classTableMajorIndexShift();
	genoperandoperand(LogicalShiftRightCqR, quickConstant1, scratchReg);
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, shiftForWord(), scratchReg);
	assert(!(shouldAnnotateObjectReference(classTableRootObj())));
	if (isWithinMwOffsetRange(backEnd(), (classTableRootObj()) + BaseHeaderSize)) {
		/* begin MoveMw:r:R: */
		offset = (classTableRootObj()) + BaseHeaderSize;
		/* begin gen:quickConstant:operand:operand: */
		anInstruction3 = genoperandoperandoperand(MoveMwrR, offset, scratchReg, destReg);
	}
	else {
		/* begin AddCq:R: */
		quickConstant = classTableRootObj();
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(AddCqR, quickConstant, scratchReg);
		/* begin MoveMw:r:R: */
		anInstruction4 = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, scratchReg, destReg);
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instReg, scratchReg);
	/* begin AndCq:R: */
	quickConstant2 = classTableMinorIndexMask();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant2, scratchReg);
	/* begin AddCq:R: */
	anInstruction2 = genoperandoperand(AddCqR, ((usqInt) BaseHeaderSize) >> (shiftForWord()), scratchReg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, scratchReg, destReg, destReg);
	return 0;
}


/*	Fetch the instance's class into destReg. If the instance is not the
	receiver and is forwarded, follow forwarding. */

	/* CogObjectRepresentationForSpur>>#genGetClassObjectOf:into:scratchReg:instRegIsReceiver: */
static sqInt NoDbgRegParms
genGetClassObjectOfintoscratchReginstRegIsReceiver(sqInt instReg, sqInt destReg, sqInt scratchReg, sqInt instRegIsReceiver)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jumpIsImm;
    AbstractInstruction *jumpNotForwarded;
    AbstractInstruction *loop;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	if (instReg == destReg) {
		return BadRegisterSet;
	}
	/* begin MoveR:R: */
	loop = genoperandoperand(MoveRR, instReg, scratchReg);
	/* begin AndCq:R: */
	quickConstant1 = tagMask();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant1, scratchReg);
	/* begin JumpNonZero: */
	jumpIsImm = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	flag("endianness");
	/* begin MoveMw:r:R: */
	anInstruction4 = genoperandoperandoperand(MoveMwrR, 0, instReg, scratchReg);
	/* begin AndCq:R: */
	quickConstant2 = classIndexMask();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(AndCqR, quickConstant2, scratchReg);
	if (!instRegIsReceiver) {

		/* if it is forwarded... */
		/* begin CmpCq:R: */
		quickConstant = isForwardedObjectClassIndexPun();
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(CmpCqR, quickConstant, scratchReg);
		/* begin JumpNonZero: */
		jumpNotForwarded = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveMw:r:R: */
		anInstruction3 = genoperandoperandoperand(MoveMwrR, BaseHeaderSize, instReg, instReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)loop));
		jmpTarget(jumpNotForwarded, gLabel());
	}
	jmpTarget(jumpIsImm, gMoveRR(scratchReg, destReg));
	/* begin PushR: */
	genoperand(PushR, instReg);
	genGetClassObjectOfClassIndexintoscratchReg(destReg, instReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instReg, destReg);
	/* begin PopR: */
	genoperand(PopR, instReg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genGetClassTagOf:into:scratchReg: */
static AbstractInstruction * NoDbgRegParms
genGetClassTagOfintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
	return genGetInlineCacheClassTagFromintoforEntry(instReg, destReg, 1);
}


/*	Fetch the instance's class index into destReg. */

	/* CogObjectRepresentationForSpur>>#genGetCompactClassIndexNonImmOf:into: */
static sqInt NoDbgRegParms
genGetCompactClassIndexNonImmOfinto(sqInt instReg, sqInt destReg)
{
	return genGetClassIndexOfNonImminto(instReg, destReg);
}

	/* CogObjectRepresentationForSpur>>#genGetDoubleValueOf:into: */
static sqInt NoDbgRegParms
genGetDoubleValueOfinto(sqInt srcReg, sqInt destFPReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveM64:r:Rd: */
	anInstruction = genoperandoperandoperand(MoveM64rRd, BaseHeaderSize, srcReg, destFPReg);
	return 0;
}


/*	Get the format field of the object in srcReg into destReg.
	srcReg may equal destReg. */

	/* CogObjectRepresentationForSpur>>#genGetFormatOf:into: */
static sqInt NoDbgRegParms
genGetFormatOfinto(sqInt srcReg, sqInt destReg)
{
	return genGetBitsofFormatByteOfinto(formatMask(), srcReg, destReg);
}


/*	Get the format of the object in sourceReg into destReg. If
	scratchRegOrNone is not NoReg, load at least the least significant 32-bits
	(64-bits in 64-bits) of the
	header word, which contains the format, into scratchRegOrNone. */

	/* CogObjectRepresentationForSpur>>#genGetFormatOf:into:leastSignificantHalfOfBaseHeaderIntoScratch: */
static sqInt NoDbgRegParms
genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(sqInt sourceReg, sqInt destReg, sqInt scratchRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt quickConstant;
    sqInt quickConstant1;

	if (scratchRegOrNone == NoReg) {
		flag("endianness");
		/* begin MoveMb:r:R: */
		anInstruction1 = genoperandoperandoperand(MoveMbrR, 3, sourceReg, destReg);
	}
	else {
		/* begin MoveMw:r:R: */
		anInstruction2 = genoperandoperandoperand(MoveMwrR, 0, sourceReg, destReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, destReg, scratchRegOrNone);
		/* begin LogicalShiftRightCq:R: */
		quickConstant = formatShift();
		genoperandoperand(LogicalShiftRightCqR, quickConstant, destReg);
	}
	/* begin AndCq:R: */
	quickConstant1 = formatMask();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant1, destReg);
	return 0;
}


/*	Get the size in word-sized slots of the object in srcReg into destReg.
	srcReg may equal destReg. */

	/* CogObjectRepresentationForSpur>>#genGetNumSlotsOf:into: */
static sqInt NoDbgRegParms
genGetNumSlotsOfinto(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmp;
    sqInt quickConstant;

	assert(srcReg != destReg);
	genGetRawSlotSizeOfNonImminto(srcReg, destReg);
	/* begin CmpCq:R: */
	quickConstant = numSlotsMask();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, destReg);
	/* begin JumpLess: */
	jmp = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genGetOverflowSlotsOfinto(srcReg, destReg);
	jmpTarget(jmp, gLabel());
	return 0;
}


/*	The raw numSlots field is the most significant byte of the 64-bit header
	word. MoveMbrR zero-extends. */

	/* CogObjectRepresentationForSpur>>#genGetRawSlotSizeOfNonImm:into: */
static sqInt NoDbgRegParms
genGetRawSlotSizeOfNonImminto(sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, destReg);

	/* begin MoveMb:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMbrR, 7, sourceReg, destReg);
	return 0;
}


/*	baseHeader holds at least the least significant 32 bits of the object */

	/* CogObjectRepresentationForSpur>>#genJumpBaseHeaderImmutable: */
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms
genJumpBaseHeaderImmutable(sqInt baseHeaderReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin TstCq:R: */
	quickConstant = immutableBitMask();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, baseHeaderReg);
	/* begin JumpNonZero: */
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}
#endif /* IMMUTABILITY */


/*	baseHeader holds at least the least significant 32 bits of the object */

	/* CogObjectRepresentationForSpur>>#genJumpBaseHeaderMutable: */
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms
genJumpBaseHeaderMutable(sqInt baseHeaderReg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin TstCq:R: */
	quickConstant = immutableBitMask();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, baseHeaderReg);
	/* begin JumpZero: */
	return genConditionalBranchoperand(JumpZero, ((sqInt)0));
}
#endif /* IMMUTABILITY */

	/* CogObjectRepresentationForSpur>>#genJumpImmediate: */
static AbstractInstruction * NoDbgRegParms
genJumpImmediate(sqInt aRegister)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin TstCq:R: */
	quickConstant = tagMask();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(TstCqR, quickConstant, aRegister);
	/* begin JumpNonZero: */
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}

	/* CogObjectRepresentationForSpur>>#genJumpMutable:scratchReg: */
#if IMMUTABILITY
static AbstractInstruction * NoDbgRegParms
genJumpMutablescratchReg(sqInt sourceReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, sourceReg, scratchReg);
	return genJumpBaseHeaderMutable(scratchReg);
}
#endif /* IMMUTABILITY */


/*	Generate a call to code that allocates a new Array of size.
	The Array should be initialized with nils iff initialized is true.
	The size arg is passed in SendNumArgsReg, the result
	must come back in ReceiverResultReg. */

	/* CogObjectRepresentationForSpur>>#genNewArrayOfSize:initialized: */
static sqInt NoDbgRegParms
genNewArrayOfSizeinitialized(sqInt size, sqInt initialized)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    sqInt constant;
    usqLong header;
    sqInt i;
    sqInt offset;
    sqInt quickConstant;
    AbstractInstruction *skip;

	assert(size < (numSlotsMask()));
	header = headerForSlotsformatclassIndex(size, arrayFormat(), ClassArrayCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	/* begin gen:literal:operand: */
	anInstruction3 = genoperandoperand(MoveAwR, address, ReceiverResultReg);
	/* begin genStoreHeader:intoNewInstance:using: */
	anInstruction4 = genoperandoperand(MoveCqR, header, TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction5 = genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	if (initialized
	 && (size > 0)) {
		/* begin genMoveConstant:R: */
		constant = nilObject();
		if (shouldAnnotateObjectReference(constant)) {
			annotateobjRef(gMoveCwR(constant, TempReg), constant);
		}
		else {
			/* begin MoveCq:R: */
			anInstruction1 = genoperandoperand(MoveCqR, constant, TempReg);
		}
		for (i = 0; i < size; i += 1) {
			/* begin MoveR:Mw:r: */
			anInstruction2 = genoperandoperandoperand(MoveRMwr, TempReg, (i * BytesPerWord) + BaseHeaderSize, ReceiverResultReg);
		}
	}
	/* begin LoadEffectiveAddressMw:r:R: */
	offset = smallObjectBytesForSlots(size);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction6 = genoperandoperandoperand(LoadEffectiveAddressMwrR, offset, ReceiverResultReg, TempReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	/* begin gen:operand:literal: */
	anInstruction7 = genoperandoperand(MoveRAw, TempReg, address1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpBelow: */
	skip = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(skip, gLabel());
	return 0;
}


/*	Create a closure with the given startpc, numArgs and numCopied
	within a context with ctxtNumArgs, large if isLargeCtxt that is in a
	block if isInBlock. Do /not/ initialize the copied values. */

	/* CogObjectRepresentationForSpur>>#genNoPopCreateClosureAt:numArgs:numCopied:contextNumArgs:large:inBlock: */
static sqInt NoDbgRegParms
genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    usqInt byteSize;
    usqLong header;
    sqInt numSlots;
    sqInt quickConstant;
    AbstractInstruction *skip;


	/* First get thisContext into ReceiverResultRega and thence in ClassReg. */
	genGetActiveContextNumArgslargeinBlock(ctxtNumArgs, isLargeCtxt, isInBlock);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	numSlots = ClosureFirstCopiedValueIndex + numCopied;
	byteSize = smallObjectBytesForSlots(numSlots);
	header = headerForSlotsformatclassIndex(numSlots, indexablePointersFormat(), ClassBlockClosureCompactIndex);
	/* begin MoveAw:R: */
	address = freeStartAddress();
	/* begin gen:literal:operand: */
	anInstruction1 = genoperandoperand(MoveAwR, address, ReceiverResultReg);
	/* begin genStoreHeader:intoNewInstance:using: */
	anInstruction2 = genoperandoperand(MoveCqR, header, TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction3 = genoperandoperandoperand(MoveRMwr, TempReg, 0, ReceiverResultReg);
	/* begin LoadEffectiveAddressMw:r:R: */
	anInstruction4 = genoperandoperandoperand(LoadEffectiveAddressMwrR, byteSize, ReceiverResultReg, TempReg);
	/* begin MoveR:Aw: */
	address1 = freeStartAddress();
	/* begin gen:operand:literal: */
	anInstruction5 = genoperandoperand(MoveRAw, TempReg, address1);
	/* begin CmpCq:R: */
	quickConstant = getScavengeThreshold();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpBelow: */
	skip = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceScheduleScavengeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(skip, gLabel());
	/* begin MoveR:Mw:r: */
	anInstruction6 = genoperandoperandoperand(MoveRMwr, ClassReg, (ClosureOuterContextIndex * BytesPerOop) + BaseHeaderSize, ReceiverResultReg);
	/* begin MoveCq:R: */
	anInstruction7 = genoperandoperand(MoveCqR, ((bcpc << 3) | 1), TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction8 = genoperandoperandoperand(MoveRMwr, TempReg, (ClosureStartPCIndex * BytesPerOop) + BaseHeaderSize, ReceiverResultReg);
	/* begin MoveCq:R: */
	anInstruction9 = genoperandoperand(MoveCqR, ((numArgs << 3) | 1), TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction10 = genoperandoperandoperand(MoveRMwr, TempReg, (ClosureNumArgsIndex * BytesPerOop) + BaseHeaderSize, ReceiverResultReg);
	return 0;
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveAsCharacter */
static sqInt
genPrimitiveAsCharacter(void)
{
    AbstractInstruction *jumpNotInt;
    AbstractInstruction *jumpOutOfRange;
    sqInt reg;

	if (methodOrBlockNumArgs == 0) {
		reg = ReceiverResultReg;
	}
	else {
		if (methodOrBlockNumArgs > 1) {
			return UnimplementedPrimitive;
		}
		reg = Arg0Reg;
		/* begin genLoadArgAtDepth:into: */
		assert(0 < (numRegArgs()));
		/* begin genJumpNotSmallInteger:scratchReg: */
		jumpNotInt = genJumpNotSmallInteger(reg);
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, reg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	jumpOutOfRange = jumpNotCharacterUnsignedValueInRegister(TempReg);
	genConvertSmallIntegerToCharacterInReg(reg);
	if (reg != ReceiverResultReg) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, reg, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpOutOfRange, gLabel());
	if (reg != ReceiverResultReg) {
		jmpTarget(jumpNotInt, getJmpTarget(jumpOutOfRange));
	}
	return CompletePrimitive;
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveIdenticalOrNotIf: */
static sqInt NoDbgRegParms
genPrimitiveIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *anInstruction;
    sqInt constant;
    AbstractInstruction *jumpCmp;
    AbstractInstruction *jumpImmediate;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genEnsureObjInRegNotForwardedscratchReg(Arg0Reg, TempReg);
	jmpTarget(jumpImmediate, gCmpRR(Arg0Reg, ReceiverResultReg));
	if (orNot) {
		/* begin JumpZero: */
		jumpCmp = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	}
	else {
		/* begin JumpNonZero: */
		jumpCmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	}
	/* begin genMoveTrueR: */
	constant = trueObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, ReceiverResultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
	}
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpCmp, genMoveFalseR(ReceiverResultReg));
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	return UnfailingPrimitive;
}

	/* CogObjectRepresentationForSpur>>#genPrimitiveObjectAt */
static sqInt
genPrimitiveObjectAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt headerReg;
    AbstractInstruction *jumpBadIndex;
    AbstractInstruction *jumpBounds;
    AbstractInstruction *jumpNotHeaderIndex;
    sqInt quickConstant;

	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* begin genJumpNotSmallInteger:scratchReg: */
	jumpBadIndex = genJumpNotSmallInteger(Arg0Reg);
	genGetMethodHeaderOfintoscratch(ReceiverResultReg, (headerReg = Arg1Reg), TempReg);
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, (((sqInt)1 << 3) | 1), Arg0Reg);
	/* begin JumpNonZero: */
	jumpNotHeaderIndex = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, headerReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpNotHeaderIndex, gAndCqR((((alternateHeaderNumLiteralsMask()) << 3) | 1), headerReg));
	/* begin SubCq:R: */
	quickConstant = ((((sqInt)1 << 3) | 1)) - (smallIntegerTag());
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(SubCqR, quickConstant, Arg0Reg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, headerReg, Arg0Reg);
	/* begin JumpAbove: */
	jumpBounds = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin AddCq:R: */
	anInstruction1 = genoperandoperand(AddCqR, ((usqInt) BaseHeaderSize) >> (shiftForWord()), Arg0Reg);
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg0Reg, ReceiverResultReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpBounds, gAddCqR(((((sqInt)1 << 3) | 1)) - (smallIntegerTag()), Arg0Reg));
	jmpTarget(jumpBadIndex, gLabel());
	return CompletePrimitive;
}


/*	c.f. StackInterpreter>>stSizeOf: lengthOf:baseHeader:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationForSpur>>#genPrimitiveSize */
static sqInt
genPrimitiveSize(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt jic;
    sqInt jnx;
    AbstractInstruction *jump32BitLongsDone;
    AbstractInstruction *jump64BitLongsDone;
    AbstractInstruction *jumpArrayDone;
    AbstractInstruction * jumpBytesDone;
    AbstractInstruction *jumpHasFixedFields;
    AbstractInstruction *jumpImm;
    AbstractInstruction *jumpIs32BitLongs;
    AbstractInstruction *jumpIsBytes;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsContext1;
    AbstractInstruction *jumpIsShorts;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpNotIndexable1;
    AbstractInstruction * jumpShortsDone;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;

	jumpImm = genJumpImmediate(ReceiverResultReg);
	/* begin genGetSizeOf:into:formatReg:scratchReg:abortJumpsInto: */
	genGetFormatOfintoleastSignificantHalfOfBaseHeaderIntoScratch(ReceiverResultReg, SendNumArgsReg, TempReg);
	genGetNumSlotsOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	quickConstant = firstByteFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, SendNumArgsReg);
	/* begin JumpGreaterOrEqual: */
	jumpIsBytes = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant1 = arrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant1, SendNumArgsReg);
	/* begin JumpZero: */
	jumpArrayDone = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin JumpLess: */
	jumpNotIndexable1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant2 = weakArrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant2, SendNumArgsReg);
	/* begin JumpLessOrEqual: */
	jumpHasFixedFields = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant3 = firstShortFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(CmpCqR, quickConstant3, SendNumArgsReg);
	/* begin JumpGreaterOrEqual: */
	jumpIsShorts = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstLongFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction4 = genoperandoperand(CmpCqR, quickConstant4, SendNumArgsReg);
	/* begin JumpGreaterOrEqual: */
	jumpIs32BitLongs = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant5 = sixtyFourBitIndexableFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction5 = genoperandoperand(CmpCqR, quickConstant5, SendNumArgsReg);
	/* begin JumpZero: */
	jump64BitLongsDone = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	jmpTarget(jumpNotIndexable1, gLabel());
	/* begin Jump: */
	jumpNotIndexable1 = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsBytes, gLogicalShiftLeftCqR(shiftForWord(), ClassReg));
	/* begin AndCq:R: */
	anInstruction6 = genoperandoperand(AndCqR, BytesPerWord - 1, SendNumArgsReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	/* begin Jump: */
	jumpBytesDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsShorts, gLogicalShiftLeftCqR((shiftForWord()) - 1, ClassReg));
	/* begin AndCq:R: */
	anInstruction7 = genoperandoperand(AndCqR, (((usqInt) BytesPerWord) >> 1) - 1, SendNumArgsReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	/* begin Jump: */
	jumpShortsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIs32BitLongs, gLogicalShiftLeftCqR((shiftForWord()) - 2, ClassReg));
	/* begin AndCq:R: */
	anInstruction8 = genoperandoperand(AndCqR, (((usqInt) BytesPerWord) >> 2) - 1, SendNumArgsReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	/* begin Jump: */
	jump32BitLongsDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpHasFixedFields, gAndCqR(classIndexMask(), TempReg));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, SendNumArgsReg);
	/* begin CmpCq:R: */
	anInstruction9 = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	/* begin JumpZero: */
	jumpIsContext1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetClassObjectOfClassIndexintoscratchReg(SendNumArgsReg, Scratch0Reg, TempReg);
	genLoadSlotsourceRegdestReg(InstanceSpecificationIndex, Scratch0Reg, SendNumArgsReg);
	genConvertSmallIntegerToIntegerInReg(SendNumArgsReg);
	/* begin AndCq:R: */
	quickConstant6 = fixedFieldsOfClassFormatMask();
	/* begin gen:quickConstant:operand: */
	anInstruction10 = genoperandoperand(AndCqR, quickConstant6, SendNumArgsReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jmpTarget(jumpArrayDone, jmpTarget(jump64BitLongsDone, jmpTarget(jump32BitLongsDone, jmpTarget(jumpShortsDone, jmpTarget(jumpBytesDone, gLabel())))));
	jumpNotIndexable = jumpNotIndexable1;
	jumpIsContext = jumpIsContext1;

	genConvertIntegerToSmallIntegerInReg(ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	assert(methodOrBlockNumArgs <= (numRegArgs()));
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpImm, jmpTarget(jumpNotIndexable, jmpTarget(jumpIsContext, gLabel())));
	return CompletePrimitive;
}

	/* CogObjectRepresentationForSpur>>#genSetSmallIntegerTagsIn: */
static sqInt NoDbgRegParms
genSetSmallIntegerTagsIn(sqInt scratchReg)
{
    AbstractInstruction *anInstruction;

	/* begin OrCq:R: */
	anInstruction = genoperandoperand(OrCqR, 1, scratchReg);
	return 0;
}


/*	Create a trampoline to store-check the update of the receiver in a
	closure's outerContext in compileBlockFrameBuild:. */

	/* CogObjectRepresentationForSpur>>#genStoreCheckContextReceiverTrampoline */
static sqInt
genStoreCheckContextReceiverTrampoline(void)
{
    sqInt startAddress;

	startAddress = methodZoneBase();
	zeroOpcodeIndex();
	genStoreCheckReceiverRegvalueRegscratchReginFrame(ReceiverResultReg, Arg0Reg, TempReg, 0);
	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceStoreCheckContextReceiver", startAddress);
	recordRunTimeObjectReferences();
	return startAddress;
}


/*	Generate the code for a store check of valueReg into destReg. */

	/* CogObjectRepresentationForSpur>>#genStoreCheckReceiverReg:valueReg:scratchReg:inFrame: */
static sqInt NoDbgRegParms
genStoreCheckReceiverRegvalueRegscratchReginFrame(sqInt destReg, sqInt valueReg, sqInt scratchReg, sqInt inFrame)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *jmpAlreadyRemembered;
    AbstractInstruction *jmpDestYoung;
    AbstractInstruction *jmpImmediate;
    AbstractInstruction *jmpSourceOld;
    sqInt mask;
    sqInt rememberedBitByteOffset;
    sqInt wordConstant;


	/* Is value stored an immediate?  If so we're done */

	/* Get the old/new boundary in scratchReg */
	jmpImmediate = genJumpImmediate(valueReg);
	/* begin MoveCw:R: */
	wordConstant = storeCheckBoundary();
	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveCwR, wordConstant, scratchReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, scratchReg, destReg);
	/* begin JumpBelow: */
	jmpDestYoung = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, scratchReg, valueReg);
	/* begin JumpAboveOrEqual: */
	jmpSourceOld = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	rememberedBitByteOffset = (rememberedBitShift()) / 8;
	mask = 1LL << ((rememberedBitShift()) % 8);
	/* begin MoveMb:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMbrR, rememberedBitByteOffset, destReg, scratchReg);
	/* begin AndCq:R: */
	anInstruction2 = genoperandoperand(AndCqR, mask, scratchReg);
	/* begin JumpNonZero: */
	jmpAlreadyRemembered = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	assert(destReg == ReceiverResultReg);
	/* begin evaluateTrampolineCallBlock:protectLinkRegIfNot: */
	if (inFrame) {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceStoreCheckTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);

	}
	else {
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceStoreCheckTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);


	}
	jmpTarget(jmpImmediate, jmpTarget(jmpDestYoung, jmpTarget(jmpSourceOld, jmpTarget(jmpAlreadyRemembered, gLabel()))));
	return 0;
}


/*	do the store */

	/* CogObjectRepresentationForSpur>>#genStoreSourceReg:slotIndex:destReg:scratchReg:inFrame:needsStoreCheck: */
static sqInt NoDbgRegParms
genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt inFrame, sqInt needsStoreCheck)
{
    AbstractInstruction *anInstruction;

	/* begin MoveR:Mw:r: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, (index * BytesPerWord) + BaseHeaderSize, destReg);
	if (needsStoreCheck) {
		return genStoreCheckReceiverRegvalueRegscratchReginFrame(destReg, sourceReg, scratchReg, inFrame);
	}
	return 0;
}


/*	This method is used for unchecked stores in objects after their creation
	(typically, inlined creation of Array, closures and some temp vectors). 
	Currently there is no need to do the immutability check here
 */

	/* CogObjectRepresentationForSpur>>#genStoreSourceReg:slotIndex:intoNewObjectInDestReg: */
static sqInt NoDbgRegParms
genStoreSourceRegslotIndexintoNewObjectInDestReg(sqInt sourceReg, sqInt index, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveR:Mw:r: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, (index * BytesPerWord) + BaseHeaderSize, destReg);
	return 0;
}


/*	Make sure SendNumArgsReg and ClassReg are available in addition to
	ReceiverResultReg and TempReg in
	genGetActiveContextNumArgs:large:inBlock:. 
 */

	/* CogObjectRepresentationForSpur>>#getActiveContextAllocatesInMachineCode */
static sqInt
getActiveContextAllocatesInMachineCode(void)
{
	return 1;
}


/*	Since all cache tags in Spur are class indices none of
	them are young or have to be updated in a scavenge. */

	/* CogObjectRepresentationForSpur>>#inlineCacheTagIsYoung: */
static sqInt NoDbgRegParms
inlineCacheTagIsYoung(sqInt cacheTag)
{
	return 0;
}

	/* CogObjectRepresentationForSpur>>#jumpNotCharacterUnsignedValueInRegister: */
static AbstractInstruction * NoDbgRegParms
jumpNotCharacterUnsignedValueInRegister(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;

	/* begin CmpCq:R: */
	quickConstant = (1LL << (numCharacterBits())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, reg);
	/* begin JumpAbove: */
	return genConditionalBranchoperand(JumpAbove, ((sqInt)0));
}


/*	Mark and trace a literal in a machine code instruction preceding address
	in cogMethodOrNil.
	Answer if code was modified. */

	/* CogObjectRepresentationForSpur>>#markAndTraceLiteral:in:atpc: */
static sqInt NoDbgRegParms
markAndTraceLiteralinatpc(sqInt literal, CogMethod *cogMethodOrNil, usqInt address)
{
    sqInt objOop;

	if (!(couldBeObject(literal))) {
		return 0;
	}
	assert(addressCouldBeObj(literal));
	if (!(isForwarded(literal))) {
		markAndTrace(literal);
		return 0;
	}
	objOop = followForwarded(literal);
	storeLiteralbeforeFollowingAddress(backEnd(), objOop, address);
	markAndTraceUpdatedLiteralin(objOop, cogMethodOrNil);
	return 1;
}


/*	Mark and trace a literal in a sqInt variable of cogMethod. */

	/* CogObjectRepresentationForSpur>>#markAndTraceLiteral:in:at: */
static void NoDbgRegParms
markAndTraceLiteralinat(sqInt literal, CogMethod *cogMethod, sqInt *address)
{
    sqInt objOop;

	if (!(couldBeObject(literal))) {
		return;
	}
	assert(addressCouldBeObj(literal));
	if (!(isForwarded(literal))) {
		markAndTrace(literal);
		return;
	}
	objOop = followForwarded(literal);
	address[0] = objOop;
	markAndTraceUpdatedLiteralin(objOop, cogMethod);
}


/*	Common code to mark a literal in cogMethod and add
	the cogMethod to youngReferrers if the literal is young. */

	/* CogObjectRepresentationForSpur>>#markAndTraceUpdatedLiteral:in: */
static void NoDbgRegParms
markAndTraceUpdatedLiteralin(sqInt objOop, CogMethod *cogMethodOrNil)
{
	if (isNonImmediate(objOop)) {
		if ((cogMethodOrNil != null)
		 && (isYoungObject(objOop))) {
			ensureInYoungReferrers(cogMethodOrNil);
		}
		markAndTrace(objOop);
	}
}


/*	If primIndex has an accessorDepth, check for primitive failure and call
	ceCheckForAndFollowForwardedPrimitiveState if so If ceCheck.... answers
	true, retry the primitive. */

	/* CogObjectRepresentationForSpur>>#maybeCompileRetry:onPrimitiveFail: */
static sqInt NoDbgRegParms
maybeCompileRetryonPrimitiveFail(AbstractInstruction *retryInst, sqInt primIndex)
{
    sqInt address;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *jmp;

	if ((accessorDepthForPrimitiveIndex(primIndex)) < 0) {
		return 0;
	}
	/* begin MoveAw:R: */
	address = primFailCodeAddress();
	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveAwR, address, TempReg);
	/* begin CmpCq:R: */
	anInstruction1 = genoperandoperand(CmpCqR, 0, TempReg);
	/* begin JumpZero: */
	jmp = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	compileCallFornumArgsargargargargresultRegregsToSave(ceCheckForAndFollowForwardedPrimitiveState, 0, null, null, null, null, TempReg, 0);
	/* begin CmpCq:R: */
	anInstruction2 = genoperandoperand(CmpCqR, 0, TempReg);
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)retryInst));
	jmpTarget(jmp, gLabel());
	return 0;
}

	/* CogObjectRepresentationForSpur>>#numCharacterBits */
static sqInt
numCharacterBits(void)
{
	return 30;
}


/*	Define how many register arguments a StackToRegisterMappingCogit can
	and should use with the receiver. The value must be 0, 1 or 2. Note that a
	SimpleStackBasedCogit always has 0 register args (although the receiver is
	passed in a register). The Spur object representation is simple enough
	that implementing at:put: is straight-forward and hence 2 register args
	are worth
	while. The method must be inlined in CoInterpreter, and dead code
	eliminated so that the register-popping enilopmarts such as
	enterRegisterArgCogMethod:- at:receiver: do not have to be implemented in
	SimpleStackBasedCogit.  */

	/* CogObjectRepresentationForSpur>>#numRegArgs */
sqInt
numRegArgs(void)
{
	return 2;
}

	/* CogObjectRepresentationForSpur>>#remapObject: */
static sqInt NoDbgRegParms
remapObject(sqInt objOop)
{
	assert(addressCouldBeObj(objOop));
	return (shouldRemapObj(objOop)
		? remapObj(objOop)
		: objOop);
}

	/* CogObjectRepresentationForSpur>>#remapOop: */
static sqInt NoDbgRegParms
remapOop(sqInt objOop)
{
	return (shouldRemapOop(objOop)
		? remapObj(objOop)
		: objOop);
}


/*	Objects in newSpace or oldSpace except nil, true, false &
	classTableRootObj need to be annotated.
 */

	/* CogObjectRepresentationForSpur>>#shouldAnnotateObjectReference: */
static sqInt NoDbgRegParms
shouldAnnotateObjectReference(sqInt anOop)
{
	return (isNonImmediate(anOop))
	 && ((oopisGreaterThan(anOop, classTableRootObj()))
	 || (oopisLessThan(anOop, nilObject())));
}

	/* CogObjectRepresentationForSpur>>#slotOffsetOfInstVarIndex: */
static sqInt NoDbgRegParms
slotOffsetOfInstVarIndex(sqInt index)
{
	return (index * BytesPerWord) + BaseHeaderSize;
}

	/* CogSimStackEntry>>#ensureSpilledAt:from: */
static CogSimStackEntry * NoDbgRegParms
ensureSpilledAtfrom(CogSimStackEntry * self_in_ensureSpilledAtfrom, sqInt baseOffset, sqInt baseRegister)
{
    AbstractInstruction *anInstruction;
    sqInt baseReg;
    AbstractInstruction *inst;
    sqInt offset;
    sqInt reg;

	if ((self_in_ensureSpilledAtfrom->spilled)) {
		if (((self_in_ensureSpilledAtfrom->type)) == SSSpill) {
			assert((((self_in_ensureSpilledAtfrom->offset)) == baseOffset)
			 && (((self_in_ensureSpilledAtfrom->registerr)) == baseRegister));
			return self_in_ensureSpilledAtfrom;
		}
	}
	assert(((self_in_ensureSpilledAtfrom->type)) != SSSpill);
	traceSpill(self_in_ensureSpilledAtfrom);
	if (((self_in_ensureSpilledAtfrom->type)) == SSConstant) {
		inst = annotateobjRef(gPushCw((self_in_ensureSpilledAtfrom->constant)), (self_in_ensureSpilledAtfrom->constant));
	}
	else {
		if (((self_in_ensureSpilledAtfrom->type)) == SSBaseOffset) {
			/* begin MoveMw:r:R: */
			offset = (self_in_ensureSpilledAtfrom->offset);
			baseReg = (self_in_ensureSpilledAtfrom->registerr);
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, TempReg);
			/* begin PushR: */
			inst = genoperand(PushR, TempReg);
		}
		else {
			assert(((self_in_ensureSpilledAtfrom->type)) == SSRegister);
			/* begin PushR: */
			reg = (self_in_ensureSpilledAtfrom->registerr);
			inst = genoperand(PushR, reg);
		}
		(self_in_ensureSpilledAtfrom->type) = SSSpill;
		(self_in_ensureSpilledAtfrom->offset) = baseOffset;
		(self_in_ensureSpilledAtfrom->registerr) = baseRegister;
	}
	(self_in_ensureSpilledAtfrom->spilled) = 1;
	if ((self_in_ensureSpilledAtfrom->annotateUse)) {
		/* begin annotateBytecode: */
		(inst->annotation = HasBytecodePC);
		(self_in_ensureSpilledAtfrom->annotateUse) = 0;
	}
	return self_in_ensureSpilledAtfrom;
}


/*	Discard type information because of a control-flow merge. */

	/* CogSimStackEntry>>#mergeAt:from: */
static CogSimStackEntry * NoDbgRegParms
mergeAtfrom(CogSimStackEntry * self_in_mergeAtfrom, sqInt baseOffset, sqInt baseRegister)
{
	assert((self_in_mergeAtfrom->spilled));
	if (((self_in_mergeAtfrom->type)) == SSSpill) {
		assert((((self_in_mergeAtfrom->offset)) == baseOffset)
		 && (((self_in_mergeAtfrom->registerr)) == baseRegister));
	}
	else {
		(self_in_mergeAtfrom->type) = SSSpill;
		(self_in_mergeAtfrom->offset) = baseOffset;
		(self_in_mergeAtfrom->registerr) = baseRegister;
	}
	return self_in_mergeAtfrom;
}

	/* CogSimStackEntry>>#popToReg: */
static CogSimStackEntry * NoDbgRegParms
popToReg(CogSimStackEntry * self_in_popToReg, sqInt reg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt baseReg;
    sqInt constant;
    AbstractInstruction *inst;
    sqInt offset;
    sqInt reg1;

	if ((self_in_popToReg->spilled)) {
		/* begin PopR: */
		inst = genoperand(PopR, reg);
	}
	else {
		
		switch ((self_in_popToReg->type)) {
		case SSBaseOffset:
			/* begin MoveMw:r:R: */
			offset = (self_in_popToReg->offset);
			baseReg = (self_in_popToReg->registerr);
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, reg);
			inst = anInstruction;
			break;
		case SSConstant:
			/* begin genMoveConstant:R: */
			constant = (self_in_popToReg->constant);
			if (shouldAnnotateObjectReference(constant)) {
				inst = annotateobjRef(gMoveCwR(constant, reg), constant);
			}
			else {
				/* begin MoveCq:R: */
				anInstruction1 = genoperandoperand(MoveCqR, constant, reg);
				inst = anInstruction1;
			}
			break;
		case SSRegister:
			if (reg != ((self_in_popToReg->registerr))) {
				/* begin MoveR:R: */
				reg1 = (self_in_popToReg->registerr);
				inst = genoperandoperand(MoveRR, reg1, reg);
			}
			else {
				/* begin Label */
				inst = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	if ((self_in_popToReg->annotateUse)) {
		/* begin annotateBytecode: */
		(inst->annotation = HasBytecodePC);
		(self_in_popToReg->annotateUse) = 0;
	}
	return self_in_popToReg;
}


/*	Answer a bit mask for the receiver's register, if any. */

	/* CogSimStackEntry>>#registerMask */
static sqInt NoDbgRegParms
registerMask(CogSimStackEntry * self_in_registerMask)
{
    sqInt reg;

	return ((((self_in_registerMask->type)) == SSBaseOffset)
	 || (((self_in_registerMask->type)) == SSRegister)
		? (/* begin registerMaskFor: */
			(reg = (self_in_registerMask->registerr)),
			1LL << reg)
		: 0);
}

	/* CogSimStackEntry>>#registerOrNone */
static sqInt NoDbgRegParms
registerOrNone(CogSimStackEntry * self_in_registerOrNone)
{
	return (((self_in_registerOrNone->type)) == SSRegister
		? (self_in_registerOrNone->registerr)
		: NoReg);
}

	/* CogSimStackEntry>>#storeToReg: */
static CogSimStackEntry * NoDbgRegParms
storeToReg(CogSimStackEntry * self_in_storeToReg, sqInt reg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt baseReg;
    sqInt constant;
    AbstractInstruction *inst;
    sqInt offset;
    sqInt reg1;

	
	switch ((self_in_storeToReg->type)) {
	case SSBaseOffset:
	case SSSpill:
		/* begin MoveMw:r:R: */
		offset = (self_in_storeToReg->offset);
		baseReg = (self_in_storeToReg->registerr);
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, reg);
		inst = anInstruction;
		break;
	case SSConstant:
		/* begin genMoveConstant:R: */
		constant = (self_in_storeToReg->constant);
		if (shouldAnnotateObjectReference(constant)) {
			inst = annotateobjRef(gMoveCwR(constant, reg), constant);
		}
		else {
			/* begin MoveCq:R: */
			anInstruction1 = genoperandoperand(MoveCqR, constant, reg);
			inst = anInstruction1;
		}
		break;
	case SSRegister:
		if (reg != ((self_in_storeToReg->registerr))) {
			/* begin MoveR:R: */
			reg1 = (self_in_storeToReg->registerr);
			inst = genoperandoperand(MoveRR, reg1, reg);
		}
		else {
			/* begin Label */
			inst = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	if ((self_in_storeToReg->annotateUse)) {
		/* begin annotateBytecode: */
		(inst->annotation = HasBytecodePC);
		(self_in_storeToReg->annotateUse) = 0;
	}
	return self_in_storeToReg;
}


/*	See e.g. Figure 3.4 Register Usage in
	System V Application Binary Interface
	AMD64 Architecture Processor Supplement
	N.B. We are playing fast and loose here being processor-specific.
	Soon enough this needs to be OS-specific. */

	/* CogX64Compiler>>#callerSavedRegisterMask */
static sqInt NoDbgRegParms
callerSavedRegisterMask(AbstractInstruction * self_in_callerSavedRegisterMask)
{
	return ((((((((1LL << RAX) | (1LL << RCX)) | (1LL << RDX)) | (1LL << RSI)) | (1LL << RDI)) | (1LL << R8)) | (1LL << R9)) | (1LL << R10)) | (1LL << R11);
}


/*	Answer the address the full call immediately preceding
	callSiteReturnAddress will jump to.
 */

	/* CogX64Compiler>>#callFullTargetFromReturnAddress: */
static sqInt NoDbgRegParms
callFullTargetFromReturnAddress(AbstractInstruction * self_in_callFullTargetFromReturnAddress, sqInt callSiteReturnAddress)
{
	return unalignedLongAt((callSiteReturnAddress - 2) - 8);
}

	/* CogX64Compiler>>#callInstructionByteSize */
static sqInt NoDbgRegParms
callInstructionByteSize(AbstractInstruction * self_in_callInstructionByteSize)
{
	return 5;
}


/*	Answer the address the call immediately preceding callSiteReturnAddress
	will jump to.
 */

	/* CogX64Compiler>>#callTargetFromReturnAddress: */
static sqInt NoDbgRegParms
callTargetFromReturnAddress(AbstractInstruction * self_in_callTargetFromReturnAddress, sqInt callSiteReturnAddress)
{
    usqInt callDistance;

	callDistance = literal32BeforeFollowingAddress(self_in_callTargetFromReturnAddress, callSiteReturnAddress);
	return callSiteReturnAddress + (((int) callDistance));
}

	/* CogX64Compiler>>#cmpC32RTempByteSize */
static sqInt NoDbgRegParms
cmpC32RTempByteSize(AbstractInstruction * self_in_cmpC32RTempByteSize)
{
	return 5;
}


/*	Compute the maximum size for each opcode. This allows jump offsets to
	be determined, provided that all backward branches are long branches. */
/*	N.B. The ^N forms are to get around the bytecode compiler's long branch
	limits which are exceeded when each case jumps around the otherwise. */

	/* CogX64Compiler>>#computeMaximumSize */
static sqInt NoDbgRegParms
computeMaximumSize(AbstractInstruction * self_in_computeMaximumSize)
{
	
	switch ((self_in_computeMaximumSize->opcode)) {
	case Label:
		return 0;

	case AlignmentNops:
		return (((self_in_computeMaximumSize->operands))[0]) - 1;

	case Fill32:
	case IMULRR:
	case AddRdRd:
	case CmpRdRd:
	case SubRdRd:
	case MulRdRd:
	case DivRdRd:
	case SqrtRd:
	case MoveRdRd:
		return 4;

	case Nop:
	case Stop:
		return 1;

	case CDQ:
	case JumpR:
		return 2;

	case IDIVR:
	case AddRR:
	case AndRR:
	case CmpRR:
	case OrRR:
	case XorRR:
	case SubRR:
	case NegateR:
	case MoveRR:
		return 3;

	case XCHGRR:
		return (((((self_in_computeMaximumSize->operands))[0]) == RAX)
		 || ((((self_in_computeMaximumSize->operands))[1]) == RAX)
			? 2
			: 3);

	case CallFull:
		return 12;

	case Call:
	case MoveRRd:
	case MoveRdR:
	case ConvertRRd:
		return 5;

	case JumpFull:
		resolveJumpTarget(self_in_computeMaximumSize);
		return 12;

	case JumpLong:
	case Jump:
		resolveJumpTarget(self_in_computeMaximumSize);
		return 5;

	case JumpZero:
	case JumpNonZero:
	case JumpNegative:
	case JumpNonNegative:
	case JumpOverflow:
	case JumpNoOverflow:
	case JumpCarry:
	case JumpNoCarry:
	case JumpLess:
	case JumpGreaterOrEqual:
	case JumpGreater:
	case JumpLessOrEqual:
	case JumpBelow:
	case JumpAboveOrEqual:
	case JumpAbove:
	case JumpBelowOrEqual:
	case JumpLongZero:
	case JumpLongNonZero:
	case JumpFPEqual:
	case JumpFPNotEqual:
	case JumpFPLess:
	case JumpFPGreaterOrEqual:
	case JumpFPGreater:
	case JumpFPLessOrEqual:
	case JumpFPOrdered:
	case JumpFPUnordered:
		resolveJumpTarget(self_in_computeMaximumSize);
		return 6;

	case RetN:
		return ((((self_in_computeMaximumSize->operands))[0]) == 0
			? 1
			: 3);

	case AddCqR:
	case AndCqR:
	case CmpCqR:
	case OrCqR:
	case SubCqR:
	case TstCqR:
		/* begin computeSizeOfArithCqR */
		if (isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])) {
			return 4;
		}
		if (isSignExtendedFourByteValue(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])) {
			return ((((self_in_computeMaximumSize->operands))[1]) == RAX
				? 6
				: 7);
		}
		return 10 + 3;

	case AddCwR:
	case AndCwR:
	case CmpCwR:
	case OrCwR:
	case SubCwR:
	case XorCwR:
		return 10 + 3;

	case CmpC32R:
		return ((((self_in_computeMaximumSize->operands))[1]) <= 7
			? ((((self_in_computeMaximumSize->operands))[1]) == RAX
					? 5
					: 6)
			: 7);

	case LoadEffectiveAddressMwrR:
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? 4
	: 7)) + ((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP
	? 1
	: 0));

	case LogicalShiftLeftCqR:
	case LogicalShiftRightCqR:
	case ArithmeticShiftRightCqR:
	case RotateRightCqR:
	case RotateLeftCqR:
		return ((((self_in_computeMaximumSize->operands))[0]) == 1
			? 3
			: 4);

	case LogicalShiftLeftRR:
	case LogicalShiftRightRR:
	case ArithmeticShiftRightRR:
		return computeShiftRRSize(self_in_computeMaximumSize);

	case MoveCqR:
		return ((((self_in_computeMaximumSize->operands))[0]) == 0
			? 3
			: (is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
					? 7
					: 11 - 1));

	case MoveCwR:
		return (inCurrentCompilation(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
			? 7
			: 11);

	case MoveC32R:
		return 7;

	case MoveAwR:
	case MoveAbR:
		return (isAddressRelativeToVarBase(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
			? 7
			: ((((self_in_computeMaximumSize->operands))[1]) == RAX
					? 10
					: 14));

	case MoveRAw:
	case MoveRAb:
		return (isAddressRelativeToVarBase(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
			? 7
			: ((((self_in_computeMaximumSize->operands))[0]) == RAX
					? 10
					: 14));

	case MoveRMwr:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1]));
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? (((((self_in_computeMaximumSize->operands))[1]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[2]) & 7) != RBP)
			? 3
			: 4)
	: 7)) + ((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP
	? 1
	: 0));

	case MoveRdM64r:
		return (((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? (((((self_in_computeMaximumSize->operands))[1]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[2]) & 6) != RSP)
			? 4
			: 5)
	: 8)) + (((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP)
 && ((((self_in_computeMaximumSize->operands))[1]) != 0)
	? 1
	: 0))) + ((((((self_in_computeMaximumSize->operands))[2]) > 7)
 || ((((self_in_computeMaximumSize->operands))[0]) > 7)
	? 1
	: 0));

	case MoveMbrR:
	case MoveMwrR:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0]));
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? (((((self_in_computeMaximumSize->operands))[0]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[1]) & 7) != RBP)
			? 3
			: 4)
	: 7)) + ((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP
	? 1
	: 0));

	case MoveRMbr:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1]));
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? (((((self_in_computeMaximumSize->operands))[1]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[0]) & 7) != RBP)
			? 3
			: 4)
	: 7)) + ((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP
	? 1
	: 0));

	case MoveM16rR:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0]));
		return ((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? (((((self_in_computeMaximumSize->operands))[0]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[1]) & 7) != RBP)
			? 4
			: 5)
	: 8)) + ((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP
	? 1
	: 0));

	case MoveRM16r:
		assert(is32BitSignedImmediate(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1]));
		return (((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[1])
	? 4
	: 7)) + ((((((self_in_computeMaximumSize->operands))[2]) & 7) == RSP
	? 1
	: 0))) + ((((((self_in_computeMaximumSize->operands))[0]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7)
	? 1
	: 0));

	case MoveM64rRd:
		return (((isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
	? (((((self_in_computeMaximumSize->operands))[0]) == 0)
		 && (((((self_in_computeMaximumSize->operands))[1]) & 6) != RSP)
			? 4
			: 5)
	: 8)) + (((((((self_in_computeMaximumSize->operands))[1]) & 7) == RSP)
 && ((((self_in_computeMaximumSize->operands))[0]) != 0)
	? 1
	: 0))) + ((((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7)
	? 1
	: 0));

	case MoveXbrRR:
		assert((((self_in_computeMaximumSize->operands))[0]) != RSP);
		return (((((self_in_computeMaximumSize->operands))[1]) & 7) == RBP
			? 5
			: 4);

	case MoveRXbrR:
		assert((((self_in_computeMaximumSize->operands))[1]) != RSP);
		return ((((((self_in_computeMaximumSize->operands))[0]) > 3)
 || (((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7))
	? 4
	: 3)) + ((((((self_in_computeMaximumSize->operands))[2]) & 7) == RBP
	? 1
	: 0));

	case MoveXwrRR:
		assert((((self_in_computeMaximumSize->operands))[0]) != RSP);
		return (((((self_in_computeMaximumSize->operands))[1]) == RBP)
		 || ((((self_in_computeMaximumSize->operands))[1]) == R13)
			? 5
			: 4);

	case MoveRXwrR:
		assert((((self_in_computeMaximumSize->operands))[1]) != RSP);
		return (((((self_in_computeMaximumSize->operands))[2]) == RBP)
		 || ((((self_in_computeMaximumSize->operands))[2]) == R13)
			? 5
			: 4);

	case MoveX32rRR:
		assert((((self_in_computeMaximumSize->operands))[0]) != RSP);
		return ((((((self_in_computeMaximumSize->operands))[1]) == RBP)
 || ((((self_in_computeMaximumSize->operands))[1]) == R13)
	? 7
	: 6)) + ((((((self_in_computeMaximumSize->operands))[0]) > 7)
 || (((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7))
	? 1
	: 0));

	case MoveRX32rR:
		assert((((self_in_computeMaximumSize->operands))[1]) != RSP);
		return ((((((self_in_computeMaximumSize->operands))[2]) == RBP)
 || ((((self_in_computeMaximumSize->operands))[2]) == R13)
	? 4
	: 3)) + ((((((self_in_computeMaximumSize->operands))[0]) > 7)
 || (((((self_in_computeMaximumSize->operands))[1]) > 7)
 || ((((self_in_computeMaximumSize->operands))[2]) > 7))
	? 1
	: 0));

	case PopR:
	case PushR:
		return ((((self_in_computeMaximumSize->operands))[0]) < 8
			? 1
			: 2);

	case PushCq:
		return (isQuick(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
			? 2
			: 5);

	case PushCw:
		return (inCurrentCompilation(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
			? 9
			: 12);

	case PrefetchAw:
		return (isAddressRelativeToVarBase(self_in_computeMaximumSize, ((self_in_computeMaximumSize->operands))[0])
			? 7
			: 0);

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}


/*	On the x86 the only instructions that shift by the value of a
	register require the shift count to be in %ecx. So we may
	have to use swap instructions to get the count into ecx. */

	/* CogX64Compiler>>#computeShiftRRSize */
static sqInt NoDbgRegParms
computeShiftRRSize(AbstractInstruction * self_in_computeShiftRRSize)
{
    unsigned long shiftCountReg;

	shiftCountReg = ((self_in_computeShiftRRSize->operands))[0];
	return (shiftCountReg == RCX
		? 3
		: (shiftCountReg == RAX
				? (2 + 3) + 2
				: (3 + 3) + 3));
}


/*	Will get inlined into concretizeAt: switch. */

	/* CogX64Compiler>>#concretizeArithCqRWithRO:raxOpcode: */
static usqInt NoDbgRegParms
concretizeArithCqRWithROraxOpcode(AbstractInstruction * self_in_concretizeArithCqRWithROraxOpcode, sqInt regOpcode, sqInt raxOpcode)
{
    unsigned long reg;
    unsigned long value;

	value = ((self_in_concretizeArithCqRWithROraxOpcode->operands))[0];
	reg = ((self_in_concretizeArithCqRWithROraxOpcode->operands))[1];
	((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[0] = (rexRxb(self_in_concretizeArithCqRWithROraxOpcode, 0, 0, reg));
	if (isQuick(self_in_concretizeArithCqRWithROraxOpcode, value)) {
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[1] = 131;
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[2] = (modRMRO(self_in_concretizeArithCqRWithROraxOpcode, ModReg, reg, regOpcode));
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[3] = (value & 0xFF);
		return ((self_in_concretizeArithCqRWithROraxOpcode->machineCodeSize) = 4);
	}
	if (isSignExtendedFourByteValue(self_in_concretizeArithCqRWithROraxOpcode, value)) {
		if (reg == RAX) {
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[1] = raxOpcode;
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[2] = (value & 0xFF);
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[3] = ((((usqInt) value) >> 8) & 0xFF);
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[4] = ((((usqInt) value) >> 16) & 0xFF);
			((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[5] = ((((usqInt) value) >> 24) & 0xFF);
			return ((self_in_concretizeArithCqRWithROraxOpcode->machineCodeSize) = 6);
		}
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[1] = 129;
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[2] = (modRMRO(self_in_concretizeArithCqRWithROraxOpcode, ModReg, reg, regOpcode));
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[3] = (value & 0xFF);
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[4] = ((((usqInt) value) >> 8) & 0xFF);
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[5] = ((((usqInt) value) >> 16) & 0xFF);
		((self_in_concretizeArithCqRWithROraxOpcode->machineCode))[6] = ((((usqInt) value) >> 24) & 0xFF);
		return ((self_in_concretizeArithCqRWithROraxOpcode->machineCodeSize) = 7);
	}
	return concretizeArithCwR(self_in_concretizeArithCqRWithROraxOpcode, (raxOpcode == 61
		? 57
		: raxOpcode - 2));
}

	/* CogX64Compiler>>#concretizeFill32 */
static usqInt NoDbgRegParms
concretizeFill32(AbstractInstruction * self_in_concretizeFill32)
{
    unsigned long word;

	word = ((self_in_concretizeFill32->operands))[0];
	((self_in_concretizeFill32->machineCode))[0] = (word & 0xFF);
	((self_in_concretizeFill32->machineCode))[1] = ((((usqInt) word) >> 8) & 0xFF);
	((self_in_concretizeFill32->machineCode))[2] = ((((usqInt) word) >> 16) & 0xFF);
	((self_in_concretizeFill32->machineCode))[3] = ((((usqInt) word) >> 24) & 0xFF);
	return ((self_in_concretizeFill32->machineCodeSize) = 4);
}

	/* CogX64Compiler>>#concretizeMoveRX32rR */
static usqInt NoDbgRegParms
concretizeMoveRX32rR(AbstractInstruction * self_in_concretizeMoveRX32rR)
{
    unsigned long base;
    unsigned long index;
    sqInt offset;
    unsigned long src;

	src = ((self_in_concretizeMoveRX32rR->operands))[0];
	index = ((self_in_concretizeMoveRX32rR->operands))[1];
	base = ((self_in_concretizeMoveRX32rR->operands))[2];
	if ((index > 7)
	 || ((base > 7)
	 || (src > 7))) {
		((self_in_concretizeMoveRX32rR->machineCode))[0] = (rexwrxb(self_in_concretizeMoveRX32rR, 0, src, index, base));
		offset = 1;
	}
	else {
		offset = 0;
	}
	if ((base & 7) != RBP) {
		((self_in_concretizeMoveRX32rR->machineCode))[offset] = 137;
		((self_in_concretizeMoveRX32rR->machineCode))[offset + 1] = (modRMRO(self_in_concretizeMoveRX32rR, ModRegInd, 4, src));
		((self_in_concretizeMoveRX32rR->machineCode))[offset + 2] = (sib(self_in_concretizeMoveRX32rR, SIB4, index, base));
		return ((self_in_concretizeMoveRX32rR->machineCodeSize) = offset + 3);
	}
	((self_in_concretizeMoveRX32rR->machineCode))[offset] = 137;
	((self_in_concretizeMoveRX32rR->machineCode))[offset + 1] = (modRMRO(self_in_concretizeMoveRX32rR, ModRegRegDisp8, 4, src));
	((self_in_concretizeMoveRX32rR->machineCode))[offset + 2] = (sib(self_in_concretizeMoveRX32rR, SIB4, index, base));
	((self_in_concretizeMoveRX32rR->machineCode))[offset + 3] = 0;
	return ((self_in_concretizeMoveRX32rR->machineCodeSize) = offset + 4);
}


/*	MoveX32rRR is expected to zero-extend, so explicitly zero the destination. */

	/* CogX64Compiler>>#concretizeMoveX32rRR */
static usqInt NoDbgRegParms
concretizeMoveX32rRR(AbstractInstruction * self_in_concretizeMoveX32rRR)
{
    unsigned long base;
    unsigned long dest;
    unsigned long index;
    sqInt offset;

	index = ((self_in_concretizeMoveX32rRR->operands))[0];
	base = ((self_in_concretizeMoveX32rRR->operands))[1];
	dest = ((self_in_concretizeMoveX32rRR->operands))[2];
	((self_in_concretizeMoveX32rRR->machineCode))[0] = (rexRxb(self_in_concretizeMoveX32rRR, dest, 0, dest));
	((self_in_concretizeMoveX32rRR->machineCode))[1] = 49;
	((self_in_concretizeMoveX32rRR->machineCode))[2] = (modRMRO(self_in_concretizeMoveX32rRR, ModReg, dest, dest));
	if ((index > 7)
	 || ((base > 7)
	 || (dest > 7))) {
		((self_in_concretizeMoveX32rRR->machineCode))[3] = (rexwrxb(self_in_concretizeMoveX32rRR, 0, dest, index, base));
		offset = 1;
	}
	else {
		offset = 0;
	}
	if ((base & 7) != RBP) {
		((self_in_concretizeMoveX32rRR->machineCode))[offset + 3] = 139;
		((self_in_concretizeMoveX32rRR->machineCode))[offset + 4] = (modRMRO(self_in_concretizeMoveX32rRR, ModRegInd, 4, dest));
		((self_in_concretizeMoveX32rRR->machineCode))[offset + 5] = (sib(self_in_concretizeMoveX32rRR, SIB4, index, base));
		return ((self_in_concretizeMoveX32rRR->machineCodeSize) = offset + 6);
	}
	((self_in_concretizeMoveX32rRR->machineCode))[offset + 3] = 139;
	((self_in_concretizeMoveX32rRR->machineCode))[offset + 4] = (modRMRO(self_in_concretizeMoveX32rRR, ModRegRegDisp8, 4, dest));
	((self_in_concretizeMoveX32rRR->machineCode))[offset + 5] = (sib(self_in_concretizeMoveX32rRR, SIB4, index, base));
	((self_in_concretizeMoveX32rRR->machineCode))[offset + 6] = 0;
	return ((self_in_concretizeMoveX32rRR->machineCodeSize) = offset + 7);
}

	/* CogX64Compiler>>#concretizeOpRR: */
static usqInt NoDbgRegParms
concretizeOpRR(AbstractInstruction * self_in_concretizeOpRR, sqInt x64opcode)
{
    unsigned long regLHS;
    unsigned long regRHS;

	regLHS = ((self_in_concretizeOpRR->operands))[0];
	regRHS = ((self_in_concretizeOpRR->operands))[1];
	((self_in_concretizeOpRR->machineCode))[0] = (rexRxb(self_in_concretizeOpRR, regRHS, 0, regLHS));
	((self_in_concretizeOpRR->machineCode))[1] = x64opcode;
	((self_in_concretizeOpRR->machineCode))[2] = (modRMRO(self_in_concretizeOpRR, ModReg, regLHS, regRHS));
	return ((self_in_concretizeOpRR->machineCodeSize) = 3);
}


/*	We support only prefetches for addresses that are variables relative to
	VarBase 
 */

	/* CogX64Compiler>>#concretizePrefetchAw */
static usqInt NoDbgRegParms
concretizePrefetchAw(AbstractInstruction * self_in_concretizePrefetchAw)
{
    unsigned long offset;
    unsigned long operand;

	operand = ((self_in_concretizePrefetchAw->operands))[0];
	if (!((operand != null)
		 && ((operand >= (varBaseAddress()))
		 && ((operand - (varBaseAddress())) < (1LL << 20))))) {
		return ((self_in_concretizePrefetchAw->machineCodeSize) = 0);
	}
	offset = operand - (varBaseAddress());
	((self_in_concretizePrefetchAw->machineCode))[0] = 15;
	((self_in_concretizePrefetchAw->machineCode))[1] = 24;
	((self_in_concretizePrefetchAw->machineCode))[2] = 147;
	((self_in_concretizePrefetchAw->machineCode))[3] = (offset & 0xFF);
	((self_in_concretizePrefetchAw->machineCode))[4] = ((((usqInt) offset) >> 16) & 0xFF);
	((self_in_concretizePrefetchAw->machineCode))[5] = ((((usqInt) offset) >> 8) & 0xFF);
	((self_in_concretizePrefetchAw->machineCode))[6] = (((usqInt) offset) >> 24);
	return ((self_in_concretizePrefetchAw->machineCodeSize) = 7);
}


/*	CmpRR/MoveRR RHS LHS computes LHS - RHS, i.e. apparently reversed. You
	have to think subtract. */

	/* CogX64Compiler>>#concretizeReverseOpRR: */
static usqInt NoDbgRegParms
concretizeReverseOpRR(AbstractInstruction * self_in_concretizeReverseOpRR, sqInt x64opcode)
{
    unsigned long regLHS;
    unsigned long regRHS;

	regRHS = ((self_in_concretizeReverseOpRR->operands))[0];
	regLHS = ((self_in_concretizeReverseOpRR->operands))[1];
	((self_in_concretizeReverseOpRR->machineCode))[0] = (rexRxb(self_in_concretizeReverseOpRR, regRHS, 0, regLHS));
	((self_in_concretizeReverseOpRR->machineCode))[1] = x64opcode;
	((self_in_concretizeReverseOpRR->machineCode))[2] = (modRMRO(self_in_concretizeReverseOpRR, ModReg, regLHS, regRHS));
	return ((self_in_concretizeReverseOpRR->machineCodeSize) = 3);
}

	/* CogX64Compiler>>#concretizeXCHGRR */
static usqInt NoDbgRegParms
concretizeXCHGRR(AbstractInstruction * self_in_concretizeXCHGRR)
{
    unsigned long r1;
    unsigned long r2;

	r1 = ((self_in_concretizeXCHGRR->operands))[0];
	r2 = ((self_in_concretizeXCHGRR->operands))[1];
	if (r2 == RAX) {
		r2 = r1;
		r1 = RAX;
	}
	if (r1 == RAX) {
		((self_in_concretizeXCHGRR->machineCode))[0] = (rexRxb(self_in_concretizeXCHGRR, 0, 0, r2));
		((self_in_concretizeXCHGRR->machineCode))[1] = (144 + (r2 % 8));
		return ((self_in_concretizeXCHGRR->machineCodeSize) = 2);
	}
	((self_in_concretizeXCHGRR->machineCode))[0] = (rexRxb(self_in_concretizeXCHGRR, r1, 0, r2));
	((self_in_concretizeXCHGRR->machineCode))[1] = 87;
	((self_in_concretizeXCHGRR->machineCode))[2] = (modRMRO(self_in_concretizeXCHGRR, r2, 0, r1));
	return ((self_in_concretizeXCHGRR->machineCodeSize) = 3);
}


/*	Attempt to generate concrete machine code for the instruction at address.
	This is the inner dispatch of concretizeAt: actualAddress which exists
	only to get around the branch size limits in the SqueakV3 (blue book
	derived) bytecode set. */

	/* CogX64Compiler>>#dispatchConcretize */
static void NoDbgRegParms
dispatchConcretize(AbstractInstruction * self_in_dispatchConcretize)
{
    unsigned long addressOperand;
    unsigned long addressOperand1;
    unsigned long addressOperand2;
    unsigned long addressOperand3;
    unsigned long base;
    unsigned long base1;
    unsigned long base2;
    unsigned long base3;
    unsigned long baseReg;
    unsigned long baseReg1;
    AbstractInstruction *dependentChain;
    unsigned long dest;
    unsigned long dest1;
    unsigned long destReg;
    unsigned long destReg1;
    unsigned long destReg10;
    unsigned long destReg11;
    unsigned long destReg12;
    unsigned long destReg13;
    unsigned long destReg14;
    unsigned long destReg15;
    unsigned long destReg2;
    unsigned long destReg3;
    unsigned long destReg4;
    unsigned long destReg5;
    unsigned long destReg6;
    unsigned long destReg7;
    unsigned long destReg8;
    unsigned long destReg9;
    unsigned long distance;
    unsigned long distance1;
    unsigned long distance2;
    unsigned long distance3;
    unsigned long distance4;
    sqInt i;
    unsigned long index;
    unsigned long index1;
    unsigned long index2;
    unsigned long index3;
    AbstractInstruction *jumpTarget;
    AbstractInstruction *jumpTarget1;
    AbstractInstruction *jumpTarget10;
    AbstractInstruction *jumpTarget11;
    AbstractInstruction *jumpTarget110;
    AbstractInstruction *jumpTarget111;
    AbstractInstruction *jumpTarget1110;
    AbstractInstruction *jumpTarget1111;
    AbstractInstruction *jumpTarget1112;
    AbstractInstruction *jumpTarget1113;
    AbstractInstruction *jumpTarget1114;
    AbstractInstruction *jumpTarget1115;
    AbstractInstruction *jumpTarget1116;
    AbstractInstruction *jumpTarget112;
    AbstractInstruction *jumpTarget113;
    AbstractInstruction *jumpTarget114;
    AbstractInstruction *jumpTarget115;
    AbstractInstruction *jumpTarget116;
    AbstractInstruction *jumpTarget117;
    AbstractInstruction *jumpTarget118;
    AbstractInstruction *jumpTarget119;
    AbstractInstruction *jumpTarget12;
    AbstractInstruction *jumpTarget120;
    AbstractInstruction *jumpTarget121;
    AbstractInstruction *jumpTarget122;
    AbstractInstruction *jumpTarget123;
    AbstractInstruction *jumpTarget124;
    AbstractInstruction *jumpTarget125;
    AbstractInstruction *jumpTarget13;
    AbstractInstruction *jumpTarget14;
    AbstractInstruction *jumpTarget15;
    AbstractInstruction *jumpTarget16;
    AbstractInstruction *jumpTarget17;
    AbstractInstruction *jumpTarget18;
    AbstractInstruction *jumpTarget19;
    AbstractInstruction *jumpTarget2;
    AbstractInstruction *jumpTarget20;
    AbstractInstruction *jumpTarget21;
    AbstractInstruction *jumpTarget210;
    AbstractInstruction *jumpTarget211;
    AbstractInstruction *jumpTarget212;
    AbstractInstruction *jumpTarget213;
    AbstractInstruction *jumpTarget214;
    AbstractInstruction *jumpTarget215;
    AbstractInstruction *jumpTarget216;
    AbstractInstruction *jumpTarget22;
    AbstractInstruction *jumpTarget23;
    AbstractInstruction *jumpTarget24;
    AbstractInstruction *jumpTarget25;
    AbstractInstruction *jumpTarget26;
    AbstractInstruction *jumpTarget27;
    AbstractInstruction *jumpTarget28;
    AbstractInstruction *jumpTarget29;
    AbstractInstruction *jumpTarget3;
    AbstractInstruction *jumpTarget30;
    AbstractInstruction *jumpTarget31;
    AbstractInstruction *jumpTarget32;
    AbstractInstruction *jumpTarget33;
    AbstractInstruction *jumpTarget34;
    AbstractInstruction *jumpTarget35;
    AbstractInstruction *jumpTarget4;
    AbstractInstruction *jumpTarget5;
    AbstractInstruction *jumpTarget6;
    AbstractInstruction *jumpTarget7;
    AbstractInstruction *jumpTarget8;
    AbstractInstruction *jumpTarget9;
    sqInt offset;
    unsigned long offset1;
    unsigned long offset10;
    unsigned long offset11;
    unsigned long offset110;
    unsigned long offset111;
    unsigned long offset112;
    sqInt offset113;
    sqInt offset114;
    sqInt offset115;
    sqInt offset116;
    sqInt offset117;
    sqInt offset118;
    sqInt offset119;
    sqInt offset12;
    sqInt offset120;
    sqInt offset121;
    sqInt offset122;
    sqInt offset123;
    sqInt offset124;
    sqInt offset125;
    sqInt offset126;
    sqInt offset127;
    sqInt offset128;
    sqInt offset13;
    unsigned long offset14;
    unsigned long offset15;
    unsigned long offset16;
    unsigned long offset17;
    sqInt offset18;
    sqInt offset19;
    unsigned long offset2;
    sqInt offset20;
    sqInt offset21;
    sqInt offset22;
    sqInt offset23;
    sqInt offset24;
    sqInt offset25;
    sqInt offset26;
    sqInt offset27;
    sqInt offset28;
    sqInt offset29;
    unsigned long offset3;
    sqInt offset30;
    sqInt offset31;
    sqInt offset32;
    sqInt offset33;
    sqInt offset34;
    sqInt offset35;
    sqInt offset36;
    sqInt offset37;
    unsigned long offset4;
    unsigned long offset5;
    unsigned long offset6;
    unsigned long offset7;
    unsigned long offset8;
    sqInt offset9;
    unsigned long operand;
    unsigned long operand1;
    unsigned long reg;
    unsigned long reg1;
    unsigned long reg10;
    unsigned long reg11;
    unsigned long reg12;
    unsigned long reg13;
    unsigned long reg14;
    unsigned long reg15;
    unsigned long reg16;
    unsigned long reg17;
    unsigned long reg18;
    unsigned long reg19;
    unsigned long reg2;
    unsigned long reg20;
    unsigned long reg21;
    unsigned long reg3;
    unsigned long reg4;
    unsigned long reg5;
    unsigned long reg6;
    unsigned long reg7;
    unsigned long reg8;
    unsigned long reg9;
    unsigned long regDivisor;
    unsigned long regLHS;
    unsigned long regLHS1;
    unsigned long regLHS2;
    unsigned long regLHS3;
    unsigned long regLHS4;
    unsigned long regRHS;
    unsigned long regRHS1;
    unsigned long regRHS2;
    unsigned long regRHS3;
    unsigned long regRHS4;
    unsigned long regToShift;
    unsigned long regToShift1;
    unsigned long save0;
    unsigned long save01;
    unsigned long save1;
    unsigned long save11;
    unsigned long save12;
    unsigned long save13;
    unsigned long shiftCountReg;
    unsigned long shiftCountReg1;
    sqInt skip;
    sqInt skip1;
    sqInt skip2;
    sqInt skip3;
    unsigned long src;
    unsigned long src1;
    unsigned long srcReg;
    unsigned long srcReg1;
    unsigned long srcReg10;
    unsigned long srcReg11;
    unsigned long srcReg12;
    unsigned long srcReg13;
    unsigned long srcReg14;
    unsigned long srcReg15;
    unsigned long srcReg2;
    unsigned long srcReg3;
    unsigned long srcReg4;
    unsigned long srcReg5;
    unsigned long srcReg6;
    unsigned long srcReg7;
    unsigned long srcReg8;
    unsigned long srcReg9;
    unsigned long value;
    unsigned long value1;
    unsigned long value2;
    unsigned long value3;
    unsigned long value4;
    unsigned long value5;
    unsigned long value6;
    unsigned long value7;
    unsigned long word;

	
	switch ((self_in_dispatchConcretize->opcode)) {
	case Label:
		/* begin concretizeLabel */
		dependentChain = (self_in_dispatchConcretize->dependent);
		while (!(dependentChain == null)) {
			updateLabel(dependentChain, self_in_dispatchConcretize);
			dependentChain = (dependentChain->dependent);
		}
		((self_in_dispatchConcretize->machineCodeSize) = 0);
		return;

	case AlignmentNops:
		/* begin concretizeAlignmentNops */
		flag("if performance is an issue generate longer nops");
		for (i = 0; i < ((self_in_dispatchConcretize->machineCodeSize)); i += 1) {
			((self_in_dispatchConcretize->machineCode))[i] = 144;
		}
		return;

	case Fill32:
		/* begin concretizeFill32 */
		word = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = (word & 0xFF);
		((self_in_dispatchConcretize->machineCode))[1] = ((((usqInt) word) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((((usqInt) word) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) word) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case Nop:
		/* begin concretizeNop */
		((self_in_dispatchConcretize->machineCode))[0] = 144;
		((self_in_dispatchConcretize->machineCodeSize) = 1);
		return;

	case CDQ:
		/* begin concretizeCDQ */
		((self_in_dispatchConcretize->machineCode))[0] = 72;
		((self_in_dispatchConcretize->machineCode))[1] = 153;
		((self_in_dispatchConcretize->machineCodeSize) = 2);
		return;

	case IDIVR:
		/* begin concretizeIDIVR */
		regDivisor = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, regDivisor));
		((self_in_dispatchConcretize->machineCode))[1] = 247;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, regDivisor, 7));
		((self_in_dispatchConcretize->machineCodeSize) = 3);
		return;

	case IMULRR:
		/* begin concretizeMulRR */
		reg1 = ((self_in_dispatchConcretize->operands))[0];
		reg2 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, reg2, 0, reg1));
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 175;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, reg1, reg2));
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case XCHGRR:
		concretizeXCHGRR(self_in_dispatchConcretize);
		return;

	case Call:
		/* begin concretizeCall */
		assert((((self_in_dispatchConcretize->operands))[0]) != 0);
		offset = (((int) (((self_in_dispatchConcretize->operands))[0]))) - (((int) (((self_in_dispatchConcretize->address)) + 5)));
		((self_in_dispatchConcretize->machineCode))[0] = 232;
		((self_in_dispatchConcretize->machineCode))[1] = (offset & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((((usqInt) offset) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case CallFull:
		/* begin concretizeCallFull */
		operand = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = 72;
		((self_in_dispatchConcretize->machineCode))[1] = 184;
		((self_in_dispatchConcretize->machineCode))[2] = (operand & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) operand) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) operand) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) operand) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) operand) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) operand) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = ((((usqInt) operand) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = ((((usqInt) operand) >> 56) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[10] = 0xFF;
		((self_in_dispatchConcretize->machineCode))[11] = (modRMRO(self_in_dispatchConcretize, ModReg, RAX, 2));
		((self_in_dispatchConcretize->machineCodeSize) = 12);
		return;

	case JumpR:
		/* begin concretizeJumpR */
		reg = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = 0xFF;
		((self_in_dispatchConcretize->machineCode))[1] = (modRMRO(self_in_dispatchConcretize, ModReg, reg, 4));
		((self_in_dispatchConcretize->machineCodeSize) = 2);
		return;

	case JumpFull:
		/* begin concretizeJumpFull */
		operand1 = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = 72;
		((self_in_dispatchConcretize->machineCode))[1] = 184;
		((self_in_dispatchConcretize->machineCode))[2] = (operand1 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) operand1) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) operand1) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) operand1) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) operand1) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) operand1) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = ((((usqInt) operand1) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = ((((usqInt) operand1) >> 56) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[10] = 0xFF;
		((self_in_dispatchConcretize->machineCode))[11] = (modRMRO(self_in_dispatchConcretize, ModReg, RAX, 4));
		((self_in_dispatchConcretize->machineCodeSize) = 12);
		return;

	case JumpLong:
		/* begin concretizeJumpLong */
		jumpTarget = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		if ((addressIsInInstructions(jumpTarget))
		 || (jumpTarget == (methodLabel()))) {
			jumpTarget = ((AbstractInstruction *) ((jumpTarget->address)));
		}
		assert(jumpTarget != 0);
		offset12 = (((int) jumpTarget)) - (((int) (((self_in_dispatchConcretize->address)) + 5)));
		((self_in_dispatchConcretize->machineCode))[0] = 233;
		((self_in_dispatchConcretize->machineCode))[1] = (offset12 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((((usqInt) offset12) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset12) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset12) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case JumpLongZero:
	case JumpZero:
	case JumpFPEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget12 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget12);
		if ((addressIsInInstructions(jumpTarget12))
		 || (jumpTarget12 == (methodLabel()))) {
			jumpTarget12 = ((AbstractInstruction *) ((jumpTarget12->address)));
		}
		assert(jumpTarget12 != 0);
		jumpTarget3 = jumpTarget12;
		offset22 = (((int) jumpTarget3)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset22)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 4);
			((self_in_dispatchConcretize->machineCode))[1] = (offset22 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget11 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget11);
		if ((addressIsInInstructions(jumpTarget11))
		 || (jumpTarget11 == (methodLabel()))) {
			jumpTarget11 = ((AbstractInstruction *) ((jumpTarget11->address)));
		}
		assert(jumpTarget11 != 0);
		jumpTarget2 = jumpTarget11;
		offset113 = (((int) jumpTarget2)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 4);
		((self_in_dispatchConcretize->machineCode))[2] = (offset113 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset113) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset113) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset113) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpLongNonZero:
	case JumpNonZero:
	case JumpFPNotEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget13 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget13);
		if ((addressIsInInstructions(jumpTarget13))
		 || (jumpTarget13 == (methodLabel()))) {
			jumpTarget13 = ((AbstractInstruction *) ((jumpTarget13->address)));
		}
		assert(jumpTarget13 != 0);
		jumpTarget4 = jumpTarget13;
		offset23 = (((int) jumpTarget4)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset23)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 5);
			((self_in_dispatchConcretize->machineCode))[1] = (offset23 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget111 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget111);
		if ((addressIsInInstructions(jumpTarget111))
		 || (jumpTarget111 == (methodLabel()))) {
			jumpTarget111 = ((AbstractInstruction *) ((jumpTarget111->address)));
		}
		assert(jumpTarget111 != 0);
		jumpTarget21 = jumpTarget111;
		offset114 = (((int) jumpTarget21)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 5);
		((self_in_dispatchConcretize->machineCode))[2] = (offset114 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset114) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset114) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset114) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case Jump:
		/* begin concretizeJump */
		jumpTarget1 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1);
		if ((addressIsInInstructions(jumpTarget1))
		 || (jumpTarget1 == (methodLabel()))) {
			jumpTarget1 = ((AbstractInstruction *) ((jumpTarget1->address)));
		}
		assert(jumpTarget1 != 0);
		offset13 = (((int) jumpTarget1)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset13)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = 235;
			((self_in_dispatchConcretize->machineCode))[1] = (offset13 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		offset13 = (((int) jumpTarget1)) - (((int) (((self_in_dispatchConcretize->address)) + 5)));
		((self_in_dispatchConcretize->machineCode))[0] = 233;
		((self_in_dispatchConcretize->machineCode))[1] = (offset13 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((((usqInt) offset13) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset13) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset13) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case JumpNegative:
		/* begin concretizeConditionalJump: */
		jumpTarget14 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget14);
		if ((addressIsInInstructions(jumpTarget14))
		 || (jumpTarget14 == (methodLabel()))) {
			jumpTarget14 = ((AbstractInstruction *) ((jumpTarget14->address)));
		}
		assert(jumpTarget14 != 0);
		jumpTarget5 = jumpTarget14;
		offset24 = (((int) jumpTarget5)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset24)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 8);
			((self_in_dispatchConcretize->machineCode))[1] = (offset24 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget112 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget112);
		if ((addressIsInInstructions(jumpTarget112))
		 || (jumpTarget112 == (methodLabel()))) {
			jumpTarget112 = ((AbstractInstruction *) ((jumpTarget112->address)));
		}
		assert(jumpTarget112 != 0);
		jumpTarget22 = jumpTarget112;
		offset115 = (((int) jumpTarget22)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 8);
		((self_in_dispatchConcretize->machineCode))[2] = (offset115 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset115) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset115) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset115) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpNonNegative:
		/* begin concretizeConditionalJump: */
		jumpTarget15 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget15);
		if ((addressIsInInstructions(jumpTarget15))
		 || (jumpTarget15 == (methodLabel()))) {
			jumpTarget15 = ((AbstractInstruction *) ((jumpTarget15->address)));
		}
		assert(jumpTarget15 != 0);
		jumpTarget6 = jumpTarget15;
		offset25 = (((int) jumpTarget6)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset25)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 9);
			((self_in_dispatchConcretize->machineCode))[1] = (offset25 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget113 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget113);
		if ((addressIsInInstructions(jumpTarget113))
		 || (jumpTarget113 == (methodLabel()))) {
			jumpTarget113 = ((AbstractInstruction *) ((jumpTarget113->address)));
		}
		assert(jumpTarget113 != 0);
		jumpTarget23 = jumpTarget113;
		offset116 = (((int) jumpTarget23)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 9);
		((self_in_dispatchConcretize->machineCode))[2] = (offset116 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset116) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset116) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset116) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpOverflow:
		/* begin concretizeConditionalJump: */
		jumpTarget16 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget16);
		if ((addressIsInInstructions(jumpTarget16))
		 || (jumpTarget16 == (methodLabel()))) {
			jumpTarget16 = ((AbstractInstruction *) ((jumpTarget16->address)));
		}
		assert(jumpTarget16 != 0);
		jumpTarget7 = jumpTarget16;
		offset26 = (((int) jumpTarget7)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset26)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112);
			((self_in_dispatchConcretize->machineCode))[1] = (offset26 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget114 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget114);
		if ((addressIsInInstructions(jumpTarget114))
		 || (jumpTarget114 == (methodLabel()))) {
			jumpTarget114 = ((AbstractInstruction *) ((jumpTarget114->address)));
		}
		assert(jumpTarget114 != 0);
		jumpTarget24 = jumpTarget114;
		offset117 = (((int) jumpTarget24)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128);
		((self_in_dispatchConcretize->machineCode))[2] = (offset117 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset117) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset117) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset117) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpNoOverflow:
		/* begin concretizeConditionalJump: */
		jumpTarget17 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget17);
		if ((addressIsInInstructions(jumpTarget17))
		 || (jumpTarget17 == (methodLabel()))) {
			jumpTarget17 = ((AbstractInstruction *) ((jumpTarget17->address)));
		}
		assert(jumpTarget17 != 0);
		jumpTarget8 = jumpTarget17;
		offset27 = (((int) jumpTarget8)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset27)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 1);
			((self_in_dispatchConcretize->machineCode))[1] = (offset27 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget115 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget115);
		if ((addressIsInInstructions(jumpTarget115))
		 || (jumpTarget115 == (methodLabel()))) {
			jumpTarget115 = ((AbstractInstruction *) ((jumpTarget115->address)));
		}
		assert(jumpTarget115 != 0);
		jumpTarget25 = jumpTarget115;
		offset118 = (((int) jumpTarget25)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 1);
		((self_in_dispatchConcretize->machineCode))[2] = (offset118 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset118) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset118) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset118) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpCarry:
	case JumpBelow:
	case JumpFPLess:
		/* begin concretizeConditionalJump: */
		jumpTarget18 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget18);
		if ((addressIsInInstructions(jumpTarget18))
		 || (jumpTarget18 == (methodLabel()))) {
			jumpTarget18 = ((AbstractInstruction *) ((jumpTarget18->address)));
		}
		assert(jumpTarget18 != 0);
		jumpTarget9 = jumpTarget18;
		offset28 = (((int) jumpTarget9)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset28)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 2);
			((self_in_dispatchConcretize->machineCode))[1] = (offset28 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget116 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget116);
		if ((addressIsInInstructions(jumpTarget116))
		 || (jumpTarget116 == (methodLabel()))) {
			jumpTarget116 = ((AbstractInstruction *) ((jumpTarget116->address)));
		}
		assert(jumpTarget116 != 0);
		jumpTarget26 = jumpTarget116;
		offset119 = (((int) jumpTarget26)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 2);
		((self_in_dispatchConcretize->machineCode))[2] = (offset119 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset119) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset119) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset119) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpNoCarry:
	case JumpAboveOrEqual:
	case JumpFPGreaterOrEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget19 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget19);
		if ((addressIsInInstructions(jumpTarget19))
		 || (jumpTarget19 == (methodLabel()))) {
			jumpTarget19 = ((AbstractInstruction *) ((jumpTarget19->address)));
		}
		assert(jumpTarget19 != 0);
		jumpTarget10 = jumpTarget19;
		offset29 = (((int) jumpTarget10)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset29)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 3);
			((self_in_dispatchConcretize->machineCode))[1] = (offset29 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget117 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget117);
		if ((addressIsInInstructions(jumpTarget117))
		 || (jumpTarget117 == (methodLabel()))) {
			jumpTarget117 = ((AbstractInstruction *) ((jumpTarget117->address)));
		}
		assert(jumpTarget117 != 0);
		jumpTarget27 = jumpTarget117;
		offset120 = (((int) jumpTarget27)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 3);
		((self_in_dispatchConcretize->machineCode))[2] = (offset120 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset120) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset120) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset120) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpLess:
		/* begin concretizeConditionalJump: */
		jumpTarget110 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget110);
		if ((addressIsInInstructions(jumpTarget110))
		 || (jumpTarget110 == (methodLabel()))) {
			jumpTarget110 = ((AbstractInstruction *) ((jumpTarget110->address)));
		}
		assert(jumpTarget110 != 0);
		jumpTarget20 = jumpTarget110;
		offset30 = (((int) jumpTarget20)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset30)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 12);
			((self_in_dispatchConcretize->machineCode))[1] = (offset30 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget118 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget118);
		if ((addressIsInInstructions(jumpTarget118))
		 || (jumpTarget118 == (methodLabel()))) {
			jumpTarget118 = ((AbstractInstruction *) ((jumpTarget118->address)));
		}
		assert(jumpTarget118 != 0);
		jumpTarget28 = jumpTarget118;
		offset121 = (((int) jumpTarget28)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 12);
		((self_in_dispatchConcretize->machineCode))[2] = (offset121 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset121) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset121) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset121) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpGreaterOrEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget119 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget119);
		if ((addressIsInInstructions(jumpTarget119))
		 || (jumpTarget119 == (methodLabel()))) {
			jumpTarget119 = ((AbstractInstruction *) ((jumpTarget119->address)));
		}
		assert(jumpTarget119 != 0);
		jumpTarget29 = jumpTarget119;
		offset31 = (((int) jumpTarget29)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset31)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 13);
			((self_in_dispatchConcretize->machineCode))[1] = (offset31 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget1110 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1110);
		if ((addressIsInInstructions(jumpTarget1110))
		 || (jumpTarget1110 == (methodLabel()))) {
			jumpTarget1110 = ((AbstractInstruction *) ((jumpTarget1110->address)));
		}
		assert(jumpTarget1110 != 0);
		jumpTarget210 = jumpTarget1110;
		offset122 = (((int) jumpTarget210)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 13);
		((self_in_dispatchConcretize->machineCode))[2] = (offset122 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset122) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset122) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset122) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpGreater:
		/* begin concretizeConditionalJump: */
		jumpTarget120 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget120);
		if ((addressIsInInstructions(jumpTarget120))
		 || (jumpTarget120 == (methodLabel()))) {
			jumpTarget120 = ((AbstractInstruction *) ((jumpTarget120->address)));
		}
		assert(jumpTarget120 != 0);
		jumpTarget30 = jumpTarget120;
		offset32 = (((int) jumpTarget30)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset32)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 15);
			((self_in_dispatchConcretize->machineCode))[1] = (offset32 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget1111 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1111);
		if ((addressIsInInstructions(jumpTarget1111))
		 || (jumpTarget1111 == (methodLabel()))) {
			jumpTarget1111 = ((AbstractInstruction *) ((jumpTarget1111->address)));
		}
		assert(jumpTarget1111 != 0);
		jumpTarget211 = jumpTarget1111;
		offset123 = (((int) jumpTarget211)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 15);
		((self_in_dispatchConcretize->machineCode))[2] = (offset123 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset123) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset123) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset123) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpLessOrEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget121 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget121);
		if ((addressIsInInstructions(jumpTarget121))
		 || (jumpTarget121 == (methodLabel()))) {
			jumpTarget121 = ((AbstractInstruction *) ((jumpTarget121->address)));
		}
		assert(jumpTarget121 != 0);
		jumpTarget31 = jumpTarget121;
		offset33 = (((int) jumpTarget31)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset33)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 14);
			((self_in_dispatchConcretize->machineCode))[1] = (offset33 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget1112 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1112);
		if ((addressIsInInstructions(jumpTarget1112))
		 || (jumpTarget1112 == (methodLabel()))) {
			jumpTarget1112 = ((AbstractInstruction *) ((jumpTarget1112->address)));
		}
		assert(jumpTarget1112 != 0);
		jumpTarget212 = jumpTarget1112;
		offset124 = (((int) jumpTarget212)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 14);
		((self_in_dispatchConcretize->machineCode))[2] = (offset124 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset124) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset124) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset124) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpAbove:
	case JumpFPGreater:
		/* begin concretizeConditionalJump: */
		jumpTarget122 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget122);
		if ((addressIsInInstructions(jumpTarget122))
		 || (jumpTarget122 == (methodLabel()))) {
			jumpTarget122 = ((AbstractInstruction *) ((jumpTarget122->address)));
		}
		assert(jumpTarget122 != 0);
		jumpTarget32 = jumpTarget122;
		offset34 = (((int) jumpTarget32)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset34)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 7);
			((self_in_dispatchConcretize->machineCode))[1] = (offset34 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget1113 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1113);
		if ((addressIsInInstructions(jumpTarget1113))
		 || (jumpTarget1113 == (methodLabel()))) {
			jumpTarget1113 = ((AbstractInstruction *) ((jumpTarget1113->address)));
		}
		assert(jumpTarget1113 != 0);
		jumpTarget213 = jumpTarget1113;
		offset125 = (((int) jumpTarget213)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 7);
		((self_in_dispatchConcretize->machineCode))[2] = (offset125 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset125) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset125) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset125) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpBelowOrEqual:
	case JumpFPLessOrEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget123 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget123);
		if ((addressIsInInstructions(jumpTarget123))
		 || (jumpTarget123 == (methodLabel()))) {
			jumpTarget123 = ((AbstractInstruction *) ((jumpTarget123->address)));
		}
		assert(jumpTarget123 != 0);
		jumpTarget33 = jumpTarget123;
		offset35 = (((int) jumpTarget33)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset35)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 6);
			((self_in_dispatchConcretize->machineCode))[1] = (offset35 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget1114 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1114);
		if ((addressIsInInstructions(jumpTarget1114))
		 || (jumpTarget1114 == (methodLabel()))) {
			jumpTarget1114 = ((AbstractInstruction *) ((jumpTarget1114->address)));
		}
		assert(jumpTarget1114 != 0);
		jumpTarget214 = jumpTarget1114;
		offset126 = (((int) jumpTarget214)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 6);
		((self_in_dispatchConcretize->machineCode))[2] = (offset126 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset126) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset126) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset126) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpFPOrdered:
		/* begin concretizeConditionalJump: */
		jumpTarget124 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget124);
		if ((addressIsInInstructions(jumpTarget124))
		 || (jumpTarget124 == (methodLabel()))) {
			jumpTarget124 = ((AbstractInstruction *) ((jumpTarget124->address)));
		}
		assert(jumpTarget124 != 0);
		jumpTarget34 = jumpTarget124;
		offset36 = (((int) jumpTarget34)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset36)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 11);
			((self_in_dispatchConcretize->machineCode))[1] = (offset36 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget1115 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1115);
		if ((addressIsInInstructions(jumpTarget1115))
		 || (jumpTarget1115 == (methodLabel()))) {
			jumpTarget1115 = ((AbstractInstruction *) ((jumpTarget1115->address)));
		}
		assert(jumpTarget1115 != 0);
		jumpTarget215 = jumpTarget1115;
		offset127 = (((int) jumpTarget215)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 11);
		((self_in_dispatchConcretize->machineCode))[2] = (offset127 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset127) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset127) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset127) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case JumpFPUnordered:
		/* begin concretizeConditionalJump: */
		jumpTarget125 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget125);
		if ((addressIsInInstructions(jumpTarget125))
		 || (jumpTarget125 == (methodLabel()))) {
			jumpTarget125 = ((AbstractInstruction *) ((jumpTarget125->address)));
		}
		assert(jumpTarget125 != 0);
		jumpTarget35 = jumpTarget125;
		offset37 = (((int) jumpTarget35)) - (((int) (((self_in_dispatchConcretize->address)) + 2)));
		if ((((self_in_dispatchConcretize->machineCodeSize)) == 0
			? isQuick(self_in_dispatchConcretize, offset37)
			: ((self_in_dispatchConcretize->machineCodeSize)) == 2)) {
			((self_in_dispatchConcretize->machineCode))[0] = (112 + 10);
			((self_in_dispatchConcretize->machineCode))[1] = (offset37 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		/* begin concretizeConditionalJumpLong: */
		jumpTarget1116 = ((AbstractInstruction *) (((self_in_dispatchConcretize->operands))[0]));
		assertSaneJumpTarget(jumpTarget1116);
		if ((addressIsInInstructions(jumpTarget1116))
		 || (jumpTarget1116 == (methodLabel()))) {
			jumpTarget1116 = ((AbstractInstruction *) ((jumpTarget1116->address)));
		}
		assert(jumpTarget1116 != 0);
		jumpTarget216 = jumpTarget1116;
		offset128 = (((int) jumpTarget216)) - (((int) (((self_in_dispatchConcretize->address)) + 6)));
		((self_in_dispatchConcretize->machineCode))[0] = 15;
		((self_in_dispatchConcretize->machineCode))[1] = (128 + 10);
		((self_in_dispatchConcretize->machineCode))[2] = (offset128 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) offset128) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset128) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset128) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 6);
		return;

	case RetN:
		/* begin concretizeRetN */
		offset1 = ((self_in_dispatchConcretize->operands))[0];
		if (offset1 == 0) {
			((self_in_dispatchConcretize->machineCode))[0] = 195;
			((self_in_dispatchConcretize->machineCodeSize) = 1);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[0] = 194;
		((self_in_dispatchConcretize->machineCode))[1] = (offset1 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = (((usqInt) offset1) >> 8);
		((self_in_dispatchConcretize->machineCodeSize) = 3);
		return;

	case Stop:
		/* begin concretizeStop */
		((self_in_dispatchConcretize->machineCode))[0] = 204;
		((self_in_dispatchConcretize->machineCodeSize) = 1);
		return;

	case AddCqR:
		concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 0, 5);
		return;

	case AddCwR:
		concretizeArithCwR(self_in_dispatchConcretize, 3);
		return;

	case AddRR:
		concretizeOpRR(self_in_dispatchConcretize, 3);
		return;

	case AddRdRd:
		/* begin concretizeSEE2OpRdRd: */
		regRHS = ((self_in_dispatchConcretize->operands))[0];
		regLHS = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 88;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS, regLHS));
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case AndCqR:
		concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 4, 37);
		return;

	case AndCwR:
		concretizeArithCwR(self_in_dispatchConcretize, 35);
		return;

	case AndRR:
		concretizeOpRR(self_in_dispatchConcretize, 35);
		return;

	case TstCqR:
		/* begin concretizeTstCqR */
		value = ((self_in_dispatchConcretize->operands))[0];
		reg3 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg3));
		if (isQuick(self_in_dispatchConcretize, value)) {
			((self_in_dispatchConcretize->machineCode))[1] = 246;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg3, 0));
			((self_in_dispatchConcretize->machineCode))[3] = (value & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 4);
			return;
		}
		if (isSignExtendedFourByteValue(self_in_dispatchConcretize, value)) {
			if (reg3 == RAX) {
				((self_in_dispatchConcretize->machineCode))[1] = 169;
				((self_in_dispatchConcretize->machineCode))[2] = (value & 0xFF);
				((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) value) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) value) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) value) >> 24) & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = 6);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[1] = 247;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg3, 0));
			((self_in_dispatchConcretize->machineCode))[3] = (value & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) value) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) value) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) value) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		concretizeArithCwR(self_in_dispatchConcretize, 133);
		return;

	case CmpCqR:
		concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 7, 61);
		return;

	case CmpCwR:
		concretizeArithCwR(self_in_dispatchConcretize, 57);
		return;

	case CmpC32R:
		/* begin concretizeCmpC32R */
		value1 = ((self_in_dispatchConcretize->operands))[0];
		reg4 = ((self_in_dispatchConcretize->operands))[1];
		if (reg4 == RAX) {
			((self_in_dispatchConcretize->machineCode))[0] = 61;
			skip = 0;
		}
		else {
			if (reg4 > 7) {
				((self_in_dispatchConcretize->machineCode))[0] = 65;
				skip = 2;
			}
			else {
				skip = 1;
			}
			((self_in_dispatchConcretize->machineCode))[skip - 1] = 129;
			((self_in_dispatchConcretize->machineCode))[skip] = (modRMRO(self_in_dispatchConcretize, ModReg, reg4, 7));
		}
		((self_in_dispatchConcretize->machineCode))[skip + 1] = (value1 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip + 2] = ((((usqInt) value1) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip + 3] = ((((usqInt) value1) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip + 4] = ((((usqInt) value1) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 5 + skip);
		return;

	case CmpRR:
		concretizeReverseOpRR(self_in_dispatchConcretize, 57);
		return;

	case CmpRdRd:
		/* begin concretizeCmpRdRd */
		regRHS1 = ((self_in_dispatchConcretize->operands))[0];
		regLHS1 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 46;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS1, regLHS1));
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case DivRdRd:
		/* begin concretizeSEE2OpRdRd: */
		regRHS2 = ((self_in_dispatchConcretize->operands))[0];
		regLHS2 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 94;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS2, regLHS2));
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case MulRdRd:
		/* begin concretizeSEE2OpRdRd: */
		regRHS3 = ((self_in_dispatchConcretize->operands))[0];
		regLHS3 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 89;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS3, regLHS3));
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case OrCqR:
		concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 1, 13);
		return;

	case OrCwR:
		concretizeArithCwR(self_in_dispatchConcretize, 11);
		return;

	case OrRR:
		concretizeOpRR(self_in_dispatchConcretize, 11);
		return;

	case SubCqR:
		concretizeArithCqRWithROraxOpcode(self_in_dispatchConcretize, 5, 45);
		return;

	case SubCwR:
		concretizeArithCwR(self_in_dispatchConcretize, 43);
		return;

	case SubRR:
		concretizeOpRR(self_in_dispatchConcretize, 43);
		return;

	case SubRdRd:
		/* begin concretizeSEE2OpRdRd: */
		regRHS4 = ((self_in_dispatchConcretize->operands))[0];
		regLHS4 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 92;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, regRHS4, regLHS4));
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case SqrtRd:
		/* begin concretizeSqrtRd */
		reg5 = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 81;
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModReg, reg5, reg5));
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case XorCwR:
		concretizeArithCwR(self_in_dispatchConcretize, 51);
		return;

	case XorRR:
		concretizeOpRR(self_in_dispatchConcretize, 51);
		return;

	case NegateR:
		/* begin concretizeNegateR */
		reg6 = ((self_in_dispatchConcretize->operands))[0];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg6));
		((self_in_dispatchConcretize->machineCode))[1] = 247;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg6, 3));
		((self_in_dispatchConcretize->machineCodeSize) = 3);
		return;

	case LoadEffectiveAddressMwrR:
		/* begin concretizeLoadEffectiveAddressMwrR */
		offset2 = ((self_in_dispatchConcretize->operands))[0];
		srcReg = ((self_in_dispatchConcretize->operands))[1];
		destReg = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg, 0, srcReg));
		((self_in_dispatchConcretize->machineCode))[1] = 141;
		if ((srcReg != RSP)
		 && (srcReg != R12)) {
			if (isQuick(self_in_dispatchConcretize, offset2)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg, destReg));
				((self_in_dispatchConcretize->machineCode))[3] = (offset2 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = 4);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg, destReg));
			((self_in_dispatchConcretize->machineCode))[3] = (offset2 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset2) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset2) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset2) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		if (isQuick(self_in_dispatchConcretize, offset2)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg, destReg));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg));
			((self_in_dispatchConcretize->machineCode))[4] = (offset2 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 5);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg, destReg));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg));
		((self_in_dispatchConcretize->machineCode))[4] = (offset2 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset2) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset2) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset2) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 8);
		return;

	case RotateLeftCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance >= 1) && (distance <= 0x3F)));
		reg7 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg7));
		if (distance == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg7, 0));
			((self_in_dispatchConcretize->machineCodeSize) = 3);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg7, 0));
		((self_in_dispatchConcretize->machineCode))[3] = distance;
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case RotateRightCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance1 = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance1 >= 1) && (distance1 <= 0x3F)));
		reg8 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg8));
		if (distance1 == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg8, 1));
			((self_in_dispatchConcretize->machineCodeSize) = 3);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg8, 1));
		((self_in_dispatchConcretize->machineCode))[3] = distance1;
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case ArithmeticShiftRightCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance2 = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance2 >= 1) && (distance2 <= 0x3F)));
		reg9 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg9));
		if (distance2 == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg9, 7));
			((self_in_dispatchConcretize->machineCodeSize) = 3);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg9, 7));
		((self_in_dispatchConcretize->machineCode))[3] = distance2;
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case LogicalShiftRightCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance3 = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance3 >= 1) && (distance3 <= 0x3F)));
		reg10 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg10));
		if (distance3 == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg10, 5));
			((self_in_dispatchConcretize->machineCodeSize) = 3);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg10, 5));
		((self_in_dispatchConcretize->machineCode))[3] = distance3;
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case LogicalShiftLeftCqR:
		/* begin concretizeShiftCqRegOpcode: */
		distance4 = ((self_in_dispatchConcretize->operands))[0];
		assert(((distance4 >= 1) && (distance4 <= 0x3F)));
		reg11 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg11));
		if (distance4 == 1) {
			((self_in_dispatchConcretize->machineCode))[1] = 209;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg11, 4));
			((self_in_dispatchConcretize->machineCodeSize) = 3);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 193;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg11, 4));
		((self_in_dispatchConcretize->machineCode))[3] = distance4;
		((self_in_dispatchConcretize->machineCodeSize) = 4);
		return;

	case ArithmeticShiftRightRR:
		/* begin concretizeShiftRegRegOpcode: */
		shiftCountReg = ((self_in_dispatchConcretize->operands))[0];
		destReg1 = ((self_in_dispatchConcretize->operands))[1];
		if (shiftCountReg == RCX) {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, destReg1));
			((self_in_dispatchConcretize->machineCode))[1] = 211;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, destReg1, 7));
			((self_in_dispatchConcretize->machineCodeSize) = 3);
			return;
		}
		regToShift = (destReg1 == shiftCountReg
			? RCX
			: (destReg1 == RCX
					? shiftCountReg
					: destReg1));
		if (shiftCountReg == RAX) {
			((self_in_dispatchConcretize->machineCode))[0] = 72;
			((self_in_dispatchConcretize->machineCode))[1] = (144 + RCX);
			((self_in_dispatchConcretize->machineCode))[2] = (rexRxb(self_in_dispatchConcretize, 0, 0, regToShift));
			((self_in_dispatchConcretize->machineCode))[3] = 211;
			((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, regToShift, 7));
			((self_in_dispatchConcretize->machineCode))[5] = 72;
			((self_in_dispatchConcretize->machineCode))[6] = (144 + RCX);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, shiftCountReg, 0, RCX));
		((self_in_dispatchConcretize->machineCode))[1] = 135;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, RCX, shiftCountReg));
		((self_in_dispatchConcretize->machineCode))[3] = (rexRxb(self_in_dispatchConcretize, 0, 0, regToShift));
		((self_in_dispatchConcretize->machineCode))[4] = 211;
		((self_in_dispatchConcretize->machineCode))[5] = (modRMRO(self_in_dispatchConcretize, ModReg, regToShift, 7));
		((self_in_dispatchConcretize->machineCode))[6] = (rexRxb(self_in_dispatchConcretize, shiftCountReg, 0, RCX));
		((self_in_dispatchConcretize->machineCode))[7] = 135;
		((self_in_dispatchConcretize->machineCode))[8] = (modRMRO(self_in_dispatchConcretize, ModReg, RCX, shiftCountReg));
		((self_in_dispatchConcretize->machineCodeSize) = 9);
		return;

	case LogicalShiftLeftRR:
		/* begin concretizeShiftRegRegOpcode: */
		shiftCountReg1 = ((self_in_dispatchConcretize->operands))[0];
		destReg2 = ((self_in_dispatchConcretize->operands))[1];
		if (shiftCountReg1 == RCX) {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, destReg2));
			((self_in_dispatchConcretize->machineCode))[1] = 211;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, destReg2, 4));
			((self_in_dispatchConcretize->machineCodeSize) = 3);
			return;
		}
		regToShift1 = (destReg2 == shiftCountReg1
			? RCX
			: (destReg2 == RCX
					? shiftCountReg1
					: destReg2));
		if (shiftCountReg1 == RAX) {
			((self_in_dispatchConcretize->machineCode))[0] = 72;
			((self_in_dispatchConcretize->machineCode))[1] = (144 + RCX);
			((self_in_dispatchConcretize->machineCode))[2] = (rexRxb(self_in_dispatchConcretize, 0, 0, regToShift1));
			((self_in_dispatchConcretize->machineCode))[3] = 211;
			((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, regToShift1, 4));
			((self_in_dispatchConcretize->machineCode))[5] = 72;
			((self_in_dispatchConcretize->machineCode))[6] = (144 + RCX);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, shiftCountReg1, 0, RCX));
		((self_in_dispatchConcretize->machineCode))[1] = 135;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, RCX, shiftCountReg1));
		((self_in_dispatchConcretize->machineCode))[3] = (rexRxb(self_in_dispatchConcretize, 0, 0, regToShift1));
		((self_in_dispatchConcretize->machineCode))[4] = 211;
		((self_in_dispatchConcretize->machineCode))[5] = (modRMRO(self_in_dispatchConcretize, ModReg, regToShift1, 4));
		((self_in_dispatchConcretize->machineCode))[6] = (rexRxb(self_in_dispatchConcretize, shiftCountReg1, 0, RCX));
		((self_in_dispatchConcretize->machineCode))[7] = 135;
		((self_in_dispatchConcretize->machineCode))[8] = (modRMRO(self_in_dispatchConcretize, ModReg, RCX, shiftCountReg1));
		((self_in_dispatchConcretize->machineCodeSize) = 9);
		return;

	case MoveCqR:
		/* begin concretizeMoveCqR */
		value2 = ((self_in_dispatchConcretize->operands))[0];
		if (!(is32BitSignedImmediate(self_in_dispatchConcretize, value2))) {
			/* begin concretizeMoveCwR */
			value5 = ((self_in_dispatchConcretize->operands))[0];
			reg16 = ((self_in_dispatchConcretize->operands))[1];
			if ((addressIsInInstructions(((AbstractInstruction *) value5)))
			 || ((((AbstractInstruction *) value5)) == (methodLabel()))) {
				value5 = ((((AbstractInstruction *) value5))->address);
			}
			if (addressIsInCurrentCompilation(value5)) {
				offset14 = value5 - (((self_in_dispatchConcretize->address)) + 7);
				((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, reg16, 0, 0));
				((self_in_dispatchConcretize->machineCode))[1] = 141;
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 5, reg16));
				((self_in_dispatchConcretize->machineCode))[3] = (offset14 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset14) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset14) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset14) >> 24) & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = 7);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg16));
			((self_in_dispatchConcretize->machineCode))[1] = (184 + (reg16 & 7));
			((self_in_dispatchConcretize->machineCode))[2] = (value5 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) value5) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) value5) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) value5) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) value5) >> 32) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) value5) >> 40) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[8] = ((((usqInt) value5) >> 48) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[9] = ((((usqInt) value5) >> 56) & 0xFF);
			if (((self_in_dispatchConcretize->opcode)) == MoveCqR) {
				((self_in_dispatchConcretize->machineCodeSize) = 10);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[10] = 144;
			assert((modRMRO(self_in_dispatchConcretize, ModReg, 0, 0)) > 144);
			((self_in_dispatchConcretize->machineCodeSize) = 11);
			return;
		}
		reg12 = ((self_in_dispatchConcretize->operands))[1];
		if (value2 == 0) {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, reg12, 0, reg12));
			((self_in_dispatchConcretize->machineCode))[1] = 49;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg12, reg12));
			((self_in_dispatchConcretize->machineCodeSize) = 3);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg12));
		((self_in_dispatchConcretize->machineCode))[1] = 199;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg12, 0));
		((self_in_dispatchConcretize->machineCode))[3] = (value2 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) value2) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) value2) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) value2) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 7);
		return;

	case MoveCwR:
		/* begin concretizeMoveCwR */
		value6 = ((self_in_dispatchConcretize->operands))[0];
		reg17 = ((self_in_dispatchConcretize->operands))[1];
		if ((addressIsInInstructions(((AbstractInstruction *) value6)))
		 || ((((AbstractInstruction *) value6)) == (methodLabel()))) {
			value6 = ((((AbstractInstruction *) value6))->address);
		}
		if (addressIsInCurrentCompilation(value6)) {
			offset15 = value6 - (((self_in_dispatchConcretize->address)) + 7);
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, reg17, 0, 0));
			((self_in_dispatchConcretize->machineCode))[1] = 141;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 5, reg17));
			((self_in_dispatchConcretize->machineCode))[3] = (offset15 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset15) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset15) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset15) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg17));
		((self_in_dispatchConcretize->machineCode))[1] = (184 + (reg17 & 7));
		((self_in_dispatchConcretize->machineCode))[2] = (value6 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) value6) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) value6) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) value6) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) value6) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) value6) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = ((((usqInt) value6) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = ((((usqInt) value6) >> 56) & 0xFF);
		if (((self_in_dispatchConcretize->opcode)) == MoveCqR) {
			((self_in_dispatchConcretize->machineCodeSize) = 10);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[10] = 144;
		assert((modRMRO(self_in_dispatchConcretize, ModReg, 0, 0)) > 144);
		((self_in_dispatchConcretize->machineCodeSize) = 11);
		return;

	case MoveC32R:
		/* begin concretizeMoveC32R */
		value3 = ((self_in_dispatchConcretize->operands))[0];
		reg13 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg13));
		((self_in_dispatchConcretize->machineCode))[1] = 199;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModReg, reg13, 0));
		((self_in_dispatchConcretize->machineCode))[3] = (value3 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) value3) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) value3) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) value3) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 7);
		return;

	case MoveRR:
		concretizeReverseOpRR(self_in_dispatchConcretize, 137);
		return;

	case MoveAwR:
		/* begin concretizeMoveAwR */
		addressOperand = ((self_in_dispatchConcretize->operands))[0];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand)))
		 || ((((AbstractInstruction *) addressOperand)) == (methodLabel()))) {
			addressOperand = ((((AbstractInstruction *) addressOperand))->address);
		}
		if ((addressOperand != null)
		 && ((addressOperand >= (varBaseAddress()))
		 && ((addressOperand - (varBaseAddress())) < (1LL << 20)))) {
			save0 = ((self_in_dispatchConcretize->operands))[0];
			save1 = ((self_in_dispatchConcretize->operands))[1];
			((self_in_dispatchConcretize->operands))[0] = (addressOperand - (varBaseAddress()));
			((self_in_dispatchConcretize->operands))[1] = RBX;
			((self_in_dispatchConcretize->operands))[2] = save1;
			/* begin concretizeMoveMwrR */
			offset17 = ((self_in_dispatchConcretize->operands))[0];
			srcReg12 = ((self_in_dispatchConcretize->operands))[1];
			destReg13 = ((self_in_dispatchConcretize->operands))[2];
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg13, 0, srcReg12));
			((self_in_dispatchConcretize->machineCode))[1] = 139;
			if ((srcReg12 != RSP)
			 && (srcReg12 != R12)) {
				if ((offset17 == 0)
				 && ((srcReg12 != RBP)
				 && (srcReg12 != R13))) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg12, destReg13));
					(self_in_dispatchConcretize->machineCodeSize) = 3;
					goto l1;
				}
				if (isQuick(self_in_dispatchConcretize, offset17)) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg12, destReg13));
					((self_in_dispatchConcretize->machineCode))[3] = (offset17 & 0xFF);
					(self_in_dispatchConcretize->machineCodeSize) = 4;
					goto l1;
				}
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg12, destReg13));
				((self_in_dispatchConcretize->machineCode))[3] = (offset17 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset17) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset17) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset17) >> 24) & 0xFF);
				(self_in_dispatchConcretize->machineCodeSize) = 7;
				goto l1;
			}
			if (offset17 == 0) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg12, destReg13));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg12));
				(self_in_dispatchConcretize->machineCodeSize) = 4;
				goto l1;
			}
			if (isQuick(self_in_dispatchConcretize, offset17)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg12, destReg13));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg12));
				((self_in_dispatchConcretize->machineCode))[4] = (offset17 & 0xFF);
				(self_in_dispatchConcretize->machineCodeSize) = 5;
				goto l1;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg12, destReg13));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg12));
			((self_in_dispatchConcretize->machineCode))[4] = (offset17 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset17) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset17) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset17) >> 24) & 0xFF);
			(self_in_dispatchConcretize->machineCodeSize) = 8;
		l1:	/* end concretizeMoveMwrR */;
			((self_in_dispatchConcretize->operands))[0] = save0;
			((self_in_dispatchConcretize->operands))[1] = save1;
			((self_in_dispatchConcretize->operands))[2] = 0;
			(self_in_dispatchConcretize->machineCodeSize);
			return;
		}
		reg18 = ((self_in_dispatchConcretize->operands))[1];
		if (reg18 == RAX) {
			offset18 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg18));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg18 % 8));
			offset18 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset18] = 72;
		((self_in_dispatchConcretize->machineCode))[1 + offset18] = 161;
		((self_in_dispatchConcretize->machineCode))[2 + offset18] = (addressOperand & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset18] = ((((usqInt) addressOperand) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset18] = ((((usqInt) addressOperand) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset18] = ((((usqInt) addressOperand) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset18] = ((((usqInt) addressOperand) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset18] = ((((usqInt) addressOperand) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset18] = ((((usqInt) addressOperand) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9 + offset18] = ((((usqInt) addressOperand) >> 56) & 0xFF);
		if (reg18 == RAX) {
			((self_in_dispatchConcretize->machineCodeSize) = 10);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[13] = (((self_in_dispatchConcretize->machineCode))[1]);
		((self_in_dispatchConcretize->machineCodeSize) = 14);
		return;

	case MoveRAw:
		/* begin concretizeMoveRAw */
		reg19 = ((self_in_dispatchConcretize->operands))[0];
		addressOperand1 = ((self_in_dispatchConcretize->operands))[1];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand1)))
		 || ((((AbstractInstruction *) addressOperand1)) == (methodLabel()))) {
			addressOperand1 = ((((AbstractInstruction *) addressOperand1))->address);
		}
		if ((addressOperand1 != null)
		 && ((addressOperand1 >= (varBaseAddress()))
		 && ((addressOperand1 - (varBaseAddress())) < (1LL << 20)))) {
			save11 = ((self_in_dispatchConcretize->operands))[1];
			((self_in_dispatchConcretize->operands))[1] = (addressOperand1 - (varBaseAddress()));
			((self_in_dispatchConcretize->operands))[2] = RBX;
			/* begin concretizeMoveRMwr */
			srcReg13 = ((self_in_dispatchConcretize->operands))[0];
			offset110 = ((self_in_dispatchConcretize->operands))[1];
			destReg14 = ((self_in_dispatchConcretize->operands))[2];
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, srcReg13, 0, destReg14));
			((self_in_dispatchConcretize->machineCode))[1] = 137;
			if ((destReg14 != RSP)
			 && (destReg14 != R12)) {
				if ((offset110 == 0)
				 && ((destReg14 != RBP)
				 && (destReg14 != R13))) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg14, srcReg13));
					(self_in_dispatchConcretize->machineCodeSize) = 3;
					goto l2;
				}
				if (isQuick(self_in_dispatchConcretize, offset110)) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg14, srcReg13));
					((self_in_dispatchConcretize->machineCode))[3] = (offset110 & 0xFF);
					(self_in_dispatchConcretize->machineCodeSize) = 4;
					goto l2;
				}
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg14, srcReg13));
				((self_in_dispatchConcretize->machineCode))[3] = (offset110 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset110) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset110) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset110) >> 24) & 0xFF);
				(self_in_dispatchConcretize->machineCodeSize) = 7;
				goto l2;
			}
			if (offset110 == 0) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg14, srcReg13));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg14));
				(self_in_dispatchConcretize->machineCodeSize) = 4;
				goto l2;
			}
			if (isQuick(self_in_dispatchConcretize, offset110)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg14, srcReg13));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg14));
				((self_in_dispatchConcretize->machineCode))[4] = (offset110 & 0xFF);
				(self_in_dispatchConcretize->machineCodeSize) = 5;
				goto l2;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg14, srcReg13));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg14));
			((self_in_dispatchConcretize->machineCode))[4] = (offset110 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset110) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset110) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset110) >> 24) & 0xFF);
			(self_in_dispatchConcretize->machineCodeSize) = 8;
		l2:	/* end concretizeMoveRMwr */;
			((self_in_dispatchConcretize->operands))[1] = save11;
			((self_in_dispatchConcretize->operands))[2] = 0;
			(self_in_dispatchConcretize->machineCodeSize);
			return;
		}
		if (reg19 == RAX) {
			offset19 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg19));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg19 % 8));
			offset19 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset19] = 72;
		((self_in_dispatchConcretize->machineCode))[1 + offset19] = 163;
		((self_in_dispatchConcretize->machineCode))[2 + offset19] = (addressOperand1 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset19] = ((((usqInt) addressOperand1) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset19] = ((((usqInt) addressOperand1) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset19] = ((((usqInt) addressOperand1) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset19] = ((((usqInt) addressOperand1) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset19] = ((((usqInt) addressOperand1) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset19] = ((((usqInt) addressOperand1) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9 + offset19] = ((((usqInt) addressOperand1) >> 56) & 0xFF);
		if (reg19 == RAX) {
			((self_in_dispatchConcretize->machineCodeSize) = 10);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[13] = (((self_in_dispatchConcretize->machineCode))[1]);
		((self_in_dispatchConcretize->machineCodeSize) = 14);
		return;

	case MoveAbR:
		/* begin concretizeMoveAbR */
		addressOperand2 = ((self_in_dispatchConcretize->operands))[0];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand2)))
		 || ((((AbstractInstruction *) addressOperand2)) == (methodLabel()))) {
			addressOperand2 = ((((AbstractInstruction *) addressOperand2))->address);
		}
		if ((addressOperand2 != null)
		 && ((addressOperand2 >= (varBaseAddress()))
		 && ((addressOperand2 - (varBaseAddress())) < (1LL << 20)))) {
			save01 = ((self_in_dispatchConcretize->operands))[0];
			save12 = ((self_in_dispatchConcretize->operands))[1];
			((self_in_dispatchConcretize->operands))[0] = (addressOperand2 - (varBaseAddress()));
			((self_in_dispatchConcretize->operands))[1] = RBX;
			((self_in_dispatchConcretize->operands))[2] = save12;
			/* begin concretizeMoveMbrR */
			offset111 = ((self_in_dispatchConcretize->operands))[0];
			srcReg14 = ((self_in_dispatchConcretize->operands))[1];
			destReg15 = ((self_in_dispatchConcretize->operands))[2];
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg15, 0, srcReg14));
			((self_in_dispatchConcretize->machineCode))[1] = 138;
			if ((srcReg14 != RSP)
			 && (srcReg14 != R12)) {
				if ((offset111 == 0)
				 && ((srcReg14 != RBP)
				 && (srcReg14 != R13))) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg14, destReg15));
					(self_in_dispatchConcretize->machineCodeSize) = 3;
					goto l3;
				}
				if (isQuick(self_in_dispatchConcretize, offset111)) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg14, destReg15));
					((self_in_dispatchConcretize->machineCode))[3] = (offset111 & 0xFF);
					(self_in_dispatchConcretize->machineCodeSize) = 4;
					goto l3;
				}
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg14, destReg15));
				((self_in_dispatchConcretize->machineCode))[3] = (offset111 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset111) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset111) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset111) >> 24) & 0xFF);
				(self_in_dispatchConcretize->machineCodeSize) = 7;
				goto l3;
			}
			if (offset111 == 0) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg14, destReg15));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg14));
				(self_in_dispatchConcretize->machineCodeSize) = 4;
				goto l3;
			}
			if (isQuick(self_in_dispatchConcretize, offset111)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg14, destReg15));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg14));
				((self_in_dispatchConcretize->machineCode))[4] = (offset111 & 0xFF);
				(self_in_dispatchConcretize->machineCodeSize) = 5;
				goto l3;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg14, destReg15));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg14));
			((self_in_dispatchConcretize->machineCode))[4] = (offset111 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset111) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset111) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset111) >> 24) & 0xFF);
			(self_in_dispatchConcretize->machineCodeSize) = 8;
		l3:	/* end concretizeMoveMbrR */;
			((self_in_dispatchConcretize->operands))[0] = save01;
			((self_in_dispatchConcretize->operands))[1] = save12;
			((self_in_dispatchConcretize->operands))[2] = 0;
			(self_in_dispatchConcretize->machineCodeSize);
			return;
		}
		reg20 = ((self_in_dispatchConcretize->operands))[1];
		if (reg20 == RAX) {
			offset20 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg20));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg20 % 8));
			offset20 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset20] = 72;
		((self_in_dispatchConcretize->machineCode))[1 + offset20] = 160;
		((self_in_dispatchConcretize->machineCode))[2 + offset20] = (addressOperand2 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset20] = ((((usqInt) addressOperand2) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset20] = ((((usqInt) addressOperand2) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset20] = ((((usqInt) addressOperand2) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset20] = ((((usqInt) addressOperand2) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset20] = ((((usqInt) addressOperand2) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset20] = ((((usqInt) addressOperand2) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9 + offset20] = ((((usqInt) addressOperand2) >> 56) & 0xFF);
		if (reg20 == RAX) {
			((self_in_dispatchConcretize->machineCodeSize) = 10);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[13] = (((self_in_dispatchConcretize->machineCode))[1]);
		((self_in_dispatchConcretize->machineCodeSize) = 14);
		return;

	case MoveRAb:
		/* begin concretizeMoveRAb */
		reg21 = ((self_in_dispatchConcretize->operands))[0];
		addressOperand3 = ((self_in_dispatchConcretize->operands))[1];
		if ((addressIsInInstructions(((AbstractInstruction *) addressOperand3)))
		 || ((((AbstractInstruction *) addressOperand3)) == (methodLabel()))) {
			addressOperand3 = ((((AbstractInstruction *) addressOperand3))->address);
		}
		if ((addressOperand3 != null)
		 && ((addressOperand3 >= (varBaseAddress()))
		 && ((addressOperand3 - (varBaseAddress())) < (1LL << 20)))) {
			save13 = ((self_in_dispatchConcretize->operands))[1];
			((self_in_dispatchConcretize->operands))[1] = (addressOperand3 - (varBaseAddress()));
			((self_in_dispatchConcretize->operands))[2] = RBX;
			/* begin concretizeMoveRMbr */
			srcReg15 = ((self_in_dispatchConcretize->operands))[0];
			offset112 = ((self_in_dispatchConcretize->operands))[1];
			baseReg1 = ((self_in_dispatchConcretize->operands))[2];
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, srcReg15, 0, baseReg1));
			((self_in_dispatchConcretize->machineCode))[1] = 136;
			if ((baseReg1 != RSP)
			 && (baseReg1 != R12)) {
				if ((offset112 == 0)
				 && ((baseReg1 != RBP)
				 && (baseReg1 != R13))) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, baseReg1, srcReg15));
					(self_in_dispatchConcretize->machineCodeSize) = 3;
					goto l4;
				}
				if (isQuick(self_in_dispatchConcretize, offset112)) {
					((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, baseReg1, srcReg15));
					((self_in_dispatchConcretize->machineCode))[3] = (offset112 & 0xFF);
					(self_in_dispatchConcretize->machineCodeSize) = 4;
					goto l4;
				}
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, baseReg1, srcReg15));
				((self_in_dispatchConcretize->machineCode))[3] = (offset112 & 0xFF);
				((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset112) >> 8) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset112) >> 16) & 0xFF);
				((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset112) >> 24) & 0xFF);
				(self_in_dispatchConcretize->machineCodeSize) = 7;
				goto l4;
			}
			if (offset112 == 0) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, baseReg1, srcReg15));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg1));
				(self_in_dispatchConcretize->machineCodeSize) = 4;
				goto l4;
			}
			if (isQuick(self_in_dispatchConcretize, offset112)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, baseReg1, srcReg15));
				((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg1));
				((self_in_dispatchConcretize->machineCode))[4] = (offset112 & 0xFF);
				(self_in_dispatchConcretize->machineCodeSize) = 5;
				goto l4;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, baseReg1, srcReg15));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg1));
			((self_in_dispatchConcretize->machineCode))[4] = (offset112 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset112) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset112) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset112) >> 24) & 0xFF);
			(self_in_dispatchConcretize->machineCodeSize) = 8;
		l4:	/* end concretizeMoveRMbr */;
			((self_in_dispatchConcretize->operands))[1] = save13;
			((self_in_dispatchConcretize->operands))[2] = 0;
			(self_in_dispatchConcretize->machineCodeSize);
			return;
		}
		if (reg21 == RAX) {
			offset21 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, 0, 0, reg21));
			((self_in_dispatchConcretize->machineCode))[1] = (144 + (reg21 % 8));
			offset21 = 2;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset21] = 72;
		((self_in_dispatchConcretize->machineCode))[1 + offset21] = 162;
		((self_in_dispatchConcretize->machineCode))[2 + offset21] = (addressOperand3 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3 + offset21] = ((((usqInt) addressOperand3) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4 + offset21] = ((((usqInt) addressOperand3) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5 + offset21] = ((((usqInt) addressOperand3) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6 + offset21] = ((((usqInt) addressOperand3) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7 + offset21] = ((((usqInt) addressOperand3) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8 + offset21] = ((((usqInt) addressOperand3) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9 + offset21] = ((((usqInt) addressOperand3) >> 56) & 0xFF);
		if (reg21 == RAX) {
			((self_in_dispatchConcretize->machineCodeSize) = 10);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[12] = (((self_in_dispatchConcretize->machineCode))[0]);
		((self_in_dispatchConcretize->machineCode))[13] = (((self_in_dispatchConcretize->machineCode))[1]);
		((self_in_dispatchConcretize->machineCodeSize) = 14);
		return;

	case MoveMbrR:
		/* begin concretizeMoveMbrR */
		offset3 = ((self_in_dispatchConcretize->operands))[0];
		srcReg1 = ((self_in_dispatchConcretize->operands))[1];
		destReg3 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg3, 0, srcReg1));
		((self_in_dispatchConcretize->machineCode))[1] = 138;
		if ((srcReg1 != RSP)
		 && (srcReg1 != R12)) {
			if ((offset3 == 0)
			 && ((srcReg1 != RBP)
			 && (srcReg1 != R13))) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg1, destReg3));
				((self_in_dispatchConcretize->machineCodeSize) = 3);
				return;
			}
			if (isQuick(self_in_dispatchConcretize, offset3)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg1, destReg3));
				((self_in_dispatchConcretize->machineCode))[3] = (offset3 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = 4);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg1, destReg3));
			((self_in_dispatchConcretize->machineCode))[3] = (offset3 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset3) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset3) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset3) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		if (offset3 == 0) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg1, destReg3));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg1));
			((self_in_dispatchConcretize->machineCodeSize) = 4);
			return;
		}
		if (isQuick(self_in_dispatchConcretize, offset3)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg1, destReg3));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg1));
			((self_in_dispatchConcretize->machineCode))[4] = (offset3 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 5);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg1, destReg3));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg1));
		((self_in_dispatchConcretize->machineCode))[4] = (offset3 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset3) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset3) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset3) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 8);
		return;

	case MoveRMbr:
		/* begin concretizeMoveRMbr */
		srcReg2 = ((self_in_dispatchConcretize->operands))[0];
		offset4 = ((self_in_dispatchConcretize->operands))[1];
		baseReg = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, srcReg2, 0, baseReg));
		((self_in_dispatchConcretize->machineCode))[1] = 136;
		if ((baseReg != RSP)
		 && (baseReg != R12)) {
			if ((offset4 == 0)
			 && ((baseReg != RBP)
			 && (baseReg != R13))) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, baseReg, srcReg2));
				((self_in_dispatchConcretize->machineCodeSize) = 3);
				return;
			}
			if (isQuick(self_in_dispatchConcretize, offset4)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, baseReg, srcReg2));
				((self_in_dispatchConcretize->machineCode))[3] = (offset4 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = 4);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, baseReg, srcReg2));
			((self_in_dispatchConcretize->machineCode))[3] = (offset4 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset4) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset4) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset4) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		if (offset4 == 0) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, baseReg, srcReg2));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg));
			((self_in_dispatchConcretize->machineCodeSize) = 4);
			return;
		}
		if (isQuick(self_in_dispatchConcretize, offset4)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, baseReg, srcReg2));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg));
			((self_in_dispatchConcretize->machineCode))[4] = (offset4 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 5);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, baseReg, srcReg2));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, baseReg));
		((self_in_dispatchConcretize->machineCode))[4] = (offset4 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset4) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset4) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset4) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 8);
		return;

	case MoveM16rR:
		/* begin concretizeMoveM16rR */
		offset5 = ((self_in_dispatchConcretize->operands))[0];
		srcReg3 = ((self_in_dispatchConcretize->operands))[1];
		destReg4 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg4, 0, srcReg3));
		((self_in_dispatchConcretize->machineCode))[1] = 15;
		((self_in_dispatchConcretize->machineCode))[2] = 183;
		if ((srcReg3 != RSP)
		 && (srcReg3 != R12)) {
			if ((offset5 == 0)
			 && ((destReg4 != RBP)
			 && (destReg4 != R13))) {
				((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg3, destReg4));
				((self_in_dispatchConcretize->machineCodeSize) = 4);
				return;
			}
			if (isQuick(self_in_dispatchConcretize, offset5)) {
				((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg3, destReg4));
				((self_in_dispatchConcretize->machineCode))[4] = (offset5 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = 5);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg3, destReg4));
			((self_in_dispatchConcretize->machineCode))[4] = (offset5 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset5) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset5) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset5) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 8);
			return;
		}
		if ((offset5 == 0)
		 && ((destReg4 != RBP)
		 && (destReg4 != R13))) {
			((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg3, destReg4));
			((self_in_dispatchConcretize->machineCode))[4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg3));
			((self_in_dispatchConcretize->machineCodeSize) = 5);
			return;
		}
		if (isQuick(self_in_dispatchConcretize, offset5)) {
			((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg3, destReg4));
			((self_in_dispatchConcretize->machineCode))[4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg3));
			((self_in_dispatchConcretize->machineCode))[5] = (offset5 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 6);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg3, destReg4));
		((self_in_dispatchConcretize->machineCode))[4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg3));
		((self_in_dispatchConcretize->machineCode))[5] = (offset5 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset5) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset5) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = ((((usqInt) offset5) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 9);
		return;

	case MoveRM16r:
		/* begin concretizeMoveRM16r */
		srcReg4 = ((self_in_dispatchConcretize->operands))[0];
		offset6 = ((self_in_dispatchConcretize->operands))[1];
		destReg5 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		if ((srcReg4 > 7)
		 || (destReg5 > 7)) {
			((self_in_dispatchConcretize->machineCode))[1] = (rexwrxb(self_in_dispatchConcretize, 0, srcReg4, 0, destReg5));
			skip1 = 1;
		}
		else {
			skip1 = 0;
		}
		if ((destReg5 & 7) != RSP) {
			if (isQuick(self_in_dispatchConcretize, offset6)) {
				((self_in_dispatchConcretize->machineCode))[skip1 + 1] = 137;
				((self_in_dispatchConcretize->machineCode))[skip1 + 2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg5, srcReg4));
				((self_in_dispatchConcretize->machineCode))[skip1 + 3] = (offset6 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = skip1 + 4);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[skip1 + 1] = 137;
			((self_in_dispatchConcretize->machineCode))[skip1 + 2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg5, srcReg4));
			((self_in_dispatchConcretize->machineCode))[skip1 + 3] = (offset6 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[skip1 + 4] = ((((usqInt) offset6) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[skip1 + 5] = ((((usqInt) offset6) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[skip1 + 6] = ((((usqInt) offset6) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = skip1 + 7);
			return;
		}
		if (isQuick(self_in_dispatchConcretize, offset6)) {
			((self_in_dispatchConcretize->machineCode))[skip1 + 1] = 137;
			((self_in_dispatchConcretize->machineCode))[skip1 + 2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg5, srcReg4));
			((self_in_dispatchConcretize->machineCode))[skip1 + 3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg5));
			((self_in_dispatchConcretize->machineCode))[skip1 + 4] = (offset6 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = skip1 + 5);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[skip1 + 1] = 137;
		((self_in_dispatchConcretize->machineCode))[skip1 + 2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg5, srcReg4));
		((self_in_dispatchConcretize->machineCode))[skip1 + 3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg5));
		((self_in_dispatchConcretize->machineCode))[skip1 + 4] = (offset6 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip1 + 5] = ((((usqInt) offset6) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip1 + 6] = ((((usqInt) offset6) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip1 + 7] = ((((usqInt) offset6) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = skip1 + 8);
		return;

	case MoveM64rRd:
		/* begin concretizeMoveM64rRd */
		offset7 = ((self_in_dispatchConcretize->operands))[0];
		srcReg5 = ((self_in_dispatchConcretize->operands))[1];
		destReg6 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = 243;
		if ((srcReg5 <= 7)
		 && (destReg6 <= 7)) {
			skip2 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip2 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, destReg6, 0, srcReg5));
		}
		((self_in_dispatchConcretize->machineCode))[skip2 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip2 + 2] = 0x7E;
		if (offset7 == 0) {
			if ((srcReg5 & 6) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip2 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg5, destReg6));
				((self_in_dispatchConcretize->machineCodeSize) = skip2 + 4);
				return;
			}
			if ((srcReg5 & 7) == RSP) {

				/* RBP & R13 fall through */
				((self_in_dispatchConcretize->machineCode))[skip2 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg5, destReg6));
				((self_in_dispatchConcretize->machineCode))[skip2 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg5));
				((self_in_dispatchConcretize->machineCodeSize) = skip2 + 5);
				return;
			}
		}
		if (isQuick(self_in_dispatchConcretize, offset7)) {
			if ((srcReg5 & 7) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip2 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg5, destReg6));
				((self_in_dispatchConcretize->machineCode))[skip2 + 4] = (offset7 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = skip2 + 5);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[skip2 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg5, destReg6));
			((self_in_dispatchConcretize->machineCode))[skip2 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg5));
			((self_in_dispatchConcretize->machineCode))[skip2 + 5] = (offset7 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = skip2 + 6);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[skip2 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg5, destReg6));
		if ((srcReg5 & 7) == RSP) {
			((self_in_dispatchConcretize->machineCode))[skip2 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg5));
			skip2 += 1;
		}
		((self_in_dispatchConcretize->machineCode))[skip2 + 4] = (offset7 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip2 + 5] = ((((usqInt) offset7) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip2 + 6] = ((((usqInt) offset7) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip2 + 7] = ((((usqInt) offset7) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = skip2 + 8);
		return;

	case MoveMwrR:
		/* begin concretizeMoveMwrR */
		offset8 = ((self_in_dispatchConcretize->operands))[0];
		srcReg6 = ((self_in_dispatchConcretize->operands))[1];
		destReg7 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, destReg7, 0, srcReg6));
		((self_in_dispatchConcretize->machineCode))[1] = 139;
		if ((srcReg6 != RSP)
		 && (srcReg6 != R12)) {
			if ((offset8 == 0)
			 && ((srcReg6 != RBP)
			 && (srcReg6 != R13))) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg6, destReg7));
				((self_in_dispatchConcretize->machineCodeSize) = 3);
				return;
			}
			if (isQuick(self_in_dispatchConcretize, offset8)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg6, destReg7));
				((self_in_dispatchConcretize->machineCode))[3] = (offset8 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = 4);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg6, destReg7));
			((self_in_dispatchConcretize->machineCode))[3] = (offset8 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset8) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset8) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset8) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		if (offset8 == 0) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, srcReg6, destReg7));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg6));
			((self_in_dispatchConcretize->machineCodeSize) = 4);
			return;
		}
		if (isQuick(self_in_dispatchConcretize, offset8)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, srcReg6, destReg7));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg6));
			((self_in_dispatchConcretize->machineCode))[4] = (offset8 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 5);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, srcReg6, destReg7));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, srcReg6));
		((self_in_dispatchConcretize->machineCode))[4] = (offset8 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset8) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset8) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset8) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 8);
		return;

	case MoveXbrRR:
		/* begin concretizeMoveXbrRR */
		index = ((self_in_dispatchConcretize->operands))[0];
		base = ((self_in_dispatchConcretize->operands))[1];
		dest = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, dest, index, base));
		((self_in_dispatchConcretize->machineCode))[1] = 138;
		if ((base != RBP)
		 && (base != R13)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 4, dest));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, index, base));
			((self_in_dispatchConcretize->machineCodeSize) = 4);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, 4, dest));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, index, base));
		((self_in_dispatchConcretize->machineCode))[4] = 0;
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case MoveRXbrR:
		/* begin concretizeMoveRXbrR */
		src = ((self_in_dispatchConcretize->operands))[0];
		index1 = ((self_in_dispatchConcretize->operands))[1];
		base1 = ((self_in_dispatchConcretize->operands))[2];
		offset9 = 0;
		if ((src > 3)
		 || ((base1 > 7)
		 || (index1 > 7))) {
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, src, index1, base1));
			offset9 = 1;
		}
		((self_in_dispatchConcretize->machineCode))[0 + offset9] = 136;
		if ((base1 & 7) != RBP) {

			/* RBP,R13 */
			((self_in_dispatchConcretize->machineCode))[1 + offset9] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 4, src));
			((self_in_dispatchConcretize->machineCode))[2 + offset9] = (sib(self_in_dispatchConcretize, SIB1, index1, base1));
			((self_in_dispatchConcretize->machineCodeSize) = 3 + offset9);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[1 + offset9] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, 4, src));
		((self_in_dispatchConcretize->machineCode))[2 + offset9] = (sib(self_in_dispatchConcretize, SIB1, index1, base1));
		((self_in_dispatchConcretize->machineCode))[3 + offset9] = 0;
		((self_in_dispatchConcretize->machineCodeSize) = 4 + offset9);
		return;

	case MoveXwrRR:
		/* begin concretizeMoveXwrRR */
		index2 = ((self_in_dispatchConcretize->operands))[0];
		base2 = ((self_in_dispatchConcretize->operands))[1];
		dest1 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, dest1, index2, base2));
		if ((base2 != RBP)
		 && (base2 != R13)) {
			((self_in_dispatchConcretize->machineCode))[1] = 139;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 4, dest1));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB8, index2, base2));
			((self_in_dispatchConcretize->machineCodeSize) = 4);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 139;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, 4, dest1));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB8, index2, base2));
		((self_in_dispatchConcretize->machineCode))[4] = 0;
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case MoveRXwrR:
		/* begin concretizeMoveRXwrR */
		src1 = ((self_in_dispatchConcretize->operands))[0];
		index3 = ((self_in_dispatchConcretize->operands))[1];
		base3 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, src1, index3, base3));
		if ((base3 != RBP)
		 && (base3 != R13)) {
			((self_in_dispatchConcretize->machineCode))[1] = 137;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 4, src1));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB8, index3, base3));
			((self_in_dispatchConcretize->machineCodeSize) = 4);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[1] = 137;
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, 4, src1));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB8, index3, base3));
		((self_in_dispatchConcretize->machineCode))[4] = 0;
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case MoveX32rRR:
		concretizeMoveX32rRR(self_in_dispatchConcretize);
		return;

	case MoveRX32rR:
		concretizeMoveRX32rR(self_in_dispatchConcretize);
		return;

	case MoveRMwr:
		/* begin concretizeMoveRMwr */
		srcReg7 = ((self_in_dispatchConcretize->operands))[0];
		offset10 = ((self_in_dispatchConcretize->operands))[1];
		destReg8 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, srcReg7, 0, destReg8));
		((self_in_dispatchConcretize->machineCode))[1] = 137;
		if ((destReg8 != RSP)
		 && (destReg8 != R12)) {
			if ((offset10 == 0)
			 && ((destReg8 != RBP)
			 && (destReg8 != R13))) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg8, srcReg7));
				((self_in_dispatchConcretize->machineCodeSize) = 3);
				return;
			}
			if (isQuick(self_in_dispatchConcretize, offset10)) {
				((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg8, srcReg7));
				((self_in_dispatchConcretize->machineCode))[3] = (offset10 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = 4);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg8, srcReg7));
			((self_in_dispatchConcretize->machineCode))[3] = (offset10 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset10) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset10) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset10) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 7);
			return;
		}
		if (offset10 == 0) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg8, srcReg7));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg8));
			((self_in_dispatchConcretize->machineCodeSize) = 4);
			return;
		}
		if (isQuick(self_in_dispatchConcretize, offset10)) {
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg8, srcReg7));
			((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg8));
			((self_in_dispatchConcretize->machineCode))[4] = (offset10 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 5);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg8, srcReg7));
		((self_in_dispatchConcretize->machineCode))[3] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg8));
		((self_in_dispatchConcretize->machineCode))[4] = (offset10 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset10) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset10) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) offset10) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 8);
		return;

	case MoveRdM64r:
		/* begin concretizeMoveRdM64r */
		srcReg8 = ((self_in_dispatchConcretize->operands))[0];
		offset11 = ((self_in_dispatchConcretize->operands))[1];
		destReg9 = ((self_in_dispatchConcretize->operands))[2];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		if ((srcReg8 <= 7)
		 && (destReg9 <= 7)) {
			skip3 = 0;
		}
		else {
			((self_in_dispatchConcretize->machineCode))[(skip3 = 1)] = (rexwrxb(self_in_dispatchConcretize, 0, srcReg8, 0, destReg9));
		}
		((self_in_dispatchConcretize->machineCode))[skip3 + 1] = 15;
		((self_in_dispatchConcretize->machineCode))[skip3 + 2] = 214;
		if (offset11 == 0) {
			if ((destReg9 & 6) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip3 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg9, srcReg8));
				((self_in_dispatchConcretize->machineCodeSize) = skip3 + 4);
				return;
			}
			if ((destReg9 & 7) == RSP) {

				/* RBP & R13 fall through */
				((self_in_dispatchConcretize->machineCode))[skip3 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegInd, destReg9, srcReg8));
				((self_in_dispatchConcretize->machineCode))[skip3 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg9));
				((self_in_dispatchConcretize->machineCodeSize) = skip3 + 5);
				return;
			}
		}
		if (isQuick(self_in_dispatchConcretize, offset11)) {
			if ((destReg9 & 7) != RSP) {
				((self_in_dispatchConcretize->machineCode))[skip3 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg9, srcReg8));
				((self_in_dispatchConcretize->machineCode))[skip3 + 4] = (offset11 & 0xFF);
				((self_in_dispatchConcretize->machineCodeSize) = skip3 + 5);
				return;
			}
			((self_in_dispatchConcretize->machineCode))[skip3 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp8, destReg9, srcReg8));
			((self_in_dispatchConcretize->machineCode))[skip3 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg9));
			((self_in_dispatchConcretize->machineCode))[skip3 + 5] = (offset11 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = skip3 + 6);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[skip3 + 3] = (modRMRO(self_in_dispatchConcretize, ModRegRegDisp32, destReg9, srcReg8));
		if ((destReg9 & 7) == RSP) {
			((self_in_dispatchConcretize->machineCode))[skip3 + 4] = (sib(self_in_dispatchConcretize, SIB1, 4, destReg9));
			skip3 += 1;
		}
		((self_in_dispatchConcretize->machineCode))[skip3 + 4] = (offset11 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip3 + 5] = ((((usqInt) offset11) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip3 + 6] = ((((usqInt) offset11) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[skip3 + 7] = ((((usqInt) offset11) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = skip3 + 8);
		return;

	case MoveRdR:
		/* begin concretizeMoveRdR */
		srcReg9 = ((self_in_dispatchConcretize->operands))[0];
		destReg10 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		((self_in_dispatchConcretize->machineCode))[1] = (rexRxb(self_in_dispatchConcretize, srcReg9, 0, destReg10));
		((self_in_dispatchConcretize->machineCode))[2] = 15;
		((self_in_dispatchConcretize->machineCode))[3] = 0x7E;
		((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, destReg10, srcReg9));
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case MoveRRd:
		/* begin concretizeMoveRRd */
		srcReg10 = ((self_in_dispatchConcretize->operands))[0];
		destReg11 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 102;
		((self_in_dispatchConcretize->machineCode))[1] = (rexRxb(self_in_dispatchConcretize, destReg11, 0, srcReg10));
		((self_in_dispatchConcretize->machineCode))[2] = 15;
		((self_in_dispatchConcretize->machineCode))[3] = 110;
		((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg10, destReg11));
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case PopR:
		/* begin concretizePopR */
		reg14 = ((self_in_dispatchConcretize->operands))[0];
		if (reg14 < 8) {
			((self_in_dispatchConcretize->machineCode))[0] = (88 + reg14);
			((self_in_dispatchConcretize->machineCodeSize) = 1);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[0] = 65;
		((self_in_dispatchConcretize->machineCode))[1] = (88 + (reg14 - 8));
		((self_in_dispatchConcretize->machineCodeSize) = 2);
		return;

	case PushR:
		/* begin concretizePushR */
		reg15 = ((self_in_dispatchConcretize->operands))[0];
		if (reg15 < 8) {
			((self_in_dispatchConcretize->machineCode))[0] = (80 + reg15);
			((self_in_dispatchConcretize->machineCodeSize) = 1);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[0] = 65;
		((self_in_dispatchConcretize->machineCode))[1] = (80 + (reg15 - 8));
		((self_in_dispatchConcretize->machineCodeSize) = 2);
		return;

	case PushCq:
		/* begin concretizePushCq */
		value4 = ((self_in_dispatchConcretize->operands))[0];
		if (isQuick(self_in_dispatchConcretize, value4)) {
			((self_in_dispatchConcretize->machineCode))[0] = 106;
			((self_in_dispatchConcretize->machineCode))[1] = (value4 & 0xFF);
			((self_in_dispatchConcretize->machineCodeSize) = 2);
			return;
		}
		assert(isSignExtendedFourByteValue(self_in_dispatchConcretize, value4));
		((self_in_dispatchConcretize->machineCode))[0] = 104;
		((self_in_dispatchConcretize->machineCode))[1] = (value4 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[2] = ((((usqInt) value4) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) value4) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) value4) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	case PushCw:
		/* begin concretizePushCw */
		value7 = ((self_in_dispatchConcretize->operands))[0];
		if ((addressIsInInstructions(((AbstractInstruction *) value7)))
		 || ((((AbstractInstruction *) value7)) == (methodLabel()))) {
			value7 = ((((AbstractInstruction *) value7))->address);
		}
		if (addressIsInCurrentCompilation(value7)) {
			offset16 = value7 - (((self_in_dispatchConcretize->address)) + 7);
			((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, RISCTempReg, 0, 0));
			((self_in_dispatchConcretize->machineCode))[1] = 141;
			((self_in_dispatchConcretize->machineCode))[2] = (modRMRO(self_in_dispatchConcretize, ModRegInd, 5, RISCTempReg));
			((self_in_dispatchConcretize->machineCode))[3] = (offset16 & 0xFF);
			((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) offset16) >> 8) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) offset16) >> 16) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) offset16) >> 24) & 0xFF);
			((self_in_dispatchConcretize->machineCode))[7] = 65;
			((self_in_dispatchConcretize->machineCode))[8] = (72 + RISCTempReg);
			((self_in_dispatchConcretize->machineCodeSize) = 9);
			return;
		}
		((self_in_dispatchConcretize->machineCode))[0] = (rexRxb(self_in_dispatchConcretize, RISCTempReg, 0, RISCTempReg));
		((self_in_dispatchConcretize->machineCode))[1] = (184 + (RISCTempReg & 7));
		((self_in_dispatchConcretize->machineCode))[2] = (value7 & 0xFF);
		((self_in_dispatchConcretize->machineCode))[3] = ((((usqInt) value7) >> 8) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[4] = ((((usqInt) value7) >> 16) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[5] = ((((usqInt) value7) >> 24) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[6] = ((((usqInt) value7) >> 32) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[7] = ((((usqInt) value7) >> 40) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[8] = ((((usqInt) value7) >> 48) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[9] = ((((usqInt) value7) >> 56) & 0xFF);
		((self_in_dispatchConcretize->machineCode))[10] = 65;
		((self_in_dispatchConcretize->machineCode))[11] = (72 + RISCTempReg);
		assert(RISCTempReg >= 8);
		assert((modRMRO(self_in_dispatchConcretize, ModReg, 0, 0)) > 87);
		((self_in_dispatchConcretize->machineCodeSize) = 12);
		return;

	case PrefetchAw:
		concretizePrefetchAw(self_in_dispatchConcretize);
		return;

	case ConvertRRd:
		/* begin concretizeConvertRRd */
		srcReg11 = ((self_in_dispatchConcretize->operands))[0];
		destReg12 = ((self_in_dispatchConcretize->operands))[1];
		((self_in_dispatchConcretize->machineCode))[0] = 242;
		((self_in_dispatchConcretize->machineCode))[1] = (rexRxb(self_in_dispatchConcretize, destReg12, 0, srcReg11));
		((self_in_dispatchConcretize->machineCode))[2] = 15;
		((self_in_dispatchConcretize->machineCode))[3] = 42;
		((self_in_dispatchConcretize->machineCode))[4] = (modRMRO(self_in_dispatchConcretize, ModReg, srcReg11, destReg12));
		((self_in_dispatchConcretize->machineCodeSize) = 5);
		return;

	default:
		error("Case not found and no otherwise clause");
	}
	return;
}

	/* CogX64Compiler>>#fullCallsAreRelative */
static sqInt NoDbgRegParms
fullCallsAreRelative(AbstractInstruction * self_in_fullCallsAreRelative)
{
	return 0;
}

	/* CogX64Compiler>>#genDivR:R:Quo:Rem: */
static AbstractInstruction * NoDbgRegParms
genDivRRQuoRem(AbstractInstruction * self_in_genDivRRQuoRem, sqInt abstractRegDivisor, sqInt abstractRegDividend, sqInt abstractRegQuotient, sqInt abstractRegRemainder)
{
    sqInt rDividend;
    sqInt rDivisor;
    sqInt reg;
    sqInt rQuotient;
    sqInt rRemainder;
    sqInt rUnused;
    sqInt saveRestoreEAX;
    sqInt saveRestoreEDX;
    sqInt saveRestoreExchanged;

	assert(abstractRegDividend != abstractRegDivisor);
	assert(abstractRegQuotient != abstractRegRemainder);
	rDividend = abstractRegDividend;
	rDivisor = abstractRegDivisor;
	rQuotient = abstractRegQuotient;

	/* IDIV r does a signed divide of RDX:RAX by r, RAX := Quotient, RDX := Remainder.
	   Since we must sign extend the dividend into RDX we must substitute another register if RDX is an input. */
	rRemainder = abstractRegRemainder;
	if ((rDividend == RDX)
	 || (rDivisor == RDX)) {

		/* Slang, sigh... */
		rUnused = RAX;
		while (rUnused <= RDI) {
			if ((rUnused != RSP)
			 && ((rUnused != RBP)
			 && ((rUnused != RDX)
			 && ((rUnused != rDividend)
			 && ((rUnused != rDivisor)
			 && ((rUnused != rQuotient)
			 && (rUnused != rRemainder))))))) {
				/* begin PushR: */
				genoperand(PushR, rUnused);
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RDX, rUnused);
				if (rDividend == RDX) {
					genDivRRQuoRem(self_in_genDivRRQuoRem, rDivisor, rUnused, rQuotient, rRemainder);
				}
				else {
					genDivRRQuoRem(self_in_genDivRRQuoRem, rUnused, rDividend, rQuotient, rRemainder);
				}
				/* begin PopR: */
				genoperand(PopR, rUnused);
				return self_in_genDivRRQuoRem;
			}
			rUnused += 1;
		}
		error("couldn't find unused register in genDivR:R:Quo:Rem:");
	}
	if ((saveRestoreEAX = (rQuotient != RAX)
	 && (rRemainder != RAX))) {
		/* begin PushR: */
		genoperand(PushR, RAX);
	}
	if ((saveRestoreEDX = (rQuotient != RDX)
	 && (rRemainder != RDX))) {
		/* begin PushR: */
		genoperand(PushR, RDX);
	}
	saveRestoreExchanged = -1;
	if (rDividend != RAX) {
		if (rDivisor == RAX) {
			if (((rDividend != rQuotient)
			 && (rDividend != rRemainder))
			 && ((rDividend != RDX)
			 || (!saveRestoreEDX))) {
				/* begin PushR: */
				reg = (saveRestoreExchanged = rDividend);
				genoperand(PushR, reg);
			}
			genoperandoperand(XCHGRR, rDivisor, rDividend);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, rDividend, RAX);
		}
	}
	gen(CDQ);
	genoperand(IDIVR, (rDivisor == RAX
		? rDividend
		: rDivisor));
	if ((rQuotient == RDX)
	 && (rRemainder == RAX)) {
		genoperandoperand(XCHGRR, rQuotient, rRemainder);
	}
	else {
		if (rQuotient == RDX) {
			if (rRemainder != RDX) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RDX, rRemainder);
			}
			if (rQuotient != RAX) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RAX, rQuotient);
			}
		}
		else {
			if (rQuotient != RAX) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RAX, rQuotient);
			}
			if (rRemainder != RDX) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, RDX, rRemainder);
			}
		}
	}
	if (saveRestoreExchanged >= 0) {
		/* begin PopR: */
		genoperand(PopR, saveRestoreExchanged);
	}
	if (saveRestoreEDX) {
		/* begin PopR: */
		genoperand(PopR, RDX);
	}
	if (saveRestoreEAX) {
		/* begin PopR: */
		genoperand(PopR, RAX);
	}
	return self_in_genDivRRQuoRem;
}


/*	Load the stack pointer register with that of the C stack, effecting
	a switch to the C stack. Used when machine code calls into the
	CoInterpreter run-time (e.g. to invoke interpreter primitives). */

	/* CogX64Compiler>>#genLoadCStackPointer */
static sqInt NoDbgRegParms
genLoadCStackPointer(AbstractInstruction * self_in_genLoadCStackPointer)
{
    sqInt address;
    AbstractInstruction *anInstruction;

	/* begin MoveAw:R: */
	address = cStackPointerAddress();
	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveAwR, address, SPReg);
	return 0;
}


/*	Load the frame and stack pointer registers with those of the C stack,
	effecting a switch to the C stack. Used when machine code calls into
	the CoInterpreter run-time (e.g. to invoke interpreter primitives). */

	/* CogX64Compiler>>#genLoadCStackPointers */
static sqInt NoDbgRegParms
genLoadCStackPointers(AbstractInstruction * self_in_genLoadCStackPointers)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;

	/* begin MoveAw:R: */
	address = cStackPointerAddress();
	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveAwR, address, SPReg);
	/* begin MoveAw:R: */
	address1 = cFramePointerAddress();
	/* begin gen:literal:operand: */
	anInstruction1 = genoperandoperand(MoveAwR, address1, FPReg);
	return 0;
}


/*	Switch back to the Smalltalk stack. Assign SPReg first
	because typically it is used immediately afterwards. */

	/* CogX64Compiler>>#genLoadStackPointers */
static sqInt NoDbgRegParms
genLoadStackPointers(AbstractInstruction * self_in_genLoadStackPointers)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;

	/* begin MoveAw:R: */
	address = stackPointerAddress();
	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveAwR, address, SPReg);
	/* begin MoveAw:R: */
	address1 = framePointerAddress();
	/* begin gen:literal:operand: */
	anInstruction1 = genoperandoperand(MoveAwR, address1, FPReg);
	return 0;
}

	/* CogX64Compiler>>#genMulR:R: */
static AbstractInstruction * NoDbgRegParms
genMulRR(AbstractInstruction * self_in_genMulRR, sqInt regSource, sqInt regDest)
{
	return genoperandoperand(IMULRR, regSource, regDest);
}


/*	Ensure that the register args are pushed before the outer and
	inner retpcs at an entry miss for arity <= self numRegArgs. The
	outer retpc is that of a call at a send site. The inner is the call
	from a method or PIC abort/miss to the trampoline. */
/*	This won't be as clumsy on a RISC. But putting the receiver and
	args above the return address means the CoInterpreter has a
	single machine-code frame format which saves us a lot of work. */
/*	Iff there are register args convert
	base	->	outerRetpc		(send site retpc)
	sp		->	innerRetpc		(PIC abort/miss retpc)
	to
	base	->	receiver
	(arg0)
	(arg1)
	outerRetpc
	sp		->	innerRetpc		(PIC abort/miss retpc) */

	/* CogX64Compiler>>#genPushRegisterArgsForAbortMissNumArgs: */
static AbstractInstruction * NoDbgRegParms
genPushRegisterArgsForAbortMissNumArgs(AbstractInstruction * self_in_genPushRegisterArgsForAbortMissNumArgs, sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;

	if (numArgs <= 2) {
		assert((numRegArgs()) <= 2);
		if (numArgs == 0) {
			/* begin MoveMw:r:R: */
			anInstruction = genoperandoperandoperand(MoveMwrR, 0, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveMw:r:R: */
			anInstruction1 = genoperandoperandoperand(MoveMwrR, BytesPerWord * 2, SPReg, TempReg);
			/* begin MoveR:Mw:r: */
			anInstruction2 = genoperandoperandoperand(MoveRMwr, TempReg, BytesPerWord, SPReg);
			/* begin MoveR:Mw:r: */
			anInstruction3 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 2 * BytesPerWord, SPReg);
			return self_in_genPushRegisterArgsForAbortMissNumArgs;
		}
		if (numArgs == 1) {
			/* begin MoveMw:r:R: */
			anInstruction4 = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveMw:r:R: */
			anInstruction5 = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveR:Mw:r: */
			anInstruction6 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 3 * BytesPerWord, SPReg);
			/* begin MoveR:Mw:r: */
			anInstruction7 = genoperandoperandoperand(MoveRMwr, Arg0Reg, 2 * BytesPerWord, SPReg);
			return self_in_genPushRegisterArgsForAbortMissNumArgs;
		}
		if (numArgs == 2) {
			/* begin PushR: */
			genoperand(PushR, Arg1Reg);
			/* begin MoveMw:r:R: */
			anInstruction8 = genoperandoperandoperand(MoveMwrR, BytesPerWord * 2, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveMw:r:R: */
			anInstruction9 = genoperandoperandoperand(MoveMwrR, BytesPerWord * 2, SPReg, TempReg);
			/* begin PushR: */
			genoperand(PushR, TempReg);
			/* begin MoveR:Mw:r: */
			anInstruction10 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 4 * BytesPerWord, SPReg);
			/* begin MoveR:Mw:r: */
			anInstruction11 = genoperandoperandoperand(MoveRMwr, Arg0Reg, 3 * BytesPerWord, SPReg);
			return self_in_genPushRegisterArgsForAbortMissNumArgs;
		}
	}
	return self_in_genPushRegisterArgsForAbortMissNumArgs;
}


/*	Ensure that the register args are pushed before the retpc for arity <=
	self numRegArgs. This
	isn't as clumsy on a RISC. But putting the receiver and args above the
	return address
	means the CoInterpreter has a single machine-code frame format which saves
	us a lot of work.
	N.B. Take great care to /not/ smash TempReg, which is used in directed
	send marshalling.
	We could use XCHG to swap the ReceiverResultReg and top-of-stack return
	address, pushing the
	the ret pc (now in ReceiverResultReg) later, but XCHG is very slow. We can
	use SendNumArgsReg
	because it is only live in sends of arity >= (NumSendTrampolines - 1). */

	/* CogX64Compiler>>#genPushRegisterArgsForNumArgs:scratchReg: */
static AbstractInstruction * NoDbgRegParms
genPushRegisterArgsForNumArgsscratchReg(AbstractInstruction * self_in_genPushRegisterArgsForNumArgsscratchReg, sqInt numArgs, sqInt scratchReg)
{
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;

	assert((numRegArgs()) < (NumSendTrampolines - 1));
	if (numArgs <= 2) {
		assert((numRegArgs()) <= 2);
		
		/* a.k.a.
		   cogit gen: XCHGMwrR operand: 0 operand: SPReg operand: ReceiverResultReg.
		   but XCHG is slow. */
		/* begin MoveMw:r:R: */
		anInstruction2 = genoperandoperandoperand(MoveMwrR, 0, SPReg, scratchReg);
		/* begin MoveR:Mw:r: */
		anInstruction3 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 0, SPReg);
		if (numArgs > 0) {
			/* begin PushR: */
			genoperand(PushR, Arg0Reg);
			if (numArgs > 1) {
				/* begin PushR: */
				genoperand(PushR, Arg1Reg);
			}
		}
		/* begin PushR: */
		genoperand(PushR, scratchReg);

	}
	return self_in_genPushRegisterArgsForNumArgsscratchReg;
}


/*	This is a no-op on x64 since the ABI passes up to 6 args in registers and
	trampolines currently observe a limit of 4.
 */

	/* CogX64Compiler>>#genRemoveNArgsFromStack: */
static sqInt NoDbgRegParms
genRemoveNArgsFromStack(AbstractInstruction * self_in_genRemoveNArgsFromStack, sqInt n)
{
	assert(n <= 6);
	return 0;
}

	/* CogX64Compiler>>#genRestoreRegsExcept: */
static sqInt NoDbgRegParms
genRestoreRegsExcept(AbstractInstruction * self_in_genRestoreRegsExcept, sqInt preservedReg)
{
    AbstractInstruction *anInstruction;
    sqInt reg;

	assert(((R15 - RAX) + 1) == 16);
	for (reg = RAX; reg <= R15; reg += 1) {
		if (!(((reg >= RSP) && (reg <= RBP)))) {
			if (preservedReg == reg) {
				/* begin AddCq:R: */
				anInstruction = genoperandoperand(AddCqR, 8, RSP);
			}
			else {
				/* begin PopR: */
				genoperand(PopR, reg);
			}
		}
	}
	return 0;
}


/*	Restore the registers in regMask as saved by genSaveRegs:. */

	/* CogX64Compiler>>#genRestoreRegs: */
static sqInt NoDbgRegParms
genRestoreRegs(AbstractInstruction * self_in_genRestoreRegs, sqInt regMask)
{
    sqInt reg;

	assert(!((regMask & (registerMaskForand(RSP, RBP)))));
	for (reg = RAX; reg <= R15; reg += 1) {
		if (regMask & (1LL << reg)) {
			/* begin PopR: */
			genoperand(PopR, reg);
		}
	}
	return 0;
}


/*	Save the registers in regMask for a call into the C run-time from a
	trampoline. 
 */

	/* CogX64Compiler>>#genSaveRegs: */
static sqInt NoDbgRegParms
genSaveRegs(AbstractInstruction * self_in_genSaveRegs, sqInt regMask)
{
    sqInt reg;

	assert(((R15 - RAX) + 1) == 16);
	assert(!((regMask & (registerMaskForand(RSP, RBP)))));
	for (reg = R15; reg >= RAX; reg += -1) {
		if (regMask & (1LL << reg)) {
			/* begin PushR: */
			genoperand(PushR, reg);
		}
	}
	return 0;
}


/*	Save the frame and stack pointer registers to the framePointer
	and stackPointer variables. Used to save the machine code frame
	for use by the run-time when calling into the CoInterpreter run-time. */

	/* CogX64Compiler>>#genSaveStackPointers */
static sqInt NoDbgRegParms
genSaveStackPointers(AbstractInstruction * self_in_genSaveStackPointers)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;

	/* begin MoveR:Aw: */
	address = framePointerAddress();
	/* begin gen:operand:literal: */
	anInstruction = genoperandoperand(MoveRAw, FPReg, address);
	/* begin MoveR:Aw: */
	address1 = stackPointerAddress();
	/* begin gen:operand:literal: */
	anInstruction1 = genoperandoperand(MoveRAw, SPReg, address1);
	return 0;
}

	/* CogX64Compiler>>#genSubstituteReturnAddress: */
static AbstractInstruction * NoDbgRegParms
genSubstituteReturnAddress(AbstractInstruction * self_in_genSubstituteReturnAddress, sqInt retpc)
{
    AbstractInstruction *anInstruction;

	/* begin PushCw: */
	anInstruction = genoperand(PushCw, retpc);
	return anInstruction;
}


/*	Answer the instruction size at pc. This is used in method disassembly
	to decode the jumps in block dispatch to discover where block methods
	occur within a larger method. This is very far from a full decode. */

	/* CogX64Compiler>>#instructionSizeAt: */
static sqInt NoDbgRegParms
instructionSizeAt(AbstractInstruction * self_in_instructionSizeAt, sqInt pc)
{
    sqInt op;

	op = byteAt(pc);
	if ((op & 0xF8) == 72) {
		return 1 + (instructionSizeAt(self_in_instructionSizeAt, pc + 1));
	}
	
	switch (op) {
	case 15:
		return twoByteInstructionSizeAt(self_in_instructionSizeAt, pc);

	case 61:
	case 233:
		return 5;

	case 112:
	case 113:
	case 114:
	case 115:
	case 116:
	case 117:
	case 118:
	case 119:
	case 120:
	case 121:
	case 122:
	case 123:
	case 0x7C:
	case 125:
	case 0x7E:
	case 0x7F:
	case 137:
	case 235:
		return 2;

	case 131:
		return sizeImmediateGroup1at(self_in_instructionSizeAt, op, pc);

	case 139:
		return sizeHasModrmat(self_in_instructionSizeAt, op, pc);

	case 144:
	case 204:
		return 1;

	default:
		error("Case not found and no otherwise clause");
		return -1;
	}
}

	/* CogX64Compiler>>#is32BitSignedImmediate: */
static sqInt NoDbgRegParms
is32BitSignedImmediate(AbstractInstruction * self_in_is32BitSignedImmediate, sqInt a64BitUnsignedOperand)
{
	return (((int) a64BitUnsignedOperand)) == (((long) a64BitUnsignedOperand));
}


/*	Support for addressing variables off the dedicated VarBaseReg. Allow for
	1Mb of variables.
	The x64 supports 32-bit offsets, but we choose not to address everything
	from VarBaseReg. */

	/* CogX64Compiler>>#isAddressRelativeToVarBase: */
static sqInt NoDbgRegParms
isAddressRelativeToVarBase(AbstractInstruction * self_in_isAddressRelativeToVarBase, usqInt varAddress)
{
	return (varAddress != null)
	 && ((varAddress >= (varBaseAddress()))
	 && ((varAddress - (varBaseAddress())) < (1LL << 20)));
}


/*	Assuming mcpc is a send return pc answer if the instruction before it is a
	call (not a CallFull).
 */

	/* CogX64Compiler>>#isCallPrecedingReturnPC: */
static sqInt NoDbgRegParms
isCallPrecedingReturnPC(AbstractInstruction * self_in_isCallPrecedingReturnPC, sqInt mcpc)
{
	return (byteAt(mcpc - 5)) == 232;
}

	/* CogX64Compiler>>#isJumpAt: */
static sqInt NoDbgRegParms
isJumpAt(AbstractInstruction * self_in_isJumpAt, sqInt pc)
{
    sqInt op;

	op = byteAt(pc);
	return (((op >= 112) && (op <= 0x7F)))
	 || ((op == 233)
	 || ((op == 235)
	 || (((op == 15)
	 && ((((byteAt(pc + 1)) >= 128) && ((byteAt(pc + 1)) <= 143))))
	 || ((op == 72)
	 && (((byteAt(pc + 1)) == 161)
	 && (((byteAt(pc + 10)) == 0xFF)
	 && ((byteAt(pc + 11)) == 224)))))));
}

	/* CogX64Compiler>>#isQuick: */
static sqInt NoDbgRegParms
isQuick(AbstractInstruction * self_in_isQuick, unsigned long operand)
{
	return (((((sqLong) operand)) >= -128) && ((((sqLong) operand)) <= 0x7F));
}


/*	Top 32 bits all the same as the bottom 32 bits' sign bit implies we can
	use a sign-extended 4 byte offset. */

	/* CogX64Compiler>>#isSignExtendedFourByteValue: */
static sqInt NoDbgRegParms
isSignExtendedFourByteValue(AbstractInstruction * self_in_isSignExtendedFourByteValue, sqInt unsigned64BitValue)
{
	return (((((sqInt) unsigned64BitValue) >> 32) + 1) ^ 1) == ((((usqInt) unsigned64BitValue) >> 0x1F) & 1);
}


/*	Answer if an address can be accessed using the offset in a MoveMw:r:R: or
	similar instruction.
	We assume this is true for 32-bit processors and expect 64-bit processors
	to answer false
	for values in the interpreter or the object memory. Restrict our use of
	offsets to reference
	addresses within the method zone, rather than checking for a 32-bit
	offset, si as to keep the
	simulator and real VM in sync. */

	/* CogX64Compiler>>#isWithinMwOffsetRange: */
static sqInt NoDbgRegParms
isWithinMwOffsetRange(AbstractInstruction * self_in_isWithinMwOffsetRange, sqInt anAddress)
{
	return ((((usqInt)anAddress)) >= codeBase)
	 && (anAddress < limitAddress);
}


/*	Set the target of a jump instruction. These all have the target in the
	first operand. */
/*	Set the target of a jump instruction. These all have the target in the
	first operand.
	Override to cope with JumpFPNotEqual where because of IEEE NaN conformance
	and the behaviour of COMISD/UCOMISD we generate two jumps to the same
	target.  */

	/* CogX64Compiler>>#jmpTarget: */
static AbstractInstruction * NoDbgRegParms
jmpTarget(AbstractInstruction * self_in_jmpTarget, AbstractInstruction *anAbstractInstruction)
{
    AbstractInstruction *aDependent;

	aDependent = (self_in_jmpTarget->dependent);
	while (aDependent != null) {
		jmpTarget(aDependent, anAbstractInstruction);
		aDependent = (aDependent->dependent);
	}
	((self_in_jmpTarget->operands))[0] = (((usqInt)anAbstractInstruction));
	return anAbstractInstruction;
}


/*	Branch/Call ranges. Jump[Cond] can be generated as short as possible.
	Call/Jump[Cond]Long must be generated
	in the same number of bytes irrespective of displacement since their
	targets may be updated, but they need only
	span 16Mb, the maximum size of the code zone. This allows e.g. ARM to use
	single-word call and jump instructions
	for most calls and jumps. CallFull/JumpFull must also be generated in the
	same number of bytes irrespective of
	displacement for the same reason, but they must be able to span the full
	(32-bit or 64-bit) address space because
	they are used to call code in the C runtime, which may be distant from the
	code zone
 */

	/* CogX64Compiler>>#jumpLongByteSize */
static sqInt NoDbgRegParms
jumpLongByteSize(AbstractInstruction * self_in_jumpLongByteSize)
{
	return 5;
}

	/* CogX64Compiler>>#jumpLongConditionalByteSize */
static sqInt NoDbgRegParms
jumpLongConditionalByteSize(AbstractInstruction * self_in_jumpLongConditionalByteSize)
{
	return 6;
}


/*	Answer the target address for the long jump immediately preceding mcpc */

	/* CogX64Compiler>>#jumpLongTargetBeforeFollowingAddress: */
static sqInt NoDbgRegParms
jumpLongTargetBeforeFollowingAddress(AbstractInstruction * self_in_jumpLongTargetBeforeFollowingAddress, sqInt mcpc)
{
	return callTargetFromReturnAddress(self_in_jumpLongTargetBeforeFollowingAddress, mcpc);
}

	/* CogX64Compiler>>#jumpTargetPCAt: */
static usqInt NoDbgRegParms
jumpTargetPCAt(AbstractInstruction * self_in_jumpTargetPCAt, sqInt pc)
{
    sqInt byte;
    sqInt offset;
    sqInt size;

	size = instructionSizeAt(self_in_jumpTargetPCAt, pc);
	if (size == 2) {
		byte = byteAt(pc + 1);
		offset = ((byte & 128) == 0
			? byte
			: byte - 256);
	}
	else {
		byte = byteAt((pc + size) - 1);
		offset = ((byte & 128) == 0
			? byte
			: byte - 256);
		offset = (((long)offset) << 8) + (byteAt((pc + size) - 2));
		offset = (((long)offset) << 8) + (byteAt((pc + size) - 3));
		offset = (((long)offset) << 8) + (byteAt((pc + size) - 4));
	}
	return (pc + size) + offset;
}


/*	Answer the delta from the stack pointer after a call to the stack pointer
	immediately prior to the call. This is used to compute the stack pointer
	immediately prior to call from within a leaf routine, which in turn is
	used to capture the c stack pointer to use in trampolines back into the C
	run-time.  */

	/* CogX64Compiler>>#leafCallStackPointerDelta */
static sqInt NoDbgRegParms
leafCallStackPointerDelta(AbstractInstruction * self_in_leafCallStackPointerDelta)
{
	return 8;
}


/*	Answer the byte size of a MoveCwR opcode's corresponding machine code
	when the argument is a PIC. This is for the self-reference at the end of a
	closed PIC: leaq 0xffffffffffffff2b(%rip), %rcx : 48 8D 0D 2B FF FF FF */

	/* CogX64Compiler>>#loadPICLiteralByteSize */
static sqInt NoDbgRegParms
loadPICLiteralByteSize(AbstractInstruction * self_in_loadPICLiteralByteSize)
{
	return 7;
}

	/* CogX64Compiler>>#machineCodeAt: */
static usqInt NoDbgRegParms
machineCodeAt(AbstractInstruction * self_in_machineCodeAt, sqInt anOffset)
{
	return ((self_in_machineCodeAt->machineCode))[anOffset];
}


/*	Answer the maximum number of bytes of machine code generated for any
	abstract instruction.
	e.g. xchg %rdx, %rax; movq $0x12345678ABCDEF0, %(rax); xchg %rdx, %rax =>
	48 92 48 A3 F0 DE BC 9A 78 56 34 12 48 92
 */

	/* CogX64Compiler>>#machineCodeBytes */
static sqInt NoDbgRegParms
machineCodeBytes(AbstractInstruction * self_in_machineCodeBytes)
{
	return 14;
}


/*	See ModR/M byte & opcode syntax
	In addition to the notation shown above in 'Mnemonic Syntax' on page 43,
	the following notation indicates the size and type of operands in the
	syntax of an instruction opcode:
	/digit	Indicates that the ModRM byte specifies only one register or memory
	(r/m) operand.
	The digit is specified by the ModRM reg field and is used as an
	instruction-opcode extension.
	Valid digit values range from 0 to 7.
	/r		Indicates that the ModRM byte specifies both a register operand and a
	reg/mem (register or memory) operand. */

	/* CogX64Compiler>>#mod:RM:RO: */
static sqInt NoDbgRegParms
modRMRO(AbstractInstruction * self_in_modRMRO, sqInt mod, sqInt regMode, sqInt regOpcode)
{
	return ((((long)mod) << 6) + (((long)(regOpcode & 7)) << 3)) + (regMode & 7);
}

	/* CogX64Compiler>>#numIntRegArgs */
static sqInt NoDbgRegParms
numIntRegArgs(AbstractInstruction * self_in_numIntRegArgs)
{
	return 6;
}

	/* CogX64Compiler>>#padIfPossibleWithStopsFrom:to: */
static AbstractInstruction * NoDbgRegParms
padIfPossibleWithStopsFromto(AbstractInstruction * self_in_padIfPossibleWithStopsFromto, sqInt startAddr, sqInt endAddr)
{
	stopsFromto(self_in_padIfPossibleWithStopsFromto, startAddr, endAddr);
	return self_in_padIfPossibleWithStopsFromto;
}

	/* CogX64Compiler>>#relocateCallBeforeReturnPC:by: */
static AbstractInstruction * NoDbgRegParms
relocateCallBeforeReturnPCby(AbstractInstruction * self_in_relocateCallBeforeReturnPCby, sqInt retpc, sqInt delta)
{
    sqInt distance;

	if (delta != 0) {
		distance = (((((long)(byteAt(retpc - 1))) << 24) + (((long)(byteAt(retpc - 2))) << 16)) + (((long)(byteAt(retpc - 3))) << 8)) + (byteAt(retpc - 4));
		distance += delta;
		byteAtput(retpc - 1, (((usqInt) distance) >> 24) & 0xFF);
		byteAtput(retpc - 2, (((usqInt) distance) >> 16) & 0xFF);
		byteAtput(retpc - 3, (((usqInt) distance) >> 8) & 0xFF);
		byteAtput(retpc - 4, distance & 0xFF);
	}
	return self_in_relocateCallBeforeReturnPCby;
}


/*	We generate the method address using pc-relative addressing.
	Simply check that rip-relative addressing is being used. c.f.
	concretizeMoveCwR */

	/* CogX64Compiler>>#relocateMethodReferenceBeforeAddress:by: */
static AbstractInstruction * NoDbgRegParms
relocateMethodReferenceBeforeAddressby(AbstractInstruction * self_in_relocateMethodReferenceBeforeAddressby, sqInt pc, sqInt delta)
{
	assert((((byteAt(pc - 6)) == 141)
	 && (((byteAt(pc - 5)) | (modRMRO(self_in_relocateMethodReferenceBeforeAddressby, 0, 0, 7))) == (modRMRO(self_in_relocateMethodReferenceBeforeAddressby, ModRegInd, 5, 7))))
	 || (((byteAt(pc - 8)) == 141)
	 && (((byteAt(pc - 7)) | (modRMRO(self_in_relocateMethodReferenceBeforeAddressby, 0, 0, 7))) == (modRMRO(self_in_relocateMethodReferenceBeforeAddressby, ModRegInd, 5, 7)))));
	return self_in_relocateMethodReferenceBeforeAddressby;
}


/*	Rewrite a call instruction to call a different target. This variant is
	used to link PICs
	in ceSendMiss et al, and to rewrite cached primitive calls. Answer the
	extent of
	the code change which is used to compute the range of the icache to flush. */
/*	self cCode: ''
	inSmalltalk: [cogit disassembleFrom: callSiteReturnAddress - 10 to:
	callSiteReturnAddress - 1]. */

	/* CogX64Compiler>>#rewriteCallAt:target: */
static sqInt NoDbgRegParms
rewriteCallAttarget(AbstractInstruction * self_in_rewriteCallAttarget, usqInt callSiteReturnAddress, usqInt callTargetAddress)
{
    usqInt callDistance;

	if (!(callTargetAddress >= (minCallAddress()))) {
		error("linking callsite to invalid address");
	}

	callDistance = ((usqInt) (int)(callTargetAddress - callSiteReturnAddress));
	byteAtput(callSiteReturnAddress - 1, (((usqInt) callDistance) >> 24) & 0xFF);
	byteAtput(callSiteReturnAddress - 2, (((usqInt) callDistance) >> 16) & 0xFF);
	byteAtput(callSiteReturnAddress - 3, (((usqInt) callDistance) >> 8) & 0xFF);
	byteAtput(callSiteReturnAddress - 4, callDistance & 0xFF);
	assert((callTargetFromReturnAddress(self_in_rewriteCallAttarget, callSiteReturnAddress)) == callTargetAddress);
	return 5;
}


/*	Rewrite a CallFull instruction to call a different target. This variant is
	used to rewrite cached primitive calls.
	Answer the extent of the code change which is used to compute the range of
	the icache to flush.
	On x64 this is a rewrite of
	movq #64bits, %rax : 48 A1 b0 b1 b2 b3 b4 b5 b6 b7
	jmp %rax : FF E0 */

	/* CogX64Compiler>>#rewriteCallFullAt:target: */
static sqInt NoDbgRegParms
rewriteCallFullAttarget(AbstractInstruction * self_in_rewriteCallFullAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	assert((byteAt(callSiteReturnAddress - 12)) == 72);
	unalignedLongAtput(callSiteReturnAddress - 10, callTargetAddress);
	assert((((usqInt) (callFullTargetFromReturnAddress(self_in_rewriteCallFullAttarget, callSiteReturnAddress)))) == callTargetAddress);
	return 12;
}


/*	Rewrite the short jump instruction to jump to a new cpic case target. */

	/* CogX64Compiler>>#rewriteCPICJumpAt:target: */
static sqInt NoDbgRegParms
rewriteCPICJumpAttarget(AbstractInstruction * self_in_rewriteCPICJumpAttarget, usqInt addressFollowingJump, usqInt jumpTargetAddress)
{
    usqInt callDistance;

	callDistance = jumpTargetAddress - addressFollowingJump;
	assert((abs(callDistance)) < 128);
	byteAtput(addressFollowingJump - 1, callDistance & 0xFF);
	return 2;
}


/*	Rewrite an inline cache to call a different target for a new tag. This
	variant is used
	to link unlinked sends in ceSend:to:numArgs: et al. Answer the extent of
	the code
	change which is used to compute the range of the icache to flush.
	N.B. On 64-bit platforms the inline cache tag is only 32-bits wide, hence
	this code
	is identical to that for the IA32. */
/*	self cCode: ''
	inSmalltalk: [cogit disassembleFrom: callSiteReturnAddress - 12 to:
	callSiteReturnAddress - 1]. */

	/* CogX64Compiler>>#rewriteInlineCacheAt:tag:target: */
static sqInt NoDbgRegParms
rewriteInlineCacheAttagtarget(AbstractInstruction * self_in_rewriteInlineCacheAttagtarget, usqInt callSiteReturnAddress, sqInt cacheTag, usqInt callTargetAddress)
{
    usqInt callDistance;

	if (!(callTargetAddress >= (minCallAddress()))) {
		error("linking callsite to invalid address");
	}

	callDistance = ((usqInt) (int)(callTargetAddress - callSiteReturnAddress));
	byteAtput(callSiteReturnAddress - 1, (((usqInt) callDistance) >> 24) & 0xFF);
	byteAtput(callSiteReturnAddress - 2, (((usqInt) callDistance) >> 16) & 0xFF);
	byteAtput(callSiteReturnAddress - 3, (((usqInt) callDistance) >> 8) & 0xFF);
	byteAtput(callSiteReturnAddress - 4, callDistance & 0xFF);
	byteAtput(callSiteReturnAddress - 6, (((usqInt) cacheTag) >> 24) & 0xFF);
	byteAtput(callSiteReturnAddress - 7, (((usqInt) cacheTag) >> 16) & 0xFF);
	byteAtput(callSiteReturnAddress - 8, (((usqInt) cacheTag) >> 8) & 0xFF);
	byteAtput(callSiteReturnAddress - 9, cacheTag & 0xFF);
	assert((callTargetFromReturnAddress(self_in_rewriteInlineCacheAttagtarget, callSiteReturnAddress)) == callTargetAddress);
	return 12;
}


/*	Rewrite an inline cache with a new tag. This variant is used
	by the garbage collector. */

	/* CogX64Compiler>>#rewriteInlineCacheTag:at: */
static AbstractInstruction * NoDbgRegParms
rewriteInlineCacheTagat(AbstractInstruction * self_in_rewriteInlineCacheTagat, sqInt cacheTag, sqInt callSiteReturnAddress)
{
	unalignedLong32Atput(self_in_rewriteInlineCacheTagat, callSiteReturnAddress - 9, cacheTag);
	return self_in_rewriteInlineCacheTagat;
}


/*	Rewrite a JumpFull instruction to jump to a different target. This variant
	is used to rewrite cached primitive calls.
	Answer the extent of the code change which is used to compute the range of
	the icache to flush.
	On x64 this is a rewrite of
	movq #64bits, %rax : 48 A1 b0 b1 b2 b3 b4 b5 b6 b7
	jmp %rax : FF E0 */

	/* CogX64Compiler>>#rewriteJumpFullAt:target: */
static sqInt NoDbgRegParms
rewriteJumpFullAttarget(AbstractInstruction * self_in_rewriteJumpFullAttarget, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteCallFullAttarget(self_in_rewriteJumpFullAttarget, callSiteReturnAddress, callTargetAddress);
}


/*	<0-15> */
/*	<0-15> */
/*	<0-15> */

	/* CogX64Compiler>>#rexR:x:b: */
static sqInt NoDbgRegParms
rexRxb(AbstractInstruction * self_in_rexRxb, sqInt reg, sqInt sibReg, sqInt fieldReg)
{
	return rexwrxb(self_in_rexRxb, 1, reg, sibReg, fieldReg);
}


/*	<Boolean> */
/*	<0-15> */
/*	<0-15> */
/*	<0-15> */
/*	Given width64, the R register, sib register, and modrm/sib/reg field
	register, answer the correctly encoded REX prefix byte.
	See AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and
	System Instructions, Table 1-11 */

	/* CogX64Compiler>>#rexw:r:x:b: */
static sqInt NoDbgRegParms
rexwrxb(AbstractInstruction * self_in_rexwrxb, sqInt width64, sqInt reg, sqInt sibReg, sqInt fieldReg)
{
    sqInt regBits;

	regBits = ((((usqInt) (reg & 8)) >> 1) + (((usqInt) (sibReg & 8)) >> 2)) + (((usqInt) fieldReg) >> 3);
	return ((width64
	? 72
	: 64)) + regBits;
}


/*	to save Slang from having to be a real compiler (it can't inline switches
	that return)
 */
/*	Answer if the receiver's opcode sets the condition codes correctly for the
	given conditional jump opcode.
 */

	/* CogX64Compiler>>#setsConditionCodesFor: */
static sqInt NoDbgRegParms
setsConditionCodesFor(AbstractInstruction * self_in_setsConditionCodesFor, sqInt aConditionalJumpOpcode)
{
	
	switch ((self_in_setsConditionCodesFor->opcode)) {
	case ArithmeticShiftRightCqR:
	case ArithmeticShiftRightRR:
	case LogicalShiftLeftCqR:
	case LogicalShiftLeftRR:
		return ((aConditionalJumpOpcode >= JumpZero) && (aConditionalJumpOpcode <= JumpNonNegative));

	case XorRR:
		return 1;

	default:
		haltmsg("unhandled opcode in setsConditionCodesFor:");
		return 0;

	}
}

	/* CogX64Compiler>>#sizeHasModrm:at: */
static sqInt NoDbgRegParms
sizeHasModrmat(AbstractInstruction * self_in_sizeHasModrmat, sqInt op, sqInt pc)
{
    sqInt mod;
    sqInt modrm;
    sqInt rm;
    sqInt ro;

	modrm = byteAt(pc + 1);
	mod = ((usqInt) modrm) >> 6;
	ro = (((usqInt) modrm) >> 3) & 7;
	rm = modrm & 7;
	if (mod == 3) {
		return 2;
	}
	if (rm != 4) {

		/* no SIB byte */
		
		switch (mod) {
		case 0:
			return (rm == 5
				? 6
				: 3);

		case 1:
			return 3;

		case 2:
			return 6;

		default:
			error("Case not found and no otherwise clause");
			return -1;
		}
	}
	haltmsg("fall through in sizeHasModrm:at:");
	return 0;
}


/*	see [1] p A-7, p A-13 */

	/* CogX64Compiler>>#sizeImmediateGroup1:at: */
static sqInt NoDbgRegParms
sizeImmediateGroup1at(AbstractInstruction * self_in_sizeImmediateGroup1at, sqInt op, sqInt pc)
{
    sqInt mod;
    sqInt modrm;
    sqInt rm;
    sqInt ro;

	modrm = byteAt(pc + 1);
	mod = ((usqInt) modrm) >> 6;
	ro = (((usqInt) modrm) >> 3) & 7;
	rm = modrm & 7;
	
	switch (ro) {
	case 7:
		return (op == 129
			? 6
			: 3);

	default:
		error("Case not found and no otherwise clause");
		return -1;
	}
}

	/* CogX64Compiler>>#stopsFrom:to: */
static AbstractInstruction * NoDbgRegParms
stopsFromto(AbstractInstruction * self_in_stopsFromto, sqInt startAddr, sqInt endAddr)
{
    sqInt addr;

	for (addr = startAddr; addr <= endAddr; addr += 1) {
		byteAtput(addr, 204);
	}
	return self_in_stopsFromto;
}


/*	Rewrite the 32-bit literal in the instruction immediately preceding
	followingAddress. 
 */

	/* CogX64Compiler>>#storeLiteral32:beforeFollowingAddress: */
static AbstractInstruction * NoDbgRegParms
storeLiteral32beforeFollowingAddress(AbstractInstruction * self_in_storeLiteral32beforeFollowingAddress, sqInt literal, sqInt followingAddress)
{
	byteAtput(followingAddress - 1, (((usqInt) literal) >> 24) & 0xFF);
	byteAtput(followingAddress - 2, (((usqInt) literal) >> 16) & 0xFF);
	byteAtput(followingAddress - 3, (((usqInt) literal) >> 8) & 0xFF);
	byteAtput(followingAddress - 4, literal & 0xFF);
	return self_in_storeLiteral32beforeFollowingAddress;
}

	/* CogX64Compiler>>#s:i:b: */
static sqInt NoDbgRegParms
sib(AbstractInstruction * self_in_sib, sqInt scale, sqInt indexReg, sqInt baseReg)
{
	return ((((long)scale) << 6) + (((long)(indexReg & 7)) << 3)) + (baseReg & 7);
}

	/* CogX64Compiler>>#twoByteInstructionSizeAt: */
static sqInt NoDbgRegParms
twoByteInstructionSizeAt(AbstractInstruction * self_in_twoByteInstructionSizeAt, sqInt pc)
{
    sqInt op;

	op = byteAt(pc + 1);
	
	switch (op & 240) {
	case 128:
		
		/* long conditional jumps */
		return 6;

	default:
		error("Case not found and no otherwise clause");
		return -1;
	}
}


/*	Answer if Call and JumpLong are relative and hence need to take the
	caller's relocation delta into account during code compaction, rather than
	just the
	callee's delta. */

	/* CogX64Compiler>>#zoneCallsAreRelative */
static sqInt NoDbgRegParms
zoneCallsAreRelative(AbstractInstruction * self_in_zoneCallsAreRelative)
{
	return 1;
}


/*	Compile the jump instruction(s) at the end of the method that dispatch to
	each block body.
 */

	/* SimpleStackBasedCogit>>#compileBlockDispatch */
static sqInt
compileBlockDispatch(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSkip;

	assert(blockCount > 0);
	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
	blockEntryNoContextSwitch = anInstruction;
	/* begin Jump: */
	jumpSkip = genoperand(Jump, ((sqInt)0));
	/* begin MoveR:R: */
	blockEntryLabel = genoperandoperand(MoveRR, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jumpSkip, gLabel());
	if (blockCount > 1) {
		genLoadSlotsourceRegdestReg(ClosureStartPCIndex, ReceiverResultReg, TempReg);
	}
	compileBlockDispatchFromto(0, blockCount - 1);
	return 0;
}


/*	After pushing the temporaries but before the stack limit check a primitive
	method needs to fetch the error code, if any, and replace the last temp
	with it. */

	/* SimpleStackBasedCogit>>#compileGetErrorCode */
static void
compileGetErrorCode(void)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jmpGotError;
    AbstractInstruction *jmpIntError;
    AbstractInstruction *jmpNoError;
    sqInt primErrorTable;
    sqInt primErrorTableSize;

	/* begin MoveAw:R: */
	address = primFailCodeAddress();
	/* begin gen:literal:operand: */
	anInstruction2 = genoperandoperand(MoveAwR, address, TempReg);
	flag("ask concrete code gen if move sets condition codes?");
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
	/* begin JumpZero: */
	jmpNoError = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	primErrorTable = primErrTable();
	primErrorTableSize = lengthOf(primErrorTable);
	flag("use CmpCqR if pc mapping means stable contexts never contain native pcs");
	/* begin CmpCw:R: */
	anInstruction1 = genoperandoperand(CmpCwR, primErrorTableSize, TempReg);
	/* begin JumpAboveOrEqual: */
	jmpIntError = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	genFetchIndexRegisterfrominto(TempReg, primErrorTable, ClassReg);
	/* begin Jump: */
	jmpGotError = genoperand(Jump, ((sqInt)0));
	jmpTarget(jmpIntError, gLabel());
	genConvertIntegerToSmallIntegerInReg(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ClassReg);
	jmpTarget(jmpGotError, gMoveRMwr(ClassReg, 0, SPReg));
	/* begin MoveCq:R: */
	anInstruction3 = genoperandoperand(MoveCqR, 0, TempReg);
	/* begin MoveR:Aw: */
	address1 = primFailCodeAddress();
	/* begin gen:operand:literal: */
	anInstruction4 = genoperandoperand(MoveRAw, TempReg, address1);
	jmpTarget(jmpNoError, gLabel());
}


/*	Compile a call to an interpreter primitive. Call the C routine with the
	usual stack-switching dance, test the primFailCode and then either
	return on success or continue to the method body. */

	/* SimpleStackBasedCogit>>#compileInterpreterPrimitive: */
static sqInt NoDbgRegParms
compileInterpreterPrimitive(void (*primitiveRoutine)(void))
{
    sqInt address10;
    sqInt address11;
    sqInt address12;
    sqInt address13;
    sqInt address2;
    sqInt address3;
    sqInt address4;
    sqInt address7;
    sqInt address8;
    sqInt address9;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction14;
    AbstractInstruction *anInstruction15;
    AbstractInstruction *anInstruction16;
    AbstractInstruction *anInstruction17;
    AbstractInstruction *anInstruction18;
    AbstractInstruction *anInstruction19;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction20;
    AbstractInstruction *anInstruction21;
    AbstractInstruction *anInstruction22;
    AbstractInstruction *anInstruction23;
    AbstractInstruction *anInstruction24;
    AbstractInstruction *anInstruction26;
    AbstractInstruction *anInstruction27;
    AbstractInstruction *anInstruction28;
    AbstractInstruction *anInstruction29;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt callTarget;
    sqInt callTarget1;
    AbstractInstruction *continuePostSampleNonPrim;
    AbstractInstruction *continuePostSamplePrim;
    sqInt flags;
    AbstractInstruction *jmp;
    AbstractInstruction *jmpSampleNonPrim;
    AbstractInstruction *jmpSamplePrim;
    sqInt literal1;
    sqInt offset;
    sqInt offset1;
    sqInt offset2;
    sqInt reg;
    sqInt retpc;
    AbstractInstruction *retry;


	/* Save processor fp, sp and return pc in the interpreter's frame stack and instruction pointers */
	genExternalizePointersForPrimitiveCall();
	genLoadCStackPointersForPrimCall();
	flags = primitivePropertyFlags(primitiveIndex);
	if (flags & PrimCallDoNotJIT) {
		return ShouldNotJIT;
	}
	if (flags & PrimCallCollectsProfileSamples) {

		/* Test nextProfileTick for being non-zero and call checkProfileTick if so */
		/* begin MoveAw:R: */
		address2 = nextProfileTickAddress();
		/* begin gen:literal:operand: */
		anInstruction2 = genoperandoperand(MoveAwR, address2, TempReg);
		/* begin CmpCq:R: */
		anInstruction3 = genoperandoperand(CmpCqR, 0, TempReg);

		/* begin JumpNonZero: */
		jmpSampleNonPrim = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin Label */
		continuePostSampleNonPrim = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	if (recordPrimTrace()) {
		genFastPrimTraceUsingand(ClassReg, SendNumArgsReg);
	}
	/* begin MoveCq:R: */
	anInstruction21 = genoperandoperand(MoveCqR, 0, TempReg);
	retry = anInstruction21;
	/* begin MoveR:Aw: */
	address11 = primFailCodeAddress();
	/* begin gen:operand:literal: */
	anInstruction22 = genoperandoperand(MoveRAw, TempReg, address11);
	if (methodOrBlockNumArgs != 0) {
		/* begin MoveCq:R: */
		anInstruction4 = genoperandoperand(MoveCqR, methodOrBlockNumArgs, TempReg);
	}
	/* begin MoveR:Aw: */
	address12 = argumentCountAddress();
	/* begin gen:operand:literal: */
	anInstruction23 = genoperandoperand(MoveRAw, TempReg, address12);
	if (flags & PrimCallNeedsPrimitiveFunction) {
		/* begin MoveCw:R: */
		anInstruction5 = genoperandoperand(MoveCwR, ((sqInt)primitiveRoutine), TempReg);
		/* begin MoveR:Aw: */
		address3 = primitiveFunctionPointerAddress();
		/* begin gen:operand:literal: */
		anInstruction6 = genoperandoperand(MoveRAw, TempReg, address3);
		primSetFunctionLabel = anInstruction6;
	}
	if (flags & (PrimCallNeedsNewMethod + PrimCallMayCallBack)) {

		/* The ceActivateFailingPrimitiveMethod: machinery can't handle framelessness. */
		if (flags & PrimCallMayCallBack) {
			needsFrame = 1;
		}
		addDependent(methodLabel, annotateAbsolutePCRef(gMoveCwR(((sqInt)methodLabel), ClassReg)));
		/* begin MoveMw:r:R: */
		offset = offsetof(CogMethod, methodObject);
		/* begin gen:quickConstant:operand:operand: */
		anInstruction7 = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
		/* begin MoveR:Aw: */
		address4 = newMethodAddress();
		/* begin gen:operand:literal: */
		anInstruction8 = genoperandoperand(MoveRAw, TempReg, address4);
	}
	/* begin PrefetchAw: */
	address13 = primFailCodeAddress();
	/* begin gen:literal: */
	anInstruction24 = genoperand(PrefetchAw, address13);
	if (flags & PrimCallMayCallBack) {

		/* Sideways call the C primitive routine so that we return through cePrimReturnEnterCogCode. */
		/* On Spur ceActivateFailingPrimitiveMethod: would like to retry if forwarders
		   are found. So insist on PrimCallNeedsPrimitiveFunction being set too. */
		assert(flags & PrimCallNeedsPrimitiveFunction);
		/* begin genSubstituteReturnAddress: */
		retpc = (flags & PrimCallCollectsProfileSamples
			? cePrimReturnEnterCogCodeProfiling
			: cePrimReturnEnterCogCode);
		/* begin PushCw: */
		anInstruction9 = genoperand(PushCw, retpc);
		/* begin JumpFullRT: */
		/* begin JumpFull: */
		literal1 = ((sqInt)(((sqInt)primitiveRoutine)));
		anInstruction26 = genoperand(JumpFull, ((sqInt)(((sqInt)primitiveRoutine))));
		primInvokeInstruction = anInstruction26;

		jmp = (jmpSamplePrim = (continuePostSamplePrim = null));
	}
	else {

		/* Call the C primitive routine. */
		/* begin CallFullRT: */
		/* begin CallFull: */
		anInstruction27 = genoperand(CallFull, ((sqInt)primitiveRoutine));
		primInvokeInstruction = anInstruction27;

		if (flags & PrimCallCollectsProfileSamples) {
			assert(flags & PrimCallNeedsNewMethod);
			/* begin MoveAw:R: */
			address7 = nextProfileTickAddress();
			/* begin gen:literal:operand: */
			anInstruction12 = genoperandoperand(MoveAwR, address7, TempReg);
			/* begin CmpCq:R: */
			anInstruction13 = genoperandoperand(CmpCqR, 0, TempReg);

			/* begin JumpNonZero: */
			jmpSamplePrim = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
			/* begin Label */
			continuePostSamplePrim = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		maybeCompileRetryonPrimitiveFail(retry, primitiveIndex);
		maybeCompileAllocFillerCheck();
		/* begin MoveAw:R: */
		address8 = instructionPointerAddress();
		reg = ClassReg;
		/* begin gen:literal:operand: */
		anInstruction14 = genoperandoperand(MoveAwR, address8, reg);
		genLoadStackPointers(backEnd);
		/* begin MoveAw:R: */
		address9 = primFailCodeAddress();
		/* begin gen:literal:operand: */
		anInstruction15 = genoperandoperand(MoveAwR, address9, TempReg);
		/* begin PushR: */
		genoperand(PushR, ClassReg);

		flag("ask concrete code gen if move sets condition codes?");
		/* begin CmpCq:R: */
		anInstruction16 = genoperandoperand(CmpCqR, 0, TempReg);
		/* begin JumpNonZero: */
		jmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin MoveMw:r:R: */
		offset1 = BytesPerWord;
		/* begin gen:quickConstant:operand:operand: */
		anInstruction17 = genoperandoperandoperand(MoveMwrR, offset1, SPReg, ReceiverResultReg);
		/* begin RetN: */
		genoperand(RetN, BytesPerWord);
	}
	if (flags & PrimCallCollectsProfileSamples) {

		/* The sample is collected by cePrimReturnEnterCogCode for external calls */
		if (!(jmpSamplePrim == null)) {

			/* Call ceCheckProfileTick: to record sample and then continue. */
			jmpTarget(jmpSamplePrim, gLabel());
			assert(flags & PrimCallNeedsNewMethod);
			/* begin CallFullRT: */
			callTarget = ((unsigned long)ceCheckProfileTick);
			/* begin CallFull: */
			anInstruction28 = genoperand(CallFull, callTarget);

			/* begin Jump: */
			genoperand(Jump, ((sqInt)continuePostSamplePrim));
		}
		jmpTarget(jmpSampleNonPrim, gLabel());
		/* begin MoveCq:R: */
		anInstruction18 = genoperandoperand(MoveCqR, 0, TempReg);
		/* begin MoveR:Aw: */
		address10 = newMethodAddress();
		/* begin gen:operand:literal: */
		anInstruction19 = genoperandoperand(MoveRAw, TempReg, address10);
		/* begin CallFullRT: */
		callTarget1 = ((unsigned long)ceCheckProfileTick);
		/* begin CallFull: */
		anInstruction29 = genoperand(CallFull, callTarget1);

		/* begin Jump: */
		genoperand(Jump, ((sqInt)continuePostSampleNonPrim));
	}
	if (!(jmp == null)) {

		/* Jump to restore of receiver reg and proceed to frame build for failure. */
		jmpTarget(jmp, gLabel());
		/* begin MoveMw:r:R: */
		offset2 = BytesPerWord * (methodOrBlockNumArgs + (1));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction20 = genoperandoperandoperand(MoveMwrR, offset2, SPReg, ReceiverResultReg);
	}
	return 0;
}


/*	Compile one method cache probe in an OpenPIC's lookup of selector.
	Answer the jump taken if the selector probe fails. */

	/* SimpleStackBasedCogit>>#compileOpenPICMethodCacheProbeFor:withShift:baseRegOrNone: */
static AbstractInstruction * NoDbgRegParms
compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selector, sqInt shift, sqInt baseRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt offset1;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	annotateobjRef(gXorCwR(selector, ClassReg), selector);
	if ((shiftForWord()) > shift) {
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - shift, ClassReg);
	}
	/* begin AndCq:R: */
	anInstruction = genoperandoperand(AndCqR, ((long)MethodCacheMask) << (shiftForWord()), ClassReg);
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset = (((usqInt)(methodCacheAddress()))) + (((long)MethodCacheSelector) << (shiftForWord()));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction1 = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	}
	else {
		/* begin AddR:R: */
		genoperandoperand(AddRR, baseRegOrNone, ClassReg);
		/* begin MoveMw:r:R: */
		anInstruction2 = genoperandoperandoperand(MoveMwrR, ((long)MethodCacheSelector) << (shiftForWord()), ClassReg, TempReg);
	}
	annotateobjRef(gCmpCwR(selector, TempReg), selector);
	/* begin JumpNonZero: */
	jumpSelectorMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset1 = (((usqInt)(methodCacheAddress()))) + (((long)MethodCacheClass) << (shiftForWord()));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction3 = genoperandoperandoperand(MoveMwrR, offset1, ClassReg, TempReg);
	}
	else {
		/* begin MoveMw:r:R: */
		anInstruction4 = genoperandoperandoperand(MoveMwrR, ((long)MethodCacheClass) << (shiftForWord()), ClassReg, TempReg);
	}
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, SendNumArgsReg, TempReg);
	return jumpSelectorMiss;
}


/*	Compile the code for an open PIC. Perform a probe of the first-level
	method lookup cache followed by a call of ceSendFromInLineCacheMiss: if
	the probe fails. */

	/* SimpleStackBasedCogit>>#compileOpenPIC:numArgs: */
static void NoDbgRegParms
compileOpenPICnumArgs(sqInt selector, sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt quickConstant;
    sqInt reg;

	compilePICAbort(numArgs);
	entry = genGetClassTagOfintoscratchReg(ReceiverResultReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, SendNumArgsReg);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	if (!(isWithinMwOffsetRange(backEnd, methodCacheAddress()))) {
		/* begin MoveCq:R: */
		quickConstant = ((sqInt) (methodCacheAddress()));
		reg = (cacheBaseReg = Scratch0Reg);
		/* begin gen:quickConstant:operand: */
		anInstruction = genoperandoperand(MoveCqR, quickConstant, reg);
	}
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 0, cacheBaseReg);
	/* begin JumpNonZero: */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = (cacheBaseReg == NoReg
		? (((usqInt)(methodCacheAddress()))) + (((long)MethodCacheMethod) << (shiftForWord()))
		: ((long)MethodCacheMethod) << (shiftForWord()));
	/* begin gen:quickConstant:operand:operand: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	itsAHit = anInstruction1;
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	jmpTarget(jumpBCMethod, picInterpretAbort);
	/* begin AddCq:R: */
	anInstruction2 = genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	/* begin JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, gLabel()));
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 1, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, gLabel());
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 2, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, gLabel());
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);

	genSmalltalkToCStackSwitch(1);
	addDependent(methodLabel, annotateAbsolutePCRef(gMoveCwR(((sqInt)methodLabel), SendNumArgsReg)));
	compileCallFornumArgsargargargargresultRegregsToSave(ceSendFromInLineCacheMiss, 1, SendNumArgsReg, null, null, null, NoReg, 0);
}


/*	Compile one method cache probe in a perform: primitive's lookup of
	selector. Answer the jump taken if the selector probe fails. */

	/* SimpleStackBasedCogit>>#compilePerformMethodCacheProbeFor:withShift:baseRegOrNone: */
static AbstractInstruction * NoDbgRegParms
compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selectorReg, sqInt shift, sqInt baseRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt offset1;

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	/* begin XorR:R: */
	genoperandoperand(XorRR, selectorReg, ClassReg);
	if ((shiftForWord()) > shift) {
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - shift, ClassReg);
	}
	/* begin AndCq:R: */
	anInstruction = genoperandoperand(AndCqR, ((long)MethodCacheMask) << (shiftForWord()), ClassReg);
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset = (((usqInt)(methodCacheAddress()))) + (((long)MethodCacheSelector) << (shiftForWord()));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction1 = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	}
	else {
		/* begin AddR:R: */
		genoperandoperand(AddRR, baseRegOrNone, ClassReg);
		/* begin MoveMw:r:R: */
		anInstruction2 = genoperandoperandoperand(MoveMwrR, ((long)MethodCacheSelector) << (shiftForWord()), ClassReg, TempReg);
	}
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, selectorReg, TempReg);
	/* begin JumpNonZero: */
	jumpSelectorMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset1 = (((usqInt)(methodCacheAddress()))) + (((long)MethodCacheClass) << (shiftForWord()));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction3 = genoperandoperandoperand(MoveMwrR, offset1, ClassReg, TempReg);
	}
	else {
		/* begin MoveMw:r:R: */
		anInstruction4 = genoperandoperandoperand(MoveMwrR, ((long)MethodCacheClass) << (shiftForWord()), ClassReg, TempReg);
	}
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, SendNumArgsReg, TempReg);
	return jumpSelectorMiss;
}


/*	Compile a primitive. If possible, performance-critical primtiives will
	be generated by their own routines (primitiveGenerator). Otherwise,
	if there is a primitive at all, we call the C routine with the usual
	stack-switching dance, test the primFailCode and then either return
	on success or continue to the method body. */

	/* SimpleStackBasedCogit>>#compilePrimitive */
static sqInt
compilePrimitive(void)
{
    sqInt code;
    sqInt opcodeIndexAtPrimitive;
    PrimitiveDescriptor *primitiveDescriptor;
    void (*primitiveRoutine)(void);

	if (primitiveIndex == 0) {
		return 0;
	}

	/* Note opcodeIndex so that compileFallbackToInterpreterPrimitive:
	   can discard arg load instructions for unimplemented primitives. */
	code = 0;

	/* If a descriptor specifies an argument count (by numArgs >= 0) then it must match
	   for the generated code to be correct.  For example for speed many primitives use
	   ResultReceiverReg instead of accessing the stack, so the receiver better be at
	   numArgs down the stack.  Use the interpreter version if not. */
	opcodeIndexAtPrimitive = opcodeIndex;
	if ((((primitiveDescriptor = primitiveGeneratorOrNil())) != null)
	 && ((((primitiveDescriptor->primitiveGenerator)) != null)
	 && ((((primitiveDescriptor->primNumArgs)) < 0)
	 || (((primitiveDescriptor->primNumArgs)) == (argumentCountOf(methodObj)))))) {
		code = ((primitiveDescriptor->primitiveGenerator))();
	}
	if ((code < 0)
	 && (code != UnimplementedPrimitive)) {

		/* Generator failed, so no point continuing... */
		return code;
	}
	if (code == UnfailingPrimitive) {
		return 0;
	}
	if ((code == CompletePrimitive)
	 && (!(((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject(initialPC + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))))) {
		return 0;
	}
	if (code == UnimplementedPrimitive) {
		opcodeIndex = opcodeIndexAtPrimitive;
	}
	if ((((primitiveRoutine = functionPointerForCompiledMethodprimitiveIndex(methodObj, primitiveIndex))) == null)
	 || (primitiveRoutine == (functionPointerForinClass(0, null)))) {
		return genFastPrimFail();
	}
	minValidCallAddress = ((minValidCallAddress < (((usqInt)primitiveRoutine))) ? minValidCallAddress : (((usqInt)primitiveRoutine)));
	return compileInterpreterPrimitive(primitiveRoutine);
}

	/* SimpleStackBasedCogit>>#extendedPushBytecode */
static sqInt
extendedPushBytecode(void)
{
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt) byte1) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		return genPushReceiverVariable(variableIndex);
	}
	if (variableType == 1) {
		return genPushTemporaryVariable(variableIndex);
	}
	if (variableType == 2) {
		return genPushLiteralIndex(variableIndex);
	}
	return genPushLiteralVariable(variableIndex);
}

	/* SimpleStackBasedCogit>>#extendedStoreAndPopBytecode */
static sqInt
extendedStoreAndPopBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt) byte1) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		return genStorePopReceiverVariable(1, variableIndex);
	}
	if (variableType == 1) {
		genStorePopTemporaryVariable(1, variableIndex);
		
#    if IMMUTABILITY
		/* begin annotateBytecode: */
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction->annotation = HasBytecodePC);

#    endif /* IMMUTABILITY */

		return 0;
	}
	if (variableType == 3) {
		return genStorePopLiteralVariable(1, variableIndex);
	}
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#extendedStoreBytecode */
static sqInt
extendedStoreBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt) byte1) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		return genStorePopReceiverVariable(0, variableIndex);
	}
	if (variableType == 1) {
		genStorePopTemporaryVariable(0, variableIndex);
		
#    if IMMUTABILITY
		/* begin annotateBytecode: */
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction->annotation = HasBytecodePC);

#    endif /* IMMUTABILITY */

		return 0;
	}
	if (variableType == 3) {
		return genStorePopLiteralVariable(0, variableIndex);
	}
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#frameOffsetOfTemporary: */
static sqInt NoDbgRegParms
frameOffsetOfTemporary(sqInt index)
{
	return (index < methodOrBlockNumArgs
		? FoxCallerSavedIP + ((methodOrBlockNumArgs - index) * BytesPerWord)
		: (FoxMFReceiver - BytesPerWord) + ((methodOrBlockNumArgs - index) * BytesPerWord));
}


/*	Return from block, assuming result already loaded into ReceiverResultReg. */

	/* SimpleStackBasedCogit>>#genBlockReturn */
static sqInt
genBlockReturn(void)
{
	if (needsFrame) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, FPReg, SPReg);
		/* begin PopR: */
		genoperand(PopR, FPReg);
			}
	/* begin RetN: */
	genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	return 0;
}

	/* SimpleStackBasedCogit>>#genDoubleFailIfZeroArgRcvr:arg: */
static AbstractInstruction * NoDbgRegParms
genDoubleFailIfZeroArgRcvrarg(sqInt rcvrReg, sqInt argReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, TempReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, TempReg, DPFPReg2);
	/* begin CmpRd:Rd: */
	genoperandoperand(CmpRdRd, DPFPReg2, argReg);
	return gJumpFPEqual(0);
}


/*	Can use any of the first 32 literals for the selector and pass up to 7
	arguments. 
 */

	/* SimpleStackBasedCogit>>#genExtendedSendBytecode */
static sqInt
genExtendedSendBytecode(void)
{
	return genSendnumArgs(byte1 & 0x1F, ((usqInt) byte1) >> 5);
}

	/* SimpleStackBasedCogit>>#genExtendedSuperBytecode */
static sqInt
genExtendedSuperBytecode(void)
{
	return genSendSupernumArgs(byte1 & 0x1F, ((usqInt) byte1) >> 5);
}

	/* SimpleStackBasedCogit>>#genFastPrimFail */
static sqInt
genFastPrimFail(void)
{
	primitiveIndex = 0;
	return UnfailingPrimitive;
}


/*	Suport for compileInterpreterPrimitive. Generate inline code so as to
	record the primitive
	trace as fast as possible. */

	/* SimpleStackBasedCogit>>#genFastPrimTraceUsing:and: */
static void NoDbgRegParms
genFastPrimTraceUsingand(sqInt r1, sqInt r2)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    sqInt offset;
    sqInt wordConstant;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, r2);

	/* begin MoveAb:R: */
	address = primTraceLogIndexAddress();
	/* begin gen:literal:operand: */
	anInstruction1 = genoperandoperand(MoveAbR, address, r2);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, r2, r1);
	/* begin AddCq:R: */
	anInstruction2 = genoperandoperand(AddCqR, 1, r1);
	/* begin MoveR:Ab: */
	address1 = primTraceLogIndexAddress();
	/* begin gen:operand:literal: */
	anInstruction3 = genoperandoperand(MoveRAb, r1, address1);
	addDependent(methodLabel, annotateAbsolutePCRef(gMoveCwR(((sqInt)methodLabel), r1)));
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, selector);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction4 = genoperandoperandoperand(MoveMwrR, offset, r1, TempReg);
	/* begin MoveCw:R: */
	wordConstant = ((sqInt)(primTraceLogAddress()));
	/* begin gen:literal:operand: */
	anInstruction5 = genoperandoperand(MoveCwR, wordConstant, r1);
	/* begin MoveR:Xwr:R: */
	genoperandoperandoperand(MoveRXwrR, TempReg, r2, r1);
}

	/* SimpleStackBasedCogit>>#genLongJumpIfFalse */
static sqInt
genLongJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = v3LongForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}

	/* SimpleStackBasedCogit>>#genLongJumpIfTrue */
static sqInt
genLongJumpIfTrue(void)
{
    sqInt distance;
    sqInt target;

	distance = v3LongForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(trueObject(), target);
}


/*	237		11101101	i i i i i i i i	Pop and Store Temporary Variable #iiiiiiii */

	/* SimpleStackBasedCogit>>#genLongStoreAndPopTemporaryVariableBytecode */
static sqInt
genLongStoreAndPopTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(1, byte1);
}

	/* SimpleStackBasedCogit>>#genLongUnconditionalBackwardJump */
static sqInt
genLongUnconditionalBackwardJump(void)
{
    sqInt distance;
    sqInt targetpc;

	distance = v3LongBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	assert(distance < 0);
	targetpc = (distance + 2) + bytecodePC;
	return genJumpBackTo(targetpc);
}

	/* SimpleStackBasedCogit>>#genLongUnconditionalForwardJump */
static sqInt
genLongUnconditionalForwardJump(void)
{
    sqInt distance;
    sqInt targetpc;

	distance = v3LongBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	assert(distance >= 0);
	targetpc = (distance + 2) + bytecodePC;
	return genJumpTo(targetpc);
}


/*	Compile the code for a probe of the first-level method cache for a perform
	primtiive. The selector is assumed to be in Arg0Reg. Defer to
	adjustArgumentsForPerform: to
	adjust the arguments before the jump to the method. */

	/* SimpleStackBasedCogit>>#genLookupForPerformNumArgs: */
static sqInt NoDbgRegParms
genLookupForPerformNumArgs(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpInterpret;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt quickConstant;
    sqInt reg;


	/* N.B.  Can't assume TempReg already contains the tag because a method can
	   of course be invoked via the unchecked entry-point, e.g. as does perform:. */
	genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, SendNumArgsReg, 0);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	if (!(isWithinMwOffsetRange(backEnd, methodCacheAddress()))) {
		/* begin MoveCq:R: */
		quickConstant = ((sqInt) (methodCacheAddress()));
		reg = (cacheBaseReg = Scratch0Reg);
		/* begin gen:quickConstant:operand: */
		anInstruction1 = genoperandoperand(MoveCqR, quickConstant, reg);
	}
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 0, cacheBaseReg);
	/* begin JumpNonZero: */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = (cacheBaseReg == NoReg
		? (((usqInt)(methodCacheAddress()))) + (((long)MethodCacheMethod) << (shiftForWord()))
		: ((long)MethodCacheMethod) << (shiftForWord()));
	/* begin gen:quickConstant:operand:operand: */
	anInstruction2 = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	itsAHit = anInstruction2;
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);

	/* Adjust arguments and jump to the method's unchecked entry-point. */
	jumpInterpret = genJumpImmediate(ClassReg);
	/* begin AddCq:R: */
	anInstruction = genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	adjustArgumentsForPerform(numArgs);
	/* begin JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, gLabel()));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 1, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, gLabel());
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 1, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpInterpret, gLabel()));
	return 0;
}

	/* SimpleStackBasedCogit>>#genMoveFalseR: */
static AbstractInstruction * NoDbgRegParms
genMoveFalseR(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt constant;

	/* begin genMoveConstant:R: */
	constant = falseObject();
	return (shouldAnnotateObjectReference(constant)
		? annotateobjRef(gMoveCwR(constant, reg), constant)
		: (/* begin MoveCq:R: */
			(anInstruction = genoperandoperand(MoveCqR, constant, reg)),
			anInstruction));
}

	/* SimpleStackBasedCogit>>#genMoveTrueR: */
static AbstractInstruction * NoDbgRegParms
genMoveTrueR(sqInt reg)
{
    AbstractInstruction *anInstruction;
    sqInt constant;

	/* begin genMoveConstant:R: */
	constant = trueObject();
	return (shouldAnnotateObjectReference(constant)
		? annotateobjRef(gMoveCwR(constant, reg), constant)
		: (/* begin MoveCq:R: */
			(anInstruction = genoperandoperand(MoveCqR, constant, reg)),
			anInstruction));
}

	/* SimpleStackBasedCogit>>#genMustBeBooleanTrampolineFor:called: */
static sqInt NoDbgRegParms
genMustBeBooleanTrampolineForcalled(sqInt boolean, char *trampolineName)
{
    AbstractInstruction *anInstruction;

	zeroOpcodeIndex();
	assert(!(shouldAnnotateObjectReference(boolean)));
	/* begin AddCq:R: */
	anInstruction = genoperandoperand(AddCqR, boolean, TempReg);
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceSendMustBeBoolean, trampolineName, 1, TempReg, null, null, null, 0, 1, NoReg, 1);
}


/*	Generate the substitute return code for an external or FFI primitive call.
	On success simply return, extracting numArgs from newMethod.
	On primitive failure call ceActivateFailingPrimitiveMethod: newMethod. */

	/* SimpleStackBasedCogit>>#genPrimReturnEnterCogCodeEnilopmart: */
static void NoDbgRegParms
genPrimReturnEnterCogCodeEnilopmart(sqInt profiling)
{
    sqInt address2;
    sqInt address5;
    sqInt address6;
    sqInt address7;
    sqInt address8;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction14;
    AbstractInstruction *anInstruction15;
    AbstractInstruction *anInstruction16;
    AbstractInstruction *anInstruction17;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt callTarget;
    AbstractInstruction *continuePostSample;
    AbstractInstruction *jmpFail;
    AbstractInstruction *jmpSample;
    sqInt quickConstant;
    sqInt reg;

	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);

	if (profiling) {

		/* Test nextProfileTick for being non-zero and call checkProfileTick: if so.
		   N.B. nextProfileTick is 64-bits so 32-bit systems need to test both halves. */
		/* begin MoveAw:R: */
		address2 = nextProfileTickAddress();
		/* begin gen:literal:operand: */
		anInstruction3 = genoperandoperand(MoveAwR, address2, TempReg);
		/* begin CmpCq:R: */
		anInstruction4 = genoperandoperand(CmpCqR, 0, TempReg);

		/* begin JumpNonZero: */
		jmpSample = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		/* begin Label */
		continuePostSample = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	maybeCompileAllocFillerCheck();
	/* begin MoveAw:R: */
	address6 = primFailCodeAddress();
	/* begin gen:literal:operand: */
	anInstruction13 = genoperandoperand(MoveAwR, address6, TempReg);
	flag("ask concrete code gen if move sets condition codes?");
	/* begin CmpCq:R: */
	anInstruction14 = genoperandoperand(CmpCqR, 0, TempReg);
	/* begin JumpNonZero: */
	jmpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveAw:R: */
	address5 = instructionPointerAddress();
	/* begin gen:literal:operand: */
	anInstruction8 = genoperandoperand(MoveAwR, address5, ClassReg);
	genLoadStackPointers(backEnd);
	/* begin MoveMw:r:R: */
	anInstruction9 = genoperandoperandoperand(MoveMwrR, 0, SPReg, ReceiverResultReg);
	/* begin MoveR:Mw:r: */
	anInstruction10 = genoperandoperandoperand(MoveRMwr, ClassReg, 0, SPReg);
	/* begin RetN: */
	genoperand(RetN, 0);

	jmpTarget(jmpFail, gMoveAwR(newMethodAddress(), SendNumArgsReg));
	/* begin MoveAw:R: */
	address7 = cStackPointerAddress();
	/* begin gen:literal:operand: */
	anInstruction15 = genoperandoperand(MoveAwR, address7, SPReg);
	compileCallFornumArgsargargargargresultRegregsToSave(ceActivateFailingPrimitiveMethod, 1, SendNumArgsReg, null, null, null, NoReg, 0);
	/* begin MoveAw:R: */
	address8 = instructionPointerAddress();
	reg = ClassReg;
	/* begin gen:literal:operand: */
	anInstruction16 = genoperandoperand(MoveAwR, address8, reg);
	genLoadStackPointers(backEnd);
	/* begin MoveMw:r:R: */
	anInstruction12 = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, ReceiverResultReg);
	/* begin PushR: */
	genoperand(PushR, ClassReg);

	/* begin RetN: */
	genoperand(RetN, BytesPerWord);
	if (profiling) {

		/* Call ceCheckProfileTick: to record sample and then continue.  newMethod
		   should be up-to-date.  Need to save and restore the link reg around this call. */
		jmpTarget(jmpSample, gLabel());
		/* begin CallFullRT: */
		callTarget = (unsigned long)ceCheckProfileTick;
		/* begin CallFull: */
		anInstruction17 = genoperand(CallFull, callTarget);


		/* begin Jump: */
		genoperand(Jump, ((sqInt)continuePostSample));
	}
}


/*	SistaV1: 230		11100110	iiiiiiii		PushNClosureTemps iiiiiiii */

	/* SimpleStackBasedCogit>>#genPushClosureTempsBytecode */
static sqInt
genPushClosureTempsBytecode(void)
{
    sqInt i;

	for (i = 1; i <= byte1; i += 1) {
		genPushLiteral(nilObject());
	}
	return 0;
}

	/* SimpleStackBasedCogit>>#genPushConstantFalseBytecode */
static sqInt
genPushConstantFalseBytecode(void)
{
	return genPushLiteral(falseObject());
}

	/* SimpleStackBasedCogit>>#genPushConstantNilBytecode */
static sqInt
genPushConstantNilBytecode(void)
{
	return genPushLiteral(nilObject());
}

	/* SimpleStackBasedCogit>>#genPushConstantTrueBytecode */
static sqInt
genPushConstantTrueBytecode(void)
{
	return genPushLiteral(trueObject());
}

	/* SimpleStackBasedCogit>>#genPushLiteralConstantBytecode */
static sqInt
genPushLiteralConstantBytecode(void)
{
	return genPushLiteralIndex(byte0 & 0x1F);
}


/*	<SmallInteger> */

	/* SimpleStackBasedCogit>>#genPushLiteralIndex: */
static sqInt NoDbgRegParms
genPushLiteralIndex(sqInt literalIndex)
{
    sqInt literal;

	literal = getLiteral(literalIndex);
	return genPushLiteral(literal);
}

	/* SimpleStackBasedCogit>>#genPushLiteralVariableBytecode */
static sqInt
genPushLiteralVariableBytecode(void)
{
	return genPushLiteralVariable(byte0 & 0x1F);
}

	/* SimpleStackBasedCogit>>#genPushQuickIntegerConstantBytecode */
static sqInt
genPushQuickIntegerConstantBytecode(void)
{
	return genPushLiteral((((byte0 - 117) << 3) | 1));
}

	/* SimpleStackBasedCogit>>#genPushReceiverVariableBytecode */
static sqInt
genPushReceiverVariableBytecode(void)
{
	return genPushReceiverVariable(byte0 & 15);
}

	/* SimpleStackBasedCogit>>#genPushTemporaryVariableBytecode */
static sqInt
genPushTemporaryVariableBytecode(void)
{
	return genPushTemporaryVariable(byte0 & 15);
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnConst */
sqInt
genQuickReturnConst(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt constant;

	constant = quickPrimitiveConstantFor(primitiveIndex);
	annotateobjRef((isImmediate(constant)
		? (/* begin MoveCq:R: */
			(anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg)),
			anInstruction)
		: (/* begin MoveCw:R: */
			(anInstruction1 = genoperandoperand(MoveCwR, constant, ReceiverResultReg)),
			anInstruction1)), constant);
	genUpArrowReturn();
	return UnfailingPrimitive;
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnInstVar */
sqInt
genQuickReturnInstVar(void)
{
    sqInt index;

	index = quickPrimitiveInstVarIndexFor(primitiveIndex);
	genLoadSlotsourceRegdestReg(index, ReceiverResultReg, ReceiverResultReg);
	genUpArrowReturn();
	return UnfailingPrimitive;
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnSelf */
sqInt
genQuickReturnSelf(void)
{
	genUpArrowReturn();
	return UnfailingPrimitive;
}

	/* SimpleStackBasedCogit>>#genReturnFalse */
static sqInt
genReturnFalse(void)
{
    AbstractInstruction *anInstruction;
    sqInt constant;

	/* begin genMoveFalseR: */
	constant = falseObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, ReceiverResultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
	}
	return genUpArrowReturn();
}

	/* SimpleStackBasedCogit>>#genReturnNil */
static sqInt
genReturnNil(void)
{
    AbstractInstruction *anInstruction;
    sqInt constant;

	/* begin genMoveConstant:R: */
	constant = nilObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, ReceiverResultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
	}
	return genUpArrowReturn();
}

	/* SimpleStackBasedCogit>>#genReturnTrue */
static sqInt
genReturnTrue(void)
{
    AbstractInstruction *anInstruction;
    sqInt constant;

	/* begin genMoveTrueR: */
	constant = trueObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, ReceiverResultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
	}
	return genUpArrowReturn();
}


/*	Can use any of the first 64 literals for the selector and pass up to 3
	arguments. 
 */

	/* SimpleStackBasedCogit>>#genSecondExtendedSendBytecode */
static sqInt
genSecondExtendedSendBytecode(void)
{
	return genSendnumArgs(byte1 & 0x3F, ((usqInt) byte1) >> 6);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector0ArgsBytecode */
static sqInt
genSendLiteralSelector0ArgsBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 0);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector1ArgBytecode */
static sqInt
genSendLiteralSelector1ArgBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 1);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector2ArgsBytecode */
static sqInt
genSendLiteralSelector2ArgsBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 2);
}

	/* SimpleStackBasedCogit>>#genShortJumpIfFalse */
static sqInt
genShortJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}

	/* SimpleStackBasedCogit>>#genShortUnconditionalJump */
static sqInt
genShortUnconditionalJump(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpTo(target);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorSend */
static sqInt
genSpecialSelectorSend(void)
{
    sqInt index;
    sqInt numArgs;

	index = byte0 - (
#if MULTIPLEBYTECODESETS
	(bytecodeSetOffset == 256
		? AltFirstSpecialSelector + 256
		: FirstSpecialSelector)
#else /* MULTIPLEBYTECODESETS */
	FirstSpecialSelector
#endif /* MULTIPLEBYTECODESETS */
	);
	numArgs = specialSelectorNumArgs(index);
	return genSendnumArgs((-index) - 1, numArgs);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopReceiverVariableBytecode */
static sqInt
genStoreAndPopReceiverVariableBytecode(void)
{
	return genStorePopReceiverVariable(1, byte0 & 7);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopRemoteTempLongBytecode */
static sqInt
genStoreAndPopRemoteTempLongBytecode(void)
{
	return genStorePopRemoteTempAt(1, byte1, byte2);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopTemporaryVariableBytecode */
static sqInt
genStoreAndPopTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(1, byte0 & 7);
}

	/* SimpleStackBasedCogit>>#genStoreRemoteTempLongBytecode */
static sqInt
genStoreRemoteTempLongBytecode(void)
{
	return genStorePopRemoteTempAt(0, byte1, byte2);
}


/*	If allocCheckFiller is true, words in newSpace from freeStart to
	scavengeThreshold are filled with their address, and after each call of a
	plugin primitive, the VM checks
	that freeStart points to a word containing the value of freeStart. This is
	a simple
	check for primitives overwriting the ends of an object. */

	/* SimpleStackBasedCogit>>#maybeCompileAllocFillerCheck */
static void
maybeCompileAllocFillerCheck(void)
{
    sqInt address;
    sqInt address1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *jmpOk;

	if (getCheckAllocFiller()) {
		/* begin MoveAw:R: */
		address = freeStartAddress();
		/* begin gen:literal:operand: */
		anInstruction = genoperandoperand(MoveAwR, address, ClassReg);
		/* begin MoveMw:r:R: */
		anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, ClassReg, TempReg);
		/* begin CmpR:R: */
		genoperandoperand(CmpRR, ClassReg, TempReg);
		/* begin JumpZero: */
		jmpOk = genConditionalBranchoperand(JumpZero, ((sqInt)0));
		/* begin MoveCq:R: */
		anInstruction2 = genoperandoperand(MoveCqR, PrimErrWritePastObject, TempReg);
		/* begin MoveR:Aw: */
		address1 = primFailCodeAddress();
		/* begin gen:operand:literal: */
		anInstruction3 = genoperandoperand(MoveRAw, TempReg, address1);
		jmpTarget(jmpOk, gLabel());
	}
}

	/* SimpleStackBasedCogit>>#numSpecialSelectors */
static sqInt
numSpecialSelectors(void)
{
	return 
#  if MULTIPLEBYTECODESETS
		(bytecodeSetOffset == 256
				? AltNumSpecialSelectors
				: NumSpecialSelectors)
#  else /* MULTIPLEBYTECODESETS */
		NumSpecialSelectors
#  endif /* MULTIPLEBYTECODESETS */
		;
}


/*	If there is a generator for the current primitive then answer it;
	otherwise answer nil. */

	/* SimpleStackBasedCogit>>#primitiveGeneratorOrNil */
static PrimitiveDescriptor *
primitiveGeneratorOrNil(void)
{
    PrimitiveDescriptor *primitiveDescriptor;
    static PrimitiveDescriptor primitiveGeneratorTable[MaxCompiledPrimitiveIndex+1] = {
	{ 0, -1 },
	{ genPrimitiveAdd, 1 },
	{ genPrimitiveSubtract, 1 },
	{ genPrimitiveLessThan, 1 },
	{ genPrimitiveGreaterThan, 1 },
	{ genPrimitiveLessOrEqual, 1 },
	{ genPrimitiveGreaterOrEqual, 1 },
	{ genPrimitiveEqual, 1 },
	{ genPrimitiveNotEqual, 1 },
	{ genPrimitiveMultiply, 1 },
	{ genPrimitiveDivide, 1 },
	{ genPrimitiveMod, 1 },
	{ genPrimitiveDiv, 1 },
	{ genPrimitiveQuo, 1 },
	{ genPrimitiveBitAnd, 1 },
	{ genPrimitiveBitOr, 1 },
	{ genPrimitiveBitXor, 1 },
	{ genPrimitiveBitShift, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveAsFloat, 0 },
	{ genPrimitiveFloatAdd, 1 },
	{ genPrimitiveFloatSubtract, 1 },
	{ genPrimitiveFloatLessThan, 1 },
	{ genPrimitiveFloatGreaterThan, 1 },
	{ genPrimitiveFloatLessOrEqual, 1 },
	{ genPrimitiveFloatGreaterOrEqual, 1 },
	{ genPrimitiveFloatEqual, 1 },
	{ genPrimitiveFloatNotEqual, 1 },
	{ genPrimitiveFloatMultiply, 1 },
	{ genPrimitiveFloatDivide, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveFloatSquareRoot, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveAt, 1 },
	{ genPrimitiveAtPut, 2 },
	{ genPrimitiveSize, 0 },
	{ genPrimitiveStringAt, 1 },
	{ genPrimitiveStringAtPut, 2 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ genPrimitiveObjectAt, 1 },
	{ 0, -1 },
	{ genPrimitiveNew, 0 },
	{ genPrimitiveNewWithArg, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentityHash, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveNewMethod, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitivePerform, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentical, 1 },
	{ genPrimitiveClass, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveNotIdentical, 1 },
	{ genPrimitiveAsCharacter, -1 },
	{ genPrimitiveImmediateAsInteger, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentityHash, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ 0, -1 },
	{ genPrimitiveClosureValue, 0 },
	{ genPrimitiveClosureValue, 1 },
	{ genPrimitiveClosureValue, 2 },
	{ genPrimitiveClosureValue, 3 },
	{ genPrimitiveClosureValue, 4 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveClosureValue, 0 },
	{ genPrimitiveClosureValue, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveSmallFloatAdd, 1 },
	{ genPrimitiveSmallFloatSubtract, 1 },
	{ genPrimitiveSmallFloatLessThan, 1 },
	{ genPrimitiveSmallFloatGreaterThan, 1 },
	{ genPrimitiveSmallFloatLessOrEqual, 1 },
	{ genPrimitiveSmallFloatGreaterOrEqual, 1 },
	{ genPrimitiveSmallFloatEqual, 1 },
	{ genPrimitiveSmallFloatNotEqual, 1 },
	{ genPrimitiveSmallFloatMultiply, 1 },
	{ genPrimitiveSmallFloatDivide, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveSmallFloatSquareRoot, 0 }
};

	if (isQuickPrimitiveIndex(primitiveIndex)) {

		/* an unused one */
		primitiveDescriptor = (&(primitiveGeneratorTable[0]));
		(primitiveDescriptor->primitiveGenerator = quickPrimitiveGeneratorFor(primitiveIndex));
		return primitiveDescriptor;
	}
	if (((primitiveIndex >= 1) && (primitiveIndex <= MaxCompiledPrimitiveIndex))) {
		return (&(primitiveGeneratorTable[primitiveIndex]));
	}
	return null;
}

	/* SimpleStackBasedCogit>>#recordCallOffsetIn: */
void
recordCallOffsetIn(CogMethod *cogMethod)
{
    unsigned long offset;
    sqInt *offsetTable;

	offset = ((primSetFunctionLabel->address)) - (((sqInt)cogMethod));
	if ((externalSetPrimOffsets[(cogMethod->cmNumArgs)]) == null) {
		externalSetPrimOffsets[(cogMethod->cmNumArgs)] = offset;
	}
	else {
		assert((externalSetPrimOffsets[(cogMethod->cmNumArgs)]) == offset);
	}
	offsetTable = (isJump(primInvokeInstruction)
		? externalPrimJumpOffsets
		: externalPrimCallOffsets);
	offset = (((primInvokeInstruction->address)) + ((primInvokeInstruction->machineCodeSize))) - (((sqInt)cogMethod));
	if ((offsetTable[(cogMethod->cmNumArgs)]) == null) {
		offsetTable[(cogMethod->cmNumArgs)] = offset;
	}
	else {
		assert((offsetTable[(cogMethod->cmNumArgs)]) == offset);
	}
}

	/* SimpleStackBasedCogit>>#register:isInMask: */
static sqInt NoDbgRegParms
registerisInMask(sqInt reg, sqInt mask)
{
	return mask & (1LL << reg);
}


/*	We must ensure the ReceiverResultReg is live across the store check so
	that we can store into receiver inst vars in a frameless method since self
	exists only in ReceiverResultReg in a frameless method. So if
	ReceiverResultReg is
	caller-saved we use the fact that ceStoreCheck: answers its argument to
	reload ReceiverResultReg cheaply. Otherwise we don't care about the result
	and use the cResultRegister, effectively a no-op (see
	compileTrampoline...)  */

	/* SimpleStackBasedCogit>>#returnRegForStoreCheck */
static sqInt
returnRegForStoreCheck(void)
{
	return (callerSavedRegMask & (1LL << ReceiverResultReg)
		? ReceiverResultReg
		: RAX);
}

	/* SimpleStackBasedCogit>>#rewritePrimInvocationIn:to: */
void
rewritePrimInvocationInto(CogMethod *cogMethod, void (*primFunctionPointer)(void))
{
    usqInt address;
    sqInt extent;
    sqInt flags;
    sqInt primIndex;

	assert(((cogMethod->cmType)) == CMMethod);
	primIndex = primitiveIndexOfMethodheader((cogMethod->methodObject), (cogMethod->methodHeader));
	flags = primitivePropertyFlags(primIndex);
	if (flags & PrimCallNeedsPrimitiveFunction) {
		storeLiteralbeforeFollowingAddress(backEnd, ((usqInt)primFunctionPointer), (((usqInt)cogMethod)) + (externalSetPrimOffsets[(cogMethod->cmNumArgs)]));
	}
	if (flags & PrimCallMayCallBack) {
		address = (((usqInt)cogMethod)) + (externalPrimJumpOffsets[(cogMethod->cmNumArgs)]);
		extent = rewriteJumpFullAttarget(backEnd, address, ((usqInt)primFunctionPointer));
	}
	else {
		address = (((usqInt)cogMethod)) + (externalPrimCallOffsets[(cogMethod->cmNumArgs)]);
		extent = rewriteCallFullAttarget(backEnd, address, ((usqInt)primFunctionPointer));
	}
	flushICacheFromto(processor, (((usqInt)cogMethod)) + cmNoCheckEntryOffset, (((usqInt)address)) + extent);
}

	/* SimpleStackBasedCogit>>#v3:Block:Code:Size: */
static sqInt NoDbgRegParms
v3BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts <= 0);
	return (((long)(fetchByteofObject(pc + 2, aMethodObj))) << 8) + (fetchByteofObject(pc + 3, aMethodObj));
}


/*	Answer the distance of a two byte forward long jump. */

	/* SimpleStackBasedCogit>>#v3:LongForward:Branch:Distance: */
static sqInt NoDbgRegParms
v3LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return (((long)((fetchByteofObject(pc, aMethodObj)) & 3)) << 8) + (fetchByteofObject(pc + 1, aMethodObj));
}


/*	Answer the distance of a two byte forward long jump. */

	/* SimpleStackBasedCogit>>#v3:Long:Branch:Distance: */
static sqInt NoDbgRegParms
v3LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return (((long)(((fetchByteofObject(pc, aMethodObj)) & 7) - 4)) << 8) + (fetchByteofObject(pc + 1, aMethodObj));
}


/*	N.B. This serves for both BlueBook/V3 and V4 short jumps. */

	/* SimpleStackBasedCogit>>#v3:ShortForward:Branch:Distance: */
static sqInt NoDbgRegParms
v3ShortForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return ((fetchByteofObject(pc, aMethodObj)) & 7) + 1;
}

	/* SimpleStackBasedCogit>>#voidCogCompiledCode */
void
voidCogCompiledCode(void)
{
    sqInt i;

	clearCogCompiledCode();
	for (i = 0; i <= MaxNumArgs; i += 1) {
		externalPrimJumpOffsets[i] = null;
		externalPrimCallOffsets[i] = null;
		externalSetPrimOffsets[i] = null;
	}
}


/*	Add a blockStart for an embedded block. For a binary tree walk block
	dispatch blocks must be compiled in pc/depth-first order but are scanned
	in breadth-first
	order, so do an insertion sort (which of course is really a bubble sort
	because we
	have to move everything higher to make room). */

	/* StackToRegisterMappingCogit>>#addBlockStartAt:numArgs:numCopied:span: */
static BlockStart * NoDbgRegParms
addBlockStartAtnumArgsnumCopiedspan(sqInt bytecodepc, sqInt numArgs, sqInt numCopied, sqInt span)
{
    BlockStart *blockStart;
    sqInt i;
    sqInt j;


	/* Transcript ensureCr; nextPutAll: 'addBlockStartAt: '; print: bytecodepc; cr; flush. */
	if (blockCount > 0) {
		i = blockCount - 1;
		while (1) {

			/* check for repeat addition during recompilation due to initialNil miscount. */
			blockStart = (&(blockStarts[i]));
			if (((blockStart->startpc)) == bytecodepc) {
				return blockStart;
			}
			if (!((((blockStart->startpc)) > bytecodepc)
			 && (i > 0))) break;
			i -= 1;
		}
		for (j = blockCount; j >= (i + 1); j += -1) {
			blockStarts[j] = (blockStarts[j - 1]);
		}
		blockStart = (&(blockStarts[i + 1]));
	}
	else {
		blockStart = (&(blockStarts[blockCount]));
	}
	blockCount += 1;
	(blockStart->startpc = bytecodepc);
	(blockStart->numArgs = numArgs);
	(blockStart->numCopied = numCopied);
	(blockStart->numInitialNils = 0);
	(blockStart->stackCheckLabel = null);
	(blockStart->hasInstVarRef = 0);
	(blockStart->span = span);
	return blockStart;
}


/*	e.g.	Receiver				Receiver	or	Receiver				Receiver	(RISC)
	Selector/Arg0	=>		Arg1			Selector/Arg0	=>		Arg1
	Arg1					Arg2			Arg1					Arg2
	Arg2					Arg3			Arg2			sp->	Arg3
	Arg3			sp->	retpc	sp->	Arg3
	sp->	retpc */
/*	Generate code to adjust the possibly stacked arguments immediately
	before jumping to a method looked up by a perform primitive. */

	/* StackToRegisterMappingCogit>>#adjustArgumentsForPerform: */
static void NoDbgRegParms
adjustArgumentsForPerform(sqInt numArgs)
{
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction14;
    AbstractInstruction *anInstruction15;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt index;
    sqInt quickConstant1;

	assert((numRegArgs()) <= 2);
	assert(numArgs >= 1);
	if (numArgs <= 2) {
		if (numArgs == 2) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, Arg1Reg, Arg0Reg);
		}
		return;
	}
	if ((2 + 1) == numArgs) {
		/* begin MoveMw:r:R: */
		anInstruction7 = genoperandoperandoperand(MoveMwrR, 0, SPReg, TempReg);
		/* begin MoveMw:r:R: */
		anInstruction4 = genoperandoperandoperand(MoveMwrR, BytesPerWord, SPReg, Arg1Reg);
		/* begin MoveMw:r:R: */
		anInstruction5 = genoperandoperandoperand(MoveMwrR, BytesPerWord * 2, SPReg, Arg0Reg);

		/* begin AddCq:R: */
		quickConstant1 = (numArgs + 1) * BytesPerWord;
		/* begin gen:quickConstant:operand: */
		anInstruction8 = genoperandoperand(AddCqR, quickConstant1, SPReg);
		/* begin MoveR:Mw:r: */
		anInstruction9 = genoperandoperandoperand(MoveRMwr, TempReg, 0, SPReg);

		return;
	}
	for (index = (numArgs - 1); index >= 1; index += -1) {
		/* begin MoveMw:r:R: */
		anInstruction13 = genoperandoperandoperand(MoveMwrR, index * BytesPerWord, SPReg, TempReg);
		/* begin MoveR:Mw:r: */
		anInstruction14 = genoperandoperandoperand(MoveRMwr, TempReg, (index + 1) * BytesPerWord, SPReg);
	}
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin MoveR:Mw:r: */
	anInstruction15 = genoperandoperandoperand(MoveRMwr, TempReg, 0, SPReg);

}


/*	If the stack entry is already in a register not conflicting with regMask,
	answers it,
	else allocate a new register not conflicting with reg mask
 */

	/* StackToRegisterMappingCogit>>#allocateRegForStackEntryAt:notConflictingWith: */
static sqInt NoDbgRegParms
allocateRegForStackEntryAtnotConflictingWith(sqInt index, sqInt regMask)
{
    CogSimStackEntry *stackEntry;

	stackEntry = ssValue(index);
	if ((((stackEntry->type)) == SSRegister)
	 && (!(registerisInMask((stackEntry->registerr), regMask)))) {
		return (stackEntry->registerr);
	}
	return allocateRegNotConflictingWith(regMask);
}


/*	if there's a free register, use it */

	/* StackToRegisterMappingCogit>>#allocateRegNotConflictingWith: */
static sqInt NoDbgRegParms
allocateRegNotConflictingWith(sqInt regMask)
{
    sqInt reg;

	reg = availableRegisterOrNoneFor(backEnd, (liveRegisters()) | regMask);
	if (reg == NoReg) {

		/* No free register, choose one that does not conflict with regMask */
		reg = freeAnyRegNotConflictingWith(regMask);
	}
	if (reg == ReceiverResultReg) {

		/* If we've allocated RcvrResultReg, it's not live anymore */
		(optStatus.isReceiverResultRegLive = 0);
	}
	return reg;
}

	/* StackToRegisterMappingCogit>>#annotateBytecodeIfAnnotated: */
static void NoDbgRegParms
annotateBytecodeIfAnnotated(CogSimStackEntry *aSimStackEntry)
{
    AbstractInstruction *abstractInstruction;

	if ((aSimStackEntry->annotateUse)) {
		/* begin annotateBytecode: */
		if (prevInstIsPCAnnotated()) {
			/* begin Nop */
			abstractInstruction = gen(Nop);
		}
		else {
			/* begin Label */
			abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		(abstractInstruction->annotation = HasBytecodePC);
		(aSimStackEntry->annotateUse = 0);
	}
}

	/* StackToRegisterMappingCogit>>#anyReferencesToRegister:inTopNItems: */
static sqInt NoDbgRegParms
anyReferencesToRegisterinTopNItems(sqInt reg, sqInt n)
{
    sqInt i;
    sqInt regMask;

	regMask = 1LL << reg;
	for (i = simStackPtr; i >= ((simStackPtr - n) + 1); i += -1) {
		if ((registerMask(simStackAt(i))) & regMask) {
			return 1;
		}
	}
	return 0;
}


/*	This is a static version of ceCallCogCodePopReceiverArg0Regs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* StackToRegisterMappingCogit>>#callCogCodePopReceiverArg0Regs */
void
callCogCodePopReceiverArg0Regs(void)
{
	realCECallCogCodePopReceiverArg0Regs();
}


/*	This is a static version of ceCallCogCodePopReceiverArg1Arg0Regs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* StackToRegisterMappingCogit>>#callCogCodePopReceiverArg1Arg0Regs */
void
callCogCodePopReceiverArg1Arg0Regs(void)
{
	realCECallCogCodePopReceiverArg1Arg0Regs();
}


/*	Loop over bytecodes, dispatching to the generator for each bytecode,
	handling fixups in due course.
 */

	/* StackToRegisterMappingCogit>>#compileAbstractInstructionsFrom:through: */
static sqInt NoDbgRegParms
compileAbstractInstructionsFromthrough(sqInt start, sqInt end)
{
    AbstractInstruction *abstractInstruction;
    sqInt debugBytecodePointers;
    BytecodeDescriptor *descriptor;
    BytecodeFixup *fixup;
    sqInt generateBranchAround;
    sqInt nExts;
    sqInt nextOpcodeIndex;
    sqInt result;

	traceSimStack();
	bytecodePC = start;
	nExts = 0;
	descriptor = null;
	deadCode = 0;
	while (1) {
		
		/* If there's no fixup following a return there's no jump to that code and it is dead. */
		fixup = fixupAt(bytecodePC - initialPC);
		if ((descriptor != null)
		 && ((descriptor->isReturn))) {
			deadCode = 1;
		}
		if ((((usqInt)((fixup->targetInstruction)))) > 0) {
			if ((((usqInt)((fixup->targetInstruction)))) >= 2) {
				mergeafterContinuation(fixup, !deadCode);
			}
			deadCode = 0;
		}
		byte0 = (fetchByteofObject(bytecodePC, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		loadSubsequentBytesForDescriptorat(descriptor, bytecodePC);
		nextOpcodeIndex = opcodeIndex;
		if (deadCode) {

			/* insert nops for dead code that is mapped so that bc to mc mapping is not many to one */
			if (((descriptor->isMapped))
			 || (inBlock
			 && ((descriptor->isMappedInBlock)))) {
				/* begin annotateBytecode: */
				abstractInstruction = gen(Nop);
				(abstractInstruction->annotation = HasBytecodePC);
			}
			result = 0;
		}
		else {
			result = ((descriptor->generator))();
		}
		if (!((descriptor->isExtension))) {

			/* extended bytecodes must consume their extensions */
			assert((extA == 0)
			 && (extB == 0));
		}
		traceDescriptor(descriptor);
		traceSimStack();
		if ((((((usqInt)((fixup->targetInstruction)))) >= 1) && ((((usqInt)((fixup->targetInstruction)))) <= 2))) {

			/* There is a fixup for this bytecode.  It must point to the first generated
			   instruction for this bytecode.  If there isn't one we need to add a label. */
			if (opcodeIndex == nextOpcodeIndex) {
				/* begin Label */
				genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			(fixup->targetInstruction = abstractInstructionAt(nextOpcodeIndex));
		}
		/* begin maybeDumpLiterals: */
		if ((isUnconditionalBranch(descriptor))
		 || ((descriptor->isReturn))) {
			/* begin dumpLiterals: */
			generateBranchAround = !((isUnconditionalBranch(descriptor))
 || ((descriptor->isReturn)));
		}
		bytecodePC = (bytecodePC + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bytecodePC, nExts, methodObj)
	: 0));
		if (!((result == 0)
		 && (bytecodePC <= end))) break;
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
	}
	/* begin checkEnoughOpcodes */
	if (opcodeIndex > numAbstractOpcodes) {
		error("Cog JIT internal error. Too many abstract opcodes.  Num opcodes heuristic is too optimistic.");
	}
	return result;
}

	/* StackToRegisterMappingCogit>>#compileBlockBodies */
static sqInt
compileBlockBodies(void)
{
    BlockStart *blockStart;
    sqInt compiledBlocksCount;
    sqInt i;
    sqInt initialOpcodeIndex;
    sqInt initialStackPtr;
    sqInt result;
    sqInt savedNeedsFrame;
    sqInt savedNumArgs;
    sqInt savedNumTemps;

	assert(blockCount > 0);
	savedNeedsFrame = needsFrame;
	savedNumArgs = methodOrBlockNumArgs;
	savedNumTemps = methodOrBlockNumTemps;
	inBlock = 1;
	compiledBlocksCount = 0;
	while (compiledBlocksCount < blockCount) {
		blockStart = blockStartAt(compiledBlocksCount);
		scanBlock(blockStart);
		initialOpcodeIndex = opcodeIndex;
		while (1) {
			compileBlockEntry(blockStart);
			initialStackPtr = simStackPtr;
			if (((result = compileAbstractInstructionsFromthrough(((blockStart->startpc)) + (pushNilSizenumInitialNils(methodObj, (blockStart->numInitialNils))), (((blockStart->startpc)) + ((blockStart->span))) - 1))) < 0) {
				return result;
			}
			if (initialStackPtr == simStackPtr) break;
			assert(initialStackPtr > simStackPtr);
			(blockStart->numInitialNils = (((blockStart->numInitialNils)) + simStackPtr) - initialStackPtr);
			(((blockStart->fakeHeader))->dependent = null);
			reinitializeFixupsFromthrough(((blockStart->startpc)) + ((blockStart->numInitialNils)), (((blockStart->startpc)) + ((blockStart->span))) - 1);
			bzero(abstractOpcodes + initialOpcodeIndex,
									(opcodeIndex - initialOpcodeIndex) * sizeof(AbstractInstruction));
			opcodeIndex = initialOpcodeIndex;
					}
		compiledBlocksCount += 1;
	}
	needsFrame = savedNeedsFrame;
	methodOrBlockNumArgs = savedNumArgs;
	methodOrBlockNumTemps = savedNumTemps;
	return 0;
}


/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. closure (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	Avoid use of SendNumArgsReg which is the flag determining whether
	context switch is allowed on stack-overflow. */
/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. Override to push the register receiver and
	register arguments, if any, and to correctly
	initialize the explicitly nilled/pushed temp entries (they are /not/ of
	type constant nil). */

	/* StackToRegisterMappingCogit>>#compileBlockFrameBuild: */
static void NoDbgRegParms
compileBlockFrameBuild(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    sqInt address;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction * cascade0;
    sqInt constant;
    sqInt i;
    sqInt ign;

	/* begin annotateBytecode: */
	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction->annotation = HasBytecodePC);
	/* begin PushR: */
	genoperand(PushR, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	cascade0 = (blockStart->fakeHeader);
	addDependent(cascade0, annotateAbsolutePCRef(gPushCw(((sqInt)((blockStart->fakeHeader))))));
	setLabelOffset(cascade0, MFMethodFlagIsBlockFlag);
	annotateobjRef(gPushCw(nilObject()), nilObject());
	if ((blockStart->hasInstVarRef)) {

		/* Use ReceiverResultReg for Context to agree with store check trampoline */
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ClassReg, ReceiverResultReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, ReceiverResultReg, Arg0Reg);
		genEnsureOopInRegNotForwardedscratchRegupdatingSlotin(Arg0Reg, TempReg, ReceiverIndex, ReceiverResultReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	}
	else {
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ClassReg, Arg0Reg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, Arg0Reg, ReceiverResultReg);
	}
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = 0; i < ((blockStart->numCopied)); i += 1) {
		genLoadSlotsourceRegdestReg(i + ClosureFirstCopiedValueIndex, ClassReg, TempReg);
		/* begin PushR: */
		genoperand(PushR, TempReg);
	}
	/* begin MoveAw:R: */
	address = stackLimitAddress();
	/* begin gen:literal:operand: */
	anInstruction1 = genoperandoperand(MoveAwR, address, TempReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, TempReg, SPReg);
	/* begin JumpBelow: */
	genConditionalBranchoperand(JumpBelow, ((sqInt)stackOverflowCall));
	(blockStart->stackCheckLabel = annotateBytecode(gLabel()));
	methodOrBlockNumTemps = (((blockStart->numArgs)) + ((blockStart->numCopied))) + ((blockStart->numInitialNils));
	initSimStackForFramefulMethod((blockStart->startpc));
	if (((blockStart->numInitialNils)) > 0) {
		if (((blockStart->numInitialNils)) > 1) {
			/* begin genMoveConstant:R: */
			constant = nilObject();
			if (shouldAnnotateObjectReference(constant)) {
				annotateobjRef(gMoveCwR(constant, TempReg), constant);
			}
			else {
				/* begin MoveCq:R: */
				anInstruction = genoperandoperand(MoveCqR, constant, TempReg);
			}
			for (ign = 1; ign <= ((blockStart->numInitialNils)); ign += 1) {
				/* begin PushR: */
				genoperand(PushR, TempReg);
			}
		}
		else {
			annotateobjRef(gPushCw(nilObject()), nilObject());
		}
		methodOrBlockNumTemps = ((blockStart->numArgs)) + ((blockStart->numCopied));
	}
}


/*	Make sure ReceiverResultReg holds the receiver, loaded from the closure,
	which is what is initially in ReceiverResultReg. We must annotate the
	first instruction so that findMethodForStartBcpc:inHomeMethod: can
	function. We need two annotations because the first is a fiducial. */
/*	Make sure ReceiverResultReg holds the receiver, loaded from
	the closure, which is what is initially in ReceiverResultReg */

	/* StackToRegisterMappingCogit>>#compileBlockFramelessEntry: */
static void NoDbgRegParms
compileBlockFramelessEntry(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;

	methodOrBlockNumTemps = (((blockStart->numArgs)) + ((blockStart->numCopied))) + ((blockStart->numInitialNils));
	initSimStackForFramelessBlock((blockStart->startpc));
	/* begin annotateBytecode: */
	abstractInstruction = (blockStart->entryLabel);
	(abstractInstruction->annotation = HasBytecodePC);
	/* begin annotateBytecode: */
	abstractInstruction1 = (blockStart->entryLabel);
	(abstractInstruction1->annotation = HasBytecodePC);
	genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, TempReg);
	genLoadSlotsourceRegdestReg(ReceiverIndex, TempReg, ReceiverResultReg);
}

	/* StackToRegisterMappingCogit>>#compileCogMethod: */
static CogMethod * NoDbgRegParms
compileCogMethod(sqInt selector)
{
    sqInt allocSize;
    sqInt debugStackPointers;
    sqInt extra;
    sqInt fixupSize;
    sqInt numBlocks;
    sqInt numBytecodes;
    sqInt numCleanBlocks;
    sqInt opcodeSize;
    sqInt result;

	methodOrBlockNumTemps = tempCountOf(methodObj);
	hasYoungReferent = (isYoungObject(methodObj))
	 || (isYoung(selector));
	methodOrBlockNumArgs = argumentCountOf(methodObj);
	inBlock = 0;
	postCompileHook = null;
	maxLitIndex = -1;
	extra = ((((primitiveIndex = primitiveIndexOf(methodObj))) > 0)
	 && (!(isQuickPrimitiveIndex(primitiveIndex)))
		? 30
		: 10);

	/* initial estimate.  Actual endPC is determined in scanMethod. */
	initialPC = startPCOfMethod(methodObj);
	endPC = (isQuickPrimitiveIndex(primitiveIndex)
		? initialPC - 1
		: numBytesOf(methodObj));
	numBytecodes = (endPC - initialPC) + 1;
	/* begin allocateOpcodes:bytecodes:ifFail: */
	numAbstractOpcodes = (numBytecodes + extra) * 10;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	allocSize = opcodeSize + fixupSize;
	if (allocSize > MaxStackAllocSize) {
		return ((CogMethod *) MethodTooBig);

		goto l1;
	}
	abstractOpcodes = alloca(allocSize);
	bzero(abstractOpcodes, allocSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	zeroOpcodeIndex();
	labelCounter = 0;
l1:	/* end allocateOpcodes:bytecodes:ifFail: */;
	if (((numBlocks = scanMethod())) < 0) {
		return ((CogMethod *) numBlocks);
	}
	numCleanBlocks = scanForCleanBlocks();
	allocateBlockStarts(numBlocks + numCleanBlocks);
	blockCount = 0;
	if (numCleanBlocks > 0) {
		addCleanBlockStarts();
	}
	if (!(maybeAllocAndInitIRCs())) {

		/* Inaccurate error code, but it'll do.  This will likely never fail. */
		return ((CogMethod *) InsufficientCodeSpace);
	}
	blockEntryLabel = null;
	(methodLabel->dependent = null);
	if (((result = compileEntireMethod())) < 0) {
		return ((CogMethod *) result);
	}
	return generateCogMethod(selector);
}


/*	Compile the abstract instructions for the entire method, including blocks. */
/*	Compile the abstract instructions for the entire method, including blocks. */

	/* StackToRegisterMappingCogit>>#compileEntireMethod */
static sqInt
compileEntireMethod(void)
{
    sqInt result;

	regArgsHaveBeenPushed = 0;
	compileAbort();
	compileEntry();
	if (((result = compilePrimitive())) < 0) {
		return result;
	}
	compileFrameBuild();
	if (((result = compileMethodBody())) < 0) {
		return result;
	}
	if (blockCount == 0) {
		return 0;
	}
	if (((result = compileBlockBodies())) < 0) {
		return result;
	}
	return compileBlockDispatch();
}


/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. receiver (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	If there is a primitive and an error code the Nth temp is the error code.
	Ensure SendNumArgsReg is set early on (incidentally to nilObj) because
	it is the flag determining whether context switch is allowed on
	stack-overflow.  */
/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. Override to push the register receiver and
	register arguments, if any. */

	/* StackToRegisterMappingCogit>>#compileFrameBuild */
static void
compileFrameBuild(void)
{
    sqInt address;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction3;
    sqInt constant;
    sqInt i;
    sqInt iLimiT;
    AbstractInstruction *jumpSkip;

	if (!needsFrame) {
		initSimStackForFramelessMethod(initialPC);
		return;
	}
	genPushRegisterArgs();
	if (!needsFrame) {
		return;
	}
	/* begin PushR: */
	genoperand(PushR, FPReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SPReg, FPReg);
	addDependent(methodLabel, annotateAbsolutePCRef(gPushCw(((sqInt)methodLabel))));
	/* begin genMoveConstant:R: */
	constant = nilObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, SendNumArgsReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, SendNumArgsReg);
	}
	/* begin PushR: */
	genoperand(PushR, SendNumArgsReg);
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = (methodOrBlockNumArgs + 1), iLimiT = (temporaryCountOfMethodHeader(methodHeader)); i <= iLimiT; i += 1) {
		/* begin PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	if (((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject(initialPC + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))) {
		compileGetErrorCode();
	}
	/* begin MoveAw:R: */
	address = stackLimitAddress();
	/* begin gen:literal:operand: */
	anInstruction3 = genoperandoperand(MoveAwR, address, TempReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, TempReg, SPReg);
	if (canContextSwitchIfActivatingheader(methodObj, methodHeader)) {
		/* begin JumpBelow: */
		genConditionalBranchoperand(JumpBelow, ((sqInt)stackOverflowCall));
		/* begin Label */
		stackCheckLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	else {
		/* begin JumpAboveOrEqual: */
		jumpSkip = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		/* begin MoveCq:R: */
		anInstruction1 = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)stackOverflowCall));
		jmpTarget(jumpSkip, (stackCheckLabel = gLabel()));
	}
	/* begin annotateBytecode: */
	(stackCheckLabel->annotation = HasBytecodePC);
	initSimStackForFramefulMethod(initialPC);
}

	/* StackToRegisterMappingCogit>>#cPICMissTrampolineFor: */
static sqInt NoDbgRegParms
cPICMissTrampolineFor(sqInt numArgs)
{
	return picMissTrampolines[((numArgs < (2 + 1)) ? numArgs : (2 + 1))];
}


/*	Replaces the Blue Book double-extended send [132], in which the first byte
	was wasted on 8 bits of argument count. 
	Here we use 3 bits for the operation sub-type (opType), and the remaining
	5 bits for argument count where needed. 
	The last byte give access to 256 instVars or literals. 
	See also secondExtendedSendBytecode
 */

	/* StackToRegisterMappingCogit>>#doubleExtendedDoAnythingBytecode */
static sqInt
doubleExtendedDoAnythingBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt opType;

	opType = ((usqInt) byte1) >> 5;
	if (opType == 0) {
		return genSendnumArgs(byte2, byte1 & 0x1F);
	}
	if (opType == 1) {
		return genSendSupernumArgs(byte2, byte1 & 0x1F);
	}
	
	switch (opType) {
	case 2:
		if (isReadMediatedContextInstVarIndex(byte2)) {
			genPushMaybeContextReceiverVariable(byte2);
		}
		else {
			genPushReceiverVariable(byte2);
			((ssTop())->annotateUse = 1);
			return 0;
		}
		break;
	case 3:
		genPushLiteralIndex(byte2);
		((ssTop())->annotateUse = 1);
		return 0;

	case 4:
		genPushLiteralVariable(byte2);
		break;
	case 7:
		genStorePopLiteralVariable(0, byte2);
		
#    if IMMUTABILITY

		/* genStorePop:LiteralVariable: annotates; don't annotate twice */
		return 0;

#    endif /* IMMUTABILITY */

		break;
	default:
		
		/* 5 & 6 */
		if (isWriteMediatedContextInstVarIndex(byte2)) {
			genStorePopMaybeContextReceiverVariable(opType == 6, byte2);
		}
		else {
			genStorePopReceiverVariable(opType == 6, byte2);
		}
		
#    if IMMUTABILITY

		/* genStorePop:LiteralVariable: annotates; don't annotate twice */
		return 0;

#    endif /* IMMUTABILITY */

;
	}
	assert(needsFrame);
	assert(!(prevInstIsPCAnnotated()));
	/* begin annotateBytecode: */
	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction->annotation = HasBytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#duplicateTopBytecode */
static sqInt
duplicateTopBytecode(void)
{
    CogSimStackEntry desc;

	desc = ssTopDescriptor();
	return ssPushDesc(desc);
}


/*	Make sure there's a flagged fixup at the targetIndex (pc relative to first
	pc) in fixups.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#ensureFixupAt: */
static BytecodeFixup * NoDbgRegParms
ensureFixupAt(sqInt targetIndex)
{
    BytecodeFixup *fixup;

	fixup = fixupAt(targetIndex);
	traceFixup(fixup);
	if ((((usqInt)((fixup->targetInstruction)))) <= 1) {

		/* convert a non-merge into a merge */
		(fixup->targetInstruction = ((AbstractInstruction *) 2));
		(fixup->simStackPtr = simStackPtr);
	}
	else {
		if (((fixup->simStackPtr)) <= -2) {

			/* this is the target of a backward branch and
			   so doesn't have a simStackPtr assigned yet. */
			(fixup->simStackPtr = simStackPtr);
		}
		else {
			assert(((fixup->simStackPtr)) == simStackPtr);
		}
	}
	return fixup;
}


/*	Make sure there's a flagged fixup at the targetIndex (pc relative to first
	pc) in fixups.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#ensureNonMergeFixupAt: */
static BytecodeFixup * NoDbgRegParms
ensureNonMergeFixupAt(sqInt targetIndex)
{
    BytecodeFixup *fixup;

	fixup = fixupAt(targetIndex);
	if (((fixup->targetInstruction)) == 0) {
		(fixup->targetInstruction = ((AbstractInstruction *) 1));
	}
	return fixup;
}

	/* StackToRegisterMappingCogit>>#ensureReceiverResultRegContainsSelf */
static void
ensureReceiverResultRegContainsSelf(void)
{
	if (needsFrame) {
		if (!((optStatus.isReceiverResultRegLive))) {
			ssAllocateRequiredReg(ReceiverResultReg);
			/* begin putSelfInReceiverResultReg */
			storeToReg((&simSelf), ReceiverResultReg);
		}
		(optStatus.isReceiverResultRegLive = 1);
	}
	else {
		assert((((simSelf.type)) == SSRegister)
		 && (((simSelf.registerr)) == ReceiverResultReg));
		assert(((optStatus.isReceiverResultRegLive))
		 && (((optStatus.ssEntry)) == ((&simSelf))));
	}
}

	/* StackToRegisterMappingCogit>>#evaluate:at: */
static void NoDbgRegParms
evaluateat(BytecodeDescriptor *descriptor, sqInt pc)
{
	byte0 = fetchByteofObject(pc, methodObj);
	assert(descriptor == (generatorAt(bytecodeSetOffset + byte0)));
	loadSubsequentBytesForDescriptorat(descriptor, pc);
	((descriptor->generator))();
}


/*	Spill the closest register on stack not conflicting with regMask. 
	Assertion Failure if regMask has already all the registers */

	/* StackToRegisterMappingCogit>>#freeAnyRegNotConflictingWith: */
static sqInt NoDbgRegParms
freeAnyRegNotConflictingWith(sqInt regMask)
{
    CogSimStackEntry *desc;
    sqInt index;
    sqInt reg;

	assert(needsFrame);
	reg = NoReg;
	index = ((simSpillBase < 0) ? 0 : simSpillBase);
	while ((reg == NoReg)
	 && (index < simStackPtr)) {
		desc = simStackAt(index);
		if (((desc->type)) == SSRegister) {
			if (!(regMask & (registerMaskFor((desc->registerr))))) {
				reg = (desc->registerr);
			}
		}
		index += 1;
	}
	assert(!((reg == NoReg)));
	ssAllocateRequiredReg(reg);
	return reg;
}


/*	Generate special versions of the ceCallCogCodePopReceiverAndClassRegs
	enilopmart that also pop register args from the stack to undo the pushing
	of register args in the abort/miss trampolines. */

	/* StackToRegisterMappingCogit>>#genCallPICEnilopmartNumArgs: */
static void (*genCallPICEnilopmartNumArgs(sqInt numArgs))(void)

{
    AbstractInstruction *anInstruction;
    sqInt endAddress;
    sqInt enilopmart;
    sqInt quickConstant;
    sqInt reg;
    sqInt size;

	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);

	genLoadStackPointers(backEnd);
	/* begin PopR: */
	genoperand(PopR, ClassReg);
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin PopR: */
	reg = SendNumArgsReg;
	genoperand(PopR, reg);
	if (numArgs > 0) {
		if (numArgs > 1) {
			/* begin PopR: */
			genoperand(PopR, Arg1Reg);
			assert((numRegArgs()) == 2);
		}
		/* begin PopR: */
		genoperand(PopR, Arg0Reg);
	}
	/* begin PopR: */
	genoperand(PopR, ReceiverResultReg);
	/* begin PushR: */
	genoperand(PushR, SendNumArgsReg);

	/* begin JumpR: */
	genoperand(JumpR, TempReg);
	computeMaximumSizes();
	size = generateInstructionsAt(methodZoneBase);
	endAddress = outputInstructionsAt(methodZoneBase);
	assert((methodZoneBase + size) == endAddress);
	enilopmart = methodZoneBase;
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	recordGeneratedRunTimeaddress(trampolineNamenumRegArgs("ceCallPIC", numArgs), enilopmart);
	return ((void (*)(void)) enilopmart);
}


/*	SistaV1: 248		11111000 iiiiiiii		mjjjjjjj		Call Primitive #iiiiiiii +
	(jjjjjjj * 256) m=1 means inlined primitive, no hard return after
	execution. See EncoderForSistaV1's class comment and
	StackInterpreter>>#inlinePrimitiveBytecode: 
 */

	/* StackToRegisterMappingCogit>>#genCallPrimitiveBytecode */
static sqInt
genCallPrimitiveBytecode(void)
{
    sqInt prim;

	if (byte2 < 128) {
		return (bytecodePC == initialPC
			? 0
			: EncounteredUnknownBytecode);
	}
	prim = (((long)(byte2 - 128)) << 8) + byte1;
	return EncounteredUnknownBytecode;
}


/*	Generates the machine code for #== in the case where the instruction is
	not followed by a branch
 */

	/* StackToRegisterMappingCogit>>#genEqualsEqualsNoBranchArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
static sqInt NoDbgRegParms
genEqualsEqualsNoBranchArgIsConstantrcvrIsConstantargRegrcvrReg(sqInt argIsConstant, sqInt rcvrIsConstant, sqInt argReg, sqInt rcvrRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt constant;
    sqInt constant1;
    sqInt constant2;
    AbstractInstruction *jumpEqual;
    AbstractInstruction *jumpNotEqual;
    AbstractInstruction *label;
    sqInt resultReg;

	/* begin Label */
	label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin genEqualsEqualsComparisonArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	if (argIsConstant) {
		/* begin genCompConstant:R: */
		constant1 = ((ssTop())->constant);
		if (shouldAnnotateObjectReference(constant1)) {
			annotateobjRef(gCmpCwR(constant1, rcvrRegOrNone), constant1);
		}
		else {
			/* begin CmpCq:R: */
			anInstruction = genoperandoperand(CmpCqR, constant1, rcvrRegOrNone);
		}
	}
	else {
		if (rcvrIsConstant) {
			/* begin genCompConstant:R: */
			constant2 = ((ssValue(1))->constant);
			if (shouldAnnotateObjectReference(constant2)) {
				annotateobjRef(gCmpCwR(constant2, argReg), constant2);
			}
			else {
				/* begin CmpCq:R: */
				anInstruction1 = genoperandoperand(CmpCqR, constant2, argReg);
			}
		}
		else {
			/* begin CmpR:R: */
			genoperandoperand(CmpRR, argReg, rcvrRegOrNone);
		}
	}
	ssPop(2);
	resultReg = (rcvrRegOrNone == NoReg
		? argReg
		: rcvrRegOrNone);
	/* begin JumpZero: */
	jumpEqual = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	if (!argIsConstant) {
		genEnsureOopInRegNotForwardedscratchRegjumpBackTo(argReg, TempReg, label);
	}
	if (!rcvrIsConstant) {
		genEnsureOopInRegNotForwardedscratchRegjumpBackTo(rcvrRegOrNone, TempReg, label);
	}
	/* begin genMoveFalseR: */
	constant = falseObject();
	if (shouldAnnotateObjectReference(constant)) {
		annotateobjRef(gMoveCwR(constant, resultReg), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction2 = genoperandoperand(MoveCqR, constant, resultReg);
	}
	/* begin Jump: */
	jumpNotEqual = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpEqual, genMoveTrueR(resultReg));
	jmpTarget(jumpNotEqual, gLabel());
	ssPushRegister(resultReg);
	return 0;
}


/*	Override to push the register receiver and register arguments, if any. */

	/* StackToRegisterMappingCogit>>#genExternalizePointersForPrimitiveCall */
static sqInt
genExternalizePointersForPrimitiveCall(void)
{
    sqInt address2;
    sqInt address3;
    sqInt address4;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;

	genPushRegisterArgs();
	/* begin MoveR:Aw: */
	address4 = framePointerAddress();
	/* begin gen:operand:literal: */
	anInstruction4 = genoperandoperand(MoveRAw, FPReg, address4);
	/* begin PopR: */
	genoperand(PopR, TempReg);
	/* begin MoveR:Aw: */
	address2 = instructionPointerAddress();
	/* begin gen:operand:literal: */
	anInstruction2 = genoperandoperand(MoveRAw, TempReg, address2);
	/* begin MoveR:Aw: */
	address3 = stackPointerAddress();
	/* begin gen:operand:literal: */
	anInstruction3 = genoperandoperand(MoveRAw, SPReg, address3);

	return 0;
}


/*	Enilopmarts transfer control from C into machine code (backwards
	trampolines). 
 */
/*	Enilopmarts transfer control from C into machine code (backwards
	trampolines). Override to add version for generic and PIC-specific entry
	with reg args. */

	/* StackToRegisterMappingCogit>>#generateEnilopmarts */
static void
generateEnilopmarts(void)
{
	
#  if Debug
	/* begin genEnilopmartFor:forCall:called: */
	realCEEnterCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 0, "realCEEnterCogCodePopReceiverReg");
	ceEnterCogCodePopReceiverReg = enterCogCodePopReceiver;
	/* begin genEnilopmartFor:forCall:called: */
	realCECallCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 1, "realCEEnterCogCodePopReceiverReg");
	ceCallCogCodePopReceiverReg = callCogCodePopReceiver;
	/* begin genEnilopmartFor:and:forCall:called: */
	realCECallCogCodePopReceiverAndClassRegs = genEnilopmartForandandforCallcalled(ReceiverResultReg, ClassReg, NoReg, 1, "realCECallCogCodePopReceiverAndClassRegs");
	ceCallCogCodePopReceiverAndClassRegs = callCogCodePopReceiverAndClassRegs;

#  else /* Debug */
	/* begin genEnilopmartFor:forCall:called: */
	ceEnterCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 0, "ceEnterCogCodePopReceiverReg");
	/* begin genEnilopmartFor:forCall:called: */
	ceCallCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 1, "ceCallCogCodePopReceiverReg");
	/* begin genEnilopmartFor:and:forCall:called: */
	ceCallCogCodePopReceiverAndClassRegs = genEnilopmartForandandforCallcalled(ReceiverResultReg, ClassReg, NoReg, 1, "ceCallCogCodePopReceiverAndClassRegs");

#  endif /* Debug */

	genPrimReturnEnterCogCodeEnilopmart(0);
	cePrimReturnEnterCogCode = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(cePrimReturnEnterCogCode);
	recordGeneratedRunTimeaddress("cePrimReturnEnterCogCode", cePrimReturnEnterCogCode);
	genPrimReturnEnterCogCodeEnilopmart(1);
	cePrimReturnEnterCogCodeProfiling = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(cePrimReturnEnterCogCodeProfiling);
	recordGeneratedRunTimeaddress("cePrimReturnEnterCogCodeProfiling", cePrimReturnEnterCogCodeProfiling);
	
#  if Debug
	/* begin genEnilopmartFor:and:forCall:called: */
	realCECallCogCodePopReceiverArg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, NoReg, 1, "realCECallCogCodePopReceiverArg0Regs");
	ceCallCogCodePopReceiverArg0Regs = callCogCodePopReceiverArg0Regs;
	realCECallCogCodePopReceiverArg1Arg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, Arg1Reg, 1, "realCECallCogCodePopReceiverArg1Arg0Regs");
	ceCallCogCodePopReceiverArg1Arg0Regs = callCogCodePopReceiverArg1Arg0Regs;

#  else /* Debug */
	/* begin genEnilopmartFor:and:forCall:called: */
	ceCallCogCodePopReceiverArg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, NoReg, 1, "ceCallCogCodePopReceiverArg0Regs");
	ceCallCogCodePopReceiverArg1Arg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, Arg1Reg, 1, "ceCallCogCodePopReceiverArg1Arg0Regs");

#  endif /* Debug */

	ceCall0ArgsPIC = genCallPICEnilopmartNumArgs(0);
	ceCall1ArgsPIC = genCallPICEnilopmartNumArgs(1);
	ceCall2ArgsPIC = genCallPICEnilopmartNumArgs(2);
	assert((numRegArgs()) == 2);


}


/*	Generate the run-time entries for the various method and PIC entry misses
	and aborts.
	Read the class-side method trampolines for documentation on the various
	trampolines 
 */

	/* StackToRegisterMappingCogit>>#generateMissAbortTrampolines */
static void
generateMissAbortTrampolines(void)
{
    sqInt numArgs;
    sqInt numArgsLimiT;

	for (numArgs = 0, numArgsLimiT = (2 + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		methodAbortTrampolines[numArgs] = (genMethodAbortTrampolineFor(numArgs));
	}
	for (numArgs = 0, numArgsLimiT = (2 + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		picAbortTrampolines[numArgs] = (genPICAbortTrampolineFor(numArgs));
	}
	for (numArgs = 0, numArgsLimiT = (2 + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		picMissTrampolines[numArgs] = (genPICMissTrampolineFor(numArgs));
	}
}


/*	Override to generate code to push the register arg(s) for <= numRegArg
	arity sends.
 */

	/* StackToRegisterMappingCogit>>#generateSendTrampolines */
static void
generateSendTrampolines(void)
{
    sqInt numArgs;

	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		ordinarySendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(ceSendsupertonumArgs, numArgs, trampolineNamenumArgs("ceSend", numArgs), ClassReg, trampolineArgConstant(0), ReceiverResultReg, (numArgs <= (NumSendTrampolines - 2)
	? (/* begin trampolineArgConstant: */
		assert(numArgs >= 0),
		-2 - numArgs)
	: SendNumArgsReg)));
	}
	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		superSendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(ceSendsupertonumArgs, numArgs, trampolineNamenumArgs("ceSuperSend", numArgs), ClassReg, trampolineArgConstant(1), ReceiverResultReg, (numArgs <= (NumSendTrampolines - 2)
	? (/* begin trampolineArgConstant: */
		assert(numArgs >= 0),
		-2 - numArgs)
	: SendNumArgsReg)));
	}
	firstSend = ordinarySendTrampolines[0];
	lastSend = superSendTrampolines[NumSendTrampolines - 1];
}


/*	Generate trampolines for tracing. In the simulator we can save a lot of
	time and avoid noise instructions in the lastNInstructions log by
	short-cutting these
	trampolines, but we need them in the real vm. */

	/* StackToRegisterMappingCogit>>#generateTracingTrampolines */
static void
generateTracingTrampolines(void)
{
	ceTraceLinkedSendTrampoline = genTrampolineForcalledargregsToSave(ceTraceLinkedSend, "ceTraceLinkedSendTrampoline", ReceiverResultReg, callerSavedRegMask);
	ceTraceBlockActivationTrampoline = genTrampolineForcalledregsToSave(ceTraceBlockActivation, "ceTraceBlockActivationTrampoline", callerSavedRegMask);
	ceTraceStoreTrampoline = genTrampolineForcalledargargregsToSave(ceTraceStoreOfinto, "ceTraceStoreTrampoline", TempReg, ReceiverResultReg, callerSavedRegMask);
}

	/* StackToRegisterMappingCogit>>#genJumpBackTo: */
static sqInt NoDbgRegParms
genJumpBackTo(sqInt targetBytecodePC)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    sqInt address;
    AbstractInstruction *anInstruction;
    void *jumpTarget;
    void *jumpTarget1;

	ssFlushTo(simStackPtr);
	/* begin MoveAw:R: */
	address = stackLimitAddress();
	/* begin gen:literal:operand: */
	anInstruction = genoperandoperand(MoveAwR, address, TempReg);
	/* begin CmpR:R: */
	genoperandoperand(CmpRR, TempReg, SPReg);
	/* begin JumpAboveOrEqual: */
	jumpTarget = fixupAt(targetBytecodePC - initialPC);
	genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)jumpTarget));
	/* begin CallRT: */
	abstractInstruction1 = genoperand(Call, ceCheckForInterruptTrampoline);
	(abstractInstruction1->annotation = IsRelativeCall);
	/* begin annotateBytecode: */
	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction->annotation = HasBytecodePC);
	/* begin Jump: */
	jumpTarget1 = fixupAt(targetBytecodePC - initialPC);
	genoperand(Jump, ((sqInt)jumpTarget1));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genJumpIf:to: */
static sqInt NoDbgRegParms
genJumpIfto(sqInt boolean, sqInt targetBytecodePC)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction2;
    AbstractInstruction *anInstruction;
    sqInt callTarget;
    CogSimStackEntry *desc;
    BytecodeFixup *fixup;
    void *jumpTarget;
    AbstractInstruction *ok;
    sqInt quickConstant;

	ssFlushTo(simStackPtr - 1);
	desc = ssTop();
	ssPop(1);
	if ((((desc->type)) == SSConstant)
	 && ((((desc->constant)) == (trueObject()))
	 || (((desc->constant)) == (falseObject())))) {

		/* Must arrange there's a fixup at the target whether it is jumped to or
		   not so that the simStackPtr can be kept correct. */

		/* Must enter any annotatedConstants into the map */
		fixup = ensureFixupAt(targetBytecodePC - initialPC);
		if ((desc->annotateUse)) {
			/* begin annotateBytecode: */
			if (prevInstIsPCAnnotated()) {
				/* begin Nop */
				abstractInstruction = gen(Nop);
			}
			else {
				/* begin Label */
				abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			(abstractInstruction->annotation = HasBytecodePC);
		}
		/* begin annotateBytecode: */
		if (((desc->constant)) == boolean) {
			/* begin Jump: */
			abstractInstruction1 = genoperand(Jump, ((sqInt)fixup));
		}
		else {
			if (prevInstIsPCAnnotated()) {
				/* begin Nop */
				abstractInstruction1 = gen(Nop);
			}
			else {
				/* begin Label */
				abstractInstruction1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
		}
		(abstractInstruction1->annotation = HasBytecodePC);
		return 0;
	}
	popToReg(desc, TempReg);
	assert((objectAfter(falseObject())) == (trueObject()));
	annotateobjRef(gSubCwR(boolean, TempReg), boolean);
	/* begin JumpZero: */
	jumpTarget = ensureFixupAt(targetBytecodePC - initialPC);
	genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
	/* begin CmpCq:R: */
	quickConstant = (boolean == (falseObject())
		? (trueObject()) - (falseObject())
		: (falseObject()) - (trueObject()));
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpZero: */
	ok = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin CallRT: */
	callTarget = (boolean == (falseObject())
		? ceSendMustBeBooleanAddFalseTrampoline
		: ceSendMustBeBooleanAddTrueTrampoline);
	/* begin annotateCall: */
	abstractInstruction2 = genoperand(Call, callTarget);
	(abstractInstruction2->annotation = IsRelativeCall);
	jmpTarget(ok, annotateBytecode(gLabel()));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genJumpTo: */
static sqInt NoDbgRegParms
genJumpTo(sqInt targetBytecodePC)
{
    void *jumpTarget;

	ssFlushTo(simStackPtr);
	/* begin Jump: */
	jumpTarget = ensureFixupAt(targetBytecodePC - initialPC);
	genoperand(Jump, ((sqInt)jumpTarget));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genMarshalledSend:numArgs:sendTable: */
static sqInt NoDbgRegParms
genMarshalledSendnumArgssendTable(sqInt selectorIndex, sqInt numArgs, sqInt *sendTable)
{
    AbstractInstruction *anInstruction;
    sqInt annotation;

	assert(needsFrame);
	/* begin annotationForSendTable: */
	if (sendTable == superSendTrampolines) {
		annotation = IsSuperSend;
		goto l2;
	}
	assert(sendTable == ordinarySendTrampolines);
	annotation = IsSendCall;
l2:	/* end annotationForSendTable: */;
	if ((annotation == IsSuperSend)
	 || (0)) {
		genEnsureOopInRegNotForwardedscratchReg(ReceiverResultReg, TempReg);
	}
	if (numArgs >= (NumSendTrampolines - 1)) {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, numArgs, SendNumArgsReg);
	}
	genLoadInlineCacheWithSelector(selectorIndex);
	((gCall(sendTable[((numArgs < (NumSendTrampolines - 1)) ? numArgs : (NumSendTrampolines - 1))]))->annotation = annotation);
	(optStatus.isReceiverResultRegLive = 0);
	return ssPushRegister(ReceiverResultReg);
}


/*	Generate the abort for a method. This abort performs either a call of
	ceSICMiss: to handle a single-in-line cache miss or a call of
	ceStackOverflow: to handle a
	stack overflow. It distinguishes the two by testing ResultReceiverReg. If
	the register is zero then this is a stack-overflow because a) the receiver
	has already
	been pushed and so can be set to zero before calling the abort, and b) the
	receiver must always contain an object (and hence be non-zero) on SIC
	miss.  */

	/* StackToRegisterMappingCogit>>#genMethodAbortTrampolineFor: */
static sqInt NoDbgRegParms
genMethodAbortTrampolineFor(sqInt numArgs)
{
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jumpSICMiss;

	zeroOpcodeIndex();
	/* begin CmpCq:R: */
	anInstruction1 = genoperandoperand(CmpCqR, 0, ReceiverResultReg);
	/* begin JumpNonZero: */
	jumpSICMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceStackOverflow, 1, SendNumArgsReg, null, null, null, 0, 0, NoReg);
	jmpTarget(jumpSICMiss, gLabel());
	genPushRegisterArgsForAbortMissNumArgs(backEnd, numArgs);
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceSICMiss, trampolineNamenumRegArgs("ceMethodAbort", numArgs), 1, ReceiverResultReg, null, null, null, 0, 0, NoReg, 1);
}


/*	Generate the abort for a PIC. This abort performs either a call of
	ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged
	target or a call of ceMNUFromPICMNUMethod:receiver: to handle an
	MNU dispatch in a closed PIC. It distinguishes the two by testing
	ClassReg. If the register is zero then this is an MNU. */

	/* StackToRegisterMappingCogit>>#genPICAbortTrampolineFor: */
static sqInt NoDbgRegParms
genPICAbortTrampolineFor(sqInt numArgs)
{
	zeroOpcodeIndex();
	genPushRegisterArgsForAbortMissNumArgs(backEnd, numArgs);
	return genInnerPICAbortTrampoline(trampolineNamenumRegArgs("cePICAbort", numArgs));
}

	/* StackToRegisterMappingCogit>>#genPICMissTrampolineFor: */
static sqInt NoDbgRegParms
genPICMissTrampolineFor(sqInt numArgs)
{
    sqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCPICMissreceiver, trampolineNamenumRegArgs("cePICMiss", numArgs), 2, ClassReg, ReceiverResultReg, null, null, 0, 1, NoReg, 1);
	return startAddress;
}

	/* StackToRegisterMappingCogit>>#genPopStackBytecode */
static sqInt
genPopStackBytecode(void)
{
    AbstractInstruction *anInstruction;

	annotateBytecodeIfAnnotated(ssTop());
	if (((ssTop())->spilled)) {
		/* begin AddCq:R: */
		anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
	}
	ssPop(1);
	return 0;
}


/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive. */
/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive.
	Override to push the register args first. */

	/* StackToRegisterMappingCogit>>#genPrimitiveClosureValue */
static sqInt
genPrimitiveClosureValue(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpFail1;
    AbstractInstruction *jumpFail2;
    AbstractInstruction *jumpFail3;
    AbstractInstruction *jumpFail4;
    AbstractInstruction *jumpFailNArgs;
    sqInt literal;
    sqInt offset;
    void (*primitiveRoutine)();
    sqInt quickConstant;
    sqInt result;

	genPushRegisterArgs();
	genLoadSlotsourceRegdestReg(ClosureNumArgsIndex, ReceiverResultReg, TempReg);
	/* begin CmpCq:R: */
	literal = ((methodOrBlockNumArgs << 3) | 1);
	anInstruction1 = genoperandoperand(CmpCqR, ((methodOrBlockNumArgs << 3) | 1), TempReg);
	/* begin JumpNonZero: */
	jumpFailNArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, ClassReg);
	jumpFail1 = genJumpImmediate(ClassReg);
	genGetCompactClassIndexNonImmOfinto(ClassReg, TempReg);
	genCmpClassMethodContextCompactIndexR(TempReg);
	/* begin JumpNonZero: */
	jumpFail2 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(MethodIndex, ClassReg, SendNumArgsReg);
	jumpFail3 = genJumpImmediate(SendNumArgsReg);
	genGetFormatOfinto(SendNumArgsReg, TempReg);
	/* begin CmpCq:R: */
	quickConstant = firstCompiledMethodFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant, TempReg);
	/* begin JumpLess: */
	jumpFail4 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	/* begin MoveM16:r:R: */
	offset = offsetof(CogMethod, blockEntryOffset);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction3 = genoperandoperandoperand(MoveM16rR, offset, ClassReg, TempReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, ClassReg, TempReg);
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndex(methodObj, primitiveIndex);
	if (primitiveRoutine == primitiveClosureValueNoContextSwitch) {
		if (blockNoContextSwitchOffset == null) {
			return NotFullyInitialized;
		}
		/* begin SubCq:R: */
		anInstruction = genoperandoperand(SubCqR, blockNoContextSwitchOffset, TempReg);
	}
	/* begin JumpR: */
	genoperand(JumpR, TempReg);
	jmpTarget(jumpBCMethod, jmpTarget(jumpFail1, jmpTarget(jumpFail2, jmpTarget(jumpFail3, jmpTarget(jumpFail4, gLabel())))));
	if (((result = compileInterpreterPrimitive(primitiveRoutine))) < 0) {
		return result;
	}
	jmpTarget(jumpFailNArgs, gLabel());
	return CompletePrimitive;
}


/*	Generate an in-line perform primitive. The lookup code requires the
	selector to be in Arg0Reg.
	adjustArgumentsForPerform: adjusts the arguments once
	genLookupForPerformNumArgs: has generated the code for the lookup. */

	/* StackToRegisterMappingCogit>>#genPrimitivePerform */
static sqInt
genPrimitivePerform(void)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	if (methodOrBlockNumArgs > 2) {
		/* begin MoveMw:r:R: */
		offset = (methodOrBlockNumArgs) * BytesPerWord;
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, Arg0Reg);
	}
	return genLookupForPerformNumArgs(methodOrBlockNumArgs);
}

	/* StackToRegisterMappingCogit>>#genPushActiveContextBytecode */
static sqInt
genPushActiveContextBytecode(void)
{
	assert(needsFrame);
	(optStatus.isReceiverResultRegLive = 0);
	ssAllocateCallRegandand(ReceiverResultReg, SendNumArgsReg, ClassReg);

	genGetActiveContextNumArgslargeinBlock(methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	return ssPushRegister(ReceiverResultReg);
}


/*	Block compilation. At this point in the method create the block. Note its
	start and defer generating code for it until after the method and any
	other preceding
	blocks. The block's actual code will be compiled later. */
/*	143 10001111 llllkkkk jjjjjjjj iiiiiiii	Push Closure Num Copied llll Num
	Args kkkk BlockSize jjjjjjjjiiiiiiii */

	/* StackToRegisterMappingCogit>>#genPushClosureCopyCopiedValuesBytecode */
static sqInt
genPushClosureCopyCopiedValuesBytecode(void)
{
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt reg;
    sqInt startpc;

	assert(needsFrame);
	startpc = bytecodePC + (((generatorAt(byte0))->numBytes));
	addBlockStartAtnumArgsnumCopiedspan(startpc, (numArgs = byte1 & 15), (numCopied = ((usqInt) byte1) >> 4), (((long)byte2) << 8) + byte3);
	/* begin genInlineClosure:numArgs:numCopied: */
	assert(getActiveContextAllocatesInMachineCode());
	(optStatus.isReceiverResultRegLive = 0);
	ssAllocateCallRegandand(ReceiverResultReg, SendNumArgsReg, ClassReg);
	genNoPopCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(startpc + 1, numArgs, numCopied, methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	for (i = 1; i <= numCopied; i += 1) {
		reg = ssStorePoptoPreferredReg(1, TempReg);
		genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, (ClosureFirstCopiedValueIndex + numCopied) - i, ReceiverResultReg);
	}
	ssPushRegister(ReceiverResultReg);

	return 0;
}

	/* StackToRegisterMappingCogit>>#genPushLiteralVariable: */
static sqInt NoDbgRegParms
genPushLiteralVariable(sqInt literalIndex)
{
    AbstractInstruction *anInstruction;
    sqInt association;
    sqInt freeReg;

	freeReg = allocateRegNotConflictingWith(0);

	/* N.B. Do _not_ use ReceiverResultReg to avoid overwriting receiver in assignment in frameless methods. */
	/* So far descriptors are not rich enough to describe the entire dereference so generate the register
	   load but don't push the result.  There is an order-of-evaluation issue if we defer the dereference. */
	association = getLiteral(literalIndex);
	/* begin genMoveConstant:R: */
	if (shouldAnnotateObjectReference(association)) {
		annotateobjRef(gMoveCwR(association, TempReg), association);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, association, TempReg);
	}
	genEnsureObjInRegNotForwardedscratchReg(TempReg, freeReg);
	genLoadSlotsourceRegdestReg(ValueIndex, TempReg, freeReg);
	ssPushRegister(freeReg);
	return 0;
}

	/* StackToRegisterMappingCogit>>#genPushLiteral: */
static sqInt NoDbgRegParms
genPushLiteral(sqInt literal)
{
	return ssPushConstant(literal);
}

	/* StackToRegisterMappingCogit>>#genPushMaybeContextReceiverVariable: */
static sqInt NoDbgRegParms
genPushMaybeContextReceiverVariable(sqInt slotIndex)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jmpDone;
    AbstractInstruction *jmpSingle;

	assert(needsFrame);
	ssAllocateCallRegand(ReceiverResultReg, SendNumArgsReg);
	ensureReceiverResultRegContainsSelf();
	if (callerSavedRegMask & (1LL << ReceiverResultReg)) {

		/* We have no way of reloading ReceiverResultReg since we need the inst var value as the result. */
		(optStatus.isReceiverResultRegLive = 0);
	}
	if (slotIndex == InstructionPointerIndex) {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceFetchContextInstVarTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		return ssPushRegister(SendNumArgsReg);
	}
	genLoadSlotsourceRegdestReg(SenderIndex, ReceiverResultReg, TempReg);
	/* begin genJumpNotSmallIntegerInScratchReg: */
	jmpSingle = genJumpNotSmallInteger(TempReg);
	/* begin MoveCq:R: */
	anInstruction1 = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
	/* begin CallRT: */
	abstractInstruction1 = genoperand(Call, ceFetchContextInstVarTrampoline);
	(abstractInstruction1->annotation = IsRelativeCall);
	/* begin Jump: */
	jmpDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jmpSingle, gLabel());
	genLoadSlotsourceRegdestReg(slotIndex, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jmpDone, gLabel());
	return ssPushRegister(SendNumArgsReg);
}

	/* StackToRegisterMappingCogit>>#genPushNewArrayBytecode */
static sqInt
genPushNewArrayBytecode(void)
{
    sqInt i;
    sqInt popValues;
    sqInt size;

	assert(needsFrame);
	(optStatus.isReceiverResultRegLive = 0);
	if ((popValues = byte1 > 0x7F)) {
		ssFlushTo(simStackPtr);
	}
	else {
		ssAllocateCallRegand(SendNumArgsReg, ReceiverResultReg);
	}
	size = byte1 & 0x7F;
	if (!popValues) {
		if (tryCollapseTempVectorInitializationOfSize(size)) {
			return 0;
		}
	}
	genNewArrayOfSizeinitialized(size, !popValues);
	if (popValues) {
		for (i = (size - 1); i >= 0; i += -1) {
			/* begin PopR: */
			genoperand(PopR, TempReg);
			genStoreSourceRegslotIndexintoNewObjectInDestReg(TempReg, i, ReceiverResultReg);
		}
		ssPop(size);
	}
	return ssPushRegister(ReceiverResultReg);
}

	/* StackToRegisterMappingCogit>>#genPushReceiverBytecode */
static sqInt
genPushReceiverBytecode(void)
{
	if ((optStatus.isReceiverResultRegLive)) {
		return ssPushRegister(ReceiverResultReg);
	}
	return ssPushDesc(simSelf);
}

	/* StackToRegisterMappingCogit>>#genPushReceiverVariable: */
static sqInt NoDbgRegParms
genPushReceiverVariable(sqInt index)
{
	ensureReceiverResultRegContainsSelf();
	return ssPushBaseoffset(ReceiverResultReg, slotOffsetOfInstVarIndex(index));
}


/*	Ensure that the register args are pushed before the retpc for methods with
	arity <= self numRegArgs.
 */
/*	This won't be as clumsy on a RISC. But putting the receiver and
	args above the return address means the CoInterpreter has a
	single machine-code frame format which saves us a lot of work. */

	/* StackToRegisterMappingCogit>>#genPushRegisterArgs */
static void
genPushRegisterArgs(void)
{
	if (!(regArgsHaveBeenPushed
		 || (methodOrBlockNumArgs > 2))) {
		genPushRegisterArgsForNumArgsscratchReg(backEnd, methodOrBlockNumArgs, SendNumArgsReg);
		regArgsHaveBeenPushed = 1;
	}
}

	/* StackToRegisterMappingCogit>>#genPushRemoteTempLongBytecode */
static sqInt
genPushRemoteTempLongBytecode(void)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt remoteTempReg;
    sqInt tempVectReg;

	tempVectReg = allocateRegNotConflictingWith(0);
	/* begin MoveMw:r:R: */
	offset = frameOffsetOfTemporary(byte2);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, tempVectReg);
	remoteTempReg = availableRegisterOrNoneFor(backEnd, (liveRegisters()) | (1LL << tempVectReg));
	if (remoteTempReg == NoReg) {
		remoteTempReg = tempVectReg;
	}
	genLoadSlotsourceRegdestReg(byte1, tempVectReg, remoteTempReg);
	return ssPushRegister(remoteTempReg);
}


/*	If a frameless method (not a block), only argument temps can be accessed.
	This is assured by the use of needsFrameIfMod16GENumArgs: in pushTemp. */

	/* StackToRegisterMappingCogit>>#genPushTemporaryVariable: */
static sqInt NoDbgRegParms
genPushTemporaryVariable(sqInt index)
{
	assert(inBlock
	 || (needsFrame
	 || (index < methodOrBlockNumArgs)));
	return ssPushDesc(simStack[index]);
}


/*	In a frameless method ReceiverResultReg already contains self.
	In a frameful method, ReceiverResultReg /may/ contain self. */

	/* StackToRegisterMappingCogit>>#genReturnReceiver */
static sqInt
genReturnReceiver(void)
{
	if (needsFrame) {
		if (!((optStatus.isReceiverResultRegLive))) {
			/* begin putSelfInReceiverResultReg */
			storeToReg((&simSelf), ReceiverResultReg);
		}
	}
	return genUpArrowReturn();
}

	/* StackToRegisterMappingCogit>>#genReturnTopFromBlock */
static sqInt
genReturnTopFromBlock(void)
{
	assert(inBlock);
	popToReg(ssTop(), ReceiverResultReg);
	ssPop(1);
	return genBlockReturn();
}

	/* StackToRegisterMappingCogit>>#genReturnTopFromMethod */
static sqInt
genReturnTopFromMethod(void)
{
	popToReg(ssTop(), ReceiverResultReg);
	ssPop(1);
	return genUpArrowReturn();
}

	/* StackToRegisterMappingCogit>>#genSendSuper:numArgs: */
static sqInt NoDbgRegParms
genSendSupernumArgs(sqInt selectorIndex, sqInt numArgs)
{
	marshallSendArguments(numArgs);
	return genMarshalledSendnumArgssendTable(selectorIndex, numArgs, superSendTrampolines);
}


/*	Generate a trampoline with four arguments.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* StackToRegisterMappingCogit>>#genSendTrampolineFor:numArgs:called:arg:arg:arg:arg: */
static sqInt NoDbgRegParms
genSendTrampolineFornumArgscalledargargargarg(void *aRoutine, sqInt numArgs, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3)
{
    sqInt routine;
    sqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	routine = ceDereferenceSelectorIndex;
	if (!(routine == null)) {
		/* begin Call: */
		genoperand(Call, routine);
	}
	genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 4, regOrConst0, regOrConst1, regOrConst2, regOrConst3, 0, 1, NoReg, 1);
	return startAddress;
}

	/* StackToRegisterMappingCogit>>#genSend:numArgs: */
static sqInt NoDbgRegParms
genSendnumArgs(sqInt selectorIndex, sqInt numArgs)
{
	marshallSendArguments(numArgs);
	return genMarshalledSendnumArgssendTable(selectorIndex, numArgs, ordinarySendTrampolines);
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorArithmetic */
static sqInt
genSpecialSelectorArithmetic(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    char annotateInst;
    sqInt argInt;
    sqInt argIsConst;
    sqInt argIsInt;
    sqInt index;
    AbstractInstruction *instToAnnotate;
    AbstractInstruction *jumpContinue;
    AbstractInstruction *jumpNotSmallInts;
    sqInt literal;
    sqInt literal1;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrInt;
    sqInt rcvrIsConst;
    sqInt rcvrIsInt;
    sqInt result;

	annotateInst = 0;
	primDescriptor = generatorAt(byte0);
	argIsInt = ((argIsConst = (((ssTop())->type)) == SSConstant))
	 && ((((((argInt = ((ssTop())->constant)))) & 7) == 1));
	rcvrIsInt = ((rcvrIsConst = (((ssValue(1))->type)) == SSConstant))
	 && ((((((rcvrInt = ((ssValue(1))->constant)))) & 7) == 1));
	if (argIsInt
	 && (rcvrIsInt)) {
		rcvrInt = (rcvrInt >> 3);
		argInt = (argInt >> 3);
		
		switch ((primDescriptor->opcode)) {
		case AddRR:
			result = rcvrInt + argInt;
			break;
		case SubRR:
			result = rcvrInt - argInt;
			break;
		case AndRR:
			result = rcvrInt & argInt;
			break;
		case OrRR:
			result = rcvrInt | argInt;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		if (isIntegerValue(result)) {

			/* Must enter any annotatedConstants into the map */
			annotateBytecodeIfAnnotated(ssValue(1));
			annotateBytecodeIfAnnotated(ssTop());
			return (ssPop(2),
				ssPushAnnotatedConstant(((result << 3) | 1)));
		}
		return genSpecialSelectorSend();
	}
	if ((rcvrIsConst
	 && (!rcvrIsInt))
	 || (argIsConst
	 && (!argIsInt))) {
		return genSpecialSelectorSend();
	}
	if (!(argIsInt
		 || (rcvrIsInt))) {
		return genSpecialSelectorSend();
	}
	if (argIsInt) {
		ssFlushTo(simStackPtr - 2);
		popToReg(ssValue(1), ReceiverResultReg);
		annotateInst = ((ssTop())->annotateUse);
		ssPop(2);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	}
	else {
		marshallSendArguments(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, TempReg);
	}
	if (argIsInt
	 || (rcvrIsInt)) {
		/* begin genJumpNotSmallIntegerInScratchReg: */
		jumpNotSmallInts = genJumpNotSmallInteger(TempReg);
	}
	else {
		/* begin genJumpNotSmallIntegersIn:andScratch:scratch: */
		genoperandoperand(AndRR, ReceiverResultReg, TempReg);
		/* begin genJumpNotSmallIntegerInScratchReg: */
		jumpNotSmallInts = genJumpNotSmallInteger(TempReg);
	}
	
	switch ((primDescriptor->opcode)) {
	case AddRR:
		if (argIsInt) {
			/* begin AddCq:R: */
			literal = argInt - ConstZero;
			anInstruction = genoperandoperand(AddCqR, argInt - ConstZero, ReceiverResultReg);
			instToAnnotate = anInstruction;
			/* begin JumpNoOverflow: */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			/* begin SubCq:R: */
			anInstruction1 = genoperandoperand(SubCqR, argInt - ConstZero, ReceiverResultReg);
		}
		else {
			genRemoveSmallIntegerTagsInScratchReg(ReceiverResultReg);
			/* begin AddR:R: */
			genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
			/* begin JumpNoOverflow: */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			if (rcvrIsInt) {
				/* begin MoveCq:R: */
				anInstruction2 = genoperandoperand(MoveCqR, rcvrInt, ReceiverResultReg);
			}
			else {
				/* begin SubR:R: */
				genoperandoperand(SubRR, Arg0Reg, ReceiverResultReg);
				genSetSmallIntegerTagsIn(ReceiverResultReg);
			}
		}
		break;
	case SubRR:
		if (argIsInt) {
			/* begin SubCq:R: */
			anInstruction3 = genoperandoperand(SubCqR, argInt - ConstZero, ReceiverResultReg);
			instToAnnotate = anInstruction3;
			/* begin JumpNoOverflow: */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			/* begin AddCq:R: */
			literal1 = argInt - ConstZero;
			anInstruction4 = genoperandoperand(AddCqR, argInt - ConstZero, ReceiverResultReg);
		}
		else {
			genRemoveSmallIntegerTagsInScratchReg(Arg0Reg);
			/* begin SubR:R: */
			genoperandoperand(SubRR, Arg0Reg, ReceiverResultReg);
			/* begin JumpNoOverflow: */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			/* begin AddR:R: */
			genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
			genSetSmallIntegerTagsIn(Arg0Reg);
		}
		break;
	case AndRR:
		if (argIsInt) {
			/* begin AndCq:R: */
			anInstruction5 = genoperandoperand(AndCqR, argInt, ReceiverResultReg);
			instToAnnotate = anInstruction5;
		}
		else {
			/* begin AndR:R: */
			genoperandoperand(AndRR, Arg0Reg, ReceiverResultReg);
		}
		/* begin Jump: */
		jumpContinue = genoperand(Jump, ((sqInt)0));
		break;
	case OrRR:
		if (argIsInt) {
			/* begin OrCq:R: */
			anInstruction6 = genoperandoperand(OrCqR, argInt, ReceiverResultReg);
			instToAnnotate = anInstruction6;
		}
		else {
			/* begin OrR:R: */
			genoperandoperand(OrRR, Arg0Reg, ReceiverResultReg);
		}
		/* begin Jump: */
		jumpContinue = genoperand(Jump, ((sqInt)0));
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	jmpTarget(jumpNotSmallInts, gLabel());
	if (argIsInt) {
		if (annotateInst) {
			/* begin annotateBytecode: */
			(instToAnnotate->annotation = HasBytecodePC);
		}
		/* begin MoveCq:R: */
		anInstruction7 = genoperandoperand(MoveCqR, argInt, Arg0Reg);
	}
	index = byte0 - (
#if MULTIPLEBYTECODESETS
	(bytecodeSetOffset == 256
		? AltFirstSpecialSelector + 256
		: FirstSpecialSelector)
#else /* MULTIPLEBYTECODESETS */
	FirstSpecialSelector
#endif /* MULTIPLEBYTECODESETS */
	);
	genMarshalledSendnumArgssendTable((-index) - 1, 1, ordinarySendTrampolines);
	jmpTarget(jumpContinue, gLabel());
	return 0;
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorClass */
static sqInt
genSpecialSelectorClass(void)
{
    sqInt topReg;

	topReg = registerOrNone(ssTop());
	ssPop(1);
	if ((topReg == NoReg)
	 || (topReg == ClassReg)) {
		ssAllocateRequiredRegand((topReg = SendNumArgsReg), ClassReg);
	}
	else {
		ssAllocateRequiredReg(ClassReg);
	}
	ssPush(1);
	popToReg(ssTop(), topReg);
	genGetClassObjectOfintoscratchReginstRegIsReceiver(topReg, ClassReg, TempReg, 0);
	return (ssPop(1),
		ssPushRegister(ClassReg));
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorComparison */
static sqInt
genSpecialSelectorComparison(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    char annotateInst;
    sqInt argInt;
    sqInt argIsInt;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt descr;
    sqInt index;
    sqInt inlineCAB;
    AbstractInstruction *jumpNotSmallInts;
    void *jumpTarget;
    sqInt nExts;
    sqInt next;
    sqInt nextPC;
    sqInt nextPC1;
    sqInt postBranch;
    sqInt postBranchPC;
    sqInt postBranchPC1;
    BytecodeDescriptor *primDescriptor;
    BytecodeDescriptor *primDescriptor1;
    sqInt rcvrIsInt;
    sqInt target;
    sqInt targetBytecodePC;
    sqInt targetBytecodePC1;

	annotateInst = 0;
	ssFlushTo(simStackPtr - 2);
	primDescriptor = generatorAt(byte0);
	argIsInt = ((((ssTop())->type)) == SSConstant)
	 && ((((((argInt = ((ssTop())->constant)))) & 7) == 1));
	rcvrIsInt = ((((ssValue(1))->type)) == SSConstant)
	 && (((((((ssValue(1))->constant))) & 7) == 1));
	if (argIsInt
	 && (rcvrIsInt)) {
		return genStaticallyResolvedSpecialSelectorComparison();
	}
	/* begin extractMaybeBranchDescriptorInto: */
	primDescriptor1 = generatorAt(byte0);
	nextPC1 = bytecodePC + ((primDescriptor1->numBytes));
	nExts = 0;
	while (1) {
		branchDescriptor1 = generatorAt((fetchByteofObject(nextPC1, methodObj)) + bytecodeSetOffset);
		if (!((branchDescriptor1->isExtension))) break;
		nExts += 1;
		nextPC1 += (branchDescriptor1->numBytes);
	}
	targetBytecodePC1 = (postBranchPC1 = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC1 = (nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj));
		postBranchPC1 = nextPC1 + ((branchDescriptor1->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPC1;
	postBranchPC = postBranchPC1;
	targetBytecodePC = targetBytecodePC1;


	/* Further, only interested in inlining = and ~= if there's a SmallInteger constant involved.
	   The relational operators successfully statically predict SmallIntegers; the equality operators do not. */
	inlineCAB = ((branchDescriptor->isBranchTrue))
	 || ((branchDescriptor->isBranchFalse));
	if (inlineCAB
	 && ((((primDescriptor->opcode)) == JumpZero)
	 || (((primDescriptor->opcode)) == JumpNonZero))) {
		inlineCAB = argIsInt
		 || (rcvrIsInt);
	}
	if (!inlineCAB) {
		return genSpecialSelectorSend();
	}
	if (argIsInt) {
		popToReg(ssValue(1), ReceiverResultReg);
		annotateInst = ((ssTop())->annotateUse);
		ssPop(2);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	}
	else {
		marshallSendArguments(1);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, Arg0Reg, TempReg);
	}
	if (argIsInt
	 || (rcvrIsInt)) {
		/* begin genJumpNotSmallIntegerInScratchReg: */
		jumpNotSmallInts = genJumpNotSmallInteger(TempReg);
	}
	else {
		/* begin genJumpNotSmallIntegersIn:andScratch:scratch: */
		genoperandoperand(AndRR, ReceiverResultReg, TempReg);
		/* begin genJumpNotSmallIntegerInScratchReg: */
		jumpNotSmallInts = genJumpNotSmallInteger(TempReg);
	}
	if (argIsInt) {
		if (annotateInst) {
			/* begin annotateBytecode: */
			anInstruction = genoperandoperand(CmpCqR, argInt, ReceiverResultReg);
			abstractInstruction = anInstruction;
			(abstractInstruction->annotation = HasBytecodePC);
		}
		else {
			/* begin CmpCq:R: */
			anInstruction1 = genoperandoperand(CmpCqR, argInt, ReceiverResultReg);
		}
	}
	else {
		/* begin CmpR:R: */
		genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	}
	genConditionalBranchoperand(((branchDescriptor->isBranchTrue)
		? (primDescriptor->opcode)
		: inverseBranchFor((primDescriptor->opcode))), ((usqInt)(ensureNonMergeFixupAt(targetBytecodePC - initialPC))));
	/* begin Jump: */
	jumpTarget = ensureNonMergeFixupAt(postBranchPC - initialPC);
	genoperand(Jump, ((sqInt)jumpTarget));
	jmpTarget(jumpNotSmallInts, gLabel());
	if (argIsInt) {
		/* begin MoveCq:R: */
		anInstruction2 = genoperandoperand(MoveCqR, argInt, Arg0Reg);
	}
	index = byte0 - (
#if MULTIPLEBYTECODESETS
	(bytecodeSetOffset == 256
		? AltFirstSpecialSelector + 256
		: FirstSpecialSelector)
#else /* MULTIPLEBYTECODESETS */
	FirstSpecialSelector
#endif /* MULTIPLEBYTECODESETS */
	);
	return genMarshalledSendnumArgssendTable((-index) - 1, 1, ordinarySendTrampolines);
}


/*	Decompose code generation for #== into a common constant-folding version,
	followed by a double dispatch throguh the objectRepresentation to a
	version that doesn't deal with forwarders and a version that does. */

	/* StackToRegisterMappingCogit>>#genSpecialSelectorEqualsEquals */
static sqInt
genSpecialSelectorEqualsEquals(void)
{
    BytecodeDescriptor *primDescriptor;
    sqInt result;

	primDescriptor = generatorAt(byte0);
	if ((isUnannotatableConstant(ssTop()))
	 && (isUnannotatableConstant(ssValue(1)))) {
		assert(!((primDescriptor->isMapped)));
		result = ((((ssTop())->constant)) == (((ssValue(1))->constant))
			? trueObject()
			: falseObject());
		ssPop(2);
		return ssPushConstant(result);
	}
	return genSpecialSelectorEqualsEqualsWithForwarders();
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorEqualsEqualsWithForwarders */
static sqInt
genSpecialSelectorEqualsEqualsWithForwarders(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    sqInt arg;
    sqInt argReg;
    sqInt argReg1;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt constant;
    sqInt constant1;
    sqInt descr;
    AbstractInstruction *finished;
    AbstractInstruction *finished1;
    usqInt fixup;
    AbstractInstruction *imm;
    AbstractInstruction *imm1;
    void *jumpTarget;
    void *jumpTarget1;
    AbstractInstruction *label;
    sqInt literal;
    sqInt nExts;
    sqInt next;
    sqInt nextPC;
    sqInt nextPC1;
    AbstractInstruction *ok;
    AbstractInstruction *ok1;
    sqInt postBranch;
    sqInt postBranchPC;
    sqInt postBranchPC1;
    BytecodeDescriptor *primDescriptor;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt rcvr;
    sqInt rcvrReg;
    sqInt rcvrReg1;
    sqInt reg;
    sqInt rNext;
    sqInt rNext1;
    sqInt rTop;
    sqInt rTop1;
    sqInt target;
    sqInt targetBytecodePC;
    sqInt targetBytecodePC1;
    sqInt topRegistersMask;
    sqInt unforwardArg;
    sqInt unforwardRcvr;

	/* begin extractMaybeBranchDescriptorInto: */
	primDescriptor = generatorAt(byte0);
	nextPC1 = bytecodePC + ((primDescriptor->numBytes));
	nExts = 0;
	while (1) {
		branchDescriptor1 = generatorAt((fetchByteofObject(nextPC1, methodObj)) + bytecodeSetOffset);
		if (!((branchDescriptor1->isExtension))) break;
		nExts += 1;
		nextPC1 += (branchDescriptor1->numBytes);
	}
	targetBytecodePC1 = (postBranchPC1 = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC1 = (nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj));
		postBranchPC1 = nextPC1 + ((branchDescriptor1->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPC1;
	postBranchPC = postBranchPC1;
	targetBytecodePC = targetBytecodePC1;

	unforwardRcvr = !(isUnannotatableConstant(ssValue(1)));
	unforwardArg = !(isUnannotatableConstant(ssTop()));
	/* begin allocateEqualsEqualsRegistersArgNeedsReg:rcvrNeedsReg:into: */
	assert(unforwardArg
	 || (unforwardRcvr));
	argReg1 = (rcvrReg1 = NoReg);
	if (unforwardArg) {
		if (unforwardRcvr) {
			/* begin allocateRegForStackTopTwoEntriesInto: */
			topRegistersMask = 0;
			rTop1 = (rNext1 = NoReg);
			if ((((ssTop())->type)) == SSRegister) {
				rTop1 = ((ssTop())->registerr);
			}
			if ((((ssValue(1))->type)) == SSRegister) {
				/* begin registerMaskFor: */
				reg = (rNext1 = ((ssValue(1))->registerr));
				topRegistersMask = 1LL << reg;
			}
			if (rTop1 == NoReg) {
				rTop1 = allocateRegNotConflictingWith(topRegistersMask);
			}
			if (rNext1 == NoReg) {
				rNext1 = allocateRegNotConflictingWith(1LL << rTop1);
			}
			assert(!(((rTop1 == NoReg)
 || (rNext1 == NoReg))));
			argReg1 = rTop1;
			rcvrReg1 = rNext1;

			popToReg(ssTop(), argReg1);
			popToReg(ssValue(1), rcvrReg1);
		}
		else {
			argReg1 = allocateRegForStackEntryAtnotConflictingWith(0, 0);
			popToReg(ssTop(), argReg1);
			if (((ssValue(1))->spilled)) {
				/* begin AddCq:R: */
				literal = BytesPerWord;
				anInstruction4 = genoperandoperand(AddCqR, BytesPerWord, SPReg);
			}
		}
	}
	else {
		assert(unforwardRcvr);
		assert(!((((ssTop())->spilled))));
		rcvrReg1 = allocateRegForStackEntryAtnotConflictingWith(1, 0);
		popToReg(ssValue(1), rcvrReg1);
	}
	assert(!((unforwardArg
 && (argReg1 == NoReg))));
	assert(!((unforwardRcvr
 && (rcvrReg1 == NoReg))));
	rcvrReg = rcvrReg1;
	argReg = argReg1;

	if (!(((branchDescriptor->isBranchTrue))
		 || ((branchDescriptor->isBranchFalse)))) {
		return genEqualsEqualsNoBranchArgIsConstantrcvrIsConstantargRegrcvrReg(!unforwardArg, !unforwardRcvr, argReg, rcvrReg);
	}
	ssFlushTo(simStackPtr - 2);
	/* begin Label */
	label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin genEqualsEqualsComparisonArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	if (!unforwardArg) {
		/* begin genCompConstant:R: */
		constant = ((ssTop())->constant);
		if (shouldAnnotateObjectReference(constant)) {
			annotateobjRef(gCmpCwR(constant, rcvrReg), constant);
		}
		else {
			/* begin CmpCq:R: */
			anInstruction = genoperandoperand(CmpCqR, constant, rcvrReg);
		}
	}
	else {
		if (!unforwardRcvr) {
			/* begin genCompConstant:R: */
			constant1 = ((ssValue(1))->constant);
			if (shouldAnnotateObjectReference(constant1)) {
				annotateobjRef(gCmpCwR(constant1, argReg), constant1);
			}
			else {
				/* begin CmpCq:R: */
				anInstruction1 = genoperandoperand(CmpCqR, constant1, argReg);
			}
		}
		else {
			/* begin CmpR:R: */
			genoperandoperand(CmpRR, argReg, rcvrReg);
		}
	}
	ssPop(2);
	if ((((fixupAt(nextPC - initialPC))->targetInstruction)) == 0) {

		/* The next instruction is dead.  we can skip it. */
		deadCode = 1;
		ensureFixupAt(targetBytecodePC - initialPC);
		ensureFixupAt(postBranchPC - initialPC);
	}
	else {
		ssPushConstant(trueObject());
	}
	assert(unforwardArg
	 || (unforwardRcvr));
	if ((branchDescriptor->isBranchTrue)) {
		fixup = ((usqInt)(ensureNonMergeFixupAt(postBranchPC - initialPC)));
		/* begin JumpZero: */
		jumpTarget = ((void *) (((usqInt)(ensureNonMergeFixupAt(targetBytecodePC - initialPC)))));
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
	}
	else {

		/* branchDescriptor is branchFalse */
		fixup = ((usqInt)(ensureNonMergeFixupAt(targetBytecodePC - initialPC)));
		/* begin JumpZero: */
		jumpTarget1 = ((void *) (((usqInt)(ensureNonMergeFixupAt(postBranchPC - initialPC)))));
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget1));
	}
	if (unforwardArg) {
		if (unforwardRcvr) {
			genEnsureOopInRegNotForwardedscratchRegjumpBackTo(argReg, TempReg, label);
		}
		else {
			/* begin genEnsureOopInRegNotForwarded:scratchReg:ifForwarder:ifNotForwarder: */
			assert(argReg != TempReg);

			/* notionally
			   self genGetClassIndexOfNonImm: reg into: scratch.
			   cogit CmpCq: objectMemory isForwardedObjectClassIndexPun R: TempReg.
			   but the following is an instruction shorter: */
			imm = genJumpImmediate(argReg);
			/* begin MoveMw:r:R: */
			anInstruction2 = genoperandoperandoperand(MoveMwrR, 0, argReg, TempReg);
			/* begin AndCq:R: */
			quickConstant = (classIndexMask()) - (isForwardedObjectClassIndexPun());
			/* begin gen:quickConstant:operand: */
			anInstruction11 = genoperandoperand(AndCqR, quickConstant, TempReg);
			/* begin JumpNonZero: */
			ok = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
			genLoadSlotsourceRegdestReg(0, argReg, argReg);
			/* begin Jump: */
			genoperand(Jump, ((sqInt)(((void *) label))));
			if (fixup == 0) {
				/* begin Label */
				finished = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			else {
				finished = ((AbstractInstruction *) fixup);
			}
			jmpTarget(imm, jmpTarget(ok, finished));
		}
	}
	if (unforwardRcvr) {
		/* begin genEnsureOopInRegNotForwarded:scratchReg:ifForwarder:ifNotForwarder: */
		assert(rcvrReg != TempReg);

		/* notionally
		   self genGetClassIndexOfNonImm: reg into: scratch.
		   cogit CmpCq: objectMemory isForwardedObjectClassIndexPun R: TempReg.
		   but the following is an instruction shorter: */
		imm1 = genJumpImmediate(rcvrReg);
		/* begin MoveMw:r:R: */
		anInstruction3 = genoperandoperandoperand(MoveMwrR, 0, rcvrReg, TempReg);
		/* begin AndCq:R: */
		quickConstant1 = (classIndexMask()) - (isForwardedObjectClassIndexPun());
		/* begin gen:quickConstant:operand: */
		anInstruction12 = genoperandoperand(AndCqR, quickConstant1, TempReg);
		/* begin JumpNonZero: */
		ok1 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
		genLoadSlotsourceRegdestReg(0, rcvrReg, rcvrReg);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)(((void *) label))));
		if (fixup == 0) {
			/* begin Label */
			finished1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		else {
			finished1 = ((AbstractInstruction *) fixup);
		}
		jmpTarget(imm1, jmpTarget(ok1, finished1));
	}
	return 0;
}


/*	Assumes both operands are ints */

	/* StackToRegisterMappingCogit>>#genStaticallyResolvedSpecialSelectorComparison */
static sqInt
genStaticallyResolvedSpecialSelectorComparison(void)
{
    sqInt argInt;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrInt;
    sqInt result;

	primDescriptor = generatorAt(byte0);
	argInt = ((ssTop())->constant);
	rcvrInt = ((ssValue(1))->constant);
	
	switch ((primDescriptor->opcode)) {
	case JumpLess:
		result = rcvrInt < argInt;
		break;
	case JumpLessOrEqual:
		result = rcvrInt <= argInt;
		break;
	case JumpGreater:
		result = rcvrInt > argInt;
		break;
	case JumpGreaterOrEqual:
		result = rcvrInt >= argInt;
		break;
	case JumpZero:
		result = rcvrInt == argInt;
		break;
	case JumpNonZero:
		result = rcvrInt != argInt;
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	annotateBytecodeIfAnnotated(ssValue(1));
	annotateBytecodeIfAnnotated(ssTop());
	ssPop(2);
	return ssPushAnnotatedConstant((result
		? trueObject()
		: falseObject()));
}


/*	The only reason we assert needsFrame here is that in a frameless method
	ReceiverResultReg must and does contain only self, but the ceStoreCheck
	trampoline expects the target of the store to be in ReceiverResultReg. So
	in a frameless method we would have a conflict between the receiver and
	the literal store, unless we we smart enough to realise that
	ReceiverResultReg was unused after the literal variable store, unlikely
	given that methods
	return self by default. */

	/* StackToRegisterMappingCogit>>#genStorePop:LiteralVariable: */
static sqInt NoDbgRegParms
genStorePopLiteralVariable(sqInt popBoolean, sqInt litVarIndex)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction2;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt association;
    AbstractInstruction *fail;
    AbstractInstruction * immutabilityFailure;
    AbstractInstruction *mutableJump;
    sqInt needStoreCheck;
    sqInt topReg;

	assert(needsFrame);
	
#  if IMMUTABILITY
	ssFlushTo(simStackPtr - 1);

#  endif /* IMMUTABILITY */

	needStoreCheck = !(isUnannotatableConstant(ssTop()));
	association = getLiteral(litVarIndex);
	(optStatus.isReceiverResultRegLive = 0);
	ssAllocateRequiredReg(ReceiverResultReg);
	/* begin genMoveConstant:R: */
	if (shouldAnnotateObjectReference(association)) {
		annotateobjRef(gMoveCwR(association, ReceiverResultReg), association);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, association, ReceiverResultReg);
	}
	genEnsureObjInRegNotForwardedscratchReg(ReceiverResultReg, TempReg);
	
#  if IMMUTABILITY
	ssAllocateRequiredReg(ClassReg);
	topReg = ClassReg;
	ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
	ssFlushTo(simStackPtr);
	/* begin genImmutableCheck:slotIndex:sourceReg:scratchReg:needRestoreRcvr: */
	assert(ReceiverResultReg == ReceiverResultReg);
	assert(TempReg == TempReg);
	assert(ClassReg == ClassReg);

	/* We reach this code if the object mutated is immutable. */
	mutableJump = genJumpMutablescratchReg(ReceiverResultReg, TempReg);
	/* begin MoveCq:R: */
	anInstruction1 = genoperandoperand(MoveCqR, ValueIndex, TempReg);
	/* begin CallRT: */
	abstractInstruction1 = genoperand(Call, ceCannotAssignToWithIndexTrampoline);
	(abstractInstruction1->annotation = IsRelativeCall);
	/* begin annotateBytecode: */
	abstractInstruction2 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction2->annotation = HasBytecodePC);
	/* begin Jump: */
	fail = genoperand(Jump, ((sqInt)0));
	jmpTarget(mutableJump, gLabel());
	immutabilityFailure = fail;

#  else /* IMMUTABILITY */
	topReg = allocateRegForStackEntryAtnotConflictingWith(0, 1LL << ReceiverResultReg);
	ssStorePoptoReg(popBoolean, topReg);

#  endif /* IMMUTABILITY */

	if (traceStores > 0) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, topReg, TempReg);
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, ValueIndex, ReceiverResultReg, TempReg, needsFrame, needStoreCheck);
	
#  if IMMUTABILITY
	jmpTarget(immutabilityFailure, gLabel());

#  endif /* IMMUTABILITY */

	return 0;
}

	/* StackToRegisterMappingCogit>>#genStorePop:MaybeContextReceiverVariable: */
static sqInt NoDbgRegParms
genStorePopMaybeContextReceiverVariable(sqInt popBoolean, sqInt slotIndex)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction11;
    AbstractInstruction *abstractInstruction2;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *fail;
    AbstractInstruction * immutabilityFailure;
    AbstractInstruction *jmpDone;
    AbstractInstruction *jmpSingle;
    AbstractInstruction *mutableJump;
    sqInt needStoreCheck;


	/* The reason we need a frame here is that assigning to an inst var of a context may
	   involve wholesale reorganization of stack pages, and the only way to preserve the
	   execution state of an activation in that case is if it has a frame. */
	assert(needsFrame);
	
#  if IMMUTABILITY
	ssFlushTo(simStackPtr - 1);

#  endif /* IMMUTABILITY */

	ssFlushUpThroughReceiverVariable(slotIndex);

	/* Note that ReceiverResultReg remains live after both
	   ceStoreContextInstVarTrampoline and ceStoreCheckTrampoline. */
	needStoreCheck = !(isUnannotatableConstant(ssTop()));
	ensureReceiverResultRegContainsSelf();
	ssPop(1);
	ssAllocateCallRegand(ClassReg, SendNumArgsReg);
	ssPush(1);
	genLoadSlotsourceRegdestReg(SenderIndex, ReceiverResultReg, TempReg);
	
#  if IMMUTABILITY
	ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
	ssFlushTo(simStackPtr);

#  else /* IMMUTABILITY */
	ssStorePoptoReg(popBoolean, ClassReg);

#  endif /* IMMUTABILITY */

	/* begin genJumpNotSmallIntegerInScratchReg: */
	jmpSingle = genJumpNotSmallInteger(TempReg);
	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
	/* begin CallRT: */
	abstractInstruction1 = genoperand(Call, ceStoreContextInstVarTrampoline);
	(abstractInstruction1->annotation = IsRelativeCall);
	/* begin Jump: */
	jmpDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jmpSingle, gLabel());
	if (traceStores > 0) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, TempReg);
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	
#  if IMMUTABILITY
	/* begin genImmutableCheck:slotIndex:sourceReg:scratchReg:needRestoreRcvr: */
	assert(ReceiverResultReg == ReceiverResultReg);
	assert(TempReg == TempReg);
	assert(ClassReg == ClassReg);

	/* We reach this code if the object mutated is immutable. */
	mutableJump = genJumpMutablescratchReg(ReceiverResultReg, TempReg);
	/* begin MoveCq:R: */
	anInstruction1 = genoperandoperand(MoveCqR, ValueIndex, TempReg);
	/* begin CallRT: */
	abstractInstruction11 = genoperand(Call, ceCannotAssignToWithIndexTrampoline);
	(abstractInstruction11->annotation = IsRelativeCall);
	/* begin annotateBytecode: */
	abstractInstruction2 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction2->annotation = HasBytecodePC);
	/* begin putSelfInReceiverResultReg */
	storeToReg((&simSelf), ReceiverResultReg);

	/* begin Jump: */
	fail = genoperand(Jump, ((sqInt)0));
	jmpTarget(mutableJump, gLabel());
	immutabilityFailure = fail;

#  endif /* IMMUTABILITY */

	genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(ClassReg, slotIndex, ReceiverResultReg, TempReg, 1, needStoreCheck);
	jmpTarget(jmpDone, gLabel());
	
#  if IMMUTABILITY
	jmpTarget(immutabilityFailure, gLabel());

#  endif /* IMMUTABILITY */

	return 0;
}

	/* StackToRegisterMappingCogit>>#genStorePop:ReceiverVariable: */
static sqInt NoDbgRegParms
genStorePopReceiverVariable(sqInt popBoolean, sqInt slotIndex)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction11;
    AbstractInstruction *abstractInstruction2;
    AbstractInstruction *anInstruction;
    AbstractInstruction *fail;
    AbstractInstruction * immutabilityFailure;
    AbstractInstruction *mutableJump;
    sqInt needStoreCheck;
    sqInt topReg;

	
#  if IMMUTABILITY
	assert(needsFrame);
	ssFlushTo(simStackPtr - 1);

#  endif /* IMMUTABILITY */

	ssFlushUpThroughReceiverVariable(slotIndex);

	/* Note that ReceiverResultReg remains live after ceStoreCheckTrampoline. */
	needStoreCheck = !(isUnannotatableConstant(ssTop()));
	ensureReceiverResultRegContainsSelf();
	
#  if IMMUTABILITY
	ssAllocateRequiredReg(ClassReg);
	topReg = ClassReg;
	ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
	ssFlushTo(simStackPtr);
	/* begin genImmutableCheck:slotIndex:sourceReg:scratchReg:needRestoreRcvr: */
	assert(ReceiverResultReg == ReceiverResultReg);
	assert(TempReg == TempReg);
	assert(ClassReg == ClassReg);

	/* We reach this code if the object mutated is immutable. */
	mutableJump = genJumpMutablescratchReg(ReceiverResultReg, TempReg);
	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, slotIndex, TempReg);
	/* begin CallRT: */
	abstractInstruction11 = genoperand(Call, ceCannotAssignToWithIndexTrampoline);
	(abstractInstruction11->annotation = IsRelativeCall);
	/* begin annotateBytecode: */
	abstractInstruction2 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	(abstractInstruction2->annotation = HasBytecodePC);
	/* begin putSelfInReceiverResultReg */
	storeToReg((&simSelf), ReceiverResultReg);

	/* begin Jump: */
	fail = genoperand(Jump, ((sqInt)0));
	jmpTarget(mutableJump, gLabel());
	immutabilityFailure = fail;

#  else /* IMMUTABILITY */
	topReg = allocateRegForStackEntryAtnotConflictingWith(0, 1LL << ReceiverResultReg);
	ssStorePoptoReg(popBoolean, topReg);

#  endif /* IMMUTABILITY */

	if (traceStores > 0) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, topReg, TempReg);
		/* begin evaluateTrampolineCallBlock:protectLinkRegIfNot: */
		if (needsFrame) {
			/* begin CallRT: */
			abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
			(abstractInstruction->annotation = IsRelativeCall);

		}
		else {
			/* begin CallRT: */
			abstractInstruction1 = genoperand(Call, ceTraceStoreTrampoline);
			(abstractInstruction1->annotation = IsRelativeCall);


		}
	}
	genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, slotIndex, ReceiverResultReg, TempReg, needsFrame, needStoreCheck);
	
#  if IMMUTABILITY
	jmpTarget(immutabilityFailure, gLabel());

#  endif /* IMMUTABILITY */

	return 0;
}


/*	The only reason we assert needsFrame here is that in a frameless method
	ReceiverResultReg must and does contain only self, but the ceStoreCheck
	trampoline expects the target of the store to be in ReceiverResultReg. So
	in a frameless method we would have a conflict between the receiver and
	the temote temp store, unless we we smart enough to realise that
	ReceiverResultReg was unused after the literal variable store, unlikely
	given that methods return self by default. */

	/* StackToRegisterMappingCogit>>#genStorePop:RemoteTemp:At: */
static sqInt NoDbgRegParms
genStorePopRemoteTempAt(sqInt popBoolean, sqInt slotIndex, sqInt remoteTempIndex)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt needStoreCheck;
    sqInt offset;
    sqInt topReg;

	assert(needsFrame);
	needStoreCheck = !(isUnannotatableConstant(ssTop()));
	topReg = allocateRegForStackEntryAtnotConflictingWith(0, 1LL << ReceiverResultReg);
	ssAllocateRequiredReg(ReceiverResultReg);
	(optStatus.isReceiverResultRegLive = 0);
	ssStoreAndReplacePoptoReg(popBoolean, topReg);
	/* begin MoveMw:r:R: */
	offset = frameOffsetOfTemporary(remoteTempIndex);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, ReceiverResultReg);
	if (traceStores > 0) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, topReg, TempReg);
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, slotIndex, ReceiverResultReg, TempReg, needsFrame, needStoreCheck);
}

	/* StackToRegisterMappingCogit>>#genStorePop:TemporaryVariable: */
static sqInt NoDbgRegParms
genStorePopTemporaryVariable(sqInt popBoolean, sqInt tempIndex)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt reg;

	ssFlushUpThroughTemporaryVariable(tempIndex);
	reg = ssStorePoptoPreferredReg(popBoolean, TempReg);
	/* begin MoveR:Mw:r: */
	offset = frameOffsetOfTemporary(tempIndex);
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, reg, offset, FPReg);
	return 0;
}


/*	Generate a method return from within a method or a block.
	Frameless method activation looks like
	CISCs (x86):
	receiver
	args
	sp->	ret pc.
	RISCs (ARM):
	receiver
	args
	ret pc in LR.
	A fully framed activation is described in CoInterpreter
	class>initializeFrameIndices. Return pops receiver and arguments off the
	stack. Callee pushes the result. */

	/* StackToRegisterMappingCogit>>#genUpArrowReturn */
static sqInt
genUpArrowReturn(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    sqInt offset;

	if (inBlock) {
		assert(needsFrame);
		/* begin CallRT: */
		abstractInstruction1 = genoperand(Call, ceNonLocalReturnTrampoline);
		(abstractInstruction1->annotation = IsRelativeCall);
		/* begin annotateBytecode: */
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		(abstractInstruction->annotation = HasBytecodePC);
		return 0;
	}
	if (needsFrame) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, FPReg, SPReg);
		/* begin PopR: */
		genoperand(PopR, FPReg);
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	else {
		/* begin RetN: */
		offset = ((methodOrBlockNumArgs > 2)
		 || (regArgsHaveBeenPushed)
			? (methodOrBlockNumArgs + 1) * BytesPerWord
			: 0);
		genoperand(RetN, offset);
	}
	return 0;
}


/*	Make sure there's a flagged fixup at the targetIndex (pc relative to first
	pc) in fixups.
	These are the targets of backward branches. A backward branch fixup's
	simStackPtr needs to be set when generating the code for the bytecode at
	the targetIndex.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#initializeFixupAt: */
static BytecodeFixup * NoDbgRegParms
initializeFixupAt(sqInt targetIndex)
{
    BytecodeFixup *fixup;

	fixup = fixupAt(targetIndex);
	(fixup->targetInstruction = ((AbstractInstruction *) 2));
	(fixup->simStackPtr = -2);
	return fixup;
}

	/* StackToRegisterMappingCogit>>#initSimStackForFramefulMethod: */
static void NoDbgRegParms
initSimStackForFramefulMethod(sqInt startpc)
{
    CogSimStackEntry *desc;
    sqInt i;

	(simSelf.type = SSBaseOffset);
	(simSelf.spilled = 1);
	(simSelf.annotateUse = 0);
	(simSelf.registerr = FPReg);
	(simSelf.offset = FoxMFReceiver);
	(optStatus.isReceiverResultRegLive = 0);
	(optStatus.ssEntry = (&simSelf));

	/* N.B. Includes num args */
	simSpillBase = methodOrBlockNumTemps;

	/* args */
	simStackPtr = simSpillBase - 1;
	for (i = 0; i < methodOrBlockNumArgs; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->annotateUse = 0);
		(desc->registerr = FPReg);
		(desc->offset = FoxCallerSavedIP + ((methodOrBlockNumArgs - i) * BytesPerWord));
		(desc->bcptr = startpc);
	}
	for (i = methodOrBlockNumArgs; i <= simStackPtr; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->annotateUse = 0);
		(desc->registerr = FPReg);
		(desc->offset = FoxMFReceiver - (((i - methodOrBlockNumArgs) + 1) * BytesPerWord));
		(desc->bcptr = startpc);
	}
}


/*	The register receiver (the closure itself) and args are pushed by the
	closure value primitive(s)
	and hence a frameless block has all arguments and copied values pushed to
	the stack. However,
	the method receiver (self) is put in the ReceiverResultRegister by the
	block entry. */

	/* StackToRegisterMappingCogit>>#initSimStackForFramelessBlock: */
static void NoDbgRegParms
initSimStackForFramelessBlock(sqInt startpc)
{
    CogSimStackEntry *desc;
    sqInt i;

	(simSelf.type = SSRegister);
	(simSelf.spilled = 0);
	(simSelf.annotateUse = 0);
	(simSelf.registerr = ReceiverResultReg);
	(optStatus.isReceiverResultRegLive = 1);
	(optStatus.ssEntry = (&simSelf));
	assert(methodOrBlockNumTemps >= methodOrBlockNumArgs);
	for (i = 0; i < methodOrBlockNumTemps; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->annotateUse = 0);
		(desc->registerr = SPReg);
		(desc->offset = (methodOrBlockNumArgs - i) * BytesPerWord);
		(desc->bcptr = startpc);
	}
	simSpillBase = (simStackPtr = methodOrBlockNumTemps - 1);
}

	/* StackToRegisterMappingCogit>>#initSimStackForFramelessMethod: */
static void NoDbgRegParms
initSimStackForFramelessMethod(sqInt startpc)
{
    CogSimStackEntry *desc;
    sqInt i;

	(simSelf.type = SSRegister);
	(simSelf.spilled = 0);
	(simSelf.annotateUse = 0);
	(simSelf.registerr = ReceiverResultReg);
	(optStatus.isReceiverResultRegLive = 1);
	(optStatus.ssEntry = (&simSelf));
	assert(methodOrBlockNumTemps >= methodOrBlockNumArgs);
	assert((numRegArgs()) <= 2);
	if (((methodOrBlockNumArgs >= 1) && (methodOrBlockNumArgs <= 2))) {
		desc = simStackAt(0);
		(desc->type = SSRegister);
		(desc->spilled = 0);
		(desc->annotateUse = 0);
		(desc->registerr = Arg0Reg);
		(desc->bcptr = startpc);
		if (methodOrBlockNumArgs > 1) {
			desc = simStackAt(1);
			(desc->type = SSRegister);
			(desc->spilled = 0);
			(desc->annotateUse = 0);
			(desc->registerr = Arg1Reg);
			(desc->bcptr = startpc);
		}
	}
	else {
		for (i = 0; i < methodOrBlockNumArgs; i += 1) {
			desc = simStackAt(i);
			(desc->type = SSBaseOffset);
			(desc->registerr = SPReg);
			(desc->spilled = 1);
			(desc->annotateUse = 0);
			(desc->offset = (methodOrBlockNumArgs - i) * BytesPerWord);
			(desc->bcptr = startpc);
		}
	}
	simSpillBase = (simStackPtr = methodOrBlockNumArgs - 1);
}

	/* StackToRegisterMappingCogit>>#liveRegisters */
static sqInt
liveRegisters(void)
{
    sqInt i;
    sqInt regsSet;

	if (needsFrame) {
		regsSet = 0;
	}
	else {
		regsSet = 1LL << ReceiverResultReg;
		if ((methodOrBlockNumArgs <= 2)
		 && (methodOrBlockNumArgs > 0)) {
			regsSet = regsSet | (1LL << Arg0Reg);
			if (methodOrBlockNumArgs > 1) {
				regsSet = regsSet | (1LL << Arg1Reg);
			}
		}
	}
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= simStackPtr; i += 1) {
		regsSet = regsSet | (registerMask(simStackAt(i)));
	}
	return regsSet;
}


/*	Spill everything on the simulated stack that needs spilling (that below
	receiver and arguments).
	Marshall receiver and arguments to stack and/or registers depending on arg
	count. If the args don't fit in registers push receiver and args (spill
	everything), but still assign
	the receiver to ReceiverResultReg. */

	/* StackToRegisterMappingCogit>>#marshallSendArguments: */
static void NoDbgRegParms
marshallSendArguments(sqInt numArgs)
{
    sqInt anyRefs;
    CogSimStackEntry * cascade0;
    sqInt numSpilled;

	ssFlushTo((simStackPtr - numArgs) - 1);
	if (numArgs > 2) {

		/* If there are no spills and no references to ReceiverResultReg
		   the fetch of ReceiverResultReg from the stack can be avoided
		   by assigning directly to ReceiverResultReg and pushing it. */
		numSpilled = numberOfSpillsInTopNItems(numArgs + 1);
		anyRefs = anyReferencesToRegisterinTopNItems(ReceiverResultReg, numArgs + 1);
		if ((numSpilled > 0)
		 || (anyRefs)) {
			ssFlushTo(simStackPtr);
			storeToReg(simStackAt(simStackPtr - numArgs), ReceiverResultReg);
		}
		else {
			cascade0 = simStackAt(simStackPtr - numArgs);
			storeToReg(cascade0, ReceiverResultReg);
			(cascade0->type = SSRegister);
			(cascade0->registerr = ReceiverResultReg);
			ssFlushTo(simStackPtr);
		}
	}
	else {

		/* Move the args to the register arguments, being careful to do
		   so last to first so e.g. previous contents don't get overwritten.
		   Also check for any arg registers in use by other args. */
		if (numArgs > 0) {
			if (numArgs > 1) {
				ssAllocateRequiredRegupThrough(Arg0Reg, simStackPtr - 2);
				ssAllocateRequiredRegupThrough(Arg1Reg, simStackPtr - 1);
			}
			else {
				ssAllocateRequiredRegupThrough(Arg0Reg, simStackPtr - 1);
			}
		}
		if (numArgs > 1) {
			popToReg(simStackAt(simStackPtr), Arg1Reg);
		}
		if (numArgs > 0) {
			popToReg(simStackAt((simStackPtr - numArgs) + 1), Arg0Reg);
		}
		popToReg(simStackAt(simStackPtr - numArgs), ReceiverResultReg);
	}
	ssPop(numArgs + 1);
}


/*	Merge control flow at a fixup. The fixup holds the simStackPtr at the jump
	to this target.
	See stackToRegisterMapping on the class side for a full description. */

	/* StackToRegisterMappingCogit>>#merge:afterContinuation: */
static void NoDbgRegParms
mergeafterContinuation(BytecodeFixup *fixup, sqInt mergeWithContinuation)
{
    sqInt i;

	traceMerge(fixup);
	(optStatus.isReceiverResultRegLive = 0);
	if (!mergeWithContinuation) {
		assert((((usqInt)((fixup->targetInstruction)))) >= 2);
		simStackPtr = (fixup->simStackPtr);
	}
	if ((((usqInt)((fixup->targetInstruction)))) <= 2) {

		/* This is either a forward or backward branch target.
		   The stack must be flushed. */
		ssFlushTo(simStackPtr);
		if (((fixup->simStackPtr)) <= -2) {

			/* This is the target of a backward branch.  It doesn't have a simStackPtr yet. */
			(fixup->simStackPtr = simStackPtr);
		}
		(fixup->targetInstruction = gLabel());
	}
	assert(simStackPtr >= ((fixup->simStackPtr)));
	simStackPtr = (fixup->simStackPtr);

	/* For now throw away all type information for values on the stack, but sometime consider
	   the more sophisticated merge described in the class side stackToRegisterMapping. */
	simSpillBase = methodOrBlockNumTemps;
	for (i = methodOrBlockNumTemps; i <= simStackPtr; i += 1) {
		mergeAtfrom(simStackAt(i), FoxMFReceiver - (((i - methodOrBlockNumArgs) + 1) * BytesPerOop), FPReg);
	}
}

	/* StackToRegisterMappingCogit>>#methodAbortTrampolineFor: */
static sqInt NoDbgRegParms
methodAbortTrampolineFor(sqInt numArgs)
{
	return methodAbortTrampolines[((numArgs < (2 + 1)) ? numArgs : (2 + 1))];
}

	/* StackToRegisterMappingCogit>>#needsFrameIfMod16GENumArgs: */
static sqInt NoDbgRegParms
needsFrameIfMod16GENumArgs(sqInt stackDelta)
{
	return (byte0 % 16) >= methodOrBlockNumArgs;
}


/*	As of August 2013, the code generator can't deal with spills in frameless
	methods (the
	issue is to do with the stack offset to get at an argument, which is
	changed when there's a spill).
	In e.g. TextColor>>#dominates: other ^other class == self class the second
	send of class
	needs also rto allocate a register that the first one used, but the first
	one's register can't be
	spilled. So avoid this by only allowing class to be sent if the stack
	contains a single element. */

	/* StackToRegisterMappingCogit>>#needsFrameIfStackGreaterThanOne: */
static sqInt NoDbgRegParms
needsFrameIfStackGreaterThanOne(sqInt stackDelta)
{
	return stackDelta > 1;
}

	/* StackToRegisterMappingCogit>>#numberOfSpillsInTopNItems: */
static sqInt NoDbgRegParms
numberOfSpillsInTopNItems(sqInt n)
{
    sqInt i;

	for (i = simStackPtr; i >= ((simStackPtr - n) + 1); i += -1) {
		if ((((simStackAt(i))->type)) == SSSpill) {
			return n - (simStackPtr - i);
		}
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#picAbortTrampolineFor: */
static sqInt NoDbgRegParms
picAbortTrampolineFor(sqInt numArgs)
{
	return picAbortTrampolines[((numArgs < (2 + 1)) ? numArgs : (2 + 1))];
}

	/* StackToRegisterMappingCogit>>#prevInstIsPCAnnotated */
static sqInt
prevInstIsPCAnnotated(void)
{
    sqInt prevIndex;
    AbstractInstruction *prevInst;

	if (!(opcodeIndex > 0)) {
		return 0;
	}
	prevIndex = opcodeIndex - 1;
	while (1) {
		if (prevIndex <= 0) {
			return 0;
		}
		prevInst = abstractInstructionAt(prevIndex);
		if (isPCMappedAnnotation((!((prevInst->annotation))
			? 0
			: (prevInst->annotation)))) {
			return 1;
		}
		if (!(((prevInst->opcode)) == Label)) break;
		prevIndex -= 1;
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#pushNilSize:numInitialNils: */
static sqInt NoDbgRegParms
pushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils)
{
    sqInt (* const pushNilSizeFunction)(sqInt,sqInt) = v3PushNilSizenumInitialNils;

	return pushNilSizeFunction(aMethodObj, numInitialNils);
}


/*	When a block must be recompiled due to overestimating the
	numInitialNils fixups must be restored, which means rescannning
	since backward branches need their targets initialized. */

	/* StackToRegisterMappingCogit>>#reinitializeFixupsFrom:through: */
static void NoDbgRegParms
reinitializeFixupsFromthrough(sqInt start, sqInt end)
{
    BytecodeFixup * cascade0;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt nExts;
    sqInt pc;
    sqInt targetPC;

	pc = start;
	nExts = 0;
	while (pc <= end) {
		cascade0 = fixupAt(pc - initialPC);
		(cascade0->targetInstruction = 0);
		(cascade0->simStackPtr = null);
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((isBranch(descriptor))
		 && (isBackwardBranchatextsin(descriptor, pc, nExts, methodObj))) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			initializeFixupAt(targetPC - initialPC);
		}
		if ((descriptor->isBlockCreation)) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			pc = (pc + ((descriptor->numBytes))) + distance;
		}
		else {
			pc += (descriptor->numBytes);
		}
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
	}
}


/*	Scan the block to determine if the block needs a frame or not */

	/* StackToRegisterMappingCogit>>#scanBlock: */
static void NoDbgRegParms
scanBlock(BlockStart *blockStart)
{
    BytecodeDescriptor *descriptor;
    sqInt end;
    sqInt framelessStackDelta;
    sqInt nExts;
    sqInt numPushNils;
    sqInt (* const numPushNilsFunction)(struct _BytecodeDescriptor *,sqInt,sqInt,sqInt) = v3NumPushNils;
    sqInt pc;
    sqInt pushingNils;

	needsFrame = 0;
	prevBCDescriptor = null;
	methodOrBlockNumArgs = (blockStart->numArgs);
	inBlock = 1;
	pc = (blockStart->startpc);
	end = ((blockStart->startpc)) + ((blockStart->span));
	framelessStackDelta = (nExts = (extA = (extB = 0)));
	pushingNils = 1;
	while (pc < end) {
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((descriptor->isExtension)) {
			loadSubsequentBytesForDescriptorat(descriptor, pc);
			((descriptor->generator))();
		}
		if (!needsFrame) {
			if ((((descriptor->needsFrameFunction)) == null)
			 || (((descriptor->needsFrameFunction))(framelessStackDelta))) {
				needsFrame = 1;
			}
			else {
				framelessStackDelta += (descriptor->stackDelta);
			}
		}
		/* begin maybeNoteDescriptor:blockStart: */
		if ((descriptor->isInstVarRef)) {
			(blockStart->hasInstVarRef = 1);
		}
		if (pushingNils
		 && (!((descriptor->isExtension)))) {

			/* Count the initial number of pushed nils acting as temp initializers.  We can't tell
			   whether an initial pushNil is an operand reference or a temp initializer, except
			   when the pushNil is a jump target (has a fixup), which never happens:
			   self systemNavigation browseAllSelect:
			   [:m| | ebc |
			   (ebc := m embeddedBlockClosures
			   select: [:ea| ea decompile statements first isMessage]
			   thenCollect: [:ea| ea decompile statements first selector]) notEmpty
			   and: [(#(whileTrue whileFalse whileTrue: whileFalse:) intersection: ebc) notEmpty]]
			   or if the bytecode set has a push multiple nils bytecode.  We simply count initial nils.
			   Rarely we may end up over-estimating.  We will correct by checking the stack depth
			   at the end of the block in compileBlockBodies. */
			if (((numPushNils = numPushNilsFunction(descriptor, pc, nExts, methodObj))) > 0) {
				assert((((descriptor->numBytes)) == 1)
				 || (((descriptor->generator)) == genPushClosureTempsBytecode));
				(blockStart->numInitialNils = ((blockStart->numInitialNils)) + numPushNils);
			}
			else {
				pushingNils = 0;
			}
		}
		pc = (pc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)
	: 0));
		if ((descriptor->isExtension)) {
			nExts += 1;
		}
		else {
			nExts = (extA = (extB = 0));
		}
		prevBCDescriptor = descriptor;
	}
	if (!needsFrame) {
		assert((framelessStackDelta >= 0)
		 && (((blockStart->numInitialNils)) >= framelessStackDelta));
		(blockStart->numInitialNils = ((blockStart->numInitialNils)) - framelessStackDelta);
	}
}


/*	Scan the method (and all embedded blocks) to determine
	- what the last bytecode is; extra bytes at the end of a method are used
	to encode things like source pointers or temp names
	- if the method needs a frame or not
	- what are the targets of any backward branches.
	- how many blocks it creates
	Answer the block count or on error a negative error code */

	/* StackToRegisterMappingCogit>>#scanMethod */
static sqInt
scanMethod(void)
{
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt framelessStackDelta;
    sqInt latestContinuation;
    sqInt nExts;
    sqInt numBlocks;
    sqInt pc;
    sqInt targetPC;

	needsFrame = 0;
	inBlock = 0;
	prevBCDescriptor = null;
	if ((primitiveIndex > 0)
	 && (isQuickPrimitiveIndex(primitiveIndex))) {
		return 0;
	}
	pc = (latestContinuation = initialPC);
	numBlocks = (framelessStackDelta = (nExts = (extA = (extB = 0))));
	while (pc <= endPC) {
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((descriptor->isExtension)) {
			if (((descriptor->opcode)) == Nop) {

				/* unknown bytecode tag; see Cogit class>>#generatorTableFrom: */
				return EncounteredUnknownBytecode;
			}
			loadSubsequentBytesForDescriptorat(descriptor, pc);
			((descriptor->generator))();
		}
		if (((descriptor->isReturn))
		 && (pc >= latestContinuation)) {
			endPC = pc;
		}
		if (!needsFrame) {
			if ((((descriptor->needsFrameFunction)) == null)
			 || (((descriptor->needsFrameFunction))(framelessStackDelta))) {
				needsFrame = 1;
			}
			else {
				framelessStackDelta += (descriptor->stackDelta);
			}
		}
		if (isBranch(descriptor)) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			if (isBackwardBranchatextsin(descriptor, pc, nExts, methodObj)) {
				initializeFixupAt(targetPC - initialPC);
			}
			else {
				latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
			}
		}
		if ((descriptor->isBlockCreation)) {
			numBlocks += 1;
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
		}
		pc += (descriptor->numBytes);
		if ((descriptor->isExtension)) {
			nExts += 1;
		}
		else {
			nExts = (extA = (extB = 0));
		}
		prevBCDescriptor = descriptor;
	}
	return numBlocks;
}


/*	Allocate a register needed in a run-time call (i.e. flush uses of the
	register to the real stack). Since the run-time can smash any and
	all caller-saved registers also flush all caller-saved registers. */

	/* StackToRegisterMappingCogit>>#ssAllocateCallReg: */
static void NoDbgRegParms
ssAllocateCallReg(sqInt requiredReg)
{
	ssAllocateRequiredRegMaskupThrough(callerSavedRegMask | (1LL << requiredReg), simStackPtr);
}


/*	Allocate registers needed in a run-time call (i.e. flush uses of the
	registers to the real stack). Since the run-time can smash any and
	all caller-saved registers also flush all caller-saved registers. */

	/* StackToRegisterMappingCogit>>#ssAllocateCallReg:and: */
static void NoDbgRegParms
ssAllocateCallRegand(sqInt requiredReg1, sqInt requiredReg2)
{
	ssAllocateRequiredRegMaskupThrough(callerSavedRegMask | ((1LL << requiredReg1) | (1LL << requiredReg2)), simStackPtr);
}


/*	Allocate registers needed in a run-time call (i.e. flush uses of the
	registers to the real stack). Since the run-time can smash any and
	all caller-saved registers also flush all caller-saved registers. */

	/* StackToRegisterMappingCogit>>#ssAllocateCallReg:and:and: */
static void NoDbgRegParms
ssAllocateCallRegandand(sqInt requiredReg1, sqInt requiredReg2, sqInt requiredReg3)
{
	ssAllocateRequiredRegMaskupThrough(callerSavedRegMask | ((1LL << requiredReg1) | ((1LL << requiredReg2) | (1LL << requiredReg3))), simStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredRegMask:upThrough: */
static void NoDbgRegParms
ssAllocateRequiredRegMaskupThrough(sqInt requiredRegsMask, sqInt stackPtr)
{
    sqInt i;
    sqInt lastRequired;
    sqInt liveRegs;


	/* compute live regs while noting the last occurrence of required regs.
	   If these are not free we must spill from simSpillBase to last occurrence.
	   Note we are conservative here; we could allocate FPReg in frameless methods. */
	lastRequired = -1;
	liveRegs = (1LL << FPReg) | (1LL << SPReg);
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= stackPtr; i += 1) {
		liveRegs = liveRegs | (registerMask(simStackAt(i)));
		if (((registerMask(simStackAt(i))) & requiredRegsMask) != 0) {
			lastRequired = i;
		}
	}
	if (!((liveRegs & requiredRegsMask) == 0)) {

		/* Some live, must spill */
		ssFlushTo(lastRequired);
		assert(((liveRegisters()) & requiredRegsMask) == 0);
	}
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredReg: */
static void NoDbgRegParms
ssAllocateRequiredReg(sqInt requiredReg)
{
	ssAllocateRequiredRegMaskupThrough(1LL << requiredReg, simStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredReg:and: */
static void NoDbgRegParms
ssAllocateRequiredRegand(sqInt requiredReg1, sqInt requiredReg2)
{
	ssAllocateRequiredRegMaskupThrough((1LL << requiredReg1) | (1LL << requiredReg2), simStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredReg:upThrough: */
static void NoDbgRegParms
ssAllocateRequiredRegupThrough(sqInt requiredReg, sqInt stackPtr)
{
	ssAllocateRequiredRegMaskupThrough(1LL << requiredReg, stackPtr);
}

	/* StackToRegisterMappingCogit>>#ssFlushTo: */
static void NoDbgRegParms
ssFlushTo(sqInt index)
{
    sqInt i;

	for (i = methodOrBlockNumTemps; i < simSpillBase; i += 1) {
		assert(((simStackAt(i))->spilled));
	}
	if (simSpillBase <= index) {
		for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= index; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i), FPReg);
		}
		simSpillBase = index + 1;
	}
}


/*	Any occurrences on the stack of the value being stored (which is the top
	of stack)
	must be flushed, and hence any values colder than them stack. */

	/* StackToRegisterMappingCogit>>#ssFlushUpThroughReceiverVariable: */
static void NoDbgRegParms
ssFlushUpThroughReceiverVariable(sqInt slotIndex)
{
    CogSimStackEntry *desc;
    sqInt index;

	/* begin ssFlushUpThrough: */
	for (index = (simStackPtr - 1); index >= (((simSpillBase < 0) ? 0 : simSpillBase)); index += -1) {
		if (((((simStackAt(index))->type)) == SSBaseOffset)
		 && (((((simStackAt(index))->registerr)) == ReceiverResultReg)
		 && ((((simStackAt(index))->offset)) == (slotOffsetOfInstVarIndex(slotIndex))))) {
			ssFlushTo(index);
			goto l1;
		}
	}
l1:	/* end ssFlushUpThrough: */;
}


/*	Any occurrences on the stack of the value being stored (which is the top
	of stack)
	must be flushed, and hence any values colder than them stack. */

	/* StackToRegisterMappingCogit>>#ssFlushUpThroughTemporaryVariable: */
static void NoDbgRegParms
ssFlushUpThroughTemporaryVariable(sqInt tempIndex)
{
    CogSimStackEntry *desc;
    sqInt index;

	/* begin ssFlushUpThrough: */
	for (index = (simStackPtr - 1); index >= (((simSpillBase < 0) ? 0 : simSpillBase)); index += -1) {
		if (((((simStackAt(index))->type)) == SSBaseOffset)
		 && (((((simStackAt(index))->registerr)) == FPReg)
		 && ((((simStackAt(index))->offset)) == (frameOffsetOfTemporary(tempIndex))))) {
			ssFlushTo(index);
			goto l1;
		}
	}
l1:	/* end ssFlushUpThrough: */;
}

	/* StackToRegisterMappingCogit>>#ssPop: */
static void NoDbgRegParms
ssPop(sqInt n)
{
	assert(((simStackPtr - n) >= (methodOrBlockNumTemps - 1))
	 || ((!needsFrame)
	 && ((simStackPtr - n) >= -1)));
	simStackPtr -= n;
}

	/* StackToRegisterMappingCogit>>#ssPushAnnotatedConstant: */
static sqInt NoDbgRegParms
ssPushAnnotatedConstant(sqInt literal)
{
    CogSimStackEntry * cascade0;

	ssPush(1);
	updateSimSpillBase();
	cascade0 = ssTop();
	(cascade0->type = SSConstant);
	(cascade0->annotateUse = 1);
	(cascade0->spilled = 0);
	(cascade0->constant = literal);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushBase:offset: */
static sqInt NoDbgRegParms
ssPushBaseoffset(sqInt reg, sqInt offset)
{
    CogSimStackEntry * cascade0;

	ssPush(1);
	updateSimSpillBase();
	cascade0 = ssTop();
	(cascade0->type = SSBaseOffset);
	(cascade0->spilled = 0);
	(cascade0->annotateUse = 0);
	(cascade0->registerr = reg);
	(cascade0->offset = offset);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushConstant: */
static sqInt NoDbgRegParms
ssPushConstant(sqInt literal)
{
    CogSimStackEntry * cascade0;

	ssPush(1);
	updateSimSpillBase();
	cascade0 = ssTop();
	(cascade0->type = SSConstant);
	(cascade0->spilled = 0);
	(cascade0->annotateUse = 0);
	(cascade0->constant = literal);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushDesc: */
static sqInt NoDbgRegParms
ssPushDesc(CogSimStackEntry simStackEntry)
{
	if (((simStackEntry.type)) == SSSpill) {
		(simStackEntry.type = SSBaseOffset);
	}
	(simStackEntry.spilled = 0);
	(simStackEntry.annotateUse = 0);
	(simStackEntry.bcptr = bytecodePC);
	simStack[(simStackPtr += 1)] = simStackEntry;
	updateSimSpillBase();
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushRegister: */
static sqInt NoDbgRegParms
ssPushRegister(sqInt reg)
{
    CogSimStackEntry * cascade0;

	ssPush(1);
	updateSimSpillBase();
	cascade0 = ssTop();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->annotateUse = 0);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPush: */
static void NoDbgRegParms
ssPush(sqInt n)
{
	simStackPtr += n;
}


/*	In addition to ssStorePop:toReg:, if this is a store and not
	a popInto I change the simulated stack to use the register 
	for the top value */

	/* StackToRegisterMappingCogit>>#ssStoreAndReplacePop:toReg: */
static void NoDbgRegParms
ssStoreAndReplacePoptoReg(sqInt popBoolean, sqInt reg)
{
    char topSpilled;

	topSpilled = ((ssTop())->spilled);
	ssStorePoptoReg(popBoolean
	 || (topSpilled), reg);
	if (!popBoolean) {
		if (!topSpilled) {
			ssPop(1);
		}
		ssPushRegister(reg);
	}
}


/*	Store or pop the top simulated stack entry to a register.
	Use preferredReg if the entry is not itself a register.
	Answer the actual register the result ends up in. */

	/* StackToRegisterMappingCogit>>#ssStorePop:toPreferredReg: */
static sqInt NoDbgRegParms
ssStorePoptoPreferredReg(sqInt popBoolean, sqInt preferredReg)
{
    sqInt actualReg;

	actualReg = preferredReg;
	if ((((ssTop())->type)) == SSRegister) {
		assert(!(((ssTop())->annotateUse)));
		assert(!(((ssTop())->spilled)));
		actualReg = ((ssTop())->registerr);
	}
	ssStorePoptoReg(popBoolean, actualReg);
	return actualReg;
}


/*	Store or pop the top simulated stack entry to a register.
	N.B.: popToReg: and storeToReg: does not generate anything if 
	it moves a register to the same register. */

	/* StackToRegisterMappingCogit>>#ssStorePop:toReg: */
static void NoDbgRegParms
ssStorePoptoReg(sqInt popBoolean, sqInt reg)
{
	if (popBoolean) {
		popToReg(ssTop(), reg);
		ssPop(1);
	}
	else {
		storeToReg(ssTop(), reg);
	}
}

	/* StackToRegisterMappingCogit>>#ssTop */
static CogSimStackEntry *
ssTop(void)
{
	return simStackAt(simStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssTopDescriptor */
static CogSimStackEntry
ssTopDescriptor(void)
{
	return simStack[simStackPtr];
}

	/* StackToRegisterMappingCogit>>#ssValue: */
static CogSimStackEntry * NoDbgRegParms
ssValue(sqInt n)
{
	return simStackAt(simStackPtr - n);
}


/*	If the sequence of bytecodes is
	push: (Array new: 1)
	popIntoTemp: tempIndex
	pushConstant: const or pushTemp: n
	popIntoTemp: 0 inVectorAt: tempIndex
	collapse this into
	tempAt: tempIndex put: {const or temp}
	and answer true, otherwise answer false.
	One might think that we should look for a sequence of more than
	one pushes and pops but this is extremely rare.
	Exclude pushRcvr: n to avoid potential complications with context inst
	vars.  */

	/* StackToRegisterMappingCogit>>#tryCollapseTempVectorInitializationOfSize: */
static sqInt NoDbgRegParms
tryCollapseTempVectorInitializationOfSize(sqInt slots)
{
    BytecodeDescriptor *pushArrayDesc;
    BytecodeDescriptor *pushValueDesc;
    sqInt reg;
    sqInt remoteTempIndex;
    BytecodeDescriptor *storeArrayDesc;
    BytecodeDescriptor *storeValueDesc;
    sqInt tempIndex;

	if (slots != 1) {
		return 0;
	}
	pushArrayDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(bytecodePC, methodObj)));
	assert(((pushArrayDesc->generator)) == genPushNewArrayBytecode);
	storeArrayDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(bytecodePC + ((pushArrayDesc->numBytes)), methodObj)));
	if (((storeArrayDesc->generator)) == genStoreAndPopTemporaryVariableBytecode) {
		tempIndex = (fetchByteofObject(bytecodePC + ((pushArrayDesc->numBytes)), methodObj)) & 7;
	}
	else {
		if (!(((storeArrayDesc->generator)) == genLongStoreAndPopTemporaryVariableBytecode)) {
			return 0;
		}
		tempIndex = fetchByteofObject((bytecodePC + ((pushArrayDesc->numBytes))) + 1, methodObj);
	}
	pushValueDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes)), methodObj)));
	if (!((((pushValueDesc->generator)) == genPushLiteralConstantBytecode)
		 || ((((pushValueDesc->generator)) == genPushQuickIntegerConstantBytecode)
		 || (((pushValueDesc->generator)) == genPushTemporaryVariableBytecode)))) {
		return 0;
	}
	storeValueDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes)), methodObj)));
	remoteTempIndex = fetchByteofObject((((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes))) + 2, methodObj);
	if (!((((storeValueDesc->generator)) == genStoreAndPopRemoteTempLongBytecode)
		 && (tempIndex == remoteTempIndex))) {
		return 0;
	}
	genNewArrayOfSizeinitialized(1, 0);
	evaluateat(pushValueDesc, (bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes)));
	reg = ssStorePoptoPreferredReg(1, TempReg);
	genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, 0, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
	evaluateat(storeArrayDesc, bytecodePC + ((pushArrayDesc->numBytes)));

	/* + pushArrayDesc numBytes this gets added by nextBytecodePCFor:at:exts:in: */
	bytecodePC = ((bytecodePC + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes))) + ((storeValueDesc->numBytes));
	return 1;
}

	/* StackToRegisterMappingCogit>>#updateSimSpillBase */
static void
updateSimSpillBase(void)
{
	if (simSpillBase > simStackPtr) {
		simSpillBase = ((simStackPtr < 0) ? 0 : simStackPtr);
	}
}

	/* StackToRegisterMappingCogit>>#v3PushNilSize:numInitialNils: */
static sqInt NoDbgRegParms
v3PushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils)
{
	return numInitialNils;
}

	/* StackToRegisterMappingCogit>>#v3:Num:Push:Nils: */
static sqInt NoDbgRegParms
v3NumPushNils(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	return (((descriptor->generator)) == genPushConstantNilBytecode
		? 1
		: 0);
}
