/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.1680 uuid: 6fe34e1e-a5e0-4966-a2cd-3f21ccb0bde9
   from
	StackInterpreter VMMaker.oscog-eem.1680 uuid: 6fe34e1e-a5e0-4966-a2cd-3f21ccb0bde9
 */
static char __buildInfo[] = "StackInterpreter VMMaker.oscog-eem.1680 uuid: 6fe34e1e-a5e0-4966-a2cd-3f21ccb0bde9 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "sq.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline off
sqInt warnpid, erroronwarn;
void
warning(char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
void
warningat(char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline on

void
invalidCompactClassError(char *s) { /* Print a (compact) class index error message and exit. */
#if SPURVM
	printf("\nClass %s does not have the required class index\n", s);
#else
	printf("\nClass %s does not have the required compact class index\n", s);
#endif
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 */
#if WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

/* end StackInterpreter class>>preambleCCode */

typedef struct {
	usqInt	segStart;
	usqInt	segSize;
	sqInt	swizzle;
	usqInt	containsPinned;
	usqInt	savedSegSize;
	usqInt	lastFreeObject;
 } SpurSegmentInfo;


typedef struct {
	usqInt	start;
	usqInt	limit;
 } SpurNewSpaceSpace;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	first;
	usqInt	last;
 } SpurCircularBuffer;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	top;
 } SpurContiguousObjStack;


typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	int	padToWord;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Constants ***/
#define AccessModifierPrivate 1
#define AccessModifierProtected 2
#define AccessModifierPublic 0
#define ActiveProcessIndex 1
#define AlternateHeaderHasPrimFlag 0x80000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 234
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BecameActiveClassFlag 8
#define BecameCompiledMethodFlag 2
#define BecamePointerObjectFlag 1
#define Byte0Mask 0xFF
#define Byte1Mask 0xFF00
#define Byte1Shift 8
#define Byte1ShiftNegated -8
#define Byte2Mask 0xFF0000
#define Byte3Mask 0xFF000000ULL
#define Byte3Shift 24
#define Byte3ShiftNegated -24
#define Byte4Mask 0xFF00000000ULL
#define Byte5Mask 0xFF0000000000ULL
#define Byte5Shift 40
#define Byte5ShiftNegated -40
#define Byte6Mask 0xFF000000000000ULL
#define Byte7Mask 0xFF00000000000000ULL
#define Byte7Shift 56
#define Byte7ShiftNegated -56
#define CacheProbeMax 3
#define CharacterTable null
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 37
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 52
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 34
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMessage 15
#define ClassMessageCompactIndex 35
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 36
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CompactionPassesForGC 2
#define CompactionPassesForSnapshot 3
#define ConstMinusOne 0xFFFFFFFFFFFFFFF9ULL
#define ConstOne 9
#define ConstTwo 17
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DumpStackOnLowSpace 0
#define EnclosingMixinIndex 3
#define EnclosingObjectIndex 4
#define EndOfRun 0x101
#if !defined(EnforceAccessControl) /* Allow this to be overridden on the compiler command line */
# define EnforceAccessControl 1
#endif
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootsSize 2048
#define FailImbalancedPrimitives 0
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerContext 8
#define FoxCallerSavedIP 8
#define FoxFrameFlags -16
#define FoxMethod -8
#define FoxReceiver -32
#define FoxSavedFP 0
#define FoxThisContext -24
#define FrameSlots 6
#define GCModeBecome 8
#define GCModeFreeSpace 32
#define GCModeFull 1
#define GCModeImageSegment 16
#define GCModeIncremental 4
#define GCModeNewSpace 2
#define HeaderIndex 0
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 0
#endif
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x100000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define LongStoreBytecode 129
#define LookupRuleDynamicSuper 0x101
#define LookupRuleImplicit 0x100
#define LookupRuleMNU 259
#define LookupRuleOrdinary 258
#define MarkObjectsForEnumerationPrimitives 0
#define MarkOnTenure 5
#define MarkStackRootIndex 0x1000
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MaxRTRefCount 7
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x200
#define MethodCacheEntrySize 4
#define MethodCacheMask 0x7FC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 2048
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 27
#define MethodHeaderFlagBitPosition 31
#define MethodHeaderTempCountShift 21
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MixinIndex 3
#define MournQueueRootIndex 4098
#define MULTIPLEBYTECODESETS 1
#define MyListIndex 3
#define NewspeakVM 1
#define NextLinkIndex 0
#define NilObject 0
#define NSMethodCacheActualReceiver 7
#define NSMethodCacheCallingMethod 3
#define NSMethodCacheClassTag 2
#define NSMethodCacheDepthOrLookupRule 4
#define NSMethodCacheMask 0xFF8
#define NSMethodCachePrimFunction 6
#define NSMethodCacheSelector 1
#define NSMethodCacheSize 4096
#define NSMethodCacheTargetMethod 5
#define ObjStackFixedSlots 4
#define ObjStackFreex 2
#define ObjStackLimit 0xFF8
#define ObjStackMyx 1
#define ObjStackNextx 3
#define ObjStackPageSlots 0xFFC
#define ObjStackTopx 0
#define OldBecameNewFlag 4
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrLimitExceeded 15
#define PrimErrNamedInternal 13
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNoModification 8
#define PrimErrNotFound 11
#define PrimErrObjectIsPinned 16
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimErrWritePastObject 17
#define PrimitiveExternalCallIndex 117
#define PrimNoErr 0
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RememberedSetRootIndex 4099
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorAttemptToAssign 50
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define SistaVM 0
#define SmallContextSlots 22
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TenureByAge 1
#define TenureByClass 2
#define TenureToShrinkRT 3
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TopHashBit 0x200000
#define TopOopBit 0x8000000000000000ULL
#define TrueObject 2
#define V3PrimitiveBitsMask 0x80000FF8ULL
#define ValueIndex 1
#if !defined(VMBIGENDIAN) /* Allow this to be overridden on the compiler command line */
# define VMBIGENDIAN 0
#endif
#define WeaklingStackRootIndex 0x1001
#define XIndex 0
#define YIndex 1


/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

extern sqInt interpret(void);
static sqInt NoDbgRegParms addressIsInPage(StackPage * self_in_addressIsInPage, char *address);
static sqInt NoDbgRegParms isFree(StackPage * self_in_isFree);
static void NoDbgRegParms freeStackPageNoAssert(StackPage *aPage);
static sqInt NoDbgRegParms freeStackPage(StackPage *aPage);
static void NoDbgRegParms markStackPageMostRecentlyUsed(StackPage *page);
static void NoDbgRegParms markStackPageNextMostRecentlyUsed(StackPage *page);
static StackPage * newStackPage(void);
static sqInt pageListIsWellFormed(void);
static StackPage * NoDbgRegParms stackPageAt(sqInt index);
static StackPage * NoDbgRegParms stackPageFor(void *pointer);
static double statAverageLivePagesWhenMapping(void);
#if IMMUTABILITY
static sqInt NoDbgRegParms canBeImmutable(sqInt oop);
#endif /* IMMUTABILITY */
extern char * cStringOrNullFor(sqInt oop);
extern sqInt failed(void);
static sqInt NoDbgRegParms isNegativeIntegerValueOf(sqInt oop);
static sqInt NoDbgRegParms magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static usqLong NoDbgRegParms magnitude64BitValueOf(sqInt oop);
extern usqInt positive32BitValueOf(sqInt oop);
extern usqLong positive64BitValueOf(sqInt oop);
extern unsigned long positiveMachineIntegerValueOf(sqInt oop);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
EXPORT(void) primitiveAllInstances(void);
EXPORT(void) primitiveAllObjects(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClosureValue(void);
extern void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
EXPORT(void) primitiveCompareBytes(void);
static void primitiveConstantFill(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
EXPORT(sqInt) primitiveCrashVM(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveEnterCriticalSection(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
static void primitiveExitCriticalSection(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailureCode(void);
static void primitiveFetchNextMourner(void);
static void primitiveFloatAdd(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveGetAttribute(void);
static void primitiveGetImmutability(void);
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveGrowMemoryByAtLeast(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
EXPORT(sqInt) primitiveImageFormatVersion(void);
static void primitiveImageName(void);
static void primitiveImmediateAsInteger(void);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsBigEnder(void);
static void primitiveIsPinned(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
static void primitiveKbdNext(void);
static void primitiveKbdPeek(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMaxIdentityHash(void);
extern usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
static void primitiveMouseButtons(void);
static void primitiveMousePoint(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
EXPORT(sqInt) primitiveOriginalMillisecondClock(void);
EXPORT(sqInt) primitivePathToUsing(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
static void primitiveResume(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
static void primitiveSetImmutability(void);
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
static void primitiveSetOrHasIdentityHash(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignal(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSizeInBytes(void);
static void primitiveSizeInBytesOfInstance(void);
static void primitiveSmallFloatAdd(void);
static void primitiveSmallFloatArctan(void);
static void primitiveSmallFloatDivide(void);
static void primitiveSmallFloatEqual(void);
static void primitiveSmallFloatExp(void);
static void primitiveSmallFloatExponent(void);
static void primitiveSmallFloatFractionalPart(void);
static void primitiveSmallFloatGreaterOrEqual(void);
static void primitiveSmallFloatGreaterThan(void);
static void primitiveSmallFloatLessOrEqual(void);
static void primitiveSmallFloatLessThan(void);
static void primitiveSmallFloatLogN(void);
static void primitiveSmallFloatMultiply(void);
static void primitiveSmallFloatNotEqual(void);
static void primitiveSmallFloatSine(void);
static void primitiveSmallFloatSquareRoot(void);
static void primitiveSmallFloatSubtract(void);
static void primitiveSmallFloatTimesTwoPower(void);
static void primitiveSmallFloatTruncated(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveSuspend(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUnloadModule(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
static void primitiveWait(void);
static void primitiveYield(void);
extern sqInt signalNoResume(sqInt aSemaphore);
extern int signed32BitValueOf(sqInt oop);
extern sqLong signed64BitValueOf(sqInt oop);
extern long signedMachineIntegerValueOf(sqInt oop);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
extern sqInt success(sqInt successBoolean);
static sqInt NoDbgRegParms initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
static sqInt NoDbgRegParms pageIndexFor(void *pointer);
static sqInt NoDbgRegParms addressAfter(sqInt objOop);
static sqInt NoDbgRegParms allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
static sqInt NoDbgRegParms allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
extern sqInt byteSwapped(sqInt w);
static usqInt NoDbgRegParms bytesInObject(sqInt objOop);
static sqInt NoDbgRegParms changeClassOfto(sqInt rcvr, sqInt argClass);
static double NoDbgRegParms dbgFloatValueOf(sqInt oop);
static sqInt NoDbgRegParms exponentOfSmallFloat(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
static sqInt NoDbgRegParms initFreeChunkWithBytesat(usqLong numBytes, sqInt address);
static void NoDbgRegParms initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address);
extern sqInt instantiateClassindexableSize(sqInt classObj, usqInt nElements);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt oop);
static sqInt NoDbgRegParms isImmediateFloat(sqInt oop);
extern sqInt isIntegerObject(sqInt oop);
extern sqInt isIntegerValue(sqInt intValue);
extern sqInt isMarked(sqInt objOop);
static sqInt NoDbgRegParms isSmallFloatValue(double aFloat);
static sqInt NoDbgRegParms isSmallFloatZero(sqInt aSmallFloat);
static sqInt NoDbgRegParms lengthOfformat(sqInt objOop, sqInt fmt);
static sqInt maxSlotsForAlloc(void);
static sqInt numFreeLists(void);
static sqInt NoDbgRegParms objectAfterlimit(sqInt objOop, sqInt limit);
static double NoDbgRegParms smallFloatValueOf(sqInt oop);
extern usqInt smallObjectBytesForSlots(sqInt numSlots);
static sqInt wordIndexableFormat(void);
static void NoDbgRegParms NeverInline addToEphemeronList(sqInt ephemeronCorpse);
static void NoDbgRegParms NeverInline addToWeakList(sqInt weakCorpse);
static sqInt allNewSpaceObjectsHaveZeroRTRefCount(void);
static sqInt allWeakSurvivorsOnWeakList(void);
static void NeverInline computeRefCountToShrinkRT(void);
static sqInt NoDbgRegParms copyAndForward(sqInt survivor);
static sqInt NoDbgRegParms NeverInline copyToOldSpacebytesformat(sqInt survivor, sqInt bytesInObject, sqInt formatOfSurvivor);
static sqInt NoDbgRegParms firstCorpse(sqInt headOfCorpseList);
static void growRememberedSet(void);
static sqInt NoDbgRegParms isInRememberedSet(sqInt objOop);
static sqInt NoDbgRegParms isMaybeOldScavengeSurvivor(sqInt oop);
static sqInt NoDbgRegParms isScavengeSurvivor(sqInt oop);
static sqInt NoDbgRegParms isonWeaklingList(sqInt oop, sqInt listHead);
static usqInt newSpaceCapacity(void);
static sqInt noUnfiredEphemeronsAtEndOfRememberedSet(void);
static void processEphemerons(void);
static void processWeaklings(void);
static sqInt NoDbgRegParms processWeakSurvivor(sqInt weakObj);
extern sqInt remember(sqInt objOop);
static void NoDbgRegParms scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress);
static void scavengeLoop(void);
static sqInt NoDbgRegParms scavengeReferentsOf(sqInt referrer);
static void NoDbgRegParms scavengeRememberedSetStartingAt(sqInt n);
static float scavengerTenuringThreshold(void);
static sqInt scavengeUnfiredEphemeronsOnEphemeronList(void);
static sqInt NoDbgRegParms accessibleObjectAfter(sqInt objOop);
static sqInt NoDbgRegParms NeverInline activeAndDeferredScan(sqInt anEphemeron);
static void NoDbgRegParms addFreeSubTree(sqInt freeTree);
extern sqInt addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeObj(sqInt address);
extern sqInt addressCouldBeOop(sqInt address);
static sqInt NoDbgRegParms addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes);
static sqInt NoDbgRegParms addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes);
static sqInt NoDbgRegParms allInstancesOf(sqInt aClass);
static sqInt allObjects(void);
static sqInt allObjectsUnmarked(void);
static sqInt allOldMarkedWeakObjectsOnWeaklingStack(void);
static sqInt allocateLargestFreeChunk(void);
static sqInt NoDbgRegParms allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static sqInt NoDbgRegParms allocateOldSpaceChunkOfBytes(usqInt chunkBytes);
extern sqInt allocatePinnedSlots(sqInt nSlots);
static sqInt allocationUnit(void);
static sqInt NoDbgRegParms allStrongSlotsOfWeaklingAreMarked(sqInt aWeakling);
static sqInt allUnscannedEphemeronsAreActive(void);
static sqInt arrayClassIndexPun(void);
extern sqInt arrayFormat(void);
static sqInt NoDbgRegParms becomeEffectFlagsFor(sqInt objOop);
extern sqInt becomewith(sqInt array1, sqInt array2);
static sqInt NoDbgRegParms becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
extern void beRootIfOld(sqInt oop);
static sqInt bitsSetInFreeSpaceMaskForAllFreeLists(void);
static sqInt bridgeSize(void);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern sqInt characterObjectOf(sqInt characterCode);
extern void characterTable(void);
extern sqInt characterValueOf(sqInt oop);
extern sqInt checkedLongAt(sqInt byteAddress);
static sqInt checkHeapFreeSpaceIntegrity(void);
static sqInt NoDbgRegParms checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedNewSpaceObjs, sqInt classIndicesShouldBeValid);
extern sqInt checkOkayOop(usqInt oop);
extern sqInt checkOopHasOkayClass(usqInt obj);
static sqInt NoDbgRegParms checkOopIntegritynamed(sqInt obj, char *name);
static sqInt NoDbgRegParms checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
extern sqInt checkTraversableSortedFreeList(void);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classAtIndex(sqInt classIndex);
static sqInt NoDbgRegParms classAtIndexput(sqInt classIndex, sqInt objOop);
extern sqInt classBitmap(void);
extern sqInt classByteArray(void);
extern sqInt classCharacter(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classFloat(void);
static sqInt classIndexFieldWidth(void);
extern sqInt classIndexOf(sqInt objOop);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classOrNilAtIndex(sqInt classIndex);
extern sqInt classPoint(void);
extern sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
extern sqInt classString(void);
extern sqInt classTableMinorIndexMask(void);
extern sqInt classTablePageSize(void);
extern sqInt classTableRootObj(void);
static sqInt classTableRootSlots(void);
extern sqInt classTagForClass(sqInt classObj);
extern sqInt classUnsafeAlien(void);
static void clearLeakMapAndMapAccessibleFreeSpace(void);
static void clearLeakMapAndMapAccessibleObjects(void);
static sqInt NoDbgRegParms cloneInOldSpaceForPinning(sqInt objOop);
extern sqInt clone(sqInt objOop);
static void NeverInline compact(void);
extern sqInt compactClassIndexOf(sqInt objOop);
static sqInt NoDbgRegParms copyObjtoAddrstartAtstopAt(sqInt objOop, sqInt segAddr, sqInt segStart, sqInt endSeg);
extern void countMarkedAndUnmarkdObjects(sqInt printFlags);
static sqInt defaultEdenBytes(void);
static void NoDbgRegParms detachFreeObject(sqInt freeChunk);
extern sqInt displayObject(void);
static void NoDbgRegParms doScavenge(sqInt tenuringCriterion);
extern sqInt eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots);
static void eliminateAndFreeForwardersForPigCompact(void);
static void NoDbgRegParms emptyObjStack(sqInt objStack);
static sqInt NoDbgRegParms ensureBehaviorHash(sqInt aBehavior);
static sqInt NoDbgRegParms ensureRoomOnObjStackAt(sqInt objStackRootIndex);
static sqInt NoDbgRegParms enterIntoClassTable(sqInt aBehavior);
static sqInt ephemeronFormat(void);
static sqInt NoDbgRegParms existInstancesInNewSpaceOf(sqInt classObj);
static void NoDbgRegParms expungeFromClassTable(sqInt aBehavior);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt objOop);
static sqInt NoDbgRegParms NeverInline fetchClassOfNonImm(sqInt objOop);
extern sqInt fetchClassOf(sqInt oop);
static sqInt NoDbgRegParms fetchClassTagOfNonImm(sqInt obj);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static sqInt NoDbgRegParms fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt objOop);
static sqInt findLargestFreeChunk(void);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
static sqInt firstAccessibleObject(void);
static void * NoDbgRegParms firstFixedFieldOfMaybeImmediate(sqInt oop);
extern void * firstFixedField(sqInt objOop);
extern void * firstIndexableField(sqInt objOop);
extern sqInt fixedFieldsOfClassFormatMask(void);
static sqInt NoDbgRegParms fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength);
static sqInt NoDbgRegParms NeverInline fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue);
static sqInt NoDbgRegParms followFieldofObject(sqInt fieldIndex, sqInt anObject);
static sqInt NoDbgRegParms followForwardedInObjStackatIndex(sqInt objStack, sqInt objStackRootIndex);
extern sqInt followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth);
extern sqInt followForwarded(sqInt objOop);
static sqInt NoDbgRegParms followObjFieldofObject(sqInt fieldIndex, sqInt anObject);
extern sqInt formatOfClass(sqInt classPointer);
static sqInt NoDbgRegParms formatOf(sqInt objOop);
static sqInt forwardedFormat(void);
static sqInt freeChunkNextIndex(void);
static sqInt freeChunkParentIndex(void);
static sqInt NoDbgRegParms freeChunkWithBytesat(sqInt bytes, sqInt address);
static sqInt freeListHeadsEmpty(void);
static sqInt freeListsObj(void);
extern sqInt freeObject(sqInt objOop);
static void NeverInline freeUnmarkedObjectsAndSortAndCoalesceFreeSpaceForPigCompact(void);
extern usqLong NeverInline fullGC(void);
static float getHeapGrowthToSizeGCRatio(void);
static sqInt NoDbgRegParms goodContextSize(sqInt oop);
static sqInt NoDbgRegParms growOldSpaceByAtLeast(sqInt minAmmount);
extern usqLong headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static usqLong NoDbgRegParms headerForSlotshashformatclassIndex(sqInt numSlots, sqInt hash, sqInt formatField, sqInt classIndex);
static sqInt hiddenRootSlots(void);
static sqInt imageSegmentVersion(void);
#if IMMUTABILITY
extern sqInt immutableBitMask(void);
#endif /* IMMUTABILITY */
extern void incrementalGC(void);
static void NoDbgRegParms inFreeTreeReplacewith(sqInt treeNode, sqInt newNode);
static sqInt NoDbgRegParms initialInstanceOf(sqInt classObj);
static void NoDbgRegParms initializeObjectMemory(sqInt bytesToShift);
extern void inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList);
static void NoDbgRegParms NeverInline inPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag);
extern sqInt instanceSizeOf(sqInt classObj);
static sqInt NoDbgRegParms instSpecOfClassFormat(sqInt classFormat);
static sqInt NoDbgRegParms instSpecOfClass(sqInt classPointer);
static sqInt NoDbgRegParms isAnyPointerFormat(sqInt format);
extern sqInt isArrayNonImm(sqInt oop);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isCharacterObject(sqInt oop);
extern sqInt isCharacterValue(sqInt anInteger);
static sqInt NoDbgRegParms isClassAtUniqueIndex(sqInt aClass);
static sqInt NoDbgRegParms isCompiledMethodFormat(sqInt format);
extern sqInt isCompiledMethod(sqInt objOop);
static sqInt NoDbgRegParms isContextHeader(sqInt aHeader);
static sqInt NoDbgRegParms isContextNonImm(sqInt oop);
static sqInt NoDbgRegParms isContext(sqInt oop);
static sqInt NoDbgRegParms isEmptyObjStack(sqInt objStack);
static sqInt NoDbgRegParms isEnumerableObjectNoAssert(sqInt objOop);
static sqInt NoDbgRegParms isEnumerableObject(sqInt objOop);
static sqInt NoDbgRegParms isEphemeron(sqInt objOop);
static sqInt NoDbgRegParms isFixedSizePointerFormat(sqInt format);
static sqInt NoDbgRegParms isForwardedClassTag(sqInt classIndex);
extern sqInt isForwarded(sqInt objOop);
static sqInt NoDbgRegParms isFreeObject(sqInt objOop);
extern sqInt isImmediate(sqInt oop);
static sqInt NoDbgRegParms isInClassTable(sqInt objOop);
extern sqInt isIndexable(sqInt objOop);
static sqInt NoDbgRegParms isInEden(sqInt objOop);
static sqInt NoDbgRegParms isInFutureSpace(sqInt address);
extern sqInt isInMemory(sqInt address);
static sqInt NoDbgRegParms isInNewSpace(sqInt objOop);
extern sqInt isInOldSpace(sqInt address);
static sqInt NoDbgRegParms isInPastSpace(sqInt address);
extern sqInt isNonImmediate(sqInt oop);
static sqInt NoDbgRegParms isObjImmutable(sqInt anOop);
extern sqInt isOldObject(sqInt objOop);
extern sqInt isOopCompiledMethod(sqInt oop);
extern sqInt isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt oop);
extern sqInt isOopMutable(sqInt oop);
static sqInt NoDbgRegParms isOopValidBecome(sqInt oop);
extern sqInt isPinned(sqInt objOop);
extern sqInt isPointers(sqInt oop);
static sqInt NoDbgRegParms isPureBitsFormat(sqInt format);
extern sqInt isReallyYoungObject(sqInt obj);
extern sqInt isReallyYoung(sqInt oop);
static sqInt NoDbgRegParms isRemembered(sqInt objOop);
static sqInt NoDbgRegParms isSegmentBridge(sqInt objOop);
extern sqInt isUnambiguouslyForwarder(sqInt objOop);
extern sqInt isValidClassTag(sqInt classIndex);
static sqInt NoDbgRegParms isValidFreeObject(sqInt objOop);
static sqInt NoDbgRegParms isValidObjStackAt(sqInt objStackRootIndex);
static sqInt NoDbgRegParms isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx);
static sqInt NoDbgRegParms isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage);
static sqInt NoDbgRegParms isValidObjStack(sqInt objStack);
static sqInt NoDbgRegParms isWeakFormat(sqInt format);
static sqInt NoDbgRegParms isWeakNonImm(sqInt objOop);
extern sqInt isWeak(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt isYoungObject(sqInt objOop);
extern sqInt isYoung(sqInt oop);
static sqInt NoDbgRegParms isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static sqInt NoDbgRegParms isonObjStack(sqInt oop, sqInt objStack);
static sqInt NoDbgRegParms keyOfEphemeron(sqInt objOop);
static sqInt NoDbgRegParms knownClassAtIndex(sqInt classIndex);
static sqInt lastClassIndexPun(void);
extern sqInt lastPointerOfWhileSwizzling(sqInt objOop);
extern sqInt lastPointerOf(sqInt objOop);
extern sqInt leakCheckBecome(void);
extern sqInt leakCheckFullGC(void);
extern sqInt leakCheckIncremental(void);
extern sqInt leakCheckNewSpaceGC(void);
static sqInt NoDbgRegParms lengthOfMaybeImmediate(sqInt oop);
extern sqInt lengthOf(sqInt objOop);
extern sqInt literalCountOfMethodHeader(sqInt header);
extern sqInt literalCountOf(sqInt methodPointer);
static sqInt NoDbgRegParms loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
extern void longPrintInstancesOf(sqInt aClassOop);
extern void longPrintInstancesWithClassIndex(sqInt classIndex);
extern void longPrintReferencesTo(sqInt anOop);
static sqInt NoDbgRegParms mapOopsFromtooutPointersoutHashes(sqInt segStart, sqInt segAddr, sqInt outPointerArray, sqInt savedOutHashes);
static void NoDbgRegParms markAndTraceClassOf(sqInt objOop);
static void NoDbgRegParms markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents);
extern void markAndTrace(sqInt objOop);
static sqInt markInactiveEphemerons(void);
static void NoDbgRegParms NeverInline markObjects(sqInt objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged);
static void markWeaklingsAndMarkAndFireEphemerons(void);
extern sqInt maybeSplObj(sqInt index);
static sqInt NoDbgRegParms methodHeaderOf(sqInt methodObj);
static sqInt NoDbgRegParms moveARunOfObjectsStartingAtupTo(usqInt startAddress, usqInt limit);
static sqInt newObjectHash(void);
static sqInt newSpaceIsEmpty(void);
extern usqInt nextInSortedFreeListLinkgiven(sqInt freeChunk, sqInt prevFree);
extern sqInt nilObject(void);
static void NeverInline nilUnmarkedWeaklingSlots(void);
static sqInt NoDbgRegParms noCheckClassAtIndex(sqInt classIndex);
static sqInt NoDbgRegParms noCheckPushonObjStack(sqInt objOop, sqInt objStack);
static sqInt NoDbgRegParms noFixupFollowFieldofObject(sqInt fieldIndex, sqInt anObject);
static sqInt NoDbgRegParms noInlineFollowForwarded(sqInt objOop);
extern sqInt nonIndexablePointerFormat(void);
static sqInt noUnscannedEphemerons(void);
static sqInt NoDbgRegParms numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
static sqInt numberOfForwarders(void);
extern sqInt numPointerSlotsOf(sqInt objOop);
static usqInt NoDbgRegParms numSlotsOfAny(sqInt objOop);
extern usqInt numSlotsOf(sqInt objOop);
static sqInt NoDbgRegParms numStrongSlotsOfInephemeral(sqInt objOop);
extern sqInt numStrongSlotsOfWeakling(sqInt objOop);
extern sqInt objectAfter(sqInt objOop);
extern sqInt objectBefore(sqInt objOop);
static sqInt NoDbgRegParms objectStartingAt(sqInt address);
extern sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt NoDbgRegParms okayOop(sqInt signedOop);
static void NoDbgRegParms NeverInline outOfPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag);
extern sqInt pinObject(sqInt objOop);
static sqInt NoDbgRegParms popObjStack(sqInt objStack);
extern sqInt popRemappableOop(void);
static void NoDbgRegParms postBecomeScanClassTable(sqInt effectsFlags);
extern sqInt primitiveErrorTable(void);
extern void printForwarders(void);
extern void printFreeChunks(void);
extern void printFreeChunk(sqInt freeChunk);
static void NoDbgRegParms printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode);
extern void printFreeListHeads(void);
extern void printFreeList(sqInt chunkOrIndex);
extern void printFreeTree(void);
static void NoDbgRegParms printFreeTreeChunk(sqInt chunkOrZero);
extern void printHeaderOf(sqInt objOop);
static void NoDbgRegParms printHeaderTypeOf(sqInt objOop);
extern void printInstancesOf(sqInt aClassOop);
extern void printInstancesWithClassIndex(sqInt classIndex);
extern void printInvalidClassTableEntries(void);
extern void printMethodReferencesTo(sqInt anOop);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printObjectsWithHash(sqInt hash);
static void NoDbgRegParms printObjStackPagemyIndexpageType(sqInt objStackPage, sqInt myx, sqInt pageType);
static void NoDbgRegParms printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType);
extern void printObjStack(sqInt objStack);
extern void printOopsFromto(sqInt startAddress, sqInt endAddress);
extern void printReferencesTo(sqInt anOop);
extern void printSortedFreeList(void);
static sqInt NoDbgRegParms pushOnUnscannedEphemeronsStack(sqInt anEphemeron);
extern void pushRemappableOop(sqInt oop);
static sqInt NoDbgRegParms pushonObjStack(sqInt objOop, sqInt objStack);
static void NoDbgRegParms queueMourner(sqInt anEphemeronOrWeakArray);
static sqInt NoDbgRegParms rawHashBitsOf(sqInt objOop);
static void rebuildFreeListsForPigCompact(void);
extern sqInt remapObj(sqInt objOop);
extern sqInt removeGCRoot(sqInt *varLoc);
static void NoDbgRegParms restoreObjectsInsavedHashes(sqInt objArray, sqInt savedHashes);
static void NoDbgRegParms runLeakCheckerForFreeSpace(sqInt gcModes);
static void NoDbgRegParms runLeakCheckerFor(sqInt gcModes);
static void NoDbgRegParms runLeakCheckerForexcludeUnmarkedNewSpaceObjsclassIndicesShouldBeValid(sqInt gcModes, sqInt excludeUnmarkedNewSpaceObjs, sqInt classIndicesShouldBeValid);
static void NoDbgRegParms scavengingGCTenuringIf(sqInt tenuringCriterion);
static sqInt NoDbgRegParms shortentoIndexableSize(sqInt objOop, sqInt indexableSize);
extern void shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress);
extern sqInt shouldRemapObj(sqInt objOop);
extern sqInt shouldRemapOop(sqInt oop);
static usqInt NoDbgRegParms sizeOfFree(sqInt objOop);
static sqInt NoDbgRegParms sizeOfObjStack(sqInt objStack);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
static sqInt NoDbgRegParms startOfObject(sqInt objOop);
extern usqInt storeCheckBoundary(void);
static sqInt NoDbgRegParms storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
static sqInt NoDbgRegParms sufficientSpaceAfterGC(sqInt numBytes);
static sqInt NoDbgRegParms swizzleObjStackAt(sqInt objStackRootIndex);
extern void tenuringIncrementalGC(void);
static sqInt NoDbgRegParms topOfObjStack(sqInt objStack);
extern sqInt topRemappableOop(void);
static usqInt totalFreeListBytes(void);
extern sqInt trueObject(void);
static void NoDbgRegParms unlinkSolitaryFreeTreeNode(sqInt freeTreeNode);
extern sqInt unpinObject(sqInt objOop);
static sqInt validClassTableHashes(void);
static sqInt validClassTableRootPages(void);
extern sqInt validFreeTree(void);
static const char * NoDbgRegParms validFreeTreeChunkparent(sqInt chunk, sqInt parent);
static sqInt validObjStacks(void);
extern sqInt vmEndianness(void);
static usqInt NoDbgRegParms segLimit(SpurSegmentInfo * self_in_segLimit);
static SpurSegmentInfo * NoDbgRegParms addSegmentOfSize(sqInt ammount);
static void NoDbgRegParms adjustSegmentSwizzlesBy(sqInt firstSegmentShift);
static sqInt allBridgesMarked(void);
static void allocateOrExtendSegmentInfos(void);
static sqInt NoDbgRegParms bridgeAt(sqInt segIndex);
static sqInt NoDbgRegParms bridgeFor(SpurSegmentInfo *aSegment);
static void NoDbgRegParms bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil);
static void checkSegments(void);
static void collapseSegmentsPostSwizzle(void);
static void * NoDbgRegParms firstGapOfSizeAtLeast(sqInt size);
static sqInt NoDbgRegParms isEmptySegment(SpurSegmentInfo *seg);
static sqInt NoDbgRegParms isInSegments(usqInt address);
static sqInt NoDbgRegParms isValidSegmentBridge(sqInt objOop);
static sqInt lastBridge(void);
static SpurSegmentInfo * NoDbgRegParms nextNonEmptySegmentAfter(sqInt i);
static void postSnapshot(void);
static void NeverInline prepareForSnapshot(void);
static sqInt NoDbgRegParms readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes);
EXPORT(SpurSegmentInfo *) segmentContainingObj(sqInt objOop);
static void NoDbgRegParms shrinkObjectMemory(usqInt delta);
static sqInt someSegmentContainsPinned(void);
static sqInt NoDbgRegParms swizzleObj(sqInt objOop);
static usqInt totalBytesInSegments(void);
static sqInt NoDbgRegParms writeImageSegmentsToFile(sqImageFile aBinaryStream);
static sqInt NoDbgRegParms writeSegmentnextSegmenttoFile(SpurSegmentInfo *segment, SpurSegmentInfo *nextSegment, sqImageFile aBinaryStream);
static sqInt NoDbgRegParms accessModifierOfMethod(sqInt methodObj);
extern sqInt activeProcess(void);
static void NoDbgRegParms addLastLinktoList(sqInt proc, sqInt aList);
static void NoDbgRegParms addNewMethodToCache(sqInt classObj);
static void NoDbgRegParms addNewMethodToNSCache(sqInt rule);
static sqInt NoDbgRegParms addressCouldBeClassObj(sqInt maybeClassObj);
static char * allOnesAsCharStar(void);
extern sqInt argumentCountOfClosure(sqInt closurePointer);
extern sqInt argumentCountOfMethodHeader(sqInt header);
extern sqInt argumentCountOf(sqInt methodPointer);
extern void * arrayValueOf(sqInt arrayOop);
static sqInt NoDbgRegParms asciiOfCharacter(sqInt characterObj);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static void NoDbgRegParms assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln);
extern sqInt booleanValueOf(sqInt obj);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
EXPORT(sqInt) callbackLeave(sqInt cbID);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
extern sqInt characterForAscii(sqInt ascii);
extern sqInt checkAllAccessibleObjectsOkay(void);
static sqInt NoDbgRegParms checkCodeIntegrity(sqInt fullGCFlag);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
extern sqInt checkedIntegerValueOf(sqInt intOop);
static sqInt checkForAndFollowForwardedPrimitiveState(void);
static sqInt NoDbgRegParms checkForEventsMayContextSwitch(sqInt mayContextSwitch);
static sqInt NoDbgRegParms checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset);
static sqInt checkInterpreterIntegrity(void);
static sqInt NoDbgRegParms checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
static sqInt NoDbgRegParms checkOkayFields(sqInt oop);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack);
static sqInt NoDbgRegParms checkOkayStackPage(StackPage *thePage);
static sqInt NoDbgRegParms checkOkayStackZone(sqInt writeBack);
static void NoDbgRegParms checkProfileTick(sqInt aPrimitiveMethod);
static sqInt checkStackIntegrity(void);
static sqInt NoDbgRegParms classNameOfIs(sqInt aClass, char *className);
static sqInt NoDbgRegParms contexthasSender(sqInt thisCntx, sqInt aContext);
static sqInt NoDbgRegParms contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
extern sqInt copiedValueCountOfClosure(sqInt closurePointer);
extern sqInt copyBits(void);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static sqInt NoDbgRegParms NeverInline couldBeProcess(sqInt oop);
static void cr(void);
static void NoDbgRegParms createActualMessageTo(sqInt lookupClass);
static sqInt defaultNumStackPages(void);
static sqInt NoDbgRegParms displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt divorceAllFrames(void);
static void NoDbgRegParms divorceFramesIn(StackPage *aStackPage);
static sqInt NoDbgRegParms doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt NoDbgRegParms doPrimitiveModby(sqInt rcvr, sqInt arg);
extern sqInt doSignalSemaphoreWithIndex(sqInt index);
static void dummyReferToProxy(void);
extern void dumpPrimTraceLog(void);
static sqInt NoDbgRegParms enclosingObjectAtwithObjectwithMixin(sqInt depth, sqInt methodReceiver, sqInt methodMixin);
static sqInt NoDbgRegParms ensureCallerContext(char *theFP);
static void NoDbgRegParms ensureImageFormatIsUpToDate(sqInt swapBytes);
static void NoDbgRegParms externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static char * NoDbgRegParms externalEnsureIsBaseFrame(char *aFramePtr);
static sqInt NoDbgRegParms externalInstVarofContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
static void failUnbalancedPrimitive(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static sqInt NoDbgRegParms fetchPointerofMarriedContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms fetchStackPointerOf(sqInt aContext);
static sqInt NoDbgRegParms findApplicationOfTargetMixinstartingAtBehavior(sqInt targetMixin, sqInt aBehavior);
static sqInt NoDbgRegParms findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * NoDbgRegParms findFrameAboveinPage(char *theFP, StackPage *thePage);
static sqInt NoDbgRegParms findHomeForContext(sqInt aContext);
static sqInt NoDbgRegParms findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
static sqInt NoDbgRegParms findNewMethodInClassTag(sqInt classTagArg);
extern sqInt findSelectorOfMethod(sqInt methArg);
static char * NoDbgRegParms findSPOfon(char *theFP, StackPage *thePage);
extern double floatArg(sqInt index);
static sqInt NoDbgRegParms flushExternalPrimitiveOf(sqInt methodObj);
static void flushMethodCache(void);
static void NoDbgRegParms followForwardedFrameContentsstackPointer(char *theFP, char *theSP);
static void NoDbgRegParms followForwardingPointersInStackZone(sqInt theBecomeEffectsFlags);
extern sqInt forceInterruptCheck(void);
extern void forceInterruptCheckFromHeartbeat(void);
static sqInt NoDbgRegParms frameCallerContext(char *theFP);
static char * NoDbgRegParms frameCallerSP(char *theFP);
static sqInt NoDbgRegParms frameContext(char *theFP);
static sqInt NoDbgRegParms frameHasContext(char *theFP);
static sqInt NoDbgRegParms frameIsBlockActivation(char *theFP);
static sqInt NoDbgRegParms frameMethodObject(char *theFP);
static sqInt NoDbgRegParms frameMethod(char *theFP);
static sqInt NoDbgRegParms frameNumArgs(char *theFP);
static char * NoDbgRegParms frameOfMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms frameReceiver(char *theFP);
static sqInt NoDbgRegParms frameStackedReceiverOffset(char *theFP);
static void freeUntracedStackPages(void);
extern sqInt fullDisplayUpdate(void);
extern void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
extern sqInt getCurrentBytecode(void);
extern sqInt getFullScreenFlag(void);
extern sqInt getInterruptKeycode(void);
extern sqInt getInterruptPending(void);
extern usqLong getNextWakeupUsecs(void);
extern sqInt getSavedWindowSize(void);
extern sqInt * getStackPointer(void);
extern sqInt getThisSessionID(void);
static sqInt NoDbgRegParms getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag);
static sqInt NoDbgRegParms handleForwardedSelectorFaultFor(sqInt selectorOop);
static sqInt NoDbgRegParms handleForwardedSendFaultForTag(sqInt classTag);
static sqInt NoDbgRegParms handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP);
static void handleStackOverflow(void);
static sqInt NoDbgRegParms handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
extern sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
extern sqInt highBit(usqInt anUnsignedValue);
static sqInt NoDbgRegParms ifCurrentStackPageHasValidHeadPointers(StackPage *thePage);
static usqInt NoDbgRegParms iframeMethod(char *theFP);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
static sqInt imageFormatVersion(void);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
static sqInt NoDbgRegParms inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(sqInt selector, sqInt classTag, sqInt callingMethod, sqInt lookupRule);
static sqInt NoDbgRegParms instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr);
extern sqInt integerArg(sqInt index);
static sqInt interpreterAllocationReserveBytes(void);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static sqInt NoDbgRegParms isBaseFrame(char *theFP);
static sqInt NoDbgRegParms isEmptyList(sqInt aLinkedList);
extern sqInt isFloatObject(sqInt oop);
static sqInt NoDbgRegParms isFrameonPage(char *aFrame, StackPage *aPage);
static sqInt NoDbgRegParms isLiveContext(sqInt oop);
static sqInt NoDbgRegParms isMachineCodeFrame(char *theFP);
static sqInt NoDbgRegParms isMarriedOrWidowedContext(sqInt aContext);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
extern sqInt isQuickPrimitiveIndex(sqInt anInteger);
extern sqInt isReadMediatedContextInstVarIndex(sqInt index);
static sqInt NoDbgRegParms isSingleContext(sqInt aContext);
static sqInt NoDbgRegParms isWidowedContextDuringGC(sqInt aOnceMarriedContext);
static sqInt NoDbgRegParms isWidowedContext(sqInt aOnceMarriedContext);
extern sqInt isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isKindOf(sqInt oop, char *className);
extern sqInt isMemberOf(sqInt oop, char *className);
static sqInt NoDbgRegParms lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt loadBitBltFrom(sqInt bb);
extern void loadInitialContext(void);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static sqInt NoDbgRegParms lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static sqInt NoDbgRegParms lookupLexicalfromrule(sqInt selector, sqInt mixin, sqInt rule);
static sqInt NoDbgRegParms lookupMethodInClass(sqInt class);
static sqInt lookupMNU(void);
static sqInt NoDbgRegParms lookupOrdinaryNoMNUEtcInClass(sqInt class);
static sqInt lookupOrdinarySend(void);
static sqInt NoDbgRegParms lookupProtectedstartingAtrule(sqInt selector, sqInt mixinApplication, sqInt rule);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class);
static StackPage * NoDbgRegParms makeBaseFrameFor(sqInt aContext);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static void NeverInline mapStackPages(void);
static sqInt NoDbgRegParms markAndTraceStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceStackPage(StackPage *thePage);
static void markAndTraceUntracedReachableStackPages(void);
static sqInt NoDbgRegParms marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static void NoDbgRegParms marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static sqInt NoDbgRegParms marryFrameSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodArgumentCount(void);
extern sqInt methodArg(sqInt index);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
static sqInt NoDbgRegParms methodHeaderIndicatesLargeFrame(sqInt methodHeader);
extern sqInt methodPrimitiveIndex(void);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt methodUsesAlternateBytecodeSet(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static char * NoDbgRegParms moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static char * NoDbgRegParms nameOfClass(sqInt classOop);
static sqInt NoDbgRegParms noInlineTemporaryin(sqInt offset, char *theFP);
static sqInt NoDbgRegParms noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static sqInt NoDbgRegParms noMarkedContextsOnPage(StackPage *thePage);
static sqInt NoDbgRegParms numSlotsOfMarriedContext(sqInt aContext);
static sqInt numStkPages(void);
static sqInt NoDbgRegParms objCouldBeClassObj(sqInt objOop);
extern sqInt objectArg(sqInt index);
extern sqInt penultimateLiteralOf(sqInt aMethodOop);
extern sqInt popStack(void);
extern sqInt pop(sqInt nItems);
extern void popthenPush(sqInt nItems, sqInt oop);
extern sqInt positive32BitIntegerFor(sqInt integerValue);
extern sqInt positive64BitIntegerFor(sqLong integerValue);
EXPORT(void) primitiveEventProcessingControl(void);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static void NoDbgRegParms printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static void NoDbgRegParms printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
extern void printAllStacks(void);
extern void printCallStack(void);
static sqInt NoDbgRegParms printCallStackFP(char *theFP);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static sqInt NoDbgRegParms printCallStackOfcurrentFP(sqInt aContext, char *currFP);
extern void printChar(sqInt aByte);
static sqInt NoDbgRegParms printContextCallStackOf(sqInt aContext);
extern void printContext(sqInt aContext);
extern void printExternalHeadFrame(void);
static sqInt NoDbgRegParms printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static void NoDbgRegParms printFrameFlagsForFP(char *theFP);
static void NoDbgRegParms printFrameOopat(char *name, char *address);
EXPORT(void) printFramesInPage(StackPage *thePage);
EXPORT(void) printFramesOnStackPageListInUse(void);
static void NoDbgRegParms printFrameThingandFrameat(char *name, char *theFP, char *address);
static void NoDbgRegParms printFrameThingat(char *name, char *address);
extern sqInt printFrame(char *theFP);
extern sqInt printFrameWithSP(char *theFP, char *theSP);
extern void printHex(sqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodCacheFor(sqInt thing);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static void NoDbgRegParms printNameOfClasscount(sqInt classOop, sqInt cnt);
static void NoDbgRegParms printNum(sqInt n);
static void NoDbgRegParms printOopShort(sqInt oop);
extern void printOop(sqInt oop);
extern void printProcessStack(sqInt aProcess);
extern sqInt printProcsOnList(sqInt procList);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame);
extern void printStackPageList(void);
extern void printStackPageListInUse(void);
extern void printStackPages(void);
extern void printStackPagesInUse(void);
static void NoDbgRegParms printStackPageuseCount(StackPage *page, sqInt n);
extern void printStackReferencesTo(sqInt oop);
static void NoDbgRegParms printStringOf(sqInt oop);
extern void print(char *s);
extern void pushBool(sqInt trueOrFalse);
static sqInt NoDbgRegParms pushedReceiverOrClosureOfFrame(char *theFP);
extern void pushFloat(double f);
extern sqInt pushInteger(sqInt integerValue);
extern void push(sqInt object);
static void NoDbgRegParms putLongtoFile(long aLong, sqImageFile aFile);
static void NoDbgRegParms putShorttoFile(short aShort, sqImageFile aFile);
static void NoDbgRegParms putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static void NoDbgRegParms putWord32toFile(int aWord32, sqImageFile aFile);
static sqInt NoDbgRegParms quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt readableFormat(sqInt imageVersion);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
static sqInt NoDbgRegParms removeFirstLinkOfList(sqInt aList);
static sqInt NoDbgRegParms resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt NoDbgRegParms reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static void NoDbgRegParms rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void));
static sqInt NoDbgRegParms roomToPushNArgs(sqInt n);
static sqInt NoDbgRegParms safeMethodClassOf(sqInt methodPointer);
static sqInt NoDbgRegParms saneFunctionPointerForFailureOfPrimIndex(sqInt primIndex);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
extern void setBreakMNUSelector(char *aString);
extern void setBreakSelector(char *aString);
extern void setFullScreenFlag(sqInt value);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
extern void setInterruptKeycode(sqInt value);
extern void setInterruptPending(sqInt value);
extern void setNextWakeupUsecs(usqLong value);
extern void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static void NoDbgRegParms setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
static sqInt NoDbgRegParms shortPrintContext(sqInt aContext);
static sqInt NoDbgRegParms shortPrintFrameAndCallers(char *theFP);
EXPORT(void) shortPrintFramesInPage(StackPage *thePage);
EXPORT(void) shortPrintFramesOnStackPageListInUse(void);
static sqInt NoDbgRegParms shortPrintFrame(char *theFP);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n);
static void NoDbgRegParms shortPrintOop(sqInt oop);
static sqInt NoDbgRegParms shortReversePrintFrameAndCallers(char *aFramePointer);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
static sqInt NoDbgRegParms snapshot(sqInt embedded);
static void space(void);
extern sqInt specialSelector(sqInt index);
static void NoDbgRegParms spurPostBecomeAction(sqInt theBecomeEffectsFlags);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
static sqInt stackLimitOffset(void);
extern sqInt stackObjectValue(sqInt offset);
static sqInt stackPageByteSize(void);
static sqInt stackPageHeadroom(void);
static sqInt NoDbgRegParms stackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms stackPointerIndexForFrame(char *theFP);
extern usqInt stackPositiveMachineIntegerValue(sqInt offset);
extern long stackSignedMachineIntegerValue(sqInt offset);
extern sqInt stackTop(void);
extern sqInt stackValue(sqInt offset);
extern sqInt startPCOfMethod(sqInt aCompiledMethod);
extern sqInt stObjectat(sqInt array, sqInt index);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
static char * NoDbgRegParms storeSenderOfFramewithValue(char *theFP, sqInt anOop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt superclassOf(sqInt classPointer);
static sqInt NoDbgRegParms synchronousSignal(sqInt aSemaphore);
extern sqInt tempCountOf(sqInt methodPointer);
extern sqInt temporaryCountOfMethodHeader(sqInt header);
static void NoDbgRegParms transferTo(sqInt newProc);
static void NoDbgRegParms updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
extern sqInt validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp);
static sqInt validStackPageBaseFrames(void);
static sqInt NoDbgRegParms validStackPageBaseFrame(StackPage *aPage);
static void NoDbgRegParms voidLongRunningPrimitive(char *reason);
static sqInt NoDbgRegParms voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
static sqInt wakeHighestPriority(void);
extern char * whereIs(sqInt anOop);
static sqInt NoDbgRegParms withSmallIntegerTags(char *value);
static sqInt NeverInline writeImageFileIO(void);
static sqInt NoDbgRegParms cloneContext(sqInt aContext);
static sqInt NoDbgRegParms fieldOrSenderFPofContext(sqInt index, sqInt contextObj);
static sqInt NoDbgRegParms fieldofFrame(sqInt index, char *theFP);
static sqInt NoDbgRegParms isAppropriateForCopyObject(sqInt oop);
static void primitiveClone(void);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveContextXray(void);
static void primitiveDeferDisplayUpdates(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExternalCall(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
static void primitiveFullGC(void);
static void primitiveIncrementalGC(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
EXPORT(sqInt) primitiveLongRunningPrimitive(void);
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
static void primitiveObjectPointsTo(void);
static void primitivePerform(void);
static void primitivePin(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSlotAt(void);
static void primitiveSlotAtPut(void);
static void primitiveStoreStackp(void);
static void primitiveTerminateTo(void);
static void primitiveVMParameter(void);
EXPORT(void) primitiveVoidReceiver(void);
static void primitiveVoidVMState(void);
static void NoDbgRegParms pruneStackstackp(sqInt stack, sqInt stackp);
static void unmarkAfterPathTo(void);
static void unmarkAllFrames(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss usqInt method;
_iss sqInt nilObj;
_iss sqInt argumentCount;
_iss StackPage * stackPage;
_iss sqInt specialObjectsOop;
_iss char * framePointer;
_iss sqInt bytecodeSetSelector;
_iss usqInt freeStart;
_iss sqInt messageSelector;
_iss sqInt markStack;
_iss usqInt newMethod;
_iss usqInt endOfMemory;
_iss usqInt instructionPointer;
_iss usqInt newSpaceLimit;
_iss sqInt trueObj;
_iss sqInt weaklingStack;
_iss sqInt falseObj;
_iss SpurSegmentInfo * segments;
_iss sqInt hiddenRootsObj;
_iss sqInt lkupClassTag;
_iss usqInt totalFreeOldSpace;
_iss usqInt pastSpaceStart;
_iss sqInt needGCFlag;
_iss StackPage * pages;
_iss sqInt numSegments;
_iss usqInt scavengeThreshold;
_iss sqInt * freeLists;
_iss char * stackMemory;
_iss sqInt classTableFirstPage;
_iss sqInt rememberedSetSize;
_iss char * stackLimit;
_iss sqInt * rememberedSet;
_iss sqInt remapBufferCount;
_iss sqInt bytesPerPage;
_iss sqInt localAbsentReceiver;
_iss usqInt freeListsMask;
_iss StackPage * mostRecentlyUsedPage;
_iss usqInt firstFreeChunk;
_iss sqInt tempOop;
_iss SpurContiguousObjStack unscannedEphemerons;
_iss sqInt lkupClass;
_iss SpurNewSpaceSpace pastSpace;
_iss usqInt newSpaceStart;
_iss usqInt oldSpaceStart;
_iss sqInt numStackPages;
_iss sqInt profileProcess;
_iss sqInt numClassTablePages;
_iss sqInt classTableIndex;
_iss SpurNewSpaceSpace futureSpace;
_iss sqInt localAbsentReceiverOrZero;
_iss sqInt profileMethod;
_iss sqLong nextProfileTick;
_iss sqInt numRememberedEphemerons;
_iss sqInt jmpDepth;
_iss usqInt lastFreeChunk;
_iss SpurNewSpaceSpace eden;
_iss sqInt futureSurvivorStart;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss sqInt profileSemaphore;
_iss char * objStackInvalidBecause;
_iss sqInt becomeEffectsFlags;
_iss sqInt ephemeronList;
_iss usqInt freeOldSpaceStart;
_iss sqInt tempOop2;
_iss sqInt tenureThreshold;
_iss sqInt extraRootCount;
_iss sqInt growHeadroom;
_iss sqInt invalidObjStackPage;
_iss sqInt previousRememberedSetSize;
_iss sqInt classNameIndex;
_iss sqInt pendingFinalizationSignals;
_iss sqInt mournQueue;
_iss sqInt tenureCriterion;
_iss sqInt metaclassNumSlots;
_iss sqInt numSegInfos;
_iss sqInt preemptionYields;
_iss usqLong nextWakeupUsecs;
_iss sqInt highestRunnableProcessPriority;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt newFinalization;
_iss usqLong statCheckForEvents;
_iss usqLong statGCEndUsecs;
_iss sqInt weakList;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt thisClassIndex;
_iss sqInt firstSegmentSize;
_iss usqLong gcStartUsecs;
_iss usqInt lowSpaceThreshold;
_iss sqInt rememberedSetLimit;
_iss sqInt shrinkThreshold;
_iss usqLong statIOProcessEvents;
_iss sqInt imageHeaderFlags;
_iss sqInt lastHash;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt marking;
_iss usqInt memory;
_iss sqInt numCompactionPasses;
_iss sqInt scavengeInProgress;
_iss sqInt statSurvivorCount;
_iss sqInt fullScreenFlag;
_iss float heapGrowthToSizeGCRatio;
_iss usqInt heapSizeAtPreviousGC;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
_iss usqLong nextPollUsecs;
_iss sqInt rememberedSetRedZone;
_iss sqInt statCompactPassCount;
_iss usqLong statForceInterruptCheck;
_iss usqLong statFullGCUsecs;
_iss sqInt statFullGCs;
_iss sqInt statGrowMemory;
_iss usqLong statProcessSwitch;
_iss usqLong statScavengeGCUsecs;
_iss sqInt statScavenges;
_iss sqInt statShrinkMemory;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss sqInt statTenures;
_iss sqInt canSwizzle;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt gcSemaphoreIndex;
_iss sqInt globalSessionID;
_iss sqInt imageFloatsBigEndian;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt savedWindowSize;
_iss sqInt signalLowSpace;
_iss sqInt statMarkCount;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statNumMaps;
_iss sqInt statPageCountWhenMappingSum;
_iss sqInt statRootTableCount;
_iss sqInt tenuringProportion;
_iss sqInt classByteArrayCompactIndex;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt refCountToShrinkRT;
_iss sqInt statCoalesces;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIncrGCUsecs;
_iss sqInt statIncrGCs;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt statRootTableOverflows;
_iss usqLong statSGCDeltaUsecs;
_iss sqInt tenuringClassIndex;
_iss sqInt the2ndUnknownShort;
_iss sqInt theUnknownShort;
_iss long methodCache[MethodCacheSize + 1 /* 2049 */];
_iss long nsMethodCache[NSMethodCacheSize + 1 /* 4097 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt *extraRoots[ExtraRootsSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss unsigned long byteCount;
_iss SpurCircularBuffer highestObjects;
_iss sqInt preferredPinningSegment;
_iss usqLong statFGCDeltaUsecs;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
 #if SQ_USE_GLOBAL_STRUCT_REG
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
#endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
#if SQ_USE_GLOBAL_STRUCT_REG
#define fooxstr(s) foostr(s)
#define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
#else
static struct foo * foo = &fum;
#endif
#endif
static void (*primitiveFunctionPointer)();
sqInt checkForLeaks;
sqInt checkAllocFiller;
sqInt inIOProcessEvents;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
sqInt extraVMMemory;
sqInt breakSelectorLength = MinSmallInteger;
unsigned long maxOldSpaceSize;
void * showSurfaceFn;
sqInt deferDisplayUpdates;
struct VirtualMachine* interpreterProxy;
static void (*interruptCheckChain)(void) = 0;
char * breakSelector;
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ (void (*)(void))0,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ primitiveImmediateAsInteger,
	/* 172 */ primitiveFetchNextMourner,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ primitiveGrowMemoryByAtLeast,
	/* 181 */ primitiveSizeInBytesOfInstance,
	/* 182 */ primitiveSizeInBytes,
	/* 183 */ primitiveIsPinned,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveFlushCacheByMethod,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ (void (*)(void))0,
	/* 245 */ (void (*)(void))0,
	/* 246 */ (void (*)(void))0,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ (void (*)(void))0,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ primitiveSmallFloatAdd,
	/* 542 */ primitiveSmallFloatSubtract,
	/* 543 */ primitiveSmallFloatLessThan,
	/* 544 */ primitiveSmallFloatGreaterThan,
	/* 545 */ primitiveSmallFloatLessOrEqual,
	/* 546 */ primitiveSmallFloatGreaterOrEqual,
	/* 547 */ primitiveSmallFloatEqual,
	/* 548 */ primitiveSmallFloatNotEqual,
	/* 549 */ primitiveSmallFloatMultiply,
	/* 550 */ primitiveSmallFloatDivide,
	/* 551 */ primitiveSmallFloatTruncated,
	/* 552 */ primitiveSmallFloatFractionalPart,
	/* 553 */ primitiveSmallFloatExponent,
	/* 554 */ primitiveSmallFloatTimesTwoPower,
	/* 555 */ primitiveSmallFloatSquareRoot,
	/* 556 */ primitiveSmallFloatSine,
	/* 557 */ primitiveSmallFloatArctan,
	/* 558 */ primitiveSmallFloatLogN,
	/* 559 */ primitiveSmallFloatExp,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
char expensiveAsserts = 0;
const char *interpreterVersion = "Newspeak Virtual Machine StackInterpreterPrimitives_VMMaker.oscog-eem.1680";
volatile int sendTrace;
sqInt suppressHeartbeatFlag;


/*** Macros ***/
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define statMaxPageCountWhenMapping() GIV(statMaxPageCountWhenMapping)
#define pageIndexForstackMemorybytesPerPage(pointer,stackmem,pageByteSize) (((char *)(pointer) - (stackmem) - 1) / (pageByteSize))
#define numTagBits() 3
#define shiftForWord() 3
#define smallFloatExponentBits() 8
#define smallFloatExponentOffset() 896
#define smallFloatMantissaBits() 52
#define smallFloatTag() 3
#define tagMask() 0x7
#define wordSize() 8
#define eden() GIV(eden)
#define futureSpace() GIV(futureSpace)
#define futureSurvivorStart() GIV(futureSurvivorStart)
#define pastSpace() GIV(pastSpace)
#define rememberedSetLimit() GIV(rememberedSetLimit)
#define rememberedSetSize() GIV(rememberedSetSize)
#define characterTag() 2
#define classIndexMask() 0x3FFFFF
#define classTableMajorIndexShift() 10
#define endOfMemory() GIV(endOfMemory)
#define firstByteFormat() 16
#define firstCompiledMethodFormat() 24
#define firstLongFormat() 10
#define firstShortFormat() 12
#define fixedFieldsFieldWidth() 16
#define formatMask() 0x1F
#define formatShift() 24
#define freeStart() GIV(freeStart)
#define identityHashFullWordShift() 32
#define identityHashHalfWordMask() 0x3FFFFF
#define indexablePointersFormat() 3
#define isForwardedObjectClassIndexPun() 8
#define maxOldSpaceSize() maxOldSpaceSize
#define memory() GIV(memory)
#define newSpaceLimit() GIV(newSpaceLimit)
#define numSlotsFullShift() 56
#define numSlotsHalfShift() 24
#define numSlotsMask() 0xFF
#define oldSpaceStart() GIV(oldSpaceStart)
#define remapBufferCount() GIV(remapBufferCount)
#define rememberedBitShift() 29
#define rootTableCapacity() GIV(rememberedSetLimit)
#define rootTableCount() GIV(rememberedSetSize)
#define sixtyFourBitIndexableFormat() 9
#define startOfMemory() GIV(memory)
#define weakArrayFormat() 4
#define numSegments() GIV(numSegments)
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define checkAllocFiller() GIV(checkAllocFiller)
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define flush() fflush(stdout)
#define printFloat(f) printf("%g", f)
#define stackPageFrameBytes() (256 * BytesPerWord)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* StackInterpreter>>#interpret */
sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentBytecode;
    sqInt extA;
    sqInt extB;
    char * localFP;
    char * localIP;
    sqInt localReturnValue;
    char * localSP;
    sqInt stackPageBytes;
    sqInt stackPagesBytes;
    void *theStackMemory;

	if (GIV(stackLimit) == 0) {
		/* begin initStackPagesAndInterpret */
		stackPageBytes = stackPageByteSize();
		/* begin computeStackZoneSize */
		stackPagesBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
		theStackMemory = alloca(stackPagesBytes);
		memset(theStackMemory, 0, stackPagesBytes);
		initializeStacknumSlotspageSize(theStackMemory, stackPagesBytes / BytesPerWord, stackPageBytes / BytesPerWord);
		loadInitialContext();
		ioInitHeartbeat();
		interpret();
		return null;
	}
	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin fetchNextBytecode */
	currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

	/* begin initExtensions */
	extA = (extB = 0);

	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		case 0:
		case 256: /*0*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize)));
			}
			break;
		case 1:
		case 257: /*1*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 8 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 2:
		case 258: /*2*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 16 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 3:
		case 259: /*3*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 24 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 4:
		case 260: /*4*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 32 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 5:
		case 261: /*5*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 40 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 6:
		case 262: /*6*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 48 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 7:
		case 263: /*7*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 56 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 8:
		case 264: /*8*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 64 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 9:
		case 265: /*9*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 72 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 10:
		case 266: /*10*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 80 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 11:
		case 267: /*11*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 88 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 12:
		case 268: /*12*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 96 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 13:
		case 269: /*13*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 104 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 14:
		case 270: /*14*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 112 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 15:
		case 271: /*15*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 120 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 16:
		case 320: /*64*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 17:
		case 321: /*65*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 18:
		case 322: /*66*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 19:
		case 323: /*67*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 20:
		case 324: /*68*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 21:
		case 325: /*69*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 22:
		case 326: /*70*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 23:
		case 327: /*71*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 24:
		case 328: /*72*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 25:
		case 329: /*73*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 26:
		case 330: /*74*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 27:
		case 331: /*75*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 28:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (12 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 29:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (13 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 30:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (14 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 31:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				object = (15 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 32:
		case 288: /*32*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 33:
		case 289: /*33*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 34:
		case 290: /*34*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 35:
		case 291: /*35*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 36:
		case 292: /*36*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 37:
		case 293: /*37*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 38:
		case 294: /*38*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 39:
		case 295: /*39*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 40:
		case 296: /*40*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 41:
		case 297: /*41*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 42:
		case 298: /*42*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 43:
		case 299: /*43*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 44:
		case 300: /*44*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 45:
		case 301: /*45*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 46:
		case 302: /*46*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 47:
		case 303: /*47*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 48:
		case 304: /*48*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 136 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 49:
		case 305: /*49*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 144 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 50:
		case 306: /*50*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 152 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 51:
		case 307: /*51*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 160 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 52:
		case 308: /*52*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 168 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 53:
		case 309: /*53*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 176 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 54:
		case 310: /*54*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 184 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 55:
		case 311: /*55*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 192 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 56:
		case 312: /*56*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 200 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 57:
		case 313: /*57*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 208 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 58:
		case 314: /*58*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 216 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 59:
		case 315: /*59*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 224 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 60:
		case 316: /*60*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 232 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 61:
		case 317: /*61*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 240 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 62:
		case 318: /*62*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 0xF8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 63:
		case 319: /*63*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 256 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 64:
		case 272: /*16*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 65:
		case 273: /*17*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 66:
		case 274: /*18*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 67:
		case 275: /*19*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 68:
		case 276: /*20*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 69:
		case 277: /*21*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 70:
		case 278: /*22*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 71:
		case 279: /*23*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 72:
		case 280: /*24*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 73:
		case 281: /*25*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 74:
		case 282: /*26*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 75:
		case 283: /*27*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 76:
		case 284: /*28*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 77:
		case 285: /*29*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 78:
		case 286: /*30*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 79:
		case 287: /*31*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 80:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 136 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 81:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 144 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 82:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 152 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 83:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 160 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 84:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 168 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 85:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 176 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 86:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 184 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 87:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 192 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 88:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 200 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 89:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 208 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 90:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 216 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 91:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 224 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 92:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 232 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 93:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 240 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 94:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 0xF8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 95:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 256 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 96:
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
		case 103:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				rcvr = longAt(localFP + FoxReceiver);
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
				
#        if IMMUTABILITY
				assert(!((isImmediate(rcvr))));
				if (((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), top);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), (((instVarIndex + 1) << 3) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l1;
				}

#        endif /* IMMUTABILITY */

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				if (isOldObject(rcvr)) {

					/* most stores into young objects */
					if (((top & (tagMask())) == 0)
					 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(rcvr);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((long)instVarIndex) << (shiftForWord())), top);
			l1:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 104:
		case 440: /*184*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 105:
		case 441: /*185*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 106:
		case 442: /*186*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 107:
		case 443: /*187*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 108:
		case 444: /*188*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 109:
		case 445: /*189*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 110:
		case 446: /*190*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 111:
		case 447: /*191*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 112:
		case 332: /*76*/
			/* pushReceiverBytecode */
			{
				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(localFP + FoxReceiver));
			}
			break;
		case 113:
			/* pushConstantTrueBytecode */
			{
				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
			break;
		case 114:
			/* pushConstantFalseBytecode */
			{
				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
			break;
		case 115:
			/* pushConstantNilBytecode */
			{
				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
			}
			break;
		case 116:
			/* pushConstantMinusOneBytecode */
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			break;
		case 117:
		case 334: /*78*/
			/* pushConstantZeroBytecode */
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			break;
		case 118:
		case 335: /*79*/
			/* pushConstantOneBytecode */
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			break;
		case 119:
			/* pushConstantTwoBytecode */
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			break;
		case 120:
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver);
				localReturnValue = longAt(localFP + FoxReceiver);
				/* goto commonReturn */
			}
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt ctxtOrNilOrZero;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				sqInt index;
				sqInt index1;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt objOop;
				sqInt objOop1;
				sqInt onSamePage;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt senderContext;
				sqInt senderOop;
				sqInt senderOop1;
				sqInt senderOop2;
				char *theFP;
				char *theFP1;
				char *theFP2;
				char *theFPAbove;
				sqInt theMethod;
				sqInt theMethod1;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;
				sqInt unwindContextOrNilOrZero;

				VM_LABEL(commonReturn);
				
				/* If this is a method simply return to the  sender/caller. */
				frameToReturnTo = 0;
				if (!((byteAt((localFP + FoxFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l190;
				}
				closure = longAt(localFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((localFP + FoxFrameFlags) + 1))) << (shiftForWord()))));

				/* Walk the closure's lexical chain to find the context or frame to return from (home). */
				home = null;
				while (closure != GIV(nilObj)) {
					/* begin followField:ofObject: */
					objOop = longAt((closure + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())));
					if (((objOop & (tagMask())) == 0)
					 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, closure, objOop);
					}
					home = objOop;
					/* begin followField:ofObject: */
					objOop1 = longAt((home + BaseHeaderSize) + (((long)ClosureIndex) << (shiftForWord())));
					if (((objOop1 & (tagMask())) == 0)
					 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, home, objOop1);
					}
					closure = objOop1;
				}
				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin findUnwindThroughContext: */

				/* Since nothing changes we don't need to internalize. */
				onSamePage = ((((((longAt((home + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
				 && (!(isWidowedContext(home))))
				 && ((pageIndexForstackMemorybytesPerPage(GIV(framePointer), GIV(stackMemory), GIV(bytesPerPage))) == (pageIndexFor(frameOfMarriedContext(home))));
				theFP2 = GIV(framePointer);
				theFPAbove = GIV(framePointer);
				do {
					if (((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0)
					 && (home == (longAt(theFP2 + FoxThisContext)))) {
						ctxtOrNilOrZero = 0;
						goto l191;
					}
					if (!((byteAt((theFP2 + FoxFrameFlags) + 3)) != 0)) {
						theMethod1 = longAt(theFP2 + FoxMethod);
						if ((primitiveIndexOfMethodheader(theMethod1, methodHeaderOf(theMethod1))) == 198) {
							if (theFP2 == theFPAbove) {
								theSP = findSPOfon(theFP2, stackPageFor(theFP2));
							}
							else {
								/* begin frameCallerStackPointer: */
								assert(!(isBaseFrame(theFPAbove)));
								theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(theFP2)));
								ctxtOrNilOrZero = longAt(theFP2 + FoxThisContext);
								goto l191;
							}
							ctxtOrNilOrZero = marryFrameSP(theFP2, theSP);
							goto l191;
						}
					}
					theFPAbove = theFP2;
					theFP2 = pointerForOop(longAt(theFP2 + FoxSavedFP));
				} while(theFP2 != 0);
				senderContext = longAt(theFPAbove + FoxCallerContext);
				if (!(((senderContext & (tagMask())) == 0)
					 && (((longAt(senderContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
					ctxtOrNilOrZero = GIV(nilObj);
					goto l191;
				}
				ctxtOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, home);
			l191:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
				assert(!((onSamePage
 && (ctxtOrNilOrZero == (nilObject())))));
				if (ctxtOrNilOrZero == 0) {
					theMethod = longAt((home + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
					if ((primitiveIndexOfMethodheader(theMethod, methodHeaderOf(theMethod))) == 198) {
						unwindContextOrNilOrZero = home;
						goto l194;
					}
					unwindContextOrNilOrZero = 0;
					goto l194;
				}
				if (!(onSamePage
					 || (ctxtOrNilOrZero == GIV(nilObj)))) {
					if ((findMethodWithPrimitiveFromContextUpToContext(0, ctxtOrNilOrZero, home)) == GIV(nilObj)) {
						unwindContextOrNilOrZero = GIV(nilObj);
						goto l194;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
			l194:	/* end findUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */
					/* begin internalCannotReturn: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l193;
					}
					ourContext = marryFrameSP(localFP, localSP);
				l193:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorCannotReturn) << (shiftForWord())));
					GIV(argumentCount) = 1;
					goto normalSend;
					/* return self */
					goto l190;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l196;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
				l196:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAboutToReturn) << (shiftForWord())));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l190;
				}
				contextToReturnTo = null;
				if (((((longAt((home + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - 1);
					if ((longAt(theFP + FoxSavedFP)) == 0) {
						contextToReturnTo = longAt(theFP + FoxCallerContext);
					}
					else {
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
					if ((((contextToReturnTo & (tagMask())) == 0)
					 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex))
					 && (((((longAt((contextToReturnTo + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop1) & 7) == 1));
						frameToReturnTo = pointerForOop(senderOop1 - 1);
						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					/* begin establishFrameForContextToReturnTo: */
					if (!(((contextToReturnTo & (tagMask())) == 0)
						 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
						frameToReturnTo = 0;
						goto l195;
					}
					if (((((longAt((contextToReturnTo + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
						if (isWidowedContext(contextToReturnTo)) {

							/* error: home's sender is dead; cannot return */
							frameToReturnTo = 0;
							goto l195;
						}
						/* begin frameOfMarriedContext: */
						senderOop2 = longAt((contextToReturnTo + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop2) & 7) == 1));
						frameToReturnTo = pointerForOop(senderOop2 - 1);
						goto l195;
					}
					if (!(((((longAt((contextToReturnTo + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord()))))) & 7) == 1))) {
						frameToReturnTo = 0;
						goto l195;
					}
					thePage1 = makeBaseFrameFor(contextToReturnTo);
					markStackPageMostRecentlyUsed(thePage1);
					frameToReturnTo = (thePage1->baseFP);
				l195:	/* end establishFrameForContextToReturnTo: */;
					if (frameToReturnTo == 0) {

						/* error: home's sender is dead; cannot return */
						/* begin internalCannotReturn: */
						if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(localFP)));
							ourContext2 = longAt(localFP + FoxThisContext);
							goto l192;
						}
						ourContext2 = marryFrameSP(localFP, localSP);
					l192:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext2);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorCannotReturn) << (shiftForWord())));
						GIV(argumentCount) = 1;
						goto normalSend;
						/* return self */
						goto l190;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				index1 = pageIndexForstackMemorybytesPerPage(frameToReturnTo, GIV(stackMemory), GIV(bytesPerPage));
				newPage = stackPageAtpages(index1, GIV(pages));
				if (newPage != GIV(stackPage)) {
					currentCtx = longAt(((GIV(stackPage)->baseFP)) + FoxCallerContext);
					freeStackPage(GIV(stackPage));
					while (1) {
						assert(isContext(currentCtx));
						if ((((((longAt((currentCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((((longAt((currentCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
							/* begin stackPageFor: */
							index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
							thePage = stackPageAtpages(index, GIV(pages));
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							/* begin frameCallerContext: */
							theFP1 = (thePage->baseFP);
							currentCtx = longAt(theFP1 + FoxCallerContext);
							freeStackPage(thePage);
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isForwarded(currentCtx)));
							longAtput((currentCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isForwarded(currentCtx)));
							longAtput((currentCtx + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage != 0);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = (frameCallerSP(callerFP)) - BytesPerWord;
				}
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
					? 256
					: 0);

				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				longAtPointerput(localSP, localReturnValue);
			}
		l190:	/* end case */;
			break;
		case 121:
			/* returnTrue */
			{
				VM_LABEL(returnTrue);
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			break;
		case 122:
			/* returnFalse */
			{
				VM_LABEL(returnFalse);
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			break;
		case 123:
			/* returnNil */
			{
				VM_LABEL(returnNil);
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			break;
		case 124:
		case 473: /*217*/
			/* returnTopFromMethod */
			{
				VM_LABEL(returnTopFromMethod);
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			break;
		case 125:
			/* returnTopFromBlock */
			{
				VM_LABEL(returnTopFromBlock);
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				sqInt index;
				sqInt isAContext;
				sqInt ourContext;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				char *theSP;

				VM_LABEL(commonCallerReturn);
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {

					/* baseFrame */
					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					contextToReturnTo = longAt(localFP + FoxCallerContext);
					isAContext = ((contextToReturnTo & (tagMask())) == 0)
					 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex);
					if (isAContext
					 && ((((((longAt((contextToReturnTo + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop) & 7) == 1));
						theFP = pointerForOop(senderOop - 1);
						/* begin stackPageFor: */
						index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index, GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
							freeStackPageNoAssert(GIV(stackPage));
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */
							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l199;
							}
							while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l199;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
						l199:	/* end findFrameAbove:inPage: */;
							moveFramesInthroughtoPage(thePage, frameAbove, GIV(stackPage));
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(isAContext
							 && (((((longAt((contextToReturnTo + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord()))))) & 7) == 1)))) {
							/* begin internalCannotReturn: */
							if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(localFP)));
								ourContext = longAt(localFP + FoxThisContext);
								goto l200;
							}
							ourContext = marryFrameSP(localFP, localSP);
						l200:	/* end ensureFrameIsMarried:SP: */;
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), ourContext);
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorCannotReturn) << (shiftForWord())));
							GIV(argumentCount) = 1;
							goto normalSend;
							/* return self */
							goto l198;
						}
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
						freeStackPageNoAssert(GIV(stackPage));
					}
					/* begin setStackPageAndLimit: */
					assert(thePage != 0);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					/* begin setMethod: */
					GIV(method) = longAt(localFP + FoxMethod);
					assert(isOopCompiledMethod(GIV(method)));
					GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
						? 256
						: 0);

					localIP = pointerForOop(longAtPointer(localSP));
					longAtPointerput(localSP, localReturnValue);
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					/* return self */
				l198:	/* end baseFrameReturn */;
					goto l197;
				}
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((localFP + FoxFrameFlags) + 1))) << (shiftForWord())));
				localFP = callersFPOrNull;
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
					? 256
					: 0);

				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				longAtPointerput(localSP, localReturnValue);
			}
		l197:	/* end case */;
			break;
		case 126:
		case 127:
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = (SelectorUnknownBytecode < (numSlotsOf(GIV(specialObjectsOop)))
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorUnknownBytecode) << (shiftForWord())))
					: 0);
				if ((GIV(messageSelector) == null)
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l201;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l201:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 128:
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt objOop;
				sqInt referent;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord()))));
					goto l2;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					object1 = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l2;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + (((long)(variableIndex + LiteralStart)) << (shiftForWord())));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l2;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					
					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((long)(variableIndex + LiteralStart)) << (shiftForWord())));
					if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar));
						referent = longAt((litVar + BaseHeaderSize) + (0LL << (shiftForWord())));
						while (((referent & (tagMask())) == 0)
						 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
						}
						litVar = referent;
					}
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord()))));

					goto l2;
				}
			}
		l2:	/* end case */;
			break;
		case 129:
			/* extendedStoreBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt objOop;
				sqInt referent;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				if (variableType == 0) {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					objOop = longAt(localFP + FoxReceiver);
					
#          if IMMUTABILITY
					assert(!((isImmediate(objOop))));
					if (((((usqInt) (longAt(objOop))) >> 23) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), objOop);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((variableIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l4;
					}

#          endif /* IMMUTABILITY */

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(objOop)));
					if (isOldObject(objOop)) {

						/* most stores into young objects */
						if (((value & (tagMask())) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(objOop);
							}
						}
					}
					longAtput((objOop + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord())), value);
				l4:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l3;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l3;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((long)(variableIndex + LiteralStart)) << (shiftForWord())));
					if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar));
						referent = longAt((litVar + BaseHeaderSize) + (0LL << (shiftForWord())));
						while (((referent & (tagMask())) == 0)
						 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
						}
						litVar = referent;
					}
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(litVar))));
					if (((((usqInt) (longAt(litVar))) >> 23) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((ValueIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l5;
					}

#          endif /* IMMUTABILITY */

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */
						if (((value & (tagMask())) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())), value);
				l5:	/* end storeLiteralVariable:withValue: */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l3;
				}
				error("illegal store");
			l3:	/* end extendedStoreBytecodePop: */;
			}
			break;
		case 130:
			/* extendedStoreAndPopBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt objOop;
				sqInt referent;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;

				if (variableType == 0) {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					objOop = longAt(localFP + FoxReceiver);
					
#          if IMMUTABILITY
					assert(!((isImmediate(objOop))));
					if (((((usqInt) (longAt(objOop))) >> 23) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), objOop);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((variableIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l7;
					}

#          endif /* IMMUTABILITY */

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(objOop)));
					if (isOldObject(objOop)) {

						/* most stores into young objects */
						if (((value & (tagMask())) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(objOop);
							}
						}
					}
					longAtput((objOop + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord())), value);
				l7:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l6;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l6;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((long)(variableIndex + LiteralStart)) << (shiftForWord())));
					if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar));
						referent = longAt((litVar + BaseHeaderSize) + (0LL << (shiftForWord())));
						while (((referent & (tagMask())) == 0)
						 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
						}
						litVar = referent;
					}
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(litVar))));
					if (((((usqInt) (longAt(litVar))) >> 23) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((ValueIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l8;
					}

#          endif /* IMMUTABILITY */

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */
						if (((value & (tagMask())) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())), value);
				l8:	/* end storeLiteralVariable:withValue: */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l6;
				}
				error("illegal store");
			l6:	/* end extendedStoreBytecodePop: */;
			}
			break;
		case 131:
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(normalSend);
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				assert(GIV(lkupClassTag) != (nilObject()));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					sqInt classTablePage;
					sqInt errorCode;
					sqInt fieldIndex;
					sqInt fieldIndex1;
					sqInt hash1;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					sqInt nArgs;
					sqInt numTemps;
					sqInt object;
					sqInt probe1;
					sqInt rcvr;
					char *savedFramePointer;
					char *savedStackPointer;
					sqInt succeeded;
					sqInt table;

					VM_LABEL(commonSendOrdinary);
					nArgs = 0;
					savedFramePointer = 0;
					savedStackPointer = 0;
					/* begin sendBreakpoint:receiver: */
					sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
					/* begin internalFindNewMethodOrdinary */

					/* shift drops two low-order zeros from addresses */
					hash1 = GIV(messageSelector) ^ GIV(lkupClassTag);

					/* first probe */
					probe1 = hash1 & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == GIV(lkupClassTag))) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l203;
					}

					/* second probe */
					probe1 = (((usqInt) hash1) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == GIV(lkupClassTag))) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l203;
					}
					probe1 = (((usqInt) hash1) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == GIV(lkupClassTag))) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l203;
					}
					/* end inlineLookupInMethodCacheSel:classTag:; fall through */
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
					 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
						if (((GIV(messageSelector) & (tagMask())) == 0)
						 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
							GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
						}
						if (lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag))) {
							goto l202;
						}
					}
					/* begin classAtIndex: */
					assert((GIV(lkupClassTag) <= (tagMask()))
					 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l206;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = GIV(lkupClassTag) & ((1LL << (classTableMajorIndexShift())) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
				l206:	/* end classAtIndex: */;
					lookupOrdinarySend();

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass));
				l203:	;
				l202:	/* end internalFindNewMethodOrdinary */;
					/* begin internalExecuteNewMethod */
					if (primitiveFunctionPointer != 0) {
						if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex());
							localPrimIndex = ((sqInt) primitiveFunctionPointer);
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((long)(localPrimIndex - 264)) << (shiftForWord()))));
								goto l207;
							}
							if (localPrimIndex == 256) {
								goto l207;
							}
							if (localPrimIndex == 257) {
								longAtPointerput(localSP, GIV(trueObj));
								goto l207;
							}
							if (localPrimIndex == 258) {
								longAtPointerput(localSP, GIV(falseObj));
								goto l207;
							}
							if (localPrimIndex == 259) {
								longAtPointerput(localSP, GIV(nilObj));
								goto l207;
							}
							longAtPointerput(localSP, (((localPrimIndex - 261) << 3) | 1));
						l207:	/* end internalQuickPrimitiveResponse */;
							goto l204;
						}
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						/* begin slowPrimitiveResponse */
						assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
						assert((remapBufferCount()) == 0);
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
						/* begin maybeRetryFailureDueToForwarding */
						if (GIV(primFailCode)
						 && (checkForAndFollowForwardedPrimitiveState())) {
							/* begin initPrimCall */
							GIV(primFailCode) = 0;
							dispatchFunctionPointer(primitiveFunctionPointer);
						}
						/* begin maybeFailForLastObjectOverwrite */
						if (checkAllocFiller) {
							if (((freeStart()) < GIV(scavengeThreshold))
							 && ((longAt(freeStart())) != (freeStart()))) {
								GIV(primFailCode) = PrimErrWritePastObject;
							}
						}
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod));
						}
						succeeded = !GIV(primFailCode);
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							browserPluginReturnIfNeeded();
							goto l204;
						}
					}
					/* begin internalActivateNewMethod */
					assert(isCompiledMethod(GIV(newMethod)));
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
					assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

					/* could new rcvr be set at point of send? */
					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(!(isOopForwarded(rcvr)));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localIP);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localFP);
					localFP = localSP;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
					/* begin setMethod:methodHeader: */
					GIV(method) = GIV(newMethod);
					assert(isOopCompiledMethod(GIV(method)));
					assert((methodHeaderOf(GIV(method))) == methodHeader);
					GIV(bytecodeSetSelector) = ((((int) methodHeader)) < 0
						? 256
						: 0);

					/* begin internalPush: */
					object = (VMBIGENDIAN
						? ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
						: ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)) + (0)) + (0));
					longAtPointerput((localSP -= BytesPerOop), object);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					}
					localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
					if (methodHeader & AlternateHeaderHasPrimFlag) {

						/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
						   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
						localIP += 3;
						if (GIV(primFailCode) != 0) {
							if ((byteAt(localIP + 1)) == (((((int) methodHeader)) < 0
																? AltLongStoreBytecode
																: LongStoreBytecode))) {
								/* begin getErrorObjectFromPrimFailCode */
								if (GIV(primFailCode) > 0) {
									table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
									if (GIV(primFailCode) <= (numSlotsOf(table))) {
										errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
										goto l205;
									}
								}
								errorCode = ((GIV(primFailCode) << 3) | 1);
							l205:	/* end getErrorObjectFromPrimFailCode */;
								longAtPointerput(localSP, errorCode);
							}
							GIV(primFailCode) = 0;
						}
					}
					assert((frameNumArgs(localFP)) == GIV(argumentCount));
					assert(!(frameIsBlockActivation(localFP)));
					assert(!(frameHasContext(localFP)));
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
					}
				l204:	/* end internalExecuteNewMethod */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
			}
			break;
		case 132:
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				char *callerFP;
				sqInt index1;
				sqInt litVar;
				sqInt litVar1;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt objOop;
				sqInt onCurrentPage;
				sqInt opType;
				sqInt rcvr;
				sqInt rcvr1;
				sqInt referent;
				sqInt referent1;
				sqInt senderOop;
				sqInt senderOop1;
				char *spouseFP;
				char * theFP;
				StackPage * thePage;
				char *theSP;
				sqInt top;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)(byte3 + LiteralStart)) << (shiftForWord())));
					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l9;
				}
				if (opType == 1) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)(byte3 + LiteralStart)) << (shiftForWord())));
					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l9;
				}
				if (opType == 2) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					/* begin pushMaybeContextReceiverVariable: */
					rcvr = longAt(localFP + FoxReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						assert(byte3 < MethodIndex);
						assert(isContext(rcvr));
						if (!(((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))) {
							object1 = longAt((rcvr + BaseHeaderSize) + (((long)byte3) << (shiftForWord())));
							goto l13;
						}
						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (isWidowedContext(rcvr)) {
							object1 = longAt((rcvr + BaseHeaderSize) + (((long)byte3) << (shiftForWord())));
							goto l13;
						}
						/* begin frameOfMarriedContext: */
						senderOop = longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop) & 7) == 1));
						spouseFP = pointerForOop(senderOop - 1);
						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */
								object1 = longAt(spouseFP + FoxCallerContext);
								goto l13;
							}
							/* begin ensureFrameIsMarried:SP: */
							assert(!(isBaseFrame(spouseFP)));
							theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((spouseFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
							if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(callerFP)));
								object1 = longAt(callerFP + FoxThisContext);
								goto l13;
							}
							object1 = marryFrameSP(callerFP, theSP);
							goto l13;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(rcvr)));
							object1 = (((stackPointerIndexForFrame(spouseFP)) << 3) | 1);
							goto l13;
						}
						if (byte3 == InstructionPointerIndex) {
							object1 = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
							goto l13;
						}
						error("bad index");
						object1 = 0;
					l13:	/* end instVar:ofContext: */;
						longAtPointerput((localSP -= BytesPerOop), object1);
					}
					else {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), longAt((rcvr + BaseHeaderSize) + (((long)byte3) << (shiftForWord()))));
					}
					goto l9;
				}
				if (opType == 3) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + (((long)(byte3 + LiteralStart)) << (shiftForWord())));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l9;
				}
				if (opType == 4) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					/* begin pushLiteralVariable: */
					
					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar1 = longAt((GIV(method) + BaseHeaderSize) + (((long)(byte3 + LiteralStart)) << (shiftForWord())));
					if (((longAt(litVar1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar1));
						referent1 = longAt((litVar1 + BaseHeaderSize) + (0LL << (shiftForWord())));
						while (((referent1 & (tagMask())) == 0)
						 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
						}
						litVar1 = referent1;
					}
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar1 + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord()))));

					goto l9;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((long)(byte3 + LiteralStart)) << (shiftForWord())));
					if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar));
						referent = longAt((litVar + BaseHeaderSize) + (0LL << (shiftForWord())));
						while (((referent & (tagMask())) == 0)
						 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
						}
						litVar = referent;
					}
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(litVar))));
					if (((((usqInt) (longAt(litVar))) >> 23) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), top);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((ValueIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l11;
					}

#          endif /* IMMUTABILITY */

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */
						if (((top & (tagMask())) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())), top);
				l11:	/* end storeLiteralVariable:withValue: */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l9;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				rcvr1 = longAt(localFP + FoxReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((longAt(rcvr1)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && (((((longAt((rcvr1 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(rcvr1));
					assert(!((isObjImmutable(rcvr1))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((((longAt((rcvr1 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
						 && (!(isWidowedContext(rcvr1))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(rcvr1)));
						if (isOldObject(rcvr1)) {

							/* most stores into young objects */
							if (((top & (tagMask())) == 0)
							 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(rcvr1))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(rcvr1);
								}
							}
						}
						longAtput((rcvr1 + BaseHeaderSize) + (((long)byte3) << (shiftForWord())), top);
						if (byte3 == StackPointerIndex) {
						}
						goto l12;
					}
					/* begin frameOfMarriedContext: */
					senderOop1 = longAt((rcvr1 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop1) & 7) == 1));
					theFP = pointerForOop(senderOop1 - 1);
					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l12;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, rcvr1);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr1)));
					if (isOldObject(rcvr1)) {

						/* most stores into young objects */
						if (((top & (tagMask())) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr1))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr1);
							}
						}
					}
					longAtput((rcvr1 + BaseHeaderSize) + (((long)byte3) << (shiftForWord())), top);
					if (byte3 == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l12:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(rcvr1))));
					if (((((usqInt) (longAt(rcvr1))) >> 23) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), rcvr1);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), top);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((byte3 + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l10;
					}

#          endif /* IMMUTABILITY */

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr1)));
					if (isOldObject(rcvr1)) {

						/* most stores into young objects */
						if (((top & (tagMask())) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr1))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr1);
							}
						}
					}
					longAtput((rcvr1 + BaseHeaderSize) + (((long)byte3) << (shiftForWord())), top);
				l10:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
		l9:	/* end case */;
			break;
		case 133:
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto superclassSend */
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt aValue;
				sqInt classPointer;
				sqInt err;
				sqInt err1;
				sqInt hash;
				sqInt hash1;
				sqInt objOop;
				sqInt objOop1;
				sqInt referent;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin superclassOf: */
				classPointer = methodClassOf(GIV(method));
				/* begin followField:ofObject: */
				objOop = longAt((classPointer + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
				if (((objOop & (tagMask())) == 0)
				 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop);
				}
				superclass = objOop;
				/* begin ensureBehaviorHash: */
				assert(addressCouldBeClassObj(superclass));
				if (((hash = (long32At(superclass + 4)) & (identityHashHalfWordMask()))) != 0) {
				}
				else {
					if (objCouldBeClassObj(superclass)) {
						if (((err = enterIntoClassTable(superclass))) != 0) {
							-err;
						}
						else {
							(long32At(superclass + 4)) & (identityHashHalfWordMask());
						}
					}
					else {
						-PrimErrBadReceiver;
					}
				}
				/* begin classTagForClass: */
				assert(addressCouldBeClassObj(superclass));
				/* begin ensureBehaviorHash: */
				assert(addressCouldBeClassObj(superclass));
				GIV(lkupClassTag) = (((hash1 = (long32At(superclass + 4)) & (identityHashHalfWordMask()))) != 0
					? hash1
					: (objCouldBeClassObj(superclass)
							? (((err1 = enterIntoClassTable(superclass))) != 0
									? -err1
									: (long32At(superclass + 4)) & (identityHashHalfWordMask()))
							: -PrimErrBadReceiver));
				/* begin ensureReceiverUnforwarded */
				if ((((longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop))) & (tagMask())) == 0)
				 && (((longAt(longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					/* begin internalStackValue:put: */
					objOop1 = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(isUnambiguouslyForwarder(objOop1));
					referent = longAt((objOop1 + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					aValue = referent;
					longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), aValue);
				}
				assert(GIV(lkupClassTag) != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 134:
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)((descriptor & 0x3F) + LiteralStart)) << (shiftForWord())));
				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
			break;
		case 135:
		case 476: /*220*/
			/* popStackBytecode */
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 136:
		case 475: /*219*/
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 137:
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l14;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l14:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			break;
		case 138:
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				usqInt newObj;
				usqInt numBytes;
				sqInt popValues;
				sqInt size;

				VM_LABEL(pushNewArrayBytecode);
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((size >= 0)
				 && (ClassArrayCompactIndex != 0));
				assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(size < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((size < 1
	? 8
	: size * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						array = 0;
						goto l15;
					}
				}
				long64Atput(newObj, ((((long)(((usqLong) size))) << (numSlotsFullShift())) + (2LL << (formatShift()))) + ClassArrayCompactIndex);
				GIV(freeStart) += numBytes;
				array = newObj;
			l15:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + BaseHeaderSize) + (((long)i) << (shiftForWord())), longAtPointer(localSP + (((size - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 139:
			/* callPrimitiveBytecode */
			{
				sqInt header;

				VM_LABEL(callPrimitiveBytecode);
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(method)));
				header = longAt((GIV(method) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				if ((header & AlternateHeaderHasPrimFlag)
				 && ((((sqInt)localIP)) == ((GIV(method) + ((LiteralStart + (literalCountOfMethodHeader(header))) * BytesPerOop)) + BaseHeaderSize))) {
					localIP = (localIP + (3)) - 1;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l16;
				}
				else {
					goto respondToUnknownBytecode;
					goto l16;
				}

			}
		l16:	/* end case */;
			break;
		case 140:
		case 506: /*250*/
			/* pushRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((tempVector + BaseHeaderSize) + (((long)remoteTempIndex) << (shiftForWord()))));
			}
			break;
		case 141:
		case 507: /*251*/
			/* storeRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(tempVector)));
				if (isOldObject(tempVector)) {

					/* most stores into young objects */
					if ((((longAtPointer(localSP)) & (tagMask())) == 0)
					 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(tempVector))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(tempVector);
						}
					}
				}
				longAtput((tempVector + BaseHeaderSize) + (((long)remoteTempIndex) << (shiftForWord())), longAtPointer(localSP));
			}
			break;
		case 142:
		case 508: /*252*/
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(tempVector)));
				if (isOldObject(tempVector)) {

					/* most stores into young objects */
					if ((((longAtPointer(localSP)) & (tagMask())) == 0)
					 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(tempVector))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(tempVector);
						}
					}
				}
				longAtput((tempVector + BaseHeaderSize) + (((long)remoteTempIndex) << (shiftForWord())), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 143:
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt classObj;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				sqInt knownClassIndex;
				sqInt newClosure;
				sqInt newClosure1;
				usqInt newObj;
				usqInt newObj1;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				usqInt numBytes;
				usqInt numBytes1;
				sqInt numCopied;
				sqInt numSlots;
				sqInt numSlots1;
				sqInt objFormat;
				sqInt objFormat1;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */
				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = ((long)(byteAtPointer(++localIP))) << 8;
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l18;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
			l18:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				objFormat = indexablePointersFormat();
				numSlots = ClosureFirstCopiedValueIndex + numCopied;
				assert((numSlots >= 0)
				 && (ClassBlockClosureCompactIndex != 0));
				assert(((objFormat < (firstByteFormat())
					? objFormat
					: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l19;
					}
				}
				long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + ClassBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
			l19:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureStartPCIndex) << (shiftForWord())), ((initialIP << 3) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureNumArgsIndex) << (shiftForWord())), ((numArgs << 3) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(newClosure)));
						longAtput((newClosure + BaseHeaderSize) + (((long)(i + ClosureFirstCopiedValueIndex)) << (shiftForWord())), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 144:
		case 448: /*192*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				/* begin jump: */
				offset = 1 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 145:
		case 449: /*193*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				/* begin jump: */
				offset = 2 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 146:
		case 450: /*194*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				/* begin jump: */
				offset = 3 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 147:
		case 451: /*195*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				/* begin jump: */
				offset = 4 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 148:
		case 452: /*196*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				/* begin jump: */
				offset = 5 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 149:
		case 453: /*197*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				/* begin jump: */
				offset = 6 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 150:
		case 454: /*198*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				/* begin jump: */
				offset = 7 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 151:
		case 455: /*199*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				/* begin jump: */
				offset = 8 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 152:
		case 153:
		case 154:
		case 155:
		case 156:
		case 157:
		case 158:
		case 159:
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorMustBeBoolean) << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l20;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l20:	/* end jumplfFalseBy: */;
			}
			break;
		case 160:
		case 161:
		case 162:
		case 163:
		case 164:
		case 165:
		case 166:
		case 167:
			/* longUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 168:
		case 169:
		case 170:
		case 171:
			/* longJumpIfTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorMustBeBoolean) << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l21;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l21:	/* end jumplfTrueBy: */;
			}
			break;
		case 172:
		case 173:
		case 174:
		case 175:
			/* longJumpIfFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorMustBeBoolean) << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l22;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l22:	/* end jumplfFalseBy: */;
			}
			break;
		case 176:
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					result = ((rcvr >> 3)) + ((arg >> 3));
					if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 3) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l23;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
							bits = rot;
							rcvr1 = (((double *) ((&bits))))[0];
							goto l24;
						}
						if ((tagBits == 1)
						 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l24;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
							rcvr1 = result1;
							goto l24;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l24:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
							bits1 = rot1;
							arg1 = (((double *) ((&bits1))))[0];
							goto l25;
						}
						if ((tagBits1 == 1)
						 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l25;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result2);
							arg1 = result2;
							goto l25;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l25:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l23;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(0 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l23:	/* end case */;
			break;
		case 177:
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					result = ((rcvr >> 3)) - ((arg >> 3));
					if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 3) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l26;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
							bits = rot;
							rcvr1 = (((double *) ((&bits))))[0];
							goto l27;
						}
						if ((tagBits == 1)
						 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l27;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
							rcvr1 = result1;
							goto l27;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l27:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
							bits1 = rot1;
							arg1 = (((double *) ((&bits1))))[0];
							goto l28;
						}
						if ((tagBits1 == 1)
						 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l28;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result2);
							arg1 = result2;
							goto l28;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l28:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l26;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(1 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l26:	/* end case */;
			break;
		case 178:
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l29;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l30;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l30;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l30;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l30:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l31;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l31;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l31;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l31:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l29;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(2 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l29:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l208;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l208;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */
						offset = (((long)(bytecode - 168)) << 8) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

						goto l208;
					}
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l208:	/* end case */;
			break;
		case 179:
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l32;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l33;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l33;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l33;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l33:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l34;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l34;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l34;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l34:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l32;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(3 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l32:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

					goto l209;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

					goto l209;
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l209:	/* end case */;
			break;
		case 180:
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l35;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l36;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l36;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l36;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l36:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l37;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l37;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l37;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l37:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l35;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(4 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l35:	/* end case */;
			break;
		case 181:
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l38;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l39;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l39;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l39;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l39:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l40;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l40;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l40;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l40:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l38;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(5 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l38:	/* end case */;
			break;
		case 182:
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l41;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l42;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l42;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l42;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l42:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l43;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l43;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l43;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l43:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l41;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(6 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l41:	/* end case */;
			break;
		case 183:
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l44;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l45;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l45;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l45;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l45:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l46;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l46;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l46;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l46:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l44;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(7 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l44:	/* end case */;
			break;
		case 184:
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					result = rcvr * arg;
					if ((arg == 0)
					 || (((result / arg) == rcvr)
					 && ((((((usqInt) result) >> 60) + 1) & 15) <= 1))) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 3) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l47;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
							bits = rot;
							rcvr1 = (((double *) ((&bits))))[0];
							goto l48;
						}
						if ((tagBits == 1)
						 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l48;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
							rcvr1 = result1;
							goto l48;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l48:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
							bits1 = rot1;
							arg1 = (((double *) ((&bits1))))[0];
							goto l49;
						}
						if ((tagBits1 == 1)
						 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l49;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result2);
							arg1 = result2;
							goto l49;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l49:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l47;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(8 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l47:	/* end case */;
			break;
		case 185:
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */
						result = rcvr / arg;
						if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 3) | 1));
							/* begin fetchNextBytecode */
							currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

							goto l50;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
							bits = rot;
							rcvr1 = (((double *) ((&bits))))[0];
							goto l51;
						}
						if ((tagBits == 1)
						 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l51;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
							rcvr1 = result1;
							goto l51;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l51:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
							bits1 = rot1;
							arg1 = (((double *) ((&bits1))))[0];
							goto l52;
						}
						if ((tagBits1 == 1)
						 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l52;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result2);
							arg1 = result2;
							goto l52;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l52:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l50;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(9 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l50:	/* end case */;
			break;
		case 186:
			/* bytecodePrimMod */
			{
				sqInt mod;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((mod << 3) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l53;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(10 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l53:	/* end case */;
			break;
		case 187:
			/* bytecodePrimMakePoint */
			{
				VM_LABEL(bytecodePrimMakePoint);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveMakePoint();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l54;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(11 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l54:	/* end case */;
			break;
		case 188:
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt shifted;
				char *sp;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((((integerArgument) & 7) == 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l57;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = signed64BitValueOf(integerReceiver);

				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 3))) >= 0) {

						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 61)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l57;
						}
						shifted = ((long)integerReceiver) << integerArgument;
						if (!(integerReceiver == (((sqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l57;
						}
					}
					else {

						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-61))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l57;
						}
						shifted = ((sqInt) integerReceiver) >> (0 - integerArgument);
					}
					shifted = ((((((usqInt) shifted) >> 60) + 1) & 15) <= 1
						? ((shifted << 3) | 1)
						: signed64BitIntegerFor(shifted));

					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
			l57:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l55;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(12 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l55:	/* end case */;
			break;
		case 189:
			/* bytecodePrimDiv */
			{
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((quotient << 3) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l58;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(13 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l58:	/* end case */;
			break;
		case 190:
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l59;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l59;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(14 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l59:	/* end case */;
			break;
		case 191:
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l60;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l60;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(15 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l60:	/* end case */;
			break;
		case 192:
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt index1;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots21;
				usqInt numSlots3;
				usqInt numSlots31;
				usqInt numSlots4;
				sqInt objOop;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				sqInt result1;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;

				VM_LABEL(bytecodePrimAt);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && ((((index) & 7) == 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */
					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						GIV(lkupClassTag) = (longAt(rcvr)) & (classIndexMask());
						/* begin fetchPointer:ofObject: */
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(16 * 2)) << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag)))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l61;
						}
						if (primitiveFunctionPointer == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = long64At(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt1 = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
							if (((fmt1 >= (firstShortFormat())) && (fmt1 <= ((firstByteFormat()) - 1)))) {
								/* begin primitiveFail */
								if (!GIV(primFailCode)) {
									GIV(primFailCode) = 1;
								}
								goto l69;
							}
							if ((fmt1 == (indexablePointersFormat()))
							 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l69;
							}
							/* begin lengthOf:format: */
							numSlots3 = byteAt(rcvr + 7);
							numSlots1 = (numSlots3 == (numSlotsMask())
								? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
								: numSlots3);
							if (fmt1 <= 5) {
								totalLength = numSlots1;
								goto l70;
							}
							if (fmt1 >= (firstByteFormat())) {

								/* bytes, including CompiledMethod */
								totalLength = (((long)numSlots1) << (shiftForWord())) - (fmt1 & 7);
								goto l70;
							}
							if (fmt1 >= (firstShortFormat())) {
								totalLength = (((long)numSlots1) << ((shiftForWord()) - 1)) - (fmt1 & 3);
								goto l70;
							}
							if (fmt1 >= (firstLongFormat())) {
								totalLength = (((long)numSlots1) << ((shiftForWord()) - 2)) - (fmt1 & 1);
								goto l70;
							}
							if (fmt1 == (sixtyFourBitIndexableFormat())) {
								totalLength = numSlots1;
								goto l70;
							}
							totalLength = 0;
						l70:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt1 >= (sixtyFourBitIndexableFormat()))
							 || (fmt1 == 2)) {
								fixedFields1 = 0;
								goto l67;
							}
							if (fmt1 < 2) {
								fixedFields1 = totalLength;
								goto l67;
							}
							class = fetchClassOfNonImm(rcvr);
							/* begin fixedFieldsOfClassFormat: */
							fixedFields1 = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						l67:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt1;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields1);
						l69:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr1 = long64At(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt2 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
								if (((fmt2 >= (firstShortFormat())) && (fmt2 <= ((firstByteFormat()) - 1)))) {
									/* begin primitiveFail */
									if (!GIV(primFailCode)) {
										GIV(primFailCode) = 1;
									}
									goto l65;
								}
								/* begin lengthOf:format: */
								numSlots21 = byteAt(rcvr + 7);
								numSlots4 = (numSlots21 == (numSlotsMask())
									? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
									: numSlots21);
								if (fmt2 <= 5) {
									totalLength1 = numSlots4;
									goto l62;
								}
								if (fmt2 >= (firstByteFormat())) {

									/* bytes, including CompiledMethod */
									totalLength1 = (((long)numSlots4) << (shiftForWord())) - (fmt2 & 7);
									goto l62;
								}
								if (fmt2 >= (firstShortFormat())) {
									totalLength1 = (((long)numSlots4) << ((shiftForWord()) - 1)) - (fmt2 & 3);
									goto l62;
								}
								if (fmt2 >= (firstLongFormat())) {
									totalLength1 = (((long)numSlots4) << ((shiftForWord()) - 2)) - (fmt2 & 1);
									goto l62;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat())) {
									totalLength1 = numSlots4;
									goto l62;
								}
								totalLength1 = 0;
							l62:	/* end lengthOf:format: */;
								fixedFields2 = 0;

								/* special flag for strings */
								fmt2 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt2;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields2;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields2);
							l65:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l61;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						index1 = (index >> 3);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1))
						 && (oopisLessThanOrEqualTo(index1, stSize))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + BaseHeaderSize) + (((long)((index1 + fixedFields) - 1)) << (shiftForWord())));
								goto l64;
							}
							if (fmt < (firstByteFormat())) {

								/* Bitmap */
								result1 = long32At((rcvr + BaseHeaderSize) + (((long)(index1 - 1)) << 2));
								/* begin positive32BitIntegerFor: */
								result = (((result1 & 0xFFFFFFFFULL) << 3) | 1);
								goto l64;

							}
							if (fmt >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* String */
								/* Spur supports the String at:[put:] primitives on WideString */
								if ((fmt - 32) < (firstByteFormat())) {
									result1 = long32At((rcvr + BaseHeaderSize) + (((long)(index1 - 1)) << 2));
								}
								else {
									result1 = byteAt((rcvr + BaseHeaderSize) + (index1 - 1));
								}
								result = (((long)result1) << (numTagBits())) + (characterTag());

								goto l64;
							}
							else {
								if ((fmt < (firstCompiledMethodFormat()))
								 || (index1 >= ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((byteAt((rcvr + BaseHeaderSize) + (index1 - 1))) << 3) | 1);
									goto l64;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
					l64:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l61;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(16 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l61:	/* end case */;
			break;
		case 193:
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt correctRcvr;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt isCharacter;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots21;
				usqInt numSlots3;
				usqInt numSlots31;
				usqInt numSlots4;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;
				sqInt valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				
#        if IMMUTABILITY
				correctRcvr = ((rcvr & (tagMask())) == 0)
				 && (!(((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0));

#        else /* IMMUTABILITY */
				correctRcvr = (rcvr & (tagMask())) == 0;

#        endif /* IMMUTABILITY */

				if (correctRcvr
				 && ((((index) & 7) == 1))) {

					/* Index into atPutCache */
					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						GIV(lkupClassTag) = (longAt(rcvr)) & (classIndexMask());
						/* begin fetchPointer:ofObject: */
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(17 * 2)) << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag)))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l71;
						}
						if (primitiveFunctionPointer == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = long64At(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt1 = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
							if (((fmt1 >= (firstShortFormat())) && (fmt1 <= ((firstByteFormat()) - 1)))) {
								/* begin primitiveFail */
								if (!GIV(primFailCode)) {
									GIV(primFailCode) = 1;
								}
								goto l79;
							}
							if ((fmt1 == (indexablePointersFormat()))
							 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l79;
							}
							/* begin lengthOf:format: */
							numSlots3 = byteAt(rcvr + 7);
							numSlots1 = (numSlots3 == (numSlotsMask())
								? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
								: numSlots3);
							if (fmt1 <= 5) {
								totalLength = numSlots1;
								goto l80;
							}
							if (fmt1 >= (firstByteFormat())) {

								/* bytes, including CompiledMethod */
								totalLength = (((long)numSlots1) << (shiftForWord())) - (fmt1 & 7);
								goto l80;
							}
							if (fmt1 >= (firstShortFormat())) {
								totalLength = (((long)numSlots1) << ((shiftForWord()) - 1)) - (fmt1 & 3);
								goto l80;
							}
							if (fmt1 >= (firstLongFormat())) {
								totalLength = (((long)numSlots1) << ((shiftForWord()) - 2)) - (fmt1 & 1);
								goto l80;
							}
							if (fmt1 == (sixtyFourBitIndexableFormat())) {
								totalLength = numSlots1;
								goto l80;
							}
							totalLength = 0;
						l80:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt1 >= (sixtyFourBitIndexableFormat()))
							 || (fmt1 == 2)) {
								fixedFields1 = 0;
								goto l77;
							}
							if (fmt1 < 2) {
								fixedFields1 = totalLength;
								goto l77;
							}
							class = fetchClassOfNonImm(rcvr);
							/* begin fixedFieldsOfClassFormat: */
							fixedFields1 = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						l77:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt1;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields1);
						l79:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr1 = long64At(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt2 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
								if (((fmt2 >= (firstShortFormat())) && (fmt2 <= ((firstByteFormat()) - 1)))) {
									/* begin primitiveFail */
									if (!GIV(primFailCode)) {
										GIV(primFailCode) = 1;
									}
									goto l75;
								}
								/* begin lengthOf:format: */
								numSlots21 = byteAt(rcvr + 7);
								numSlots4 = (numSlots21 == (numSlotsMask())
									? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
									: numSlots21);
								if (fmt2 <= 5) {
									totalLength1 = numSlots4;
									goto l72;
								}
								if (fmt2 >= (firstByteFormat())) {

									/* bytes, including CompiledMethod */
									totalLength1 = (((long)numSlots4) << (shiftForWord())) - (fmt2 & 7);
									goto l72;
								}
								if (fmt2 >= (firstShortFormat())) {
									totalLength1 = (((long)numSlots4) << ((shiftForWord()) - 1)) - (fmt2 & 3);
									goto l72;
								}
								if (fmt2 >= (firstLongFormat())) {
									totalLength1 = (((long)numSlots4) << ((shiftForWord()) - 2)) - (fmt2 & 1);
									goto l72;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat())) {
									totalLength1 = numSlots4;
									goto l72;
								}
								totalLength1 = 0;
							l72:	/* end lengthOf:format: */;
								fixedFields2 = 0;

								/* special flag for strings */
								fmt2 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt2;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields2;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields2);
							l75:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l71;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo((index >> 3), 1))
						 && (oopisLessThanOrEqualTo((index >> 3), stSize))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								assert(!(isForwarded(rcvr)));
								if (isOldObject(rcvr)) {

									/* most stores into young objects */
									if (((value & (tagMask())) == 0)
									 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
											remember(rcvr);
										}
									}
								}
								longAtput((rcvr + BaseHeaderSize) + (((long)((((index >> 3)) + fixedFields) - 1)) << (shiftForWord())), value);
								goto l74;
							}
							if (fmt < (firstByteFormat())) {

								/* Bitmap */
								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									long32Atput((rcvr + BaseHeaderSize) + (((long)(((index >> 3)) - 1)) << 2), valToPut);
									goto l74;
								}
								GIV(primFailCode) = PrimErrBadArgument;
								goto l74;
							}
							if (fmt >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								isCharacter = (value & (tagMask())) == 2;
								if (!isCharacter) {
									GIV(primFailCode) = PrimErrBadArgument;
									goto l74;
								}
								valToPut = ((usqInt) (((usqInt)value))) >> (numTagBits());

								if ((fmt - 32) < (firstByteFormat())) {
									long32Atput((rcvr + BaseHeaderSize) + (((long)(((index >> 3)) - 1)) << 2), valToPut);
									goto l74;
								}
							}
							else {
								if ((fmt >= (firstCompiledMethodFormat()))
								 && (((index >> 3)) < ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									GIV(primFailCode) = PrimErrBadIndex;
									goto l74;
								}
								valToPut = ((((value) & 7) == 1)
									? (value >> 3)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								GIV(primFailCode) = PrimErrBadArgument;
								goto l74;
							}
							byteAtput((rcvr + BaseHeaderSize) + (((index >> 3)) - 1), valToPut);
							goto l74;
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
					l74:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l71;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(17 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
		l71:	/* end case */;
			break;
		case 194:
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt fmt;
				sqInt fmt1;
				sqInt isArray;
				sqInt isString;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				sqInt rcvr;
				sqInt sz;

				VM_LABEL(bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isString = 0;
					goto l82;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l82;

			l82:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf:format: */
					fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots1 = byteAt(rcvr + 7);
					numSlots = (numSlots1 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
						: numSlots1);
					if (fmt <= 5) {
						sz = numSlots;
						goto l83;
					}
					if (fmt >= (firstByteFormat())) {

						/* bytes, including CompiledMethod */
						sz = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
						goto l83;
					}
					if (fmt >= (firstShortFormat())) {
						sz = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
						goto l83;
					}
					if (fmt >= (firstLongFormat())) {
						sz = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
						goto l83;
					}
					if (fmt == (sixtyFourBitIndexableFormat())) {
						sz = numSlots;
						goto l83;
					}
					sz = 0;
				l83:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 3) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l81;
				}
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isArray = 0;
					goto l84;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex1 = (longAt(rcvr)) & (classIndexMask());
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l84;

			l84:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf:format: */
					fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots11 = byteAt(rcvr + 7);
					numSlots2 = (numSlots11 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
						: numSlots11);
					if (fmt1 <= 5) {
						sz = numSlots2;
						goto l85;
					}
					if (fmt1 >= (firstByteFormat())) {

						/* bytes, including CompiledMethod */
						sz = (((long)numSlots2) << (shiftForWord())) - (fmt1 & 7);
						goto l85;
					}
					if (fmt1 >= (firstShortFormat())) {
						sz = (((long)numSlots2) << ((shiftForWord()) - 1)) - (fmt1 & 3);
						goto l85;
					}
					if (fmt1 >= (firstLongFormat())) {
						sz = (((long)numSlots2) << ((shiftForWord()) - 2)) - (fmt1 & 1);
						goto l85;
					}
					if (fmt1 == (sixtyFourBitIndexableFormat())) {
						sz = numSlots2;
						goto l85;
					}
					sz = 0;
				l85:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 3) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l81;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(18 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l81:	/* end case */;
			break;
		case 195:
		case 355: /*99*/
			/* bytecodePrimNext */
			{
				VM_LABEL(bytecodePrimNext);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(19 * 2)) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((19 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord()))))) >> 3);
				goto normalSend;
			}
			break;
		case 196:
		case 356: /*100*/
			/* bytecodePrimNextPut */
			{
				VM_LABEL(bytecodePrimNextPut);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(20 * 2)) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((20 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord()))))) >> 3);
				goto normalSend;
			}
			break;
		case 197:
		case 357: /*101*/
			/* bytecodePrimAtEnd */
			{
				VM_LABEL(bytecodePrimAtEnd);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(21 * 2)) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((21 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord()))))) >> 3);
				goto normalSend;
			}
			break;
		case 198:
			/* bytecodePrimIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 199:
		case 359: /*103*/
			/* bytecodePrimClass */
			{
				sqInt aValue;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				if (((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				/* begin internalStackTopPut: */
				aValue = (((tagBits = rcvr & (tagMask()))) != 0
					? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
					: fetchClassOfNonImm(rcvr));
				longAtPointerput(localSP, aValue);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 200:
		case 360: /*104*/
			/* bytecodePrimSpecialSelector24 */
			{
				VM_LABEL(bytecodePrimSpecialSelector24);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(24 * 2)) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((24 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord()))))) >> 3);
				goto normalSend;
			}
			break;
		case 201:
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isBlock = 0;
					goto l87;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l87;

			l87:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l86;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(25 * 2)) << (shiftForWord())));
				goto normalSend;
			}
		l86:	/* end case */;
			break;
		case 202:
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isBlock = 0;
					goto l89;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l89;

			l89:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l88;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(26 * 2)) << (shiftForWord())));
				goto normalSend;
			}
		l88:	/* end case */;
			break;
		case 203:
		case 363: /*107*/
			/* bytecodePrimDo */
			{
				VM_LABEL(bytecodePrimDo);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(27 * 2)) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((27 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord()))))) >> 3);
				goto normalSend;
			}
			break;
		case 204:
		case 364: /*108*/
			/* bytecodePrimNew */
			{
				VM_LABEL(bytecodePrimNew);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(28 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 205:
		case 365: /*109*/
			/* bytecodePrimNewWithArg */
			{
				VM_LABEL(bytecodePrimNewWithArg);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(29 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			break;
		case 206:
			/* bytecodePrimPointX */
			{
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & (tagMask())) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((long)XIndex) << (shiftForWord()))));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l90;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(30 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l90:	/* end case */;
			break;
		case 207:
			/* bytecodePrimPointY */
			{
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & (tagMask())) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((long)YIndex) << (shiftForWord()))));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l91;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(0x1F * 2)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l91:	/* end case */;
			break;
		case 208:
		case 209:
		case 210:
		case 211:
		case 212:
		case 213:
		case 214:
		case 215:
		case 216:
		case 217:
		case 218:
		case 219:
		case 220:
		case 221:
		case 222:
		case 223:
		case 368: /*112*/
		case 369: /*113*/
		case 370: /*114*/
		case 371: /*115*/
		case 372: /*116*/
		case 373: /*117*/
		case 374: /*118*/
		case 375: /*119*/
		case 376: /*120*/
		case 377: /*121*/
		case 378: /*122*/
		case 379: /*123*/
		case 380: /*124*/
		case 381: /*125*/
		case 382: /*126*/
		case 383: /*127*/
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector0ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)((currentBytecode & 15) + LiteralStart)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				rcvr = longAtPointer(localSP + (0 * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				assert(GIV(lkupClassTag) != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 224:
		case 225:
		case 226:
		case 227:
		case 228:
		case 229:
		case 230:
		case 231:
		case 232:
		case 233:
		case 234:
		case 235:
		case 236:
		case 237:
		case 238:
		case 239:
		case 384: /*128*/
		case 385: /*129*/
		case 386: /*130*/
		case 387: /*131*/
		case 388: /*132*/
		case 389: /*133*/
		case 390: /*134*/
		case 391: /*135*/
		case 392: /*136*/
		case 393: /*137*/
		case 394: /*138*/
		case 395: /*139*/
		case 396: /*140*/
		case 397: /*141*/
		case 398: /*142*/
		case 399: /*143*/
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector1ArgBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)((currentBytecode & 15) + LiteralStart)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				assert(GIV(lkupClassTag) != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 240:
		case 241:
		case 242:
		case 243:
		case 244:
		case 245:
		case 246:
		case 247:
		case 248:
		case 249:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
		case 255:
		case 400: /*144*/
		case 401: /*145*/
		case 402: /*146*/
		case 403: /*147*/
		case 404: /*148*/
		case 405: /*149*/
		case 406: /*150*/
		case 407: /*151*/
		case 408: /*152*/
		case 409: /*153*/
		case 410: /*154*/
		case 411: /*155*/
		case 412: /*156*/
		case 413: /*157*/
		case 414: /*158*/
		case 415: /*159*/
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector2ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)((currentBytecode & 15) + LiteralStart)) << (shiftForWord())));
				GIV(argumentCount) = 2;
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				assert(GIV(lkupClassTag) != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 333: /*77*/
			/* extPushPseudoVariableOrOuterBytecode */
			{
				sqInt context;
				sqInt thing;

				VM_LABEL(extPushPseudoVariableOrOuterBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				
				switch (extB) {
				case 0:
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
					goto l92;

					break;
				case 1:
					thing = GIV(trueObj);

					break;
				case 2:
					thing = GIV(nilObj);

					break;
				case 3:
					/* begin ensureFrameIsMarried:SP: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						context = longAt(localFP + FoxThisContext);
						goto l93;
					}
					context = marryFrameSP(localFP, localSP);
				l93:	/* end ensureFrameIsMarried:SP: */;
					thing = context;

					break;
				default:
					thing = (extB < 0
						? enclosingObjectAtwithObjectwithMixin(0 - extB, longAt(localFP + FoxReceiver), methodClassOf(GIV(method)))
						: (error("undefined extension for extPushPseudoVariableOrOuter"),
							GIV(nilObj)));

				}
				extB = 0;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), thing);
			}
		l92:	/* end case */;
			break;
		case 336: /*80*/
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimAdd1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					result = ((rcvr >> 3)) + ((arg >> 3));
					if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 3) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l94;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
							bits = rot;
							rcvr1 = (((double *) ((&bits))))[0];
							goto l95;
						}
						if ((tagBits == 1)
						 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l95;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
							rcvr1 = result1;
							goto l95;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l95:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
							bits1 = rot1;
							arg1 = (((double *) ((&bits1))))[0];
							goto l96;
						}
						if ((tagBits1 == 1)
						 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l96;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result2);
							arg1 = result2;
							goto l96;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l96:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l94;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(0 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l94:	/* end case */;
			break;
		case 337: /*81*/
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimSubtract1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					result = ((rcvr >> 3)) - ((arg >> 3));
					if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 3) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l97;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
							bits = rot;
							rcvr1 = (((double *) ((&bits))))[0];
							goto l98;
						}
						if ((tagBits == 1)
						 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l98;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
							rcvr1 = result1;
							goto l98;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l98:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
							bits1 = rot1;
							arg1 = (((double *) ((&bits1))))[0];
							goto l99;
						}
						if ((tagBits1 == 1)
						 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l99;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result2);
							arg1 = result2;
							goto l99;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l99:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l97;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(1 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l97:	/* end case */;
			break;
		case 338: /*82*/
			/* bytecodePrimLessThanV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimLessThanV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatV4: */
					if (rcvr < arg) {
						/* goto booleanCheatTrueV4 */
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l100;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l101;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l101;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l101;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l101:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l102;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l102;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l102;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l102:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l100;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(2 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l100:	/* end case */;
			
		booleanCheatTrueV4:
			/* booleanCheatTrueV4 */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrueV4);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if (bytecode >= 208) {
					if (bytecode <= 215) {

						/* short jumpIfFalse 208 - 215 */
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l210;
					}
					if (bytecode == 244) {

						/* long jumpIfFalse */
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l210;
					}
					if (bytecode == 243) {

						/* long jumpIfTrue 243 */
						offset = byteAtPointer(++localIP);
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

						goto l210;
					}
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l210:	/* end case */;
			break;
		case 339: /*83*/
			/* bytecodePrimGreaterThanV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimGreaterThanV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatV4: */
					if (rcvr > arg) {
						goto booleanCheatTrueV4;
					}
					else {
						/* goto booleanCheatFalseV4 */
					}
					goto l103;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l104;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l104;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l104;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l104:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l105;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l105;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l105;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l105:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l103;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(3 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l103:	/* end case */;
			
		booleanCheatFalseV4:
			/* booleanCheatFalseV4 */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalseV4);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 216)
				 && (bytecode > 207)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 207)) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

					goto l211;
				}
				if (bytecode == 244) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

					goto l211;
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l211:	/* end case */;
			break;
		case 340: /*84*/
			/* bytecodePrimLessOrEqualV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimLessOrEqualV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatV4: */
					if (rcvr <= arg) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l106;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l107;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l107;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l107;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l107:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l108;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l108;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l108;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l108:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l106;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(4 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l106:	/* end case */;
			break;
		case 341: /*85*/
			/* bytecodePrimGreaterOrEqualV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimGreaterOrEqualV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatV4: */
					if (rcvr >= arg) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l109;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l110;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l110;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l110;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l110:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l111;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l111;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l111;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l111:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l109;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(5 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l109:	/* end case */;
			break;
		case 342: /*86*/
			/* bytecodePrimEqualV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimEqualV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					/* begin booleanCheatV4: */
					if (rcvr == arg) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l112;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l113;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l113;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l113;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l113:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l114;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l114;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l114;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l114:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l112;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(6 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l112:	/* end case */;
			break;
		case 343: /*87*/
			/* bytecodePrimNotEqualV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimNotEqualV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					/* begin booleanCheatV4: */
					if (rcvr != arg) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l115;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if (((tagBits = rcvr & (tagMask()))) != 0) {
					if (tagBits == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(rcvr));
						rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
						if (rot > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
						bits = rot;
						rcvr1 = (((double *) ((&bits))))[0];
						goto l116;
					}
					if ((tagBits == 1)
					 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
						rcvr1 = ((double) ((rcvr >> 3)) );
						goto l116;
					}
				}
				else {
					if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result);
						rcvr1 = result;
						goto l116;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l116:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if (((tagBits1 = arg & (tagMask()))) != 0) {
					if (tagBits1 == (smallFloatTag())) {
						/* begin smallFloatValueOf: */
						assert(isImmediateFloat(arg));
						rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
						if (rot1 > 1) {

							/* a.k.a. ~= +/-0.0 */
							rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
						}
						rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
						bits1 = rot1;
						arg1 = (((double *) ((&bits1))))[0];
						goto l117;
					}
					if ((tagBits1 == 1)
					 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
					(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
						arg1 = ((double) ((arg >> 3)) );
						goto l117;
					}
				}
				else {
					if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l117;
					}
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l117:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (!aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l115;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(7 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l115:	/* end case */;
			break;
		case 344: /*88*/
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimMultiply1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					result = rcvr * arg;
					if ((arg == 0)
					 || (((result / arg) == rcvr)
					 && ((((((usqInt) result) >> 60) + 1) & 15) <= 1))) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 3) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l118;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
							bits = rot;
							rcvr1 = (((double *) ((&bits))))[0];
							goto l119;
						}
						if ((tagBits == 1)
						 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l119;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
							rcvr1 = result1;
							goto l119;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l119:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
							bits1 = rot1;
							arg1 = (((double *) ((&bits1))))[0];
							goto l120;
						}
						if ((tagBits1 == 1)
						 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l120;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result2);
							arg1 = result2;
							goto l120;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l120:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l118;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(8 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l118:	/* end case */;
			break;
		case 345: /*89*/
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt bits;
				sqInt bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				sqInt rot;
				sqInt rot1;
				sqInt shift;
				sqInt shift1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(bytecodePrimDivide1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((((rcvr) & 7) == 1))
				 && ((((arg) & 7) == 1))) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */
						result = rcvr / arg;
						if ((((((usqInt) result) >> 60) + 1) & 15) <= 1) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 3) | 1));
							/* begin fetchNextBytecode */
							currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

							goto l121;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
							bits = rot;
							rcvr1 = (((double *) ((&bits))))[0];
							goto l122;
						}
						if ((tagBits == 1)
						 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)rcvr) << shift)) >> shift) == rcvr))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l122;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
							rcvr1 = result1;
							goto l122;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l122:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((usqInt) (((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {

								/* a.k.a. ~= +/-0.0 */
								rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
							}
							rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
							bits1 = rot1;
							arg1 = (((double *) ((&bits1))))[0];
							goto l123;
						}
						if ((tagBits1 == 1)
						 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
						(((sqInt) (((long)arg) << shift1)) >> shift1) == arg))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l123;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result2);
							arg1 = result2;
							goto l123;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l123:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l121;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(9 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l121:	/* end case */;
			break;
		case 346: /*90*/
			/* bytecodePrimMod */
			{
				sqInt mod;

				VM_LABEL(bytecodePrimMod1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((mod << 3) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l124;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(10 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l124:	/* end case */;
			break;
		case 347: /*91*/
			/* bytecodePrimMakePoint */
			{
				VM_LABEL(bytecodePrimMakePoint1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveMakePoint();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l125;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(11 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l125:	/* end case */;
			break;
		case 348: /*92*/
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt shifted;
				char *sp;

				VM_LABEL(bytecodePrimBitShift1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((((integerArgument) & 7) == 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l128;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = signed64BitValueOf(integerReceiver);

				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 3))) >= 0) {

						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 61)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l128;
						}
						shifted = ((long)integerReceiver) << integerArgument;
						if (!(integerReceiver == (((sqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l128;
						}
					}
					else {

						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-61))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l128;
						}
						shifted = ((sqInt) integerReceiver) >> (0 - integerArgument);
					}
					shifted = ((((((usqInt) shifted) >> 60) + 1) & 15) <= 1
						? ((shifted << 3) | 1)
						: signed64BitIntegerFor(shifted));

					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
			l128:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l126;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(12 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l126:	/* end case */;
			break;
		case 349: /*93*/
			/* bytecodePrimDiv */
			{
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((quotient << 3) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l129;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(13 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l129:	/* end case */;
			break;
		case 350: /*94*/
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd1);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l130;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l130;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(14 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l130:	/* end case */;
			break;
		case 351: /*95*/
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr1);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l131;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l131;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(15 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l131:	/* end case */;
			break;
		case 352: /*96*/
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt index1;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots21;
				usqInt numSlots3;
				usqInt numSlots31;
				usqInt numSlots4;
				sqInt objOop;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				sqInt result1;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;

				VM_LABEL(bytecodePrimAt1);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && ((((index) & 7) == 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */
					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						GIV(lkupClassTag) = (longAt(rcvr)) & (classIndexMask());
						/* begin fetchPointer:ofObject: */
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(16 * 2)) << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag)))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l132;
						}
						if (primitiveFunctionPointer == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = long64At(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt1 = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
							if (((fmt1 >= (firstShortFormat())) && (fmt1 <= ((firstByteFormat()) - 1)))) {
								/* begin primitiveFail */
								if (!GIV(primFailCode)) {
									GIV(primFailCode) = 1;
								}
								goto l140;
							}
							if ((fmt1 == (indexablePointersFormat()))
							 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l140;
							}
							/* begin lengthOf:format: */
							numSlots3 = byteAt(rcvr + 7);
							numSlots1 = (numSlots3 == (numSlotsMask())
								? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
								: numSlots3);
							if (fmt1 <= 5) {
								totalLength = numSlots1;
								goto l141;
							}
							if (fmt1 >= (firstByteFormat())) {

								/* bytes, including CompiledMethod */
								totalLength = (((long)numSlots1) << (shiftForWord())) - (fmt1 & 7);
								goto l141;
							}
							if (fmt1 >= (firstShortFormat())) {
								totalLength = (((long)numSlots1) << ((shiftForWord()) - 1)) - (fmt1 & 3);
								goto l141;
							}
							if (fmt1 >= (firstLongFormat())) {
								totalLength = (((long)numSlots1) << ((shiftForWord()) - 2)) - (fmt1 & 1);
								goto l141;
							}
							if (fmt1 == (sixtyFourBitIndexableFormat())) {
								totalLength = numSlots1;
								goto l141;
							}
							totalLength = 0;
						l141:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt1 >= (sixtyFourBitIndexableFormat()))
							 || (fmt1 == 2)) {
								fixedFields1 = 0;
								goto l138;
							}
							if (fmt1 < 2) {
								fixedFields1 = totalLength;
								goto l138;
							}
							class = fetchClassOfNonImm(rcvr);
							/* begin fixedFieldsOfClassFormat: */
							fixedFields1 = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						l138:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt1;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields1);
						l140:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr1 = long64At(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt2 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
								if (((fmt2 >= (firstShortFormat())) && (fmt2 <= ((firstByteFormat()) - 1)))) {
									/* begin primitiveFail */
									if (!GIV(primFailCode)) {
										GIV(primFailCode) = 1;
									}
									goto l136;
								}
								/* begin lengthOf:format: */
								numSlots21 = byteAt(rcvr + 7);
								numSlots4 = (numSlots21 == (numSlotsMask())
									? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
									: numSlots21);
								if (fmt2 <= 5) {
									totalLength1 = numSlots4;
									goto l133;
								}
								if (fmt2 >= (firstByteFormat())) {

									/* bytes, including CompiledMethod */
									totalLength1 = (((long)numSlots4) << (shiftForWord())) - (fmt2 & 7);
									goto l133;
								}
								if (fmt2 >= (firstShortFormat())) {
									totalLength1 = (((long)numSlots4) << ((shiftForWord()) - 1)) - (fmt2 & 3);
									goto l133;
								}
								if (fmt2 >= (firstLongFormat())) {
									totalLength1 = (((long)numSlots4) << ((shiftForWord()) - 2)) - (fmt2 & 1);
									goto l133;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat())) {
									totalLength1 = numSlots4;
									goto l133;
								}
								totalLength1 = 0;
							l133:	/* end lengthOf:format: */;
								fixedFields2 = 0;

								/* special flag for strings */
								fmt2 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt2;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields2;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields2);
							l136:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l132;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						index1 = (index >> 3);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1))
						 && (oopisLessThanOrEqualTo(index1, stSize))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + BaseHeaderSize) + (((long)((index1 + fixedFields) - 1)) << (shiftForWord())));
								goto l135;
							}
							if (fmt < (firstByteFormat())) {

								/* Bitmap */
								result1 = long32At((rcvr + BaseHeaderSize) + (((long)(index1 - 1)) << 2));
								/* begin positive32BitIntegerFor: */
								result = (((result1 & 0xFFFFFFFFULL) << 3) | 1);
								goto l135;

							}
							if (fmt >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* String */
								/* Spur supports the String at:[put:] primitives on WideString */
								if ((fmt - 32) < (firstByteFormat())) {
									result1 = long32At((rcvr + BaseHeaderSize) + (((long)(index1 - 1)) << 2));
								}
								else {
									result1 = byteAt((rcvr + BaseHeaderSize) + (index1 - 1));
								}
								result = (((long)result1) << (numTagBits())) + (characterTag());

								goto l135;
							}
							else {
								if ((fmt < (firstCompiledMethodFormat()))
								 || (index1 >= ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((byteAt((rcvr + BaseHeaderSize) + (index1 - 1))) << 3) | 1);
									goto l135;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
					l135:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l132;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(16 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l132:	/* end case */;
			break;
		case 353: /*97*/
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt correctRcvr;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt isCharacter;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots21;
				usqInt numSlots3;
				usqInt numSlots31;
				usqInt numSlots4;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;
				sqInt valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut1);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				
#        if IMMUTABILITY
				correctRcvr = ((rcvr & (tagMask())) == 0)
				 && (!(((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0));

#        else /* IMMUTABILITY */
				correctRcvr = (rcvr & (tagMask())) == 0;

#        endif /* IMMUTABILITY */

				if (correctRcvr
				 && ((((index) & 7) == 1))) {

					/* Index into atPutCache */
					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						GIV(lkupClassTag) = (longAt(rcvr)) & (classIndexMask());
						/* begin fetchPointer:ofObject: */
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(17 * 2)) << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag)))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l142;
						}
						if (primitiveFunctionPointer == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = long64At(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt1 = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
							if (((fmt1 >= (firstShortFormat())) && (fmt1 <= ((firstByteFormat()) - 1)))) {
								/* begin primitiveFail */
								if (!GIV(primFailCode)) {
									GIV(primFailCode) = 1;
								}
								goto l150;
							}
							if ((fmt1 == (indexablePointersFormat()))
							 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l150;
							}
							/* begin lengthOf:format: */
							numSlots3 = byteAt(rcvr + 7);
							numSlots1 = (numSlots3 == (numSlotsMask())
								? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
								: numSlots3);
							if (fmt1 <= 5) {
								totalLength = numSlots1;
								goto l151;
							}
							if (fmt1 >= (firstByteFormat())) {

								/* bytes, including CompiledMethod */
								totalLength = (((long)numSlots1) << (shiftForWord())) - (fmt1 & 7);
								goto l151;
							}
							if (fmt1 >= (firstShortFormat())) {
								totalLength = (((long)numSlots1) << ((shiftForWord()) - 1)) - (fmt1 & 3);
								goto l151;
							}
							if (fmt1 >= (firstLongFormat())) {
								totalLength = (((long)numSlots1) << ((shiftForWord()) - 2)) - (fmt1 & 1);
								goto l151;
							}
							if (fmt1 == (sixtyFourBitIndexableFormat())) {
								totalLength = numSlots1;
								goto l151;
							}
							totalLength = 0;
						l151:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt1 >= (sixtyFourBitIndexableFormat()))
							 || (fmt1 == 2)) {
								fixedFields1 = 0;
								goto l148;
							}
							if (fmt1 < 2) {
								fixedFields1 = totalLength;
								goto l148;
							}
							class = fetchClassOfNonImm(rcvr);
							/* begin fixedFieldsOfClassFormat: */
							fixedFields1 = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						l148:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt1;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields1);
						l150:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr1 = long64At(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt2 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
								if (((fmt2 >= (firstShortFormat())) && (fmt2 <= ((firstByteFormat()) - 1)))) {
									/* begin primitiveFail */
									if (!GIV(primFailCode)) {
										GIV(primFailCode) = 1;
									}
									goto l146;
								}
								/* begin lengthOf:format: */
								numSlots21 = byteAt(rcvr + 7);
								numSlots4 = (numSlots21 == (numSlotsMask())
									? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
									: numSlots21);
								if (fmt2 <= 5) {
									totalLength1 = numSlots4;
									goto l143;
								}
								if (fmt2 >= (firstByteFormat())) {

									/* bytes, including CompiledMethod */
									totalLength1 = (((long)numSlots4) << (shiftForWord())) - (fmt2 & 7);
									goto l143;
								}
								if (fmt2 >= (firstShortFormat())) {
									totalLength1 = (((long)numSlots4) << ((shiftForWord()) - 1)) - (fmt2 & 3);
									goto l143;
								}
								if (fmt2 >= (firstLongFormat())) {
									totalLength1 = (((long)numSlots4) << ((shiftForWord()) - 2)) - (fmt2 & 1);
									goto l143;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat())) {
									totalLength1 = numSlots4;
									goto l143;
								}
								totalLength1 = 0;
							l143:	/* end lengthOf:format: */;
								fixedFields2 = 0;

								/* special flag for strings */
								fmt2 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt2;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields2;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields2);
							l146:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l142;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo((index >> 3), 1))
						 && (oopisLessThanOrEqualTo((index >> 3), stSize))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								assert(!(isForwarded(rcvr)));
								if (isOldObject(rcvr)) {

									/* most stores into young objects */
									if (((value & (tagMask())) == 0)
									 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
											remember(rcvr);
										}
									}
								}
								longAtput((rcvr + BaseHeaderSize) + (((long)((((index >> 3)) + fixedFields) - 1)) << (shiftForWord())), value);
								goto l145;
							}
							if (fmt < (firstByteFormat())) {

								/* Bitmap */
								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									long32Atput((rcvr + BaseHeaderSize) + (((long)(((index >> 3)) - 1)) << 2), valToPut);
									goto l145;
								}
								GIV(primFailCode) = PrimErrBadArgument;
								goto l145;
							}
							if (fmt >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								isCharacter = (value & (tagMask())) == 2;
								if (!isCharacter) {
									GIV(primFailCode) = PrimErrBadArgument;
									goto l145;
								}
								valToPut = ((usqInt) (((usqInt)value))) >> (numTagBits());

								if ((fmt - 32) < (firstByteFormat())) {
									long32Atput((rcvr + BaseHeaderSize) + (((long)(((index >> 3)) - 1)) << 2), valToPut);
									goto l145;
								}
							}
							else {
								if ((fmt >= (firstCompiledMethodFormat()))
								 && (((index >> 3)) < ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									GIV(primFailCode) = PrimErrBadIndex;
									goto l145;
								}
								valToPut = ((((value) & 7) == 1)
									? (value >> 3)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								GIV(primFailCode) = PrimErrBadArgument;
								goto l145;
							}
							byteAtput((rcvr + BaseHeaderSize) + (((index >> 3)) - 1), valToPut);
							goto l145;
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
					l145:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l142;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(17 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
		l142:	/* end case */;
			break;
		case 354: /*98*/
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt fmt;
				sqInt fmt1;
				sqInt isArray;
				sqInt isString;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				sqInt rcvr;
				sqInt sz;

				VM_LABEL(bytecodePrimSize1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isString = 0;
					goto l153;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l153;

			l153:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf:format: */
					fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots1 = byteAt(rcvr + 7);
					numSlots = (numSlots1 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
						: numSlots1);
					if (fmt <= 5) {
						sz = numSlots;
						goto l154;
					}
					if (fmt >= (firstByteFormat())) {

						/* bytes, including CompiledMethod */
						sz = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
						goto l154;
					}
					if (fmt >= (firstShortFormat())) {
						sz = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
						goto l154;
					}
					if (fmt >= (firstLongFormat())) {
						sz = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
						goto l154;
					}
					if (fmt == (sixtyFourBitIndexableFormat())) {
						sz = numSlots;
						goto l154;
					}
					sz = 0;
				l154:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 3) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l152;
				}
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isArray = 0;
					goto l155;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex1 = (longAt(rcvr)) & (classIndexMask());
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l155;

			l155:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf:format: */
					fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots11 = byteAt(rcvr + 7);
					numSlots2 = (numSlots11 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
						: numSlots11);
					if (fmt1 <= 5) {
						sz = numSlots2;
						goto l156;
					}
					if (fmt1 >= (firstByteFormat())) {

						/* bytes, including CompiledMethod */
						sz = (((long)numSlots2) << (shiftForWord())) - (fmt1 & 7);
						goto l156;
					}
					if (fmt1 >= (firstShortFormat())) {
						sz = (((long)numSlots2) << ((shiftForWord()) - 1)) - (fmt1 & 3);
						goto l156;
					}
					if (fmt1 >= (firstLongFormat())) {
						sz = (((long)numSlots2) << ((shiftForWord()) - 2)) - (fmt1 & 1);
						goto l156;
					}
					if (fmt1 == (sixtyFourBitIndexableFormat())) {
						sz = numSlots2;
						goto l156;
					}
					sz = 0;
				l156:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 3) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l152;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(18 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l152:	/* end case */;
			break;
		case 358: /*102*/
			/* bytecodePrimIdenticalV4 */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdenticalV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				if (((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheatV4: */
				if (rcvr == arg) {
					goto booleanCheatTrueV4;
				}
				else {
					goto booleanCheatFalseV4;
				}
			}
			break;
		case 361: /*105*/
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue1);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isBlock = 0;
					goto l158;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l158;

			l158:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l157;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(25 * 2)) << (shiftForWord())));
				goto normalSend;
			}
		l157:	/* end case */;
			break;
		case 362: /*106*/
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isBlock = 0;
					goto l160;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l160;

			l160:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l159;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(26 * 2)) << (shiftForWord())));
				goto normalSend;
			}
		l159:	/* end case */;
			break;
		case 366: /*110*/
			/* bytecodePrimPointX */
			{
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & (tagMask())) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((long)XIndex) << (shiftForWord()))));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l161;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(30 * 2)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l161:	/* end case */;
			break;
		case 367: /*111*/
			/* bytecodePrimPointY */
			{
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & (tagMask())) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((long)YIndex) << (shiftForWord()))));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l162;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(0x1F * 2)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l162:	/* end case */;
			break;
		case 416: /*160*/
		case 417: /*161*/
		case 418: /*162*/
		case 419: /*163*/
		case 420: /*164*/
		case 421: /*165*/
		case 422: /*166*/
		case 423: /*167*/
		case 424: /*168*/
		case 425: /*169*/
		case 426: /*170*/
		case 427: /*171*/
		case 428: /*172*/
		case 429: /*173*/
		case 430: /*174*/
		case 431: /*175*/
			/* sendAbsentImplicit0ArgsBytecode */
			{
				VM_LABEL(sendAbsentImplicit0ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)((currentBytecode & 15) + LiteralStart)) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto commonSendImplicitReceiver;
			}
			break;
		case 432: /*176*/
		case 433: /*177*/
		case 434: /*178*/
		case 435: /*179*/
		case 436: /*180*/
		case 437: /*181*/
		case 438: /*182*/
		case 439: /*183*/
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode1);
				rcvr = longAt(localFP + FoxReceiver);
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
				
#        if IMMUTABILITY
				assert(!((isImmediate(rcvr))));
				if (((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), top);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), (((instVarIndex + 1) << 3) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l163;
				}

#        endif /* IMMUTABILITY */

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				if (isOldObject(rcvr)) {

					/* most stores into young objects */
					if (((top & (tagMask())) == 0)
					 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(rcvr);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((long)instVarIndex) << (shiftForWord())), top);
			l163:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 456: /*200*/
		case 457: /*201*/
		case 458: /*202*/
		case 459: /*203*/
		case 460: /*204*/
		case 461: /*205*/
		case 462: /*206*/
		case 463: /*207*/
			/* shortConditionalJumpTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpTrue);
				/* begin jumplfTrueBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorMustBeBoolean) << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l164;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l164:	/* end jumplfTrueBy: */;
			}
			break;
		case 464: /*208*/
		case 465: /*209*/
		case 466: /*210*/
		case 467: /*211*/
		case 468: /*212*/
		case 469: /*213*/
		case 470: /*214*/
		case 471: /*215*/
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse1);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorMustBeBoolean) << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l165;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l165:	/* end jumplfFalseBy: */;
			}
			break;
		case 472: /*216*/
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver1);
				localReturnValue = longAt(localFP + FoxReceiver);
				goto commonReturn;
			}
			break;
		case 474: /*218*/
			/* extReturnTopFromBlock */
			{
				VM_LABEL(extReturnTopFromBlock);
				if (extA == 0) {
					localReturnValue = longAtPointer(localSP);
					goto commonCallerReturn;
					goto l166;
				}
				error("shouldBeImplemented");
				extA = 0;
			}
		l166:	/* end case */;
			break;
		case 477: /*221*/
			/* extNopBytecode */
			{
				VM_LABEL(extNopBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = (extB = 0);
			}
			break;
		case 478: /*222*/
		case 479: /*223*/
		case 502: /*246*/
		case 503: /*247*/
		case 504: /*248*/
		case 511: /*255*/
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			break;
		case 480: /*224*/
			/* extABytecode */
			{
				VM_LABEL(extABytecode);
				extA = (((usqInt) extA << 8)) + (byteAtPointer(++localIP));
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 481: /*225*/
			/* extBBytecode */
			{
				sqInt byte;

				VM_LABEL(extBBytecode);
				byte = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extB = ((extB == 0)
				 && (byte > 0x7F)
					? byte - 256
					: (((usqInt) extB << 8)) + byte);
			}
			break;
		case 482: /*226*/
			/* extPushReceiverVariableBytecode */
			{
				char *callerFP;
				sqInt index;
				sqInt object;
				sqInt rcvr;
				sqInt senderOop;
				char *spouseFP;
				char *theSP;

				VM_LABEL(extPushReceiverVariableBytecode);
				index = (byteAtPointer(++localIP)) + (((long)extA) << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin pushMaybeContextReceiverVariable: */
				rcvr = longAt(localFP + FoxReceiver);
				if ((index <= StackPointerIndex)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
					/* begin internalPush: */
					assert(index < MethodIndex);
					assert(isContext(rcvr));
					if (!(((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))) {
						object = longAt((rcvr + BaseHeaderSize) + (((long)index) << (shiftForWord())));
						goto l167;
					}
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (isWidowedContext(rcvr)) {
						object = longAt((rcvr + BaseHeaderSize) + (((long)index) << (shiftForWord())));
						goto l167;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop) & 7) == 1));
					spouseFP = pointerForOop(senderOop - 1);
					if (index == SenderIndex) {
						/* begin ensureCallerContext: */
						callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
						if (callerFP == 0) {

							/* base frame, context in saved ip slot (or base of stack in Cog) */
							object = longAt(spouseFP + FoxCallerContext);
							goto l167;
						}
						/* begin ensureFrameIsMarried:SP: */
						assert(!(isBaseFrame(spouseFP)));
						theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((spouseFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
						if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(callerFP)));
							object = longAt(callerFP + FoxThisContext);
							goto l167;
						}
						object = marryFrameSP(callerFP, theSP);
						goto l167;
					}
					if (index == StackPointerIndex) {
						assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(rcvr)));
						object = (((stackPointerIndexForFrame(spouseFP)) << 3) | 1);
						goto l167;
					}
					if (index == InstructionPointerIndex) {
						object = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
						goto l167;
					}
					error("bad index");
					object = 0;
				l167:	/* end instVar:ofContext: */;
					longAtPointerput((localSP -= BytesPerOop), object);
				}
				else {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((rcvr + BaseHeaderSize) + (((long)index) << (shiftForWord()))));
				}
			}
			break;
		case 483: /*227*/
			/* extPushLiteralVariableBytecode */
			{
				sqInt index;
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(extPushLiteralVariableBytecode);
				index = (byteAtPointer(++localIP)) + (((long)extA) << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + (((long)(index + LiteralStart)) << (shiftForWord())));
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord()))));

			}
			break;
		case 484: /*228*/
			/* extPushLiteralBytecode */
			{
				sqInt index;
				sqInt object;

				VM_LABEL(extPushLiteralBytecode);
				index = (byteAtPointer(++localIP)) + (((long)extA) << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((long)(index + LiteralStart)) << (shiftForWord())));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 485: /*229*/
			/* extPushIntegerBytecode */
			{
				sqInt value;

				VM_LABEL(extPushIntegerBytecode);
				value = (byteAtPointer(++localIP)) + (((long)extB) << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extB = 0;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ((value << 3) | 1));
			}
			break;
		case 486: /*230*/
			/* longPushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;
				sqInt object;

				VM_LABEL(longPushTemporaryVariableBytecode);
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				object = (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 487: /*231*/
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				usqInt newObj;
				usqInt numBytes;
				sqInt popValues;
				sqInt size;

				VM_LABEL(pushNewArrayBytecode1);
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((size >= 0)
				 && (ClassArrayCompactIndex != 0));
				assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(size < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((size < 1
	? 8
	: size * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						array = 0;
						goto l168;
					}
				}
				long64Atput(newObj, ((((long)(((usqLong) size))) << (numSlotsFullShift())) + (2LL << (formatShift()))) + ClassArrayCompactIndex);
				GIV(freeStart) += numBytes;
				array = newObj;
			l168:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + BaseHeaderSize) + (((long)i) << (shiftForWord())), longAtPointer(localSP + (((size - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 488: /*232*/
			/* extStoreReceiverVariableBytecode */
			{
				sqInt anObject;
				sqInt index1;
				sqInt onCurrentPage;
				sqInt rcvr;
				sqInt senderOop;
				char * theFP;
				StackPage * thePage;
				sqInt variableIndex;

				VM_LABEL(extStoreReceiverVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((long)extA) << 8);
				extA = 0;
				/* begin storeMaybeContextReceiverVariable:withValue: */
				anObject = longAtPointer(localSP);
				rcvr = longAt(localFP + FoxReceiver);
				if ((variableIndex <= ReceiverIndex)
				 && ((((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && (((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(rcvr));
					assert(!((isObjImmutable(rcvr))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
						 && (!(isWidowedContext(rcvr))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(rcvr)));
						if (isOldObject(rcvr)) {

							/* most stores into young objects */
							if (((anObject & (tagMask())) == 0)
							 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(rcvr);
								}
							}
						}
						longAtput((rcvr + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord())), anObject);
						if (variableIndex == StackPointerIndex) {
						}
						goto l170;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - 1);
					if (variableIndex == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, anObject);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l170;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, rcvr);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */
						if (((anObject & (tagMask())) == 0)
						 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord())), anObject);
					if (variableIndex == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l170:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(rcvr))));
					if (((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), rcvr);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), anObject);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((variableIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l169;
					}

#          endif /* IMMUTABILITY */

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */
						if (((anObject & (tagMask())) == 0)
						 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord())), anObject);
				l169:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 489: /*233*/
			/* extStoreLiteralVariableBytecode */
			{
				sqInt anObject;
				sqInt litVar;
				sqInt referent;
				sqInt variableIndex;

				VM_LABEL(extStoreLiteralVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((long)extA) << 8);
				extA = 0;
				/* begin storeLiteralVariable:withValue: */
				anObject = longAtPointer(localSP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + (((long)(variableIndex + LiteralStart)) << (shiftForWord())));
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					litVar = referent;
				}
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
				
#        if IMMUTABILITY
				assert(!((isImmediate(litVar))));
				if (((((usqInt) (longAt(litVar))) >> 23) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), litVar);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), anObject);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), (((ValueIndex + 1) << 3) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l171;
				}

#        endif /* IMMUTABILITY */

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(litVar)));
				if (isOldObject(litVar)) {

					/* most stores into young objects */
					if (((anObject & (tagMask())) == 0)
					 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(litVar);
						}
					}
				}
				longAtput((litVar + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())), anObject);
			l171:	/* end storeLiteralVariable:withValue: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 490: /*234*/
			/* longStoreTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;

				VM_LABEL(longStoreTemporaryVariableBytecode);
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
			}
			break;
		case 491: /*235*/
			/* extStoreAndPopReceiverVariableBytecode */
			{
				sqInt index1;
				sqInt onCurrentPage;
				sqInt rcvr;
				sqInt senderOop;
				char * theFP;
				StackPage * thePage;
				sqInt value;
				sqInt variableIndex;

				VM_LABEL(extStoreAndPopReceiverVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((long)extA) << 8);
				extA = 0;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storeMaybeContextReceiverVariable:withValue: */
				rcvr = longAt(localFP + FoxReceiver);
				if ((variableIndex <= ReceiverIndex)
				 && ((((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && (((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(rcvr));
					assert(!((isObjImmutable(rcvr))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
						 && (!(isWidowedContext(rcvr))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(rcvr)));
						if (isOldObject(rcvr)) {

							/* most stores into young objects */
							if (((value & (tagMask())) == 0)
							 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(rcvr);
								}
							}
						}
						longAtput((rcvr + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord())), value);
						if (variableIndex == StackPointerIndex) {
						}
						goto l173;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - 1);
					if (variableIndex == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, value);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l173;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, rcvr);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */
						if (((value & (tagMask())) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord())), value);
					if (variableIndex == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l173:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					
#          if IMMUTABILITY
					assert(!((isImmediate(rcvr))));
					if (((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), rcvr);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), value);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), (((variableIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
						GIV(argumentCount) = 2;
						goto normalSend;
						/* return self */
						goto l172;
					}

#          endif /* IMMUTABILITY */

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */
						if (((value & (tagMask())) == 0)
						 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (((long)variableIndex) << (shiftForWord())), value);
				l172:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 492: /*236*/
			/* extStoreAndPopLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt referent;
				sqInt value;
				sqInt variableIndex;

				VM_LABEL(extStoreAndPopLiteralVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((long)extA) << 8);
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				extA = 0;
				/* begin storeLiteralVariable:withValue: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + (((long)(variableIndex + LiteralStart)) << (shiftForWord())));
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					litVar = referent;
				}
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
				
#        if IMMUTABILITY
				assert(!((isImmediate(litVar))));
				if (((((usqInt) (longAt(litVar))) >> 23) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), litVar);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), value);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), (((ValueIndex + 1) << 3) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorAttemptToAssign) << (shiftForWord())));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l174;
				}

#        endif /* IMMUTABILITY */

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(litVar)));
				if (isOldObject(litVar)) {

					/* most stores into young objects */
					if (((value & (tagMask())) == 0)
					 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(litVar);
						}
					}
				}
				longAtput((litVar + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())), value);
			l174:	/* end storeLiteralVariable:withValue: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 493: /*237*/
			/* longStoreAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;

				VM_LABEL(longStoreAndPopTemporaryVariableBytecode);
				/* begin longStoreTemporaryVariableBytecode */
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 494: /*238*/
			/* extSendBytecode */
			{
				sqInt byte;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(extSendBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)(((((usqInt) byte) >> 3) + (((long)extA) << 5)) + LiteralStart)) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (((long)extB) << 3);
				extB = 0;
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				goto commonSendOrdinary;
			}
			break;
		case 495: /*239*/
			/* extSendSuperBytecode */
			{
				sqInt byte;

				VM_LABEL(extSendSuperBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)(((((usqInt) byte) >> 3) + (((long)extA) << 5)) + LiteralStart)) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (((long)extB) << 3);
				extB = 0;
				goto superclassSend;
			}
		l175:	/* end case */;
			break;
		case 496: /*240*/
			/* extSendAbsentImplicitBytecode */
			{
				sqInt byte;

				VM_LABEL(extSendAbsentImplicitBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)(((((usqInt) byte) >> 3) + (((long)extA) << 5)) + LiteralStart)) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (((long)extB) << 3);
				extB = 0;
				/* goto commonSendImplicitReceiver */
			}
			
		commonSendImplicitReceiver:
			/* commonSendImplicitReceiver */
			{
				sqInt actualLookupRule;
				sqInt candidateMixin;
				sqInt candidateMixinApplication;
				sqInt candidateReceiver;
				sqInt classTablePage;
				sqInt dictionary;
				sqInt errorCode;
				sqInt fieldIndex;
				sqInt fieldIndex1;
				sqInt found;
				sqInt hash;
				sqInt i;
				sqInt i1;
				sqInt index;
				usqInt length;
				sqInt localPrimIndex;
				usqInt mask;
				sqInt methodArray;
				sqInt methodHeader;
				sqInt methodReceiver;
				sqInt nArgs;
				sqInt nextSelector;
				usqInt numSlots;
				sqInt numTemps;
				sqInt object;
				sqInt objOop;
				sqInt objOop1;
				sqInt objOop11;
				sqInt objOop2;
				sqInt objOop3;
				sqInt objOop4;
				sqInt objOop5;
				sqInt oop;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;
				sqInt tagBits;
				sqInt tagBits1;
				sqInt tagBits2;
				sqInt wrapAround;

				VM_LABEL(commonSendImplicitReceiver);
				nArgs = 0;
				savedFramePointer = 0;
				savedStackPointer = 0;
				/* begin sendBreakpoint:receiver: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				/* begin internalFindNewMethodImplicitReceiver */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				assert(!((isOopForwarded(GIV(localAbsentReceiver)))));
				GIV(lkupClassTag) = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? tagBits
					: (longAt(GIV(localAbsentReceiver))) & (classIndexMask()));
				if (inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(GIV(messageSelector), GIV(lkupClassTag), GIV(method), LookupRuleImplicit)) {
					if (!(GIV(localAbsentReceiverOrZero) == 0)) {
						GIV(localAbsentReceiver) = GIV(localAbsentReceiverOrZero);
					}
				}
				else {

					/* entry was not found in the cache; look it up the hard way */
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
					 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
						if (((GIV(messageSelector) & (tagMask())) == 0)
						 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
							GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
						}
					}
					/* begin classAtIndex: */
					assert((GIV(lkupClassTag) <= (tagMask()))
					 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l213;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = GIV(lkupClassTag) & ((1LL << (classTableMajorIndexShift())) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
				l213:	/* end classAtIndex: */;
					/* begin lookupImplicitReceiverSend */
					GIV(messageSelector) = (((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))
						? noInlineFollowForwarded(GIV(messageSelector))
						: GIV(messageSelector));
					methodReceiver = longAt(localFP + FoxReceiver);
					candidateReceiver = methodReceiver;
					assert(!((isForwarded(GIV(method)))));
					candidateMixin = methodClassOf(GIV(method));
					GIV(localAbsentReceiverOrZero) = 0;
					while (1) {
						assert(!((isForwarded(candidateMixin))));
						assert(!((isForwarded(candidateReceiver))));
						candidateMixinApplication = findApplicationOfTargetMixinstartingAtBehavior(candidateMixin, (((tagBits2 = candidateReceiver & (tagMask()))) != 0
							? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits2) << (shiftForWord())))
							: fetchClassOfNonImm(candidateReceiver)));
						assert(!((candidateMixinApplication == 0)));
						assert(!((candidateMixinApplication == (nilObject()))));
						assert(!((isForwarded(candidateMixinApplication))));
						assert(addressCouldBeClassObj(candidateMixinApplication));
						/* begin followObjField:ofObject: */
						objOop = longAt((candidateMixinApplication + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
						assert(isNonImmediate(objOop));
						if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, candidateMixinApplication, objOop);
						}
						dictionary = objOop;
						/* begin lookupMethodInDictionary: */
						flag("endianness");
						assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
						numSlots = byteAt(dictionary + 7);
						length = (numSlots == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(dictionary - BaseHeaderSize))) << 8)))) >> 8
							: numSlots);

						/* Use linear search on small dictionaries; its cheaper.
						   Also the limit can be set to force linear search of all dictionaries, which supports the
						   booting of images that need rehashing (e.g. because a tracer has generated an image
						   with different hashes but hasn't rehashed it yet.) */
						mask = (length - SelectorStart) - 1;
						if (mask <= GIV(methodDictLinearSearchLimit)) {
							index = 0;
							while (index <= mask) {
								nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)(index + SelectorStart)) << (shiftForWord())));
								if (((nextSelector & (tagMask())) == 0)
								 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
									nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
								}
								if (nextSelector == GIV(messageSelector)) {
									/* begin followObjField:ofObject: */
									objOop5 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
									assert(isNonImmediate(objOop5));
									if (((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
										objOop5 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop5);
									}
									methodArray = objOop5;
									/* begin followField:ofObject: */
									objOop2 = longAt((methodArray + BaseHeaderSize) + (((long)index) << (shiftForWord())));
									if (((objOop2 & (tagMask())) == 0)
									 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
										objOop2 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop2);
									}
									GIV(newMethod) = objOop2;
									found = 1;
									goto l212;
								}
								index += 1;
							}
							found = 0;
							goto l212;
						}

						/* It is assumed that there are some nils in this dictionary, and search will
						   stop when one is encountered. However, if there are no nils, then wrapAround
						   will be detected the second time the loop gets to the end of the table. */
						index = SelectorStart + (mask & (((GIV(messageSelector) & (tagMask())) != 0
	? (GIV(messageSelector) >> 3)
	: (/* begin hashBitsOf: */
		(objOop3 = GIV(messageSelector)),
		(hash = (long32At(objOop3 + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(objOop3 + 4, ((((long32At(objOop3 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
						wrapAround = 0;
						while (1) {
							nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
							if (nextSelector == GIV(nilObj)) {
								found = 0;
								goto l212;
							}
							if (((nextSelector & (tagMask())) == 0)
							 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
								nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
							}
							if (nextSelector == GIV(messageSelector)) {
								/* begin followObjField:ofObject: */
								objOop11 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
								assert(isNonImmediate(objOop11));
								if (((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
									objOop11 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop11);
								}
								methodArray = objOop11;
								/* begin followField:ofObject: */
								objOop4 = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
								if (((objOop4 & (tagMask())) == 0)
								 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
									objOop4 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop4);
								}
								GIV(newMethod) = objOop4;
								found = 1;
								goto l212;
							}
							index += 1;
							if (index == length) {
								if (wrapAround) {
									found = 0;
									goto l212;
								}
								wrapAround = 1;
								index = SelectorStart;
							}
						}
						found = 0;
					l212:	/* end lookupMethodInDictionary: */;
						if (found) {
							GIV(localAbsentReceiver) = candidateReceiver;
							actualLookupRule = lookupLexicalfromrule(GIV(messageSelector), candidateMixin, LookupRuleImplicit);
							goto l215;
						}
						/* begin followObjField:ofObject: */
						objOop1 = longAt((candidateMixin + BaseHeaderSize) + (((long)EnclosingMixinIndex) << (shiftForWord())));
						assert(isNonImmediate(objOop1));
						if (((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop1 = fixFollowedFieldofObjectwithInitialValue(EnclosingMixinIndex, candidateMixin, objOop1);
						}
						candidateMixin = objOop1;
						assert(!((isForwarded(candidateMixin))));
						if (candidateMixin == GIV(nilObj)) break;
						GIV(localAbsentReceiverOrZero) = (candidateReceiver = followObjFieldofObject(EnclosingObjectIndex, candidateMixinApplication));
					}
					GIV(localAbsentReceiverOrZero) = 0;
					GIV(localAbsentReceiver) = methodReceiver;

					/* MNU lookup starts here. */
					GIV(lkupClass) = (((tagBits1 = methodReceiver & (tagMask()))) != 0
						? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits1) << (shiftForWord())))
						: fetchClassOfNonImm(methodReceiver));
					actualLookupRule = lookupProtectedstartingAtrule(GIV(messageSelector), GIV(lkupClass), LookupRuleImplicit);
				l215:	/* end lookupImplicitReceiverSend */;
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToNSCache(actualLookupRule);
				}
				/* begin shuffleArgumentsAndStoreAbsentReceiver: */

				/* a.k.a. self internalPush: anything */
				localSP -= BytesPerOop;
				for (i = 1; i <= GIV(argumentCount); i += 1) {
					oop = longAtPointer(localSP + (i * BytesPerOop));
					longAtPointerput(localSP + ((i - 1) * BytesPerOop), oop);
				}
				longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), GIV(localAbsentReceiver));
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((long)(localPrimIndex - 264)) << (shiftForWord()))));
							goto l217;
						}
						if (localPrimIndex == 256) {
							goto l217;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l217;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l217;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l217;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 3) | 1));
					l217:	/* end internalQuickPrimitiveResponse */;
						goto l214;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
					assert((remapBufferCount()) == 0);
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					/* begin maybeRetryFailureDueToForwarding */
					if (GIV(primFailCode)
					 && (checkForAndFollowForwardedPrimitiveState())) {
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
					}
					/* begin maybeFailForLastObjectOverwrite */
					if (checkAllocFiller) {
						if (((freeStart()) < GIV(scavengeThreshold))
						 && ((longAt(freeStart())) != (freeStart()))) {
							GIV(primFailCode) = PrimErrWritePastObject;
						}
					}
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l214;
					}
				}
				/* begin internalActivateNewMethod */
				assert(isCompiledMethod(GIV(newMethod)));
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
				assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

				/* could new rcvr be set at point of send? */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				assert(!(isOopForwarded(rcvr)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((methodHeaderOf(GIV(method))) == methodHeader);
				GIV(bytecodeSetSelector) = ((((int) methodHeader)) < 0
					? 256
					: 0);

				/* begin internalPush: */
				object = (VMBIGENDIAN
					? ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
					: ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)) + (0)) + (0));
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i1 = (GIV(argumentCount) + 1); i1 <= numTemps; i1 += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
				if (methodHeader & AlternateHeaderHasPrimFlag) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
					localIP += 3;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (((((int) methodHeader)) < 0
														? AltLongStoreBytecode
														: LongStoreBytecode))) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
								if (GIV(primFailCode) <= (numSlotsOf(table))) {
									errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
									goto l216;
								}
							}
							errorCode = ((GIV(primFailCode) << 3) | 1);
						l216:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l214:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 497: /*241*/
			/* extSendAbsentDynamicSuperBytecode */
			{
				sqInt byte;

				VM_LABEL(extSendAbsentDynamicSuperBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)(((((usqInt) byte) >> 3) + (((long)extA) << 5)) + LiteralStart)) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (((long)extB) << 3);
				extB = 0;
				/* goto commonSendDynamicSuper */
			}
			
		commonSendDynamicSuper:
			/* commonSendDynamicSuper */
			{
				sqInt actualLookupRule;
				sqInt classTablePage;
				sqInt errorCode;
				sqInt fieldIndex;
				sqInt fieldIndex1;
				sqInt hash1;
				sqInt i;
				sqInt i1;
				sqInt localPrimIndex;
				sqInt methodHeader;
				sqInt methodMixin;
				sqInt methodMixinApplication;
				sqInt nArgs;
				sqInt numTemps;
				sqInt object;
				sqInt objOop;
				sqInt oop;
				sqInt probe1;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(commonSendDynamicSuper);
				nArgs = 0;
				savedFramePointer = 0;
				savedStackPointer = 0;
				/* begin sendBreakpoint:receiver: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				/* begin internalFindNewMethodDynamicSuper */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				assert(!((isOopForwarded(GIV(localAbsentReceiver)))));
				GIV(lkupClassTag) = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? tagBits
					: (longAt(GIV(localAbsentReceiver))) & (classIndexMask()));
				hash1 = (GIV(messageSelector) ^ GIV(lkupClassTag)) ^ (GIV(method) ^ LookupRuleDynamicSuper);

				/* first probe */
				probe1 = hash1 & NSMethodCacheMask;
				if (((((GIV(nsMethodCache)[probe1 + NSMethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheClassTag]) == GIV(lkupClassTag)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheCallingMethod]) == GIV(method)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheDepthOrLookupRule]) == LookupRuleDynamicSuper)) {
					GIV(newMethod) = GIV(nsMethodCache)[probe1 + NSMethodCacheTargetMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe1 + NSMethodCachePrimFunction]));
					GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe1 + NSMethodCacheActualReceiver];
					goto l221;
				}

				/* second probe */
				probe1 = (((usqInt) hash1) >> 1) & NSMethodCacheMask;
				if (((((GIV(nsMethodCache)[probe1 + NSMethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheClassTag]) == GIV(lkupClassTag)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheCallingMethod]) == GIV(method)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheDepthOrLookupRule]) == LookupRuleDynamicSuper)) {
					GIV(newMethod) = GIV(nsMethodCache)[probe1 + NSMethodCacheTargetMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe1 + NSMethodCachePrimFunction]));
					GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe1 + NSMethodCacheActualReceiver];
					goto l221;
				}
				probe1 = (((usqInt) hash1) >> 2) & NSMethodCacheMask;
				if (((((GIV(nsMethodCache)[probe1 + NSMethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheClassTag]) == GIV(lkupClassTag)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheCallingMethod]) == GIV(method)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheDepthOrLookupRule]) == LookupRuleDynamicSuper)) {
					GIV(newMethod) = GIV(nsMethodCache)[probe1 + NSMethodCacheTargetMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe1 + NSMethodCachePrimFunction]));
					GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe1 + NSMethodCacheActualReceiver];
					goto l221;
				}
				/* end inlineLookupInNSMethodCacheSel:classTag:method:lookupRule:; fall through */
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				if ((((GIV(messageSelector) & (tagMask())) == 0)
				 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
				 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
					if (((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
					}
					if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
						GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
					}
				}
				/* begin classAtIndex: */
				assert((GIV(lkupClassTag) <= (tagMask()))
				 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
				/* begin fetchPointer:ofObject: */
				fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
				classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
				if (classTablePage == GIV(nilObj)) {
					GIV(lkupClass) = null;
					goto l218;
				}
				/* begin fetchPointer:ofObject: */
				fieldIndex1 = GIV(lkupClassTag) & ((1LL << (classTableMajorIndexShift())) - 1);
				GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
			l218:	/* end classAtIndex: */;
				/* begin lookupDynamicSuperSend */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				GIV(localAbsentReceiverOrZero) = 0;
				methodMixin = methodClassOf(GIV(method));
				methodMixinApplication = findApplicationOfTargetMixinstartingAtBehavior(methodMixin, (((tagBits1 = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits1) << (shiftForWord())))
					: fetchClassOfNonImm(GIV(localAbsentReceiver))));
				/* begin followField:ofObject: */
				objOop = longAt((methodMixinApplication + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
				if (((objOop & (tagMask())) == 0)
				 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, methodMixinApplication, objOop);
				}
				GIV(lkupClass) = objOop;
				actualLookupRule = lookupProtectedstartingAtrule(GIV(messageSelector), GIV(lkupClass), LookupRuleDynamicSuper);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				addNewMethodToNSCache(actualLookupRule);
			l221:	;

				/* begin shuffleArgumentsAndStoreAbsentReceiver: */

				/* a.k.a. self internalPush: anything */
				localSP -= BytesPerOop;
				for (i = 1; i <= GIV(argumentCount); i += 1) {
					oop = longAtPointer(localSP + (i * BytesPerOop));
					longAtPointerput(localSP + ((i - 1) * BytesPerOop), oop);
				}
				longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), GIV(localAbsentReceiver));
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((long)(localPrimIndex - 264)) << (shiftForWord()))));
							goto l222;
						}
						if (localPrimIndex == 256) {
							goto l222;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l222;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l222;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l222;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 3) | 1));
					l222:	/* end internalQuickPrimitiveResponse */;
						goto l220;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
					assert((remapBufferCount()) == 0);
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					/* begin maybeRetryFailureDueToForwarding */
					if (GIV(primFailCode)
					 && (checkForAndFollowForwardedPrimitiveState())) {
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
					}
					/* begin maybeFailForLastObjectOverwrite */
					if (checkAllocFiller) {
						if (((freeStart()) < GIV(scavengeThreshold))
						 && ((longAt(freeStart())) != (freeStart()))) {
							GIV(primFailCode) = PrimErrWritePastObject;
						}
					}
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l220;
					}
				}
				/* begin internalActivateNewMethod */
				assert(isCompiledMethod(GIV(newMethod)));
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
				assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

				/* could new rcvr be set at point of send? */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				assert(!(isOopForwarded(rcvr)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((methodHeaderOf(GIV(method))) == methodHeader);
				GIV(bytecodeSetSelector) = ((((int) methodHeader)) < 0
					? 256
					: 0);

				/* begin internalPush: */
				object = (VMBIGENDIAN
					? ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
					: ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)) + (0)) + (0));
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i1 = (GIV(argumentCount) + 1); i1 <= numTemps; i1 += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
				if (methodHeader & AlternateHeaderHasPrimFlag) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
					localIP += 3;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (((((int) methodHeader)) < 0
														? AltLongStoreBytecode
														: LongStoreBytecode))) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
								if (GIV(primFailCode) <= (numSlotsOf(table))) {
									errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
									goto l219;
								}
							}
							errorCode = ((GIV(primFailCode) << 3) | 1);
						l219:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l220:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 498: /*242*/
			/* extUnconditionalJump */
			{
				sqInt byte;
				sqInt offset;

				VM_LABEL(extUnconditionalJump);
				byte = byteAtPointer(++localIP);
				offset = byte + (((long)extB) << 8);
				extB = 0;
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 499: /*243*/
			/* extJumpIfTrue */
			{
				sqInt boolean;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extJumpIfTrue);
				byte = byteAtPointer(++localIP);
				offset = byte + (((long)extB) << 8);
				extB = 0;
				/* begin jumplfTrueBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorMustBeBoolean) << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l176;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l176:	/* end jumplfTrueBy: */;
			}
			break;
		case 500: /*244*/
			/* extJumpIfFalse */
			{
				sqInt boolean;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extJumpIfFalse);
				byte = byteAtPointer(++localIP);
				offset = byte + (((long)extB) << 8);
				extB = 0;
				/* begin jumplfFalseBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorMustBeBoolean) << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l177;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l177:	/* end jumplfFalseBy: */;
			}
			break;
		case 501: /*245*/
			/* extSendAbsentSelfBytecode */
			{
				sqInt actualLookupRule;
				sqInt byte;
				sqInt classTablePage;
				sqInt count;
				sqInt errorCode;
				sqInt fieldIndex;
				sqInt fieldIndex1;
				sqInt i;
				sqInt i1;
				sqInt localPrimIndex;
				sqInt methodHeader;
				sqInt mixinApplication;
				sqInt nArgs;
				sqInt numTemps;
				sqInt object;
				sqInt objOop;
				sqInt oop;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;
				sqInt tagBits;
				sqInt tagBits1;
				sqInt targetMixin;

				VM_LABEL(extSendAbsentSelfBytecode);
				nArgs = 0;
				savedFramePointer = 0;
				savedStackPointer = 0;
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)(((((usqInt) byte) >> 3) + (((long)extA) << 5)) + LiteralStart)) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (((long)extB) << 3);
				extB = 0;
				/* begin commonSendOuter: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				/* begin internalFindNewMethodOuter: */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				assert(!((isOopForwarded(GIV(localAbsentReceiver)))));
				GIV(lkupClassTag) = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? tagBits
					: (longAt(GIV(localAbsentReceiver))) & (classIndexMask()));
				if (inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(GIV(messageSelector), GIV(lkupClassTag), GIV(method), 0)) {
					if (!(GIV(localAbsentReceiverOrZero) == 0)) {
						GIV(localAbsentReceiver) = GIV(localAbsentReceiverOrZero);
					}
				}
				else {

					/* entry was not found in the cache; look it up the hard way */
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
					 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
						if (((GIV(messageSelector) & (tagMask())) == 0)
						 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
							GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
						}
					}
					/* begin classAtIndex: */
					assert((GIV(lkupClassTag) <= (tagMask()))
					 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l180;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = GIV(lkupClassTag) & ((1LL << (classTableMajorIndexShift())) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
				l180:	/* end classAtIndex: */;
					/* begin lookupOuterSend: */
					GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
					GIV(localAbsentReceiverOrZero) = 0;
					targetMixin = methodClassOf(GIV(method));
					count = 0;
					while (count < 0) {
						count += 1;
						mixinApplication = findApplicationOfTargetMixinstartingAtBehavior(targetMixin, (((tagBits1 = GIV(localAbsentReceiver) & (tagMask()))) != 0
							? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits1) << (shiftForWord())))
							: fetchClassOfNonImm(GIV(localAbsentReceiver))));
						GIV(localAbsentReceiverOrZero) = (GIV(localAbsentReceiver) = followObjFieldofObject(EnclosingObjectIndex, mixinApplication));
						/* begin followObjField:ofObject: */
						objOop = longAt((targetMixin + BaseHeaderSize) + (((long)EnclosingMixinIndex) << (shiftForWord())));
						assert(isNonImmediate(objOop));
						if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop = fixFollowedFieldofObjectwithInitialValue(EnclosingMixinIndex, targetMixin, objOop);
						}
						targetMixin = objOop;
					}
					actualLookupRule = lookupLexicalfromrule(GIV(messageSelector), targetMixin, 0);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToNSCache(actualLookupRule);
				}
				/* begin shuffleArgumentsAndStoreAbsentReceiver: */

				/* a.k.a. self internalPush: anything */
				localSP -= BytesPerOop;
				for (i = 1; i <= GIV(argumentCount); i += 1) {
					oop = longAtPointer(localSP + (i * BytesPerOop));
					longAtPointerput(localSP + ((i - 1) * BytesPerOop), oop);
				}
				longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), GIV(localAbsentReceiver));
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((long)(localPrimIndex - 264)) << (shiftForWord()))));
							goto l181;
						}
						if (localPrimIndex == 256) {
							goto l181;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l181;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l181;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l181;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 3) | 1));
					l181:	/* end internalQuickPrimitiveResponse */;
						goto l179;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
					assert((remapBufferCount()) == 0);
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					/* begin maybeRetryFailureDueToForwarding */
					if (GIV(primFailCode)
					 && (checkForAndFollowForwardedPrimitiveState())) {
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
					}
					/* begin maybeFailForLastObjectOverwrite */
					if (checkAllocFiller) {
						if (((freeStart()) < GIV(scavengeThreshold))
						 && ((longAt(freeStart())) != (freeStart()))) {
							GIV(primFailCode) = PrimErrWritePastObject;
						}
					}
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l179;
					}
				}
				/* begin internalActivateNewMethod */
				assert(isCompiledMethod(GIV(newMethod)));
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
				assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

				/* could new rcvr be set at point of send? */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				assert(!(isOopForwarded(rcvr)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((methodHeaderOf(GIV(method))) == methodHeader);
				GIV(bytecodeSetSelector) = ((((int) methodHeader)) < 0
					? 256
					: 0);

				/* begin internalPush: */
				object = (VMBIGENDIAN
					? ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
					: ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)) + (0)) + (0));
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i1 = (GIV(argumentCount) + 1); i1 <= numTemps; i1 += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
				if (methodHeader & AlternateHeaderHasPrimFlag) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
					localIP += 3;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (((((int) methodHeader)) < 0
														? AltLongStoreBytecode
														: LongStoreBytecode))) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
								if (GIV(primFailCode) <= (numSlotsOf(table))) {
									errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
									goto l178;
								}
							}
							errorCode = ((GIV(primFailCode) << 3) | 1);
						l178:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l179:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 505: /*249*/
			/* callPrimitiveBytecode */
			{
				sqInt header;

				VM_LABEL(callPrimitiveBytecode1);
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(method)));
				header = longAt((GIV(method) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				if ((header & AlternateHeaderHasPrimFlag)
				 && ((((sqInt)localIP)) == ((GIV(method) + ((LiteralStart + (literalCountOfMethodHeader(header))) * BytesPerOop)) + BaseHeaderSize))) {
					localIP = (localIP + (3)) - 1;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l182;
				}
				else {
					goto respondToUnknownBytecode;
					goto l182;
				}

			}
		l182:	/* end case */;
			break;
		case 509: /*253*/
			/* extPushClosureBytecode */
			{
				sqInt blockSize;
				sqInt byte;
				sqInt classObj;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				sqInt knownClassIndex;
				sqInt newClosure;
				sqInt newClosure1;
				usqInt newObj;
				usqInt newObj1;
				sqInt numArgs;
				usqInt numBytes;
				usqInt numBytes1;
				sqInt numCopied;
				sqInt numSlots;
				sqInt numSlots1;
				sqInt objFormat;
				sqInt objFormat1;

				VM_LABEL(extPushClosureBytecode);
				byte = byteAtPointer(++localIP);
				numArgs = (byte & 7) + ((extA % 16) * 8);
				numCopied = ((((usqInt) byte) >> 3) & 7) + ((extA / 16) * 8);
				extA = 0;
				blockSize = (byteAtPointer(++localIP)) + (((long)extB) << 8);
				extB = 0;
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l184;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
			l184:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				objFormat = indexablePointersFormat();
				numSlots = ClosureFirstCopiedValueIndex + numCopied;
				assert((numSlots >= 0)
				 && (ClassBlockClosureCompactIndex != 0));
				assert(((objFormat < (firstByteFormat())
					? objFormat
					: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l185;
					}
				}
				long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + ClassBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
			l185:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureStartPCIndex) << (shiftForWord())), ((initialIP << 3) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureNumArgsIndex) << (shiftForWord())), ((numArgs << 3) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(newClosure)));
						longAtput((newClosure + BaseHeaderSize) + (((long)(i + ClosureFirstCopiedValueIndex)) << (shiftForWord())), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 510: /*254*/
			/* extSendAbsentOuterBytecode */
			{
				sqInt actualLookupRule;
				sqInt byte;
				sqInt classTablePage;
				sqInt count;
				sqInt depth;
				sqInt errorCode;
				sqInt fieldIndex;
				sqInt fieldIndex1;
				sqInt i;
				sqInt i1;
				sqInt localPrimIndex;
				sqInt methodHeader;
				sqInt mixinApplication;
				sqInt nArgs;
				sqInt numTemps;
				sqInt object;
				sqInt objOop;
				sqInt oop;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;
				sqInt tagBits;
				sqInt tagBits1;
				sqInt targetMixin;

				VM_LABEL(extSendAbsentOuterBytecode);
				nArgs = 0;
				savedFramePointer = 0;
				savedStackPointer = 0;
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((long)(((((usqInt) byte) >> 3) + (((long)extA) << 5)) + LiteralStart)) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (((long)extB) << 3);
				extB = 0;
				depth = byteAtPointer(++localIP);
				/* begin commonSendOuter: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				/* begin internalFindNewMethodOuter: */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				assert(!((isOopForwarded(GIV(localAbsentReceiver)))));
				GIV(lkupClassTag) = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? tagBits
					: (longAt(GIV(localAbsentReceiver))) & (classIndexMask()));
				if (inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(GIV(messageSelector), GIV(lkupClassTag), GIV(method), depth)) {
					if (!(GIV(localAbsentReceiverOrZero) == 0)) {
						GIV(localAbsentReceiver) = GIV(localAbsentReceiverOrZero);
					}
				}
				else {

					/* entry was not found in the cache; look it up the hard way */
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
					 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
						if (((GIV(messageSelector) & (tagMask())) == 0)
						 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
							GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
						}
					}
					/* begin classAtIndex: */
					assert((GIV(lkupClassTag) <= (tagMask()))
					 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l188;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = GIV(lkupClassTag) & ((1LL << (classTableMajorIndexShift())) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
				l188:	/* end classAtIndex: */;
					/* begin lookupOuterSend: */
					GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
					GIV(localAbsentReceiverOrZero) = 0;
					targetMixin = methodClassOf(GIV(method));
					count = 0;
					while (count < depth) {
						count += 1;
						mixinApplication = findApplicationOfTargetMixinstartingAtBehavior(targetMixin, (((tagBits1 = GIV(localAbsentReceiver) & (tagMask()))) != 0
							? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits1) << (shiftForWord())))
							: fetchClassOfNonImm(GIV(localAbsentReceiver))));
						GIV(localAbsentReceiverOrZero) = (GIV(localAbsentReceiver) = followObjFieldofObject(EnclosingObjectIndex, mixinApplication));
						/* begin followObjField:ofObject: */
						objOop = longAt((targetMixin + BaseHeaderSize) + (((long)EnclosingMixinIndex) << (shiftForWord())));
						assert(isNonImmediate(objOop));
						if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop = fixFollowedFieldofObjectwithInitialValue(EnclosingMixinIndex, targetMixin, objOop);
						}
						targetMixin = objOop;
					}
					actualLookupRule = lookupLexicalfromrule(GIV(messageSelector), targetMixin, depth);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToNSCache(actualLookupRule);
				}
				/* begin shuffleArgumentsAndStoreAbsentReceiver: */

				/* a.k.a. self internalPush: anything */
				localSP -= BytesPerOop;
				for (i = 1; i <= GIV(argumentCount); i += 1) {
					oop = longAtPointer(localSP + (i * BytesPerOop));
					longAtPointerput(localSP + ((i - 1) * BytesPerOop), oop);
				}
				longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), GIV(localAbsentReceiver));
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((long)(localPrimIndex - 264)) << (shiftForWord()))));
							goto l189;
						}
						if (localPrimIndex == 256) {
							goto l189;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l189;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l189;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l189;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 3) | 1));
					l189:	/* end internalQuickPrimitiveResponse */;
						goto l187;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
					assert((remapBufferCount()) == 0);
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					/* begin maybeRetryFailureDueToForwarding */
					if (GIV(primFailCode)
					 && (checkForAndFollowForwardedPrimitiveState())) {
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
					}
					/* begin maybeFailForLastObjectOverwrite */
					if (checkAllocFiller) {
						if (((freeStart()) < GIV(scavengeThreshold))
						 && ((longAt(freeStart())) != (freeStart()))) {
							GIV(primFailCode) = PrimErrWritePastObject;
						}
					}
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l187;
					}
				}
				/* begin internalActivateNewMethod */
				assert(isCompiledMethod(GIV(newMethod)));
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
				assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

				/* could new rcvr be set at point of send? */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				assert(!(isOopForwarded(rcvr)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((methodHeaderOf(GIV(method))) == methodHeader);
				GIV(bytecodeSetSelector) = ((((int) methodHeader)) < 0
					? 256
					: 0);

				/* begin internalPush: */
				object = (VMBIGENDIAN
					? ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
					: ((1 + (((long)((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)) + (0)) + (0));
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i1 = (GIV(argumentCount) + 1); i1 <= numTemps; i1 += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
				if (methodHeader & AlternateHeaderHasPrimFlag) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
					localIP += 3;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (((((int) methodHeader)) < 0
														? AltLongStoreBytecode
														: LongStoreBytecode))) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
								if (GIV(primFailCode) <= (numSlotsOf(table))) {
									errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
									goto l186;
								}
							}
							errorCode = ((GIV(primFailCode) << 3) | 1);
						l186:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l187:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		}
	}

	/* undo the pre-increment of IP before returning */
	localIP -= 1;
	/* begin externalizeIPandSP */
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}


/*	For assert-checking */

	/* CogStackPage>>#addressIsInPage: */
static sqInt NoDbgRegParms
addressIsInPage(StackPage * self_in_addressIsInPage, char *address)
{
	return (((self_in_addressIsInPage->lastAddress)) < address)
	 && (address < ((self_in_addressIsInPage->baseAddress)));
}

	/* CogStackPage>>#isFree */
static sqInt NoDbgRegParms
isFree(StackPage * self_in_isFree)
{
	return ((self_in_isFree->baseFP)) == 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPageNoAssert: */
static void NoDbgRegParms
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return;
	}
	if ((((prev = (aPage->prevPage))->baseFP)) == 0) {
		return;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPage: */
static sqInt NoDbgRegParms
freeStackPage(StackPage *aPage)
{
	freeStackPageNoAssert(aPage);
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageNextMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#newStackPage */
static StackPage *
newStackPage(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *lruOrFree;

	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#pageListIsWellFormed */
static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page)))) {
			if (!(asserta((addressIsInPage(page, (page->baseFP)))
				 && (addressIsInPage(page, (page->headSP)))))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == (numStkPages())))) {
		ok = 0;
	}
	return ok;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

	/* CogStackPages>>#stackPageAt: */
static StackPage * NoDbgRegParms
stackPageAt(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages));
}


/*	<Integer> */

	/* CogStackPages>>#stackPageFor: */
static StackPage * NoDbgRegParms
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
	return stackPageAtpages(index, GIV(pages));
}

	/* CogStackPages>>#statAverageLivePagesWhenMapping */
static double
statAverageLivePagesWhenMapping(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((double) GIV(statPageCountWhenMappingSum) )) / GIV(statNumMaps);
}

	/* InterpreterPrimitives>>#canBeImmutable: */
#if IMMUTABILITY
static sqInt NoDbgRegParms
canBeImmutable(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt processLists;
    sqInt scheduler;

	assert(isNonImmediate(oop));
	if (((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		return 0;
	}
	if (((longAt(oop)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord())))))) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	processLists = longAt((scheduler + BaseHeaderSize) + (((long)ProcessListsIndex) << (shiftForWord())));
	if (oop == scheduler) {
		return 0;
	}
	if (oop == processLists) {
		return 0;
	}
	if ((classIndexOf(longAt((processLists + BaseHeaderSize) + (1LL << (shiftForWord()))))) == ((longAt(oop)) & (classIndexMask()))) {
		return 0;
	}
	if ((classIndexOf(longAt((scheduler + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord()))))) == ((longAt(oop)) & (classIndexMask()))) {
		return 0;
	}
	return 1;
}
#endif /* IMMUTABILITY */


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

	/* InterpreterPrimitives>>#cStringOrNullFor: */
char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    char *cString;
    sqInt fmt;
    sqInt isString;
    sqInt len;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & (tagMask())) != 0) {
		isString = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	isString = ClassByteStringCompactIndex == ccIndex;
	goto l2;

l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!isString) {
		if (oop != GIV(nilObj)) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		len = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		len = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		len = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		len = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		len = numSlots;
		goto l1;
	}
	len = 0;
l1:	/* end lengthOf:format: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!(cString)) {
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

	/* InterpreterPrimitives>>#failed */
sqInt
failed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

	/* InterpreterPrimitives>>#isNegativeIntegerValueOf: */
static sqInt NoDbgRegParms
isNegativeIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt ok;
    sqInt smallInt;

	if ((((oop) & 7) == 1)) {
		smallInt = (oop >> 3);
		return smallInt < 0;
	}
	if ((oop & (tagMask())) == 0) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & (classIndexMask());
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l1;

	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (ok) {
			return 0;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex1 = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
		goto l2;

	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (ok) {
			return 1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Return a Large Integer object for the given integer magnitude and sign */

	/* InterpreterPrimitives>>#magnitude64BitIntegerFor:neg: */
static sqInt NoDbgRegParms
magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    sqInt isSmall;
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt smallVal;
    sqInt sz;

	isSmall = (isNegative
		? magnitude <= ((MaxSmallInteger) + 1)
		: magnitude <= (MaxSmallInteger));
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return ((smallVal << 3) | 1);
	}
	if (isNegative) {
		/* begin knownClassAtIndex: */
		assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize()))));
		largeClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)ClassLargeNegativeIntegerCompactIndex) << (shiftForWord())));
	}
	else {
		/* begin knownClassAtIndex: */
		assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize()))));
		largeClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)ClassLargePositiveIntegerCompactIndex) << (shiftForWord())));
	}
	sz = 8;

	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	
#  if VMBIGENDIAN
	if (sz > 4) {
		byteAtput((newLargeInteger + BaseHeaderSize) + 7, (magnitude >> 56) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 6, (magnitude >> 48) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 5, (magnitude >> 40) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 4, (magnitude >> 32) & 0xFF);
	}
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (magnitude >> 24) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (magnitude >> 16) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (magnitude >> 8) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize), magnitude & 0xFF);

#  else /* VMBIGENDIAN */
	if (sz > 4) {
		long32Atput((newLargeInteger + BaseHeaderSize) + (1LL << 2), magnitude >> 32);
	}
	long32Atput((newLargeInteger + BaseHeaderSize) + (0LL << 2), magnitude);

#  endif /* VMBIGENDIAN */

	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#magnitude64BitValueOf: */
static usqLong NoDbgRegParms
magnitude64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt i;
    sqInt ok;
    sqInt smallIntValue;
    sqInt sz;
    usqLong value;

	if ((((oop) & 7) == 1)) {
		smallIntValue = (oop >> 3);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return ((usqLong) smallIntValue);
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = (((long)(numSlotsOf(oop))) << (shiftForWord())) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	value = byteAt((oop + BaseHeaderSize) + (sz - 1));
	for (i = (sz - 2); i >= 0; i += -1) {
		value = (((long)value) << 8) + (byteAt((oop + BaseHeaderSize) + i));
	}
	return value;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive32BitValueOf: */
usqInt
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt fmt;
    sqInt ok;
    sqInt sz;
    sqInt value;

	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
		if ((value < 0)
		 || ((((unsigned int) value)) != value)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = 0;
		}
		return value;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;

}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive64BitValueOf: */
usqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt fmt;
    sqInt i;
    sqInt ok;
    sqInt sz;
    usqLong value;

	if ((((oop) & 7) == 1)) {
		if (((oop >> 3)) < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return (oop >> 3);
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = (((long)(numSlotsOf(oop))) << (shiftForWord())) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	value = 0;
	for (i = 0; i < sz; i += 1) {
		value += ((long)(((usqLong) (byteAt((oop + BaseHeaderSize) + i))))) << (i * 8);
	}
	return value;
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */
/*	only two callers & one is primitiveNewWithArg */

	/* InterpreterPrimitives>>#positiveMachineIntegerValueOf: */
unsigned long
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt ok;
    sqInt value;

	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((long)(numSlotsOf(oop))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return 
#    if VMBIGENDIAN
			(((((((byteAt((oop + BaseHeaderSize))) + (((long)(byteAt((oop + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((oop + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((oop + BaseHeaderSize) + 3))) << 24)) + (((long)(byteAt((oop + BaseHeaderSize) + 4))) << 32)) + (((long)(byteAt((oop + BaseHeaderSize) + 5))) << 40)) + (((long)(byteAt((oop + BaseHeaderSize) + 6))) << 48)) + (((long)(byteAt((oop + BaseHeaderSize) + 7))) << 56)
#    else /* VMBIGENDIAN */
			long64At((oop + BaseHeaderSize) + (0LL << 3))
#    endif /* VMBIGENDIAN */
			;
	}
	else {
		return 
#    if VMBIGENDIAN
			(((byteAt((oop + BaseHeaderSize))) + (((long)(byteAt((oop + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((oop + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((oop + BaseHeaderSize) + 3))) << 24)
#    else /* VMBIGENDIAN */
			long32At((oop + BaseHeaderSize) + (0LL << 2))
#    endif /* VMBIGENDIAN */
			;
	}
}

	/* InterpreterPrimitives>>#primitiveAdd */
static void
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((((((usqInt) integerResult) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveAddLargeIntegers */
EXPORT(void)
primitiveAddLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative == bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

	/* InterpreterPrimitives>>#primitiveAdoptInstance */
static void
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt i;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((arg & (tagMask())) != 0)
	 || ((GIV(argumentCount) > 1)
	 && (((rcvr & (tagMask())) != 0)
	 || (!(objCouldBeClassObj(rcvr)))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	err = changeClassOfto(arg, rcvr);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}


/*	Answer an array of all instances of the receiver that exist
	when the primitive is called, excluding any that may be
	garbage collected as a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllInstances */
EXPORT(void)
primitiveAllInstances(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt result;
    char *sp;

	
	/* For the mirror prims check that the class obj is actually a valid class. */
	if (!((GIV(argumentCount) < 1)
		 || ((((longAt(GIV(stackPointer))) & (tagMask())) == 0)
		 && (objCouldBeClassObj(longAt(GIV(stackPointer))))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}

	result = allInstancesOf(longAt(GIV(stackPointer)));
	if ((((result) & 7) == 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = (BaseHeaderSize * 2) + (((result >> 3)) * BytesPerOop);
		growOldSpaceByAtLeast(((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom)));
		result = allInstancesOf(longAt(GIV(stackPointer)));
		if ((((result) & 7) == 1)) {
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Answer an array of all objects that exist when the primitive
	is called, excluding those that may be garbage collected as
	a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllObjects */
EXPORT(void)
primitiveAllObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt result;
    char *sp;

	result = allObjects();
	if ((((result) & 7) == 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = (BaseHeaderSize * 2) + (((result >> 3)) * BytesPerOop);
		growOldSpaceByAtLeast(((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom)));
		result = allObjects();
		if ((((result) & 7) == 1)) {
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveArctan */
static void
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt object;
    double rcvr;
    char *sp;

	/* begin popFloat */
	rcvr = floatValueOf(popStack());
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = atan(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecome */
static void
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 0);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWay */
static void
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument
	deciding whether to
	copy the receiver's element's identity hash over the argument's elementy's
	identity hash.
 */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayCopyHash */
static void
primitiveArrayBecomeOneWayCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copyHashFlag;
    sqInt ec;

	copyHashFlag = 0;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			copyHashFlag = 0;
		}
		else {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	ec = becomewithtwoWaycopyHash(longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), 0, copyHashFlag);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}

	/* InterpreterPrimitives>>#primitiveAsCharacter */
static void
primitiveAsCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    sqInt objOop;
    sqInt reasonCode;
    char *sp;

	characterCode = longAt(GIV(stackPointer));
	if (!(((((characterCode) & 7) == 1))
		 && (((characterCode = (characterCode >> 3)),
		((characterCode >= 0) && (characterCode <= ((1LL << 30) - 1))))))) {
		/* begin primitiveFailFor: */
		reasonCode = (GIV(argumentCount) == 0
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		(GIV(primFailCode) = reasonCode);
		return;
	}
	characterObject = (((long)characterCode) << (numTagBits())) + (characterTag());

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), characterObject);
	GIV(stackPointer) = sp;
}


/*	N.B. This will answer inexact results for integers with > 53 bits of
	magnitude. 
 */

	/* InterpreterPrimitives>>#primitiveAsFloat */
static void
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	assert((((rcvr) & 7) == 1));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(((double) ((rcvr >> 3)) )));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveAt */
static void
primitiveAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    sqInt integerValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if ((rcvr & (tagMask())) != 0) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	if (((index & (tagMask())) != 1)
	 || ((GIV(argumentCount) > 1)
	 && (((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	index = (index >> 3);
	/* begin stObject:at: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l4;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l4;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l4;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l4;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l4;
	}
	totalLength = 0;
l4:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l5;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			result = longAt((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << (shiftForWord())));
			goto l5;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l5;
		}
		if (fmt >= (firstShortFormat())) {
			result = (((shortAt((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 1))) << 3) | 1);
			goto l5;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 2));
		result = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
		goto l5;

	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
l5:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveAtPut */
static void
primitiveAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt class1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt reasonCode1;
    sqInt signedValueToStore;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    sqInt sp2;
    sqInt sp3;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    usqInt unsignedValueToStore;
    usqInt unsignedValueToStore1;
    sqInt value;
    sqInt value1;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if ((rcvr & (tagMask())) != 0) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	if (((index & (tagMask())) != 1)
	 || ((GIV(argumentCount) > 2)
	 && (((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		GIV(primFailCode) = PrimErrNoModification;
		goto l1;
	}
	index = (index >> 3);
	/* begin stObject:at:put: */
	hdr1 = long64At(rcvr);
	fmt1 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots11 = byteAt(rcvr + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots11);
	if (fmt1 <= 5) {
		totalLength1 = numSlots2;
		goto l8;
	}
	if (fmt1 >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength1 = (((long)numSlots2) << (shiftForWord())) - (fmt1 & 7);
		goto l8;
	}
	if (fmt1 >= (firstShortFormat())) {
		totalLength1 = (((long)numSlots2) << ((shiftForWord()) - 1)) - (fmt1 & 3);
		goto l8;
	}
	if (fmt1 >= (firstLongFormat())) {
		totalLength1 = (((long)numSlots2) << ((shiftForWord()) - 2)) - (fmt1 & 1);
		goto l8;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat())) {
		totalLength1 = numSlots2;
		goto l8;
	}
	totalLength1 = 0;
l8:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt1 >= (sixtyFourBitIndexableFormat()))
	 || (fmt1 == 2)) {
		fixedFields1 = 0;
		goto l9;
	}
	if (fmt1 < 2) {
		fixedFields1 = totalLength1;
		goto l9;
	}
	class1 = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields1 = (((longAt((class1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l9:	/* end fixedFieldsOf:format:length: */;
	if ((fmt1 == (indexablePointersFormat()))
	 && ((hdr1 & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(rcvr)));
			stSize1 = sp3;
			goto l10;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((rcvr + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp11) & 7) == 1))) {
			stSize1 = 0;
			goto l10;
		}
		assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(rcvr)));
		stSize1 = (sp11 >> 3);
	l10:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize1))
		 && ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr), value);
			goto l11;
		}
	}
	else {
		stSize1 = totalLength1 - fixedFields1;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize1))) {
		/* begin subscript:with:storing:format: */
		if (fmt1 <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */
				if (((value & (tagMask())) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << (shiftForWord())), value);
			goto l7;
		}
		if (fmt1 >= (firstByteFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l7;
			}
			signedValueToStore1 = (value >> 3);
			if (!((signedValueToStore1 >= 0)
				 && (signedValueToStore1 <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l7;
			}
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
			goto l7;
		}
		if (fmt1 >= (firstShortFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l7;
			}
			signedValueToStore1 = (value >> 3);
			if (!((signedValueToStore1 >= 0)
				 && (signedValueToStore1 <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l7;
			}
			shortAtput((rcvr + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << 1), signedValueToStore1);
			goto l7;
		}
		unsignedValueToStore1 = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			long32Atput((rcvr + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << 2), unsignedValueToStore1);
		}
	l7:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode1 = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode1;
	}
l11:	/* end stObject:at:put: */;

	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAtPut: */;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

	/* InterpreterPrimitives>>#primitiveBeCursor */
static void
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt i;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;

	bitsObj = 0;
	cursorBitsIndex = 0;
	cursorObj = 0;
	depth = 0;
	extentX = 0;
	extentY = 0;
	i = 0;
	maskBitsIndex = 0;
	maskObj = 0;
	offsetObj = 0;
	ourCursor = 0;
	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin success: */
	successBoolean11 = (((cursorObj & (tagMask())) == 0)
	 && (((((usqInt) (longAt(cursorObj))) >> (formatShift())) & (formatMask())) <= 5))
	 && ((lengthOfformat(cursorObj, (((usqInt) (longAt(cursorObj))) >> (formatShift())) & (formatMask()))) >= 5);
	if (!successBoolean11) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0LL << (shiftForWord())));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4LL << (shiftForWord())));
	}
	/* begin success: */
	successBoolean12 = (((offsetObj & (tagMask())) == 0)
	 && (((((usqInt) (longAt(offsetObj))) >> (formatShift())) & (formatMask())) <= 5))
	 && ((lengthOfformat(offsetObj, (((usqInt) (longAt(offsetObj))) >> (formatShift())) & (formatMask()))) >= 2);
	if (!successBoolean12) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {

			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */
			/* begin success: */
			successBoolean = (extentX > 0)
			 && (extentY > 0);
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean1 = (offsetX >= (extentX * -1))
			 && (offsetX <= 0);
			if (!successBoolean1) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean2 = (offsetY >= (extentY * -1))
			 && (offsetY <= 0);
			if (!successBoolean2) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean3 = (((bitsObj & (tagMask())) == 0)
			 && (((((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1)))))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask()))) == (extentX * extentY));
			if (!successBoolean3) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
					}
		else {
			/* begin success: */
			successBoolean4 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean4) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (offsetX >= -16)
			 && (offsetX <= 0);
			if (!successBoolean5) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean6 = (offsetY >= -16)
			 && (offsetY <= 0);
			if (!successBoolean6) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean7 = (((bitsObj & (tagMask())) == 0)
			 && (((((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1)))))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask()))) == 16);
			if (!successBoolean7) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
					}
	}
	if (GIV(argumentCount) == 1) {
		/* begin success: */
		successBoolean10 = (((maskObj & (tagMask())) == 0)
		 && (((((usqInt) (longAt(maskObj))) >> (formatShift())) & (formatMask())) <= 5))
		 && ((lengthOfformat(maskObj, (((usqInt) (longAt(maskObj))) >> (formatShift())) & (formatMask()))) >= 5);
		if (!successBoolean10) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0LL << (shiftForWord())));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!GIV(primFailCode)) {
			/* begin success: */
			successBoolean8 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean8) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean9 = (((bitsObj & (tagMask())) == 0)
			 && (((((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1)))))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask()))) == 16);
			if (!successBoolean9) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount) == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable. */

	/* InterpreterPrimitives>>#primitiveBeDisplay */
static void
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt successBoolean;

	rcvr = longAt(GIV(stackPointer));
	/* begin success: */
	successBoolean = (((rcvr & (tagMask())) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= 5))
	 && ((lengthOfformat(rcvr, (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))) >= 4);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */
			if (((rcvr & (tagMask())) == 0)
			 && (oopisLessThan(rcvr, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheDisplay) << (shiftForWord())), rcvr);
	}
}


/*	make the basic beep noise */

	/* InterpreterPrimitives>>#primitiveBeep */
static void
primitiveBeep(void)
{
	ioBeep();
}

	/* InterpreterPrimitives>>#primitiveBehaviorHash */
static void
primitiveBehaviorHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBehavior;
    sqInt err;
    sqInt hash;
    sqInt hashOrError;
    char *sp;

	
	/* For the mirror prims check that the class obj is actually a valid class. */
	if (GIV(argumentCount) > 0) {
		if (!((((longAt(GIV(stackPointer))) & (tagMask())) == 0)
			 && (objCouldBeClassObj(longAt(GIV(stackPointer)))))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
	}

	assert((isNonImmediate(stackTop()))
	 && (addressCouldBeClassObj(stackTop())));
	/* begin ensureBehaviorHash: */
	aBehavior = longAt(GIV(stackPointer));
	assert(addressCouldBeClassObj(aBehavior));
	hashOrError = (((hash = (long32At(aBehavior + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(aBehavior)
				? (((err = enterIntoClassTable(aBehavior))) != 0
						? -err
						: (long32At(aBehavior + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((hashOrError << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = -hashOrError;
	}
}

	/* InterpreterPrimitives>>#primitiveBitAnd */
static void
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArgument;
    usqLong integerReceiver;
    sqInt integerValue;
    sqInt oop;
    sqInt oop1;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));

	/* Comment out the short-cut.  Either the inline interpreter bytecode or the JIT primitive will handle this case.
	   ((objectMemory isIntegerObject: integerArgument)
	   and: [objectMemory isIntegerObject: integerReceiver])
	   ifTrue: [self pop: 2 thenPush: (integerArgument bitAnd: integerReceiver)]
	   ifFalse:
	   [ */
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerArgument = positive64BitValueOf(integerArgument);
	integerReceiver = positive64BitValueOf(integerReceiver);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positive64BitIntegerFor(integerArgument & integerReceiver);
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}

}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitAndLargeIntegers */
EXPORT(void)
primitiveBitAndLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitOr */
static void
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArgument;
    usqLong integerReceiver;
    sqInt integerValue;
    sqInt oop;
    sqInt oop1;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));

	/* Comment out the short-cut.  Either the inline interpreter bytecode or the JIT primitive will handle this case.
	   ((objectMemory isIntegerObject: integerArgument)
	   and: [objectMemory isIntegerObject: integerReceiver])
	   ifTrue: [self pop: 2 thenPush: (integerArgument bitOr: integerReceiver)]
	   ifFalse:
	   [ */
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerArgument = positive64BitValueOf(integerArgument);
	integerReceiver = positive64BitValueOf(integerReceiver);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positive64BitIntegerFor(integerArgument | integerReceiver);
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}

}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitOrLargeIntegers */
EXPORT(void)
primitiveBitOrLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Perform a bitShift. In 32-bits deal only with non-negative 32-bit
	integers. In 64-bits deal with signed 64-bit quantities (max (2^63)-1). */

	/* InterpreterPrimitives>>#primitiveBitShift */
static void
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt shifted;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	if (!((((integerArgument) & 7) == 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerReceiver = signed64BitValueOf(integerReceiver);

	if (!GIV(primFailCode)) {
		if (((integerArgument = (integerArgument >> 3))) >= 0) {

			/* Left shift -- must fail bits would be lost */
			if (!(integerArgument <= 61)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((long)integerReceiver) << integerArgument;
			if (!(integerReceiver == (((sqInt) shifted) >> integerArgument))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		else {

			/* Right shift -- OK to lose bits */
			if (!(integerArgument >= (-61))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((sqInt) integerReceiver) >> (0 - integerArgument);
		}
		shifted = ((((((usqInt) shifted) >> 60) + 1) & 15) <= 1
			? ((shifted << 3) | 1)
			: signed64BitIntegerFor(shifted));

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitShiftLargeIntegers */
EXPORT(void)
primitiveBitShiftLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    sqInt integerPointer;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		shift = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		shift = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	if (GIV(primFailCode)) {
		return;
	}
	if (shift >= 0) {

		/* Protect against overflow */

		/* This is to avoid undue (usqInt) cast */
		result = 0xFFFFFFFFFFFFFFFFULL;
		if ((shift >= 64)
		 || (a > (result >> shift))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = ((long)a) << shift;
	}
	else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		}
		else {
			result = a >> shift;
		}
		if (aIsNegative
		 && ((((long)result) << shift) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitXor */
static void
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArgument;
    usqLong integerReceiver;
    sqInt integerValue;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    char *sp1;
    char *sp2;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerArgument) & 7) == 1))
	 && ((((integerReceiver) & 7) == 1))) {

		/* xoring will leave the tag bits zero, whether the tag is 1 or zero, so add it back in. */
		/* begin pop:thenPush: */
		oop = (integerArgument ^ integerReceiver) + 1;
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
	else {
		integerArgument = positive64BitValueOf(integerArgument);
		integerReceiver = positive64BitValueOf(integerReceiver);
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			oop1 = positive64BitIntegerFor(integerArgument ^ integerReceiver);
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
			GIV(stackPointer) = sp1;
		}

	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitXorLargeIntegers */
EXPORT(void)
primitiveBitXorLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Reports bytes available at this moment. For more meaningful 
	results, calls to this primitive should be precedeed by a full 
	or incremental garbage collection. */

	/* InterpreterPrimitives>>#primitiveBytesLeft */
static void
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt integerVal;
    char *sp;
    char *sp1;

	if (GIV(argumentCount) == 0) {

		/* old behavior - just return the size of free memory */
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((GIV(totalFreeOldSpace) << 3) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* new behaviour -including or excluding swap space depending on aBool */
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushInteger: */
			integerVal = (((GIV(totalFreeOldSpace) + ((((eden()).limit)) - GIV(freeStart))) + ((((pastSpace()).limit)) - GIV(pastSpaceStart))) + ((((futureSpace()).limit)) - (((futureSpace()).limit)))) - (interpreterAllocationReserveBytes());
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerVal << 3) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

	/* InterpreterPrimitives>>#primitiveCalloutToFFI */
static void
primitiveCalloutToFFI(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static void *function = (void *)-1;
    void (*primitiveCallout)(void);

	/* begin functionForPrimitiveCallout */
	if ((((sqInt)function)) == -1) {
		function = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
	}
	primitiveCallout = ((void (*)(void)) function);
	if (primitiveCallout == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		primitiveCallout();
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if the
	receiver or argument are SmallIntegers, or the receiver is an instance of
	a compact
	class and the argument isn't, or when the argument's class is compact and
	the receiver
	isn't, or when the format of the receiver is different from the format of
	the argument's
	class, or when the arguments class is fixed and the receiver's size
	differs from the size
	that an instance of the argument's class should have. */

	/* InterpreterPrimitives>>#primitiveChangeClass */
static void
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	argClass = fetchClassOfNonImm(arg);
	err = changeClassOfto(rcvr, argClass);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

	/* InterpreterPrimitives>>#primitiveClass */
static void
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    sqInt oop;
    char *sp;
    sqInt tagBits;

	instance = longAt(GIV(stackPointer));
	if ((GIV(argumentCount) > 0)
	 && (((instance & (tagMask())) == 0)
	 && (((longAt(instance)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		oop = (((tagBits = instance & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
			: fetchClassOfNonImm(instance));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Void the VM profile histograms. */

	/* InterpreterPrimitives>>#primitiveClearVMProfile */
static void
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

	/* InterpreterPrimitives>>#primitiveClipboardText */
static void
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt formatField;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(((s & (tagMask())) == 0)
			 && (((((usqInt) (longAt(s))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (!GIV(primFailCode)) {
			/* begin numBytesOfBytes: */
			fmt = (((usqInt) (longAt(s))) >> (formatShift())) & (formatMask());
			assert(fmt >= (firstByteFormat()));
			sz = (((long)(numSlotsOf(s))) << (shiftForWord())) - (fmt & 7);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize();
		/* begin allocateBytes:classIndex: */
		assert(addressCouldBeClassObj(classAtIndex(ClassByteStringCompactIndex)));
		assert((instSpecOfClass(classAtIndex(ClassByteStringCompactIndex))) == (firstByteFormat()));
		/* begin allocateSlots:format:classIndex: */
		numSlots = ((sz + BytesPerOop) - 1) / BytesPerOop;
		formatField = (firstByteFormat()) + ((8 - sz) & (BytesPerWord - 1));
		if (numSlots >= (numSlotsMask())) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				s = null;
				goto l1;
			}
			newObj = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			s = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, ClassByteStringCompactIndex);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots);
			longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), formatField, ClassByteStringCompactIndex));
		}
		else {
			longAtput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)formatField) << (formatShift()))) + ClassByteStringCompactIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		s = newObj;
	l1:	/* end allocateSlots:format:classIndex: */;
		if (!(s)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}

		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

	/* InterpreterPrimitives>>#primitiveClockLogAddresses */
EXPORT(sqInt)
primitiveClockLogAddresses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt integerValue1;
    sqInt midx;
    void *msecs;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;

	midx = 0;
	msecs = 0;
	uidx = 0;
	usecs = 0;
	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer) + (0 * BytesPerWord))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassArray) << (shiftForWord()))), 5);
	if (result == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop)));
	longAtput((objOop + BaseHeaderSize) + (0LL << (shiftForWord())), ((runInNOut << 3) | 1));
	/* begin positive32BitIntegerFor: */
	integerValue = ((usqInt)usecs);
	v1 = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
	goto l1;

l1:	/* end positive32BitIntegerFor: */;
	/* begin positive32BitIntegerFor: */
	integerValue1 = ((usqInt)msecs);
	v2 = (((integerValue1 & 0xFFFFFFFFULL) << 3) | 1);
	goto l2;

l2:	/* end positive32BitIntegerFor: */;
	if (GIV(primFailCode)) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin storePointer:ofObject:withValue: */
	objOop3 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop3)));
	if (isOldObject(objOop3)) {

		/* most stores into young objects */
		if (((v1 & (tagMask())) == 0)
		 && (oopisLessThan(v1, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop3))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop3);
			}
		}
	}
	longAtput((objOop3 + BaseHeaderSize) + (1LL << (shiftForWord())), v1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop1)));
	longAtput((objOop1 + BaseHeaderSize) + (2LL << (shiftForWord())), ((uidx << 3) | 1));
	/* begin storePointer:ofObject:withValue: */
	objOop4 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop4)));
	if (isOldObject(objOop4)) {

		/* most stores into young objects */
		if (((v2 & (tagMask())) == 0)
		 && (oopisLessThan(v2, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop4))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop4);
			}
		}
	}
	longAtput((objOop4 + BaseHeaderSize) + (3LL << (shiftForWord())), v2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop2)));
	longAtput((objOop2 + BaseHeaderSize) + (4LL << (shiftForWord())), ((midx << 3) | 1));
	/* begin pop:thenPush: */
	oop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	oop1 = oop2;
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveClosureValue */
static void
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt theMethod;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureNumArgsIndex) << (shiftForWord())));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())));
	if (!(((outerContext & (tagMask())) == 0)
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
	if (!(((closureMethod & (tagMask())) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, blockClosure, objOop);
	}
	outerContext1 = objOop;
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	/* begin followField:ofObject: */
	objOop1 = longAt((outerContext1 + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
	if (((objOop1 & (tagMask())) == 0)
	 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(MethodIndex, outerContext1, objOop1);
	}
	theMethod = objOop1;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (1LL << ((BytesPerWord * 8) - 24))
		: ((1 + (((long)numArgs) << 8)) + (0)) + (1LL << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	objOop2 = longAt((outerContext1 + BaseHeaderSize) + (((long)ReceiverIndex) << (shiftForWord())));
	if (((objOop2 & (tagMask())) == 0)
	 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop2 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext1, objOop2);
	}
	object1 = objOop2;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((long)(i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureStartPCIndex) << (shiftForWord())));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveClosureValueNoContextSwitch */
void
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt theMethod;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureNumArgsIndex) << (shiftForWord())));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())));
	if (!(((outerContext & (tagMask())) == 0)
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
	if (!(((closureMethod & (tagMask())) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, blockClosure, objOop);
	}
	outerContext1 = objOop;
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	/* begin followField:ofObject: */
	objOop1 = longAt((outerContext1 + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
	if (((objOop1 & (tagMask())) == 0)
	 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(MethodIndex, outerContext1, objOop1);
	}
	theMethod = objOop1;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (1LL << ((BytesPerWord * 8) - 24))
		: ((1 + (((long)numArgs) << 8)) + (0)) + (1LL << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	objOop2 = longAt((outerContext1 + BaseHeaderSize) + (((long)ReceiverIndex) << (shiftForWord())));
	if (((objOop2 & (tagMask())) == 0)
	 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop2 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext1, objOop2);
	}
	object1 = objOop2;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((long)(i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureStartPCIndex) << (shiftForWord())));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(0);
	}
}

	/* InterpreterPrimitives>>#primitiveClosureValueWithArgs */
static void
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt index;
    sqInt numArgs;
    sqInt numCopied;
    usqInt numSlots;
    sqInt object;
    sqInt object1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt theMethod;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(argumentArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	if (!(roomToPushNArgs(arraySize))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureNumArgsIndex) << (shiftForWord())));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())));
	if (!(((outerContext & (tagMask())) == 0)
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
	if (!(((closureMethod & (tagMask())) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord()))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, blockClosure, objOop);
	}
	outerContext1 = objOop;
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	/* begin followField:ofObject: */
	objOop1 = longAt((outerContext1 + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
	if (((objOop1 & (tagMask())) == 0)
	 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(MethodIndex, outerContext1, objOop1);
	}
	theMethod = objOop1;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (1LL << ((BytesPerWord * 8) - 24))
		: ((1 + (((long)numArgs) << 8)) + (0)) + (1LL << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	objOop2 = longAt((outerContext1 + BaseHeaderSize) + (((long)ReceiverIndex) << (shiftForWord())));
	if (((objOop2 & (tagMask())) == 0)
	 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop2 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext1, objOop2);
	}
	object1 = objOop2;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((long)(i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))));
		GIV(stackPointer) = sp7;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((long)ClosureStartPCIndex) << (shiftForWord())));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	Primitive. Compare two byte-indexed objects for equality */

	/* InterpreterPrimitives>>#primitiveCompareBytes */
EXPORT(void)
primitiveCompareBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt fmt;
    sqInt fmt1;
    sqInt i;
    sqInt len1;
    sqInt len2;
    usqInt numBytes;
    usqInt numBytes1;
    usqInt numSlots;
    usqInt numSlots1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((((arg1 & (tagMask())) == 0)
		 && (((((usqInt) (longAt(arg1))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
		 && (((arg2 & (tagMask())) == 0)
		 && (((((usqInt) (longAt(arg2))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (arg1 == arg2) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOf: */
	if ((arg1 & (tagMask())) != 0) {
		len1 = 0;
		goto l1;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(arg1))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(arg1)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(arg1 + 7);
	numBytes = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(arg1 - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	numBytes = ((long)numBytes) << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		len1 = numBytes - (fmt & 7);
		goto l3;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		len1 = numBytes;
		goto l3;
	}
	if (fmt >= (firstShortFormat())) {
		len1 = numBytes - (((long)(fmt & 3)) << 1);
		goto l3;
	}
	len1 = numBytes - (((long)(fmt & 1)) << 2);
l3:	/* end numBytesOf: */;
l1:	/* end byteSizeOf: */;
	/* begin byteSizeOf: */
	if ((arg2 & (tagMask())) != 0) {
		len2 = 0;
		goto l2;
	}
	/* begin numBytesOf: */
	fmt1 = (((usqInt) (longAt(arg2))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(arg2)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(arg2 + 7);
	numBytes1 = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(arg2 - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	numBytes1 = ((long)numBytes1) << (shiftForWord());
	if (fmt1 >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		len2 = numBytes1 - (fmt1 & 7);
		goto l4;
	}
	if (fmt1 <= (sixtyFourBitIndexableFormat())) {
		len2 = numBytes1;
		goto l4;
	}
	if (fmt1 >= (firstShortFormat())) {
		len2 = numBytes1 - (((long)(fmt1 & 3)) << 1);
		goto l4;
	}
	len2 = numBytes1 - (((long)(fmt1 & 1)) << 2);
l4:	/* end numBytesOf: */;
l2:	/* end byteSizeOf: */;
	if (!(len1 == len2)) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp1;
		return;
	}
	for (i = 0; i < len1; i += 1) {
		if (!((byteAt((arg1 + BaseHeaderSize) + i)) == (byteAt((arg2 + BaseHeaderSize) + i)))) {
			/* begin pop:thenPush: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
	GIV(stackPointer) = sp3;
}


/*	Fill the receiver, which must be an indexable bytes or words 
	objects, with the given integer value. */

	/* InterpreterPrimitives>>#primitiveConstantFill */
static void
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end;
    sqInt fillValue;
    usqInt i;
    sqInt rcvr;
    sqInt rcvrIsBytes;
    sqInt successBoolean;
    sqInt successBoolean1;

	fillValue = positive32BitValueOf(longAt(GIV(stackPointer)));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin success: */
	successBoolean1 = ((rcvr & (tagMask())) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())));
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	rcvrIsBytes = ((rcvr & (tagMask())) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()));
	if (rcvrIsBytes) {
		/* begin success: */
		successBoolean = (fillValue >= 0)
		 && (fillValue <= 0xFF);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		end = rcvr + ((((long)(numSlotsOf(rcvr))) << (shiftForWord())) + BaseHeaderSize);
		i = rcvr + BaseHeaderSize;
		if (rcvrIsBytes) {
			fillValue = fillValue & 0xFF;
			fillValue = ((fillValue + (((long)fillValue) << 8)) + (((long)fillValue) << 16)) + (((long)fillValue) << 24);
		}
		while (i < end) {
			long32Atput(i, fillValue);
			i += 4;
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

	/* InterpreterPrimitives>>#primitiveControlVMProfiling */
static void
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((((bufferSize) & 7) == 1))
			 && (((bufferSize = (bufferSize >> 3))) > 0))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), ((numSamples << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class.
	Fail if the receiver or argument are contexts (because of context-to-stack
	mapping). Fail if receiver and argument have different lengths (for
	indexable objects).
	Fail if the objects are not in a fit state to be copied (e.g. married
	contexts and Cogged methods) */

	/* InterpreterPrimitives>>#primitiveCopyObject */
static void
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt fmt;
    sqInt i;
    usqInt length;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt valuePointer;

	if (!(GIV(argumentCount) >= 1)) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & (tagMask())) != 0) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if ((arg & (tagMask())) != 0) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (((longAt(rcvr)) & (classIndexMask())) != ((longAt(arg)) & (classIndexMask()))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))) {
		/* begin numBytesOf: */
		fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots1 = byteAt(rcvr + 7);
		numBytes = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		numBytes = ((long)numBytes) << (shiftForWord());
		if (fmt >= (firstByteFormat())) {

			/* bytes (the common case), including CompiledMethod */
			length = ((sqInt) (numBytes - (fmt & 7)));
			goto l1;
		}
		if (fmt <= (sixtyFourBitIndexableFormat())) {
			length = ((sqInt) numBytes);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			length = ((sqInt) (numBytes - (((long)(fmt & 3)) << 1)));
			goto l1;
		}
		length = ((sqInt) (numBytes - (((long)(fmt & 1)) << 2)));
	l1:	/* end numBytesOf: */;
		if (!((((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) == ((((usqInt) (longAt(arg))) >> (formatShift())) & (formatMask())))
			 && (length == (numBytesOf(arg))))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		memcpy(((void *)(rcvr + BaseHeaderSize)), ((void *)(arg + BaseHeaderSize)), length);
	}
	else {
		if (!(isAppropriateForCopyObject(rcvr))) {
			(GIV(primFailCode) = PrimErrBadReceiver);
			return;
		}
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(rcvr + 7);
		length = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);
		if (!((isAppropriateForCopyObject(arg))
			 && (length == (lengthOfformat(arg, (((usqInt) (longAt(arg))) >> (formatShift())) & (formatMask())))))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		for (i = 0; i < length; i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((arg + BaseHeaderSize) + (((long)i) << (shiftForWord())));
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */
				if (((valuePointer & (tagMask())) == 0)
				 && (oopisLessThan(valuePointer, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((long)i) << (shiftForWord())), valuePointer);
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. If
	the argument is an integer use the method that implies.
	bit 0 = thread to crash in; 1 => this thread
	bit 1 = crash method; 0 => indirect through null pointer; 1 => call exit */

	/* InterpreterPrimitives>>#primitiveCrashVM */
EXPORT(sqInt)
primitiveCrashVM(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	if (((((longAt(GIV(stackPointer)))) & 7) == 1)) {
		crashInThisThread = ((longAt(GIV(stackPointer))) >> 3);
	}
	else {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			crashInThisThread = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			crashInThisThread = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		crashInThisThread = null;
	l1:	/* end booleanValueOf: */;
	}
	if (GIV(primFailCode)
	 || (GIV(argumentCount) != 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	crashInThisOrAnotherThread(crashInThisThread);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveDisablePowerManager */
EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		integer = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveDiv */
static void
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt) quotient) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((quotient << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}

	/* InterpreterPrimitives>>#primitiveDivide */
static void
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		integerReceiver = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		integerArgument = (integerPointer1 >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if ((((((usqInt) (integerReceiver / integerArgument)) >> 60) + 1) & 15) <= 1) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((integerReceiver / integerArgument) << 3) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}

			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivideLargeIntegers */
EXPORT(void)
primitiveDivideLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (!((b != 0)
		 && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivLargeIntegers */
EXPORT(void)
primitiveDivLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	if (!(a == 0)) {
		if (!(bIsNegative == aIsNegative)) {

			/* Round toward negative infinity */
			rem = a % b;
			if (!(rem == 0)) {

				/* This can not overflow, because b > 1, otherwise rem = 0 */
				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process.
	For simulation if there is an argument it is taken to be the effective
	activeProcess (see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveEnterCriticalSection */
static void
primitiveEnterCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt objOop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin fetchPointer:ofObject: */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
		activeProc = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((long)owningProcessIndex) << (shiftForWord())));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		if (isOldObject(criticalSection)) {

			/* most stores into young objects */
			if (((activeProc & (tagMask())) == 0)
			 && (oopisLessThan(activeProc, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(criticalSection))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(criticalSection);
				}
			}
		}
		longAtput((criticalSection + BaseHeaderSize) + (((long)owningProcessIndex) << (shiftForWord())), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp2;
	addLastLinktoList(activeProc, criticalSection);
	transferTo(wakeHighestPriority());
}

	/* InterpreterPrimitives>>#primitiveEqual */
static void
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerReceiver) & 7) == 1))
	 && ((((integerArgument) & 7) == 1))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver == integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (signed64BitValueOf(integerReceiver)) == (signed64BitValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveEqualLargeIntegers */
EXPORT(void)
primitiveEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr == integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Exit the critical section.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveExitCriticalSection */
static void
primitiveExitCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;


	/* rcvr */
	criticalSection = longAt(GIV(stackPointer));

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	if (isEmptyList(criticalSection)) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		longAtput((criticalSection + BaseHeaderSize) + (((long)owningProcessIndex) << (shiftForWord())), GIV(nilObj));
	}
	else {

		/* store check unnecessary because criticalSection referred to owningProcess
		   via its FirstLinkIndex slot before owningProcess was removed. */
		owningProcess = removeFirstLinkOfList(criticalSection);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		longAtput((criticalSection + BaseHeaderSize) + (((long)owningProcessIndex) << (shiftForWord())), owningProcess);
		resumepreemptedYieldingIf(owningProcess, GIV(preemptionYields));
	}
}

	/* InterpreterPrimitives>>#primitiveExitToDebugger */
static void
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power. */

	/* InterpreterPrimitives>>#primitiveExp */
static void
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt object;
    double rcvr;
    char *sp;

	/* begin popFloat */
	rcvr = floatValueOf(popStack());
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = exp(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Exponent part of this float. */

	/* InterpreterPrimitives>>#primitiveExponent */
static void
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double frac;
    int pwr;
    double rcvr;
    char *sp;

	/* begin popFloat */
	rcvr = floatValueOf(popStack());
	if (!GIV(primFailCode)) {

		/* rcvr = frac * 2^pwr, where frac is in [0.5..1.0) */
		frac = frexp(rcvr, &pwr);
		/* begin pushInteger: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), (((pwr - 1) << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}

	/* InterpreterPrimitives>>#primitiveFailureCode */
sqInt
primitiveFailureCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}

	/* InterpreterPrimitives>>#primitiveFetchNextMourner */
static void
primitiveFetchNextMourner(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mourner;
    char *sp;

	mourner = popObjStack(GIV(mournQueue));
	if (mourner == null) {
		GIV(primFailCode) = PrimErrNotFound;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), mourner);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatAdd */
static void
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt bits;
    sqInt bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)rcvrOop) << shift)) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)argOop) << shift1)) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAt */
static void
primitiveFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bits;
    sqInt bits1;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt integerValue;
    sqInt integerValue1;
    sqInt rcvr;
    sqInt reasonCode;
    usqInt result;
    sqInt rot;
    sqInt rot1;
    char *sp;
    char *sp1;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		/* begin positive32BitIntegerFor: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		if (!((rcvr & (tagMask())) == (smallFloatTag()))) {
			integerValue = long32At((rcvr + BaseHeaderSize) + (((long)fieldIndex) << 2));
			goto l3;
		}
		/* begin smallFloatBitsOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {

			/* a.k.a. ~= +/-0.0 */
			rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
		}
		rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
		bits = rot;
		integerValue = (((int *) ((&bits))))[fieldIndex];
	l3:	/* end fetchLong32:ofFloatObject: */;
		result = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
		goto l1;

	l1:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin positive32BitIntegerFor: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		if (!((rcvr & (tagMask())) == (smallFloatTag()))) {
			integerValue1 = long32At((rcvr + BaseHeaderSize) + (((long)fieldIndex1) << 2));
			goto l4;
		}
		/* begin smallFloatBitsOf: */
		assert(isImmediateFloat(rcvr));
		rot1 = ((usqInt) (((usqInt)rcvr))) >> (numTagBits());
		if (rot1 > 1) {

			/* a.k.a. ~= +/-0.0 */
			rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
		}
		rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
		bits1 = rot1;
		integerValue1 = (((int *) ((&bits1))))[fieldIndex1];
	l4:	/* end fetchLong32:ofFloatObject: */;
		result = (((integerValue1 & 0xFFFFFFFFULL) << 3) | 1);
		goto l2;

	l2:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((((index) & 7) == 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAtPut */
static void
primitiveFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    usqInt valueToStore;

	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore);
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & (tagMask())) == (smallFloatTag())) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	if (index == ConstOne) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		long32Atput((rcvr + BaseHeaderSize) + (((long)fieldIndex) << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		long32Atput((rcvr + BaseHeaderSize) + (((long)fieldIndex1) << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((((index) & 7) == 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}

	/* InterpreterPrimitives>>#primitiveFloatDivide */
static void
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt bits;
    sqInt bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatDivide:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)rcvrOop) << shift)) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)argOop) << shift1)) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin success: */
	if (!(arg != 0.0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatEqual */
static void
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt floatOrIntOop1;
    double rcvr;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatEqual:toArg: */
	floatOrIntOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			rcvr = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop1 = longAt(GIV(stackPointer));
	if (((tagBits1 = floatOrIntOop1 & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop1));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop1))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop1) << shift1)) >> shift1) == floatOrIntOop1))) {
			arg = ((double) ((floatOrIntOop1 >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(floatOrIntOop1)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop1 + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterOrEqual */
static void
primitiveFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt floatOrIntOop1;
    double rcvr;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatGreaterOrEqual:toArg: */
	floatOrIntOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			rcvr = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop1 = longAt(GIV(stackPointer));
	if (((tagBits1 = floatOrIntOop1 & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop1));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop1))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop1) << shift1)) >> shift1) == floatOrIntOop1))) {
			arg = ((double) ((floatOrIntOop1 >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(floatOrIntOop1)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop1 + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr >= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterThan */
static void
primitiveFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt floatOrIntOop1;
    double rcvr;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatGreater:thanArg: */
	floatOrIntOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			rcvr = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop1 = longAt(GIV(stackPointer));
	if (((tagBits1 = floatOrIntOop1 & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop1));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop1))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop1) << shift1)) >> shift1) == floatOrIntOop1))) {
			arg = ((double) ((floatOrIntOop1 >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(floatOrIntOop1)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop1 + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr > arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessOrEqual */
static void
primitiveFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt floatOrIntOop1;
    double rcvr;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatLessOrEqual:toArg: */
	floatOrIntOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			rcvr = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop1 = longAt(GIV(stackPointer));
	if (((tagBits1 = floatOrIntOop1 & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop1));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop1))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop1) << shift1)) >> shift1) == floatOrIntOop1))) {
			arg = ((double) ((floatOrIntOop1 >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(floatOrIntOop1)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop1 + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr <= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessThan */
static void
primitiveFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt floatOrIntOop1;
    double rcvr;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatLess:thanArg: */
	floatOrIntOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			rcvr = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop1 = longAt(GIV(stackPointer));
	if (((tagBits1 = floatOrIntOop1 & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop1));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop1))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop1) << shift1)) >> shift1) == floatOrIntOop1))) {
			arg = ((double) ((floatOrIntOop1 >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(floatOrIntOop1)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop1 + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr < arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatMultiply */
static void
primitiveFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt bits;
    sqInt bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatMultiply:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)rcvrOop) << shift)) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)argOop) << shift1)) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatNotEqual */
static void
primitiveFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt floatOrIntOop1;
    double rcvr;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatEqual:toArg: */
	floatOrIntOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			rcvr = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop1 = longAt(GIV(stackPointer));
	if (((tagBits1 = floatOrIntOop1 & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop1));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop1))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop1) << shift1)) >> shift1) == floatOrIntOop1))) {
			arg = ((double) ((floatOrIntOop1 >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(floatOrIntOop1)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop1 + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (!aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatSubtract */
static void
primitiveFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt bits;
    sqInt bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    sqInt shift1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;

	/* begin primitiveFloatSubtract:fromArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((usqInt) (((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			rcvr = (((double *) ((&bits))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)rcvrOop) << shift)) >> shift) == rcvrOop))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((usqInt) (((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l2;
		}
		if ((tagBits1 == 1)
		 && (((shift1 = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)argOop) << shift1)) >> shift1) == argOop))) {
			arg = ((double) ((argOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

	/* InterpreterPrimitives>>#primitiveFlushCache */
static void
primitiveFlushCache(void)
{
	flushMethodCache();
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invokation.
 */

	/* InterpreterPrimitives>>#primitiveFlushExternalPrimitives */
static void
primitiveFlushExternalPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt firstBytecode;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt i;
    usqInt limit;
    sqInt methodHeader;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt primBits;
    sqInt primIdx;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	/* begin flushExternalPrimitives */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & (classIndexMask())) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */
				/* begin primitiveIndexOfMethod:header: */
				assert(isCompiledMethod(objOop1));
				methodHeader = longAt((objOop1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				if (methodHeader & AlternateHeaderHasPrimFlag) {
					firstBytecode = (objOop1 + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
					primIdx = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
				}
				else {
					primIdx = 0;
				}

				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */
					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & (classIndexMask())) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */
				/* begin primitiveIndexOfMethod:header: */
				assert(isCompiledMethod(objOop1));
				methodHeader = longAt((objOop1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				if (methodHeader & AlternateHeaderHasPrimFlag) {
					firstBytecode = (objOop1 + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
					primIdx = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
				}
				else {
					primIdx = 0;
				}

				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */
					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (!(((longAt(objOop11)) & (classIndexMask())) == 0)) {
				if (((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

					/* This is a compiled method */
					/* begin primitiveIndexOfMethod:header: */
					assert(isCompiledMethod(objOop11));
					methodHeader = longAt((objOop11 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					if (methodHeader & AlternateHeaderHasPrimFlag) {
						firstBytecode = (objOop11 + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
						primIdx = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
					}
					else {
						primIdx = 0;
					}

					if (primIdx == PrimitiveExternalCallIndex) {

						/* It's primitiveExternalCall */
						flushExternalPrimitiveOf(objOop11);
					}
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	flushMethodCache();
	/* begin flushExternalPrimitiveTable */
	for (i = 0; i < MaxExternalPrimitiveTableSize; i += 1) {
		externalPrimitiveTable[i] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

	/* InterpreterPrimitives>>#primitiveForceDisplayUpdate */
static void
primitiveForceDisplayUpdate(void)
{
	ioForceDisplayUpdate();
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

	/* InterpreterPrimitives>>#primitiveFormPrint */
static void
primitiveFormPrint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt depth;
    sqInt fmt;
    sqInt h;
    double hScale;
    sqInt landscapeFlag;
    usqInt numBytes;
    usqInt numSlots;
    sqInt ok;
    sqInt pixelsPerWord;
    sqInt rcvr;
    double vScale;
    sqInt w;
    sqInt wordsPerLine;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l2;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l2;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	landscapeFlag = null;
l2:	/* end booleanValueOf: */;
	vScale = floatValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	hScale = floatValueOf(longAt(GIV(stackPointer) + (2 * BytesPerWord)));
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if (!((((rcvr & (tagMask())) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= 5))
		 && ((lengthOfformat(rcvr, (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))) >= 4))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

	}
	if (!GIV(primFailCode)) {
		bitsArray = longAt((rcvr + BaseHeaderSize) + (0LL << (shiftForWord())));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if (((bitsArray & (tagMask())) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(bitsArray))) >> (formatShift())) & (formatMask())))) {
			/* begin numBytesOf: */
			fmt = (((usqInt) (longAt(bitsArray))) >> (formatShift())) & (formatMask());
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(bitsArray)) > (isForwardedObjectClassIndexPun()));
			numSlots = byteAt(bitsArray + 7);
			numBytes = (numSlots == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(bitsArray - BaseHeaderSize))) << 8)))) >> 8
				: numSlots);
			numBytes = ((long)numBytes) << (shiftForWord());
			if (fmt >= (firstByteFormat())) {

				/* bytes (the common case), including CompiledMethod */
				bitsArraySize = numBytes - (fmt & 7);
				goto l1;
			}
			if (fmt <= (sixtyFourBitIndexableFormat())) {
				bitsArraySize = numBytes;
				goto l1;
			}
			if (fmt >= (firstShortFormat())) {
				bitsArraySize = numBytes - (((long)(fmt & 3)) << 1);
				goto l1;
			}
			bitsArraySize = numBytes - (((long)(fmt & 1)) << 2);
		l1:	/* end numBytesOf: */;
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
	if (!GIV(primFailCode)) {
		ok = ioFormPrint(bitsArray + BaseHeaderSize, w, h, depth, hScale, vScale, landscapeFlag);
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveFractionalPart */
static void
primitiveFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double frac;
    sqInt object;
    double rcvr;
    char *sp;
    double trunc;

	/* begin popFloat */
	rcvr = floatValueOf(popStack());
	if (!GIV(primFailCode)) {
		frac = modf(rcvr, (&trunc));
		/* begin pushFloat: */
		object = floatObjectOf(frac);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Fetch the system attribute with the given integer ID. The 
	result is a string, which will be empty if the attribute is not 
	defined. */

	/* InterpreterPrimitives>>#primitiveGetAttribute */
static void
primitiveGetAttribute(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    sqInt integerPointer;
    sqInt s;
    char *sp;
    sqInt sz;

	sz = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		attr = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		attr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		sz = attributeSize(attr);
	}
	if (!GIV(primFailCode)) {
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord()))), sz);
		getAttributeIntoLength(attr, s + BaseHeaderSize, sz);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGetImmutability */
static void
primitiveGetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt trueOrFalse;

	
#  if IMMUTABILITY
	rcvr = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin pop:thenPushBool: */
	trueOrFalse = ((rcvr & (tagMask())) != 0)
	 || (((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;

#  else /* IMMUTABILITY */
	GIV(primFailCode) = PrimErrUnsupported;

#  endif /* IMMUTABILITY */

}


/*	Primitive. Answer the VM's current log directory */

	/* InterpreterPrimitives>>#primitiveGetLogDirectory */
EXPORT(sqInt)
primitiveGetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char*ptr;
    char *sp;
    sqInt stringOop;
    sqInt sz;

	ptr = ioGetLogDirectory();
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = strlen(ptr);
	stringOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord()))), sz);
	for (i = 0; i < sz; i += 1) {
		byteAtput((stringOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), stringOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Return the next input event from the VM event queue. */

	/* InterpreterPrimitives>>#primitiveGetNextEvent */
static void
primitiveGetNextEvent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    long eventTypeIs;
    long evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    long value;

	arg = longAt(GIV(stackPointer));
	if (!((((arg & (tagMask())) == 0)
		 && (((((usqInt) (longAt(arg))) >> (formatShift())) & (formatMask())) == 2))
		 && ((slotSizeOf(arg)) == 8))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (GIV(primFailCode)) {
		return;
	}
	eventTypeIs = evtBuf[0];
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqInt) (evtBuf[0])) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(arg)));
		longAtput((arg + BaseHeaderSize) + (0LL << (shiftForWord())), (((evtBuf[0]) << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	if (eventTypeIs == 6) {

		/* Event is Complex, assume evtBuf is populated correctly and return */
		for (i = 1; i <= 7; i += 1) {
			value = evtBuf[i];
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(arg)));
			if (isOldObject(arg)) {

				/* most stores into young objects */
				if (((value & (tagMask())) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(arg))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(arg);
					}
				}
			}
			longAtput((arg + BaseHeaderSize) + (((long)i) << (shiftForWord())), value);
		}
	}
	else {

		/* Event time stamp */
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqInt) ((evtBuf[1]) & MillisecondClockMask)) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(arg)));
			longAtput((arg + BaseHeaderSize) + (1LL << (shiftForWord())), ((((evtBuf[1]) & MillisecondClockMask) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (GIV(primFailCode)) {
			return;
		}
		for (i = 2; i <= 7; i += 1) {
			value = evtBuf[i];
			if ((((((usqInt) value) >> 60) + 1) & 15) <= 1) {
				/* begin storeInteger:ofObject:withValue: */
				if ((((((usqInt) value) >> 60) + 1) & 15) <= 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(arg)));
					longAtput((arg + BaseHeaderSize) + (((long)i) << (shiftForWord())), ((value << 3) | 1));
				}
				else {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
			}
			else {
				value = positive64BitIntegerFor(value);

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(arg)));
				if (isOldObject(arg)) {

					/* most stores into young objects */
					if (((value & (tagMask())) == 0)
					 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(arg))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(arg);
						}
					}
				}
				longAtput((arg + BaseHeaderSize) + (((long)i) << (shiftForWord())), value);
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's label */

	/* InterpreterPrimitives>>#primitiveGetWindowLabel */
EXPORT(sqInt)
primitiveGetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt labelOop;
    char*ptr;
    char *sp;
    sqInt sz;

	ptr = ioGetWindowLabel();
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = strlen(ptr);
	labelOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord()))), sz);
	for (i = 0; i < sz; i += 1) {
		byteAtput((labelOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), labelOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveGetWindowSize */
EXPORT(sqInt)
primitiveGetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt h;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt object;
    sqInt objFormat;
    sqInt pointResult;
    char *sp;
    sqInt w;

	w = ioGetWindowWidth();
	h = ioGetWindowHeight();
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((long)XIndex) << (shiftForWord())), ((w << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((long)YIndex) << (shiftForWord())), ((h << 3) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveGreaterOrEqual */
static void
primitiveGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerReceiver) & 7) == 1))
	 && ((((integerArgument) & 7) == 1))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver >= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterOrEqualLargeIntegers */
EXPORT(void)
primitiveGreaterOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr >= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGreaterThan */
static void
primitiveGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerReceiver) & 7) == 1))
	 && ((((integerArgument) & 7) == 1))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver > integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterThanLargeIntegers */
EXPORT(void)
primitiveGreaterThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr > integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGrowMemoryByAtLeast */
static void
primitiveGrowMemoryByAtLeast(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ammount;
    sqInt segSize;
    char *sp;

	ammount = longAt(GIV(stackPointer));
	if (!((((ammount) & 7) == 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	segSize = growOldSpaceByAtLeast((ammount >> 3));
	if (segSize == null) {
		GIV(primFailCode) = PrimErrNoMemory;
	}
	else {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((segSize << 3) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer the heartbeat frequency in beats per second. If the argument is
	true, reset the frequency measure. */

	/* InterpreterPrimitives>>#primitiveHeartbeatFrequency */
EXPORT(sqInt)
primitiveHeartbeatFrequency(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt oop;
    sqInt reset;
    char *sp;

	reset = (GIV(argumentCount) == 1)
	 && ((longAt(GIV(stackPointer))) == GIV(trueObj));
	/* begin pop:thenPush: */
	integerValue = ioHeartbeatFrequency(reset);
	oop = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
	goto l1;

l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the value of the high resolution clock if this system has any. The
	exact frequency of the high res clock is undefined specifically so that we
	can use processor dependent instructions (like RDTSC). The only use for
	the high res clock is for profiling where we can allocate time based on
	sub-msec resolution of the high res clock. If no high-resolution counter
	is available, the platform should return zero.
 */

	/* InterpreterPrimitives>>#primitiveHighResClock */
EXPORT(sqInt)
primitiveHighResClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	/* begin push: */
	object = positive64BitIntegerFor(ioHighResClock());
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

	/* InterpreterPrimitives>>#primitiveIdentical */
static void
primitiveIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	if ((((otherObject & (tagMask())) == 0)
	 && (((longAt(otherObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
	 || ((GIV(argumentCount) > 1)
	 && (((thisObject & (tagMask())) == 0)
	 && (((longAt(thisObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))))) {
		GIV(primFailCode) = PrimErrBadArgument;
	}
	else {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject == otherObject
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveIdentityHash */
static void
primitiveIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt integerVal;
    char *sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	if (((thisReceiver & (tagMask())) != 0)
	 || ((GIV(argumentCount) > 0)
	 && (((longAt(thisReceiver)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPushInteger: */
		hash = (long32At(thisReceiver + 4)) & (identityHashHalfWordMask());
		if (hash == 0) {

			/* would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */
			hash = (newObjectHash()) & (identityHashHalfWordMask());
			/* begin setHashBitsOf:to: */
			flag("endianness");
			assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
			long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
		}
		integerVal = hash;
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((integerVal << 3) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer an integer identifying the type of image. The image version number
	may identify the format of the image (e.g. 32 or 64-bit word size) or
	specific requirements
	of the image (e.g. block closure support required).
	
	This is a named (not numbered) primitive in the null module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveImageFormatVersion */
EXPORT(sqInt)
primitiveImageFormatVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt isSpurFlag;
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	isSpurFlag = 16;
	integerValue = (68003) + isSpurFlag;
	oop = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
	goto l1;

l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	When called with a single string argument, record the string as the
	current image file name. When called with zero arguments, return a string
	containing the current image file name.
 */

	/* InterpreterPrimitives>>#primitiveImageName */
static void
primitiveImageName(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ok;
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {

		/* If the security plugin can be loaded, use it to check for rename permission.
		   If not, assume it's ok */
		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn != 0) {
			okToRename = ((sqInt (*)(void))sCRIfn)();
			if (!okToRename) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		s = longAt(GIV(stackPointer));
		/* begin assertClassOf:is: */
		ok = (s & (tagMask())) == 0;
		if (ok) {
			/* begin isClassOfNonImm:equalTo: */
			assert(isNonImmediate(s));
			ok = ((longAt(s)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
		}
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			sz = stSizeOf(s);
			imageNamePutLength(s + BaseHeaderSize, sz);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = imageNameSize();
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord()))), sz);
		imageNameGetLength(s + BaseHeaderSize, sz);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), s);
		GIV(stackPointer) = sp;
	}
}


/*	For a Smalllnteger, answer itself.
	For a Character, answer its code as an unsigned integer.
	For a SmallFloat, answer the signed, but unadjusted bit pattern (so as to
	keep the result a SmallInteger).
	This is a good value for an immediate's hash. */

	/* InterpreterPrimitives>>#primitiveImmediateAsInteger */
static void
primitiveImmediateAsInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;
    sqInt value;

	value = 0;
	oop = longAt(GIV(stackPointer));
	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
	}
	else {
		if ((oop & (tagMask())) == 2) {
			value = ((usqInt) (((usqInt)oop))) >> (numTagBits());
		}
		else {
			if ((oop & (tagMask())) == (smallFloatTag())) {
				/* begin rotatedFloatBitsOf: */
				assert(isImmediateFloat(oop));
				value = (((usqInt) (((usqInt)oop))) >> ((numTagBits()) + 1)) + ((oop & (1LL << (numTagBits()))
	? -1LL << ((64 - (numTagBits())) - 1)
	: 0));
			}
			else {
				(GIV(primFailCode) = PrimErrBadReceiver);
				return;
			}
		}
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Register the input semaphore. If the argument is not a 
	Semaphore, unregister the current input semaphore. */

	/* InterpreterPrimitives>>#primitiveInputSemaphore */
static void
primitiveInputSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((((arg) & 7) == 1)) {

		/* If arg is integer, then use it as an index
		   into the external objects array and install it
		   as the new event semaphore */
		ioSetInputSemaphore((arg >> 3));
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
		return;
	}
	if (TheInputSemaphore == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask())) == 0)
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord())))))))) {
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */
			if (((arg & (tagMask())) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheInputSemaphore) << (shiftForWord())), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

	/* InterpreterPrimitives>>#primitiveInputWord */
static void
primitiveInputWord(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((sqInt)0 << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the 32bit signed integer contents of a words receiver */

	/* InterpreterPrimitives>>#primitiveIntegerAt */
static void
primitiveIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt fmt;
    sqInt index;
    sqInt integerPointer;
    int intValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & (tagMask())) == 0)
		 && (((((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1)))))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		sz = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		sz = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		sz = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		sz = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		sz = numSlots;
		goto l1;
	}
	sz = 0;
l1:	/* end lengthOf:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}

	/* for zero indexing */
	addr = (rcvr + BaseHeaderSize) + ((index - 1) * 4);
	value = intAt(addr);
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	if ((((((usqInt) value) >> 60) + 1) & 15) <= 1) {
		/* begin pushInteger: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), ((value << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {

		/* 32 bit int may have been stored in 32 or 64 bit sqInt */
		intValue = value;
		/* begin push: */
		object = (((((int) intValue)) << 3) | 1);
		goto l2;

	l2:	/* end signed32BitIntegerFor: */;
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp1;
	}
}


/*	Return the 32bit signed integer contents of a words receiver */

	/* InterpreterPrimitives>>#primitiveIntegerAtPut */
static void
primitiveIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt fmt;
    sqInt index;
    sqInt integerPointer;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    int value;
    sqInt valueOop;

	valueOop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	value = signed32BitValueOf(valueOop);
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & (tagMask())) == 0)
		 && (((((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1)))))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		sz = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		sz = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		sz = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		sz = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		sz = numSlots;
		goto l1;
	}
	sz = 0;
l1:	/* end lengthOf:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}

	/* for zero indexing */
	addr = (rcvr + BaseHeaderSize) + ((index - 1) * 4);
	value = intAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), valueOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the number of interrupt checks per milliseconds that we
	execute on this machine. This can be used to adjust the sub-msecs profiler
	to check (roughly) 
	n times per millisecond.
 */

	/* InterpreterPrimitives>>#primitiveInterruptChecksPerMSec */
EXPORT(sqInt)
primitiveInterruptChecksPerMSec(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin pop:thenPush: */
	oop = (((ioHeartbeatMilliseconds()) << 3) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

	/* InterpreterPrimitives>>#primitiveInterruptSemaphore */
static void
primitiveInterruptSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask())) == 0)
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord())))))))) {
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */
			if (((arg & (tagMask())) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheInterruptSemaphore) << (shiftForWord())), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

	/* InterpreterPrimitives>>#primitiveInvokeObjectAsMethod */
static void
primitiveInvokeObjectAsMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt rcvr;
    sqInt runArgs;
    sqInt runReceiver;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt tagBits;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
	 && (ClassArrayCompactIndex != 0));
	assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
	runArgs = allocateNewSpaceSlotsformatclassIndex(GIV(argumentCount), 2, ClassArrayCompactIndex);

	for (i = (GIV(argumentCount) - 1); i >= 0; i += -1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		top1 = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		valuePointer = top1;
		assert(!(isForwarded(runArgs)));
		longAtput((runArgs + BaseHeaderSize) + (((long)i) << (shiftForWord())), valuePointer);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	runReceiver = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(messageSelector));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), runArgs);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), runReceiver);
	GIV(stackPointer) = sp3;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorRunWithIn) << (shiftForWord())));
	GIV(argumentCount) = 3;
	if (((tagBits = GIV(newMethod) & (tagMask()))) != 0) {
		lookupClassTag = tagBits;
	}
	else {
		lookupClassTag = (longAt(GIV(newMethod))) & (classIndexMask());
	}
	findNewMethodInClassTag(lookupClassTag);
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((int) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader1)) < 0
								? AltLongStoreBytecode
								: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 3) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Answer if running on a big endian machine. */

	/* InterpreterPrimitives>>#primitiveIsBigEnder */
EXPORT(sqInt)
primitiveIsBigEnder(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (VMBIGENDIAN
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Answer if the receiver is pinned, i.e. immobile. */

	/* InterpreterPrimitives>>#primitiveIsPinned */
static void
primitiveIsPinned(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;
    char *sp;
    sqInt trueOrFalse;

	obj = longAt(GIV(stackPointer));
	if (((obj & (tagMask())) != 0)
	 || (((longAt(obj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	/* begin pop:thenPushBool: */
	trueOrFalse = (((((usqInt) (longAt(obj))) >> 30) & 1) != 0
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer whether the OS window is currently partially or fully
	obscured. 
 */

	/* InterpreterPrimitives>>#primitiveIsWindowObscured */
EXPORT(sqInt)
primitiveIsWindowObscured(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    sqInt trueOrFalse;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin pushBool: */
	trueOrFalse = ioIsWindowObscured();
	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and remove it from the input buffer. The low byte
	is the 8-bit ISO character. The next four bits are the Smalltalk modifier
	bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveKbdNext */
static void
primitiveKbdNext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioGetKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((keystrokeWord << 3) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and without removing it from the input buffer. The
	low byte is the 8-bit ISO character. The next four bits are the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveKbdPeek */
static void
primitiveKbdPeek(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioPeekKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((keystrokeWord << 3) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessOrEqual */
static void
primitiveLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerReceiver) & 7) == 1))
	 && ((((integerArgument) & 7) == 1))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver <= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessOrEqualLargeIntegers */
EXPORT(void)
primitiveLessOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr <= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessThan */
static void
primitiveLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerReceiver) & 7) == 1))
	 && ((((integerArgument) & 7) == 1))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver < integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessThanLargeIntegers */
EXPORT(void)
primitiveLessThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr < integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Return the n-th builtin module name. */

	/* InterpreterPrimitives>>#primitiveListBuiltinModule */
static void
primitiveListBuiltinModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord()))), length);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	Primitive. Return the n-th loaded external module name. */

	/* InterpreterPrimitives>>#primitiveListExternalModule */
static void
primitiveListExternalModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord()))), length);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well
	formed. It will return as its value the original array of roots, and the
	erstwhile segmentWordArray will have been truncated to a size of one word,
	i.e. retaining the version
	stamp. If this primitive should fail, the segmentWordArray will, sadly,
	have been reduced to
	an unrecognizable and unusable jumble. But what more could you have done
	with it anyway? */

	/* InterpreterPrimitives>>#primitiveLoadImageSegment */
static void
primitiveLoadImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt outPointerArray;
    sqInt result;
    sqInt segmentWordArray;
    char *sp;

	outPointerArray = longAt(GIV(stackPointer));

	/* Essential type checks */
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((outPointerArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(outPointerArray))) >> (formatShift())) & (formatMask())) == 2))
		 && (((segmentWordArray & (tagMask())) == 0)
		 && (((((((usqInt) (longAt(segmentWordArray))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(segmentWordArray))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1))))))) {

		/* Must be indexable words */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = loadImageSegmentFromoutPointers(segmentWordArray, outPointerArray);
	if (oopisGreaterThan(result, segmentWordArray)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = result;
	}
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

	/* InterpreterPrimitives>>#primitiveLocalMicrosecondClock */
static void
primitiveLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioLocalMicrosecondsNow());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Natural log. */

	/* InterpreterPrimitives>>#primitiveLogN */
static void
primitiveLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt object;
    double rcvr;
    char *sp;

	/* begin popFloat */
	rcvr = floatValueOf(popStack());
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = log(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

	/* InterpreterPrimitives>>#primitiveLowSpaceSemaphore */
static void
primitiveLowSpaceSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask())) == 0)
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord())))))))) {
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */
			if (((arg & (tagMask())) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheLowSpaceSemaphore) << (shiftForWord())), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

	/* InterpreterPrimitives>>#primitiveMakePoint */
static void
primitiveMakePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt pt;
    sqInt rcvr;
    char *sp;
    sqInt tagBits;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((((rcvr) & 7) == 1))
		 || ((((tagBits = rcvr & (tagMask()))) != 0
			? tagBits == (smallFloatTag())
			: ((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin eeInstantiateSmallClass:numSlots: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pt = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pt = newObj;
l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pt)));
	longAtput((pt + BaseHeaderSize) + (((long)XIndex) << (shiftForWord())), rcvr);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pt)));
	longAtput((pt + BaseHeaderSize) + (((long)YIndex) << (shiftForWord())), longAt(GIV(stackPointer)));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), pt);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMaxIdentityHash */
static void
primitiveMaxIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin pop:thenPushInteger: */
	integerVal = identityHashHalfWordMask();
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the method an external primitive was defined in */

	/* InterpreterPrimitives>>#primitiveMethod */
usqInt
primitiveMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

	/* InterpreterPrimitives>>#primitiveMillisecondClock */
static void
primitiveMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((ioMSecs()) & MillisecondClockMask) << 3) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Provide access to the millisecond clock mask to support calculation
	of durations based on the millisecond clock value. */

	/* InterpreterPrimitives>>#primitiveMillisecondClockMask */
EXPORT(sqInt)
primitiveMillisecondClockMask(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((sqInt)MillisecondClockMask << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMod */
static void
primitiveMod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    char *sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt) mod) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((mod << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveModLargeIntegers */
EXPORT(void)
primitiveModLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}

	/* Handle remainder of same sign as argument */
	result = a % b;
	if (!(result == 0)) {
		if (!(bIsNegative == aIsNegative)) {
			result = b - result;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the mouse button state. The low three bits encode the state of the
	<red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveMouseButtons */
static void
primitiveMouseButtons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt buttonWord;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	buttonWord = ioGetButtonState();
	/* begin pushInteger: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), ((buttonWord << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return a Point indicating current position of the mouse. Note that mouse
	coordinates may be negative if the mouse moves above or to the left of the
	top-left corner of the Smalltalk window.
 */

	/* InterpreterPrimitives>>#primitiveMousePoint */
static void
primitiveMousePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt oop;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;
    sqInt x;
    sqInt y;

	pointWord = ioMousePoint();
	/* begin signExtend16: */
	if ((((((usqInt) pointWord) >> 16) & 0xFFFF) & 32768) == 0) {
		x = (((usqInt) pointWord) >> 16) & 0xFFFF;
		goto l1;
	}
	else {
		x = ((((usqInt) pointWord) >> 16) & 0xFFFF) - 65536;
		goto l1;
	}
l1:	/* end signExtend16: */;
	/* begin signExtend16: */
	if (((pointWord & 0xFFFF) & 32768) == 0) {
		y = pointWord & 0xFFFF;
		goto l2;
	}
	else {
		y = (pointWord & 0xFFFF) - 65536;
		goto l2;
	}
l2:	/* end signExtend16: */;
	/* begin pop:thenPush: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l3;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
l3:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((long)XIndex) << (shiftForWord())), ((x << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((long)YIndex) << (shiftForWord())), ((y << 3) | 1));
	oop = pointResult;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMultiply */
static void
primitiveMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		integerRcvr = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		integerArg = (integerPointer1 >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* check for C overflow by seeing if computation is reversible */
		integerResult = integerRcvr * integerArg;
		if ((integerArg == 0)
		 || ((integerResult / integerArg) == integerRcvr)) {
			/* begin pop2AndPushIntegerIfOK: */
			if (!GIV(primFailCode)) {
				if ((((((usqInt) integerResult) >> 60) + 1) & 15) <= 1) {
					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 3) | 1));
					GIV(stackPointer) = sp;
				}
				else {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

				}
			}
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveMultiplyLargeIntegers */
EXPORT(void)
primitiveMultiplyLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if ((a > 1)
	 && ((b > 1)
	 && (a > (0xFFFFFFFFFFFFFFFFULL / b)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a * b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNew */
static void
primitiveNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt classObj;
    sqInt classObj1;
    sqInt err;
    sqInt hash;
    sqInt instSpec;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    sqInt numSlots;
    sqInt obj;
    sqInt oop;
    usqInt p;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    sqInt spaceOkay;

	spaceOkay = 0;
	
	/* For the mirror prims check that the class obj is actually a valid class. */
	if (!((GIV(argumentCount) < 1)
		 || (objCouldBeClassObj(longAt(GIV(stackPointer)))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}

	
	/* Allocate a new fixed-size instance.  Fail if the allocation would leave
	   less than lowSpaceThreshold bytes free. This *will not* cause a GC :-) */
	/* begin instantiateClass: */
	classObj1 = longAt(GIV(stackPointer));
	classFormat = ((longAt((classObj1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
	instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (!((instSpec <= 1)
		 || (instSpec == 5))) {
		obj = null;
		goto l2;
	}
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj1));
	classIndex = (((hash = (long32At(classObj1 + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(classObj1)
				? (((err = enterIntoClassTable(classObj1))) != 0
						? -err
						: (long32At(classObj1 + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		GIV(primFailCode) = -classIndex;
		obj = null;
		goto l2;
	}
	numSlots = classFormat & ((1LL << (fixedFieldsFieldWidth())) - 1);
	/* begin allocateSlots:format:classIndex: */
	if (numSlots >= (numSlotsMask())) {
		if ((((usqInt) numSlots) >> 56) > 0) {
			newObj = null;
			goto l1;
		}
		newObj1 = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj1 = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
		goto l1;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots);
		longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), instSpec, classIndex));
	}
	else {
		longAtput(newObj1, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)instSpec) << (formatShift()))) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj1 % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	newObj = newObj1;
l1:	/* end allocateSlots:format:classIndex: */;
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8) {
			longAtput(p, GIV(nilObj));
		}
	}
	obj = newObj;
l2:	/* end instantiateClass: */;
	if (obj == null) {
		/* begin primitiveFailFor: */
		reasonCode = (isFixedSizePointerFormat(instSpecOfClassFormat(((longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}

}

	/* InterpreterPrimitives>>#primitiveNewMethod */
static void
primitiveNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt hash;
    sqInt header;
    sqInt i;
    usqInt instSpec;
    sqInt literalCount;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    sqInt numSlots;
    usqInt p;
    sqInt reasonCode;
    sqInt size;
    char *sp;
    sqInt theMethod;

	header = longAt(GIV(stackPointer));
	bytecodeCount = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((((header) & 7) == 1))
		 && (((((bytecodeCount) & 7) == 1))
		 && (((bytecodeCount = (bytecodeCount >> 3))) >= 0)))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	class = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	literalCount = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	size = ((literalCount + LiteralStart) * BytesPerOop) + bytecodeCount;
	/* begin instantiateCompiledMethodClass:indexableSize: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
	instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (instSpec != (firstCompiledMethodFormat())) {
		theMethod = null;
		goto l2;
	}
	numSlots = (size + 7) / 8;
	instSpec += (8 - size) & 7;
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(class));
	classIndex = (((hash = (long32At(class + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(class)
				? (((err = enterIntoClassTable(class))) != 0
						? -err
						: (long32At(class + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		GIV(primFailCode) = -classIndex;
		theMethod = null;
		goto l2;
	}
	if (numSlots > ((1LL << (fixedFieldsFieldWidth())) - 1)) {
		if (numSlots > (0x10000000000ULL)) {
			theMethod = null;
			goto l2;
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (((long)(((numSlots < 1) ? 1 : numSlots))) << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), instSpec, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				newObj = null;
				goto l1;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots);
			longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), instSpec, classIndex));
		}
		else {
			longAtput(newObj1, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)instSpec) << (formatShift()))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l1:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8) {
			longAtput(p, 0);
		}
	}
	theMethod = newObj;
l2:	/* end instantiateCompiledMethodClass:indexableSize: */;
	if (!(theMethod)) {
		/* begin primitiveFailFor: */
		reasonCode = (isCompiledMethodFormat(instSpecOfClassFormat(((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
		return;
	}

	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theMethod)));
	longAtput((theMethod + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())), header);
	for (i = 1; i <= literalCount; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theMethod)));
		if (isOldObject(theMethod)) {

			/* most stores into young objects */
			if (((GIV(nilObj) & (tagMask())) == 0)
			 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theMethod))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(theMethod);
				}
			}
		}
		longAtput((theMethod + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

	/* InterpreterPrimitives>>#primitiveNewWithArg */
static void
primitiveNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt classObj;
    sqInt fmt;
    sqInt instSpec;
    sqInt obj;
    sqInt ok;
    sqInt oop;
    sqInt oop1;
    sqInt reasonCode;
    unsigned long size;
    char *sp;
    char *sp1;
    sqInt spaceOkay;
    sqInt value;

	spaceOkay = 0;
	
	/* For the mirror prims check that the class obj is actually a valid class. */
	if (!((GIV(argumentCount) < 2)
		 || (addressCouldBeClassObj(longAt(GIV(stackPointer) + (1 * BytesPerWord)))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}

	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((((oop1) & 7) == 1)) {
		value = (oop1 >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l2;
		}
		size = value;
		goto l2;
	}
	if ((oop1 & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop1)));
	ccIndex = (longAt(oop1)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop1))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((long)(numSlotsOf(oop1))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		size = 
#    if VMBIGENDIAN
			(((((((byteAt((oop1 + BaseHeaderSize))) + (((long)(byteAt((oop1 + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((oop1 + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((oop1 + BaseHeaderSize) + 3))) << 24)) + (((long)(byteAt((oop1 + BaseHeaderSize) + 4))) << 32)) + (((long)(byteAt((oop1 + BaseHeaderSize) + 5))) << 40)) + (((long)(byteAt((oop1 + BaseHeaderSize) + 6))) << 48)) + (((long)(byteAt((oop1 + BaseHeaderSize) + 7))) << 56)
#    else /* VMBIGENDIAN */
			long64At((oop1 + BaseHeaderSize) + (0LL << 3))
#    endif /* VMBIGENDIAN */
			;
		goto l2;
	}
	else {
		size = 
#    if VMBIGENDIAN
			(((byteAt((oop1 + BaseHeaderSize))) + (((long)(byteAt((oop1 + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((oop1 + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((oop1 + BaseHeaderSize) + 3))) << 24)
#    else /* VMBIGENDIAN */
			long32At((oop1 + BaseHeaderSize) + (0LL << 2))
#    endif /* VMBIGENDIAN */
			;
		goto l2;
	}
l2:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {

		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	obj = instantiateClassindexableSize(longAt(GIV(stackPointer) + (1 * BytesPerWord)), size);
	if (obj == null) {
		/* begin instSpecOfClassFormat: */
		instSpec = (((usqInt) (((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3))) >> (fixedFieldsFieldWidth())) & (formatMask());
		/* begin primitiveFailFor: */
		reasonCode = (((instSpec >= 2)
		 && ((instSpec <= (weakArrayFormat()))
		 || (instSpec >= (sixtyFourBitIndexableFormat()))))
		 && (!(instSpec >= (firstCompiledMethodFormat())))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}

}

	/* InterpreterPrimitives>>#primitiveNextInstance */
static void
primitiveNextInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualObj;
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt object;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;
    char *sp;
    sqInt subsequentObject;

	object = longAt(GIV(stackPointer));
	if (!((object & (tagMask())) != 0)) {
		/* begin instanceAfter: */
		actualObj = object;
		classIndex = (longAt(object)) & (classIndexMask());
		if (oopisGreaterThanOrEqualToandLessThan(object, ((eden()).start), GIV(freeStart))) {
			while (1) {
				/* begin objectAfter:limit: */
				numSlots1 = byteAt(actualObj + 7);
				numSlots2 = (numSlots1 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(actualObj - BaseHeaderSize))) << 8)))) >> 8
					: numSlots1);
				if (numSlots2 == 0) {
					slotBytes = 8;
				}
				else {
					slotBytes = ((long)numSlots2) << (shiftForWord());
				}
				followingWordAddress = (actualObj + BaseHeaderSize) + slotBytes;
				if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
					actualObj = GIV(freeStart);
					goto l1;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				actualObj = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
			l1:	/* end objectAfter:limit: */;
				if (!(oopisLessThan(actualObj, GIV(freeStart)))) break;
				if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
					subsequentObject = actualObj;
					goto l4;
				}
			}
			if (oopisGreaterThan(GIV(pastSpaceStart), ((pastSpace()).start))) {
				/* begin objectStartingAt: */
				address = ((pastSpace()).start);
				numSlots = byteAt(address + 7);
				actualObj = (numSlots == (numSlotsMask())
					? address + BaseHeaderSize
					: address);
			}
			else {
				actualObj = GIV(nilObj);
			}
		}
		if (oopisGreaterThanOrEqualToandLessThan(actualObj, ((pastSpace()).start), GIV(pastSpaceStart))) {
			while (1) {
				/* begin objectAfter:limit: */
				numSlots11 = byteAt(actualObj + 7);
				numSlots3 = (numSlots11 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(actualObj - BaseHeaderSize))) << 8)))) >> 8
					: numSlots11);
				if (numSlots3 == 0) {
					slotBytes1 = 8;
				}
				else {
					slotBytes1 = ((long)numSlots3) << (shiftForWord());
				}
				followingWordAddress1 = (actualObj + BaseHeaderSize) + slotBytes1;
				if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart))) {
					actualObj = GIV(pastSpaceStart);
					goto l2;
				}
				flag("endianness");
				followingWord1 = longAt(followingWordAddress1);
				actualObj = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress1 + BaseHeaderSize
					: followingWordAddress1);
			l2:	/* end objectAfter:limit: */;
				if (!(oopisLessThan(actualObj, GIV(pastSpaceStart)))) break;
				if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
					subsequentObject = actualObj;
					goto l4;
				}
			}
			actualObj = GIV(nilObj);
		}
		while (1) {
			/* begin objectAfter:limit: */
			numSlots12 = byteAt(actualObj + 7);
			numSlots4 = (numSlots12 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(actualObj - BaseHeaderSize))) << 8)))) >> 8
				: numSlots12);
			if (numSlots4 == 0) {
				slotBytes2 = 8;
			}
			else {
				slotBytes2 = ((long)numSlots4) << (shiftForWord());
			}
			followingWordAddress2 = (actualObj + BaseHeaderSize) + slotBytes2;
			if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
				actualObj = GIV(endOfMemory);
				goto l3;
			}
			flag("endianness");
			followingWord2 = longAt(followingWordAddress2);
			actualObj = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress2 + BaseHeaderSize
				: followingWordAddress2);
		l3:	/* end objectAfter:limit: */;
			if (!(oopisLessThan(actualObj, GIV(endOfMemory)))) break;
			if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
				subsequentObject = actualObj;
				goto l4;
			}
		}
		subsequentObject = null;
	l4:	/* end instanceAfter: */;
		if (!(subsequentObject == null)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), subsequentObject);
			GIV(stackPointer) = sp;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

	/* InterpreterPrimitives>>#primitiveNextObject */
static void
primitiveNextObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    char *sp;
    char *sp1;

	instance = accessibleObjectAfter(longAt(GIV(stackPointer)));
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((sqInt)0 << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		assert(isInMemory(instance));
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp1;
	}
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

	/* InterpreterPrimitives>>#primitiveNoop */
static void
primitiveNoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

	/* InterpreterPrimitives>>#primitiveNotEqual */
static void
primitiveNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerReceiver) & 7) == 1))
	 && ((((integerArgument) & 7) == 1))) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver != integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (signedMachineIntegerValueOf(integerReceiver)) != (signedMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveNotEqualLargeIntegers */
EXPORT(void)
primitiveNotEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr != integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	is the receiver/first argument not the same object as the (last)
	argument?. pop argumentCount because this can be used as a mirror
	primitive. 
 */

	/* InterpreterPrimitives>>#primitiveNotIdentical */
static void
primitiveNotIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    sqInt referent;
    sqInt referent1;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	if (((otherObject & (tagMask())) == 0)
	 && (((longAt(otherObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		assert(GIV(argumentCount) > 1);
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(thisObject));
		referent = longAt((thisObject + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		otherObject = referent;
	}
	if (((thisObject & (tagMask())) == 0)
	 && (((longAt(thisObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(thisObject));
		referent1 = longAt((thisObject + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent1 & (tagMask())) == 0)
		 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		thisObject = referent1;
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject != otherObject
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

	/* InterpreterPrimitives>>#primitiveObjectAt */
static void
primitiveObjectAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index > 0)
		 && (index <= ((literalCountOfMethodHeader(methodHeaderOf(thisReceiver))) + LiteralStart)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), longAt((thisReceiver + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord()))));
	GIV(stackPointer) = sp;
}


/*	Store a literal into a CompiledMethod at the given index. Defined for
	CompiledMethods only.
 */

	/* InterpreterPrimitives>>#primitiveObjectAtPut */
static void
primitiveObjectAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt newValue;
    char *sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & (tagMask())) != 1)
	 || ((index == ConstOne)
	 && ((newValue & (tagMask())) != 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	index = (index >> 3);
	thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(thisReceiver))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	if (!((index > 0)
		 && (index <= ((literalCountOfMethodHeader(methodHeaderOf(thisReceiver))) + LiteralStart)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(thisReceiver)));
	if (isOldObject(thisReceiver)) {

		/* most stores into young objects */
		if (((newValue & (tagMask())) == 0)
		 && (oopisLessThan(newValue, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(thisReceiver))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(thisReceiver);
			}
		}
	}
	longAtput((thisReceiver + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord())), newValue);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Return the value of the millisecond clock as an integer, using the old
	method prior to the 64-bit microsecond clock.
 */

	/* InterpreterPrimitives>>#primitiveOriginalMillisecondClock */
EXPORT(sqInt)
primitiveOriginalMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((ioOldMSecs()) & MillisecondClockMask) << 3) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	primitivePathTo: anObject using: stack <Array> followWeak: boolean
	Answer a path to anObject from the root that does not pass through
	the current context */

	/* InterpreterPrimitives>>#primitivePathToUsing */
EXPORT(sqInt)
primitivePathToUsing(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt current;
    sqInt err;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt followWeak;
    usqInt freeStartAtStart;
    sqInt goal;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt index;
    sqInt next;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt path;
    char *sp;
    sqInt stack;
    sqInt stackp;
    sqInt stackSize;

	err = 0;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(GIV(argumentCount) >= 2)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	if (!(((longAt(GIV(stackPointer))) == GIV(trueObj))
		 || ((longAt(GIV(stackPointer))) == GIV(falseObj)))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	/* begin pathTo:using:followWeak: */
	goal = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	stack = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	followWeak = (longAt(GIV(stackPointer))) == GIV(trueObj);
	if (!(((stack & (tagMask())) == 0)
		 && (((((usqInt) (longAt(stack))) >> (formatShift())) & (formatMask())) == 2))) {
		err = PrimErrBadArgument;
		goto l4;
	}
	assert(allObjectsUnmarked());

	/* check no allocations during search */
	freeStartAtStart = freeStart();
	beRootIfOld(stack);
	/* begin lengthOf:format: */
	fmt1 = (((usqInt) (longAt(stack))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(stack + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(stack - BaseHeaderSize))) << 8)))) >> 8
		: numSlots11);
	if (fmt1 <= 5) {
		stackSize = numSlots2;
		goto l2;
	}
	if (fmt1 >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		stackSize = (((long)numSlots2) << (shiftForWord())) - (fmt1 & 7);
		goto l2;
	}
	if (fmt1 >= (firstShortFormat())) {
		stackSize = (((long)numSlots2) << ((shiftForWord()) - 1)) - (fmt1 & 3);
		goto l2;
	}
	if (fmt1 >= (firstLongFormat())) {
		stackSize = (((long)numSlots2) << ((shiftForWord()) - 2)) - (fmt1 & 1);
		goto l2;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat())) {
		stackSize = numSlots2;
		goto l2;
	}
	stackSize = 0;
l2:	/* end lengthOf:format: */;
	/* begin mark: */
	assert(!(isFreeObject(stack)));
	longAtput(stack, (longAt(stack)) | (1LL << 55));
	current = GIV(specialObjectsOop);
	/* begin mark: */
	assert(!(isFreeObject(current)));
	longAtput(current, (longAt(current)) | (1LL << 55));
	/* begin lengthOf:format: */
	fmt2 = (((usqInt) (longAt(current))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots12 = byteAt(current + 7);
	numSlots3 = (numSlots12 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(current - BaseHeaderSize))) << 8)))) >> 8
		: numSlots12);
	if (fmt2 <= 5) {
		index = numSlots3;
		goto l3;
	}
	if (fmt2 >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		index = (((long)numSlots3) << (shiftForWord())) - (fmt2 & 7);
		goto l3;
	}
	if (fmt2 >= (firstShortFormat())) {
		index = (((long)numSlots3) << ((shiftForWord()) - 1)) - (fmt2 & 3);
		goto l3;
	}
	if (fmt2 >= (firstLongFormat())) {
		index = (((long)numSlots3) << ((shiftForWord()) - 2)) - (fmt2 & 1);
		goto l3;
	}
	if (fmt2 == (sixtyFourBitIndexableFormat())) {
		index = numSlots3;
		goto l3;
	}
	index = 0;
l3:	/* end lengthOf:format: */;
	stackp = 0;
	while(1) {
		while (((index -= 1)) >= -1) {
			if ((((((usqInt)current)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)current)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)current)) <= (((usqInt)GIV(pages))))))) {
				if (index >= 0) {
					next = fieldofFrame(index, ((char *) current));
				}
				else {
					next = GIV(nilObj);
				}
			}
			else {
				if (index >= 0) {
					if (((longAt(current)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						next = fieldOrSenderFPofContext(index, current);
					}
					else {
						next = longAt((current + BaseHeaderSize) + (((long)index) << (shiftForWord())));
					}
				}
				else {
					next = fetchClassOfNonImm(current);
				}
			}
			if ((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))) {
				assert(isFrameonPage(((char *) next), stackPageFor(((char *) next))));
			}
			else {
				assert(checkOkayOop(next));
			}
			if (next == goal) {
				assert(freeStartAtStart == (freeStart()));
				unmarkAfterPathTo();
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				if (isOldObject(stack)) {

					/* most stores into young objects */
					if (((current & (tagMask())) == 0)
					 && (oopisLessThan(current, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(stack))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(stack);
						}
					}
				}
				longAtput((stack + BaseHeaderSize) + (((long)stackp) << (shiftForWord())), current);
				pruneStackstackp(stack, stackp);
				err = 0;
				goto l4;
			}
			if (((next & (tagMask())) != 1)
			 && (((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))
				? !(((longAt(next + FoxFrameFlags)) & 2) != 0)
				: (!(((((usqInt) (longAt(next))) >> 55) & 1) != 0))
					 && (((((next & (tagMask())) == 0)
					 && (((((usqInt) (longAt(next))) >> (formatShift())) & (formatMask())) <= 5))
					 || (((((usqInt) (longAt(next))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
					 && (followWeak
					 || (!(isWeakFormat((((usqInt) (longAt(next))) >> (formatShift())) & (formatMask()))))))))) {
				if ((stackp + 2) > stackSize) {
					assert(freeStartAtStart == (freeStart()));
					unmarkAfterPathTo();
					/* begin nilFieldsOf: */
					for (i = 0, iLimiT = ((numSlotsOf(stack)) - 1); i <= iLimiT; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(stack)));
						longAtput((stack + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
					}
					err = PrimErrBadIndex;
					goto l4;
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + (((long)stackp) << (shiftForWord())), current);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + (((long)(stackp + 1)) << (shiftForWord())), ((index << 3) | 1));
				stackp += 2;
				if ((((((usqInt)(((char *) next)))) & (BytesPerWord - 1)) == 0)
				 && ((((((usqInt)(((char *) next)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) next)))) <= (((usqInt)GIV(pages))))))) {
					/* begin markFrame: */
					longAtput(next + FoxFrameFlags, (longAt(next + FoxFrameFlags)) | 2);
					index = CtxtTempFrameStart + (stackPointerIndexForFrame(((char *) next)));
				}
				else {
					/* begin mark: */
					assert(!(isFreeObject(next)));
					longAtput(next, (longAt(next)) | (1LL << 55));
					if (((((usqInt) (longAt(next))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
						index = (literalCountOfMethodHeader(methodHeaderOf(next))) + LiteralStart;
					}
					else {
						/* begin lengthOf:format: */
						fmt = (((usqInt) (longAt(next))) >> (formatShift())) & (formatMask());
						/* begin numSlotsOfAny: */
						numSlots1 = byteAt(next + 7);
						numSlots = (numSlots1 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(next - BaseHeaderSize))) << 8)))) >> 8
							: numSlots1);
						if (fmt <= 5) {
							index = numSlots;
							goto l1;
						}
						if (fmt >= (firstByteFormat())) {

							/* bytes, including CompiledMethod */
							index = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
							goto l1;
						}
						if (fmt >= (firstShortFormat())) {
							index = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
							goto l1;
						}
						if (fmt >= (firstLongFormat())) {
							index = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
							goto l1;
						}
						if (fmt == (sixtyFourBitIndexableFormat())) {
							index = numSlots;
							goto l1;
						}
						index = 0;
					l1:	/* end lengthOf:format: */;
					}
				}
				current = next;
			}
		}
		if (current == GIV(specialObjectsOop)) {
			assert(freeStartAtStart == (freeStart()));
			unmarkAfterPathTo();
			/* begin nilFieldsOf: */
			for (i1 = 0, iLimiT1 = ((numSlotsOf(stack)) - 1); i1 <= iLimiT1; i1 += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + (((long)i1) << (shiftForWord())), GIV(nilObj));
			}
			err = PrimErrNotFound;
			goto l4;
		}
		index = ((longAt((stack + BaseHeaderSize) + (((long)(stackp - 1)) << (shiftForWord())))) >> 3);
		current = longAt((stack + BaseHeaderSize) + (((long)(stackp - 2)) << (shiftForWord())));
		stackp -= 2;
	}
l4:	/* end pathTo:using:followWeak: */;
	if (err != 0) {
		return (GIV(primFailCode) = err);
	}
	path = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), path);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitivePerformInSuperclass */
static void
primitivePerformInSuperclass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt currentClass;
    sqInt delta;
    sqInt err;
    sqInt errorCode;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt lookupClass;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt nItems;
    sqInt numArgs;
    usqInt numSlots;
    sqInt numTemps;
    sqInt object;
    sqInt objOop;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    sqInt rcvr1;
    char *savedFramePointer;
    char *savedStackPointer;
    sqInt selector;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt tagBits2;
    sqInt top;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	lookupClass = longAt(GIV(stackPointer));
	if ((GIV(argumentCount) > 3)
	 && (((rcvr & (tagMask())) == 0)
	 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((tagBits = rcvr & (tagMask()))) != 0) {
		currentClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())));
	}
	else {
		currentClass = fetchClassOfNonImm(rcvr);
	}
	while (currentClass != lookupClass) {
		/* begin followField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop & (tagMask())) == 0)
		 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop);
		}
		currentClass = objOop;
		if (currentClass == GIV(nilObj)) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
	}
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	selector = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l3;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(argumentArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l3;
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and the args in the array. */
	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), rcvr);
	findNewMethodInClassTag((lookupClass == null
		? (((tagBits1 = rcvr & (tagMask()))) != 0
				? tagBits1
				: (longAt(rcvr)) & (classIndexMask()))
		: (/* begin classTagForClass: */
			assert(addressCouldBeClassObj(lookupClass)),
			/* begin ensureBehaviorHash: */
			assert(addressCouldBeClassObj(lookupClass)),
			(((hash = (long32At(lookupClass + 4)) & (identityHashHalfWordMask()))) != 0
					? hash
					: (objCouldBeClassObj(lookupClass)
							? (((err = enterIntoClassTable(lookupClass))) != 0
									? -err
									: (long32At(lookupClass + 4)) & (identityHashHalfWordMask()))
							: -PrimErrBadReceiver)))));
	if ((((GIV(newMethod) & (tagMask())) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop()) == ((arraySize == 0
			? rcvr
			: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		nItems = arraySize + 1;
		GIV(stackPointer) += nItems * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l3;
	}

	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr1)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((int) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader1)) < 0
								? AltLongStoreBytecode
								: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 3) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
l3:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}

	/* InterpreterPrimitives>>#primitivePerformWithArgs */
static void
primitivePerformWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualReceiver;
    sqInt argumentArray;
    usqInt arraySize;
    sqInt delta;
    sqInt err;
    sqInt errorCode;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt nItems;
    sqInt numArgs;
    usqInt numSlots;
    sqInt numTemps;
    sqInt object;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    sqInt selector;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt top;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	actualReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	selector = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l3;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(argumentArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l3;
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and the args in the array. */
	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), actualReceiver);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), actualReceiver);
	findNewMethodInClassTag((((tagBits1 = actualReceiver & (tagMask()))) != 0
		? tagBits1
		: (longAt(actualReceiver)) & (classIndexMask())));
	if ((((GIV(newMethod) & (tagMask())) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop()) == ((arraySize == 0
			? actualReceiver
			: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		nItems = arraySize + 1;
		GIV(stackPointer) += nItems * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l3;
	}

	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((int) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader1)) < 0
								? AltLongStoreBytecode
								: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 3) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
l3:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}


/*	Primitive. Answer the last primitive method sampled by the profiler. */

	/* InterpreterPrimitives>>#primitiveProfilePrimitive */
EXPORT(sqInt)
primitiveProfilePrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileMethod));
	GIV(stackPointer) = sp;
	GIV(profileMethod) = GIV(nilObj);
}


/*	Primitive. Answer the last sample taken by the profiler, or nil if the
	profiler isn't active.
	See also primitiveProfileStart.
 */

	/* InterpreterPrimitives>>#primitiveProfileSample */
EXPORT(sqInt)
primitiveProfileSample(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileProcess));
	GIV(stackPointer) = sp;
	GIV(profileProcess) = GIV(nilObj);
}


/*	Primitive. Install the semaphore to be used for profiling, 
	or nil if no semaphore should be used.
	See also primitiveProfileStart. */

	/* InterpreterPrimitives>>#primitiveProfileSemaphore */
EXPORT(sqInt)
primitiveProfileSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;

	if (!(GIV(argumentCount) == 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((sema == GIV(nilObj))
		 || (((sema & (tagMask())) == 0)
		 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord()))))))))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	GIV(profileSemaphore) = sema;
	GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj));
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Primitive. Begin profiling execution every by using the interrupt
	check-counter instead of a time-based process (which is limited to timing
	resolution and triggers off the same signal that many of the processes
	being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let
	go by before taking a sample. The sample is being stored in the
	profileSample iVar which can be retrieved by executing
	primitiveProfileSample. When a sample is taken, it signals the semaphore
	specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling.
 */

	/* InterpreterPrimitives>>#primitiveProfileStart */
EXPORT(sqInt)
primitiveProfileStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaTicks;
    sqInt integerPointer;

	if (!(GIV(argumentCount) == 1)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		deltaTicks = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		deltaTicks = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(nextProfileTick) = (ioHighResClock()) + deltaTicks;
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveQuit */
static void
primitiveQuit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioExitWithErrorCode((GIV(argumentCount) == 1
		? ((longAt(GIV(stackPointer))) >> 3)
		: 0));
}


/*	Rounds negative results towards zero. */

	/* InterpreterPrimitives>>#primitiveQuo */
static void
primitiveQuo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	integerResult = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		integerRcvr = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		integerArg = (integerPointer1 >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(integerArg != 0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		integerResult = (integerRcvr > 0
			? (integerArg > 0
					? integerRcvr / integerArg
					: 0 - (integerRcvr / (0 - integerArg)))
			: (integerArg > 0
					? 0 - ((0 - integerRcvr) / integerArg)
					: (0 - integerRcvr) / (0 - integerArg)));
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt) integerResult) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveQuoLargeIntegers */
EXPORT(void)
primitiveQuoLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

	/* InterpreterPrimitives>>#primitiveRelinquishProcessor */
static void
primitiveRelinquishProcessor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		microSecs = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		microSecs = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* DO NOT allow relinquishing the processor while we are profiling since this
		   may skew the time base for our measures (it may reduce processor speed etc).
		   Instead we go full speed, therefore measuring the precise time we spend in the
		   inner idle loop as a busy loop. */
		if (GIV(nextProfileTick) == 0) {
			ioRelinquishProcessorForMicroseconds(microSecs);
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveRemLargeIntegers */
EXPORT(void)
primitiveRemLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a % b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is
	a chance for processes of it's priority level. It must go to the back of
	its run queue so
	as not to preempt any already running processes at this level. If the
	process's priority
	is higher than the current process, preempt the current process. */

	/* InterpreterPrimitives>>#primitiveResume */
static void
primitiveResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt proc;


	/* rcvr */
	proc = longAt(GIV(stackPointer));
	if (!(isContext(longAt((proc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	resumepreemptedYieldingIf(proc, GIV(preemptionYields));
}


/*	The character scanner primitive. */

	/* InterpreterPrimitives>>#primitiveScanCharacters */
static void
primitiveScanCharacters(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		kernDelta = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		kernDelta = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		stops = null;
		goto l2;
	}
	stops = oop;
l2:	/* end stackObjectValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		scanRightX = (integerPointer1 >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanRightX = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((oop1 & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		sourceString = null;
		goto l4;
	}
	sourceString = oop1;
l4:	/* end stackObjectValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer2) & 7) == 1)) {
		scanStopIndex = (integerPointer2 >> 3);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStopIndex = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (5 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer3) & 7) == 1)) {
		scanStartIndex = (integerPointer3 >> 3);
		goto l6;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStartIndex = 0;
		goto l6;
	}
l6:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop2 = longAt(GIV(stackPointer) + (6 * BytesPerWord));
	if ((oop2 & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l7;
	}
	rcvr = oop2;
l7:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	if (!(((stops & (tagMask())) == 0)
		 && (((((usqInt) (longAt(stops))) >> (formatShift())) & (formatMask())) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((slotSizeOf(stops)) >= 258)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(((sourceString & (tagMask())) == 0)
		 && (((((usqInt) (longAt(sourceString))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
		 && (scanStopIndex <= (byteSizeOf(sourceString)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((((rcvr & (tagMask())) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= 5))
		 && ((slotSizeOf(rcvr)) >= 4))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + BaseHeaderSize) + (2LL << (shiftForWord())));
	scanMap = longAt((rcvr + BaseHeaderSize) + (3LL << (shiftForWord())));
	if (!((((scanXTable & (tagMask())) == 0)
		 && (((((usqInt) (longAt(scanXTable))) >> (formatShift())) & (formatMask())) == 2))
		 && (((scanMap & (tagMask())) == 0)
		 && (((((usqInt) (longAt(scanMap))) >> (formatShift())) & (formatMask())) == 2)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((slotSizeOf(scanMap)) == 256)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (GIV(primFailCode)) {
		return;
	}

	/* Okay, here we go. We have eliminated nearly all failure
	   conditions, to optimize the inner fetches. */
	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */

		/* Known to be okay since stops size >= 258 */
		ascii = byteAt((sourceString + BaseHeaderSize) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + BaseHeaderSize) + (((long)ascii) << (shiftForWord()))))) == nilOop)) {

			/* Store everything back and get out of here since some stop conditionn needs to be checked */
			if (!((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (0LL << (shiftForWord())), ((scanDestX << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt) scanLastIndex) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (1LL << (shiftForWord())), ((scanLastIndex << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop: */
			GIV(stackPointer) += 7 * BytesPerWord;
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), stopReason);
			GIV(stackPointer) = sp;
			return;
		}

		/* fail if the glyphIndex is out of range */
		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if (GIV(primFailCode)
		 || ((glyphIndex < 0)
		 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);

		/* Above may fail if non-integer entries in scanXTable */
		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (GIV(primFailCode)) {
			return;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {

			/* Store everything back and get out of here since we got to the right edge */
			if (!((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (0LL << (shiftForWord())), ((scanDestX << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt) scanLastIndex) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (1LL << (shiftForWord())), ((scanLastIndex << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + BaseHeaderSize) + (((long)(CrossedX - 1)) << (shiftForWord()))));
			GIV(stackPointer) = sp1;
			return;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqInt) scanDestX) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(rcvr)));
		longAtput((rcvr + BaseHeaderSize) + (0LL << (shiftForWord())), ((scanDestX << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqInt) scanStopIndex) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(rcvr)));
		longAtput((rcvr + BaseHeaderSize) + (1LL << (shiftForWord())), ((scanStopIndex << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + BaseHeaderSize) + (((long)(EndOfRun - 1)) << (shiftForWord()))));
	GIV(stackPointer) = sp2;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

	/* InterpreterPrimitives>>#primitiveScreenDepth */
EXPORT(sqInt)
primitiveScreenDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    char *sp;

	depth = ioScreenDepth();
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((depth << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Answer a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the
	point is encoded into a single 32bit value in the image header.
	This might well become a problem one day */

	/* InterpreterPrimitives>>#primitiveScreenSize */
static void
primitiveScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt oop;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;

	pointWord = ioScreenSize();
	/* begin pop:thenPush: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((long)XIndex) << (shiftForWord())), ((((((usqInt) pointWord) >> 16) & 0xFFFF) << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((long)YIndex) << (shiftForWord())), (((pointWord & 0xFFFF) << 3) | 1));
	oop = pointResult;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

	/* InterpreterPrimitives>>#primitiveSecondsClock */
static void
primitiveSecondsClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	integerValue = ioSecondsNow();
	oop = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
	goto l1;

l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Set to OS to the requested display mode.
	See also DisplayScreen setDisplayDepth:extent:fullscreen: */

	/* InterpreterPrimitives>>#primitiveSetDisplayMode */
static void
primitiveSetDisplayMode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt okay;
    char *sp;
    sqInt w;

	okay = 0;
	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	fsFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		h = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		w = (integerPointer1 >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer2) & 7) == 1)) {
		d = (integerPointer2 >> 3);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		d = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioSetDisplayMode(w, h, d, fsFlag);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((5 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

	/* InterpreterPrimitives>>#primitiveSetFullScreen */
static void
primitiveSetFullScreen(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveSetImmutability */
static void
primitiveSetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt wasImmutable;

	
#  if IMMUTABILITY
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & (tagMask())) != 0) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	wasImmutable = 
#  if IMMUTABILITY
		((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		if (!(canBeImmutable(rcvr))) {
			(GIV(primFailCode) = PrimErrInappropriate);
			return;
		}
		/* begin setIsImmutableOf:to: */
		longAtput(rcvr, (longAt(rcvr)) | (1LL << 23));
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			/* begin setIsImmutableOf:to: */
			longAtput(rcvr, (longAt(rcvr)) & (~(1LL << 23)));
		}
		else {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (wasImmutable
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;

#  else /* IMMUTABILITY */
	GIV(primFailCode) = PrimErrUnsupported;

#  endif /* IMMUTABILITY */

}


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

	/* InterpreterPrimitives>>#primitiveSetInterruptKey */
static void
primitiveSetInterruptKey(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		keycode = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		keycode = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		/* begin setInterruptKeycode: */
		GIV(interruptKeycode) = keycode;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Set the VM's log directory */

	/* InterpreterPrimitives>>#primitiveSetLogDirectory */
EXPORT(sqInt)
primitiveSetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;
    sqInt stringOop;
    sqInt sz;

	stringOop = longAt(GIV(stackPointer));
	if (!(((stringOop & (tagMask())) == 0)
		 && (((((usqInt) (longAt(stringOop))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin byteSizeOf: */
	if ((stringOop & (tagMask())) != 0) {
		sz = 0;
		goto l1;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(stringOop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(stringOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(stringOop + 7);
	numBytes = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(stringOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	numBytes = ((long)numBytes) << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		sz = numBytes - (fmt & 7);
		goto l2;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		sz = numBytes;
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		sz = numBytes - (((long)(fmt & 3)) << 1);
		goto l2;
	}
	sz = numBytes - (((long)(fmt & 1)) << 2);
l2:	/* end numBytesOf: */;
l1:	/* end byteSizeOf: */;
	ioSetLogDirectoryOfSize(firstIndexableField(stringOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveSetOrHasIdentityHash */
static void
primitiveSetOrHasIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasHash;
    sqInt hash;
    sqInt hash1;
    sqInt integerPointer;
    sqInt oldHash;
    sqInt oop;
    char *sp;
    char *sp1;
    sqInt thisReceiver;

	if (GIV(argumentCount) == 0) {
		hasHash = (((longAt(GIV(stackPointer))) & (tagMask())) == 0)
		 && ((long32At((longAt(GIV(stackPointer))) + 4)) & (identityHashHalfWordMask()));
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (hasHash
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		hash = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		hash = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		thisReceiver = null;
		goto l2;
	}
	thisReceiver = oop;
l2:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin hashBitsOf: */
		hash1 = (long32At(thisReceiver + 4)) & (identityHashHalfWordMask());
		if (hash1 == 0) {

			/* would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */
			hash1 = (newObjectHash()) & (identityHashHalfWordMask());
			/* begin setHashBitsOf:to: */
			flag("endianness");
			assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
			long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
		}
		oldHash = hash1;
		/* begin setHashBitsOf:to: */
		flag("endianness");
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
		/* begin pop:thenPushInteger: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((oldHash << 3) | 1));
		GIV(stackPointer) = sp1;
	}
}


/*	Primitive. Set the OS window's label */

	/* InterpreterPrimitives>>#primitiveSetWindowLabel */
EXPORT(sqInt)
primitiveSetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt labelOop;
    usqInt numBytes;
    usqInt numSlots;
    sqInt sz;

	labelOop = longAt(GIV(stackPointer));
	if (!(((labelOop & (tagMask())) == 0)
		 && (((((usqInt) (longAt(labelOop))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin byteSizeOf: */
	if ((labelOop & (tagMask())) != 0) {
		sz = 0;
		goto l1;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(labelOop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(labelOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(labelOop + 7);
	numBytes = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(labelOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	numBytes = ((long)numBytes) << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		sz = numBytes - (fmt & 7);
		goto l2;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		sz = numBytes;
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		sz = numBytes - (((long)(fmt & 3)) << 1);
		goto l2;
	}
	sz = numBytes - (((long)(fmt & 1)) << 2);
l2:	/* end numBytesOf: */;
l1:	/* end byteSizeOf: */;
	ioSetWindowLabelOfSize(firstIndexableField(labelOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveSetWindowSize */
EXPORT(sqInt)
primitiveSetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt w;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		h = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		w = (integerPointer1 >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioSetWindowWidthHeight(w, h);
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Treat the receiver, which can be indexible by either bytes or words, as
	an array of signed 16-bit values. Answer the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word.  */

	/* InterpreterPrimitives>>#primitiveShortAt */
static void
primitiveShortAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((((index) & 7) == 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & (tagMask())) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	index = (index >> 3);
	if (!((index >= 1)
		 && (index <= (((usqInt) (numBytesOf(rcvr))) >> 1)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	value = shortAt((rcvr + BaseHeaderSize) + (((long)(index - 1)) << 1));
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

	/* InterpreterPrimitives>>#primitiveShortAtPut */
static void
primitiveShortAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((((value) & 7) == 1))
		 && (((((index) & 7) == 1))
		 && (((value = (value >> 3)),
		(value >= -32768)
			 && (value <= 0x7FFF)))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & (tagMask())) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	index = (index >> 3);
	if (!((index >= 1)
		 && (index <= (((usqInt) (numBytesOf(rcvr))) >> 1)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	shortAtput((rcvr + BaseHeaderSize) + (((long)(index - 1)) << 1), value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), ((value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

	/* InterpreterPrimitives>>#primitiveShowDisplayRect */
static void
primitiveShowDisplayRect(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt left;
    sqInt right;
    sqInt top;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		bottom = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bottom = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		top = (integerPointer1 >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		top = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer2) & 7) == 1)) {
		right = (integerPointer2 >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		right = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer3) & 7) == 1)) {
		left = (integerPointer3 >> 3);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		left = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	displayBitsOfLeftTopRightBottom(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheDisplay) << (shiftForWord()))), left, top, right, bottom);
	if (!GIV(primFailCode)) {
		ioForceDisplayUpdate();
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
	}
}


/*	Synchronously signal the semaphore.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveSignal */
static void
primitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	synchronousSignal(longAt(GIV(stackPointer)));
}


/*	Set the low-water mark for free space. When the free space falls
	below this level, the new and new: primitives fail and system attempts
	to allocate space (e.g., to create a method context) cause the low-space
	semaphore (if one is registered) to be signalled. */

	/* InterpreterPrimitives>>#primitiveSignalAtBytesLeft */
static void
primitiveSignalAtBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;

	bytes = longAt(GIV(stackPointer));
	if (((((bytes) & 7) == 1))
	 && (((bytes = (bytes >> 3))) >= 0)) {
		/* begin lowSpaceThreshold: */
		GIV(lowSpaceThreshold) = bytes;
		if (GIV(totalFreeOldSpace) < bytes) {
			growOldSpaceByAtLeast(bytes - GIV(totalFreeOldSpace));
		}
		assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

	/* InterpreterPrimitives>>#primitiveSine */
static void
primitiveSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt object;
    double rcvr;
    char *sp;

	/* begin popFloat */
	rcvr = floatValueOf(popStack());
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = sin(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveSize */
static void
primitiveSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	if (((rcvr & (tagMask())) != 0)
	 || (((hdr = long64At(rcvr)),
	((fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask()))) < 2))) {

		/* This is not an indexable object */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		primitiveContextSize();
		return;
	}
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l1;
	}
	totalLength = 0;
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l2:	/* end fixedFieldsOf:format:length: */;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((totalLength - fixedFields) << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSizeInBytes */
static void
primitiveSizeInBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong byteSize;
    sqInt oop;
    char *sp;

	byteSize = (((longAt(GIV(stackPointer))) & (tagMask())) != 0
		? 0
		: bytesInObject(longAt(GIV(stackPointer))));
	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(byteSize);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer the byte size of an instance of the receiver. If num args > 0
	then the last argument is a variable size and the size answered is the
	size of an instance of the receiver with that many indexable elements. */

	/* InterpreterPrimitives>>#primitiveSizeInBytesOfInstance */
static void
primitiveSizeInBytesOfInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byteSize;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt code;
    sqInt err;
    sqInt instSpec;
    sqInt instSpec1;
    sqInt nElements;
    usqInt numSlots;
    sqInt numSlots1;
    sqInt oop;
    char *sp;
    char *sp1;

	
	/* Support VMMirror>>byteSizeOfInstanceOf:WithIndexableVariables: */
	if (GIV(argumentCount) > 2) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}

	err = -1;
	if (GIV(argumentCount) >= 1) {
		if (!(((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		/* begin byteSizeOfInstanceOf:withIndexableSlots:errInto: */
		nElements = ((longAt(GIV(stackPointer))) >> 3);
		classFormat = ((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
		instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
		
		switch (instSpec) {
		case 2:
			numSlots = nElements;
			break;
		case indexablePointersFormat():
		case weakArrayFormat():
			numSlots = (classFormat & ((1LL << (fixedFieldsFieldWidth())) - 1)) + nElements;
			break;
		case sixtyFourBitIndexableFormat():
			numSlots = nElements;
			break;
		case firstLongFormat():
			numSlots = (nElements + 1) / 2;
			break;
		case firstShortFormat():
			numSlots = (nElements + 3) / 4;
			break;
		case firstByteFormat():
		case firstCompiledMethodFormat():
			numSlots = (nElements + (BytesPerOop - 1)) / BytesPerOop;
			break;
		default:
			code = -PrimErrBadReceiver;
			byteSize = (err = code);

			goto l1;

		}
		if (numSlots >= (((long)(((long)1))) << ((BytesPerOop * 8) - 3))) {
			code = (nElements < 0
				? PrimErrBadArgument
				: PrimErrLimitExceeded);
			byteSize = (err = code);

			goto l1;
		}
		byteSize = (((long)(((numSlots < 1) ? 1 : numSlots))) << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize));
	l1:	/* end byteSizeOfInstanceOf:withIndexableSlots:errInto: */;
		if (err >= 0) {
			(GIV(primFailCode) = err);
			return;
		}
		/* begin pop:thenPush: */
		oop = positive64BitIntegerFor(byteSize);
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOfInstanceOf:errInto: */
	classFormat1 = ((longAt(((longAt(GIV(stackPointer) + (0 * BytesPerWord))) + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
	instSpec1 = (((usqInt) classFormat1) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (!((instSpec1 <= 1)
		 || (instSpec1 == 5))) {
		byteSize = (err = PrimErrBadReceiver);

		goto l2;
	}
	numSlots1 = classFormat1 & ((1LL << (fixedFieldsFieldWidth())) - 1);
	byteSize = (((long)(((numSlots1 < 1) ? 1 : numSlots1))) << (shiftForWord())) + ((numSlots1 >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize));
l2:	/* end byteSizeOfInstanceOf:errInto: */;
	if (err >= 0) {
		(GIV(primFailCode) = err);
		return;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((byteSize << 3) | 1));
	GIV(stackPointer) = sp1;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatAdd */
static void
primitiveSmallFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatArctan */
static void
primitiveSmallFloatArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bits;
    double f;
    sqInt oop;
    double rcvr;
    sqInt rot;
    char *sp;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin pop:thenPushFloat: */
	f = atan(rcvr);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(f));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatDivide */
static void
primitiveSmallFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (arg == 0.0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatEqual */
static void
primitiveSmallFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr == arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Computes E raised to the receiver power.
	Since SmallFloats cannot represent NaNs there's no need to special case. */

	/* InterpreterPrimitives>>#primitiveSmallFloatExp */
static void
primitiveSmallFloatExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    char *sp;

	/* begin pop:thenPushFloat: */
	f = exp(smallFloatValueOf(longAt(GIV(stackPointer))));
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(f));
	GIV(stackPointer) = sp;
}


/*	Answer the exponent part of this float. */

	/* InterpreterPrimitives>>#primitiveSmallFloatExponent */
static void
primitiveSmallFloatExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin pop:thenPushInteger: */
	integerVal = (exponentOfSmallFloat(longAt(GIV(stackPointer)))) - 1;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatFractionalPart */
static void
primitiveSmallFloatFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bits;
    double frac;
    sqInt oop;
    double rcvr;
    sqInt rot;
    char *sp;
    double trunc;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	frac = modf(rcvr, (&trunc));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(frac));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatGreaterOrEqual */
static void
primitiveSmallFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr >= arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatGreaterThan */
static void
primitiveSmallFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr > arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatLessOrEqual */
static void
primitiveSmallFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr <= arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatLessThan */
static void
primitiveSmallFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (rcvr < arg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Natural log. */

	/* InterpreterPrimitives>>#primitiveSmallFloatLogN */
static void
primitiveSmallFloatLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bits;
    double f;
    sqInt oop;
    double rcvr;
    sqInt rot;
    char *sp;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin pop:thenPushFloat: */
	f = log(rcvr);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(f));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatMultiply */
static void
primitiveSmallFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatNotEqual */
static void
primitiveSmallFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (!(rcvr == arg)
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSine */
static void
primitiveSmallFloatSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bits;
    double f;
    sqInt oop;
    double rcvr;
    sqInt rot;
    char *sp;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin pop:thenPushFloat: */
	f = sin(rcvr);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(f));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSquareRoot */
static void
primitiveSmallFloatSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    char *sp;

	/* begin pop:thenPushFloat: */
	f = sqrt(smallFloatValueOf(longAt(GIV(stackPointer))));
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(f));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSubtract */
static void
primitiveSmallFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt bits;
    sqInt bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    sqInt rot;
    sqInt rot1;
    sqInt shift;
    char *sp;
    sqInt tagBits;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	/* begin loadFloatOrIntFrom: */
	floatOrIntOop = longAt(GIV(stackPointer));
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((usqInt) (((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot1 += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot1 = (((long)rot1) << 0x3F) + (((usqInt) (((unsigned long)rot1))) >> 1);
			bits1 = rot1;
			arg = (((double *) ((&bits1))))[0];
			goto l1;
		}
		if ((tagBits == 1)
		 && (((shift = (64 - (numTagBits())) - (smallFloatMantissaBits())),
		(((sqInt) (((long)floatOrIntOop) << shift)) >> shift) == floatOrIntOop))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l1;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l1:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
}


/*	Multiply the receiver by the power of the argument. */

	/* InterpreterPrimitives>>#primitiveSmallFloatTimesTwoPower */
static void
primitiveSmallFloatTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt rcvr;
    sqInt result;
    char *sp;
    sqInt twiceMaxExponent;

	arg = longAt(GIV(stackPointer));
	if (!((((arg) & 7) == 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}

	/* N.B. SmallFloats are finite.  NaN and Infinity overflow into boxed floats.
	   This is doing range checking work that is done in ldexp, but we include
	   it explicitly to exemplify bit manipulation of SmallFloats. */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (isSmallFloatZero(rcvr)) {
		result = rcvr;
	}
	else {
		arg = (arg >> 3);
		twiceMaxExponent = 2 * (1LL << 11);
		if (arg < (-twiceMaxExponent)) {
			/* begin mapSignedSmallFloatToSignedSmallFloatZero: */
			assert(isImmediateFloat(rcvr));
			result = rcvr & ((1LL << (numTagBits())) + (tagMask()));
		}
		else {

			/* clip arg to at most int range; ldexp's last arg is of type int */
			if (arg > twiceMaxExponent) {
				arg = twiceMaxExponent;
			}
			result = floatObjectOf(ldexp(smallFloatValueOf(rcvr), ((int) arg)));
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatTruncated */
static void
primitiveSmallFloatTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bits;
    sqInt oop;
    double rcvr;
    sqInt rot;
    char *sp;
    double trunc;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	rcvr = (((double *) ((&bits))))[0];
	modf(rcvr, (&trunc));
	if (((trunc >= (((double) (MinSmallInteger) ))) && (trunc <= (((double) (MaxSmallInteger) ))))) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((((sqInt)trunc)) << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	save a normal snapshot under the same name as it was loaded unless it has
	been renamed by the last primitiveImageName
 */

	/* InterpreterPrimitives>>#primitiveSnapshot */
static void
primitiveSnapshot(void)
{
	snapshot(0);
}


/*	save an embedded snapshot */

	/* InterpreterPrimitives>>#primitiveSnapshotEmbedded */
static void
primitiveSnapshotEmbedded(void)
{
	snapshot(1);
}

	/* InterpreterPrimitives>>#primitiveSomeInstance */
static void
primitiveSomeInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt instance;
    char *sp;

	class = longAt(GIV(stackPointer));
	
	/* For the mirror prims check that the class obj is actually a valid class. */
	if (!((GIV(argumentCount) < 1)
		 || (((class & (tagMask())) == 0)
		 && (objCouldBeClassObj(class))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}

	instance = initialInstanceOf(class);
	if (instance == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
}


/*	Return the first object in the heap. */

	/* InterpreterPrimitives>>#primitiveSomeObject */
static void
primitiveSomeObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	object = firstAccessibleObject();
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the oop of the SpecialObjectsArray. */

	/* InterpreterPrimitives>>#primitiveSpecialObjectsOop */
static void
primitiveSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(specialObjectsOop));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSquareRoot */
static void
primitiveSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt object;
    double rcvr;
    char *sp;

	/* begin popFloat */
	rcvr = floatValueOf(popStack());
	/* begin success: */
	if (!(rcvr >= 0.0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = sqrt(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
 */
/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

	/* InterpreterPrimitives>>#primitiveStoreImageSegment */
static void
primitiveStoreImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt ecode;
    sqInt outPointerArray;
    sqInt segmentWordArray;

	outPointerArray = longAt(GIV(stackPointer));
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* Essential type checks */
	arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((arrayOfRoots & (tagMask())) == 0)
		 && (((((usqInt) (longAt(arrayOfRoots))) >> (formatShift())) & (formatMask())) == 2))
		 && ((((outPointerArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(outPointerArray))) >> (formatShift())) & (formatMask())) == 2))
		 && (((segmentWordArray & (tagMask())) == 0)
		 && (((((((usqInt) (longAt(segmentWordArray))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(segmentWordArray))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1)))))))) {

		/* Must be indexable words */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots);
	if (ecode == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ecode;
	}
}

	/* InterpreterPrimitives>>#primitiveStringAt */
static void
primitiveStringAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    sqInt integerValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if ((rcvr & (tagMask())) != 0) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	if (((index & (tagMask())) != 1)
	 || ((GIV(argumentCount) > 1)
	 && (((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	index = (index >> 3);
	/* begin stObject:at: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l4;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l4;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l4;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l4;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l4;
	}
	totalLength = 0;
l4:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l5;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			result = longAt((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << (shiftForWord())));
			goto l5;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l5;
		}
		if (fmt >= (firstShortFormat())) {
			result = (((shortAt((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 1))) << 3) | 1);
			goto l5;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 2));
		result = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
		goto l5;

	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
l5:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		result = (((long)((result >> 3))) << (numTagBits())) + (characterTag());


		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveStringAtPut */
static void
primitiveStringAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt class1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt reasonCode1;
    sqInt signedValueToStore;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    sqInt sp2;
    sqInt sp3;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    usqInt unsignedValueToStore;
    usqInt unsignedValueToStore1;
    sqInt value;
    sqInt value1;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if ((rcvr & (tagMask())) != 0) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	if (((index & (tagMask())) != 1)
	 || ((GIV(argumentCount) > 2)
	 && (((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		GIV(primFailCode) = PrimErrNoModification;
		goto l1;
	}
	index = (index >> 3);
	/* begin stObject:at:put: */
	value1 = asciiOfCharacter(value);
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l5;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l5;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l5;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l5;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l5;
	}
	totalLength = 0;
l5:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr), value1);
			goto l6;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */
				if (((value1 & (tagMask())) == 0)
				 && (oopisLessThan(value1, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << (shiftForWord())), value1);
			goto l3;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((((value1) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			signedValueToStore = (value1 >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l3;
		}
		if (fmt >= (firstShortFormat())) {
			if (!((((value1) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			signedValueToStore = (value1 >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			shortAtput((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 1), signedValueToStore);
			goto l3;
		}
		unsignedValueToStore = positive32BitValueOf(value1);
		if (!GIV(primFailCode)) {
			long32Atput((rcvr + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 2), unsignedValueToStore);
		}
	l3:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
	}
l6:	/* end stObject:at:put: */;

	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAtPut: */;
}


/*	
	<array> primReplaceFrom: start to: stop with: replacement 
	startingAt: repStart 
	<primitive: 105>
	 */

	/* InterpreterPrimitives>>#primitiveStringReplace */
static void
primitiveStringReplace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt arrayFmt;
    sqInt arrayInstSize;
    sqInt class;
    sqInt class1;
    sqLong hdr;
    sqInt i;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt repl;
    sqInt replFmt;
    sqInt replInstSize;
    sqInt replStart;
    sqInt srcIndex;
    sqInt start;
    sqInt stop;
    sqInt totalLength;
    sqInt valuePointer;

	array = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		start = (integerPointer >> 3);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		start = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer1) & 7) == 1)) {
		stop = (integerPointer1 >> 3);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		stop = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	repl = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer2) & 7) == 1)) {
		replStart = (integerPointer2 >> 3);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		replStart = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if ((repl & (tagMask())) != 0) {

		/* can happen in LgInt copy */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(array))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	hdr = long64At(array);
	arrayFmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots2 = byteAt(array + 7);
	numSlots = (numSlots2 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(array - BaseHeaderSize))) << 8)))) >> 8
		: numSlots2);
	if (arrayFmt <= 5) {
		totalLength = numSlots;
		goto l1;
	}
	if (arrayFmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (arrayFmt & 7);
		goto l1;
	}
	if (arrayFmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (arrayFmt & 3);
		goto l1;
	}
	if (arrayFmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (arrayFmt & 1);
		goto l1;
	}
	if (arrayFmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l1;
	}
	totalLength = 0;
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((arrayFmt >= (sixtyFourBitIndexableFormat()))
	 || (arrayFmt == 2)) {
		arrayInstSize = 0;
		goto l6;
	}
	if (arrayFmt < 2) {
		arrayInstSize = totalLength;
		goto l6;
	}
	class = fetchClassOfNonImm(array);
	/* begin fixedFieldsOfClassFormat: */
	arrayInstSize = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l6:	/* end fixedFieldsOf:format:length: */;
	if (!((start >= 1)
		 && (((start - 1) <= stop)
		 && ((stop + arrayInstSize) <= totalLength)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	hdr = long64At(repl);
	replFmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots3 = byteAt(repl + 7);
	numSlots1 = (numSlots3 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(repl - BaseHeaderSize))) << 8)))) >> 8
		: numSlots3);
	if (replFmt <= 5) {
		totalLength = numSlots1;
		goto l2;
	}
	if (replFmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots1) << (shiftForWord())) - (replFmt & 7);
		goto l2;
	}
	if (replFmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots1) << ((shiftForWord()) - 1)) - (replFmt & 3);
		goto l2;
	}
	if (replFmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots1) << ((shiftForWord()) - 2)) - (replFmt & 1);
		goto l2;
	}
	if (replFmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots1;
		goto l2;
	}
	totalLength = 0;
l2:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((replFmt >= (sixtyFourBitIndexableFormat()))
	 || (replFmt == 2)) {
		replInstSize = 0;
		goto l7;
	}
	if (replFmt < 2) {
		replInstSize = totalLength;
		goto l7;
	}
	class1 = fetchClassOfNonImm(repl);
	/* begin fixedFieldsOfClassFormat: */
	replInstSize = (((longAt((class1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l7:	/* end fixedFieldsOf:format:length: */;
	if (!((replStart >= 1)
		 && ((((stop - start) + replStart) + replInstSize) <= totalLength))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((((arrayFmt >= (firstShortFormat())) && (arrayFmt <= ((firstLongFormat()) - 1))))
	 || (arrayFmt == (sixtyFourBitIndexableFormat()))) {
		(GIV(primFailCode) = PrimErrUnsupported);
		return;
	}
	if (arrayFmt < (firstByteFormat())) {
		if (!(arrayFmt == replFmt)) {
			(GIV(primFailCode) = PrimErrInappropriate);
			return;
		}
	}
	else {
		if (!((arrayFmt & 24) == (replFmt & 24))) {
			(GIV(primFailCode) = PrimErrInappropriate);
			return;
		}
	}

	/* - 1 for 0-based access */
	srcIndex = (replStart + replInstSize) - 1;
	if (arrayFmt <= 5) {
		for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((repl + BaseHeaderSize) + (((long)srcIndex) << (shiftForWord())));
			assert(!(isForwarded(array)));
			if (isOldObject(array)) {

				/* most stores into young objects */
				if (((valuePointer & (tagMask())) == 0)
				 && (oopisLessThan(valuePointer, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(array))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(array);
					}
				}
			}
			longAtput((array + BaseHeaderSize) + (((long)i) << (shiftForWord())), valuePointer);
			srcIndex += 1;
		}
	}
	else {
		if (arrayFmt < (firstByteFormat())) {

			/* 32-bit-word type objects */
			for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
				long32Atput((array + BaseHeaderSize) + (((long)i) << 2), long32At((repl + BaseHeaderSize) + (((long)srcIndex) << 2)));
				srcIndex += 1;
			}
		}
		else {

			/* byte-type objects */
			for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
				byteAtput((array + BaseHeaderSize) + i, byteAt((repl + BaseHeaderSize) + srcIndex));
				srcIndex += 1;
			}
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

	/* InterpreterPrimitives>>#primitiveSubtract */
static void
primitiveSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) - (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((((((usqInt) integerResult) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveSubtractLargeIntegers */
EXPORT(void)
primitiveSubtractLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative != bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = !aIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Suspend the receiver, aProcess such that it can be executed
	again by sending #resume. If the given process is not currently running,
	take it off
	its corresponding list. The primitive returns the list the receiver was
	previously on.
 */

	/* InterpreterPrimitives>>#primitiveSuspend */
static void
primitiveSuspend(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt lastLink;
    sqInt myList;
    sqInt nextLink;
    sqInt process;
    sqInt referent;
    char *sp;
    char *sp1;
    sqInt tempLink;

	process = longAt(GIV(stackPointer));
	if (process == (fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord()))))))) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
		transferTo(wakeHighestPriority());
		return;
	}

	/* XXXX Fixme. We should really check whether myList is a kind of LinkedList or not
	   but we can't easily so just do a quick check for nil which is the most common case. */
	myList = longAt((process + BaseHeaderSize) + (((long)MyListIndex) << (shiftForWord())));
	if (myList == GIV(nilObj)) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if (((longAt(myList)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(myList));
		referent = longAt((myList + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		myList = referent;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(process)));
		if (isOldObject(process)) {

			/* most stores into young objects */
			if (((myList & (tagMask())) == 0)
			 && (oopisLessThan(myList, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(process))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(process);
				}
			}
		}
		longAtput((process + BaseHeaderSize) + (((long)MyListIndex) << (shiftForWord())), myList);
	}
	/* begin removeProcess:fromList: */
	assert(!((isForwarded(process))));
	assert(!((isForwarded(myList))));
	firstLink = longAt((myList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())));
	lastLink = longAt((myList + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())));
	assert(!((isForwarded(firstLink))));
	assert(!((isForwarded(lastLink))));
	if (process == firstLink) {
		nextLink = longAt((process + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())));
		assert(!((isForwarded(nextLink))));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(myList)));
		if (isOldObject(myList)) {

			/* most stores into young objects */
			if (((nextLink & (tagMask())) == 0)
			 && (oopisLessThan(nextLink, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(myList))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(myList);
				}
			}
		}
		longAtput((myList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())), nextLink);
		if (process == lastLink) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(myList)));
			longAtput((myList + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())), GIV(nilObj));
		}
	}
	else {
		tempLink = firstLink;
		while (1) {
			assert(!((isForwarded(tempLink))));
			if (tempLink == GIV(nilObj)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				goto l1;
			}
			nextLink = longAt((tempLink + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())));
			if (nextLink == process) break;
			tempLink = longAt((tempLink + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())));
		}
		nextLink = longAt((process + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(tempLink)));
		if (isOldObject(tempLink)) {

			/* most stores into young objects */
			if (((nextLink & (tagMask())) == 0)
			 && (oopisLessThan(nextLink, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(tempLink))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(tempLink);
				}
			}
		}
		longAtput((tempLink + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())), nextLink);
		if (process == lastLink) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(myList)));
			if (isOldObject(myList)) {

				/* most stores into young objects */
				if (((tempLink & (tagMask())) == 0)
				 && (oopisLessThan(tempLink, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(myList))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(myList);
					}
				}
			}
			longAtput((myList + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())), tempLink);
		}
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(process)));
	if (isOldObject(process)) {

		/* most stores into young objects */
		if (((GIV(nilObj) & (tagMask())) == 0)
		 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(process))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(process);
			}
		}
	}
	longAtput((process + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())), GIV(nilObj));
l1:	/* end removeProcess:fromList: */;
	if (!GIV(primFailCode)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(process)));
		if (isOldObject(process)) {

			/* most stores into young objects */
			if (((GIV(nilObj) & (tagMask())) == 0)
			 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(process))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(process);
				}
			}
		}
		longAtput((process + BaseHeaderSize) + (((long)MyListIndex) << (shiftForWord())), GIV(nilObj));
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), myList);
		GIV(stackPointer) = sp1;
	}
}


/*	Attempt to test-and-set the ownership of the critical section. If not
	owned, set the owner to the current process and answer false. If owned by
	the current process answer true. If owned by some other process answer
	nil. For simulation if there is an argument it is taken to be the
	effective activeProcess
	(see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveTestAndSetOwnershipOfCriticalSection */
static void
primitiveTestAndSetOwnershipOfCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt objOop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin fetchPointer:ofObject: */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
		activeProc = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((long)owningProcessIndex) << (shiftForWord())));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		if (isOldObject(criticalSection)) {

			/* most stores into young objects */
			if (((activeProc & (tagMask())) == 0)
			 && (oopisLessThan(activeProc, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(criticalSection))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(criticalSection);
				}
			}
		}
		longAtput((criticalSection + BaseHeaderSize) + (((long)owningProcessIndex) << (shiftForWord())), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
	GIV(stackPointer) = sp2;
}


/*	Return true if the host OS does support the given display depth. */

	/* InterpreterPrimitives>>#primitiveTestDisplayDepth */
static void
primitiveTestDisplayDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsPerPixel;
    sqInt integerPointer;
    sqInt okay;
    char *sp;

	okay = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		bitsPerPixel = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bitsPerPixel = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Multiply the receiver by the power of the argument. */

	/* InterpreterPrimitives>>#primitiveTimesTwoPower */
static void
primitiveTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    double rcvr;
    double result;
    char *sp;
    sqInt twiceMaxExponent;

	arg = longAt(GIV(stackPointer));
	if (!((((arg) & 7) == 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	arg = (arg >> 3);
	
	/* clip arg to at most int range; ldexp's last arg is of type int */
	twiceMaxExponent = 2 * (1LL << 11);
	if (arg < (-twiceMaxExponent)) {
		arg = -twiceMaxExponent;
	}
	else {
		if (arg > twiceMaxExponent) {
			arg = twiceMaxExponent;
		}
	}

	rcvr = floatValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	result = ldexp(rcvr, ((int) arg));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(result));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveTruncated */
static void
primitiveTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double rcvr;
    char *sp;
    double trunc;

	/* begin popFloat */
	rcvr = floatValueOf(popStack());
	if (!GIV(primFailCode)) {
		modf(rcvr, (&trunc));
		/* begin success: */
		if (!(((trunc >= (((double) (MinSmallInteger) ))) && (trunc <= (((double) (MaxSmallInteger) )))))) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pushInteger: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), (((((sqInt)trunc)) << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Primitive. Unload the module with the given name. */
/*	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is ensured by invalidating current
	sessionID. 
 */

	/* InterpreterPrimitives>>#primitiveUnloadModule */
static void
primitiveUnloadModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt firstBytecode;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt i;
    usqInt limit;
    sqInt methodHeader;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt primBits;
    sqInt primIdx;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = longAt(GIV(stackPointer));
	if ((((moduleName) & 7) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(((moduleName & (tagMask())) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName)), byteSizeOf(moduleName)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin flushExternalPrimitives */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & (classIndexMask())) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */
				/* begin primitiveIndexOfMethod:header: */
				assert(isCompiledMethod(objOop1));
				methodHeader = longAt((objOop1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				if (methodHeader & AlternateHeaderHasPrimFlag) {
					firstBytecode = (objOop1 + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
					primIdx = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
				}
				else {
					primIdx = 0;
				}

				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */
					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & (classIndexMask())) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */
				/* begin primitiveIndexOfMethod:header: */
				assert(isCompiledMethod(objOop1));
				methodHeader = longAt((objOop1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				if (methodHeader & AlternateHeaderHasPrimFlag) {
					firstBytecode = (objOop1 + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
					primIdx = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
				}
				else {
					primIdx = 0;
				}

				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */
					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (!(((longAt(objOop11)) & (classIndexMask())) == 0)) {
				if (((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

					/* This is a compiled method */
					/* begin primitiveIndexOfMethod:header: */
					assert(isCompiledMethod(objOop11));
					methodHeader = longAt((objOop11 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					if (methodHeader & AlternateHeaderHasPrimFlag) {
						firstBytecode = (objOop11 + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
						primIdx = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
					}
					else {
						primIdx = 0;
					}

					if (primIdx == PrimitiveExternalCallIndex) {

						/* It's primitiveExternalCall */
						flushExternalPrimitiveOf(objOop11);
					}
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	flushMethodCache();
	/* begin flushExternalPrimitiveTable */
	for (i = 0; i < MaxExternalPrimitiveTableSize; i += 1) {
		externalPrimitiveTable[i] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	forceInterruptCheck();
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Update the VMs notion of the current timezone. The VM sets its notion
	of the timezone once at start-up. If one wants the VM to keep its notion
	up-to-date arrange to invoke this primitive periodically. */

	/* InterpreterPrimitives>>#primitiveUpdateTimezone */
static void
primitiveUpdateTimezone(void)
{
	ioUpdateVMTimezone();
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

	/* InterpreterPrimitives>>#primitiveUTCMicrosecondClock */
static void
primitiveUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioUTCMicrosecondsNow());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Posix epoch and
	the current seconds offset from GMT in the local time zone.
	This is a named (not numbered) primitive in the null module (ie the VM) */

	/* InterpreterPrimitives>>#primitiveUtcWithOffset */
EXPORT(sqInt)
primitiveUtcWithOffset(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static usqLong epochDelta= 2177452800000000ULL;
    sqLong offset;
    sqInt oop;
    sqInt oop1;
    sqInt resultArray;
    char *sp;
    usqLong utcMicroseconds;
    sqInt valuePointer;

	utcMicroseconds = ioUTCMicroseconds();
	offset = (ioLocalMicroseconds()) - utcMicroseconds;
	offset = offset / 1000000;
	/* begin pushRemappableOop: */
	oop = positive64BitIntegerFor(utcMicroseconds - epochDelta);
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassArray) << (shiftForWord()))), 2);
	/* begin storePointer:ofObject:withValue: */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	valuePointer = oop1;
	assert(!(isForwarded(resultArray)));
	if (isOldObject(resultArray)) {

		/* most stores into young objects */
		if (((valuePointer & (tagMask())) == 0)
		 && (oopisLessThan(valuePointer, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(resultArray))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(resultArray);
			}
		}
	}
	longAtput((resultArray + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(resultArray)));
	longAtput((resultArray + BaseHeaderSize) + (1LL << (shiftForWord())), ((offset << 3) | 1));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
}


/*	Return a string containing the path name of VM's directory. */

	/* InterpreterPrimitives>>#primitiveVMPath */
static void
primitiveVMPath(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	sz = vmPathSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord()))), sz);
	vmPathGetLength(s + BaseHeaderSize, sz);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
	GIV(stackPointer) = sp;
}


/*	Primitive.
	0 args: Answer whether the VM Profiler is running or not.
	1 arg:	Copy the sample data into the supplied argument, which must be a
	Bitmap of suitable size. Answer the number of samples copied into the
	buffer.  */

	/* InterpreterPrimitives>>#primitiveVMProfileSamplesInto */
static void
primitiveVMProfileSamplesInto(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long bufferSize;
    sqInt numSamples;
    sqInt ok;
    sqInt oop;
    sqInt running;
    sqInt sampleBuffer;
    unsigned long *sampleBufferAddress;
    char *sp;
    char *sp1;
    sqInt successBoolean;

	sampleBuffer = 0;
	ioNewProfileStatus(&running,&bufferSize);
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (running
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin success: */
	if (!(GIV(argumentCount) == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin stackObjectValue: */
		oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
		if ((oop & (tagMask())) != 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			sampleBuffer = null;
			goto l1;
		}
		sampleBuffer = oop;
	l1:	/* end stackObjectValue: */;
		/* begin assertClassOf:is: */
		ok = (sampleBuffer & (tagMask())) == 0;
		if (ok) {
			/* begin isClassOfNonImm:equalTo: */
			assert(isNonImmediate(sampleBuffer));
			ok = ((longAt(sampleBuffer)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassBitmap) << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
		}
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		/* begin success: */
		successBoolean = (numSlotsOf(sampleBuffer)) >= bufferSize;
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	/* begin firstFixedField: */
	sampleBufferAddress = ((void *) (pointerForOop(sampleBuffer + BaseHeaderSize)));
	numSamples = ioNewProfileSamplesInto(sampleBufferAddress);
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((numSamples << 3) | 1));
	GIV(stackPointer) = sp1;
}

	/* InterpreterPrimitives>>#primitiveWait */
static void
primitiveWait(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt excessSignals;
    sqInt objOop;
    sqInt sema;


	/* rcvr */
	sema = longAt(GIV(stackPointer));
	excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema);
	if (excessSignals > 0) {
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqInt) (excessSignals - 1)) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(sema)));
			longAtput((sema + BaseHeaderSize) + (((long)ExcessSignalsIndex) << (shiftForWord())), (((excessSignals - 1) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin fetchPointer:ofObject: */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
		activeProc = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
		addLastLinktoList(activeProc, sema);
		transferTo(wakeHighestPriority());
	}
}


/*	Primitively do the equivalent of Process>yield, avoiding the overhead of a
	fork and a wait in the standard implementation.
 */

	/* InterpreterPrimitives>>#primitiveYield */
static void
primitiveYield(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt scheduler;

	/* begin fetchPointer:ofObject: */
	scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	activeProc = longAt((scheduler + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (((long)PriorityIndex) << (shiftForWord())));
	assert((((oop) & 7) == 1));
	priority = (oop >> 3);
	processLists = longAt((scheduler + BaseHeaderSize) + (((long)ProcessListsIndex) << (shiftForWord())));
	processList = longAt((processLists + BaseHeaderSize) + (((long)(priority - 1)) << (shiftForWord())));
	if (!(isEmptyList(processList))) {
		addLastLinktoList(activeProc, processList);
		transferTo(wakeHighestPriority());
	}
}


/*	Signal the given semaphore from within the interpreter. Used to serialize
	callbacks. 
 */

	/* InterpreterPrimitives>>#signalNoResume: */
sqInt
signalNoResume(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt empty;

	/* begin isEmptyList: */
	assert(!(isForwarded(aSemaphore)));
	empty = (longAt((aSemaphore + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())))) == GIV(nilObj);
	if (!empty) {
		putToSleepyieldingIf(removeFirstLinkOfList(aSemaphore), 1);
	}
	return empty;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#signed32BitValueOf: */
int
signed32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt negative;
    sqInt ok;
    int value;
    long value64;

	if ((((oop) & 7) == 1)) {
		
		/* Must fail for SmallIntegers with digitLength > 4 */
		value64 = (oop >> 3);
		if ((((int) value64)) != value64) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value64 = 0;
		}
		return value64;

	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	if ((numBytesOfBytes(oop)) > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	value = 
#  if VMBIGENDIAN
		(((byteAt((oop + BaseHeaderSize))) + (((long)(byteAt((oop + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((oop + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((oop + BaseHeaderSize) + 3))) << 24)
#  else /* VMBIGENDIAN */
		long32At((oop + BaseHeaderSize) + (0LL << 2))
#  endif /* VMBIGENDIAN */
		;
	if (value < 0) {
		assert((sizeof(value)) == 4);
		if (negative
		 && (0 == (((long)value) << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return (negative
		? 0 - value
		: value);
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#signed64BitValueOf: */
sqLong
signed64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt i;
    sqInt negative;
    sqInt ok;
    sqInt sz;
    sqLong value;

	if ((((oop) & 7) == 1)) {
		return ((sqLong) ((oop >> 3)));
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = (((long)(numSlotsOf(oop))) << (shiftForWord())) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	
#  if VMBIGENDIAN
	value = byteAt((oop + BaseHeaderSize) + (sz - 1));
	for (i = (sz - 2); i >= 0; i += -1) {
		value = (((long)value) << 8) + (byteAt((oop + BaseHeaderSize) + i));
	}

#  else /* VMBIGENDIAN */
	if (sz > 4) {
		value = long64At((oop + BaseHeaderSize) + (0LL << 3));
	}
	else {
		value = ((usqInt)(long32At((oop + BaseHeaderSize) + (0LL << 2))));
	}

#  endif /* VMBIGENDIAN */

	if (value < 0) {
		assert((sizeof(value)) == 8);
		assert((sizeof(((long)value) << 1)) == 8);
		if (negative
		 && (0 == (((long)value) << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return (negative
		? 0 - value
		: value);
}


/*	Answer a signed value of an integer up to the size of a machine word.
	The object may be either a positive SmallInteger or a LargeInteger of size
	<= word size.
 */

	/* InterpreterPrimitives>>#signedMachineIntegerValueOf: */
long
signedMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt negative;
    usqInt numBytes;
    usqInt numSlots;
    sqInt ok;
    long value;

	if ((((oop) & 7) == 1)) {
		return (oop >> 3);
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(oop + 7);
	numBytes = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	numBytes = ((long)numBytes) << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		bs = numBytes - (fmt & 7);
		goto l3;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		bs = numBytes;
		goto l3;
	}
	if (fmt >= (firstShortFormat())) {
		bs = numBytes - (((long)(fmt & 3)) << 1);
		goto l3;
	}
	bs = numBytes - (((long)(fmt & 1)) << 2);
l3:	/* end numBytesOf: */;
	if (bs > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		value = 
#    if VMBIGENDIAN
			(((((((byteAt((oop + BaseHeaderSize))) + (((long)(byteAt((oop + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((oop + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((oop + BaseHeaderSize) + 3))) << 24)) + (((long)(byteAt((oop + BaseHeaderSize) + 4))) << 32)) + (((long)(byteAt((oop + BaseHeaderSize) + 5))) << 40)) + (((long)(byteAt((oop + BaseHeaderSize) + 6))) << 48)) + (((long)(byteAt((oop + BaseHeaderSize) + 7))) << 56)
#    else /* VMBIGENDIAN */
			long64At((oop + BaseHeaderSize) + (0LL << 3))
#    endif /* VMBIGENDIAN */
			;
	}
	else {
		value = 
#    if VMBIGENDIAN
			(((byteAt((oop + BaseHeaderSize))) + (((long)(byteAt((oop + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((oop + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((oop + BaseHeaderSize) + 3))) << 24)
#    else /* VMBIGENDIAN */
			((usqInt)(long32At((oop + BaseHeaderSize) + (0LL << 2))))
#    endif /* VMBIGENDIAN */
			;
	}
	if (value < 0) {

		/* Don't fail for -16r80000000[00000000].
		   Alas the simple (negative and: [value - 1 > 0]) isn't adequate since in C the result of signed integer
		   overflow is undefined and hence under optimization this may fail.  The shift, however, is well-defined. */
		if (negative
		 && (0 == (((long)value) << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return (negative
		? 0 - value
		: value);
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#sizeOfAlienData: */
usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt size;

	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassAlien) << (shiftForWord())))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	size = longAt(oop + BaseHeaderSize);
	return abs(size);
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#startOfAlienData: */
void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassAlien) << (shiftForWord())))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) (((longAt(oop + BaseHeaderSize)) > 0
	? (oop + BaseHeaderSize) + BytesPerOop
	: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Set the state of the primitive failure code/success flag, iff
	successBoolean is false. If primFailCode is non-zero a primitive has
	failed. If primFailCode
	is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self success: false to exit. */

	/* InterpreterPrimitives>>#success: */
sqInt
success(sqInt successBoolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Initialize the stack pages. For testing I want stack addresses to be
	disjoint from
	normal memory addresses so stack addresses are negative. The first address
	is -pageSize bytes. So for example if there are 1024 bytes per page and 3
	pages then the pages are organized as
	
	byte address: -1024 <-> -2047 | -2048 <-> -3071 | -3072 <-> -4096 |
	page 3			page 2			page 1
	mem index: 769 <-> 513 | 512 <-> 257 | 256 <-> 1 |
	
	The byte address is the external address corresponding to a real address
	in the VM.
	mem index is the index in the memory Array holding the stack, an index
	internal to
	the stack pages. The first stack page allocated will be the last page in
	the array of pages
	at the highest effective address. Its base address be -1024 and grow down
	towards -2047. */
/*	The lFoo's are to get around the foo->variable scheme in the C call to
	allocStackPages below.
 */

	/* InterpreterStackPages>>#initializeStack:numSlots:pageSize: */
static sqInt NoDbgRegParms
initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    char * highestAddress;
    sqInt i;
    sqInt index;
    char * lowestAddress;
    sqInt memIndex;
    sqInt numPages;
    StackPage *page;
    char *pageStructBase;
    void *pointer;
    sqInt structStackPageSize;
    sqInt theIndex;

	
	/* For initialization in the C code. */
	GIV(stackMemory) = theStackPages;
	structStackPageSize = sizeof(CogStackPage);
	GIV(bytesPerPage) = slotsPerPage * BytesPerWord;

	/* Because stack pages grow down baseAddress is at the top of a stack page and so to avoid
	   subtracting BytesPerWord from baseAddress and lastAddress in the init loop below we simply
	   push the stackPage array up one word to avoid the overlap.  This word is extraStackBytes. */
	numPages = GIV(numStackPages);
	pageStructBase = (theStackPages + (numPages * GIV(bytesPerPage))) + BytesPerWord;

	/* Simulation only.  Since addresses are negative the offset is positive.  To make all
	   stack addresses negative we make the offset a page more than it needs to be so the
	   address of the last slot in memory (the highest address in the stack, or its start) is
	   - pageByteSize
	   and the address of the first slot (the lowest address, or its end) is
	   - pageByteSize * (numPages + 1) */
	GIV(pages) = (StackPage *)pageStructBase;
	assert((((stackPageByteSize()) - (stackLimitBytes())) - (stackLimitOffset())) >= (stackPageHeadroom()));
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		(page->lastAddress = (char *)theStackPages + (index * GIV(bytesPerPage)));
		(page->baseAddress = ((page->lastAddress)) + GIV(bytesPerPage));
		(page->stackLimit = ((page->baseAddress)) - ((((stackPageFrameBytes()) < (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord)))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord))))));
		(page->realStackLimit = (page->stackLimit));
		(page->baseFP = 0);
		(page->nextPage = stackPageAt((index == (numPages - 1)
			? 0
			: index + 1)));
		(page->prevPage = stackPageAt((index == 0
			? numPages - 1
			: index - 1)));
	}
	/* begin stackPageAt: */
	page = stackPageAtpages(0, GIV(pages));
	GIV(overflowLimit) = ((((page->baseAddress)) - ((page->realStackLimit))) * 3) / 5;
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		assert((pageIndexFor((page->baseAddress))) == index);
		assert((pageIndexFor(((page->baseAddress)) - ((slotsPerPage - 1) * BytesPerWord))) == index);
		assert((stackPageFor((page->baseAddress))) == page);
		assert((stackPageFor((page->stackLimit))) == page);
		/* begin initializePageTraceToInvalid: */
		(page->trace = StackPageTraceInvalid);
	}
	/* begin stackPageAt: */
	GIV(mostRecentlyUsedPage) = stackPageAtpages(0, GIV(pages));
	page = GIV(mostRecentlyUsedPage);
	count = 0;
	do {
		count += 1;
		/* begin pageIndexFor: */
		pointer = (page->baseAddress);
		theIndex = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
		assert((stackPageAt(theIndex)) == page);
		assert((pageIndexFor((page->baseAddress))) == theIndex);
		assert((pageIndexFor((page->stackLimit))) == theIndex);
		assert((pageIndexFor(((page->lastAddress)) + BytesPerWord)) == theIndex);
	} while(((page = (page->nextPage))) != GIV(mostRecentlyUsedPage));
	assert(count == numPages);
	assert(pageListIsWellFormed());
}


/*	<Integer> */
/*	Answer the page index for a pointer into stack memory, i.e. the index
	for the page the address is in. N.B. This is a zero-relative index. */

	/* InterpreterStackPages>>#pageIndexFor: */
static sqInt NoDbgRegParms
pageIndexFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
}


/*	Answer the address immediately following an object. */

	/* Spur64BitMemoryManager>>#addressAfter: */
static sqInt NoDbgRegParms
addressAfter(sqInt objOop)
{
    usqInt numSlots;
    usqInt numSlots1;
    sqInt slotBytes;

	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (numSlots == 0) {
		slotBytes = 8;
	}
	else {
		slotBytes = ((long)numSlots) << (shiftForWord());
	}
	return (objOop + BaseHeaderSize) + slotBytes;
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. Try
	and allocate in a segment that already includes pinned objects. The header
	of the
	result will have been filled-in but not the contents. */

	/* Spur64BitMemoryManager>>#allocateSlotsForPinningInOldSpace:bytes:format:classIndex: */
static sqInt NoDbgRegParms
allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt acceptedChunk;
    sqInt acceptedNode;
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    sqInt f;
    usqInt index;
    usqInt initialIndex;
    sqInt next;
    sqInt node;
    sqInt prev;
    sqInt valuePointer;
    sqInt valuePointer1;

	/* begin allocateOldSpaceChunkOfBytes:suchThat: */

	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= totalBytes;
	initialIndex = totalBytes / 8;
	if ((initialIndex < 64)
	 && ((1LL << initialIndex) <= GIV(freeListsMask))) {
		if (GIV(freeListsMask) & (1LL << initialIndex)) {
			if (((node = GIV(freeLists)[initialIndex])) == 0) {
				GIV(freeListsMask) -= 1LL << initialIndex;
			}
			else {
				prev = 0;
				while (node != 0) {
					assert(node == (startOfObject(node)));
					assert(isValidFreeObject(node));
					next = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
					if (((segmentContainingObj(node))->containsPinned)) {
						if (prev == 0) {
							GIV(freeLists)[initialIndex] = next;
						}
						else {
							/* begin storePointer:ofFreeChunk:withValue: */
							assert(isFreeObject(prev));
							assert((next == 0)
							 || (isFreeObject(next)));
							longAtput((prev + BaseHeaderSize) + (0LL << (shiftForWord())), next);
						}
						chunk = node;
						goto l1;
					}
					prev = node;
					node = next;
				}
			}
		}
		index = initialIndex;
		while ((((index += initialIndex)) < 64)
		 && ((1LL << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1LL << index)) {
				if (((node = GIV(freeLists)[index])) == 0) {
					GIV(freeListsMask) -= 1LL << index;
				}
				else {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node)));
						assert(isValidFreeObject(node));
						next = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
						if (((segmentContainingObj(node))->containsPinned)) {
							if (prev == 0) {
								GIV(freeLists)[index] = next;
							}
							else {
								/* begin storePointer:ofFreeChunk:withValue: */
								assert(isFreeObject(prev));
								assert((next == 0)
								 || (isFreeObject(next)));
								longAtput((prev + BaseHeaderSize) + (0LL << (shiftForWord())), next);
							}
							freeChunkWithBytesat((index * 8) - totalBytes, (((byteAt(node + 7)) == (numSlotsMask())
	? node - BaseHeaderSize
	: node)) + totalBytes);
							chunk = node;
							goto l1;
						}
						prev = node;
						node = next;
					}
				}
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < 64)
		 && ((1LL << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1LL << index)) {
				if (((node = GIV(freeLists)[index])) == 0) {
					GIV(freeListsMask) -= 1LL << index;
				}
				else {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node)));
						assert(isValidFreeObject(node));
						next = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
						if (((segmentContainingObj(node))->containsPinned)) {
							if (prev == 0) {
								GIV(freeLists)[index] = next;
							}
							else {
								/* begin storePointer:ofFreeChunk:withValue: */
								assert(isFreeObject(prev));
								assert((next == 0)
								 || (isFreeObject(next)));
								longAtput((prev + BaseHeaderSize) + (0LL << (shiftForWord())), next);
							}
							freeChunkWithBytesat((index * 8) - totalBytes, (((byteAt(node + 7)) == (numSlotsMask())
	? node - BaseHeaderSize
	: node)) + totalBytes);
							chunk = node;
							goto l1;
						}
						prev = node;
						node = next;
					}
				}
			}
		}
	}
	child = GIV(freeLists)[0];
	node = (acceptedChunk = (acceptedNode = 0));
	while (child != 0) {
		assert(isValidFreeObject(child));
		childBytes = bytesInObject(child);
		if (childBytes == totalBytes) {

			/* size match; try to remove from list at node. */
			node = child;
			while (1) {
				prev = node;
				node = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
				if (!(node != 0)) break;
				if (((segmentContainingObj(node))->containsPinned)) {
					assert(isValidFreeObject(node));
					/* begin storePointer:ofFreeChunk:withValue: */
					valuePointer = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
					assert(isFreeObject(prev));
					assert((valuePointer == 0)
					 || (isFreeObject(valuePointer)));
					longAtput((prev + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
					chunk = ((byteAt(node + 7)) == (numSlotsMask())
						? node - BaseHeaderSize
						: node);
					goto l1;
				}
			}
			if (((segmentContainingObj(child))->containsPinned)) {
				next = longAt((child + BaseHeaderSize) + (0LL << (shiftForWord())));
				if (next == 0) {

					/* no list; remove the interior node */
					unlinkSolitaryFreeTreeNode(child);
				}
				else {

					/* list; replace node with it */
					inFreeTreeReplacewith(child, next);
				}
				chunk = ((byteAt(child + 7)) == (numSlotsMask())
					? child - BaseHeaderSize
					: child);
				goto l1;
			}
		}
		if (child != 0) {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (totalBytes + 8)) {

				/* node too small; walk down the larger size of the tree */
				child = longAt((child + BaseHeaderSize) + (4LL << (shiftForWord())));
			}
			else {
				flag("we can do better here; preferentially choosing the lowest node. That would be a form of best-fit since we are trying to compact down");
				node = child;
				child = longAt((node + BaseHeaderSize) + (3LL << (shiftForWord())));
				if (acceptedNode == 0) {

					/* first search the list. */
					acceptedChunk = node;
					do {
						acceptedChunk = longAt((acceptedChunk + BaseHeaderSize) + (0LL << (shiftForWord())));
						if ((acceptedChunk != 0)
						 && (((segmentContainingObj(acceptedChunk))->containsPinned))) {
							acceptedNode = node;
						}
					} while((acceptedChunk != 0)
						 && (acceptedNode == 0));
					if ((acceptedNode == 0)
					 && (((segmentContainingObj(node))->containsPinned))) {
						acceptedNode = node;

						/* break out of loop now we have an acceptedNode */
						child = 0;
					}
				}
			}
		}
	}
	if (acceptedNode != 0) {
		if (acceptedChunk != 0) {
			assert((bytesInObject(acceptedChunk)) >= (totalBytes + (allocationUnit())));
			while (1) {
				next = longAt((acceptedNode + BaseHeaderSize) + (0LL << (shiftForWord())));
				if (!(next != acceptedChunk)) break;
				acceptedNode = next;
			}
			/* begin storePointer:ofFreeChunk:withValue: */
			valuePointer1 = longAt((acceptedChunk + BaseHeaderSize) + (0LL << (shiftForWord())));
			assert(isFreeObject(acceptedNode));
			assert((valuePointer1 == 0)
			 || (isFreeObject(valuePointer1)));
			longAtput((acceptedNode + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer1);
			freeChunkWithBytesat((bytesInObject(acceptedChunk)) - totalBytes, (((byteAt(acceptedChunk + 7)) == (numSlotsMask())
	? acceptedChunk - BaseHeaderSize
	: acceptedChunk)) + totalBytes);
			chunk = ((byteAt(acceptedChunk + 7)) == (numSlotsMask())
				? acceptedChunk - BaseHeaderSize
				: acceptedChunk);
			goto l1;
		}
		next = longAt((acceptedNode + BaseHeaderSize) + (0LL << (shiftForWord())));
		if (next == 0) {

			/* no list; remove the interior node */
			unlinkSolitaryFreeTreeNode(acceptedNode);
		}
		else {

			/* list; replace node with it */
			inFreeTreeReplacewith(acceptedNode, next);
		}
		assert((bytesInObject(acceptedNode)) >= (totalBytes + (allocationUnit())));
		freeChunkWithBytesat((bytesInObject(acceptedNode)) - totalBytes, (((byteAt(acceptedNode + 7)) == (numSlotsMask())
	? acceptedNode - BaseHeaderSize
	: acceptedNode)) + totalBytes);
		chunk = ((byteAt(acceptedNode + 7)) == (numSlotsMask())
			? acceptedNode - BaseHeaderSize
			: acceptedNode);
		goto l1;
	}

	/* optimism was unfounded */
	GIV(totalFreeOldSpace) += totalBytes;
	chunk = null;
l1:	/* end allocateOldSpaceChunkOfBytes:suchThat: */;
	if (!(chunk)) {
		chunk = allocateOldSpaceChunkOfBytes(totalBytes);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	if (!(chunk)) {
		return null;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		longAtput(chunk, numSlots + (((long)(numSlotsMask())) << (numSlotsFullShift())));
		longAtput(chunk + BaseHeaderSize, (headerForSlotsformatclassIndex(numSlotsMask(), formatField, classIndex)) | (1LL << 30));
		return chunk + BaseHeaderSize;
	}
	longAtput(chunk, (((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)formatField) << (formatShift()))) + classIndex) | (1LL << 30));
	return chunk;
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. The
	header will have been filled-in but not the contents. If no memory is
	available answer nil. */

	/* Spur64BitMemoryManager>>#allocateSlotsInOldSpace:bytes:format:classIndex: */
static sqInt NoDbgRegParms
allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;

	chunk = allocateOldSpaceChunkOfBytes(totalBytes);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	if (!(chunk)) {
		return null;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		longAtput(chunk, numSlots + (((long)(numSlotsMask())) << (numSlotsFullShift())));
		longAtput(chunk + BaseHeaderSize, headerForSlotsformatclassIndex(numSlotsMask(), formatField, classIndex));
		return chunk + BaseHeaderSize;
	}
	longAtput(chunk, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)formatField) << (formatShift()))) + classIndex);
	return chunk;
}


/*	Answer the given integer with its bytes in the reverse order. */

	/* Spur64BitMemoryManager>>#byteSwapped: */
sqInt
byteSwapped(sqInt w)
{
	return ((((((((((usqInt) w >> 56)) & Byte0Mask) + ((((usqInt) w >> 40)) & Byte1Mask)) + ((((usqInt) w >> 24)) & Byte2Mask)) + ((((usqInt) w >> 8)) & Byte3Mask)) + ((((usqInt) w << 8)) & Byte4Mask)) + ((((usqInt) w << 24)) & Byte5Mask)) + ((((usqInt) w << 40)) & Byte6Mask)) + ((((usqInt) w << 56)) & Byte7Mask);
}


/*	Answer the total number of bytes in an object including header and
	possible overflow size header.
 */

	/* Spur64BitMemoryManager>>#bytesInObject: */
static usqInt NoDbgRegParms
bytesInObject(sqInt objOop)
{
    usqLong header;
    sqInt headerNumSlots;
    usqLong numSlots;

	flag("endianness");
	header = longAt(objOop);
	headerNumSlots = header >> (numSlotsFullShift());
	if (headerNumSlots == (numSlotsMask())) {
		numSlots = ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8;
	}
	else {
		numSlots = (headerNumSlots == 0
			? 1
			: headerNumSlots);
	}
	return (((long)numSlots) << (shiftForWord())) + ((headerNumSlots == (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize));
}


/*	Attempt to change the class of the receiver to the argument given that the
	format of the receiver matches the format of the argument. If successful,
	answer 0, otherwise answer an error code indicating the reason for
	failure. 
	Fail if the format of the receiver is incompatible with the format of the
	argument, or if the argument is a fixed class and the receiver's size
	differs from the size
	that an instance of the argument should have. */

	/* Spur64BitMemoryManager>>#changeClassOf:to: */
static sqInt NoDbgRegParms
changeClassOfto(sqInt rcvr, sqInt argClass)
{
    sqInt classFormat;
    sqInt classIndex;
    sqInt fixedFields;
    sqInt fmt;
    sqInt instBytes;
    sqInt instFormat;
    sqInt newFormat;
    sqInt normalizedInstFormat;
    usqInt numBytes;
    usqInt numSlots;

	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		return PrimErrNoModification;
	}
	classFormat = ((longAt((argClass + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
	fixedFields = classFormat & ((1LL << (fixedFieldsFieldWidth())) - 1);
	classFormat = (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
	instFormat = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
	/* begin classFormatForInstanceFormat: */
	if (instFormat < (firstLongFormat())) {
		normalizedInstFormat = instFormat;
		goto l2;
	}
	if (instFormat >= (firstByteFormat())) {
		normalizedInstFormat = instFormat & -8;
		goto l2;
	}
	normalizedInstFormat = (instFormat >= (firstShortFormat())
		? instFormat & -4
		: instFormat & -2);
l2:	/* end classFormatForInstanceFormat: */;
	if ((normalizedInstFormat > 5)
	 && (normalizedInstFormat == classFormat)) {
		newFormat = instFormat;
	}
	else {
		if (normalizedInstFormat <= 5) {
			if (classFormat > 5) {
				return PrimErrInappropriate;
			}
			if ((numSlotsOf(rcvr)) < fixedFields) {
				return PrimErrBadReceiver;
			}
			newFormat = classFormat;
		}
		else {
			/* begin numBytesOf: */
			fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
			numSlots = byteAt(rcvr + 7);
			numBytes = (numSlots == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
				: numSlots);
			numBytes = ((long)numBytes) << (shiftForWord());
			if (fmt >= (firstByteFormat())) {

				/* bytes (the common case), including CompiledMethod */
				instBytes = numBytes - (fmt & 7);
				goto l1;
			}
			if (fmt <= (sixtyFourBitIndexableFormat())) {
				instBytes = numBytes;
				goto l1;
			}
			if (fmt >= (firstShortFormat())) {
				instBytes = numBytes - (((long)(fmt & 3)) << 1);
				goto l1;
			}
			instBytes = numBytes - (((long)(fmt & 1)) << 2);
		l1:	/* end numBytesOf: */;
			
			switch (normalizedInstFormat) {
			case sixtyFourBitIndexableFormat():
				if ((classFormat < (sixtyFourBitIndexableFormat()))
				 || (classFormat >= (firstCompiledMethodFormat()))) {
					return PrimErrInappropriate;
				}
				newFormat = classFormat;
				break;
			case firstLongFormat():
				if ((classFormat < (sixtyFourBitIndexableFormat()))
				 || (classFormat >= (firstCompiledMethodFormat()))) {
					return PrimErrInappropriate;
				}
				if ((classFormat == (sixtyFourBitIndexableFormat()))
				 && (instBytes & 1)) {
					return PrimErrBadReceiver;
				}
				newFormat = classFormat;
				break;
			case firstShortFormat():
				if ((classFormat < (sixtyFourBitIndexableFormat()))
				 || (classFormat >= (firstCompiledMethodFormat()))) {
					return PrimErrInappropriate;
				}
				
				switch (classFormat) {
				case sixtyFourBitIndexableFormat():
					if (instBytes & 7) {
						return PrimErrBadReceiver;
					}
					newFormat = classFormat;
					break;
				case firstLongFormat():
					if (instBytes & 3) {
						return PrimErrBadReceiver;
					}
					newFormat = classFormat + ((2 - instBytes) & 1);
					break;
				case firstByteFormat():
					newFormat = classFormat + ((8 - instBytes) & 7);
					break;
				default:
					error("Case not found and no otherwise clause");
				}
				break;
			case firstByteFormat():
				if ((classFormat < (sixtyFourBitIndexableFormat()))
				 || (classFormat >= (firstCompiledMethodFormat()))) {
					return PrimErrInappropriate;
				}
				
				switch (classFormat) {
				case sixtyFourBitIndexableFormat():
					if (instBytes & 7) {
						return PrimErrBadReceiver;
					}
					newFormat = classFormat;
					break;
				case firstLongFormat():
					if (instBytes & 3) {
						return PrimErrBadReceiver;
					}
					newFormat = classFormat + ((2 - instBytes) & 1);
					break;
				case firstShortFormat():
					if (instBytes & 1) {
						return PrimErrBadReceiver;
					}
					newFormat = classFormat + ((4 - instBytes) & 3);
					break;
				default:
					error("Case not found and no otherwise clause");
				}
				newFormat = classFormat;
				break;
			case firstCompiledMethodFormat():
				if (classFormat != (firstCompiledMethodFormat())) {
					return PrimErrInappropriate;
				}
				newFormat = instFormat;
				break;
			default:
				error("Case not found and no otherwise clause");
			}
		}
	}
	if (((classIndex = ensureBehaviorHash(argClass))) < 0) {
		return -classIndex;
	}
	/* begin set:classIndexTo:formatTo: */
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((newFormat >= 0) && (newFormat <= (formatMask()))));
	longAtput(rcvr, ((longAt(rcvr)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex + (((long)newFormat) << (formatShift()))));
	return 0;
}


/*	Answer the C double precision floating point value of the argument,
	or if it is not, answer 0. */

	/* Spur64BitMemoryManager>>#dbgFloatValueOf: */
static double NoDbgRegParms
dbgFloatValueOf(sqInt oop)
{
    sqInt bits;
    double result;
    sqInt rot;
    sqInt tagBits;

	if (((tagBits = oop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(oop));
			rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			return (((double *) ((&bits))))[0];
		}
	}
	else {
		if (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(oop + BaseHeaderSize, result);
			return result;
		}
	}
	return 0.0;
}


/*	Answer the exponent of the argument, a SmallFloat.
	See section 61-bit Immediate Floats in the SpurMemoryManager class
	comment. msb lsb 
	[8expsubset][52mantissa][1s][3tags] */

	/* Spur64BitMemoryManager>>#exponentOfSmallFloat: */
static sqInt NoDbgRegParms
exponentOfSmallFloat(sqInt oop)
{
    sqInt exp;

	assert((oop & (tagMask())) == (smallFloatTag()));
	return ((((usqInt)oop)) <= 15
		? 0
		: ((exp = ((usqInt) (((usqInt)oop))) >> (((numTagBits()) + (smallFloatMantissaBits())) + 1)),
			(exp + (smallFloatExponentOffset())) - 0x3FE));
}

	/* Spur64BitMemoryManager>>#floatObjectOf: */
sqInt
floatObjectOf(double aFloat)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newFloatObj;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqLong rawFloat;
    unsigned long rot;

	if (isSmallFloatValue(aFloat)) {
		/* begin smallFloatObjectOf: */
		assert(isSmallFloatValue(aFloat));
		rawFloat = (((sqLong *) ((&aFloat))))[0];
		rot = ((((unsigned sqLong)rawFloat) >> 0x3F) & 1) + (((long)rawFloat) << 1);
		if (rot > 1) {

			/* a.k.a. ~= +/-0.0 */
			rot -= ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			assert(rot > 0);
		}
		return (((long)rot) << (numTagBits())) + (smallFloatTag());
	}
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = firstLongFormat();
	numSlots = (sizeof(double)) / BytesPerOop;
	assert((numSlots >= 0)
	 && (ClassFloatCompactIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassFloatCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newFloatObj = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + ClassFloatCompactIndex);
	GIV(freeStart) += numBytes;
	newFloatObj = newObj;
l1:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Answer the C double precision floating point value of the argument,
	or fail if it is not a Float, and answer 0.
	Note: May be called by translated primitive code. */

	/* Spur64BitMemoryManager>>#floatValueOf: */
double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bits;
    double result;
    sqInt rot;
    sqInt tagBits;

	if (((tagBits = oop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(oop));
			rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
			if (rot > 1) {

				/* a.k.a. ~= +/-0.0 */
				rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
			}
			rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
			bits = rot;
			return (((double *) ((&bits))))[0];
		}
	}
	else {
		if (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(oop + BaseHeaderSize, result);
			return result;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	must have room for a header (single or double) plus the next free pointer */

	/* Spur64BitMemoryManager>>#initFreeChunkWithBytes:at: */
static sqInt NoDbgRegParms
initFreeChunkWithBytesat(usqLong numBytes, sqInt address)
{
    sqInt numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= (BaseHeaderSize + BytesPerOop)));
	if (numBytes >= ((((long)(numSlotsMask())) << (shiftForWord())) + BaseHeaderSize)) {
		numSlots = ((usqInt) ((numBytes - BaseHeaderSize) - BaseHeaderSize)) >> (shiftForWord());
		longAtput(address, (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots);
		longAtput(address + 8, ((long)(numSlotsMask())) << (numSlotsFullShift()));
		return address + 8;
	}
	numSlots = ((usqInt) (numBytes - BaseHeaderSize)) >> (shiftForWord());
	assert(numSlots < (numSlotsMask()));
	longAtput(address, ((long)numSlots) << (numSlotsFullShift()));
	return address;
}


/*	must have room for a double header */

	/* Spur64BitMemoryManager>>#initSegmentBridgeWithBytes:at: */
static void NoDbgRegParms
initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address)
{
    sqInt numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= (BaseHeaderSize + BaseHeaderSize)));
	numSlots = ((usqInt) ((numBytes - BaseHeaderSize) - BaseHeaderSize)) >> (shiftForWord());
	if (numSlots == 0) {

		/* short bridge for adjacent segments */
		longAtput(address, (((1LL << 30) + (1LL << 55)) + (((long)(sixtyFourBitIndexableFormat())) << (formatShift()))) + 3);
	}
	else {

		/* long bridge */
		longAtput(address, (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots);
		longAtput(address + BaseHeaderSize, ((((((long)(numSlotsMask())) << (numSlotsFullShift())) + (1LL << 30)) + (1LL << 55)) + (((long)(sixtyFourBitIndexableFormat())) << (formatShift()))) + 3);
	}
}


/*	Allocate an instance of a variable class, excepting CompiledMethod. */

	/* Spur64BitMemoryManager>>#instantiateClass:indexableSize: */
sqInt
instantiateClassindexableSize(sqInt classObj, usqInt nElements)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt fillValue;
    sqInt hash;
    usqInt instSpec;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt p;

	classFormat = ((longAt((classObj + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
	instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	fillValue = 0;
	
	switch (instSpec) {
	case 2:
		numSlots = nElements;
		fillValue = GIV(nilObj);
		break;
	case indexablePointersFormat():
	case weakArrayFormat():
		numSlots = (classFormat & ((1LL << (fixedFieldsFieldWidth())) - 1)) + nElements;
		fillValue = GIV(nilObj);
		break;
	case sixtyFourBitIndexableFormat():
		numSlots = nElements;
		break;
	case firstLongFormat():
		if ((classIndex == ClassFloatCompactIndex)
		 && (nElements != 2)) {
			GIV(primFailCode) = PrimErrBadReceiver;
			return null;
		}
		numSlots = (nElements + 1) / 2;
		instSpec += nElements & 1;
		break;
	case firstShortFormat():
		numSlots = (nElements + 3) / 4;
		instSpec += (4 - nElements) & 3;
		break;
	case firstByteFormat():
		numSlots = (nElements + 7) / 8;
		instSpec += (8 - nElements) & 7;
		break;
	default:
		
		/* some Squeak images include funky fixed subclasses of abstract variable
		   superclasses. e.g. DirectoryEntry as a subclass of ArrayedCollection.
		   Allow fixed classes to be instantiated here iff nElements = 0. */
		if ((nElements != 0)
		 || (instSpec > 5)) {
			return null;
		}
		numSlots = classFormat & ((1LL << (fixedFieldsFieldWidth())) - 1);

	}
	if (classIndex == 0) {
		/* begin ensureBehaviorHash: */
		assert(addressCouldBeClassObj(classObj));
		classIndex = (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
			? hash
			: (objCouldBeClassObj(classObj)
					? (((err = enterIntoClassTable(classObj))) != 0
							? -err
							: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
					: -PrimErrBadReceiver));
		if (classIndex < 0) {
			GIV(primFailCode) = -classIndex;
			return null;
		}
	}
	if (numSlots > ((1LL << (fixedFieldsFieldWidth())) - 1)) {
		if (numSlots > (0x10000000000ULL)) {
			GIV(primFailCode) = PrimErrUnsupported;
			return null;
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (((long)(((numSlots < 1) ? 1 : numSlots))) << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), instSpec, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				newObj = null;
				goto l1;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots);
			longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), instSpec, classIndex));
		}
		else {
			longAtput(newObj1, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)instSpec) << (formatShift()))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l1:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8) {
			longAtput(p, fillValue);
		}
	}
	return newObj;
}


/*	Convert the integer value, assumed to be in SmallInteger range, into a
	tagged SmallInteger object.
	In C, use a shift and an add to set the tag bit.
	In Smalltalk we have to work harder because the simulator works with
	strictly positive bit patterns. */

	/* Spur64BitMemoryManager>>#integerObjectOf: */
sqInt
integerObjectOf(sqInt value)
{
	return (((long)value) << (numTagBits())) + 1;
}


/*	Translator produces 'oop >> 3' */

	/* Spur64BitMemoryManager>>#integerValueOf: */
sqInt
integerValueOf(sqInt oop)
{
	return ((((usqInt) oop >> 63)) == 1
		? ((((((-(numTagBits())) < 0) ? ((usqInt) oop >> -(-(numTagBits()))) : ((usqInt) oop << (-(numTagBits()))))) & 0x1FFFFFFFFFFFFFFFULL) - 0x1FFFFFFFFFFFFFFFULL) - 1
		: (((-(numTagBits())) < 0) ? ((usqInt) oop >> -(-(numTagBits()))) : ((usqInt) oop << (-(numTagBits())))));
}

	/* Spur64BitMemoryManager>>#isImmediateFloat: */
static sqInt NoDbgRegParms
isImmediateFloat(sqInt oop)
{
	return (oop & (tagMask())) == (smallFloatTag());
}

	/* Spur64BitMemoryManager>>#isIntegerObject: */
sqInt
isIntegerObject(sqInt oop)
{
	return (oop & (tagMask())) == 1;
}


/*	Answer if the given value can be represented as a Smalltalk integer value.
	In 64-bits we use a 3 bit tag which leaves 61 bits for 2's complement
	signed integers. In C, use a shift add and mask to test if the top 4 bits
	are all the same.
	Since 16rFFFFFFFFFFFFFFFF >> 60 = 16rF the computation intValue >> 60 + 1
	bitAnd: 16rF
	maps in-range -ve values to 0 and in-range +ve values to 1. */

	/* Spur64BitMemoryManager>>#isIntegerValue: */
sqInt
isIntegerValue(sqInt intValue)
{
	return (((((usqInt) intValue) >> 60) + 1) & 15) <= 1;
}

	/* Spur64BitMemoryManager>>#isMarked: */
sqInt
isMarked(sqInt objOop)
{
	return ((((usqInt) (longAt(objOop))) >> 55) & 1) != 0;
}

	/* Spur64BitMemoryManager>>#isSmallFloatValue: */
static sqInt NoDbgRegParms
isSmallFloatValue(double aFloat)
{
    sqInt exponent;
    sqLong rawFloat;

	rawFloat = (((sqLong *) ((&aFloat))))[0];
	exponent = (((unsigned sqLong)rawFloat) >> (smallFloatMantissaBits())) & 0x7FF;
	return (exponent > (smallFloatExponentOffset())
		? exponent <= (0xFF + (smallFloatExponentOffset()))
		: ((rawFloat & ((1LL << (smallFloatMantissaBits())) - 1)) == 0
				? exponent == 0
				: exponent == (smallFloatExponentOffset())));
}

	/* Spur64BitMemoryManager>>#isSmallFloatZero: */
static inline sqInt NoDbgRegParms
isSmallFloatZero(sqInt aSmallFloat)
{
	assert(isImmediateFloat(aSmallFloat));
	return (((usqInt)aSmallFloat)) <= ((1LL << (numTagBits())) + (smallFloatTag()));
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes)
	should be subtracted from the result of this method. */

	/* Spur64BitMemoryManager>>#lengthOf:format: */
static sqInt NoDbgRegParms
lengthOfformat(sqInt objOop, sqInt fmt)
{
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (((long)numSlots) << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}


/*	Answer the maximum number of slots we are willing to attempt to allocate
	in an object.
	Must fit in 56-bits; c.f. bytesInObject: */

	/* Spur64BitMemoryManager>>#maxSlotsForAlloc */
static sqInt
maxSlotsForAlloc(void)
{
	return 0x10000000000ULL;
}


/*	Answer the number of free lists. We use freeListsMask, a bitmap, to avoid
	reading empty list heads. This should fit in a machine word to end up in a
	register during free chunk allocation. */

	/* Spur64BitMemoryManager>>#numFreeLists */
static sqInt
numFreeLists(void)
{
	return 64;
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated numSlots. If the word
	following an object doesn't have a saturated numSlots field it must be a
	single-header object.
	If the word following does have a saturated numSlots it must be the
	overflow size word. */

	/* Spur64BitMemoryManager>>#objectAfter:limit: */
static sqInt NoDbgRegParms
objectAfterlimit(sqInt objOop, sqInt limit)
{
    sqInt followingWord;
    sqInt followingWordAddress;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt slotBytes;

	/* begin addressAfter: */
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (numSlots == 0) {
		slotBytes = 8;
	}
	else {
		slotBytes = ((long)numSlots) << (shiftForWord());
	}
	followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
	if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
		return limit;
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	return ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
		? followingWordAddress + BaseHeaderSize
		: followingWordAddress);
}


/*	Answer the C double precision floating point value of the argument, a
	SmallFloat. See section 61-bit Immediate Floats in the SpurMemoryManager
	class comment.
	msb lsb 
	Decode:				[8expsubset][52mantissa][1s][3tags] 
	shift away tags:		[ 000 ][8expsubset][52mantissa][1s] 
	add exponent offset:	[ 11 exponent ][52mantissa][1s] 
	rot sign:				[1s][ 11 exponent ][52mantissa] */

	/* Spur64BitMemoryManager>>#smallFloatValueOf: */
static double NoDbgRegParms
smallFloatValueOf(sqInt oop)
{
    sqInt bits;
    sqInt rot;

	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((usqInt) (((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += ((long)(smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1);
	}
	rot = (((long)rot) << 0x3F) + (((usqInt) (((unsigned long)rot))) >> 1);
	bits = rot;
	return (((double *) ((&bits))))[0];
}


/*	Answer the total number of bytes in an object without an overflow header,
	including header bytes.
 */

	/* Spur64BitMemoryManager>>#smallObjectBytesForSlots: */
usqInt
smallObjectBytesForSlots(sqInt numSlots)
{
	return BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
}

	/* Spur64BitMemoryManager>>#wordIndexableFormat */
static sqInt
wordIndexableFormat(void)
{
	return sixtyFourBitIndexableFormat();
}


/*	ephemeronCorpse is the corpse of an ephemeron that was copied and
	forwarded. Later on its surviving copy must be scanned to nil weak
	references. Thread the corpse onto the weakList. Later, the weakList can
	be followed, and
	the forwarding pointer followed to locate the survivor. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#addToEphemeronList: */
static void NoDbgRegParms NeverInline
addToEphemeronList(sqInt ephemeronCorpse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeronListOffset;
    sqInt format;
    sqInt hash;

	assert(!(isScavengeSurvivor(keyOfEphemeron(followForwarded(ephemeronCorpse)))));
	ephemeronListOffset = (!(GIV(ephemeronList))
		? 0
		: GIV(ephemeronList));
	/* begin setCorpseOffsetOf:to: */
	assert(isYoung(ephemeronCorpse));
	assert(isForwarded(ephemeronCorpse));
	
	/* So we use the single assignment */
	long64Atput(ephemeronCorpse, headerForSlotshashformatclassIndex(byteAt(ephemeronCorpse + 7), ((usqInt) ephemeronListOffset) >> 5, ephemeronListOffset & (formatMask()), isForwardedObjectClassIndexPun()));

	GIV(ephemeronList) = (((usqInt) (ephemeronCorpse - GIV(newSpaceStart))) >> 3) + 1;
	assert((firstCorpse(GIV(ephemeronList))) == ephemeronCorpse);
}


/*	weakCorpse is the corpse of a weak array that was copied and forwarded.
	Later on its surviving copy must be scanned to nil weak references.
	Thread the corpse onto the weakList. Later, the weakList can be followed,
	and the forwarding pointer followed to locate the survivor. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#addToWeakList: */
static void NoDbgRegParms NeverInline
addToWeakList(sqInt weakCorpse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt format;
    sqInt hash;
    sqInt weakListOffset;

	weakListOffset = (!(GIV(weakList))
		? 0
		: GIV(weakList));
	/* begin setCorpseOffsetOf:to: */
	assert(isYoung(weakCorpse));
	assert(isForwarded(weakCorpse));
	
	/* So we use the single assignment */
	long64Atput(weakCorpse, headerForSlotshashformatclassIndex(byteAt(weakCorpse + 7), ((usqInt) weakListOffset) >> 5, weakListOffset & (formatMask()), isForwardedObjectClassIndexPun()));

	GIV(weakList) = (((usqInt) (weakCorpse - GIV(newSpaceStart))) >> 3) + 1;
	assert((firstCorpse(GIV(weakList))) == weakCorpse);
}

	/* SpurGenerationScavenger>>#allNewSpaceObjectsHaveZeroRTRefCount */
static sqInt
allNewSpaceObjectsHaveZeroRTRefCount(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt slotBytes;
    sqInt slotBytes1;

	/* begin allNewSpaceObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots3 = byteAt(address + 7);
	objOop1 = (numSlots3 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> (rememberedBitShift())) & MaxRTRefCount) > 0) {
			return 0;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop1 + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots4 = byteAt(address1 + 7);
	objOop1 = (numSlots4 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> (rememberedBitShift())) & MaxRTRefCount) > 0) {
			return 0;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	return 1;
}

	/* SpurGenerationScavenger>>#allWeakSurvivorsOnWeakList */
static sqInt
allWeakSurvivorsOnWeakList(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt followingWord;
    sqInt followingWordAddress;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt slotBytes;
    sqInt survivor;

	/* begin allFutureSpaceEntitiesDo: */
	prevPrevObj = (prevObj = null);
	/* begin objectStartingAt: */
	address = (GIV(futureSpace).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(futureSurvivorStart);
	while (oopisLessThan(objOop, limit)) {
		if (isWeakFormat((((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask()))) {
			if (!(isonWeaklingList(objOop, GIV(weakList)))) {
				return 0;
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop + 7);
		numSlots2 = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return 1;
}


/*	Some time in every scavenger's life there may come a time when someone
	writes code that stresses
	the remembered table. One might conclude that if the remembered table is
	full, then the right thing
	to do is simply to tenure everything, emptying the remembered table. Bt in
	some circumstances this
	can be counter-productive, and result in the same situation arising soon
	after tenuring everything.
	Instead, we can try and selectively prune the remembered table, tenuring
	only those objects that
	are referenced by many objects in the remembered table. That's what this
	algorithm does. It
	reference counts young objects referenced from the remembered set, and
	then sets a threshold
	used to tenure objects oft referenced from the remembered set, thereby
	allowing the remembered
	set to shrink, while not tenuring everything.
	
	Once in a network monitoring application in a galaxy not dissimilar from
	the one this code inhabits,
	a tree of nodes referring to large integers was in precisely this
	situation. The nodes were old, and
	the integers were in new space. Some of the nodes referred to shared
	numbers, some their own
	unique numbers. The numbers were updated frequently. Were new space simply
	tenured when the
	remembered table was full, the remembered table would soon fill up as new
	numbers were computed.
	Only by selectively pruning the remembered table of nodes that shared
	data, was a balance achieved
	whereby the remembered table population was kept small, and tenuring rates
	were low. */

	/* SpurGenerationScavenger>>#computeRefCountToShrinkRT */
static void NeverInline
computeRefCountToShrinkRT(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt elephant;
    sqInt entirePopulation;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt j;
    sqInt j1;
    sqInt jLimiT;
    long population[MaxRTRefCount + 1];
    sqInt refCount;
    sqInt referent;

	memset(population, 0, (sizeof(long)) * (MaxRTRefCount + 1));
	assert(allNewSpaceObjectsHaveZeroRTRefCount());
	/* begin referenceCountRememberedReferents: */
	for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
		elephant = GIV(rememberedSet)[i1];
		for (j1 = 0, jLimiT = ((numPointerSlotsOf(elephant)) - 1); j1 <= jLimiT; j1 += 1) {
			referent = longAt((elephant + BaseHeaderSize) + (((long)j1) << (shiftForWord())));
			if (((referent & (tagMask())) == 0)
			 && (isYoungObject(referent))) {
				refCount = (((usqInt) (longAt(referent))) >> (rememberedBitShift())) & MaxRTRefCount;
				if (refCount < MaxRTRefCount) {
					if (refCount > 0) {
						population[refCount] = ((population[refCount]) - 1);
					}
					refCount += 1;
					/* begin rtRefCountOf:put: */
					assert(((refCount >= 0) && (refCount <= MaxRTRefCount)));
					header = longAt(referent);
					header = header & (~(7LL << (rememberedBitShift())));
					header += ((long)refCount) << (rememberedBitShift());
					longAtput(referent, header);
					population[refCount] = ((population[refCount]) + 1);
				}
			}
		}
	}
	/* begin setRefCountToShrinkRT: */
	assert((population[0]) == 0);
	entirePopulation = 0;
	for (j = 1; j <= MaxRTRefCount; j += 1) {
		entirePopulation += population[j];
	}
	count = 0;
	i = MaxRTRefCount + 1;
	while ((count < (entirePopulation / 2))
	 && (((i -= 1)) >= 0)) {
		count += population[i];
	}
	GIV(refCountToShrinkRT) = ((i < 0) ? 0 : i);
}


/*	copyAndForward: survivor copies a survivor object either to
	futureSurvivorSpace or, if it is to be promoted, to oldSpace.
	It leaves a forwarding pointer behind. If the object is weak
	then corpse is threaded onto the weakList for later treatment. */

	/* SpurGenerationScavenger>>#copyAndForward: */
static sqInt NoDbgRegParms
copyAndForward(sqInt survivor)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInObj;
    sqInt classIndex;
    sqInt format;
    sqInt header;
    sqInt newLocation;
    sqInt newStart;
    sqInt startOfSurvivor;
    sqInt tenure;

	assert((isInEden(survivor))
	 || (isInPastSpace(survivor)));
	bytesInObj = bytesInObject(survivor);
	format = (((usqInt) (longAt(survivor))) >> (formatShift())) & (formatMask());

	/* Allow Slang to inline. */
	
	switch (GIV(tenureCriterion)) {
	case TenureByAge:
		tenure = survivor < GIV(tenureThreshold);

		break;
	case TenureByClass:
		tenure = ((longAt(survivor)) & (classIndexMask())) == GIV(tenuringClassIndex);

		break;
	case TenureToShrinkRT:
		tenure = ((((usqInt) (longAt(survivor))) >> (rememberedBitShift())) & MaxRTRefCount) >= GIV(refCountToShrinkRT);

		break;
	default:
		tenure = 0;

	}
	if (tenure
	 || ((GIV(futureSurvivorStart) + bytesInObj) > ((GIV(futureSpace).limit)))) {
		newLocation = copyToOldSpacebytesformat(survivor, bytesInObj, format);
	}
	else {
		/* begin copyToFutureSpace:bytes: */

		/* we hope writes are cheap... */
		GIV(statSurvivorCount) += 1;
		assert((GIV(futureSurvivorStart) + bytesInObj) <= ((GIV(futureSpace).limit)));
		startOfSurvivor = ((byteAt(survivor + 7)) == (numSlotsMask())
			? survivor - BaseHeaderSize
			: survivor);
		newStart = GIV(futureSurvivorStart);
		GIV(futureSurvivorStart) += bytesInObj;
		memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObj);
		if (GIV(tenureCriterion) == TenureToShrinkRT) {
			/* begin rtRefCountOf:put: */
			assert(((0 >= 0) && (0 <= MaxRTRefCount)));
			header = longAt(newStart + (survivor - startOfSurvivor));
			header = header & (~(7LL << (rememberedBitShift())));
			header += 0LL << (rememberedBitShift());
			longAtput(newStart + (survivor - startOfSurvivor), header);
		}
		newLocation = newStart + (survivor - startOfSurvivor);
	}
	/* begin forwardSurvivor:to: */
	assert(isInNewSpace(survivor));
	assert((isInFutureSpace(newLocation))
	 || (isInOldSpace(newLocation)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(survivor)));
	longAtput((survivor + BaseHeaderSize) + (0LL << (shiftForWord())), newLocation);
	/* begin set:classIndexTo:formatTo: */
	classIndex = isForwardedObjectClassIndexPun();
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((7 >= 0) && (7 <= (formatMask()))));
	longAtput(survivor, ((longAt(survivor)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex + (7LL << (formatShift()))));
	if (format == (weakArrayFormat())) {
		addToWeakList(survivor);
	}
	if ((format == 5)
	 && (!(isScavengeSurvivor(keyOfEphemeron(newLocation))))) {
		addToEphemeronList(survivor);
	}
	return newLocation;
}


/*	Copy survivor to oldSpace. Answer the new oop of the object. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#copyToOldSpace:bytes:format: */
static sqInt NoDbgRegParms NeverInline
copyToOldSpacebytesformat(sqInt survivor, sqInt bytesInObject, sqInt formatOfSurvivor)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt header;
    sqInt newOop;
    sqInt newStart;
    sqInt nTenures;
    sqInt p;
    sqInt startOfSurvivor;

	assert((formatOfSurvivor == (formatOf(survivor)))
	 && (((!(isMarked(survivor)))
	 || (GIV(tenureCriterion) == MarkOnTenure))
	 && ((GIV(tenureCriterion) == TenureToShrinkRT)
	 || ((!(isPinned(survivor)))
	 && (!(isRemembered(survivor)))))));
	nTenures = GIV(statTenures);
	startOfSurvivor = ((byteAt(survivor + 7)) == (numSlotsMask())
		? survivor - BaseHeaderSize
		: survivor);
	newStart = allocateOldSpaceChunkOfBytes(bytesInObject);
	if (!(newStart)) {
		growOldSpaceByAtLeast(0);
		newStart = allocateOldSpaceChunkOfBytes(bytesInObject);
		if (!(newStart)) {
			error("out of memory");
		}
	}
	memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObject);
	newOop = newStart + (survivor - startOfSurvivor);
	if (GIV(tenureCriterion) >= (((TenureToShrinkRT < MarkOnTenure) ? TenureToShrinkRT : MarkOnTenure))) {
		if (GIV(tenureCriterion) == TenureToShrinkRT) {
			/* begin rtRefCountOf:put: */
			assert(((0 >= 0) && (0 <= MaxRTRefCount)));
			header = longAt(newOop);
			header = header & (~(7LL << (rememberedBitShift())));
			header += 0LL << (rememberedBitShift());
			longAtput(newOop, header);
		}
		if (GIV(tenureCriterion) == MarkOnTenure) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(newOop)));
			longAtput(newOop, (longAt(newOop)) | (1LL << 55));
		}
	}
	GIV(statTenures) = nTenures + 1;
	if ((formatOfSurvivor <= 5)
	 || (formatOfSurvivor >= (firstCompiledMethodFormat()))) {

		/* A very quick and dirty scan to find young referents.  If we misidentify bytes
		   in a CompiledMethod as young we don't care; it's unlikely, and a subsequent
		   scan of the rt will filter the object out.  But it's good to filter here because
		   otherwise an attempt to shrink the RT may simply fill it up with new objects,
		   and here the data is likely in the cache. */
		for (p = BaseHeaderSize; p <= ((bytesInObject - (survivor - startOfSurvivor)) - BytesPerWord); p += BytesPerWord) {
			field = longAt(survivor + p);
			if (((field & (tagMask())) == 0)
			 && (isYoungObject(field))) {
				remember(newOop);
				return newOop;
			}
		}
	}
	return newOop;
}

	/* SpurGenerationScavenger>>#firstCorpse: */
static sqInt NoDbgRegParms
firstCorpse(sqInt headOfCorpseList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((long)(headOfCorpseList - 1)) << 3) + GIV(newSpaceStart);
}

	/* SpurGenerationScavenger>>#growRememberedSet */
static void
growRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt *base;
    sqInt fudge;
    sqInt i;
    sqInt newObj;
    sqInt nSlots;
    sqInt nSlots1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    usqInt p;
    usqInt p1;


	/* Don't ruin locality in remember: */
	obj = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)RememberedSetRootIndex) << (shiftForWord())));
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(obj)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(obj + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(obj - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	assert(numSlots >= 1024);
	/* begin allocatePinnedSlots: */
	nSlots1 = numSlots * 2;
	obj2 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots1, (((long)(((nSlots1 < 1) ? 1 : nSlots1))) << (shiftForWord())) + ((nSlots1 >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), sixtyFourBitIndexableFormat(), 19);
	if (!(obj2 == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((obj2 + BaseHeaderSize) + (nSlots1 * BytesPerOop)) - 1, addressAfter(obj2)));
		for (p1 = (((usqInt)(obj2 + BaseHeaderSize))); p1 <= (((usqInt)(((obj2 + BaseHeaderSize) + (nSlots1 * BytesPerOop)) - 1))); p1 += 8) {
			longAtput(p1, 0);
		}
	}
	newObj = obj2;
	if (!(newObj)) {
		/* begin allocatePinnedSlots: */
		nSlots = numSlots + 1024;
		obj1 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots, (((long)(((nSlots < 1) ? 1 : nSlots))) << (shiftForWord())) + ((nSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), sixtyFourBitIndexableFormat(), 19);
		if (!(obj1 == null)) {
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((obj1 + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1, addressAfter(obj1)));
			for (p = (((usqInt)(obj1 + BaseHeaderSize))); p <= (((usqInt)(((obj1 + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1))); p += 8) {
				longAtput(p, 0);
			}
		}
		newObj = obj1;
		if (!(newObj)) {
			error("could not grow remembered set");
		}
	}
	/* begin rememberedSetObj: */
	assert(isOldObject(newObj));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(GIV(hiddenRootsObj))));
	longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)RememberedSetRootIndex) << (shiftForWord())), newObj);
	base = firstIndexableField(newObj);
	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		base[i] = (GIV(rememberedSet)[i]);
	}
	if (((((usqInt) (longAt(obj))) >> 55) & 1) != 0) {
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(newObj)));
		longAtput(newObj, (longAt(newObj)) | (1LL << 55));
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(obj)));
		longAtput(obj, (longAt(obj)) & (~(1LL << 55)));
	}
	freeObject(obj);
	GIV(rememberedSet) = base;
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(newObj)) > (isForwardedObjectClassIndexPun()));
	numSlots2 = byteAt(newObj + 7);
	GIV(rememberedSetLimit) = (numSlots2 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(newObj - BaseHeaderSize))) << 8)))) >> 8
		: numSlots2);
	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 1024;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
}

	/* SpurGenerationScavenger>>#isInRememberedSet: */
static sqInt NoDbgRegParms
isInRememberedSet(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		if ((GIV(rememberedSet)[i]) == objOop) {
			return 1;
		}
	}
	return 0;
}


/*	Answer whether the oop has survived a scavenge. This version is
	for processing weak survivors and must cope with the scavenge in
	freeUnmarkedObjectsAndSortAndCoalesceFreeSpaceForPigCompact. */

	/* SpurGenerationScavenger>>#isMaybeOldScavengeSurvivor: */
static sqInt NoDbgRegParms
isMaybeOldScavengeSurvivor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt target;

	if ((oop & (tagMask())) != 0) {
		return 1;
	}
	if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(oop));
		referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		target = referent;
		if ((oop & (tagMask())) != 0) {
			return 1;
		}
	}
	else {
		target = oop;
	}
	return (isOldObject(target)
		? (GIV(tenureCriterion) != MarkOnTenure)
			 || (((((usqInt) (longAt(target))) >> 55) & 1) != 0)
		: oopisGreaterThanOrEqualToandLessThan(target, ((futureSpace()).start), futureSurvivorStart()));
}


/*	Answer whether the oop has survived a scavenge. This is equivalent to
	| target |
	(manager isImmediate: oop) ifTrue:
	[^true].
	target := (manager isForwarded: oop)
	ifTrue: [manager followForwarded: oop]
	ifFalse: [oop].
	^((manager isInEden: target)
	or: [(manager isInPastSpace: target)]) not */

	/* SpurGenerationScavenger>>#isScavengeSurvivor: */
static sqInt NoDbgRegParms
isScavengeSurvivor(sqInt oop)
{
    sqInt referent;
    sqInt target;

	if ((oop & (tagMask())) != 0) {
		return 1;
	}
	if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(oop));
		referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		target = referent;
	}
	else {
		target = oop;
	}
	return (!(((target & (tagMask())) == 0)
 && (isYoungObject(target))))
	 || (oopisGreaterThanOrEqualToandLessThan(target, ((futureSpace()).start), futureSurvivorStart()));
}

	/* SpurGenerationScavenger>>#is:onWeaklingList: */
static sqInt NoDbgRegParms
isonWeaklingList(sqInt oop, sqInt listHead)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt corpse;
    sqInt listOffset;

	corpse = (((long)(listHead - 1)) << 3) + GIV(newSpaceStart);
	while (corpse != null) {
		if (oop == (followForwarded(corpse))) {
			return 1;
		}
		/* begin nextCorpseOrNil: */
		assert(isYoung(corpse));
		listOffset = (((long)((long32At(corpse + 4)) & (identityHashHalfWordMask()))) << 5) + ((((usqInt) (longAt(corpse))) >> (formatShift())) & (formatMask()));
		corpse = (listOffset != 0
			? (((long)(listOffset - 1)) << 3) + GIV(newSpaceStart)
			: 0);
	}
	return 0;
}

	/* SpurGenerationScavenger>>#newSpaceCapacity */
static usqInt
newSpaceCapacity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(eden).limit)) - (((((GIV(futureSpace).start)) < ((GIV(pastSpace).start))) ? ((GIV(futureSpace).start)) : ((GIV(pastSpace).start))));
}


/*	For assert checking only. */

	/* SpurGenerationScavenger>>#noUnfiredEphemeronsAtEndOfRememberedSet */
static sqInt
noUnfiredEphemeronsAtEndOfRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt referrer;

	for (i = GIV(numRememberedEphemerons); i < GIV(rememberedSetSize); i += 1) {
		referrer = GIV(rememberedSet)[i];
		if (isEphemeron(referrer)) {
			if (!(isScavengeSurvivor(keyOfEphemeron(referrer)))) {
				return 0;
			}
		}
	}
	return 1;
}


/*	There are ephemerons to be scavenged. Scavenge them and fire any whose
	keys are
	still in pastSpace and/or eden. The unscavenged ephemerons in this cycle
	can only be
	fired if all the unscavenged ephemerons in this cycle are firable, because
	references to ephemeron keys from unfired ephemerons should prevent the
	ephemerons with
	those keys from firing. So scavenge ephemerons with surviving keys, and
	only if none
	are found, fire ephemerons with unreferenced keys, and scavenge them. Read
	the class comment for a more in-depth description of the algorithm. */

	/* SpurGenerationScavenger>>#processEphemerons */
static void
processEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt ephemeron1;
    sqInt ephemeronCorpse;
    sqInt hasNewReferents;
    sqInt i;
    sqInt i1;
    sqInt listOffset;
    sqInt referent;
    sqInt referrer;
    sqInt unfiredEphemeronsScavenged;
    sqInt unfiredEphemeronsScavenged1;
    sqInt valuePointer;
    sqInt valuePointer1;

	/* begin scavengeUnfiredEphemeronsInRememberedSet */
	unfiredEphemeronsScavenged1 = 0;
	i = 0;
	while (i < GIV(numRememberedEphemerons)) {
		referrer = GIV(rememberedSet)[i];
		assert(isEphemeron(referrer));
		if (isScavengeSurvivor(keyOfEphemeron(referrer))) {
			unfiredEphemeronsScavenged1 = 1;

			/* remove from unscanned ephemerons in set by swapping with last ephemeron */
			hasNewReferents = scavengeReferentsOf(referrer);
			GIV(numRememberedEphemerons) -= 1;
			GIV(rememberedSet)[i] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
			if (hasNewReferents) {

				/* keep in set */
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = referrer;
			}
			else {

				/* remove from set by overwriting with next-to-be scanned */
				GIV(previousRememberedSetSize) -= 1;
				GIV(rememberedSetSize) -= 1;
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = (GIV(rememberedSet)[GIV(previousRememberedSetSize)]);
				GIV(rememberedSet)[GIV(previousRememberedSetSize)] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
				/* begin setIsRememberedOf:to: */
				longAtput(referrer, (longAt(referrer)) & (~(1LL << (rememberedBitShift()))));
			}
		}
		else {
			i += 1;
		}
	}
	unfiredEphemeronsScavenged = unfiredEphemeronsScavenged1;
	if (scavengeUnfiredEphemeronsOnEphemeronList()) {
		unfiredEphemeronsScavenged = 1;
	}
	if (!unfiredEphemeronsScavenged) {
		/* begin fireEphemeronsInRememberedSet */
		assert(noUnfiredEphemeronsAtEndOfRememberedSet());
		i1 = 0;
		while (i1 < GIV(numRememberedEphemerons)) {
			ephemeron = GIV(rememberedSet)[i1];
			assert(isEphemeron(ephemeron));
			assert(!(isScavengeSurvivor(keyOfEphemeron(ephemeron))));
			/* begin fireEphemeron: */
			queueMourner(ephemeron);
			/* begin signalFinalization: */
			forceInterruptCheck();
			GIV(pendingFinalizationSignals) += 1;
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer = copyAndForward(keyOfEphemeron(ephemeron));
			assert(!(isForwarded(ephemeron)));
			longAtput((ephemeron + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
			if (scavengeReferentsOf(ephemeron)) {

				/* keep in set */
				i1 += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(ephemeron, (longAt(ephemeron)) & (~(1LL << (rememberedBitShift()))));
				GIV(numRememberedEphemerons) -= 1;
				GIV(previousRememberedSetSize) -= 1;

				/* First overwrite with last firable ephemeron (could be a noop if this is the last one).
				   Then overwrite last firable entry with next unscanned rememberedSet entry (could also be a noop).
				   Then overwrite next unscanned entry with last unscanned rememberedSet entry (could also be a noop). */
				GIV(rememberedSetSize) -= 1;
				GIV(rememberedSet)[i1] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = (GIV(rememberedSet)[GIV(previousRememberedSetSize)]);
				GIV(rememberedSet)[GIV(previousRememberedSetSize)] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
			}
		}
		GIV(numRememberedEphemerons) = 0;
		/* begin fireEphemeronsOnEphemeronList */
		if (!(GIV(ephemeronList))) {
			goto l1;
		}

		/* Reset the list head so that new ephemerons will get added
		   to a new list, not concatenated on the one we are scanning. */
		ephemeronCorpse = (((long)(GIV(ephemeronList) - 1)) << 3) + GIV(newSpaceStart);
		GIV(ephemeronList) = null;
		while (ephemeronCorpse != null) {
			assert(isForwarded(ephemeronCorpse));
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(ephemeronCorpse));
			referent = longAt((ephemeronCorpse + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent & (tagMask())) == 0)
			 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			ephemeron1 = referent;
			assert(!(isScavengeSurvivor(keyOfEphemeron(ephemeron1))));
			/* begin fireEphemeron: */
			queueMourner(ephemeron1);
			/* begin signalFinalization: */
			forceInterruptCheck();
			GIV(pendingFinalizationSignals) += 1;
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer1 = copyAndForward(keyOfEphemeron(ephemeron1));
			assert(!(isForwarded(ephemeron1)));
			longAtput((ephemeron1 + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer1);
			((void) (scavengeReferentsOf(ephemeron1)));
			/* begin nextCorpseOrNil: */
			assert(isYoung(ephemeronCorpse));
			listOffset = (((long)((long32At(ephemeronCorpse + 4)) & (identityHashHalfWordMask()))) << 5) + ((((usqInt) (longAt(ephemeronCorpse))) >> (formatShift())) & (formatMask()));
			ephemeronCorpse = (listOffset != 0
				? (((long)(listOffset - 1)) << 3) + GIV(newSpaceStart)
				: 0);
		}
	l1:	/* end fireEphemeronsOnEphemeronList */;
	}
}


/*	Go through the remembered set and the weak list, nilling references to
	any objects that didn't survive the scavenge. Read the class comment
	for a more in-depth description of the algorithm. */

	/* SpurGenerationScavenger>>#processWeaklings */
static void
processWeaklings(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt listOffset;
    sqInt referent;
    sqInt rootObj;
    sqInt weakCorpse;
    sqInt weakObj;

	assert(allWeakSurvivorsOnWeakList());
	i = 0;
	while (i < GIV(rememberedSetSize)) {
		rootObj = GIV(rememberedSet)[i];
		if (isWeakFormat((((usqInt) (longAt(rootObj))) >> (formatShift())) & (formatMask()))) {

			/* If no more referents, remove by overwriting with the last element in the set. */
			if (processWeakSurvivor(rootObj)) {
				i += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(rootObj, (longAt(rootObj)) & (~(1LL << (rememberedBitShift()))));
				if ((i + 1) < GIV(rememberedSetSize)) {
					GIV(rememberedSet)[i] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
				}
				GIV(rememberedSetSize) -= 1;
			}
		}
		else {
			i += 1;
		}
	}
	if (!(GIV(weakList) == null)) {
		weakCorpse = (((long)(GIV(weakList) - 1)) << 3) + GIV(newSpaceStart);
		while (weakCorpse != null) {
			assert(isForwarded(weakCorpse));
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(weakCorpse));
			referent = longAt((weakCorpse + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent & (tagMask())) == 0)
			 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			weakObj = referent;
			if ((processWeakSurvivor(weakObj))
			 && ((isOldObject(weakObj))
			 && (!(((((usqInt) (longAt(weakObj))) >> (rememberedBitShift())) & 1) != 0)))) {
				remember(weakObj);
			}
			/* begin nextCorpseOrNil: */
			assert(isYoung(weakCorpse));
			listOffset = (((long)((long32At(weakCorpse + 4)) & (identityHashHalfWordMask()))) << 5) + ((((usqInt) (longAt(weakCorpse))) >> (formatShift())) & (formatMask()));
			weakCorpse = (listOffset != 0
				? (((long)(listOffset - 1)) << 3) + GIV(newSpaceStart)
				: 0);
		}
		GIV(weakList) = null;
	}
}


/*	Process a weak survivor on the weakList. Those of its fields
	which have not survived the scavenge should be nilled, and if any
	are, the coInterpreter should be informed via fireFinalization:.
	Answer if the weakObj has any young referents. */

	/* SpurGenerationScavenger>>#processWeakSurvivor: */
static sqInt NoDbgRegParms
processWeakSurvivor(sqInt weakObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classPointer;
    sqInt hasYoungReferents;
    sqInt i;
    sqInt iLimiT;
    sqInt numStrongSlots;
    sqInt referent;
    sqInt referent1;
    sqInt weakObjShouldMourn;


	/* N.B. generateToByDoLimitExpression:negative:on: guards against (unsigned)0 - 1 going +ve */
	weakObjShouldMourn = (hasYoungReferents = 0);
	/* begin fixedFieldsOfClassFormat: */
	classPointer = fetchClassOfNonImm(weakObj);
	classFormat = ((longAt((classPointer + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
	numStrongSlots = classFormat & ((1LL << (fixedFieldsFieldWidth())) - 1);
	for (i = 0; i < numStrongSlots; i += 1) {
		referent = longAt((weakObj + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if (((referent & (tagMask())) == 0)
		 && (isYoungObject(referent))) {
			hasYoungReferents = 1;
		}
	}
	for (i = numStrongSlots, iLimiT = ((numSlotsOf(weakObj)) - 1); i <= iLimiT; i += 1) {

		/* Referent could be forwarded due to scavenging or a become:, don't assume. */
		referent = longAt((weakObj + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if ((referent & (tagMask())) == 0) {
			if (((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(referent));
				referent1 = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent1 & (tagMask())) == 0)
				 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				referent = referent1;
				assert((isReallyYoungObject(weakObj))
				 || (isRemembered(weakObj)));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(weakObj)));
				longAtput((weakObj + BaseHeaderSize) + (((long)i) << (shiftForWord())), referent);
			}
			if (isMaybeOldScavengeSurvivor(referent)) {
				if (isYoungObject(referent)) {
					hasYoungReferents = 1;
				}
			}
			else {
				weakObjShouldMourn = 1;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(weakObj)));
				longAtput((weakObj + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
			}
		}
	}
	if (weakObjShouldMourn) {
		/* begin fireFinalization: */
		if (GIV(newFinalization)) {
			queueMourner(weakObj);
		}
		/* begin signalFinalization: */
		forceInterruptCheck();
		GIV(pendingFinalizationSignals) += 1;
	}
	return hasYoungReferents;
}


/*	Add the argument to the remembered set and set its isRemembered bit to
	true. Answer the argument for the benefit of the Cogit. */

	/* SpurGenerationScavenger>>#remember: */
sqInt
remember(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	assert(!((isYoungObject(objOop))));
	assert(!((isRemembered(objOop))));
	assert(!((isInRememberedSet(objOop))));
	/* begin setIsRememberedOf:to: */
	longAtput(objOop, (longAt(objOop)) | (1LL << (rememberedBitShift())));
	if (GIV(rememberedSetSize) >= GIV(rememberedSetLimit)) {
		growRememberedSet();
	}
	GIV(rememberedSet)[GIV(rememberedSetSize)] = objOop;
	if (((GIV(rememberedSetSize) += 1)) >= GIV(rememberedSetRedZone)) {
		/* begin scheduleScavenge */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	return objOop;
}


/*	scavengeFutureSurvivorSpaceStartingAt: does a depth-first traversal of the
	new objects starting at the one at initialAddress in futureSurvivorSpace. */

	/* SpurGenerationScavenger>>#scavengeFutureSurvivorSpaceStartingAt: */
static void NoDbgRegParms
scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt ptr;
    sqInt slotBytes;

	ptr = initialAddress;
	while (ptr < GIV(futureSurvivorStart)) {
		/* begin objectStartingAt: */
		numSlots = byteAt(ptr + 7);
		obj = (numSlots == (numSlotsMask())
			? ptr + BaseHeaderSize
			: ptr);
		/* begin addressAfter: */
		numSlots1 = byteAt(obj + 7);
		numSlots2 = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(obj - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		ptr = (obj + BaseHeaderSize) + slotBytes;
		((void) (scavengeReferentsOf(obj)));
	}
}


/*	This is the inner loop of the main routine, scavenge. It first scavenges
	the new objects immediately
	reachable from old ones. Then it scavenges those that are transitively
	reachable. If this results in a
	promotion, the promotee gets remembered, and it first scavenges objects
	adjacent to the promotee,
	then scavenges the ones reachable from the promoted. This loop continues
	until no more reachable
	objects are left. At that point, pastSurvivorSpace is exchanged with
	futureSurvivorSpace. 
	Notice that each pointer in a live object is inspected once and only once.
	The previousRememberedSetSize
	and previousFutureSurvivorSpaceLimit variables ensure that no object is
	scanned twice, as well as
	detecting closure. If this were not true, some pointers might get
	forwarded twice.
	
	An extension of the algorithm presented in David's original paper is to
	handle weak arrays and ephemerons.
	Weak arrays should not have their weak referents scavenged unless there
	are strong references to them.
	Ephemerons should fire if their key is not reachable other than from
	ephemerons and weak arrays.
	Handle this by maintaining a list for weak arrays and a list for
	ephemerons, which allow scavenging these
	objects once all other objects in new space have been scavenged, hence
	allowing the scavenger to
	detect which referents in new space of weak arrays are dead and of
	ephemeron keys are only live due to
	ephemerons. Read the class comment for a more in-depth description of the
	algorithm.  */

	/* SpurGenerationScavenger>>#scavengeLoop */
static void
scavengeLoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstTime;
    sqInt i;
    sqInt i1;
    sqInt oop;
    sqInt previousFutureSurvivorStart;
    StackPage *thePage;

	assert(GIV(futureSurvivorStart) == ((GIV(futureSpace).start)));
	GIV(weakList) = (GIV(ephemeronList) = null);
	GIV(numRememberedEphemerons) = 0;
	firstTime = 1;
	GIV(previousRememberedSetSize) = 0;
	previousFutureSurvivorStart = GIV(futureSurvivorStart);
	/* begin initStackPageGC */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i1 = 0; i1 < GIV(numStackPages); i1 += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i1, GIV(pages));
		(thePage->trace = StackPageUnreached);
	}
	while(1) {
		scavengeRememberedSetStartingAt(GIV(previousRememberedSetSize));
		GIV(previousRememberedSetSize) = GIV(rememberedSetSize);
		if (firstTime) {
			mapInterpreterOops();
			/* begin mapExtraRoots */
			if ((((longAt(GIV(specialObjectsOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
			 || ((isReallyYoungObject(GIV(specialObjectsOop)))
			 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(specialObjectsOop), ((futureSpace()).start), futureSurvivorStart()))))) {
				GIV(specialObjectsOop) = remapObj(GIV(specialObjectsOop));
			}
			assert(GIV(remapBufferCount) == 0);
			for (i = 1; i <= GIV(extraRootCount); i += 1) {
				oop = (GIV(extraRoots)[i])[0];
				if (!(((oop & (tagMask())) != 0)
					 || (((longAt(oop)) & (classIndexMask())) == 0))) {
					if ((((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
					 || ((isReallyYoungObject(oop))
					 && (!(oopisGreaterThanOrEqualToandLessThan(oop, ((futureSpace()).start), futureSurvivorStart()))))) {
						(GIV(extraRoots)[i])[0] = (remapObj(oop));
					}
				}
			}
			firstTime = 0;
		}
		if ((GIV(previousRememberedSetSize) == GIV(rememberedSetSize))
		 && ((previousFutureSurvivorStart == GIV(futureSurvivorStart))
		 && ((GIV(numRememberedEphemerons) == 0)
		 && (GIV(ephemeronList) == null)))) {
			return;
		}
		scavengeFutureSurvivorSpaceStartingAt(previousFutureSurvivorStart);

		/* no more roots created to scavenge... */
		previousFutureSurvivorStart = GIV(futureSurvivorStart);
		if (GIV(previousRememberedSetSize) == GIV(rememberedSetSize)) {
			if ((GIV(numRememberedEphemerons) == 0)
			 && (GIV(ephemeronList) == null)) {
				return;
			}
			processEphemerons();
		}
	}
}


/*	scavengeReferentsOf: referrer inspects all the pointers in referrer. If
	any are new objects, it has them moved to FutureSurvivorSpace, and
	answers truth. If there are no new referents, it answers falsity. To
	handle weak arrays, if the referrer is weak only scavenge strong slots and
	answer true so that it won't be removed from the remembered set until
	later.  */
/*	forwarding objects should be followed by callers,
	unless the forwarder is a root in the remembered table. */

	/* SpurGenerationScavenger>>#scavengeReferentsOf: */
static sqInt NoDbgRegParms
scavengeReferentsOf(sqInt referrer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt foundNewReferentOrIsWeakling;
    sqInt header;
    sqInt i;
    sqInt newLocation;
    sqInt numLiterals;
    sqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop1;
    sqInt referent;
    sqInt referent1;
    sqInt sp;

	assert((!(isForwarded(referrer)))
	 || (isRemembered(referrer)));
	assert((!(isEphemeron(referrer)))
	 || ((isScavengeSurvivor(keyOfEphemeron(referrer)))
	 || (isonWeaklingList(referrer, GIV(ephemeronList)))));
	fmt = (((usqInt) (longAt(referrer))) >> (formatShift())) & (formatMask());
	foundNewReferentOrIsWeakling = fmt == (weakArrayFormat());
	/* begin numStrongSlotsOf:format:ephemeronInactiveIf: */
	if (fmt <= 5) {
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(referrer)) > (isForwardedObjectClassIndexPun()));
		numSlots1 = byteAt(referrer + 7);
		numSlots2 = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(referrer - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (fmt <= 2) {
			numSlots = numSlots2;
			goto l2;
		}
		if (fmt == (indexablePointersFormat())) {
			if (((longAt(referrer)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(referrer);
				/* begin fetchStackPointerOf: */
				sp = longAt((referrer + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l1;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(referrer)));
				contextSize = (sp >> 3);
			l1:	/* end fetchStackPointerOf: */;
				numSlots = CtxtTempFrameStart + contextSize;
				goto l2;
			}
			numSlots = numSlots2;
			goto l2;
		}
		if (fmt == (weakArrayFormat())) {
			/* begin fixedFieldsOfClass: */
			objOop1 = fetchClassOfNonImm(referrer);
			/* begin fixedFieldsOfClassFormat: */
			numSlots = (((longAt((objOop1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
			goto l2;
		}
		assert(fmt == (ephemeronFormat()));
		numSlots = (isScavengeSurvivor((keyOfEphemeron(referrer)))
			? numSlots2
			: 0);
		goto l2;
	}
	if (fmt == 7) {
		numSlots = 1;
		goto l2;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		numSlots = 0;
		goto l2;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(referrer));
	header = longAt((referrer + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	numSlots = numLiterals + LiteralStart;
l2:	/* end numStrongSlotsOf:format:ephemeronInactiveIf: */;
	for (i = 0; i < numSlots; i += 1) {
		referent = longAt((referrer + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if ((referent & (tagMask())) == 0) {

			/* a forwarding pointer could be because of become: or scavenging. */
			if (((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(referent));
				referent1 = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent1 & (tagMask())) == 0)
				 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				referent = referent1;
			}
			if (isYoungObject(referent)) {

				/* if target is already in future space forwarding pointer was due to a become:. */
				if (oopisGreaterThanOrEqualToandLessThan(referent, ((futureSpace()).start), futureSurvivorStart())) {
					newLocation = referent;
					foundNewReferentOrIsWeakling = 1;
				}
				else {
					newLocation = copyAndForward(referent);
					if (((newLocation & (tagMask())) == 0)
					 && (oopisLessThan(newLocation, GIV(newSpaceLimit)))) {
						foundNewReferentOrIsWeakling = 1;
					}
				}
				longAtput((referrer + BaseHeaderSize) + (((long)i) << (shiftForWord())), newLocation);
			}
			else {
				longAtput((referrer + BaseHeaderSize) + (((long)i) << (shiftForWord())), referent);
			}
		}
	}
	return foundNewReferentOrIsWeakling;
}


/*	scavengeRememberedSetStartingAt: n traverses objects in the remembered
	set starting at the nth one. If the object does not refer to any new
	objects, it
	is removed from the set. Otherwise, its new referents are scavenged. Defer
	scavenging ephemerons until after a complete scavenge has been performed,
	so that triggered ephemerons can be fired. Move them to the front of the
	set and count them in numRememberedEphemerons for later scanning. */

	/* SpurGenerationScavenger>>#scavengeRememberedSetStartingAt: */
static void NoDbgRegParms
scavengeRememberedSetStartingAt(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt destIndex;
    sqInt referrer;
    sqInt sourceIndex;

	sourceIndex = (destIndex = n);
	while (sourceIndex < GIV(rememberedSetSize)) {

		/* *Don't* follow forwarding pointers here. oldSpace objects may refer
		   to these roots, and so they can't be removed in the scavenge. */

		/* Any potential firing ephemerons should not be scanned yet.
		   Move any to the front of the set to save time in later scanning. */
		referrer = GIV(rememberedSet)[sourceIndex];
		if ((isEphemeron(referrer))
		 && (!(isScavengeSurvivor(keyOfEphemeron(referrer))))) {
			assert(destIndex >= GIV(numRememberedEphemerons));
			GIV(rememberedSet)[destIndex] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
			GIV(rememberedSet)[GIV(numRememberedEphemerons)] = referrer;
			GIV(numRememberedEphemerons) += 1;
			destIndex += 1;
		}
		else {
			if (scavengeReferentsOf(referrer)) {
				GIV(rememberedSet)[destIndex] = referrer;
				destIndex += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(referrer, (longAt(referrer)) & (~(1LL << (rememberedBitShift()))));
			}
		}
		sourceIndex += 1;
	}
	GIV(rememberedSetSize) = destIndex;
	assert(noUnfiredEphemeronsAtEndOfRememberedSet());
}


/*	(Slang flattens so need unique selectors) */

	/* SpurGenerationScavenger>>#scavengerTenuringThreshold */
static float
scavengerTenuringThreshold(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(tenureThreshold) >= ((GIV(pastSpace).start))
		? (((double) (GIV(tenureThreshold) - ((GIV(pastSpace).start))) )) / (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))
		: 0);
}


/*	There may be ephemerons to be scavenged on the ephemeronList.
	Scavenge any with unfired (live) keys, removing them from the
	list, and answer if any with unfired keys were found. */

	/* SpurGenerationScavenger>>#scavengeUnfiredEphemeronsOnEphemeronList */
static sqInt
scavengeUnfiredEphemeronsOnEphemeronList(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt corpseOffset;
    sqInt ephemeron;
    sqInt ephemeronCorpse;
    sqInt format;
    sqInt hash;
    sqInt nextCorpseOffset;
    sqInt previousCorpse;
    sqInt referent;
    sqInt unfiredEphemeronsScavenged;

	previousCorpse = 0;
	if (!(GIV(ephemeronList))) {
		return 0;
	}
	unfiredEphemeronsScavenged = 0;
	corpseOffset = GIV(ephemeronList);
	while (corpseOffset != 0) {
		ephemeronCorpse = (((long)(corpseOffset - 1)) << 3) + GIV(newSpaceStart);
		assert(isForwarded(ephemeronCorpse));
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(ephemeronCorpse));
		referent = longAt((ephemeronCorpse + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		ephemeron = referent;
		nextCorpseOffset = (((long)((long32At(ephemeronCorpse + 4)) & (identityHashHalfWordMask()))) << 5) + ((((usqInt) (longAt(ephemeronCorpse))) >> (formatShift())) & (formatMask()));
		if (isScavengeSurvivor(keyOfEphemeron(ephemeron))) {
			if (corpseOffset == GIV(ephemeronList)) {
				GIV(ephemeronList) = (nextCorpseOffset != 0
					? nextCorpseOffset
					: 0);
			}
			else {
				/* begin setCorpseOffsetOf:to: */
				assert(isYoung(previousCorpse));
				assert(isForwarded(previousCorpse));
				
				/* So we use the single assignment */
				long64Atput(previousCorpse, headerForSlotshashformatclassIndex(byteAt(previousCorpse + 7), ((usqInt) nextCorpseOffset) >> 5, nextCorpseOffset & (formatMask()), isForwardedObjectClassIndexPun()));

			}
			unfiredEphemeronsScavenged = 1;
			((void) (scavengeReferentsOf(ephemeron)));
		}
		else {
			previousCorpse = ephemeronCorpse;
		}
		corpseOffset = nextCorpseOffset;
	}
	return unfiredEphemeronsScavenged;
}


/*	Answer the accessible object following the given object or 
	free chunk in the heap. Return nil when heap is exhausted.
	This is for primitiveNextObject subsequent to primtiiveSomeObject.
	It also tries to handle more general use by ordering objects as
	eden
	past
	old
	but this is tricky becaus ethe order in memory is
	past
	eden
	old */

	/* SpurMemoryManager>>#accessibleObjectAfter: */
static sqInt NoDbgRegParms
accessibleObjectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objAfter;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	objAfter = objOop;
	if (oopisLessThan(objAfter, GIV(nilObj))) {

		/* object in new space */
		assert((isInEden(objOop))
		 || (isInPastSpace(objOop)));
		if (oopisGreaterThan(objAfter, GIV(pastSpaceStart))) {

			/* Obj is in eden.  Answer next normal object in eden, if there is one. */
			while (1) {
				/* begin objectAfter:limit: */
				numSlots1 = byteAt(objAfter + 7);
				numSlots2 = (numSlots1 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objAfter - BaseHeaderSize))) << 8)))) >> 8
					: numSlots1);
				if (numSlots2 == 0) {
					slotBytes = 8;
				}
				else {
					slotBytes = ((long)numSlots2) << (shiftForWord());
				}
				followingWordAddress = (objAfter + BaseHeaderSize) + slotBytes;
				if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
					objAfter = GIV(freeStart);
					goto l1;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				objAfter = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
			l1:	/* end objectAfter:limit: */;
				if (!(oopisLessThan(objAfter, GIV(freeStart)))) break;
				if (((longAt(objAfter)) & (classIndexMask())) > 0x1F) {
					return objAfter;
				}
			}
			if (GIV(pastSpaceStart) <= (((pastSpace()).start))) {
				return GIV(nilObj);
			}
			/* begin objectStartingAt: */
			address = ((pastSpace()).start);
			numSlots = byteAt(address + 7);
			objAfter = (numSlots == (numSlotsMask())
				? address + BaseHeaderSize
				: address);
			if (((longAt(objAfter)) & (classIndexMask())) > 0x1F) {
				return objAfter;
			}
		}
		while (1) {
			/* begin objectAfter:limit: */
			numSlots11 = byteAt(objAfter + 7);
			numSlots3 = (numSlots11 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objAfter - BaseHeaderSize))) << 8)))) >> 8
				: numSlots11);
			if (numSlots3 == 0) {
				slotBytes1 = 8;
			}
			else {
				slotBytes1 = ((long)numSlots3) << (shiftForWord());
			}
			followingWordAddress1 = (objAfter + BaseHeaderSize) + slotBytes1;
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart))) {
				objAfter = GIV(pastSpaceStart);
				goto l2;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objAfter = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		l2:	/* end objectAfter:limit: */;
			if (!(oopisLessThan(objAfter, GIV(pastSpaceStart)))) break;
			if (((longAt(objAfter)) & (classIndexMask())) > 0x1F) {
				return objAfter;
			}
		}
		return GIV(nilObj);
	}
	while(1) {
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objAfter + 7);
		numSlots4 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objAfter - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objAfter + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objAfter = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objAfter = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
		if (objAfter == GIV(endOfMemory)) {
			return null;
		}
		if (((longAt(objAfter)) & (classIndexMask())) > 0x1F) {
			return objAfter;
		}
	}
}


/*	Answer whether an ephemeron is active (has an unmarked
	key) and was pushed on the unscanned ephemerons stack. */

	/* SpurMemoryManager>>#activeAndDeferredScan: */
static sqInt NoDbgRegParms NeverInline
activeAndDeferredScan(sqInt anEphemeron)
{
    sqInt key;

	assert(isEphemeron(anEphemeron));
	if ((isImmediate((key = keyOfEphemeron(anEphemeron))))
	 || (((((usqInt) (longAt(key))) >> 55) & 1) != 0)) {
		return 0;
	}
	return pushOnUnscannedEphemeronsStack(anEphemeron);
}


/*	Add a freeChunk sub tree back into the large free chunk tree.
	This is for allocateOldSpaceChunkOf[Exactly]Bytes:[suchThat:]. */
/*	N.B. *can't* use numSlotsOfAny: because of rounding up of odd slots
	and/or step in size at 1032 bytes in 32-bits or 2048 bytes in 64-bits. */

	/* SpurMemoryManager>>#addFreeSubTree: */
static void NoDbgRegParms
addFreeSubTree(sqInt freeTree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInArg;
    usqInt bytesInNode;
    sqInt subNode;
    sqInt treeNode;

	assert(isFreeObject(freeTree));
	bytesInArg = bytesInObject(freeTree);
	assert(bytesInArg >= ((numFreeLists()) * (allocationUnit())));
	treeNode = GIV(freeLists)[0];
	assert(treeNode != 0);
	while(1) {

		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		bytesInNode = bytesInObject(treeNode);
		assert((oopisLessThanOrEqualTo((freeTree + bytesInArg) - BaseHeaderSize, treeNode))
		 || (oopisGreaterThanOrEqualTo(freeTree, (treeNode + bytesInNode) - BaseHeaderSize)));
		assert(bytesInNode >= ((numFreeLists()) * (allocationUnit())));
		assert(bytesInArg != bytesInNode);
		if (bytesInNode > bytesInArg) {
			subNode = longAt((treeNode + BaseHeaderSize) + (3LL << (shiftForWord())));
			if (subNode == 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(treeNode));
				assert((freeTree == 0)
				 || (isFreeObject(freeTree)));
				longAtput((treeNode + BaseHeaderSize) + (3LL << (shiftForWord())), freeTree);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeTree));
				assert((treeNode == 0)
				 || (isFreeObject(treeNode)));
				longAtput((freeTree + BaseHeaderSize) + (2LL << (shiftForWord())), treeNode);
				return;
			}
		}
		else {
			subNode = longAt((treeNode + BaseHeaderSize) + (4LL << (shiftForWord())));
			if (subNode == 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(treeNode));
				assert((freeTree == 0)
				 || (isFreeObject(freeTree)));
				longAtput((treeNode + BaseHeaderSize) + (4LL << (shiftForWord())), freeTree);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeTree));
				assert((treeNode == 0)
				 || (isFreeObject(treeNode)));
				longAtput((freeTree + BaseHeaderSize) + (2LL << (shiftForWord())), treeNode);
				return;
			}
		}
		treeNode = subNode;
	}
}


/*	Add the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#addGCRoot: */
sqInt
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootsSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}

	/* SpurMemoryManager>>#addressCouldBeObj: */
sqInt
addressCouldBeObj(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & (BaseHeaderSize - 1)) == 0)
	 && ((oopisGreaterThanOrEqualToandLessThan(address, GIV(oldSpaceStart), GIV(endOfMemory)))
	 || ((oopisGreaterThanOrEqualToandLessThan(address, ((eden()).start), GIV(freeStart)))
	 || ((oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace()).start), GIV(pastSpaceStart)))
	 || (GIV(scavengeInProgress)
	 && (oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace()).start), futureSurvivorStart()))))));
}


/*	Answer if address appears to be that of either an immediate or an object.
	For code disassembly and assertions. */

	/* SpurMemoryManager>>#addressCouldBeOop: */
sqInt
addressCouldBeOop(sqInt address)
{
	return ((address & (tagMask())) != 0)
	 || (addressCouldBeObj(address));
}


/*	Add freeChunk to the relevant freeList.
	For the benefit of sortedFreeObject:, if freeChunk is large, answer the
	treeNode it
	is added to, if it is added to the next list of a freeTreeNode, otherwise
	answer 0. */
/*	coInterpreter transcript ensureCr. coInterpreter print: 'freeing '. self
	printFreeChunk: freeChunk.
 */

	/* SpurMemoryManager>>#addToFreeList:bytes: */
static sqInt NoDbgRegParms
addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt valuePointer;

	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInObject(freeChunk)));
	index = chunkBytes / 8;
	if (index < 64) {
		/* begin storePointer:ofFreeChunk:withValue: */
		valuePointer = GIV(freeLists)[index];
		assert(isFreeObject(freeChunk));
		assert((valuePointer == 0)
		 || (isFreeObject(valuePointer)));
		longAtput((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
		GIV(freeLists)[index] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | (1LL << index);
		return 0;
	}
	return addToFreeTreebytes(freeChunk, chunkBytes);
}


/*	Add freeChunk to the large free chunk tree.
	For the benefit of sortedFreeObject:, answer the treeNode it is added
	to, if it is added to the next list of a freeTreeNode, otherwise answer 0. */

	/* SpurMemoryManager>>#addToFreeTree:bytes: */
static sqInt NoDbgRegParms
addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt parent;
    sqInt valuePointer;

	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInObject(freeChunk)));
	assert(chunkBytes >= ((numFreeLists()) * (allocationUnit())));
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (2LL << (shiftForWord())), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (3LL << (shiftForWord())), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (4LL << (shiftForWord())), 0);
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {

		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		childBytes = bytesInObject(child);
		assert((oopisLessThanOrEqualTo((freeChunk + chunkBytes) - BaseHeaderSize, child))
		 || (oopisGreaterThanOrEqualTo(freeChunk, (child + childBytes) - BaseHeaderSize)));
		if (childBytes == chunkBytes) {

			/* size match; add to list at node. */
			/* begin storePointer:ofFreeChunk:withValue: */
			valuePointer = longAt((child + BaseHeaderSize) + (0LL << (shiftForWord())));
			assert(isFreeObject(freeChunk));
			assert((valuePointer == 0)
			 || (isFreeObject(valuePointer)));
			longAtput((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(child));
			assert((freeChunk == 0)
			 || (isFreeObject(freeChunk)));
			longAtput((child + BaseHeaderSize) + (0LL << (shiftForWord())), freeChunk);
			return child;
		}
		parent = child;
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex = (childBytes > chunkBytes
			? 3
			: 4);
		child = longAt((child + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	}
	if (parent == 0) {
		assert((GIV(freeLists)[0]) == 0);
		GIV(freeLists)[0] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | 1;
		return 0;
	}
	assert(GIV(freeListsMask) & 1);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert((parent == 0)
	 || (isFreeObject(parent)));
	longAtput((freeChunk + BaseHeaderSize) + (2LL << (shiftForWord())), parent);
	/* begin storePointer:ofFreeChunk:withValue: */
	fieldIndex1 = (childBytes > chunkBytes
		? 3
		: 4);
	assert(isFreeObject(parent));
	assert((freeChunk == 0)
	 || (isFreeObject(freeChunk)));
	longAtput((parent + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())), freeChunk);
	return 0;
}


/*	Attempt to answer an array of all objects, excluding those that may
	be garbage collected as a side effect of allocating the result array.
	If no memory is available answer the number of instances as a
	SmallInteger. Since objects are at least 16 bytes big, and the largest
	SmallInteger covers
	1/4 of the address space, the count can never overflow. */

	/* SpurMemoryManager>>#allInstancesOf: */
static sqInt NoDbgRegParms
allInstancesOf(sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualIndex;
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    usqInt bytes;
    sqInt c;
    sqInt classIndex;
    sqInt classOrNil;
    sqInt count;
    sqInt count1;
    sqInt count2;
    sqInt entry;
    sqInt expectedIndex;
    sqInt expectedIndex1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord11;
    sqInt followingWord2;
    sqInt followingWord21;
    sqInt followingWord3;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress11;
    sqInt followingWordAddress2;
    sqInt followingWordAddress21;
    sqInt followingWordAddress3;
    sqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt index;
    sqInt j;
    sqInt jLimiT;
    sqInt limit;
    usqInt limit1;
    usqInt limit11;
    usqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numBytes1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots111;
    usqInt numSlots12;
    usqInt numSlots121;
    usqInt numSlots13;
    usqInt numSlots14;
    usqInt numSlots15;
    usqInt numSlots2;
    usqInt numSlots21;
    usqInt numSlots3;
    usqInt numSlots31;
    usqInt numSlots4;
    usqInt numSlots41;
    usqInt numSlots5;
    usqInt numSlots51;
    usqInt numSlots6;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt p;
    sqInt page;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj11;
    sqInt prevObj2;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj11;
    sqInt prevPrevObj2;
    sqInt ptr;
    sqInt ptr1;
    sqInt ptr2;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes11;
    sqInt slotBytes2;
    sqInt slotBytes21;
    sqInt slotBytes3;
    sqInt slotBytes4;
    sqInt smallObj;
    sqInt start;

	classIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask());
	if (classIndex == 0) {
		/* begin allocateSlots:format:classIndex: */
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + (8);

		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			freeChunk = allocateSlotsInOldSpacebytesformatclassIndex(0, numBytes, 2, ClassArrayCompactIndex);
			goto l1;
		}
		longAtput(newObj, ((((long)(((usqLong) 0))) << (numSlotsFullShift())) + (2LL << (formatShift()))) + ClassArrayCompactIndex);

		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		freeChunk = newObj;
	l1:	/* end allocateSlots:format:classIndex: */;
		return freeChunk;
	}
	freeChunk = allocateLargestFreeChunk();
	start = freeChunk + BaseHeaderSize;
	/* begin addressAfter: */
	numSlots1 = byteAt(freeChunk + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(freeChunk - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (numSlots == 0) {
		slotBytes = 8;
	}
	else {
		slotBytes = ((long)numSlots) << (shiftForWord());
	}
	limit = (freeChunk + BaseHeaderSize) + slotBytes;
	if (isClassAtUniqueIndex(aClass)) {
		/* begin uniqueIndex:allInstancesInto:limit:resultsInto: */
		count1 = 0;
		ptr1 = start;
		/* begin allHeapEntitiesDo: */
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj = (prevObj = null);
		objOop = GIV(nilObj);
		while (1) {
			assert((objOop % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
			assert((long64At(objOop)) != 0);
			
			/* continue enumerating even if no room so as to unmark all objects. */
			if (1) {
				if (((longAt(objOop)) & (classIndexMask())) > 0x1F) {
					if (((longAt(objOop)) & (classIndexMask())) == classIndex) {
						count1 += 1;
						if (ptr1 < limit) {
							longAtput(ptr1, objOop);
							ptr1 += BytesPerOop;
						}
					}
				}
				else {
									}
			}

			prevPrevObj = prevObj;
			prevObj = objOop;
			/* begin objectAfter:limit: */
			numSlots11 = byteAt(objOop + 7);
			numSlots2 = (numSlots11 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
				: numSlots11);
			if (numSlots2 == 0) {
				slotBytes3 = 8;
			}
			else {
				slotBytes3 = ((long)numSlots2) << (shiftForWord());
			}
			followingWordAddress = (objOop + BaseHeaderSize) + slotBytes3;
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				objOop = GIV(endOfMemory);
				goto l5;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
		l5:	/* end objectAfter:limit: */;
		}
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj1 = (prevObj1 = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		/* begin objectStartingAt: */
		address = ((pastSpace()).start);
		numSlots5 = byteAt(address + 7);
		objOop1 = (numSlots5 == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		limit1 = GIV(pastSpaceStart);
		while (oopisLessThan(objOop1, limit1)) {
			
			/* continue enumerating even if no room so as to unmark all objects. */
			if (1) {
				if (((longAt(objOop1)) & (classIndexMask())) > 0x1F) {
					if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
						count1 += 1;
						if (ptr1 < limit) {
							longAtput(ptr1, objOop1);
							ptr1 += BytesPerOop;
						}
					}
				}
				else {
									}
			}

			prevPrevObj1 = prevObj1;
			prevObj1 = objOop1;
			/* begin objectAfter:limit: */
			numSlots12 = byteAt(objOop1 + 7);
			numSlots3 = (numSlots12 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots12);
			if (numSlots3 == 0) {
				slotBytes1 = 8;
			}
			else {
				slotBytes1 = ((long)numSlots3) << (shiftForWord());
			}
			followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes1;
			if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit1)) {
				objOop1 = limit1;
				goto l3;
			}
			flag("endianness");
			followingWord2 = longAt(followingWordAddress2);
			objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress2 + BaseHeaderSize
				: followingWordAddress2);
		l3:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address1 = ((eden()).start);
		numSlots14 = byteAt(address1 + 7);
		objOop1 = (numSlots14 == (numSlotsMask())
			? address1 + BaseHeaderSize
			: address1);
		while (oopisLessThan(objOop1, GIV(freeStart))) {
			
			/* continue enumerating even if no room so as to unmark all objects. */
			if (1) {
				if (((longAt(objOop1)) & (classIndexMask())) > 0x1F) {
					if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
						count1 += 1;
						if (ptr1 < limit) {
							longAtput(ptr1, objOop1);
							ptr1 += BytesPerOop;
						}
					}
				}
				else {
									}
			}

			prevPrevObj1 = prevObj1;
			prevObj1 = objOop1;
			/* begin objectAfter:limit: */
			numSlots13 = byteAt(objOop1 + 7);
			numSlots4 = (numSlots13 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots13);
			if (numSlots4 == 0) {
				slotBytes2 = 8;
			}
			else {
				slotBytes2 = ((long)numSlots4) << (shiftForWord());
			}
			followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes2;
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
				objOop1 = GIV(freeStart);
				goto l4;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		l4:	/* end objectAfter:limit: */;
		}
		count = count1;
		ptr = ptr1;

	}
	else {
		/* begin ambiguousClass:allInstancesInto:limit:resultsInto: */
		count2 = 0;
		ptr2 = start;
		expectedIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask());
		/* begin allHeapEntitiesDo: */
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj11 = (prevObj11 = null);
		objOop11 = GIV(nilObj);
		while (1) {
			assert((objOop11 % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
			assert((long64At(objOop11)) != 0);
			
			/* continue enumerating even if no room so as to unmark all objects and/or normalize class indices. */
			if (1) {
				if (((longAt(objOop11)) & (classIndexMask())) > 0x1F) {
					actualIndex = (longAt(objOop11)) & (classIndexMask());
					if ((classOrNilAtIndex(actualIndex)) == aClass) {
						if (actualIndex != expectedIndex) {
							/* begin setClassIndexOf:to: */
							assert(((expectedIndex >= 0) && (expectedIndex <= (classIndexMask()))));
							longAtput(objOop11, ((longAt(objOop11)) & (~(classIndexMask()))) + expectedIndex);
						}
						count2 += 1;
						if (ptr2 < limit) {
							longAtput(ptr2, objOop11);
							ptr2 += BytesPerOop;
						}
					}
				}
				else {
									}
			}

			prevPrevObj11 = prevObj11;
			prevObj11 = objOop11;
			/* begin objectAfter:limit: */
			numSlots121 = byteAt(objOop11 + 7);
			numSlots31 = (numSlots121 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots121);
			if (numSlots31 == 0) {
				slotBytes21 = 8;
			}
			else {
				slotBytes21 = ((long)numSlots31) << (shiftForWord());
			}
			followingWordAddress21 = (objOop11 + BaseHeaderSize) + slotBytes21;
			if (oopisGreaterThanOrEqualTo(followingWordAddress21, GIV(endOfMemory))) {
				objOop11 = GIV(endOfMemory);
				goto l6;
			}
			flag("endianness");
			followingWord21 = longAt(followingWordAddress21);
			objOop11 = ((((usqInt) followingWord21) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress21 + BaseHeaderSize
				: followingWordAddress21);
		l6:	/* end objectAfter:limit: */;
		}
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj2 = (prevObj2 = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		/* begin objectStartingAt: */
		address2 = ((pastSpace()).start);
		numSlots41 = byteAt(address2 + 7);
		objOop2 = (numSlots41 == (numSlotsMask())
			? address2 + BaseHeaderSize
			: address2);
		limit11 = GIV(pastSpaceStart);
		while (oopisLessThan(objOop2, limit11)) {
			
			/* continue enumerating even if no room so as to unmark all objects and/or normalize class indices. */
			if (1) {
				if (((longAt(objOop2)) & (classIndexMask())) > 0x1F) {
					actualIndex = (longAt(objOop2)) & (classIndexMask());
					if ((classOrNilAtIndex(actualIndex)) == aClass) {
						if (actualIndex != expectedIndex) {
							/* begin setClassIndexOf:to: */
							assert(((expectedIndex >= 0) && (expectedIndex <= (classIndexMask()))));
							longAtput(objOop2, ((longAt(objOop2)) & (~(classIndexMask()))) + expectedIndex);
						}
						count2 += 1;
						if (ptr2 < limit) {
							longAtput(ptr2, objOop2);
							ptr2 += BytesPerOop;
						}
					}
				}
				else {
									}
			}

			prevPrevObj2 = prevObj2;
			prevObj2 = objOop2;
			/* begin objectAfter:limit: */
			numSlots15 = byteAt(objOop2 + 7);
			numSlots6 = (numSlots15 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop2 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots15);
			if (numSlots6 == 0) {
				slotBytes4 = 8;
			}
			else {
				slotBytes4 = ((long)numSlots6) << (shiftForWord());
			}
			followingWordAddress3 = (objOop2 + BaseHeaderSize) + slotBytes4;
			if (oopisGreaterThanOrEqualTo(followingWordAddress3, limit11)) {
				objOop2 = limit11;
				goto l7;
			}
			flag("endianness");
			followingWord3 = longAt(followingWordAddress3);
			objOop2 = ((((usqInt) followingWord3) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress3 + BaseHeaderSize
				: followingWordAddress3);
		l7:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address11 = ((eden()).start);
		numSlots51 = byteAt(address11 + 7);
		objOop2 = (numSlots51 == (numSlotsMask())
			? address11 + BaseHeaderSize
			: address11);
		while (oopisLessThan(objOop2, GIV(freeStart))) {
			
			/* continue enumerating even if no room so as to unmark all objects and/or normalize class indices. */
			if (1) {
				if (((longAt(objOop2)) & (classIndexMask())) > 0x1F) {
					actualIndex = (longAt(objOop2)) & (classIndexMask());
					if ((classOrNilAtIndex(actualIndex)) == aClass) {
						if (actualIndex != expectedIndex) {
							/* begin setClassIndexOf:to: */
							assert(((expectedIndex >= 0) && (expectedIndex <= (classIndexMask()))));
							longAtput(objOop2, ((longAt(objOop2)) & (~(classIndexMask()))) + expectedIndex);
						}
						count2 += 1;
						if (ptr2 < limit) {
							longAtput(ptr2, objOop2);
							ptr2 += BytesPerOop;
						}
					}
				}
				else {
									}
			}

			prevPrevObj2 = prevObj2;
			prevObj2 = objOop2;
			/* begin objectAfter:limit: */
			numSlots111 = byteAt(objOop2 + 7);
			numSlots21 = (numSlots111 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop2 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots111);
			if (numSlots21 == 0) {
				slotBytes11 = 8;
			}
			else {
				slotBytes11 = ((long)numSlots21) << (shiftForWord());
			}
			followingWordAddress11 = (objOop2 + BaseHeaderSize) + slotBytes11;
			if (oopisGreaterThanOrEqualTo(followingWordAddress11, GIV(freeStart))) {
				objOop2 = GIV(freeStart);
				goto l8;
			}
			flag("endianness");
			followingWord11 = longAt(followingWordAddress11);
			objOop2 = ((((usqInt) followingWord11) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress11 + BaseHeaderSize
				: followingWordAddress11);
		l8:	/* end objectAfter:limit: */;
		}
		/* begin purgeDuplicateClassTableEntriesFor: */
		expectedIndex1 = (long32At(aClass + 4)) & (identityHashHalfWordMask());
		/* begin classTableEntriesDo: */
		for (i1 = 0; i1 < GIV(numClassTablePages); i1 += 1) {
			page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i1) << (shiftForWord())));
			for (j = 0, jLimiT = ((1LL << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
				classOrNil = longAt((page + BaseHeaderSize) + (((long)j) << (shiftForWord())));
				if (classOrNil != GIV(nilObj)) {
					index = (((long)i1) << (classTableMajorIndexShift())) + j;
					if ((classOrNil == aClass)
					 && (index != expectedIndex1)) {
						classAtIndexput(index, GIV(nilObj));
						if (index < GIV(classTableIndex)) {
							GIV(classTableIndex) = index;
						}
					}

				}
			}
		}
		assert(GIV(classTableIndex) >= (1LL << (classTableMajorIndexShift())));
		count = count2;
		ptr = ptr2;

	}
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));

	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8))) {

		/* can't split a single word */
		freeObject(freeChunk);
		return ((count << 3) | 1);
	}
	if (count < (numSlotsMask())) {
		/* begin allocateSlots:format:classIndex: */
		if (count >= (numSlotsMask())) {
			if ((((usqInt) count) >> 56) > 0) {
				smallObj = null;
				goto l2;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes1 = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes1 = BaseHeaderSize + ((count < 1
	? 8
	: count * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			smallObj = allocateSlotsInOldSpacebytesformatclassIndex(count, numBytes1, 2, ClassArrayCompactIndex);
			goto l2;
		}
		if (count >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + count);
			longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), 2, ClassArrayCompactIndex));
		}
		else {
			longAtput(newObj1, ((((long)(((usqLong) count))) << (numSlotsFullShift())) + (2LL << (formatShift()))) + ClassArrayCompactIndex);
		}
		assert((numBytes1 % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes1;
		smallObj = newObj1;
	l2:	/* end allocateSlots:format:classIndex: */;
		for (i = 0; i < count; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(smallObj)));
			longAtput((smallObj + BaseHeaderSize) + (((long)i) << (shiftForWord())), longAt((freeChunk + BaseHeaderSize) + (((long)i) << (shiftForWord()))));
		}
		freeChunkWithBytesat(bytesInObject(freeChunk), ((byteAt(freeChunk + 7)) == (numSlotsMask())
			? freeChunk - BaseHeaderSize
			: freeChunk));
		beRootIfOld(smallObj);
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
			runLeakCheckerForFreeSpace(GCModeFreeSpace);
		}
		return smallObj;
	}
	bytes = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
	start = ((byteAt(freeChunk + 7)) == (numSlotsMask())
		? freeChunk - BaseHeaderSize
		: freeChunk);
	freeChunkWithBytesat((limit - start) - bytes, start + bytes);
	GIV(totalFreeOldSpace) -= bytes;
	/* begin rawOverflowSlotsOf:put: */
	flag("endianness");
	longAtput(freeChunk - BaseHeaderSize, (((long)(numSlotsMask())) << 56) + count);
	/* begin set:classIndexTo:formatTo: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask()))));
	assert(((2 >= 0) && (2 <= (formatMask()))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (ClassArrayCompactIndex + (2LL << (formatShift()))));
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt) (longAt(freeChunk))) >> (rememberedBitShift())) & 1) != 0)) {
		remember(freeChunk);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	runLeakCheckerFor(GCModeFull);
	return freeChunk;
}


/*	Attempt to answer an array of all objects, excluding those that may
	be garbage collected as a side effect of allocating the result array.
	If no memory is available answer the number of objects as a SmallInteger.
	Since objects are at least 16 bytes big, and the largest SmallInteger
	covers 1/4 of the address space, the count can never overflow. */

	/* SpurMemoryManager>>#allObjects */
static sqInt
allObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    usqInt bytes;
    sqInt count;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt freeChunk;
    sqInt limit;
    usqInt limit1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    usqInt numSlots5;
    usqInt numSlots6;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt ptr;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;
    sqInt slotBytes3;
    sqInt start;

	freeChunk = allocateLargestFreeChunk();
	ptr = (start = freeChunk + BaseHeaderSize);
	/* begin addressAfter: */
	numSlots12 = byteAt(freeChunk + 7);
	numSlots3 = (numSlots12 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(freeChunk - BaseHeaderSize))) << 8)))) >> 8
		: numSlots12);
	if (numSlots3 == 0) {
		slotBytes2 = 8;
	}
	else {
		slotBytes2 = ((long)numSlots3) << (shiftForWord());
	}
	limit = (freeChunk + BaseHeaderSize) + slotBytes2;
	count = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		
		/* continue enumerating even if no room so as to unmark all objects. */
		if (1) {
			if (((longAt(objOop1)) & (classIndexMask())) > 0x1F) {
				count += 1;
				if (ptr < limit) {
					longAtput(ptr, objOop1);
					ptr += BytesPerOop;
				}
			}
			else {
							}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots6 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots6 == 0) {
			slotBytes3 = 8;
		}
		else {
			slotBytes3 = ((long)numSlots6) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes3;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots4 = byteAt(address + 7);
	objOop = (numSlots4 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit1 = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit1)) {
		
		/* continue enumerating even if no room so as to unmark all objects. */
		if (1) {
			if (((longAt(objOop)) & (classIndexMask())) > 0x1F) {
				count += 1;
				if (ptr < limit) {
					longAtput(ptr, objOop);
					ptr += BytesPerOop;
				}
			}
			else {
							}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit1)) {
			objOop = limit1;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots5 = byteAt(address1 + 7);
	objOop = (numSlots5 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		
		/* continue enumerating even if no room so as to unmark all objects. */
		if (1) {
			if (((longAt(objOop)) & (classIndexMask())) > 0x1F) {
				count += 1;
				if (ptr < limit) {
					longAtput(ptr, objOop);
					ptr += BytesPerOop;
				}
			}
			else {
							}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress1 = (objOop + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));

	assert(count >= (numSlotsMask()));
	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8))) {

		/* can't split a single word */
		freeChunkWithBytesat(bytesInObject(freeChunk), ((byteAt(freeChunk + 7)) == (numSlotsMask())
			? freeChunk - BaseHeaderSize
			: freeChunk));
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
			runLeakCheckerForFreeSpace(GCModeFreeSpace);
		}
		return ((count << 3) | 1);
	}
	bytes = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
	start = ((byteAt(freeChunk + 7)) == (numSlotsMask())
		? freeChunk - BaseHeaderSize
		: freeChunk);
	freeChunkWithBytesat((limit - start) - bytes, start + bytes);
	GIV(totalFreeOldSpace) -= bytes;
	/* begin rawOverflowSlotsOf:put: */
	flag("endianness");
	longAtput(freeChunk - BaseHeaderSize, (((long)(numSlotsMask())) << 56) + count);
	/* begin set:classIndexTo:formatTo: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask()))));
	assert(((2 >= 0) && (2 <= (formatMask()))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (ClassArrayCompactIndex + (2LL << (formatShift()))));
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt) (longAt(freeChunk))) >> (rememberedBitShift())) & 1) != 0)) {
		remember(freeChunk);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	runLeakCheckerFor(GCModeFull);
	return freeChunk;
}

	/* SpurMemoryManager>>#allObjectsUnmarked */
static sqInt
allObjectsUnmarked(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			return 0;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			return 0;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (((((usqInt) (longAt(objOop11))) >> 55) & 1) != 0) {
				return 0;
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	return 1;
}

	/* SpurMemoryManager>>#allOldMarkedWeakObjectsOnWeaklingStack */
static sqInt
allOldMarkedWeakObjectsOnWeaklingStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWordAddress;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt o;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt slotBytes;

	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if ((isWeakFormat((((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask())))
		 && (((((usqInt) (longAt(objOop))) >> 55) & 1) != 0)) {
			if (!(isonObjStack(objOop, GIV(weaklingStack)))) {
				return 0;
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return 1;
}


/*	Answer the largest free chunk in the free lists. */
/*	would like to use ifNotNil: but the ^next inside the ^blah ifNotNil:
	confused Slang
 */

	/* SpurMemoryManager>>#allocateLargestFreeChunk */
static sqInt
allocateLargestFreeChunk(void)
{
    sqInt freeChunk;
    sqInt next;
    sqInt valuePointer;

	freeChunk = findLargestFreeChunk();
	if (!(freeChunk)) {
		return null;
	}
	next = longAt((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())));
	if (next != 0) {
		/* begin storePointer:ofFreeChunk:withValue: */
		valuePointer = longAt((next + BaseHeaderSize) + (0LL << (shiftForWord())));
		assert(isFreeObject(freeChunk));
		assert((valuePointer == 0)
		 || (isFreeObject(valuePointer)));
		longAtput((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
		return next;
	}
	unlinkSolitaryFreeTreeNode(freeChunk);
	return freeChunk;
}


/*	Allocate an object with numSlots in newSpace. This is for the `ee'
	execution engine allocations,
	and must be satisfied. If no memory is available, abort. If the allocation
	pushes freeStart past
	scavengeThreshold and a scavenge is not already scheduled, schedule a
	scavenge.  */
/*	Object headers are 8 bytes in length if the slot size fits in the num
	slots field (max implies overflow),
	16 bytes otherwise (num slots in preceding word).
	Objects always have at least one slot, for the forwarding pointer,
	and are multiples of 8 bytes in length. */

	/* SpurMemoryManager>>#allocateNewSpaceSlots:format:classIndex: */
static sqInt NoDbgRegParms
allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newObj;
    usqInt numBytes;

	if (numSlots >= (numSlotsMask())) {
		if (numSlots > 0xFFFFFFFFULL) {
			return null;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateNewSpaceSlots:format:classIndex:");
			return 0;
		}
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, ((long)(numSlotsMask())) << (numSlotsHalfShift()));
		long64Atput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), formatField, classIndex));
	}
	else {
		long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)formatField) << (formatShift()))) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	return newObj;
}


/*	Answer a chunk of oldSpace from the free lists, if available,
	otherwise answer nil. Break up a larger chunk if one of the
	exact size does not exist. N.B. the chunk is simply a pointer, it
	has no valid header. The caller *must* fill in the header correctly. */
/*	for debugging: */
/*	totalFreeOldSpace := self totalFreeListBytes */

	/* SpurMemoryManager>>#allocateOldSpaceChunkOfBytes: */
static sqInt NoDbgRegParms
allocateOldSpaceChunkOfBytes(usqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    usqInt index;
    usqInt initialIndex;
    usqInt nodeBytes;
    sqInt parent;
    sqInt valuePointer;
    sqInt valuePointer1;

	nodeBytes = 0;

	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= chunkBytes;
	initialIndex = chunkBytes / 8;
	if ((initialIndex < 64)
	 && ((1LL << initialIndex) <= GIV(freeListsMask))) {
		if (GIV(freeListsMask) & (1LL << initialIndex)) {
			if (((chunk = GIV(freeLists)[initialIndex])) != 0) {
				assert(chunk == (startOfObject(chunk)));
				assert(isValidFreeObject(chunk));
				/* begin unlinkFreeChunk:atIndex: */
				assert(((bytesInObject(chunk)) == (initialIndex * (allocationUnit())))
				 && ((initialIndex > 1)
				 && ((startOfObject(chunk)) == chunk)));
				GIV(freeLists)[initialIndex] = (longAt((chunk + BaseHeaderSize) + (0LL << (shiftForWord()))));
				return chunk;
			}
			GIV(freeListsMask) -= 1LL << initialIndex;
		}
		index = initialIndex;
		while ((((index += index)) < 64)
		 && ((1LL << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1LL << index)) {
				if (((chunk = GIV(freeLists)[index])) != 0) {
					assert(chunk == (startOfObject(chunk)));
					assert(isValidFreeObject(chunk));
					/* begin unlinkFreeChunk:atIndex: */
					assert(((bytesInObject(chunk)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk)) == chunk)));
					GIV(freeLists)[index] = (longAt((chunk + BaseHeaderSize) + (0LL << (shiftForWord()))));
					assert((bytesInObject(chunk)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * 8) - chunkBytes, (((byteAt(chunk + 7)) == (numSlotsMask())
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes);
					return chunk;
				}
				GIV(freeListsMask) -= 1LL << index;
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < 64)
		 && ((1LL << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1LL << index)) {
				if (((chunk = GIV(freeLists)[index])) != 0) {
					assert(chunk == (startOfObject(chunk)));
					assert(isValidFreeObject(chunk));
					/* begin unlinkFreeChunk:atIndex: */
					assert(((bytesInObject(chunk)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk)) == chunk)));
					GIV(freeLists)[index] = (longAt((chunk + BaseHeaderSize) + (0LL << (shiftForWord()))));
					assert((bytesInObject(chunk)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * 8) - chunkBytes, (((byteAt(chunk + 7)) == (numSlotsMask())
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes);
					return chunk;
				}
				GIV(freeListsMask) -= 1LL << index;
			}
		}
	}
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		assert(isValidFreeObject(child));
		childBytes = bytesInObject(child);
		if (childBytes == chunkBytes) {

			/* size match; try to remove from list at node. */
			chunk = longAt((child + BaseHeaderSize) + (0LL << (shiftForWord())));
			if (chunk != 0) {
				assert(isValidFreeObject(chunk));
				/* begin storePointer:ofFreeChunk:withValue: */
				valuePointer = longAt((chunk + BaseHeaderSize) + (0LL << (shiftForWord())));
				assert(isFreeObject(child));
				assert((valuePointer == 0)
				 || (isFreeObject(valuePointer)));
				longAtput((child + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
				return ((byteAt(chunk + 7)) == (numSlotsMask())
					? chunk - BaseHeaderSize
					: chunk);
			}
			nodeBytes = childBytes;
			parent = child;

			/* break out of loop to remove interior node */
			child = 0;
		}
		else {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (chunkBytes + 8)) {

				/* node too small; walk down the larger size of the tree */
				child = longAt((child + BaseHeaderSize) + (4LL << (shiftForWord())));
			}
			else {

				/* parent will be smallest node >= chunkBytes + allocationUnit */
				parent = child;
				nodeBytes = childBytes;
				child = longAt((child + BaseHeaderSize) + (3LL << (shiftForWord())));
			}
		}
	}
	if (parent == 0) {

		/* optimism was unfounded */
		GIV(totalFreeOldSpace) += chunkBytes;
		return null;
	}
	assert((nodeBytes == chunkBytes)
	 || (nodeBytes >= (chunkBytes + (2 * (allocationUnit())))));
	assert((bytesInObject(parent)) == nodeBytes);
	chunk = longAt((parent + BaseHeaderSize) + (0LL << (shiftForWord())));
	if (chunk != 0) {
		assert((chunkBytes == nodeBytes)
		 || ((chunkBytes + (allocationUnit())) < nodeBytes));
		/* begin storePointer:ofFreeChunk:withValue: */
		valuePointer1 = longAt((chunk + BaseHeaderSize) + (0LL << (shiftForWord())));
		assert(isFreeObject(parent));
		assert((valuePointer1 == 0)
		 || (isFreeObject(valuePointer1)));
		longAtput((parent + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer1);
		if (chunkBytes != nodeBytes) {
			freeChunkWithBytesat(nodeBytes - chunkBytes, (((byteAt(chunk + 7)) == (numSlotsMask())
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes);
		}
		return ((byteAt(chunk + 7)) == (numSlotsMask())
			? chunk - BaseHeaderSize
			: chunk);
	}
	chunk = parent;
	unlinkSolitaryFreeTreeNode(chunk);
	if (chunkBytes != nodeBytes) {
		freeChunkWithBytesat(nodeBytes - chunkBytes, (((byteAt(chunk + 7)) == (numSlotsMask())
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes);
	}
	return ((byteAt(chunk + 7)) == (numSlotsMask())
		? chunk - BaseHeaderSize
		: chunk);
}

	/* SpurMemoryManager>>#allocatePinnedSlots: */
sqInt
allocatePinnedSlots(sqInt nSlots)
{
    sqInt obj;
    usqInt p;

	obj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots, (((long)(((nSlots < 1) ? 1 : nSlots))) << (shiftForWord())) + ((nSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), sixtyFourBitIndexableFormat(), 19);
	if (!(obj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1, addressAfter(obj)));
		for (p = (((usqInt)(obj + BaseHeaderSize))); p <= (((usqInt)(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1))); p += 8) {
			longAtput(p, 0);
		}
	}
	return obj;
}


/*	All objects are a multiple of 8 bytes in length */

	/* SpurMemoryManager>>#allocationUnit */
static sqInt
allocationUnit(void)
{
	return 8;
}


/*	N.B. generateToByDoLimitExpression:negative:on: guards against (unsigned)0
	- 1 going +ve
 */

	/* SpurMemoryManager>>#allStrongSlotsOfWeaklingAreMarked: */
static sqInt NoDbgRegParms
allStrongSlotsOfWeaklingAreMarked(sqInt aWeakling)
{
    sqInt i;
    sqInt iLimiT;
    sqInt referent;

	for (i = 0, iLimiT = ((numStrongSlotsOfWeakling(aWeakling)) - 1); i <= iLimiT; i += 1) {
		referent = longAt((aWeakling + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if ((referent & (tagMask())) == 0) {
			if (!(((((usqInt) (longAt(referent))) >> 55) & 1) != 0)) {
				return 0;
			}
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#allUnscannedEphemeronsAreActive */
static sqInt
allUnscannedEphemeronsAreActive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt key;
    sqInt objOop;
    sqInt p;

	for (p = ((GIV(unscannedEphemerons).start)); p <= (((GIV(unscannedEphemerons).top)) - BytesPerOop); p += 1) {
		/* begin keyOfEphemeron: */
		objOop = longAt(p);
		assert((isNonImmediate(objOop))
		 && (isEphemeron(objOop)));
		key = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
		if (((key & (tagMask())) != 0)
		 || (((((usqInt) (longAt(key))) >> 55) & 1) != 0)) {
			return 0;
		}
	}
	return 1;
}


/*	Class puns are class indices not used by any class. There is an entry
	for the pun that refers to the notional class of objects with this class
	index. But because the index doesn't match the class it won't show up
	in allInstances, hence hiding the object with a pun as its class index.
	The puns occupy indices 16 through 31. */

	/* SpurMemoryManager>>#arrayClassIndexPun */
static sqInt
arrayClassIndexPun(void)
{
	return 16;
}

	/* SpurMemoryManager>>#arrayFormat */
sqInt
arrayFormat(void)
{
	return 2;
}


/*	Answer the appropriate become effect flags for objOop, or 0 if none.
	The effect flags determine how much work is done after the become
	in following forwarding pointers, voiding method caches, etc. */

	/* SpurMemoryManager>>#becomeEffectFlagsFor: */
static sqInt NoDbgRegParms
becomeEffectFlagsFor(sqInt objOop)
{
    sqInt hash;

	return (((((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask())) <= 5
		? ((((hash = (long32At(objOop + 4)) & (identityHashHalfWordMask()))) != 0)
			 && ((classAtIndex(hash)) == objOop)
				? BecamePointerObjectFlag + BecameActiveClassFlag
				: BecamePointerObjectFlag)
		: (((((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())
				? BecameCompiledMethodFlag
				: 0));
}

	/* SpurMemoryManager>>#become:with: */
sqInt
becomewith(sqInt array1, sqInt array2)
{
	return becomewithtwoWaycopyHash(array1, array2, 1, 1);
}


/*	All references to each object in array1 are swapped with all references to
	the corresponding object in array2. That is, all pointers to one object
	are replaced
	with with pointers to the other. The arguments must be arrays of the same
	length. 
	Answers PrimNoErr if the primitive succeeds, otherwise a relevant error
	code. 
 */
/*	Implementation: Uses lazy forwarding to defer updating references until
	message send.
 */

	/* SpurMemoryManager>>#become:with:twoWay:copyHash: */
static sqInt NoDbgRegParms
becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt contextSize;
    sqInt ec;
    sqInt effectsFlags;
    sqInt effectsFlags1;
    sqInt errCode;
    sqInt fieldOffset;
    sqInt fieldOffset1;
    sqInt fmt;
    sqInt hash;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt newObj1;
    sqInt newObj2;
    sqInt o1ClassIndex;
    sqInt o2ClassIndex;
    sqInt obj1;
    sqInt obj11;
    sqInt obj2;
    sqInt obj21;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt objOop6;
    sqInt oop;
    sqInt oop1;
    sqInt referent;
    sqInt referent1;
    sqInt referent11;
    sqInt referent2;
    sqInt referent3;
    sqInt referent4;
    usqInt size;
    sqInt sp;

	assert(GIV(becomeEffectsFlags) == 0);
	runLeakCheckerFor(GCModeBecome);
	if (!(((array1 & (tagMask())) == 0)
		 && (((((usqInt) (longAt(array1))) >> (formatShift())) & (formatMask())) == 2))) {
		return PrimErrBadReceiver;
	}
	if (!((((array2 & (tagMask())) == 0)
		 && (((((usqInt) (longAt(array2))) >> (formatShift())) & (formatMask())) == 2))
		 && ((numSlotsOf(array1)) == (numSlotsOf(array2))))) {
		return PrimErrBadArgument;
	}
	if (twoWayFlag
	 || (copyHashFlag)) {
		/* begin containsOnlyValidBecomeObjects:and: */
		fmt = (((usqInt) (longAt(array1))) >> (formatShift())) & (formatMask());
		assert(fmt != (forwardedFormat()));
		if (fmt <= 5) {
			if ((fmt == (indexablePointersFormat()))
			 && (((longAt(array1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((array1 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l2;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array1)));
				contextSize = (sp >> 3);
			l2:	/* end fetchStackPointerOf: */;
				fieldOffset = (((CtxtTempFrameStart - 1) + contextSize) * BytesPerOop) + BaseHeaderSize;
				goto l3;
			}
			fieldOffset = (((numSlotsOf(array1)) - 1) * BytesPerOop) + BaseHeaderSize;
			goto l3;
		}
		if (fmt < (firstCompiledMethodFormat())) {
			fieldOffset = 0;
			goto l3;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(array1));
		header = longAt((array1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
		fieldOffset = ((((literalCountOfMethodHeader(header)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
	l3:	/* end lastPointerOf: */;

		/* same size as array2 */
		effectsFlags = (size = 0);
		while (fieldOffset >= BaseHeaderSize) {
			oop = longAt(array1 + fieldOffset);
			if (((oop & (tagMask())) == 0)
			 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop));
				referent3 = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent3 & (tagMask())) == 0)
				 && (((longAt(referent3)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent3 = longAt((referent3 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				oop = referent3;
				longAtput(array1 + fieldOffset, oop);
			}
			if ((oop & (tagMask())) != 0) {
				ec = PrimErrInappropriate;
				goto l4;
			}
			if (((((usqInt) (longAt(oop))) >> 30) & 1) != 0) {
				ec = PrimErrObjectIsPinned;
				goto l4;
			}
			effectsFlags = effectsFlags | (becomeEffectFlagsFor(oop));
			size += bytesInObject(oop);
			oop = longAt(array2 + fieldOffset);
			if (((oop & (tagMask())) == 0)
			 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop));
				referent11 = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent11 & (tagMask())) == 0)
				 && (((longAt(referent11)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent11 = longAt((referent11 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				oop = referent11;
				longAtput(array2 + fieldOffset, oop);
			}
			if ((oop & (tagMask())) != 0) {
				ec = PrimErrInappropriate;
				goto l4;
			}
			if (((((usqInt) (longAt(oop))) >> 30) & 1) != 0) {
				ec = PrimErrObjectIsPinned;
				goto l4;
			}
			effectsFlags = effectsFlags | (becomeEffectFlagsFor(oop));
			size += bytesInObject(oop);
			fieldOffset -= BytesPerOop;
		}
		if (size >= (GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart)))) {
			ec = PrimErrNoMemory;
			goto l4;
		}
		GIV(becomeEffectsFlags) = effectsFlags;
		ec = 0;
	l4:	/* end containsOnlyValidBecomeObjects:and: */;
	}
	else {
		followForwardedObjectFieldstoDepth(array2, 0);
		/* begin containsOnlyValidBecomeObjects: */
		assert(isArray(array1));
		fieldOffset1 = (((numSlotsOf(array1)) - 1) * BytesPerOop) + BaseHeaderSize;

		/* same size as array2 */
		effectsFlags1 = 0;
		while (fieldOffset1 >= BaseHeaderSize) {
			oop1 = longAt(array1 + fieldOffset1);
			if (((oop1 & (tagMask())) == 0)
			 && (((longAt(oop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop1));
				referent4 = longAt((oop1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent4 & (tagMask())) == 0)
				 && (((longAt(referent4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent4 = longAt((referent4 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				oop1 = referent4;
				longAtput(array1 + fieldOffset1, oop1);
			}
			if (!(((errCode = isOopValidBecome(oop1))) == 0)) {
				ec = errCode;
				goto l5;
			}
			effectsFlags1 = effectsFlags1 | (becomeEffectFlagsFor(oop1));
			fieldOffset1 -= BytesPerOop;
		}
		GIV(becomeEffectsFlags) = effectsFlags1;
		ec = 0;
	l5:	/* end containsOnlyValidBecomeObjects: */;
	}
	if (ec != 0) {
		GIV(becomeEffectsFlags) = 0;
		return ec;
	}
	/* begin preBecomeAction */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	if (twoWayFlag) {
		/* begin innerBecomeObjectsIn:and:copyHash: */
		for (i = 0, iLimiT = ((numSlotsOf(array1)) - 1); i <= iLimiT; i += 1) {

			/* At first blush it would appear unnecessary to use followField: here since
			   the validation in become:with:twoWay:copyHash: follows forwarders.  But
			   there's nothing to ensure all elements of each array are unique and don't
			   appear in the other array.  So the enumeration could encounter an object
			   already becommed earlier in the same enumeration. */
			/* begin followField:ofObject: */
			objOop2 = longAt((array1 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
			if (((objOop2 & (tagMask())) == 0)
			 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop2 = fixFollowedFieldofObjectwithInitialValue(i, array1, objOop2);
			}
			obj1 = objOop2;
			/* begin followField:ofObject: */
			objOop3 = longAt((array2 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
			if (((objOop3 & (tagMask())) == 0)
			 && (((longAt(objOop3)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop3 = fixFollowedFieldofObjectwithInitialValue(i, array2, objOop3);
			}
			obj2 = objOop3;
			if (obj1 != obj2) {
				/* begin doBecome:and:copyHash: */
				o1ClassIndex = (long32At(obj1 + 4)) & (identityHashHalfWordMask());
				if ((o1ClassIndex != 0)
				 && ((classAtIndex(o1ClassIndex)) != obj1)) {
					o1ClassIndex = 0;
				}
				o2ClassIndex = (long32At(obj2 + 4)) & (identityHashHalfWordMask());
				if ((o2ClassIndex != 0)
				 && ((classAtIndex(o2ClassIndex)) != obj2)) {
					o2ClassIndex = 0;
				}
				if (((numSlotsOf(obj1)) == (numSlotsOf(obj2)))
				 && ((o1ClassIndex == 0)
				 && (o2ClassIndex == 0))) {
					inPlaceBecomeandcopyHashFlag(obj1, obj2, copyHashFlag);
					goto l1;
				}
				outOfPlaceBecomeandcopyHashFlag(obj1, obj2, copyHashFlag);
				if (copyHashFlag) {
					goto l1;
				}
				if (o1ClassIndex != 0) {
					if (o2ClassIndex != 0) {
						classAtIndexput(o1ClassIndex, obj2);
						classAtIndexput(o2ClassIndex, obj1);
					}
					else {

						/* o2 wasn't in the table; set its hash */
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(obj1));
						referent1 = longAt((obj1 + BaseHeaderSize) + (0LL << (shiftForWord())));
						while (((referent1 & (tagMask())) == 0)
						 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
						}
						newObj2 = referent1;
						assert((rawHashBitsOf(newObj2)) == 0);
						/* begin setHashBitsOf:to: */
						flag("endianness");
						assert(((o1ClassIndex >= 0) && (o1ClassIndex <= (identityHashHalfWordMask()))));
						long32Atput(newObj2 + 4, ((((long32At(newObj2 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + o1ClassIndex);
					}
				}
				else {
					if (o2ClassIndex != 0) {

						/* o1 wasn't in the table; set its hash */
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(obj2));
						referent2 = longAt((obj2 + BaseHeaderSize) + (0LL << (shiftForWord())));
						while (((referent2 & (tagMask())) == 0)
						 && (((longAt(referent2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent2 = longAt((referent2 + BaseHeaderSize) + (0LL << (shiftForWord())));
						}
						newObj1 = referent2;
						assert((rawHashBitsOf(newObj1)) == 0);
						/* begin setHashBitsOf:to: */
						flag("endianness");
						assert(((o2ClassIndex >= 0) && (o2ClassIndex <= (identityHashHalfWordMask()))));
						long32Atput(newObj1 + 4, ((((long32At(newObj1 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + o2ClassIndex);
					}
				}
			l1:	/* end doBecome:and:copyHash: */;
				/* begin followField:ofObject: */
				objOop = longAt((array1 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
				if (((objOop & (tagMask())) == 0)
				 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(i, array1, objOop);
				}
				/* begin followField:ofObject: */
				objOop1 = longAt((array2 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
				if (((objOop1 & (tagMask())) == 0)
				 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop1 = fixFollowedFieldofObjectwithInitialValue(i, array2, objOop1);
				}
			}
		}
	}
	else {
		/* begin innerBecomeObjectsIn:to:copyHash: */
		for (i1 = 0, iLimiT1 = ((numSlotsOf(array1)) - 1); i1 <= iLimiT1; i1 += 1) {

			/* At first blush it would appear unnecessary to use followField: here since
			   the validation in become:with:twoWay:copyHash: follows forwarders.  But
			   there's nothing to ensure all elements of each array is unique and doesn't
			   appear in the other array.  So the enumeration could encounter an object
			   already becommed earlier in the same enumeration. */
			/* begin followField:ofObject: */
			objOop5 = longAt((array1 + BaseHeaderSize) + (((long)i1) << (shiftForWord())));
			if (((objOop5 & (tagMask())) == 0)
			 && (((longAt(objOop5)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop5 = fixFollowedFieldofObjectwithInitialValue(i1, array1, objOop5);
			}
			obj11 = objOop5;
			/* begin followField:ofObject: */
			objOop6 = longAt((array2 + BaseHeaderSize) + (((long)i1) << (shiftForWord())));
			if (((objOop6 & (tagMask())) == 0)
			 && (((longAt(objOop6)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop6 = fixFollowedFieldofObjectwithInitialValue(i1, array2, objOop6);
			}
			obj21 = objOop6;
			if (obj11 != obj21) {
				/* begin doBecome:to:copyHash: */
				classIndex = isForwardedObjectClassIndexPun();
				assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
				assert(((7 >= 0) && (7 <= (formatMask()))));
				longAtput(obj11, ((longAt(obj11)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex + (7LL << (formatShift()))));
				
#        if IMMUTABILITY
				/* begin setIsImmutableOf:to: */
				longAtput(obj11, (longAt(obj11)) & (~(1LL << 23)));

#        endif /* IMMUTABILITY */

				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(obj11));
				assert(!(isOopForwarded(obj21)));
				if (isOldObject(obj11)) {

					/* most stores into young objects */
					if (((obj21 & (tagMask())) == 0)
					 && (oopisLessThan(obj21, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(obj11))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(obj11);
						}
					}
				}
				longAtput((obj11 + BaseHeaderSize) + (0LL << (shiftForWord())), obj21);
				if ((byteAt(obj11 + 7)) == 0) {
					byteAtput(obj11 + 7, 1);
				}
				if (copyHashFlag) {
					/* begin setHashBitsOf:to: */
					hash = (long32At(obj11 + 4)) & (identityHashHalfWordMask());
					flag("endianness");
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
					long32Atput(obj21 + 4, ((((long32At(obj21 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
				}
				if ((isOldObject(obj11))
				 && (isYoungObject(obj21))) {
					GIV(becomeEffectsFlags) = GIV(becomeEffectsFlags) | OldBecameNewFlag;
				}
				assert(!((isForwarded(obj21))));
				/* begin followField:ofObject: */
				objOop4 = longAt((array1 + BaseHeaderSize) + (((long)i1) << (shiftForWord())));
				if (((objOop4 & (tagMask())) == 0)
				 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop4 = fixFollowedFieldofObjectwithInitialValue(i1, array1, objOop4);
				}
				assert(!(isForwarded(obj21)));
			}
		}
	}
	/* begin followSpecialObjectsOop */
	if (((longAt(GIV(specialObjectsOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(specialObjectsOop)));
		referent = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		GIV(specialObjectsOop) = referent;
	}
	followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0);
	/* begin postBecomeAction: */
	spurPostBecomeAction(GIV(becomeEffectsFlags));

	postBecomeScanClassTable(GIV(becomeEffectsFlags));
	GIV(becomeEffectsFlags) = 0;
	assert(validClassTableHashes());
	runLeakCheckerFor(GCModeBecome);
	return PrimNoErr;
}


/*	If this object is old, mark it as a root (because a new object
	may be stored into it). */

	/* SpurMemoryManager>>#beRootIfOld: */
void
beRootIfOld(sqInt oop)
{
	if (isOldObject(oop)) {

		/* No, oop is an old object */
		/* begin possibleRootStoreInto: */
		if (!(((((usqInt) (longAt(oop))) >> (rememberedBitShift())) & 1) != 0)) {
			remember(oop);
		}
	}
}

	/* SpurMemoryManager>>#bitsSetInFreeSpaceMaskForAllFreeLists */
static sqInt
bitsSetInFreeSpaceMaskForAllFreeLists(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;

	for (i = 0, iLimiT = (64 - 1); i <= iLimiT; i += 1) {
		if (((GIV(freeLists)[i]) != 0)
		 && (((1LL << i) & GIV(freeListsMask)) == 0)) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#bridgeSize */
static sqInt
bridgeSize(void)
{
	return 2 * BaseHeaderSize;
}

	/* SpurMemoryManager>>#byteFormatMask */
static sqInt
byteFormatMask(void)
{
	return 24;
}

	/* SpurMemoryManager>>#byteSizeOf: */
sqInt
byteSizeOf(sqInt oop)
{
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;

	if ((oop & (tagMask())) != 0) {
		return 0;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(oop + 7);
	numBytes = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	numBytes = ((long)numBytes) << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat())) {
		return numBytes - (((long)(fmt & 3)) << 1);
	}
	return numBytes - (((long)(fmt & 1)) << 2);
}

	/* SpurMemoryManager>>#characterObjectOf: */
sqInt
characterObjectOf(sqInt characterCode)
{
	return (((long)characterCode) << (numTagBits())) + (characterTag());
}

	/* SpurMemoryManager>>#characterTable */
void
characterTable(void)
{
	error("shouldNotImplement");
}


/*	Immediate characters are unsigned */

	/* SpurMemoryManager>>#characterValueOf: */
sqInt
characterValueOf(sqInt oop)
{
	return ((usqInt) (((usqInt)oop))) >> (numTagBits());
}


/*	Assumes zero-based array indexing. */

	/* SpurMemoryManager>>#checkedLongAt: */
sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isInMemory(byteAddress))) {
		warning("checkedLongAt bad address");
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return longAt(byteAddress);
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleFreeSpace has set a bit at each free chunk's
	header. Scan all objects in the heap checking that no pointer points
	to a free chunk and that all free chunks that refer to others refer to
	marked chunks. Answer if all checks pass. */

	/* SpurMemoryManager>>#checkHeapFreeSpaceIntegrity */
static sqInt
checkHeapFreeSpaceIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt fi;
    sqInt fieldOop;
    sqInt fiLimiT;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt i;
    sqInt iLimiT;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt ok;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	ok = 1;
	for (i = 0, iLimiT = (64 - 1); i <= iLimiT; i += 1) {
		if ((GIV(freeLists)[i]) != 0) {
			if ((heapMapAtWord(pointerForOop(GIV(freeLists)[i]))) == 0) {
				print("leak in free list ");
				printNum(i);
				print(" to non-free ");
				printHex(GIV(freeLists)[i]);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit)) {
		if (((longAt(objOop)) & (classIndexMask())) == 0) {
			print("young object ");
			printHex(objOop);
			print(" is free");
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop)) - 1); fi <= fiLimiT; fi += 1) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (((long)fi) << (shiftForWord())));
				if ((fieldOop & (tagMask())) == 0) {
					if ((heapMapAtWord(pointerForOop(fieldOop))) != 0) {
						print("object leak in ");
						printHex(objOop);
						print(" @ ");
						printNum(fi);
						print(" = ");
						printHex(fieldOop);
						print(" is free");
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (((longAt(objOop)) & (classIndexMask())) == 0) {
			print("young object ");
			printHex(objOop);
			print(" is free");
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop)) - 1); fi <= fiLimiT; fi += 1) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (((long)fi) << (shiftForWord())));
				if ((fieldOop & (tagMask())) == 0) {
					if ((heapMapAtWord(pointerForOop(fieldOop))) != 0) {
						print("object leak in ");
						printHex(objOop);
						print(" @ ");
						printNum(fi);
						print(" = ");
						printHex(fieldOop);
						print(" is free");
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == 0) {
			if ((heapMapAtWord(pointerForOop(objOop1))) == 0) {
				print("leak in free chunk ");
				printHex(objOop1);
				print(" is unmapped?! ");
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			fieldOop = longAt((objOop1 + BaseHeaderSize) + (0LL << (shiftForWord())));
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
				print("leak in free chunk ");
				printHex(objOop1);
				print(" @ 0 = ");
				printHex(fieldOop);
				print(" is unmapped");
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			if ((bytesInObject(objOop1)) >= (64 * 8)) {
				for (fi = 2, fiLimiT = 4; fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((long)fi) << (shiftForWord())));
					if ((fieldOop != 0)
					 && ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
						print("leak in free chunk ");
						printHex(objOop1);
						print(" @ ");
						printNum(fi);
						print(" = ");
						printHex(fieldOop);
						print(" is unmapped");
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}
		else {
			for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop1)) - 1); fi <= fiLimiT; fi += 1) {
				fieldOop = longAt((objOop1 + BaseHeaderSize) + (((long)fi) << (shiftForWord())));
				if ((fieldOop & (tagMask())) == 0) {
					if ((heapMapAtWord(pointerForOop(fieldOop))) != 0) {
						print("object leak in ");
						printHex(objOop1);
						print(" @ ");
						printNum(fi);
						print(" = ");
						printHex(fieldOop);
						print(" is free");
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	return ok;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each (non-free)
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rememberedSet, remapBuffer and
	extraRootTable checking
	that every entry is a pointer to a header. Check that the number of roots
	is correct and that all
	rememberedSet entries have their isRemembered: flag set. Answer if all
	checks pass. */

	/* SpurMemoryManager>>#checkHeapIntegrity:classIndicesShouldBeValid: */
static sqInt NoDbgRegParms
checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedNewSpaceObjs, sqInt classIndicesShouldBeValid)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt classIndex3;
    sqInt classOop;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqInt classTablePage2;
    sqInt containsYoung;
    sqInt fi;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex11;
    sqInt fieldIndex12;
    sqInt fieldIndex2;
    sqInt fieldIndex3;
    sqInt fieldOop;
    sqInt fiLimiT;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    usqInt limit;
    sqInt numRememberedObjectsInHeap;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt ok;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt ri;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	ok = 1;
	numRememberedObjectsInHeap = 0;
	for (i = 0, iLimiT = (64 - 1); i <= iLimiT; i += 1) {
		if ((GIV(freeLists)[i]) != 0) {
			if ((heapMapAtWord(pointerForOop(GIV(freeLists)[i]))) != 0) {
				print("leak in free list ");
				printNum(i);
				print(" to non-free ");
				printHex(GIV(freeLists)[i]);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit)) {
		if (((longAt(objOop)) & (classIndexMask())) == 0) {
			print("young object ");
			printHex(objOop);
			print(" is free");
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if (!((!(((((usqInt) (longAt(objOop))) >> 55) & 1) != 0))
				 && (excludeUnmarkedNewSpaceObjs))) {
				if (((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0) {
					print("young object ");
					printHex(objOop);
					print(" is remembered");
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
				if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
					print("object leak in forwarder ");
					printHex(objOop);
					print(" to unmapped ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			else {
				/* begin classOrNilAtIndex: */
				classIndex1 = (classIndex = (longAt(objOop)) & (classIndexMask()));
				assert((classIndex1 <= (tagMask()))
				 || (classIndex1 >= (arrayClassIndexPun())));
				/* begin fetchPointer:ofObject: */
				fieldIndex = ((usqInt) classIndex1) >> (classTableMajorIndexShift());
				classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
				if (classTablePage == GIV(nilObj)) {
					classOop = GIV(nilObj);
					goto l7;
				}
				/* begin fetchPointer:ofObject: */
				fieldIndex1 = classIndex1 & ((1LL << (classTableMajorIndexShift())) - 1);
				classOop = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
			l7:	/* end classOrNilAtIndex: */;
				if (classIndicesShouldBeValid
				 && ((classOop == GIV(nilObj))
				 && (!(((longAt(objOop)) & (classIndexMask())) <= 0x1F)))) {
					print("object leak in ");
					printHex(objOop);
					print(" invalid class index ");
					printHex(classIndex);
					print(" -> ");
					print((classOop == null
						? "nil"
						: "nilObj"));
					/* begin cr */
					printf("\n");
					ok = 0;
				}
				for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop)) - 1); fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop + BaseHeaderSize) + (((long)fi) << (shiftForWord())));
					if ((fieldOop & (tagMask())) == 0) {
						if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
							print("object leak in ");
							printHex(objOop);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							ok = 0;
						}
					}
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (((longAt(objOop)) & (classIndexMask())) == 0) {
			print("young object ");
			printHex(objOop);
			print(" is free");
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if (!((!(((((usqInt) (longAt(objOop))) >> 55) & 1) != 0))
				 && (excludeUnmarkedNewSpaceObjs))) {
				if (((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0) {
					print("young object ");
					printHex(objOop);
					print(" is remembered");
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
				if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
					print("object leak in forwarder ");
					printHex(objOop);
					print(" to unmapped ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			else {
				/* begin classOrNilAtIndex: */
				classIndex2 = (classIndex = (longAt(objOop)) & (classIndexMask()));
				assert((classIndex2 <= (tagMask()))
				 || (classIndex2 >= (arrayClassIndexPun())));
				/* begin fetchPointer:ofObject: */
				fieldIndex2 = ((usqInt) classIndex2) >> (classTableMajorIndexShift());
				classTablePage1 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex2) << (shiftForWord())));
				if (classTablePage1 == GIV(nilObj)) {
					classOop = GIV(nilObj);
					goto l8;
				}
				/* begin fetchPointer:ofObject: */
				fieldIndex11 = classIndex2 & ((1LL << (classTableMajorIndexShift())) - 1);
				classOop = longAt((classTablePage1 + BaseHeaderSize) + (((long)fieldIndex11) << (shiftForWord())));
			l8:	/* end classOrNilAtIndex: */;
				if (classIndicesShouldBeValid
				 && ((classOop == GIV(nilObj))
				 && (!(((longAt(objOop)) & (classIndexMask())) <= 0x1F)))) {
					print("object leak in ");
					printHex(objOop);
					print(" invalid class index ");
					printHex(classIndex);
					print(" -> ");
					print((classOop == null
						? "nil"
						: "nilObj"));
					/* begin cr */
					printf("\n");
					ok = 0;
				}
				for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop)) - 1); fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop + BaseHeaderSize) + (((long)fi) << (shiftForWord())));
					if ((fieldOop & (tagMask())) == 0) {
						if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
							print("object leak in ");
							printHex(objOop);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							ok = 0;
						}
					}
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == 0) {
			if ((heapMapAtWord(pointerForOop(objOop1))) != 0) {
				print("leak in free chunk ");
				printHex(objOop1);
				print(" is mapped?! ");
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			fieldOop = longAt((objOop1 + BaseHeaderSize) + (0LL << (shiftForWord())));
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(objOop1))) != 0)) {
				print("leak in free chunk ");
				printHex(objOop1);
				print(" @ 0 = ");
				printHex(fieldOop);
				print(" is mapped");
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			if ((bytesInObject(objOop1)) >= (64 * 8)) {
				for (fi = 2, fiLimiT = 4; fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((long)fi) << (shiftForWord())));
					if ((fieldOop != 0)
					 && ((heapMapAtWord(pointerForOop(objOop1))) != 0)) {
						print("leak in free chunk ");
						printHex(objOop1);
						print(" @ ");
						printNum(fi);
						print(" = ");
						printHex(fieldOop);
						print(" is mapped");
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
			}
		}
		else {
			containsYoung = 0;
			if (((((usqInt) (longAt(objOop1))) >> (rememberedBitShift())) & 1) != 0) {
				numRememberedObjectsInHeap += 1;
				if (!(isInRememberedSet(objOop1))) {
					print("remembered object ");
					printHex(objOop1);
					print(" is not in remembered table");
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			if (((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				fieldOop = longAt((objOop1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
					print("object leak in forwarder ");
					printHex(objOop1);
					print(" to unmapped ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
				if (((fieldOop & (tagMask())) == 0)
				 && (isYoungObject(fieldOop))) {
					containsYoung = 1;
				}
			}
			else {
				/* begin classOrNilAtIndex: */
				classIndex3 = (classIndex = (longAt(objOop1)) & (classIndexMask()));
				assert((classIndex3 <= (tagMask()))
				 || (classIndex3 >= (arrayClassIndexPun())));
				/* begin fetchPointer:ofObject: */
				fieldIndex3 = ((usqInt) classIndex3) >> (classTableMajorIndexShift());
				classTablePage2 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex3) << (shiftForWord())));
				if (classTablePage2 == GIV(nilObj)) {
					classOop = GIV(nilObj);
					goto l9;
				}
				/* begin fetchPointer:ofObject: */
				fieldIndex12 = classIndex3 & ((1LL << (classTableMajorIndexShift())) - 1);
				classOop = longAt((classTablePage2 + BaseHeaderSize) + (((long)fieldIndex12) << (shiftForWord())));
			l9:	/* end classOrNilAtIndex: */;
				if (classIndicesShouldBeValid
				 && ((classOop == GIV(nilObj))
				 && (classIndex > 0x1F))) {
					print("object leak in ");
					printHex(objOop1);
					print(" invalid class index ");
					printHex(classIndex);
					print(" -> ");
					print((classOop == null
						? "nil"
						: "nilObj"));
					/* begin cr */
					printf("\n");
					ok = 0;
				}
				for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop1)) - 1); fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((long)fi) << (shiftForWord())));
					if ((fieldOop & (tagMask())) == 0) {
						if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
							print("object leak in ");
							printHex(objOop1);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							ok = 0;
						}
						if (((fieldOop & (tagMask())) == 0)
						 && (isYoungObject(fieldOop))) {
							containsYoung = 1;
						}
					}
				}
			}
			if (containsYoung) {
				if (!(((((usqInt) (longAt(objOop1))) >> (rememberedBitShift())) & 1) != 0)) {
					print("unremembered object ");
					printHex(objOop1);
					print(" contains young oop(s)");
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	if (numRememberedObjectsInHeap != (rememberedSetSize())) {
		print("root count mismatch. #heap roots ");
		printNum(numRememberedObjectsInHeap);
		print("; #roots ");
		printNum(rememberedSetSize());
		/* begin cr */
		printf("\n");
		flag("no support for remembered set overflow yet");
	}
	/* begin rememberedSetWithIndexDo: */
	for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
		obj = GIV(rememberedSet)[i1];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned oop in remembered set @ ");
			printNum(i1);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in remembered set @ ");
				printNum(i1);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			else {
				if (((obj & (tagMask())) == 0)
				 && (oopisLessThan(obj, GIV(newSpaceLimit)))) {
					print("non-root in remembered set @ ");
					printNum(i1);
					print(" = ");
					printHex(obj);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
		}

	}
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned remapRoot @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in remapRoots @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned extraRoot @ ");
			printNum(ri);
			print(" => ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in extraRoots @ ");
				printNum(ri);
				print(" => ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
	Answer true if OK. Otherwise print reason and answer false. */

	/* SpurMemoryManager>>#checkOkayOop: */
sqInt
checkOkayOop(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */
	if ((oop & (tagMask())) != 0) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		print("oop ");
		printHex(oop);
		print(" is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		print("oop ");
		printHex(oop);
		print(" size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = (longAt(oop)) & (classIndexMask()))) >= 16)) {
		print("oop ");
		printHex(oop);
		print(" is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask()))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask()))) {
		print("oop ");
		printHex(oop);
		print(" header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	if ((fmt == 6) || (fmt == 8)) {
		print("oop ");
		printHex(oop);
		print(" has an unknown format type");
		return 0;
	}
	if ((fmt == 7) != (classIndex == (isForwardedObjectClassIndexPun()))) {
		print("oop ");
		printHex(oop);
		print(" has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1LL << 22) | (1LL << (22 + 32));
	if (((long64At(oop)) & unusedBits) != 0) {
		print("oop ");
		printHex(oop);
		print(" has some unused header bits set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = (1LL << 0x1F) | ((1LL << 30) | (1LL << (rememberedBitShift())));
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		print("oop ");
		printHex(oop);
		print(" has some header bits unused in young objects set; should be zero");
		return 0;
	}
	return 1;
}


/*	Attempt to verify that the given obj has a reasonable behavior. The class
	must be a
	valid, non-integer oop and must not be nilObj. It must be a pointers
	object with three
	or more fields. Finally, the instance specification field of the behavior
	must match that
	of the instance. If OK answer true. If not, print reason and answer false. */

	/* SpurMemoryManager>>#checkOopHasOkayClass: */
sqInt
checkOopHasOkayClass(usqInt obj)
{
    usqInt objClass;
    sqInt objFormat;

	if (!(checkOkayOop(obj))) {
		return 0;
	}
	objClass = ((usqInt) (fetchClassOfNonImm(obj)));
	if ((objClass & (tagMask())) != 0) {
		print("obj ");
		printHex(obj);
		print(" an immediate is not a valid class or behavior");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!(okayOop(objClass))) {
		print("obj ");
		printHex(obj);
		print(" class obj is not ok");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!((((((usqInt) (longAt(objClass))) >> (formatShift())) & (formatMask())) <= 5)
		 && ((numSlotsOf(objClass)) >= 3))) {
		print("obj ");
		printHex(obj);
		print(" a class (behavior) must be a pointers object of size >= 3");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (((obj & (tagMask())) == 0)
	 && (((((usqInt) (longAt(obj))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))) {
		objFormat = ((((((usqInt) (longAt(obj))) >> (formatShift())) & (formatMask())) | 7) - 7);
	}
	else {
		objFormat = (((usqInt) (longAt(obj))) >> (formatShift())) & (formatMask());
	}
	if ((instSpecOfClassFormat(((longAt((objClass + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3))) != objFormat) {
		print("obj ");
		printHex(obj);
		print(" and its class (behavior) formats differ");
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

	/* SpurMemoryManager>>#checkOopIntegrity:named: */
static sqInt NoDbgRegParms
checkOopIntegritynamed(sqInt obj, char *name)
{
	if ((heapMapAtWord(pointerForOop(obj))) != 0) {
		return 1;
	}
	print(name);
	print(" leak ");
	printHex(obj);
	/* begin cr */
	printf("\n");
	return 0;
}

	/* SpurMemoryManager>>#checkOopIntegrity:named:index: */
static sqInt NoDbgRegParms
checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i)
{
	if ((heapMapAtWord(pointerForOop(obj))) != 0) {
		return 1;
	}
	print(name);
	print(" leak @ ");
	printNum(i);
	print(" = ");
	printHex(obj);
	/* begin cr */
	printf("\n");
	return 0;
}

	/* SpurMemoryManager>>#checkTraversableSortedFreeList */
sqInt
checkTraversableSortedFreeList(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWordAddress;
    usqInt freeChunk;
    usqInt limit;
    usqInt next;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt o;
    usqInt objOop;
    sqInt objOop1;
    usqInt prevFree;
    sqInt prevObj;
    usqInt prevPrevFree;
    sqInt prevPrevObj;
    sqInt slotBytes;

	prevFree = (prevPrevFree = 0);
	if (GIV(firstFreeChunk) == 0) {
		return GIV(lastFreeChunk) == 0;
	}
	freeChunk = GIV(firstFreeChunk);
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == 0) {
			assert(objOop1 == freeChunk);
			next = ((usqInt)((longAt((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ prevFree));

			/* coInterpreter transcript cr; print: freeChunk; tab; print: o; tab; print: prevFree; nextPutAll: '<->'; print: next; flush. */
			limit = (next == 0
				? GIV(endOfMemory)
				: next);
			objOop = freeChunk;
			while (oopisLessThan((objOop = objectAfter(objOop)), limit)) {
				assert(!(isFreeObject(objOop)));
			}
			prevPrevFree = prevFree;
			prevFree = freeChunk;
			freeChunk = next;
		}

		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop1 + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	assert(prevFree == GIV(lastFreeChunk));
	assert((nextInSortedFreeListLinkgiven(GIV(lastFreeChunk), 0)) == prevPrevFree);
	assert(freeChunk == 0);
	return 1;
}

	/* SpurMemoryManager>>#classAlien */
sqInt
classAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassAlien) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classArray */
sqInt
classArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassArray) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classAtIndex: */
sqInt
classAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift());
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1LL << (classTableMajorIndexShift())) - 1);
	return longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
}


/*	for become & GC of classes */

	/* SpurMemoryManager>>#classAtIndex:put: */
static sqInt NoDbgRegParms
classAtIndexput(sqInt classIndex, sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	assert((objOop == GIV(nilObj))
	 || ((((rawHashBitsOf(objOop)) == classIndex)
	 || ((classAtIndex(rawHashBitsOf(objOop))) == objOop))
	 && (objCouldBeClassObj(objOop))));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift());
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (classTablePage == GIV(nilObj)) {
		error("attempt to add class to empty page");
	}
	/* begin storePointer:ofObject:withValue: */
	fieldIndex1 = classIndex & ((1LL << (classTableMajorIndexShift())) - 1);
	assert(!(isForwarded(classTablePage)));
	if (isOldObject(classTablePage)) {

		/* most stores into young objects */
		if (((objOop & (tagMask())) == 0)
		 && (oopisLessThan(objOop, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(classTablePage))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(classTablePage);
			}
		}
	}
	return longAtput((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())), objOop);
}

	/* SpurMemoryManager>>#classBitmap */
sqInt
classBitmap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassBitmap) << (shiftForWord())));
}


/*	a.k.a. self fetchPointer: ClassByteArrayCompactIndex ofObject:
	classTableFirstPage 
 */

	/* SpurMemoryManager>>#classByteArray */
sqInt
classByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteArray) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classCharacter */
sqInt
classCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassCharacter) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classExternalAddress */
sqInt
classExternalAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassExternalAddress) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classExternalData */
sqInt
classExternalData(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassExternalData) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classExternalFunction */
sqInt
classExternalFunction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassExternalFunction) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classExternalLibrary */
sqInt
classExternalLibrary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassExternalLibrary) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classExternalStructure */
sqInt
classExternalStructure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassExternalStructure) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classFloat */
sqInt
classFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassFloat) << (shiftForWord())));
}


/*	22-bit class mask => ~ 4M classes */

	/* SpurMemoryManager>>#classIndexFieldWidth */
static sqInt
classIndexFieldWidth(void)
{
	return 22;
}

	/* SpurMemoryManager>>#classIndexOf: */
sqInt
classIndexOf(sqInt objOop)
{
	return (longAt(objOop)) & (classIndexMask());
}

	/* SpurMemoryManager>>#classLargeNegativeInteger */
sqInt
classLargeNegativeInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin knownClassAtIndex: */
	assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize()))));
	return longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)ClassLargeNegativeIntegerCompactIndex) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classLargePositiveInteger */
sqInt
classLargePositiveInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin knownClassAtIndex: */
	assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize()))));
	return longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)ClassLargePositiveIntegerCompactIndex) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classOrNilAtIndex: */
sqInt
classOrNilAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift());
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (classTablePage == GIV(nilObj)) {
		return GIV(nilObj);
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1LL << (classTableMajorIndexShift())) - 1);
	return longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classPoint */
sqInt
classPoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classSemaphore */
sqInt
classSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classSmallInteger */
sqInt
classSmallInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSmallInteger) << (shiftForWord())));
}

	/* SpurMemoryManager>>#classString */
sqInt
classString(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteString) << (shiftForWord())));
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTableMinorIndexMask */

	/* SpurMemoryManager>>#classTableMinorIndexMask */
sqInt
classTableMinorIndexMask(void)
{
	return (1LL << (classTableMajorIndexShift())) - 1;
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTablePageSize */

	/* SpurMemoryManager>>#classTablePageSize */
sqInt
classTablePageSize(void)
{
	return 1LL << (classTableMajorIndexShift());
}


/*	For Cogit & bootstrap */

	/* SpurMemoryManager>>#classTableRootObj */
sqInt
classTableRootObj(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(hiddenRootsObj);
}


/*	Answer the number of slots for class table pages in the hidden root
	object. 
 */

	/* SpurMemoryManager>>#classTableRootSlots */
static sqInt
classTableRootSlots(void)
{
	return 1LL << (22 - (classTableMajorIndexShift()));
}


/*	Answer the classObj's identityHash to use as a tag in the first-level
	method lookup cache.
 */

	/* SpurMemoryManager>>#classTagForClass: */
sqInt
classTagForClass(sqInt classObj)
{
    sqInt err;
    sqInt hash;

	assert(addressCouldBeClassObj(classObj));
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	return (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(classObj)
				? (((err = enterIntoClassTable(classObj))) != 0
						? -err
						: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
}

	/* SpurMemoryManager>>#classUnsafeAlien */
sqInt
classUnsafeAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassUnsafeAlien) << (shiftForWord())));
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each free
	chunk's header. */

	/* SpurMemoryManager>>#clearLeakMapAndMapAccessibleFreeSpace */
static void
clearLeakMapAndMapAccessibleFreeSpace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWordAddress;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt slotBytes;

	clearHeapMap();
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == 0) {
			heapMapAtWordPut(pointerForOop(objOop1), 1);
		}

		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop1 + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */

	/* SpurMemoryManager>>#clearLeakMapAndMapAccessibleObjects */
static void
clearLeakMapAndMapAccessibleObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	clearHeapMap();
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		heapMapAtWordPut(pointerForOop(objOop1), 1);


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		heapMapAtWordPut(pointerForOop(objOop1), 1);


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			heapMapAtWordPut(pointerForOop(objOop11), 1);

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#cloneInOldSpaceForPinning: */
static sqInt NoDbgRegParms
cloneInOldSpaceForPinning(sqInt objOop)
{
    sqInt fmt;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt referent;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	newObj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(numSlots, (((long)(((numSlots < 1) ? 1 : numSlots))) << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), fmt, (longAt(objOop)) & (classIndexMask()));
	if (fmt <= 5) {
		hasYoung = 0;
		for (i = 0; i < numSlots; i += 1) {
			oop = longAt((objOop + BaseHeaderSize) + (((long)i) << (shiftForWord())));
			if (((oop & (tagMask())) == 0)
			 && (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop));
				referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent & (tagMask())) == 0)
				 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				oop = referent;
			}
			if (((oop & (tagMask())) == 0)
			 && (isYoungObject(oop))) {
				hasYoung = 1;
			}
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(newObj)));
			longAtput((newObj + BaseHeaderSize) + (((long)i) << (shiftForWord())), oop);
		}
		if (hasYoung
		 && (!(isYoungObject(newObj)))) {
			remember(newObj);
		}
	}
	else {
		for (i = 0; i < numSlots; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(newObj)));
			longAtput((newObj + BaseHeaderSize) + (((long)i) << (shiftForWord())), longAt((objOop + BaseHeaderSize) + (((long)i) << (shiftForWord()))));
		}
		if (fmt >= (firstCompiledMethodFormat())) {
			if ((isOldObject(newObj))
			 && ((isYoungObject(objOop))
			 || (((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0))) {
				remember(newObj);
			}
		}
	}
	return newObj;
}

	/* SpurMemoryManager>>#clone: */
sqInt
clone(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt fmt;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt referent;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	if (numSlots > ((1LL << (fixedFieldsFieldWidth())) - 1)) {
		/* begin allocateSlotsInOldSpace:format:classIndex: */
		classIndex = (longAt(objOop)) & (classIndexMask());
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (((long)(((numSlots < 1) ? 1 : numSlots))) << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), fmt, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		classIndex1 = (longAt(objOop)) & (classIndexMask());
		if (numSlots >= (numSlotsMask())) {
			if ((((usqInt) numSlots) >> 56) > 0) {
				newObj = null;
				goto l1;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, fmt, classIndex1);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots);
			longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), fmt, classIndex1));
		}
		else {
			longAtput(newObj1, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)fmt) << (formatShift()))) + classIndex1);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l1:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj)) {
		return 0;
	}
	if (fmt <= 5) {
		hasYoung = 0;
		for (i = 0; i < numSlots; i += 1) {
			oop = longAt((objOop + BaseHeaderSize) + (((long)i) << (shiftForWord())));
			if ((oop & (tagMask())) == 0) {
				if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(oop));
					referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					oop = referent;
				}
				if (((oop & (tagMask())) == 0)
				 && (isYoungObject(oop))) {
					hasYoung = 1;
				}
			}
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(newObj)));
			longAtput((newObj + BaseHeaderSize) + (((long)i) << (shiftForWord())), oop);
		}
		if (hasYoung
		 && (!(isYoungObject(newObj)))) {
			remember(newObj);
		}
	}
	else {
		for (i = 0; i < numSlots; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(newObj)));
			longAtput((newObj + BaseHeaderSize) + (((long)i) << (shiftForWord())), longAt((objOop + BaseHeaderSize) + (((long)i) << (shiftForWord()))));
		}
		if (fmt >= (firstCompiledMethodFormat())) {
			if ((isOldObject(newObj))
			 && ((isYoungObject(objOop))
			 || (((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0))) {
				remember(newObj);
			}
		}
	}
	return newObj;
}


/*	We'd like to use exact fit followed by best or first fit, but it doesn't
	work well enough in practice. So use pig compact. Fill large free objects
	starting from low memory with objects taken from the end of memory. */
/*	for profiling */

	/* SpurMemoryManager>>#compact */
static void NeverInline
compact(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cascade0;
    sqInt cascade1;
    usqInt free;
    sqInt high;
    sqInt i;
    sqInt low;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt prevFree;
    usqInt prevPrevFree;
    sqInt scanAddress;
    sqInt slotBytes;

	GIV(statCompactPassCount) += 1;
	assert((GIV(firstFreeChunk) == 0)
	 || (isFreeObject(GIV(firstFreeChunk))));
	for (i = 1; i <= GIV(numCompactionPasses); i += 1) {
		/* begin pigCompact */
		/* begin sortedFreeListPairwiseReverseDo: */
		free = GIV(lastFreeChunk);
		prevPrevFree = (prevFree = 0);
		while (free != 0) {
			high = (prevFree == 0
				? GIV(endOfMemory) - (2 * BaseHeaderSize)
				: ((byteAt(prevFree + 7)) == (numSlotsMask())
						? prevFree - BaseHeaderSize
						: prevFree));
			/* begin addressAfter: */
			numSlots1 = byteAt(free + 7);
			numSlots = (numSlots1 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(free - BaseHeaderSize))) << 8)))) >> 8
				: numSlots1);
			if (numSlots == 0) {
				slotBytes = 8;
			}
			else {
				slotBytes = ((long)numSlots) << (shiftForWord());
			}
			scanAddress = (free + BaseHeaderSize) + slotBytes;
			while (oopisLessThan(scanAddress, high)) {
				scanAddress = moveARunOfObjectsStartingAtupTo(scanAddress, high);
				if (scanAddress == 0) {
					goto l1;
				}
			}

			if (prevFree == 0) {
				assert(free == GIV(lastFreeChunk));
				prevFree = GIV(lastFreeChunk);
				free = ((usqInt)((longAt((GIV(lastFreeChunk) + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ 0));
			}
			else {
				assert(isFreeObject(prevFree));
				if (prevPrevFree == 0) {
					prevPrevFree = GIV(lastFreeChunk);
					prevFree = ((usqInt)((longAt((GIV(lastFreeChunk) + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ 0));
				}
				else {
					assert(isFreeObject(prevPrevFree));
					free = ((usqInt)((longAt((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ prevPrevFree));
					prevPrevFree = prevFree;
					prevFree = free;
				}
				free = ((usqInt)((longAt((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ prevPrevFree));
			}
		}
		assert(checkTraversableSortedFreeList());
	l1:	/* end pigCompact */;
		eliminateAndFreeForwardersForPigCompact();
	}
	assert(freeListHeadsEmpty());
	rebuildFreeListsForPigCompact();
}

	/* SpurMemoryManager>>#compactClassIndexOf: */
sqInt
compactClassIndexOf(sqInt objOop)
{
	return (longAt(objOop)) & (classIndexMask());
}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Copy objOop into the segment beginning at segAddr, and forward it to the
	copy. If it is a class in the class table, set the copy's hash to 0 for
	reassignment on load,
	and mark it as a class by setting its isRemembered bit.
	Answer the next segmentAddr if successful. Answer an appropriate error
	code if not */
/*	Copy the object... */

	/* SpurMemoryManager>>#copyObj:toAddr:startAt:stopAt: */
static sqInt NoDbgRegParms
copyObjtoAddrstartAtstopAt(sqInt objOop, sqInt segAddr, sqInt segStart, sqInt endSeg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bodySize;
    sqInt contextSize;
    sqInt copy;
    sqInt hash;
    sqInt hash1;
    sqInt i;
    sqInt iLimiT;
    sqInt newOop;
    sqInt numMediatedSlots;
    usqInt numSlots;
    sqInt oop;

	bodySize = bytesInObject(objOop);
	if (oopisGreaterThanOrEqualTo(segAddr + bodySize, endSeg)) {
		return PrimErrWritePastObject;
	}
	memcpy(((void *)segAddr), ((void *)(((byteAt(objOop + 7)) == (numSlotsMask())
	? objOop - BaseHeaderSize
	: objOop))), bodySize);
	/* begin objectStartingAt: */
	numSlots = byteAt(segAddr + 7);
	copy = (numSlots == (numSlotsMask())
		? segAddr + BaseHeaderSize
		: segAddr);
	/* begin setIsRememberedOf:to: */
	longAtput(copy, (longAt(copy)) & (~(1LL << (rememberedBitShift()))));
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(copy)));
	longAtput(copy, (longAt(copy)) & (~(1LL << 55)));
	/* begin ifAProxy:updateCopy: */
	if ((((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex))
	 && (((((longAt((objOop + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))) {

		/* Since the context is here via objectsReachableFromRoots: we know it cannot be divorced.
		   I'd like to assert coInterpreter checkIsStillMarriedContext: objOop currentFP: framePointer,
		   here but that requires access to framePointer. */
		/* begin numSlotsOfMarriedContext: */
		contextSize = stackPointerIndexForFrame(frameOfMarriedContext(objOop));
		numMediatedSlots = CtxtTempFrameStart + contextSize;
		for (i = 0; i < numMediatedSlots; i += 1) {
			oop = fetchPointerofMarriedContext(i, objOop);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(copy)));
			longAtput((copy + BaseHeaderSize) + (((long)i) << (shiftForWord())), oop);
		}
		for (i = numMediatedSlots, iLimiT = ((numSlotsOf(objOop)) - 1); i <= iLimiT; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(copy)));
			longAtput((copy + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
		}
	}
	hash = (long32At(objOop + 4)) & (identityHashHalfWordMask());
	if ((hash > 0x1F)
	 && ((classOrNilAtIndex(hash)) == objOop)) {
		/* begin setHashBitsOf:to: */
		flag("endianness");
		assert(((0 >= 0) && (0 <= (identityHashHalfWordMask()))));
		long32Atput(copy + 4, ((((long32At(copy + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))));
		/* begin setIsRememberedOf:to: */
		longAtput(copy, (longAt(copy)) | (1LL << (rememberedBitShift())));
	}
	newOop = (copy - segStart) / 8;
	if (newOop > (identityHashHalfWordMask())) {
		return PrimErrLimitExceeded;
	}
	/* begin setHashBitsOf:to: */
	hash1 = (copy - segStart) / 8;
	flag("endianness");
	assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
	long32Atput(objOop + 4, ((((long32At(objOop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop)));
	longAtput(objOop, (longAt(objOop)) | (1LL << 55));
	return segAddr + bodySize;
}


/*	print the count of marked and unmarked objects.
	In addition if 1 is set in printFlags, short-print marked objects,
	and/or if 2 is set, short-print unmarked obejcts. */

	/* SpurMemoryManager>>#countMarkedAndUnmarkdObjects: */
void
countMarkedAndUnmarkdObjects(sqInt printFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    sqInt nm;
    sqInt nu;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	nm = (nu = 0);
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			nm += 1;
			if (printFlags & 1) {
				shortPrintOop(objOop1);
			}
		}
		else {
			nu += 1;
			if (printFlags & 2) {
				shortPrintOop(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			nm += 1;
			if (printFlags & 1) {
				shortPrintOop(objOop1);
			}
		}
		else {
			nu += 1;
			if (printFlags & 2) {
				shortPrintOop(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (((((usqInt) (longAt(objOop11))) >> 55) & 1) != 0) {
				nm += 1;
				if (printFlags & 1) {
					shortPrintOop(objOop11);
				}
			}
			else {
				nu += 1;
				if (printFlags & 2) {
					shortPrintOop(objOop11);
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	print("n marked: ");
	printNum(nm);
	/* begin cr */
	printf("\n");
	print("n unmarked: ");
	printNum(nu);
	/* begin cr */
	printf("\n");
}


/*	Answer the default amount of memory to allocate for the eden space.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file.
	The shootout tests seem to plateau at 5 or 6Mb.
	
	Both the 32-bit and 64-bit versions use the same 4Mb default. Measuring
	the simulator on image start-up, the 64-bit system's eden at the same
	point in start-up (the first copyBits) is only 8% larger in bytes because
	it allocates
	26% fewer objects. Some 21% of the objects in the 32-bit version's eden
	are large integers and floats that are representable as 64-bit immediates. */

	/* SpurMemoryManager>>#defaultEdenBytes */
static sqInt
defaultEdenBytes(void)
{
	return (4 * 1024) * 1024;
}


/*	This is a rare operation, so its efficiency isn't critical.
	Having a valid prev link for tree nodes would help. */

	/* SpurMemoryManager>>#detachFreeObject: */
static void NoDbgRegParms
detachFreeObject(sqInt freeChunk)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    usqInt chunkBytes;
    sqInt f;
    sqInt fieldIndex;
    usqInt index;
    sqInt next;
    sqInt node;
    sqInt prev;
    sqInt result;
    sqInt valuePointer;

	chunkBytes = bytesInObject(freeChunk);
	/* begin allocateOldSpaceChunkOfExactlyBytes:suchThat: */
	index = chunkBytes / 8;
	if (index < 64) {
		if (GIV(freeListsMask) & (1LL << index)) {
			if (((node = GIV(freeLists)[index])) == 0) {
				GIV(freeListsMask) -= 1LL << index;
			}
			else {
				prev = 0;
				while (node != 0) {
					assert(node == (startOfObject(node)));
					assert(isValidFreeObject(node));
					next = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
					if (node == freeChunk) {
						if (prev == 0) {
							GIV(freeLists)[index] = next;
						}
						else {
							/* begin storePointer:ofFreeChunk:withValue: */
							assert(isFreeObject(prev));
							assert((next == 0)
							 || (isFreeObject(next)));
							longAtput((prev + BaseHeaderSize) + (0LL << (shiftForWord())), next);
						}
						GIV(totalFreeOldSpace) -= chunkBytes;
						result = node;
						goto l1;
					}
					prev = node;
					node = next;
				}
			}
		}
		result = null;
		goto l1;
	}
	node = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		assert(isValidFreeObject(child));
		childBytes = bytesInObject(child);
		if (childBytes == chunkBytes) {

			/* size match; try to remove from list at node first. */
			node = child;
			while (1) {
				prev = node;
				node = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
				if (!(node != 0)) break;
				if (node == freeChunk) {
					assert(isValidFreeObject(node));
					/* begin storePointer:ofFreeChunk:withValue: */
					valuePointer = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
					assert(isFreeObject(prev));
					assert((valuePointer == 0)
					 || (isFreeObject(valuePointer)));
					longAtput((prev + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
					GIV(totalFreeOldSpace) -= chunkBytes;
					result = ((byteAt(node + 7)) == (numSlotsMask())
						? node - BaseHeaderSize
						: node);
					goto l1;
				}
			}
			if (!(child == freeChunk)) {
				result = null;
				goto l1;
			}
			next = longAt((child + BaseHeaderSize) + (0LL << (shiftForWord())));
			if (next == 0) {

				/* no list; remove the interior node */
				unlinkSolitaryFreeTreeNode(child);
			}
			else {

				/* list; replace node with it */
				inFreeTreeReplacewith(child, next);
			}
			GIV(totalFreeOldSpace) -= chunkBytes;
			result = ((byteAt(child + 7)) == (numSlotsMask())
				? child - BaseHeaderSize
				: child);
			goto l1;
		}
		else {

			/* no size match; walk down the tree */
			/* begin fetchPointer:ofFreeChunk: */
			fieldIndex = (childBytes < chunkBytes
				? 4
				: 3);
			child = longAt((child + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
		}
	}
	result = null;
l1:	/* end allocateOldSpaceChunkOfExactlyBytes:suchThat: */;
	assert(result == (startOfObject(freeChunk)));
}

	/* SpurMemoryManager>>#displayObject */
sqInt
displayObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheDisplay) << (shiftForWord())));
}


/*	The inner shell for scavenge, abstrascted out so globalGarbageCollect can
	use it.
 */

	/* SpurMemoryManager>>#doScavenge: */
static void NoDbgRegParms
doScavenge(sqInt tenuringCriterion)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurNewSpaceSpace *aNewSpace;
    float fractionSurvived;
    sqInt oldStart;
    sqInt p;
    SpurNewSpaceSpace temp;

	GIV(scavengeInProgress) = 1;
	/* begin scavenge: */
	GIV(statSurvivorCount) = 0;
	GIV(tenureCriterion) = tenuringCriterion;
	/* begin strategizeToLimitRememberedTable */
	if ((GIV(tenureCriterion) == TenureByAge)
	 && (GIV(rememberedSetSize) >= GIV(rememberedSetRedZone))) {
		GIV(tenureCriterion) = TenureToShrinkRT;
		computeRefCountToShrinkRT();
	}
	scavengeLoop();
	processWeaklings();
	/* begin computeTenuringThreshold */
	fractionSurvived = (((GIV(futureSpace).limit)) == ((GIV(futureSpace).start))
		? 0.0
		: (((double) (GIV(futureSurvivorStart) - ((GIV(futureSpace).start))) )) / (((GIV(futureSpace).limit)) - ((GIV(futureSpace).start))));
	GIV(tenureThreshold) = (fractionSurvived > 0.9
		? (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - GIV(tenuringProportion))))) + ((GIV(pastSpace).start))
		: 0);
	/* begin exchangeSurvivorSpaces */
	temp = GIV(pastSpace);
	GIV(pastSpace) = GIV(futureSpace);
	GIV(futureSpace) = temp;
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	GIV(pastSpaceStart) = oldStart;
	assert(oopisGreaterThanOrEqualToandLessThanOrEqualTo(GIV(pastSpaceStart), ((pastSpace()).start), ((pastSpace()).limit)));
	GIV(freeStart) = ((eden()).start);
	/* begin initSpaceForAllocationCheck:limit: */
	aNewSpace = ((SpurNewSpaceSpace *) ((&(eden()))));
	if (!(GIV(memory) == null)) {
		if (checkAllocFiller()) {
			for (p = ((aNewSpace->start)); p < GIV(scavengeThreshold); p += BytesPerWord) {
				longAtput(p, p);
			}
		}
	}
	GIV(scavengeInProgress) = 0;
}


/*	Instantiate an instance of a compact class. ee stands for execution engine
	and implies that this allocation will *NOT* cause a GC. N.B. the
	instantiated object
	IS NOT FILLED and must be completed before returning it to Smalltalk.
	Since this
	call is used in routines that do just that we are safe. Break this rule
	and die in GC.
	Result is guaranteed to be young. */

	/* SpurMemoryManager>>#eeInstantiateClassIndex:format:numSlots: */
sqInt
eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots)
{
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	return allocateNewSpaceSlotsformatclassIndex(numSlots, objFormat, knownClassIndex);
}


/*	As the final phase of global garbage collect, sweep the heap to follow
	forwarders, then free forwarders, coalescing with free space as we go. */

	/* SpurMemoryManager>>#eliminateAndFreeForwardersForPigCompact */
static void
eliminateAndFreeForwardersForPigCompact(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt bytes;
    sqInt endOfFreeRun;
    sqInt f;
    sqInt firstOfFreeRun;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord11;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress11;
    sqInt followingWordAddress2;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt lowest;
    usqInt lowestForwarder;
    usqInt lowestForwarder1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots111;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots21;
    usqInt numSlots3;
    usqInt numSlots31;
    usqInt numSlots4;
    sqInt o;
    sqInt o1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop2;
    sqInt objOop21;
    sqInt objOop3;
    sqInt objOop4;
    sqInt prevFree;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj11;
    sqInt prevObj2;
    sqInt prevPrevFree;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj11;
    sqInt prevPrevObj2;
    sqInt referent;
    sqInt referent1;
    sqInt referent11;
    sqInt referent2;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes11;
    sqInt slotBytes2;
    sqInt startOfFreeRun;

	endOfFreeRun = 0;
	startOfFreeRun = 0;
	assert(!(isForwarded(GIV(nilObj))));
	assert(!(isForwarded(GIV(falseObj))));
	assert(!(isForwarded(GIV(trueObj))));
	assert(!(isForwarded(freeListsObj())));
	assert(!(isForwarded(GIV(hiddenRootsObj))));
	assert(!(isForwarded(GIV(classTableFirstPage))));
	/* begin followSpecialObjectsOop */
	if (((longAt(GIV(specialObjectsOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(specialObjectsOop)));
		referent = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		GIV(specialObjectsOop) = referent;
	}
	followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0);
	/* begin followForwardedObjStacks */
	followForwardedInObjStackatIndex(GIV(markStack), MarkStackRootIndex);
	followForwardedInObjStackatIndex(GIV(weaklingStack), WeaklingStackRootIndex);
	followForwardedInObjStackatIndex(GIV(mournQueue), MournQueueRootIndex);
	mapInterpreterOops();
	/* begin followRememberedForwardersAndForgetFreeObjectsForPigCompact */
	index = 0;
	while (index < GIV(rememberedSetSize)) {
		obj = GIV(rememberedSet)[index];
		if (((longAt(obj)) & (classIndexMask())) == 0) {

			/* free; remove by overwriting with last element */
			GIV(rememberedSetSize) -= 1;
			GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
		}
		else {
			if (((longAt(obj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin setIsRememberedOf:to: */
				longAtput(obj, (longAt(obj)) & (~(1LL << (rememberedBitShift()))));
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj));
				referent1 = longAt((obj + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent1 & (tagMask())) == 0)
				 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				obj = referent1;
				assert(isRemembered(obj));
				GIV(rememberedSet)[index] = obj;
			}
			index += 1;
		}
	}
	/* begin unmarkSurvivingObjectsForPigCompact */
	prevPrevObj = (prevObj = null);
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	while (oopisLessThan(objOop1, GIV(pastSpaceStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(objOop1)));
			longAtput(objOop1, (longAt(objOop1)) & (~(1LL << 55)));
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart))) {
			objOop1 = GIV(pastSpaceStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin sweepToFollowForwardersForPigCompact */
	assert((GIV(freeStart) == (((eden()).start)))
	 && ((futureSurvivorStart()) == (((futureSpace()).start))));
	/* begin allPastSpaceObjectsDo: */
	prevPrevObj2 = (prevObj2 = null);
	/* begin objectStartingAt: */
	address1 = ((pastSpace()).start);
	numSlots4 = byteAt(address1 + 7);
	objOop12 = (numSlots4 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop12, GIV(pastSpaceStart))) {
		assert(isEnumerableObjectNoAssert(objOop12));
		if (!(((longAt(objOop12)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
			for (i = 0, iLimiT = ((numPointerSlotsOf(objOop12)) - 1); i <= iLimiT; i += 1) {
				f = longAt((objOop12 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
				if (((f & (tagMask())) == 0)
				 && (((longAt(f)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(f));
					referent2 = longAt((f + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent2 & (tagMask())) == 0)
					 && (((longAt(referent2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent2 = longAt((referent2 + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					f = referent2;
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop12)));
					longAtput((objOop12 + BaseHeaderSize) + (((long)i) << (shiftForWord())), f);
				}
			}
		}


		prevPrevObj2 = prevObj2;
		prevObj2 = objOop12;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop12 + 7);
		numSlots21 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop12 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots21 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots21) << (shiftForWord());
		}
		followingWordAddress2 = (objOop12 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(pastSpaceStart))) {
			objOop12 = GIV(pastSpaceStart);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop12 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	lowestForwarder1 = 0;
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj11 = (prevObj11 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				if (lowestForwarder1 == 0) {
					lowestForwarder1 = objOop11;
				}
			}
			else {
				for (i = 0, iLimiT = ((numPointerSlotsOf(objOop11)) - 1); i <= iLimiT; i += 1) {
					f = longAt((objOop11 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
					if (((f & (tagMask())) == 0)
					 && (((longAt(f)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(f));
						referent11 = longAt((f + BaseHeaderSize) + (0LL << (shiftForWord())));
						while (((referent11 & (tagMask())) == 0)
						 && (((longAt(referent11)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent11 = longAt((referent11 + BaseHeaderSize) + (0LL << (shiftForWord())));
						}
						f = referent11;
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(objOop11)));
						if (isOldObject(objOop11)) {

							/* most stores into young objects */
							if (((f & (tagMask())) == 0)
							 && (oopisLessThan(f, GIV(newSpaceLimit)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(objOop11))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(objOop11);
								}
							}
						}
						longAtput((objOop11 + BaseHeaderSize) + (((long)i) << (shiftForWord())), f);
					}
				}
			}

		}

		prevPrevObj11 = prevObj11;
		prevObj11 = objOop11;
		/* begin objectAfter:limit: */
		numSlots111 = byteAt(objOop11 + 7);
		numSlots31 = (numSlots111 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots111);
		if (numSlots31 == 0) {
			slotBytes11 = 8;
		}
		else {
			slotBytes11 = ((long)numSlots31) << (shiftForWord());
		}
		followingWordAddress11 = (objOop11 + BaseHeaderSize) + slotBytes11;
		if (oopisGreaterThanOrEqualTo(followingWordAddress11, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord11 = longAt(followingWordAddress11);
		objOop11 = ((((usqInt) followingWord11) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress11 + BaseHeaderSize
			: followingWordAddress11);
	l4:	/* end objectAfter:limit: */;
	}
	lowestForwarder = lowestForwarder1;
	/* begin sweepToCoallesceFreeSpaceForPigCompactFrom: */
	lowest = ((((lowestForwarder == 0
	? GIV(endOfMemory)
	: lowestForwarder)) < ((GIV(firstFreeChunk) == 0
	? GIV(endOfMemory)
	: GIV(firstFreeChunk)))) ? ((lowestForwarder == 0
	? GIV(endOfMemory)
	: lowestForwarder)) : ((GIV(firstFreeChunk) == 0
	? GIV(endOfMemory)
	: GIV(firstFreeChunk))));
	firstOfFreeRun = (prevPrevFree = (prevFree = 0));
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(lowest));
	prevPrevObj1 = (prevObj1 = null);
	objOop3 = lowest;
	while (1) {
		assert((objOop3 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop3, GIV(endOfMemory)))) break;
		assert((long64At(objOop3)) != 0);
		if ((((longAt(objOop3)) & (classIndexMask())) == 0)
		 || (((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
			if (firstOfFreeRun == 0) {
				/* begin setObjectFree: */
				if ((byteAt(objOop3 + 7)) == 0) {
					byteAtput(objOop3 + 7, 1);
				}
				/* begin setFree: */
				long32Atput(objOop3, 0);
				firstOfFreeRun = objOop3;
				startOfFreeRun = ((byteAt(objOop3 + 7)) == (numSlotsMask())
					? objOop3 - BaseHeaderSize
					: objOop3);
			}
			endOfFreeRun = objOop3;
		}
		else {
			if (firstOfFreeRun != 0) {
				bytes = (addressAfter(endOfFreeRun)) - startOfFreeRun;
				firstOfFreeRun = initFreeChunkWithBytesat(bytes, startOfFreeRun);
				/* begin inSortedFreeListLink:to:given: */
				if (prevFree == 0) {
					GIV(firstFreeChunk) = firstOfFreeRun;
				}
				else {
					/* begin storePointer:ofFreeChunk:withUncheckedValue: */
					assert(isFreeObject(prevFree));
					longAtput((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree ^ firstOfFreeRun);
				}
				prevPrevFree = prevFree;
				prevFree = firstOfFreeRun;
				firstOfFreeRun = 0;
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop3;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop3 + 7);
		numSlots3 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop3 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop3 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop3 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop3 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	if (firstOfFreeRun != 0) {
		bytes = (addressAfter(endOfFreeRun)) - startOfFreeRun;
		firstOfFreeRun = initFreeChunkWithBytesat(bytes, startOfFreeRun);
		/* begin inSortedFreeListLink:to:given: */
		if (prevFree == 0) {
			GIV(firstFreeChunk) = firstOfFreeRun;
		}
		else {
			/* begin storePointer:ofFreeChunk:withUncheckedValue: */
			assert(isFreeObject(prevFree));
			longAtput((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree ^ firstOfFreeRun);
		}
		prevPrevFree = prevFree;
		prevFree = firstOfFreeRun;
		firstOfFreeRun = 0;
	}
	if (prevFree != GIV(firstFreeChunk)) {
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(prevFree));
		assert((prevPrevFree == 0)
		 || (isFreeObject(prevPrevFree)));
		longAtput((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree);
	}
	GIV(lastFreeChunk) = prevFree;
	/* begin inSortedFreeListLink:to:given: */
	if (GIV(lastFreeChunk) == 0) {
		GIV(firstFreeChunk) = 0;
	}
	else {
		/* begin storePointer:ofFreeChunk:withUncheckedValue: */
		assert(isFreeObject(GIV(lastFreeChunk)));
		longAtput((GIV(lastFreeChunk) + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree ^ 0);
	}
	assert(checkTraversableSortedFreeList());
	assert((numberOfForwarders()) == 0);
}


/*	Remove all the entries on the stack. Do so by setting Topx to 0
	on the first page, and adding all subsequent pages to the free list. */

	/* SpurMemoryManager>>#emptyObjStack: */
static void NoDbgRegParms
emptyObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nextNextPage;
    sqInt nextPage;

	if (objStack == GIV(nilObj)) {
		return;
	}
	eassert(isValidObjStack(objStack));
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(objStack)) == (wordIndexableFormat()));
	longAtput((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())), 0);
	nextPage = longAt((objStack + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
	while (nextPage != 0) {
		nextNextPage = longAt((nextPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		longAtput((nextPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())), longAt((objStack + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord()))));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		longAtput((nextPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())), 0);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())), nextPage);
		nextPage = nextNextPage;
	}
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(objStack)) == (wordIndexableFormat()));
	longAtput((objStack + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())), 0);
	eassert(isValidObjStack(objStack));
}

	/* SpurMemoryManager>>#ensureBehaviorHash: */
static sqInt NoDbgRegParms
ensureBehaviorHash(sqInt aBehavior)
{
    sqInt err;
    sqInt hash;

	assert(addressCouldBeClassObj(aBehavior));
	return (((hash = (long32At(aBehavior + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(aBehavior)
				? (((err = enterIntoClassTable(aBehavior))) != 0
						? -err
						: (long32At(aBehavior + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such as
	the markStack or the ephemeronQueue. It is a linked list of segments,
	with the hot end at the head of the list. It is a word object. The stack
	pointer is in ObjStackTopx and 0 means empty. The list goes through
	ObjStackNextx. We don't want to shrink objStacks, since they're used
	in GC and its good to keep their memory around. So unused pages
	created by popping emptying pages are kept on the ObjStackFreex list. */

	/* SpurMemoryManager>>#ensureRoomOnObjStackAt: */
static sqInt NoDbgRegParms
ensureRoomOnObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt formatField;
    sqInt freeOrNewPage;
    sqInt stackOrNil;
    sqInt thang;

	stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)objStackRootIndex) << (shiftForWord())));
	if ((stackOrNil == GIV(nilObj))
	 || ((longAt((stackOrNil + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())))) >= ObjStackLimit)) {
		if (stackOrNil == GIV(nilObj)) {
			freeOrNewPage = 0;
		}
		else {
			freeOrNewPage = longAt((stackOrNil + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())));
		}
		if (freeOrNewPage != 0) {

			/* the free page list is always on the new page. */
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
			longAtput((stackOrNil + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())), 0);
			assert((!GIV(marking))
			 || (isMarked(freeOrNewPage)));
		}
		else {
			/* begin allocateSlotsInOldSpace:format:classIndex: */
			formatField = sixtyFourBitIndexableFormat();
			freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, (((long)(((ObjStackPageSlots < 1) ? 1 : ObjStackPageSlots))) << (shiftForWord())) + (BaseHeaderSize + BaseHeaderSize), formatField, 19);
			if (!(freeOrNewPage)) {
				error("no memory to allocate or extend obj stack");
			}
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
			longAtput((freeOrNewPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())), 0);
			if (GIV(marking)) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(freeOrNewPage)));
				longAtput(freeOrNewPage, (longAt(freeOrNewPage)) | (1LL << 55));
			}
		}
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((long)ObjStackMyx) << (shiftForWord())), objStackRootIndex);
		/* begin storePointer:ofObjStack:withValue: */
		thang = (stackOrNil == GIV(nilObj)
			? 0
			: stackOrNil);
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())), thang);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())), 0);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (isOldObject(GIV(hiddenRootsObj))) {

			/* most stores into young objects */
			if (((freeOrNewPage & (tagMask())) == 0)
			 && (oopisLessThan(freeOrNewPage, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)objStackRootIndex) << (shiftForWord())), freeOrNewPage);
		assert(isValidObjStackAt(objStackRootIndex));
		/* begin updateRootOfObjStackAt:with: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (isOldObject(GIV(hiddenRootsObj))) {

			/* most stores into young objects */
			if (((freeOrNewPage & (tagMask())) == 0)
			 && (oopisLessThan(freeOrNewPage, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)objStackRootIndex) << (shiftForWord())), freeOrNewPage);
		
		switch (objStackRootIndex) {
		case MarkStackRootIndex:
			GIV(markStack) = freeOrNewPage;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = freeOrNewPage;
			break;
		case MournQueueRootIndex:
			GIV(mournQueue) = freeOrNewPage;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		stackOrNil = freeOrNewPage;
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return stackOrNil;
}


/*	Enter aBehavior into the class table and answer 0. Otherwise answer a
	primitive failure code. */

	/* SpurMemoryManager>>#enterIntoClassTable: */
static sqInt NoDbgRegParms
enterIntoClassTable(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt initialMajorIndex;
    sqInt majorIndex;
    sqInt minorIndex;
    sqInt numSlots;
    sqInt numSlots1;
    usqInt p;
    sqInt page;

	majorIndex = ((usqInt) GIV(classTableIndex)) >> (classTableMajorIndexShift());

	/* classTableIndex should never index the first page; it's reserved for known classes */
	initialMajorIndex = majorIndex;
	assert(initialMajorIndex > 0);
	minorIndex = GIV(classTableIndex) & ((1LL << (classTableMajorIndexShift())) - 1);
	while(1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)majorIndex) << (shiftForWord())));
		if (page == GIV(nilObj)) {
			/* begin allocateSlotsInOldSpace:format:classIndex: */
			numSlots = 1LL << (classTableMajorIndexShift());
			page = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (((long)(((numSlots < 1) ? 1 : numSlots))) << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), 2, 16);
			if (!(page)) {
				return PrimErrNoMemory;
			}
			/* begin fillObj:numSlots:with: */
			numSlots1 = 1LL << (classTableMajorIndexShift());
			assert(oopisLessThan(((page + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1, addressAfter(page)));
			for (p = (((usqInt)(page + BaseHeaderSize))); p <= (((usqInt)(((page + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1))); p += 8) {
				longAtput(p, GIV(nilObj));
			}
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(GIV(hiddenRootsObj))));
			if (isOldObject(GIV(hiddenRootsObj))) {

				/* most stores into young objects */
				if (((page & (tagMask())) == 0)
				 && (oopisLessThan(page, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(GIV(hiddenRootsObj));
					}
				}
			}
			longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)majorIndex) << (shiftForWord())), page);
			GIV(numClassTablePages) += 1;
			minorIndex = 0;
		}
		for (i = minorIndex, iLimiT = ((1LL << (classTableMajorIndexShift())) - 1); i <= iLimiT; i += 1) {
			if ((longAt((page + BaseHeaderSize) + (((long)i) << (shiftForWord())))) == GIV(nilObj)) {

				/* classTableIndex must never index the first page, which is reserved for classes known to the VM. */
				GIV(classTableIndex) = (((long)majorIndex) << (classTableMajorIndexShift())) + i;
				assert(GIV(classTableIndex) >= (1LL << (classTableMajorIndexShift())));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(page)));
				if (isOldObject(page)) {

					/* most stores into young objects */
					if (((aBehavior & (tagMask())) == 0)
					 && (oopisLessThan(aBehavior, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(page))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(page);
						}
					}
				}
				longAtput((page + BaseHeaderSize) + (((long)i) << (shiftForWord())), aBehavior);
				/* begin setHashBitsOf:to: */
				flag("endianness");
				assert(((GIV(classTableIndex) >= 0) && (GIV(classTableIndex) <= (identityHashHalfWordMask()))));
				long32Atput(aBehavior + 4, ((((long32At(aBehavior + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + GIV(classTableIndex));
				assert((classAtIndex(rawHashBitsOf(aBehavior))) == aBehavior);
				return 0;
			}
		}
		majorIndex = ((((majorIndex + 1) & (classIndexMask())) < 1) ? 1 : ((majorIndex + 1) & (classIndexMask())));
		if (majorIndex == initialMajorIndex) {

			/* wrapped; table full */
			return PrimErrLimitExceeded;
		}
	}
}

	/* SpurMemoryManager>>#ephemeronFormat */
static sqInt
ephemeronFormat(void)
{
	return 5;
}

	/* SpurMemoryManager>>#existInstancesInNewSpaceOf: */
static sqInt NoDbgRegParms
existInstancesInNewSpaceOf(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt slotBytes;
    sqInt slotBytes1;

	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin allNewSpaceObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			return 1;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			return 1;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	return 0;
}


/*	Remove aBehavior from the class table. */

	/* SpurMemoryManager>>#expungeFromClassTable: */
static void NoDbgRegParms
expungeFromClassTable(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt majorIndex;
    sqInt minorIndex;

	assert(isInClassTable(aBehavior));
	classIndex = (long32At(aBehavior + 4)) & (identityHashHalfWordMask());
	majorIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift());
	minorIndex = classIndex & ((1LL << (classTableMajorIndexShift())) - 1);
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)majorIndex) << (shiftForWord())));
	assert(classTablePage != GIV(classTableFirstPage));
	assert((numSlotsOf(classTablePage)) == (classTablePageSize()));
	assert((fetchPointerofObject(minorIndex, classTablePage)) == aBehavior);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(classTablePage)));
	longAtput((classTablePage + BaseHeaderSize) + (((long)minorIndex) << (shiftForWord())), GIV(nilObj));
	if (classIndex < GIV(classTableIndex)) {
		GIV(classTableIndex) = classIndex;
	}
	assert(GIV(classTableIndex) >= (1LL << (classTableMajorIndexShift())));
}

	/* SpurMemoryManager>>#falseObject */
sqInt
falseObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(falseObj);
}

	/* SpurMemoryManager>>#fetchByte:ofObject: */
sqInt
fetchByteofObject(sqInt byteIndex, sqInt objOop)
{
	return byteAt((objOop + BaseHeaderSize) + byteIndex);
}

	/* SpurMemoryManager>>#fetchClassOfNonImm: */
static sqInt NoDbgRegParms NeverInline
fetchClassOfNonImm(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	classIndex = (longAt(objOop)) & (classIndexMask());
	if (classIndex <= 0x1F) {
		if (classIndex == 0x1F) {
			return objOop;
		}
		if (classIndex == (isForwardedObjectClassIndexPun())) {
			return GIV(nilObj);
		}
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift());
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (classTablePage == GIV(nilObj)) {
		return GIV(nilObj);
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1LL << (classTableMajorIndexShift())) - 1);
	return longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
}

	/* SpurMemoryManager>>#fetchClassOf: */
sqInt
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt tagBits;

	return (((tagBits = oop & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(oop));
}


/*	In Spur an object's classIndex is the tag in all method caches. */

	/* SpurMemoryManager>>#fetchClassTagOfNonImm: */
static sqInt NoDbgRegParms
fetchClassTagOfNonImm(sqInt obj)
{
	return (longAt(obj)) & (classIndexMask());
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

	/* SpurMemoryManager>>#fetchLong32:ofObject: */
sqInt
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (((long)fieldIndex) << 2));
}

	/* SpurMemoryManager>>#fetchPointer:ofFreeChunk: */
static sqInt NoDbgRegParms
fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
}

	/* SpurMemoryManager>>#fetchPointer:ofObject: */
sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
}


/*	Answer, but do not remove, the largest free chunk in the free lists. */

	/* SpurMemoryManager>>#findLargestFreeChunk */
static sqInt
findLargestFreeChunk(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt childNode;
    sqInt treeNode;

	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		return null;
	}
	while (1) {
		assert(isValidFreeObject(treeNode));
		assert((bytesInObject(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
		childNode = longAt((treeNode + BaseHeaderSize) + (4LL << (shiftForWord())));
		if (!(childNode != 0)) break;
		treeNode = childNode;
	}
	return treeNode;
}


/*	Print the oops of all string-like things that start with the same
	characters as aCString
 */

	/* SpurMemoryManager>>#findStringBeginningWith: */
void
findStringBeginningWith(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt cssz;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	cssz = strlen(aCString);
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask()))) >= cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1);
			/* begin space */
			putchar(' ');
			printNum(lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())));
			/* begin space */
			putchar(' ');
			printOopShort(objOop1);
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask()))) >= cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1);
			/* begin space */
			putchar(' ');
			printNum(lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())));
			/* begin space */
			putchar(' ');
			printOopShort(objOop1);
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if ((((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))
			 && (((lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask()))) >= cssz)
			 && ((strncmp(aCString, pointerForOop(objOop11 + BaseHeaderSize), cssz)) == 0))) {
				printHex(objOop11);
				/* begin space */
				putchar(' ');
				printNum(lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())));
				/* begin space */
				putchar(' ');
				printOopShort(objOop11);
				/* begin cr */
				printf("\n");
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

	/* SpurMemoryManager>>#findString: */
void
findString(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt cssz;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	cssz = strlen(aCString);
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask()))) == cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1);
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask()))) == cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1);
			/* begin space */
			putchar(' ');
			printOopShort(objOop1);
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if ((((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))
			 && (((lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask()))) == cssz)
			 && ((strncmp(aCString, pointerForOop(objOop11 + BaseHeaderSize), cssz)) == 0))) {
				printHex(objOop11);
				/* begin space */
				putchar(' ');
				printOopShort(objOop11);
				/* begin cr */
				printf("\n");
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#firstAccessibleObject */
static sqInt
firstAccessibleObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt savedTenuringThreshold;

	assert(GIV(nilObj) == GIV(oldSpaceStart));
	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
	return GIV(nilObj);
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* SpurMemoryManager>>#firstFixedFieldOfMaybeImmediate: */
static void * NoDbgRegParms
firstFixedFieldOfMaybeImmediate(sqInt oop)
{
	return ((oop & (tagMask())) != 0
		? ((void *)oop)
		: (/* begin firstFixedField: */
			pointerForOop(oop + BaseHeaderSize)));
}

	/* SpurMemoryManager>>#firstFixedField: */
void *
firstFixedField(sqInt objOop)
{
	return pointerForOop(objOop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes.
	There are only two important cases, both for objects with named inst vars,
	i.e. formats 2,3 & 5.
	The first indexable field for formats 2 & 5 is the slot count (by
	convention, even though that's off the end
	of the object). For 3 we must go to the class. */

	/* SpurMemoryManager>>#firstIndexableField: */
void *
firstIndexableField(sqInt objOop)
{
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	if (fmt <= (weakArrayFormat())) {
		if (fmt == 2) {

			/* array starts at 0. */
			return pointerForOop(objOop + BaseHeaderSize);
		}
		if (fmt >= (indexablePointersFormat())) {

			/* indexable with inst vars; need to delve into the class format word */
			/* begin formatOfClass: */
			classPointer = fetchClassOfNonImm(objOop);
			classFormat = ((longAt((classPointer + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
			return pointerForOop((objOop + BaseHeaderSize) + (((long)(classFormat & ((1LL << (fixedFieldsFieldWidth())) - 1))) << (shiftForWord())));
		}
		return 0;
	}
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 && (fmt < (firstCompiledMethodFormat()))) {
		return pointerForOop(objOop + BaseHeaderSize);
	}
	return 0;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormatMask */
sqInt
fixedFieldsOfClassFormatMask(void)
{
	return (1LL << (fixedFieldsFieldWidth())) - 1;
}

	/* SpurMemoryManager>>#fixedFieldsOf:format:length: */
static sqInt NoDbgRegParms
fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength)
{
    sqInt class;


	/* N.B. written to fall through to fetchClassOfNonImm: et al for forwarders
	   so as to trigger an assert fail. */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		return 0;
	}
	if (fmt < 2) {
		return wordLength;
	}
	class = fetchClassOfNonImm(objOop);
	/* begin fixedFieldsOfClassFormat: */
	return (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
}


/*	Private helper for followField:ofObject: to avoid code duplication for
	rare case.
 */

	/* SpurMemoryManager>>#fixFollowedField:ofObject:withInitialValue: */
static sqInt NoDbgRegParms NeverInline
fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;

	assert(isOopForwarded(initialValue));
	objOop = initialValue;
	do {
		objOop = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
	} while(((objOop & (tagMask())) == 0)
		 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(anObject)));
	if (isOldObject(anObject)) {

		/* most stores into young objects */
		if (((objOop & (tagMask())) == 0)
		 && (oopisLessThan(objOop, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(anObject))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(anObject);
			}
		}
	}
	longAtput((anObject + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())), objOop);
	return objOop;
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

	/* SpurMemoryManager>>#followField:ofObject: */
static sqInt NoDbgRegParms
followFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;

	objOop = longAt((anObject + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop);
	}
	return objOop;
}


/*	Post-compact, follow forwarders in an obj stack. */

	/* SpurMemoryManager>>#followForwardedInObjStack:atIndex: */
static sqInt NoDbgRegParms
followForwardedInObjStackatIndex(sqInt objStack, sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt firstPage;
    sqInt index;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt stackOrNil;

	if (objStack == GIV(nilObj)) {
		return objStack;
	}
	stackOrNil = objStack;
	if (((longAt(stackOrNil)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(stackOrNil));
		referent = longAt((stackOrNil + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		stackOrNil = referent;
		/* begin updateRootOfObjStackAt:with: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (isOldObject(GIV(hiddenRootsObj))) {

			/* most stores into young objects */
			if (((stackOrNil & (tagMask())) == 0)
			 && (oopisLessThan(stackOrNil, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)objStackRootIndex) << (shiftForWord())), stackOrNil);
		
		switch (objStackRootIndex) {
		case MarkStackRootIndex:
			GIV(markStack) = stackOrNil;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = stackOrNil;
			break;
		case MournQueueRootIndex:
			GIV(mournQueue) = stackOrNil;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	firstPage = stackOrNil;
	do {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		assert((fetchPointerofObject(ObjStackMyx, stackOrNil)) == objStackRootIndex);

		/* follow forwarded fields including ObjStackNextx and leave field containing the next link. */
		index = (longAt((stackOrNil + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())))) + ObjStackNextx;
		do {
			field = longAt((stackOrNil + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			if ((field != 0)
			 && (((field & (tagMask())) == 0)
			 && (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(field));
				referent1 = longAt((field + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent1 & (tagMask())) == 0)
				 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				field = referent1;
				/* begin storePointer:ofObjStack:withValue: */
				assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
				longAtput((stackOrNil + BaseHeaderSize) + (((long)index) << (shiftForWord())), field);
			}
		} while(((index -= 1)) > ObjStackFreex);
		assert(field == (fetchPointerofObject(ObjStackNextx, stackOrNil)));
	} while(((stackOrNil = field)) != 0);
	while (1) {
		stackOrNil = longAt((firstPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())));
		if (!(stackOrNil != 0)) break;
		if (((longAt(stackOrNil)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(stackOrNil));
			referent2 = longAt((stackOrNil + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent2 & (tagMask())) == 0)
			 && (((longAt(referent2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent2 = longAt((referent2 + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			stackOrNil = referent2;
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(firstPage)) == (wordIndexableFormat()));
			longAtput((firstPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())), stackOrNil);
		}
		firstPage = stackOrNil;
	}
	assert(isValidObjStackAt(objStackRootIndex));
}


/*	Follow pointers in the object to depth.
	Answer if any forwarders were found.
	How to avoid cyclic structures?? A temproary mark bit? */

	/* SpurMemoryManager>>#followForwardedObjectFields:toDepth: */
sqInt
followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt found;
    sqInt i;
    sqInt iLimiT;
    sqInt oop;
    sqInt referent;

	found = 0;
	assert((isPointers(objOop))
	 || (isOopCompiledMethod(objOop)));
	for (i = 0, iLimiT = ((numPointerSlotsOf(objOop)) - 1); i <= iLimiT; i += 1) {
		oop = longAt((objOop + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if ((oop & (tagMask())) == 0) {
			if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				found = 1;
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop));
				referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent & (tagMask())) == 0)
				 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				oop = referent;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(objOop)));
				if (isOldObject(objOop)) {

					/* most stores into young objects */
					if (((oop & (tagMask())) == 0)
					 && (oopisLessThan(oop, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(objOop);
						}
					}
				}
				longAtput((objOop + BaseHeaderSize) + (((long)i) << (shiftForWord())), oop);
			}
			if ((depth > 0)
			 && ((((oop & (tagMask())) == 0)
			 && (isAnyPointerFormat((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask()))))
			 && (followForwardedObjectFieldstoDepth(oop, depth - 1)))) {
				found = 1;
			}
		}
	}
	return found;
}


/*	Follow a forwarding pointer. THis must be a loop because we cannot prevent
	forwarders to
	forwarders being created by lazy become. Consider the following example by
	Igor Stasenko:
	array := { a. b. c }.
	- array at: 1 points to &a. array at: 2 points to &b. array at: 3 points
	to &c
	a becomeForward: b
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	b becomeForward: c.
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	- when accessing array first one has to follow a forwarding chain:
	&a -> &b -> c */

	/* SpurMemoryManager>>#followForwarded: */
sqInt
followForwarded(sqInt objOop)
{
    sqInt referent;

	assert(isUnambiguouslyForwarder(objOop));
	referent = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
	while (((referent & (tagMask())) == 0)
	 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
	}
	return referent;
}


/*	Make sure the obj at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) obj at
	fieldIndex.  */

	/* SpurMemoryManager>>#followObjField:ofObject: */
static sqInt NoDbgRegParms
followObjFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;

	objOop = longAt((anObject + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	assert(isNonImmediate(objOop));
	if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop);
	}
	return objOop;
}

	/* SpurMemoryManager>>#formatOfClass: */
sqInt
formatOfClass(sqInt classPointer)
{
	return ((longAt((classPointer + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3);
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 (?) 64-bit indexable
	10 - 11 32-bit indexable	(11 unused in 32 bits)
	12 - 15 16-bit indexable	(14 & 15 unused in 32-bits)
	16 - 23 byte indexable		(20-23 unused in 32-bits)
	24 - 31 compiled method	(28-31 unused in 32-bits) */

	/* SpurMemoryManager>>#formatOf: */
static sqInt NoDbgRegParms
formatOf(sqInt objOop)
{
	return (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
}


/*	A special format used by the GC to follow only the first pointer. */

	/* SpurMemoryManager>>#forwardedFormat */
static sqInt
forwardedFormat(void)
{
	return 7;
}


/*	for linking objecs on each free list, or, during pigCompact, doubly-
	linking the free objects in address order using the xor link hack. */

	/* SpurMemoryManager>>#freeChunkNextIndex */
static sqInt
freeChunkNextIndex(void)
{
	return 0;
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkParentIndex */
static sqInt
freeChunkParentIndex(void)
{
	return 2;
}

	/* SpurMemoryManager>>#freeChunkWithBytes:at: */
static sqInt NoDbgRegParms
freeChunkWithBytesat(sqInt bytes, sqInt address)
{
    sqInt freeChunk;

	assert(isInOldSpace(address));
	freeChunk = initFreeChunkWithBytesat(bytes, address);
	assert(isInMemory(addressAfter(freeChunk)));
	addToFreeListbytes(freeChunk, bytes);
	assert(freeChunk == (objectStartingAt(address)));
	return freeChunk;
}

	/* SpurMemoryManager>>#freeListHeadsEmpty */
static sqInt
freeListHeadsEmpty(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;

	for (i = 0, iLimiT = (64 - 1); i <= iLimiT; i += 1) {
		if ((GIV(freeLists)[i]) != 0) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#freeListsObj */
static sqInt
freeListsObj(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((firstIndexableField(objectAfter(GIV(trueObj)))) == GIV(freeLists));
	return objectAfter(GIV(trueObj));
}


/*	Free an object in oldSpace. Coalesce if possible to reduce fragmentation. */

	/* SpurMemoryManager>>#freeObject: */
sqInt
freeObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqInt bytes;
    sqInt index;
    sqInt next;
    usqInt numSlots;
    sqInt start;

	assert(isInOldSpace(objOop));
	if (((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0) {
		/* begin forgetObject: */
		assert(GIV(rememberedSetSize) > 0);
		assert(isRemembered(objOop));
		/* begin setIsRememberedOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(1LL << (rememberedBitShift()))));
		if (!(objOop == (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]))) {
			index = 0;
			while (index < GIV(rememberedSetSize)) {
				if (objOop == (GIV(rememberedSet)[index])) {
					GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
					index = GIV(rememberedSetSize);
				}
			}
		}
		GIV(rememberedSetSize) -= 1;
		assert(GIV(rememberedSetSize) >= 0);
	}
	bytes = bytesInObject(objOop);
	start = ((byteAt(objOop + 7)) == (numSlotsMask())
		? objOop - BaseHeaderSize
		: objOop);
	/* begin objectStartingAt: */
	address = start + bytes;
	numSlots = byteAt(address + 7);
	next = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	if (((longAt(next)) & (classIndexMask())) == 0) {
		detachFreeObject(next);
		bytes += bytesInObject(next);
	}
	GIV(totalFreeOldSpace) += bytes;
	return freeChunkWithBytesat(bytes, start);
}


/*	Sweep all of old space, freeing unmarked objects, coalescing free chunks,
	and sorting free space.
	
	Doubly-link the free chunks in address order through the
	freeChunkNextIndex field using the
	xor trick to use only one field, see e.g.
	The Art of Computer Programming, Vol 1, D.E. Knuth, 3rd Ed, Sec 2.2.4
	`Circular Lists', exercise. 18
	http://en.wikipedia.org/wiki/XOR_linked_list.
	Record the lowest free object in firstFreeChunk and the highest in
	lastFreeChunk. 
	Let the segmentManager mark which segments contain pinned objects via
	notePinned:. 
 */

	/* SpurMemoryManager>>#freeUnmarkedObjectsAndSortAndCoalesceFreeSpaceForPigCompact */
static void NeverInline
freeUnmarkedObjectsAndSortAndCoalesceFreeSpaceForPigCompact(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt address;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt header1NumSlots;
    usqInt header2NumSlots;
    sqInt here;
    sqInt here1;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt index;
    usqLong newNumSlots;
    sqInt next;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt numSlots4;
    usqInt numSlots5;
    sqInt o;
    sqInt obj;
    usqLong obj2slots;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevFree;
    sqInt prevObj;
    sqInt prevPrevFree;
    sqInt prevPrevObj;
    usqInt rawNumSlots;
    usqInt rawNumSlotsAfter;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;
    sqInt sweepIndex;


	/* for profiling */
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	/* begin forgetUnmarkedRememberedObjects */
	index = 0;
	while (index < GIV(rememberedSetSize)) {
		obj = GIV(rememberedSet)[index];
		if (((((usqInt) (longAt(obj))) >> 55) & 1) != 0) {
			index += 1;
		}
		else {

			/* unmarked; remove by overwriting with last element. */
			/* begin setIsRememberedOf:to: */
			longAtput(obj, (longAt(obj)) & (~(1LL << (rememberedBitShift()))));
			GIV(rememberedSetSize) -= 1;
			GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
		}
	}
	assert(GIV(rememberedSetSize) >= 0);
	doScavenge(MarkOnTenure);
	/* begin prepareForGlobalSweep */
	sweepIndex = 0;
	for (i1 = 0; i1 < GIV(numSegments); i1 += 1) {
		((GIV(segments)[i1]).containsPinned = 0);
	}
	/* begin setIsMarkedOf:to: */
	address = (((((&(GIV(segments)[GIV(numSegments) - 1])))->segSize)) + ((((&(GIV(segments)[GIV(numSegments) - 1])))->segStart))) - (2 * BaseHeaderSize);
	numSlots5 = byteAt(address + 7);
	objOop1 = (numSlots5 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	assert(!(isFreeObject(objOop1)));
	longAtput(objOop1, (longAt(objOop1)) | (1LL << 55));
	/* begin resetFreeListHeads */
	for (i = 0, iLimiT = (64 - 1); i <= iLimiT; i += 1) {
		GIV(freeLists)[i] = 0;
	}
	GIV(firstFreeChunk) = (prevPrevFree = (prevFree = 0));
	/* begin allOldSpaceEntitiesForCoalescingFrom:do: */
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		rawNumSlots = byteAt(objOop + 7);
		assert((GIV(firstFreeChunk) == 0)
		 || (isFreeObject(GIV(firstFreeChunk))));
		if (((((usqInt) (longAt(objOop))) >> 55) & 1) != 0) {

			/* forwarders should have been followed in markAndTrace: */
			assert(!(isForwarded(objOop)));
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(objOop)));
			longAtput(objOop, (longAt(objOop)) & (~(1LL << 55)));
			if (((((usqInt) (longAt(objOop))) >> 30) & 1) != 0) {
				/* begin notePinned: */
				assert(isPinned(objOop));
				if (((longAt(objOop)) & (classIndexMask())) == 3) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop)));
					longAtput(objOop, (longAt(objOop)) | (1LL << 55));
				}
				else {
					while (((((GIV(segments)[sweepIndex]).segSize)) + (((GIV(segments)[sweepIndex]).segStart))) < objOop) {
						sweepIndex += 1;
					}
					((GIV(segments)[sweepIndex]).containsPinned = 1);
				}
			}
		}
		else {

			/* unmarked; two cases, an unreachable object or a free chunk. */
			assert(!(isRemembered(objOop)));
			/* begin coallesceFreeChunk: */
			here1 = objOop;
			assert(!(isRemembered(here1)));
			assert(isMarked(lastBridge()));
			/* begin objectAfter:limit: */
			numSlots11 = byteAt(here1 + 7);
			numSlots3 = (numSlots11 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(here1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots11);
			if (numSlots3 == 0) {
				slotBytes1 = 8;
			}
			else {
				slotBytes1 = ((long)numSlots3) << (shiftForWord());
			}
			followingWordAddress1 = (here1 + BaseHeaderSize) + slotBytes1;
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
				next = GIV(endOfMemory);
				goto l5;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			next = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		l5:	/* end objectAfter:limit: */;
			while (!(((((usqInt) (longAt(next))) >> 55) & 1) != 0)) {

				/* coalescing; rare case */
				assert(!(isRemembered(next)));
				GIV(statCoalesces) += 1;
				/* begin coalesce:and: */
				header1NumSlots = byteAt(here1 + 7);

				/* compute total number of slots in obj2, including header */
				header2NumSlots = byteAt(next + 7);
				obj2slots = (header2NumSlots == (numSlotsMask())
					? (((usqInt) (((unsigned long)(((long)(longAt(next - BaseHeaderSize))) << 8)))) >> 8) + ((2 * BaseHeaderSize) / BytesPerWord)
					: ((header2NumSlots == 0
	? 1
	: header2NumSlots)) + (BaseHeaderSize / BytesPerWord));
				assert((obj2slots * BytesPerWord) == (bytesInObject(next)));
				if (header1NumSlots == (numSlotsMask())) {
					/* begin rawOverflowSlotsOf:put: */
					numSlots4 = obj2slots + (((usqInt) (((unsigned long)(((long)(longAt(here1 - BaseHeaderSize))) << 8)))) >> 8);
					flag("endianness");
					longAtput(here1 - BaseHeaderSize, (((long)(numSlotsMask())) << 56) + numSlots4);
					here1 = here1;
					goto l6;
				}
				header1NumSlots = (header1NumSlots == 0
					? 1
					: header1NumSlots);
				assert(((header1NumSlots * BytesPerWord) + BaseHeaderSize) == (bytesInObject(here1)));

				/* if obj1 still only requires a single header things are simple... */
				newNumSlots = obj2slots + header1NumSlots;
				if (newNumSlots < (numSlotsMask())) {
					byteAtput(here1 + 7, newNumSlots);
					here1 = here1;
					goto l6;
				}
				newNumSlots -= BaseHeaderSize / BytesPerWord;
				/* begin rawNumSlotsOf:put: */
				aByte = numSlotsMask();
				flag("endian");
				byteAtput((here1 + BaseHeaderSize) + 7, aByte);
				/* begin rawOverflowSlotsOf:put: */
				flag("endianness");
				longAtput((here1 + BaseHeaderSize) - BaseHeaderSize, (((long)(numSlotsMask())) << 56) + newNumSlots);
				here1 += BaseHeaderSize;
			l6:	/* end coalesce:and: */;
				/* begin objectAfter:limit: */
				numSlots12 = byteAt(here1 + 7);
				numSlots2 = (numSlots12 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(here1 - BaseHeaderSize))) << 8)))) >> 8
					: numSlots12);
				if (numSlots2 == 0) {
					slotBytes2 = 8;
				}
				else {
					slotBytes2 = ((long)numSlots2) << (shiftForWord());
				}
				followingWordAddress2 = (here1 + BaseHeaderSize) + slotBytes2;
				if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
					next = GIV(endOfMemory);
					goto l7;
				}
				flag("endianness");
				followingWord2 = longAt(followingWordAddress2);
				next = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress2 + BaseHeaderSize
					: followingWordAddress2);
			l7:	/* end objectAfter:limit: */;
			}
			here = here1;
			/* begin setObjectFree: */
			if ((byteAt(here + 7)) == 0) {
				byteAtput(here + 7, 1);
			}
			/* begin setFree: */
			long32Atput(here, 0);
			/* begin inSortedFreeListLink:to:given: */
			if (prevFree == 0) {
				GIV(firstFreeChunk) = here;
			}
			else {
				/* begin storePointer:ofFreeChunk:withUncheckedValue: */
				assert(isFreeObject(prevFree));
				longAtput((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree ^ here);
			}
			prevPrevFree = prevFree;
			prevFree = here;
		}

		flag("future work");
		rawNumSlotsAfter = byteAt(objOop + 7);
		if ((rawNumSlotsAfter != rawNumSlots)
		 && (rawNumSlotsAfter == (numSlotsMask()))) {
			objOop += BaseHeaderSize;
			assert((objectAfterlimit(prevObj, GIV(endOfMemory))) == objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	if (prevFree != GIV(firstFreeChunk)) {
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(prevFree));
		assert((prevPrevFree == 0)
		 || (isFreeObject(prevPrevFree)));
		longAtput((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree);
	}
	GIV(lastFreeChunk) = prevFree;
	/* begin inSortedFreeListLink:to:given: */
	if (GIV(lastFreeChunk) == 0) {
		GIV(firstFreeChunk) = 0;
	}
	else {
		/* begin storePointer:ofFreeChunk:withUncheckedValue: */
		assert(isFreeObject(GIV(lastFreeChunk)));
		longAtput((GIV(lastFreeChunk) + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree ^ 0);
	}
	assert(checkTraversableSortedFreeList());
}


/*	Perform a full lazy compacting GC. Answer the size of the largest free
	chunk. 
 */
/*	for profiling */

	/* SpurMemoryManager>>#fullGC */
usqLong NeverInline
fullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statMarkCount) = 0;
	/* begin preGCAction: */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	flushMethodCache();

	/* begin globalGarbageCollect */
	assert(validObjStacks());
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	markObjects(1);
	freeUnmarkedObjectsAndSortAndCoalesceFreeSpaceForPigCompact();
	runLeakCheckerForexcludeUnmarkedNewSpaceObjsclassIndicesShouldBeValid(GCModeFull, 1, 1);
	compact();
	/* begin setHeapSizeAtPreviousGC */
	GIV(heapSizeAtPreviousGC) = (GIV(endOfMemory) - GIV(nilObj)) - GIV(totalFreeOldSpace);
	assert(validObjStacks());
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	assert(allObjectsUnmarked());
	runLeakCheckerFor(GCModeFull);
	/* begin attemptToShrink */
	if ((GIV(totalFreeOldSpace) > GIV(shrinkThreshold))
	 && (GIV(totalFreeOldSpace) > GIV(growHeadroom))) {
		GIV(statShrinkMemory) += 1;
		shrinkObjectMemory(GIV(totalFreeOldSpace) - GIV(growHeadroom));
	}
	/* begin postGCAction: */
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	GIV(statFullGCs) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statFullGCUsecs) += GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	return ((GIV(freeLists)[0]) != 0
		? bytesInObject(findLargestFreeChunk())
		: 0);
}

	/* SpurMemoryManager>>#getHeapGrowthToSizeGCRatio */
static float
getHeapGrowthToSizeGCRatio(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(heapGrowthToSizeGCRatio);
}

	/* SpurMemoryManager>>#goodContextSize: */
static sqInt NoDbgRegParms
goodContextSize(sqInt oop)
{
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	return (numSlots == SmallContextSlots)
	 || (numSlots == LargeContextSlots);
}


/*	Attempt to grow memory by at least minAmmount.
	Answer the size of the new segment, or nil if the attempt failed. */

	/* SpurMemoryManager>>#growOldSpaceByAtLeast: */
static sqInt NoDbgRegParms
growOldSpaceByAtLeast(sqInt minAmmount)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    unsigned long ammount;
    sqInt bytes;
    unsigned long headroom;
    sqInt i;
    SpurSegmentInfo *segInfo;
    usqInt total;
    usqInt total1;


	/* statGrowMemory counts attempts, not successes. */

	/* we need to include overhead for a new object header plus the segment bridge. */
	GIV(statGrowMemory) += 1;

	/* round up to the nearest power of two. */
	ammount = minAmmount + ((BaseHeaderSize * 2) + (2 * BaseHeaderSize));

	/* and grow by at least growHeadroom. */
	ammount = 1LL << (highBit(ammount - 1));

	/* Now apply the maxOldSpaceSize limit, if one is in effect. */
	ammount = ((ammount < GIV(growHeadroom)) ? GIV(growHeadroom) : ammount);
	if (maxOldSpaceSize > 0) {
		/* begin totalBytesInSegments */
		total1 = 0;
		for (i = 0; i < GIV(numSegments); i += 1) {
			total1 += ((GIV(segments)[i]).segSize);
		}
		total = total1;
		if (total >= maxOldSpaceSize) {
			return null;
		}
		headroom = maxOldSpaceSize - total;
		if (headroom < ammount) {
			if (headroom < (minAmmount + ((BaseHeaderSize * 2) + (2 * BaseHeaderSize)))) {
				return null;
			}
			ammount = headroom;
		}
	}
	return ((segInfo = addSegmentOfSize(ammount)),
		(!(segInfo == null)
				? (/* begin assimilateNewSegment: */
					((((segInfo->segSize)) + ((segInfo->segStart))) >= GIV(endOfMemory)
							? (GIV(freeOldSpaceStart) = (GIV(endOfMemory) = (((segInfo->segSize)) + ((segInfo->segStart))) - (2 * BaseHeaderSize)))
							: 0),
					/* begin addFreeChunkWithBytes:at: */
					(bytes = ((segInfo->segSize)) - (2 * BaseHeaderSize)),
					(address = (segInfo->segStart)),
					freeChunkWithBytesat(bytes, address),
					(GIV(totalFreeOldSpace) += bytes),
					assert((addressAfter(objectStartingAt((segInfo->segStart)))) == ((segLimit(segInfo)) - (bridgeSize()))),
					/* begin checkFreeSpace: */
					assert(bitsSetInFreeSpaceMaskForAllFreeLists()),
					assert(GIV(totalFreeOldSpace) == (totalFreeListBytes())),
					(((checkForLeaks & (GCModeFreeSpace | GCModeFreeSpace)) == (GCModeFreeSpace | GCModeFreeSpace))
							? runLeakCheckerForFreeSpace(GCModeFreeSpace)
							: 0),
					checkSegments(),
					(segInfo->segSize))
				: 0));
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,?})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#headerForSlots:format:classIndex: */
usqLong
headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{
	return ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)formatField) << (formatShift()))) + classIndex;
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,?})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#headerForSlots:hash:format:classIndex: */
static usqLong NoDbgRegParms
headerForSlotshashformatclassIndex(sqInt numSlots, sqInt hash, sqInt formatField, sqInt classIndex)
{
	return (((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)(((usqLong) hash))) << (identityHashFullWordShift()))) + (((long)formatField) << (formatShift()))) + classIndex;
}


/*	Answer the number of extra root slots in the root of the hidden root
	object. 
 */

	/* SpurMemoryManager>>#hiddenRootSlots */
static sqInt
hiddenRootSlots(void)
{
	return 8;
}


/*	a more complex version that tells both the word reversal and the
	endianness of the machine
	it came from. Low half of word is e.g. 6521. Top byte is top byte of
	#doesNotUnderstand: on
	this machine. ($d on the Mac or $s on the PC) */

	/* SpurMemoryManager>>#imageSegmentVersion */
static sqInt
imageSegmentVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt wholeWord;


	/* first data word, 'does' */
	wholeWord = long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorDoesNotUnderstand) << (shiftForWord())))) + BaseHeaderSize);
	return (imageFormatVersion()) | (wholeWord & 0xFF000000ULL);
}


/*	mask the immutable bit in the base header word */

	/* SpurMemoryManager>>#immutableBitMask */
#if IMMUTABILITY
sqInt
immutableBitMask(void)
{
	return 1LL << 23;
}
#endif /* IMMUTABILITY */

	/* SpurMemoryManager>>#incrementalGC */
void
incrementalGC(void)
{
	error("shouldNotImplement");
}


/*	Part of reorderReversedTreeList:. Switch treeNode with newNode in
	the tree, but do nothing to the list linked through freeChunkNextIndex. */
/*	copy parent, smaller, larger */

	/* SpurMemoryManager>>#inFreeTreeReplace:with: */
static void NoDbgRegParms
inFreeTreeReplacewith(sqInt treeNode, sqInt newNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt i;
    sqInt iLimiT;
    sqInt relative;

	for (i = 2, iLimiT = 4; i <= iLimiT; i += 1) {
		relative = longAt((treeNode + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if (i == 2) {
			if (relative == 0) {

				/* update root to point to newNode */
				assert((GIV(freeLists)[0]) == treeNode);
				GIV(freeLists)[0] = newNode;
			}
			else {

				/* replace link from parent to treeNode with link to newNode. */
				/* begin storePointer:ofFreeChunk:withValue: */
				fieldIndex = (treeNode == (longAt((relative + BaseHeaderSize) + (3LL << (shiftForWord()))))
					? 3
					: 4);
				assert(isFreeObject(relative));
				assert((newNode == 0)
				 || (isFreeObject(newNode)));
				longAtput((relative + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())), newNode);
			}
		}
		else {
			if (relative != 0) {
				assert((fetchPointerofFreeChunk(freeChunkParentIndex(), relative)) == treeNode);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(relative));
				assert((newNode == 0)
				 || (isFreeObject(newNode)));
				longAtput((relative + BaseHeaderSize) + (2LL << (shiftForWord())), newNode);
			}
		}
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(newNode));
		assert((relative == 0)
		 || (isFreeObject(relative)));
		longAtput((newNode + BaseHeaderSize) + (((long)i) << (shiftForWord())), relative);
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(treeNode));
		assert(1);
		longAtput((treeNode + BaseHeaderSize) + (((long)i) << (shiftForWord())), 0);
	}
}

	/* SpurMemoryManager>>#initialInstanceOf: */
static sqInt NoDbgRegParms
initialInstanceOf(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	if (classIndex == 0) {
		return null;
	}
	/* begin flushNewSpaceInstancesOf: */
	classIndex1 = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	if (classIndex1 == 0) {

		/* no instances; nothing to do */
		goto l1;
	}
	/* begin tenuringClassIndex: */
	GIV(tenuringClassIndex) = classIndex1;
	scavengingGCTenuringIf(TenureByClass);
	assert(!(existInstancesInNewSpaceOf(classObj)));
l1:	/* end flushNewSpaceInstancesOf: */;
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (classIndex == ((longAt(objOop1)) & (classIndexMask()))) {
			return objOop1;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (classIndex == ((longAt(objOop1)) & (classIndexMask()))) {
			return objOop1;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (classIndex == ((longAt(objOop11)) & (classIndexMask()))) {
				return objOop11;
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l4:	/* end objectAfter:limit: */;
	}
	return null;
}


/*	Initialize object memory variables at startup time. Assume endOfMemory at
	al are
	initialised by the image-reading code via
	setHeapBase:memoryLimit:endOfMemory:. endOfMemory is assumed to point to
	the end of the last object in the image.
	Assume: image reader also initializes the following variables:
	specialObjectsOop
	lastHash */
/*	Catch mis-initializations leading to bad translations to C */

	/* SpurMemoryManager>>#initializeObjectMemory: */
static void NoDbgRegParms
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurNewSpaceSpace *aNewSpace;
    sqInt anOop;
    sqInt classIndex;
    sqInt classTableRoot;
    sqInt field;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt firstObj;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt followingWordAddress3;
    sqInt freeChunk;
    sqInt freeListObj;
    usqInt freeOldStart;
    sqInt fudge;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt iLimiT;
    sqInt index;
    sqInt indexLimiT;
    usqInt limit;
    usqInt nilObjPreSwizzle;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots14;
    usqInt numSlots15;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    usqInt numSlots5;
    usqInt numSlots6;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt p;
    usqInt p1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;
    sqInt slotBytes3;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert(BaseHeaderSize == BaseHeaderSize);
	assert((((sqInt)((maxSlotsForAlloc()) * BytesPerWord))) > 0);
	initSegmentBridgeWithBytesat(2 * BaseHeaderSize, GIV(endOfMemory) - (2 * BaseHeaderSize));

	adjustSegmentSwizzlesBy(bytesToShift);
	/* begin adjustAllOopsBy: */
	assert(newSpaceIsEmpty());
	/* begin countNumClassPagesPreSwizzle: */
	numSlots6 = byteAt(GIV(oldSpaceStart) + 7);
	firstObj = (numSlots6 == (numSlotsMask())
		? GIV(oldSpaceStart) + BaseHeaderSize
		: GIV(oldSpaceStart));
	/* begin objectAfter:limit: */
	numSlots14 = byteAt(firstObj + 7);
	numSlots5 = (numSlots14 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(firstObj - BaseHeaderSize))) << 8)))) >> 8
		: numSlots14);
	if (numSlots5 == 0) {
		slotBytes3 = 8;
	}
	else {
		slotBytes3 = ((long)numSlots5) << (shiftForWord());
	}
	followingWordAddress3 = (firstObj + BaseHeaderSize) + slotBytes3;
	if (oopisGreaterThanOrEqualTo(followingWordAddress3, GIV(endOfMemory))) {
		objOop2 = GIV(endOfMemory);
		goto l4;
	}
	flag("endianness");
	followingWord3 = longAt(followingWordAddress3);
	objOop2 = ((((usqInt) followingWord3) >> (numSlotsFullShift())) == (numSlotsMask())
		? followingWordAddress3 + BaseHeaderSize
		: followingWordAddress3);
l4:	/* end objectAfter:limit: */;
	/* begin addressAfter: */
	numSlots11 = byteAt(objOop2 + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop2 - BaseHeaderSize))) << 8)))) >> 8
		: numSlots11);
	if (numSlots2 == 0) {
		slotBytes = 8;
	}
	else {
		slotBytes = ((long)numSlots2) << (shiftForWord());
	}
	followingWordAddress2 = (objOop2 + BaseHeaderSize) + slotBytes;
	if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
		objOop1 = GIV(endOfMemory);
		goto l3;
	}
	flag("endianness");
	followingWord2 = longAt(followingWordAddress2);
	objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
		? followingWordAddress2 + BaseHeaderSize
		: followingWordAddress2);
l3:	/* end objectAfter:limit: */;
	/* begin addressAfter: */
	numSlots12 = byteAt(objOop1 + 7);
	numSlots3 = (numSlots12 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
		: numSlots12);
	if (numSlots3 == 0) {
		slotBytes1 = 8;
	}
	else {
		slotBytes1 = ((long)numSlots3) << (shiftForWord());
	}
	followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
	if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
		objOop = GIV(endOfMemory);
		goto l2;
	}
	flag("endianness");
	followingWord1 = longAt(followingWordAddress1);
	objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
		? followingWordAddress1 + BaseHeaderSize
		: followingWordAddress1);
l2:	/* end objectAfter:limit: */;
	/* begin addressAfter: */
	numSlots13 = byteAt(objOop + 7);
	numSlots4 = (numSlots13 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots13);
	if (numSlots4 == 0) {
		slotBytes2 = 8;
	}
	else {
		slotBytes2 = ((long)numSlots4) << (shiftForWord());
	}
	followingWordAddress = (objOop + BaseHeaderSize) + slotBytes2;
	if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
		classTableRoot = GIV(endOfMemory);
		goto l5;
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	classTableRoot = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
		? followingWordAddress + BaseHeaderSize
		: followingWordAddress);
l5:	/* end objectAfter:limit: */;
	nilObjPreSwizzle = GIV(oldSpaceStart) - bytesToShift;
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classTableRoot)) > (isForwardedObjectClassIndexPun()));
	numSlots15 = byteAt(classTableRoot + 7);
	GIV(numClassTablePages) = (numSlots15 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(classTableRoot - BaseHeaderSize))) << 8)))) >> 8
		: numSlots15);
	assert(GIV(numClassTablePages) == ((classTableRootSlots()) + (hiddenRootSlots())));
	for (i2 = 2; i2 < GIV(numClassTablePages); i2 += 1) {
		if ((longAt((classTableRoot + BaseHeaderSize) + (((long)i2) << (shiftForWord())))) == nilObjPreSwizzle) {
			GIV(numClassTablePages) = i2;
			goto l6;
		}
	}
l6:	/* end countNumClassPagesPreSwizzle: */;
	if ((bytesToShift != 0)
	 || ((numSegments()) > 1)) {
		/* begin objectStartingAt: */
		numSlots = byteAt(GIV(oldSpaceStart) + 7);
		obj = (numSlots == (numSlotsMask())
			? GIV(oldSpaceStart) + BaseHeaderSize
			: GIV(oldSpaceStart));
		while (oopisLessThan(obj, GIV(freeOldSpaceStart))) {
			classIndex = (longAt(obj)) & (classIndexMask());
			if (classIndex >= (isForwardedObjectClassIndexPun())) {
				/* begin swizzleFieldsOfObject: */
				fieldAddr = obj + (lastPointerOfWhileSwizzling(obj));
				while (oopisGreaterThanOrEqualTo(fieldAddr, obj + BaseHeaderSize)) {
					fieldOop = longAt(fieldAddr);
					if ((fieldOop & (tagMask())) == 0) {
						longAtput(fieldAddr, swizzleObj(fieldOop));
					}
					fieldAddr -= BytesPerOop;
				}
			}
			else {
				if (classIndex == 0) {
					/* begin swizzleFieldsOfFreeChunk: */
					field = longAt((obj + BaseHeaderSize) + (0LL << (shiftForWord())));
					if (field != 0) {
						/* begin storePointerNoAssert:ofFreeChunk:withValue: */
						valuePointer = swizzleObj(field);
						longAtput((obj + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
					}
					if ((bytesInObject(obj)) >= (64 * 8)) {
						for (index = 2, indexLimiT = 4; index <= indexLimiT; index += 1) {
							field = longAt((obj + BaseHeaderSize) + (((long)index) << (shiftForWord())));
							if (field != 0) {
								/* begin storePointerNoAssert:ofFreeChunk:withValue: */
								valuePointer1 = swizzleObj(field);
								longAtput((obj + BaseHeaderSize) + (((long)index) << (shiftForWord())), valuePointer1);
							}
						}
					}
				}
			}
			obj = objectAfter(obj);
		}
	}

	/* heavily used special objects */
	GIV(specialObjectsOop) = swizzleObj(GIV(specialObjectsOop));
	GIV(nilObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)NilObject) << (shiftForWord())));
	GIV(falseObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)FalseObject) << (shiftForWord())));

	/* In Cog we insist that nil, true & false are next to each other (Cogit generates tighter
	   conditional branch code as a result).  In addition, Spur places the free lists and
	   class table root page immediately following them. */
	GIV(trueObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TrueObject) << (shiftForWord())));
	assert(GIV(nilObj) == GIV(oldSpaceStart));
	assert(GIV(falseObj) == (objectAfter(GIV(nilObj))));
	assert(GIV(trueObj) == (objectAfter(GIV(falseObj))));
	freeListObj = objectAfter(GIV(trueObj));
	/* begin setHiddenRootsObj: */
	anOop = objectAfter(freeListObj);
	GIV(hiddenRootsObj) = anOop;
	assert(validClassTableRootPages());
	GIV(classTableFirstPage) = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (0LL << (shiftForWord())));
	assert(((numSlotsOf(GIV(classTableFirstPage))) - 1) == (classTableMinorIndexMask()));
	GIV(numClassTablePages) = 1LL << (22 - (classTableMajorIndexShift()));
	for (i = 2; i < GIV(numClassTablePages); i += 1) {
		if ((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i) << (shiftForWord())))) == GIV(nilObj)) {
			GIV(numClassTablePages) = i;
			GIV(classTableIndex) = ((long)((((GIV(numClassTablePages) - 1) < 1) ? 1 : (GIV(numClassTablePages) - 1)))) << (classTableMajorIndexShift());
			goto l1;
		}
	}
	GIV(classTableIndex) = 1LL << (classTableMajorIndexShift());
l1:	/* end setHiddenRootsObj: */;
	GIV(markStack) = swizzleObjStackAt(MarkStackRootIndex);
	GIV(weaklingStack) = swizzleObjStackAt(WeaklingStackRootIndex);
	GIV(mournQueue) = swizzleObjStackAt(MournQueueRootIndex);
	assert(validObjStacks());
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	/* begin initializeFreeSpacePostLoad: */
	assert((numSlotsOf(freeListObj)) == (numFreeLists()));
	assert((formatOf(freeListObj)) == (wordIndexableFormat()));
	GIV(freeLists) = firstIndexableField(freeListObj);
	GIV(freeListsMask) = 0;
	for (i1 = 0, iLimiT = (64 - 1); i1 <= iLimiT; i1 += 1) {
		if ((GIV(freeLists)[i1]) != 0) {
			GIV(freeListsMask) = GIV(freeListsMask) | (1LL << i1);
			GIV(freeLists)[i1] = (swizzleObj(GIV(freeLists)[i1]));
		}
	}
	collapseSegmentsPostSwizzle();
	/* begin computeFreeSpacePostSwizzle */
	GIV(totalFreeOldSpace) = totalFreeListBytes();
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	/* begin initializeOldSpaceFirstFree: */
	limit = GIV(endOfMemory) - (2 * BaseHeaderSize);
	if (limit > GIV(freeOldSpaceStart)) {
		GIV(totalFreeOldSpace) += limit - GIV(freeOldSpaceStart);
		freeOldStart = GIV(freeOldSpaceStart);
		while ((limit - freeOldStart) >= (1LL << 32)) {
			freeChunk = freeChunkWithBytesat(1LL << 32, freeOldStart);
			freeOldStart += 1LL << 32;
			assert(freeOldStart == (addressAfter(freeChunk)));
		}

		if (freeOldStart < limit) {
			freeChunk = freeChunkWithBytesat(limit - freeOldStart, freeOldStart);
			assert((addressAfter(freeChunk)) == limit);
		}
	}
	GIV(endOfMemory) -= 2 * BaseHeaderSize;
	GIV(freeOldSpaceStart) = GIV(endOfMemory);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFreeSpace)) == (GCModeFreeSpace | GCModeFreeSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	/* begin initializeNewSpaceVariables */
	GIV(freeStart) = ((eden()).start);
	GIV(pastSpaceStart) = ((pastSpace()).start);
	GIV(scavengeThreshold) = ((((eden()).limit)) - ((((GIV(eden).limit)) - ((GIV(eden).start))) / 64)) - (interpreterAllocationReserveBytes());
	GIV(newSpaceStart) = (((((pastSpace()).start)) < (((futureSpace()).start))) ? (((pastSpace()).start)) : (((futureSpace()).start)));
	assert(GIV(newSpaceStart) < (((eden()).start)));
	/* begin initSpaceForAllocationCheck:limit: */
	aNewSpace = ((SpurNewSpaceSpace *) ((&(eden()))));
	if (!(GIV(memory) == null)) {
		if (checkAllocFiller()) {
			for (p = ((aNewSpace->start)); p < GIV(scavengeThreshold); p += BytesPerWord) {
				longAtput(p, p);
			}
		}
	}
	/* begin initializeRememberedSet */
	obj2 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)RememberedSetRootIndex) << (shiftForWord())));
	if (obj2 == GIV(nilObj)) {
		/* begin allocatePinnedSlots: */
		obj1 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(1024, (((long)(((1024 < 1) ? 1 : 1024))) << (shiftForWord())) + (BaseHeaderSize + BaseHeaderSize), sixtyFourBitIndexableFormat(), 19);
		if (!(obj1 == null)) {
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((obj1 + BaseHeaderSize) + (1024 * BytesPerOop)) - 1, addressAfter(obj1)));
			for (p1 = (((usqInt)(obj1 + BaseHeaderSize))); p1 <= (((usqInt)(((obj1 + BaseHeaderSize) + (1024 * BytesPerOop)) - 1))); p1 += 8) {
				longAtput(p1, 0);
			}
		}
		obj2 = obj1;
		/* begin rememberedSetObj: */
		assert(isOldObject(obj2));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)RememberedSetRootIndex) << (shiftForWord())), obj2);
	}
	GIV(rememberedSet) = firstIndexableField(obj2);
	GIV(rememberedSetSize) = 0;
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(obj2)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(obj2 + 7);
	GIV(rememberedSetLimit) = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(obj2 - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 1024;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
	checkSegments();

	/* These defaults should depend on machine size; e.g. too small on a powerful laptop, too big on a Pi. */
	GIV(numCompactionPasses) = CompactionPassesForGC;

	/* headroom when growing */
	GIV(growHeadroom) = (16 * 1024) * 1024;

	/* free space before shrinking */
	GIV(shrinkThreshold) = (32 * 1024) * 1024;
	/* begin setHeapSizeAtPreviousGC */
	GIV(heapSizeAtPreviousGC) = (GIV(endOfMemory) - GIV(nilObj)) - GIV(totalFreeOldSpace);
	GIV(heapGrowthToSizeGCRatio) = 0.333333;
}


/*	print free chunks in freeTree in order. */

	/* SpurMemoryManager>>#inOrderPrintFreeTree:printList: */
void
inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList)
{
    sqInt next;

	if (((next = longAt((freeChunk + BaseHeaderSize) + (3LL << (shiftForWord()))))) != 0) {
		inOrderPrintFreeTreeprintList(next, printNextList);
	}
	printFreeChunkprintAsTreeNode(freeChunk, 1);
	if (printNextList) {
		next = freeChunk;
		while (((next = longAt((next + BaseHeaderSize) + (0LL << (shiftForWord()))))) != 0) {
			/* begin tab */
			putchar('	');
			printFreeChunkprintAsTreeNode(next, 0);
		}
	}
	if (((next = longAt((freeChunk + BaseHeaderSize) + (4LL << (shiftForWord()))))) != 0) {
		inOrderPrintFreeTreeprintList(next, printNextList);
	}
}


/*	in an effort to fix a compiler bug with two-way become post r3427 */
/*	Do become in place by swapping object contents. */

	/* SpurMemoryManager>>#inPlaceBecome:and:copyHashFlag: */
static void NoDbgRegParms NeverInline
inPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt hash;
    sqLong hash1;
    sqLong hash2;
    sqInt hashTemp;
    sqLong header1;
    sqLong header2;
    sqLong headerTemp;
    sqInt i;
    sqInt iLimiT;
    sqInt o1HasYoung;
    sqInt o2HasYoung;
    sqLong remembered1;
    sqInt remembered11;
    sqLong remembered2;
    sqInt remembered21;
    sqInt temp1;
    sqInt temp2;

	assert((numSlotsOf(obj1)) == (numSlotsOf(obj2)));
	assert(((rawHashBitsOf(obj1)) == 0)
	 || ((classOrNilAtIndex(rawHashBitsOf(obj1))) != obj1));
	assert(((rawHashBitsOf(obj2)) == 0)
	 || ((classOrNilAtIndex(rawHashBitsOf(obj2))) != obj2));
	/* begin cleverSwapHeaders:and:copyHashFlag: */
	header1 = long64At(obj1);
	header2 = long64At(obj2);
	remembered1 = header1 & (1LL << (rememberedBitShift()));
	remembered2 = header2 & (1LL << (rememberedBitShift()));
	if (remembered1 != remembered2) {
		header1 = (header1 - remembered1) + remembered2;
		header2 = (header2 - remembered2) + remembered1;
	}
	if (!copyHashFlag) {
		hash1 = header1 & 0x3FFFFF00000000ULL;
		hash2 = header2 & 0x3FFFFF00000000ULL;
		if (hash1 != hash2) {
			header1 = (header1 - hash1) + hash2;
			header2 = (header2 - hash2) + hash1;
		}
	}
	long64Atput(obj1, header2);
	long64Atput(obj2, header1);

	o1HasYoung = (o2HasYoung = 0);
	for (i = 0, iLimiT = ((numSlotsOf(obj1)) - 1); i <= iLimiT; i += 1) {
		temp1 = longAt((obj1 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		temp2 = longAt((obj2 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(obj1)));
		longAtput((obj1 + BaseHeaderSize) + (((long)i) << (shiftForWord())), temp2);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(obj2)));
		longAtput((obj2 + BaseHeaderSize) + (((long)i) << (shiftForWord())), temp1);
		if (((temp2 & (tagMask())) == 0)
		 && (oopisLessThan(temp2, GIV(newSpaceLimit)))) {
			o1HasYoung = 1;
		}
		if (((temp1 & (tagMask())) == 0)
		 && (oopisLessThan(temp1, GIV(newSpaceLimit)))) {
			o2HasYoung = 1;
		}
	}
	if (o1HasYoung
	 && (isOldObject(obj1))) {
		fmt = (((usqInt) (longAt(obj1))) >> (formatShift())) & (formatMask());
		if (!((fmt >= (sixtyFourBitIndexableFormat()))
			 && (fmt < (firstCompiledMethodFormat())))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(obj1))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(obj1);
			}
		}
	}
	if (o2HasYoung
	 && (isOldObject(obj2))) {
		fmt = (((usqInt) (longAt(obj2))) >> (formatShift())) & (formatMask());
		if (!((fmt >= (sixtyFourBitIndexableFormat()))
			 && (fmt < (firstCompiledMethodFormat())))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(obj2))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(obj2);
			}
		}
	}
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

	/* SpurMemoryManager>>#instanceSizeOf: */
sqInt
instanceSizeOf(sqInt classObj)
{
	assert(addressCouldBeClassObj(classObj));
	return (((longAt((classObj + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
}

	/* SpurMemoryManager>>#instSpecOfClassFormat: */
static sqInt NoDbgRegParms
instSpecOfClassFormat(sqInt classFormat)
{
	return (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
}


/*	This field in a class's format inst var corresponds to the 5-bit format
	field stored in every object header
 */

	/* SpurMemoryManager>>#instSpecOfClass: */
static sqInt NoDbgRegParms
instSpecOfClass(sqInt classPointer)
{
	/* begin instSpecOfClassFormat: */
	return (((usqInt) (((longAt((classPointer + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3))) >> (fixedFieldsFieldWidth())) & (formatMask());
}


/*	the inverse of isPureBitsFormat: */

	/* SpurMemoryManager>>#isAnyPointerFormat: */
static sqInt NoDbgRegParms
isAnyPointerFormat(sqInt format)
{
	return (format <= 5)
	 || (format >= (firstCompiledMethodFormat()));
}


/*	Answer if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArrayNonImm: */
sqInt
isArrayNonImm(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) == 2;
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArray: */
sqInt
isArray(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) == 2);
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

	/* SpurMemoryManager>>#isBytes: */
sqInt
isBytes(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()));
}

	/* SpurMemoryManager>>#isCharacterObject: */
sqInt
isCharacterObject(sqInt oop)
{
	return (oop & (tagMask())) == 2;
}

	/* SpurMemoryManager>>#isCharacterValue: */
sqInt
isCharacterValue(sqInt anInteger)
{
	return ((anInteger >= 0) && (anInteger <= ((1LL << 30) - 1)));
}


/*	Answer if aClass exists at only one index in the class table. Be careful
	not to
	be misled by classes that have puns, such as Array. */

	/* SpurMemoryManager>>#isClassAtUniqueIndex: */
static sqInt NoDbgRegParms
isClassAtUniqueIndex(sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt entry;
    sqInt expectedIndex;
    sqInt i;
    sqInt index;
    sqInt j;
    sqInt jLimiT;
    sqInt page;

	expectedIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask());
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		for (j = 0, jLimiT = ((1LL << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
			classOrNil = longAt((page + BaseHeaderSize) + (((long)j) << (shiftForWord())));
			if (classOrNil != GIV(nilObj)) {
				index = (((long)i) << (classTableMajorIndexShift())) + j;
				if ((classOrNil == aClass)
				 && ((index != expectedIndex)
				 && (index > 0x1F))) {
					return 0;
				}

			}
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#isCompiledMethodFormat: */
static sqInt NoDbgRegParms
isCompiledMethodFormat(sqInt format)
{
	return format >= (firstCompiledMethodFormat());
}


/*	Answer whether the argument object is of compiled method format */

	/* SpurMemoryManager>>#isCompiledMethod: */
sqInt
isCompiledMethod(sqInt objOop)
{
	return ((((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat());
}

	/* SpurMemoryManager>>#isContextHeader: */
static sqInt NoDbgRegParms
isContextHeader(sqInt aHeader)
{
	return (aHeader & (classIndexMask())) == ClassMethodContextCompactIndex;
}

	/* SpurMemoryManager>>#isContextNonImm: */
static sqInt NoDbgRegParms
isContextNonImm(sqInt oop)
{
	return ((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex;
}

	/* SpurMemoryManager>>#isContext: */
static sqInt NoDbgRegParms
isContext(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex);
}

	/* SpurMemoryManager>>#isEmptyObjStack: */
static sqInt NoDbgRegParms
isEmptyObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (objStack == GIV(nilObj)) {
		return 1;
	}
	eassert(isValidObjStack(objStack));
	return (0 == (longAt((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())))))
	 && (0 == (longAt((objStack + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())))));
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	This is for assert-checking only. */

	/* SpurMemoryManager>>#isEnumerableObjectNoAssert: */
static sqInt NoDbgRegParms
isEnumerableObjectNoAssert(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	classIndex = (longAt(objOop)) & (classIndexMask());
	return (classIndex >= (isForwardedObjectClassIndexPun()))
	 && (classIndex < (GIV(numClassTablePages) * (1LL << (classTableMajorIndexShift()))));
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	Non-objects should be excluded; these are bridges and free chunks. */

	/* SpurMemoryManager>>#isEnumerableObject: */
static sqInt NoDbgRegParms
isEnumerableObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	classIndex = (longAt(objOop)) & (classIndexMask());
	assert(((long64At(objOop)) != 0)
	 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))));
	return classIndex >= (isForwardedObjectClassIndexPun());
}

	/* SpurMemoryManager>>#isEphemeron: */
static sqInt NoDbgRegParms
isEphemeron(sqInt objOop)
{
    sqInt format;

	assert(isNonImmediate(objOop));
	/* begin isEphemeronFormat: */
	format = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	return format == 5;
}

	/* SpurMemoryManager>>#isFixedSizePointerFormat: */
static sqInt NoDbgRegParms
isFixedSizePointerFormat(sqInt format)
{
	return (format <= 1)
	 || (format == 5);
}

	/* SpurMemoryManager>>#isForwardedClassTag: */
static sqInt NoDbgRegParms
isForwardedClassTag(sqInt classIndex)
{
	return classIndex == (isForwardedObjectClassIndexPun());
}


/*	Answer if objOop is that if a forwarder. Take advantage of
	isForwardedObjectClassIndexPun being a power of two to generate a more
	efficient test than the straight-forward
	(self classIndexOf: objOop) = self isForwardedObjectClassIndexPun
	at the cost of this being ambiguous with free chunks. So either never
	apply this to free chunks
	or guard with (self isFreeObject: foo) not. So far the idiom has been to
	guard with isFreeObject: */
/*	self assert: (self isFreeObject: objOop) not. */

	/* SpurMemoryManager>>#isForwarded: */
sqInt
isForwarded(sqInt objOop)
{
	return ((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0;
}

	/* SpurMemoryManager>>#isFreeObject: */
static sqInt NoDbgRegParms
isFreeObject(sqInt objOop)
{
	return ((longAt(objOop)) & (classIndexMask())) == 0;
}

	/* SpurMemoryManager>>#isImmediate: */
sqInt
isImmediate(sqInt oop)
{
	return (oop & (tagMask())) != 0;
}

	/* SpurMemoryManager>>#isInClassTable: */
static sqInt NoDbgRegParms
isInClassTable(sqInt objOop)
{
    sqInt hash;

	hash = (long32At(objOop + 4)) & (identityHashHalfWordMask());
	return (hash != 0)
	 && ((classAtIndex(hash)) == objOop);
}

	/* SpurMemoryManager>>#isIndexable: */
sqInt
isIndexable(sqInt objOop)
{
    sqInt fmt;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	return (fmt >= 2)
	 && ((fmt <= (weakArrayFormat()))
	 || (fmt >= (sixtyFourBitIndexableFormat())));
}

	/* SpurMemoryManager>>#isInEden: */
static sqInt NoDbgRegParms
isInEden(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(objOop, ((eden()).start), GIV(freeStart));
}

	/* SpurMemoryManager>>#isInFutureSpace: */
static sqInt NoDbgRegParms
isInFutureSpace(sqInt address)
{
	return oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace()).start), futureSurvivorStart());
}


/*	Answer if the given address is in ST object memory. */

	/* SpurMemoryManager>>#isInMemory: */
sqInt
isInMemory(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	if ((oopisLessThan(address, GIV(newSpaceLimit)))
	 && (oopisGreaterThanOrEqualTo(address, GIV(newSpaceStart)))) {
		return (oopisGreaterThanOrEqualToandLessThan(address, ((eden()).start), GIV(freeStart)))
		 || ((oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace()).start), GIV(pastSpaceStart)))
		 || (GIV(scavengeInProgress)
		 && (oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace()).start), futureSurvivorStart()))));
	}
	/* begin isInSegments: */
	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < ((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart)))) {
			return 1;
		}
	}
	return 0;
}

	/* SpurMemoryManager>>#isInNewSpace: */
static sqInt NoDbgRegParms
isInNewSpace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisLessThan(objOop, GIV(newSpaceLimit)))
	 && (oopisGreaterThanOrEqualTo(objOop, GIV(newSpaceStart)));
}

	/* SpurMemoryManager>>#isInOldSpace: */
sqInt
isInOldSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, GIV(oldSpaceStart), GIV(endOfMemory));
}

	/* SpurMemoryManager>>#isInPastSpace: */
static sqInt NoDbgRegParms
isInPastSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace()).start), GIV(pastSpaceStart));
}

	/* SpurMemoryManager>>#isNonImmediate: */
sqInt
isNonImmediate(sqInt oop)
{
	return (oop & (tagMask())) == 0;
}

	/* SpurMemoryManager>>#isObjImmutable: */
static sqInt NoDbgRegParms
isObjImmutable(sqInt anOop)
{
	return 
#  if IMMUTABILITY
		((((usqInt) (longAt(anOop))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		;
}


/*	Answer if obj is old. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isOldObject: */
sqInt
isOldObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart));
}


/*	Answer whether the oop is an object of compiled method format */

	/* SpurMemoryManager>>#isOopCompiledMethod: */
sqInt
isOopCompiledMethod(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()));
}

	/* SpurMemoryManager>>#isOopForwarded: */
sqInt
isOopForwarded(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()));
}

	/* SpurMemoryManager>>#isOopImmutable: */
sqInt
isOopImmutable(sqInt oop)
{
	return ((oop & (tagMask())) != 0)
	 || (((((usqInt) (longAt(oop))) >> 23) & 1) != 0);
}

	/* SpurMemoryManager>>#isOopMutable: */
sqInt
isOopMutable(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (!(((((usqInt) (longAt(oop))) >> 23) & 1) != 0));
}


/*	Answers 0 if the oop can be become.
	Answers an error code in the other case */

	/* SpurMemoryManager>>#isOopValidBecome: */
static sqInt NoDbgRegParms
isOopValidBecome(sqInt oop)
{
	if ((oop & (tagMask())) != 0) {
		return PrimErrInappropriate;
	}
	if (((((usqInt) (longAt(oop))) >> 30) & 1) != 0) {
		return PrimErrObjectIsPinned;
	}
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(oop))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		return PrimErrNoModification;
	}
	return 0;
}

	/* SpurMemoryManager>>#isPinned: */
sqInt
isPinned(sqInt objOop)
{
	return ((((usqInt) (longAt(objOop))) >> 30) & 1) != 0;
}


/*	Answer if the argument has only fields that can hold oops. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isPointers: */
sqInt
isPointers(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) <= 5);
}


/*	the inverse of isAnyPointerFormat: */

	/* SpurMemoryManager>>#isPureBitsFormat: */
static sqInt NoDbgRegParms
isPureBitsFormat(sqInt format)
{
	return (format >= (sixtyFourBitIndexableFormat()))
	 && (format < (firstCompiledMethodFormat()));
}


/*	Answer if obj is young. This for compatibility with SqueakV3 where
	the GC makes all objects young during full GC. Spur doesn't do so. */

	/* SpurMemoryManager>>#isReallyYoungObject: */
sqInt
isReallyYoungObject(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin isYoungObject: */
	assert(isNonImmediate(obj));
	return oopisLessThan(obj, GIV(newSpaceLimit));
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isReallyYoung: */
sqInt
isReallyYoung(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (isYoungObject(oop));
}

	/* SpurMemoryManager>>#isRemembered: */
static sqInt NoDbgRegParms
isRemembered(sqInt objOop)
{
	return ((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0;
}


/*	Maybe this should be in SpurSegmentManager only */

	/* SpurMemoryManager>>#isSegmentBridge: */
static sqInt NoDbgRegParms
isSegmentBridge(sqInt objOop)
{
	return ((longAt(objOop)) & (classIndexMask())) == 3;
}


/*	This version is private to SpurMemoryManager (for asserts, etc). It does
	not take advantage of the power-of0two optimization in isForwarded:. */

	/* SpurMemoryManager>>#isUnambiguouslyForwarder: */
sqInt
isUnambiguouslyForwarder(sqInt objOop)
{
	return ((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun());
}

	/* SpurMemoryManager>>#isValidClassTag: */
sqInt
isValidClassTag(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert(((classIndex >= 0) && (classIndex <= ((1LL << (classIndexFieldWidth())) - 1))));
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift());
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (classTablePage == GIV(nilObj)) {
		classOrNil = GIV(nilObj);
		goto l1;
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1LL << (classTableMajorIndexShift())) - 1);
	classOrNil = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
l1:	/* end classOrNilAtIndex: */;
	return (classOrNil != GIV(nilObj))
	 && (((long32At(classOrNil + 4)) & (identityHashHalfWordMask())) == classIndex);
}

	/* SpurMemoryManager>>#isValidFreeObject: */
static sqInt NoDbgRegParms
isValidFreeObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;

	return (((objOop & (BaseHeaderSize - 1)) == 0)
	 && (oopisGreaterThanOrEqualToandLessThan(objOop, GIV(oldSpaceStart), GIV(endOfMemory))))
	 && ((((longAt(objOop)) & (classIndexMask())) == 0)
	 && ((oopisLessThanOrEqualTo(addressAfter(objOop), GIV(endOfMemory)))
	 && (((((chunk = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord()))))) == 0)
	 || (((chunk & (tagMask())) == 0)
	 && (((longAt(chunk)) & (classIndexMask())) == 0)))
	 && ((!((bytesInObject(objOop)) >= (64 * 8)))
	 || (((((chunk = longAt((objOop + BaseHeaderSize) + (2LL << (shiftForWord()))))) == 0)
	 || ((((chunk & (tagMask())) == 0)
	 && (((longAt(chunk)) & (classIndexMask())) == 0))
	 && ((bytesInObject(chunk)) >= (64 * 8))))
	 && (((((chunk = longAt((objOop + BaseHeaderSize) + (3LL << (shiftForWord()))))) == 0)
	 || ((((chunk & (tagMask())) == 0)
	 && (((longAt(chunk)) & (classIndexMask())) == 0))
	 && ((bytesInObject(chunk)) >= (64 * 8))))
	 && ((((chunk = longAt((objOop + BaseHeaderSize) + (4LL << (shiftForWord()))))) == 0)
	 || ((((chunk & (tagMask())) == 0)
	 && (((longAt(chunk)) & (classIndexMask())) == 0))
	 && ((bytesInObject(chunk)) >= (64 * 8))))))))));
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackAt: */
static sqInt NoDbgRegParms
isValidObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stackOrNil;

	stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)objStackRootIndex) << (shiftForWord())));
	return (stackOrNil == GIV(nilObj))
	 || (isValidObjStackPagemyIndexfirstPage(stackOrNil, objStackRootIndex, 1));
}


/*	Just check the page itself. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex: */
static sqInt NoDbgRegParms
isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(((longAt(objStackPage)) & (classIndexMask())) == 19)) {
		GIV(objStackInvalidBecause) = "wrong class index";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(((((usqInt) (longAt(objStackPage))) >> (formatShift())) & (formatMask())) == (sixtyFourBitIndexableFormat()))) {
		GIV(objStackInvalidBecause) = "wrong format";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!((numSlotsOfAny(objStackPage)) == ObjStackPageSlots)) {
		GIV(objStackInvalidBecause) = "wrong num slots";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(myx == (longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackMyx) << (shiftForWord())))))) {
		GIV(objStackInvalidBecause) = "wrong myx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (GIV(marking)
	 && (!(((((usqInt) (longAt(objStackPage))) >> 55) & 1) != 0))) {
		GIV(objStackInvalidBecause) = "marking but page is unmarked";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return 1;
}


/*	Answer if the obj stack at stackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex:firstPage: */
static sqInt NoDbgRegParms
isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNextPage;
    sqInt index;
    char *ns;
    sqInt page;

	if (!(isValidObjStackPagemyIndex(objStackPage, myx))) {
		return 0;
	}
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())));
	while (freeOrNextPage != 0) {
		if (!isFirstPage) {
			GIV(objStackInvalidBecause) = "free page on other than first page";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (freeOrNextPage == (longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord()))))) {
			GIV(objStackInvalidBecause) = "free page = next page";
			GIV(invalidObjStackPage) = freeOrNextPage;
			return 0;
		}
		if (!(isValidObjStackPagemyIndex(freeOrNextPage, myx))) {
			ns = malloc(((strlen(GIV(objStackInvalidBecause))) + (strlen(", on next page"))) + 2);
			strcpy(ns, GIV(objStackInvalidBecause));
			GIV(objStackInvalidBecause) = strcat(ns, ", on next page");

			return 0;
		}
		page = longAt((freeOrNextPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())));
		if ((page == freeOrNextPage)
		 || (page == objStackPage)) {
			GIV(objStackInvalidBecause) = "circularity in free page list";
			GIV(invalidObjStackPage) = page;
			return 0;
		}
		freeOrNextPage = page;
	}
	if (isFirstPage) {
		if (!(((myx >= (1LL << (22 - (classTableMajorIndexShift())))) && (myx <= (((1LL << (22 - (classTableMajorIndexShift()))) + 8) - 1))))) {
			GIV(objStackInvalidBecause) = "myx out of range";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (!((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)myx) << (shiftForWord())))) == objStackPage)) {
			GIV(objStackInvalidBecause) = "firstPage is not root";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
	}
	index = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
	if (!(((index >= 0) && (index <= ObjStackLimit)))) {
		GIV(objStackInvalidBecause) = "bad topx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
	if (freeOrNextPage == 0) {
		return 1;
	}
	if (freeOrNextPage == objStackPage) {
		GIV(objStackInvalidBecause) = "circularity in objStack page list";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(freeOrNextPage, myx, 0);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStack: */
static sqInt NoDbgRegParms
isValidObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((addressCouldBeObj(objStack))
		 && ((numSlotsOfAny(objStack)) == ObjStackPageSlots))) {
		GIV(objStackInvalidBecause) = "first page not obj or wrong size";
		GIV(invalidObjStackPage) = objStack;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(objStack, longAt((objStack + BaseHeaderSize) + (((long)ObjStackMyx) << (shiftForWord()))), 1);
}

	/* SpurMemoryManager>>#isWeakFormat: */
static sqInt NoDbgRegParms
isWeakFormat(sqInt format)
{
	return format == (weakArrayFormat());
}

	/* SpurMemoryManager>>#isWeakNonImm: */
static sqInt NoDbgRegParms
isWeakNonImm(sqInt objOop)
{
    sqInt format;

	/* begin isWeakFormat: */
	format = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	return format == (weakArrayFormat());
}


/*	Answer if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWeak: */
sqInt
isWeak(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (isWeakFormat((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* SpurMemoryManager>>#isWordsOrBytes: */
sqInt
isWordsOrBytes(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWords: */
sqInt
isWords(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && (((((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1))));
}


/*	Answer if obj is young. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isYoungObject: */
sqInt
isYoungObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return oopisLessThan(objOop, GIV(newSpaceLimit));
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isYoung: */
sqInt
isYoung(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((oop & (tagMask())) == 0)
	 && (oopisLessThan(oop, GIV(newSpaceLimit)));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if oop's compact class index
	and compactClassIndex are non-zero. */

	/* SpurMemoryManager>>#is:instanceOf:compactClassIndex: */
static sqInt NoDbgRegParms
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{
    sqInt ccIndex;

	if ((oop & (tagMask())) != 0) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	if (compactClassIndex != 0) {
		return compactClassIndex == ccIndex;
	}
	else {
		return classOop == (classAtIndex(ccIndex));
	}
}

	/* SpurMemoryManager>>#is:onObjStack: */
static sqInt NoDbgRegParms
isonObjStack(sqInt oop, sqInt objStack)
{
    sqInt index;
    sqInt nextPage;

	assert((numSlotsOfAny(objStack)) == ObjStackPageSlots);
	index = (longAt((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())))) + ObjStackNextx;
	while (index >= ObjStackFixedSlots) {
		if (oop == (longAt((objStack + BaseHeaderSize) + (((long)index) << (shiftForWord()))))) {
			return 1;
		}
		index -= 1;
	}
	nextPage = longAt((objStack + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
	if (nextPage != 0) {
		if (isonObjStack(oop, nextPage)) {
			return 1;
		}
	}
	return 0;
}


/*	Answer the object the ephemeron guards. This is its first element. */

	/* SpurMemoryManager>>#keyOfEphemeron: */
static sqInt NoDbgRegParms
keyOfEphemeron(sqInt objOop)
{
	assert((isNonImmediate(objOop))
	 && (isEphemeron(objOop)));
	return longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
}

	/* SpurMemoryManager>>#knownClassAtIndex: */
static sqInt NoDbgRegParms
knownClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(((classIndex >= 1) && (classIndex <= (classTablePageSize()))));
	return longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)classIndex) << (shiftForWord())));
}


/*	Class puns are class indices not used by any class. There is an entry
	for the pun that refers to the notional class of objects with this class
	index. But because the index doesn't match the class it won't show up
	in allInstances, hence hiding the object with a pun as its class index.
	The puns occupy indices 16 through 31. */

	/* SpurMemoryManager>>#lastClassIndexPun */
static sqInt
lastClassIndexPun(void)
{
	return 0x1F;
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects.
	Does not examine the stack pointer of contexts to be sure to swizzle
	the nils that fill contexts on snapshot.
	It is invariant that on image load no object contains a forwarding
	pointer, and the image contains no forwarders (see class comment). */

	/* SpurMemoryManager>>#lastPointerOfWhileSwizzling: */
sqInt
lastPointerOfWhileSwizzling(sqInt objOop)
{
    sqInt fmt;
    sqInt header;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	assert(fmt != (forwardedFormat()));
	if (fmt <= 5) {
		return (((numSlotsOf(objOop)) - 1) * BytesPerOop) + BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header = longAt((objOop + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	return ((((literalCountOfMethodHeader(header)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#lastPointerOf: */
sqInt
lastPointerOf(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	assert(fmt != (forwardedFormat()));
	if (fmt <= 5) {
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
			contextSize = (sp >> 3);
		l1:	/* end fetchStackPointerOf: */;
			return (((CtxtTempFrameStart - 1) + contextSize) * BytesPerOop) + BaseHeaderSize;
		}
		return (((numSlotsOf(objOop)) - 1) * BytesPerOop) + BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header = longAt((objOop + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	return ((((literalCountOfMethodHeader(header)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}

	/* SpurMemoryManager>>#leakCheckBecome */
sqInt
leakCheckBecome(void)
{
	return (checkForLeaks & GCModeBecome) != 0;
}

	/* SpurMemoryManager>>#leakCheckFullGC */
sqInt
leakCheckFullGC(void)
{
	return (checkForLeaks & GCModeFull) != 0;
}

	/* SpurMemoryManager>>#leakCheckIncremental */
sqInt
leakCheckIncremental(void)
{
	return (checkForLeaks & GCModeIncremental) != 0;
}

	/* SpurMemoryManager>>#leakCheckNewSpaceGC */
sqInt
leakCheckNewSpaceGC(void)
{
	return (checkForLeaks & GCModeNewSpace) != 0;
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* SpurMemoryManager>>#lengthOfMaybeImmediate: */
static sqInt NoDbgRegParms
lengthOfMaybeImmediate(sqInt oop)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	if ((oop & (tagMask())) != 0) {
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (((long)numSlots) << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes) should
	be subtracted from the result. */

	/* SpurMemoryManager>>#lengthOf: */
sqInt
lengthOf(sqInt objOop)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (((long)numSlots) << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}

	/* SpurMemoryManager>>#literalCountOfMethodHeader: */
sqInt
literalCountOfMethodHeader(sqInt header)
{
	assert((((header) & 7) == 1));
	return ((header >> 3)) & AlternateHeaderNumLiteralsMask;
}

	/* SpurMemoryManager>>#literalCountOf: */
sqInt
literalCountOf(sqInt methodPointer)
{
    sqInt header;

	/* begin literalCountOfMethodHeader: */
	assert(isCompiledMethod(methodPointer));
	header = longAt((methodPointer + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	assert((((header) & 7) == 1));
	return ((header >> 3)) & AlternateHeaderNumLiteralsMask;
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed.
	It will return as its value the original array of roots, and the
	segmentWordArray will become an
	array of the loaded objects. If this primitive should fail, the
	segmentWordArray will, sadly, have
	been reduced to an unrecognizable and unusable jumble. But what more could
	you have done
	with it anyway? */

	/* SpurMemoryManager>>#loadImageSegmentFrom:outPointers: */
static sqInt NoDbgRegParms
loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex11;
    sqInt classIndex2;
    sqInt classOop;
    sqInt classRef;
    sqInt errorCode;
    sqInt errorCode1;
    sqInt fillIdx;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt followingWordAddress3;
    sqInt hash;
    sqInt i;
    sqInt iLimiT;
    sqInt loadedObjectsArray;
    sqInt mappedOop;
    usqInt newObj;
    usqInt numBytes;
    sqInt numLoadedObjects;
    usqInt numOutPointers;
    sqInt numSegObjs;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots111;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots14;
    usqInt numSlots15;
    usqInt numSlots16;
    usqInt numSlots2;
    usqInt numSlots21;
    usqInt numSlots22;
    usqInt numSlots3;
    usqInt numSlots4;
    usqInt numSlots5;
    usqInt numSlots6;
    usqInt numSlots7;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oldClone;
    sqInt oop;
    sqInt oop1;
    usqInt segmentLimit;
    sqInt segmentStart;
    sqInt segVersion;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;
    sqInt slotBytes3;
    sqInt slotBytes4;
    sqInt slotBytes5;
    sqInt stopAddr;
    sqInt stopAddr1;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(segmentWordArray)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(segmentWordArray + 7);
	segmentLimit = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(segmentWordArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	if (((((long)(((segmentLimit < 1) ? 1 : segmentLimit))) << (shiftForWord())) + ((segmentLimit >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))) < (8 + BaseHeaderSize)) {

		/* version info */
		/* one object header */
		return PrimErrBadArgument;
	}
	segVersion = longAt(segmentWordArray + BaseHeaderSize);
	if (!(((segVersion & 0xFFFFFF) == (imageFormatVersion()))
		 || (0))) {

		/* low 3 bytes */
		/* begin reverseBytesIn32BitWordsFrom:to: */
		numSlots12 = byteAt(segmentWordArray + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(segmentWordArray - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		stopAddr1 = (segmentWordArray + BaseHeaderSize) + slotBytes1;
		addr1 = segmentWordArray + BaseHeaderSize;
		while (oopisLessThan(addr1, stopAddr1)) {
			long32Atput(addr1, ((((((usqInt) (long32At(addr1)) >> 24)) & Byte0Mask) + ((((usqInt) (long32At(addr1)) >> 8)) & Byte1Mask)) + ((((usqInt) (long32At(addr1)) << 8)) & Byte2Mask)) + ((((usqInt) (long32At(addr1)) << 24)) & Byte3Mask));
			addr1 += 4;
		}
		segVersion = longAt(segmentWordArray + BaseHeaderSize);
		if (!(((segVersion & 0xFFFFFF) == (imageFormatVersion()))
			 || (0))) {

			/* low 3 bytes */
			/* begin reverseBytesIn32BitWordsFrom:to: */
			numSlots11 = byteAt(segmentWordArray + 7);
			numSlots2 = (numSlots11 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(segmentWordArray - BaseHeaderSize))) << 8)))) >> 8
				: numSlots11);
			if (numSlots2 == 0) {
				slotBytes = 8;
			}
			else {
				slotBytes = ((long)numSlots2) << (shiftForWord());
			}
			stopAddr = (segmentWordArray + BaseHeaderSize) + slotBytes;
			addr = segmentWordArray + BaseHeaderSize;
			while (oopisLessThan(addr, stopAddr)) {
				long32Atput(addr, ((((((usqInt) (long32At(addr)) >> 24)) & Byte0Mask) + ((((usqInt) (long32At(addr)) >> 8)) & Byte1Mask)) + ((((usqInt) (long32At(addr)) << 8)) & Byte2Mask)) + ((((usqInt) (long32At(addr)) << 24)) & Byte3Mask));
				addr += 4;
			}
			return PrimErrBadArgument;
		}
	}
	segmentStart = (segmentWordArray + BaseHeaderSize) + 8;

	/* Notionally reverse the Byte type objects if the data is from opposite endian machine.
	   Test top byte.  $d on the Mac or $s on the PC.  Rest of word is equal.  If Spur is ever
	   ported to big-endian machines then the segment may have to be byte/word swapped,
	   but so far it only runs on little-endian machines, so for now just fail if endinanness is wrong. */
	segmentLimit = ((segmentLimit * BytesPerOop) + segmentWordArray) + BaseHeaderSize;
	flag("endianness");
	if (((((usqInt) segVersion) >> 24) & 0xFF) != ((((usqInt) (imageSegmentVersion())) >> 24) & 0xFF)) {

		/* Reverse the byte-type objects once */
		return PrimErrBadArgument;

	}
	/* begin mapOopsAndValidateClassRefsFrom:to:outPointers: */
	flag("endianness");
	assert((classIndexOf(outPointerArray)) > (isForwardedObjectClassIndexPun()));
	numSlots6 = byteAt(outPointerArray + 7);
	numOutPointers = (numSlots6 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(outPointerArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots6);
	numSegObjs = 0;
	/* begin objectStartingAt: */
	numSlots15 = byteAt(segmentStart + 7);
	objOop1 = (numSlots15 == (numSlotsMask())
		? segmentStart + BaseHeaderSize
		: segmentStart);
	while (objOop1 < segmentLimit) {
		numSegObjs += 1;
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			errorCode = PrimErrInappropriate;
			goto l6;
		}

		/* validate the class ref, but don't update it until any internal classes have been added to the class table. */
		classIndex1 = ((longAt(objOop1)) & (classIndexMask())) - 16;
		if (classIndex1 & TopHashBit) {
			if ((classIndex1 - TopHashBit) >= numOutPointers) {
				errorCode = PrimErrBadIndex;
				goto l6;
			}
			mappedOop = longAt((outPointerArray + BaseHeaderSize) + (((long)(classIndex1 - TopHashBit)) << (shiftForWord())));
			hash = (long32At(mappedOop + 4)) & (identityHashHalfWordMask());
			if (!((hash > 0x1F)
				 && ((classOrNilAtIndex(hash)) == mappedOop))) {
				errorCode = PrimErrInappropriate;
				goto l6;
			}
		}
		else {

			/* The class is contained within the segment. */
			if (((oop1 = (classIndex1 * 8) + segmentStart)) >= segmentLimit) {
				errorCode = PrimErrBadIndex;
				goto l6;
			}
			if (((long32At(oop1 + 4)) & (identityHashHalfWordMask())) != 0) {
				errorCode = PrimErrInappropriate;
				goto l6;
			}
		}
		for (i = 0, iLimiT = ((numPointerSlotsOf(objOop1)) - 1); i <= iLimiT; i += 1) {
			oop1 = longAt((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord())));
			if ((oop1 & (tagMask())) == 0) {
				if (oop1 & TopOopBit) {
					if (((oop1 = (oop1 - TopOopBit) / BytesPerOop)) >= numOutPointers) {
						errorCode = PrimErrBadIndex;
						goto l6;
					}
					mappedOop = longAt((outPointerArray + BaseHeaderSize) + (((long)oop1) << (shiftForWord())));
				}
				else {
					if ((oop1 & (8 - 1)) != 0) {
						errorCode = PrimErrInappropriate;
						goto l6;
					}
					if (((mappedOop = oop1 + segmentStart)) >= segmentLimit) {
						errorCode = PrimErrBadIndex;
						goto l6;
					}
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord())), mappedOop);
			}
		}
		/* begin objectAfter:limit: */
		numSlots111 = byteAt(objOop1 + 7);
		numSlots21 = (numSlots111 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots111);
		if (numSlots21 == 0) {
			slotBytes4 = 8;
		}
		else {
			slotBytes4 = ((long)numSlots21) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes4;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, segmentLimit)) {
			objOop1 = segmentLimit;
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	errorCode = -numSegObjs;
l6:	/* end mapOopsAndValidateClassRefsFrom:to:outPointers: */;
	if (errorCode > 0) {
		return errorCode;
	}
	numLoadedObjects = -errorCode;
	/* begin allocateSlots:format:classIndex: */
	if (numLoadedObjects >= (numSlotsMask())) {
		if ((((usqInt) numLoadedObjects) >> 56) > 0) {
			loadedObjectsArray = null;
			goto l4;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numLoadedObjects * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numLoadedObjects < 1
	? 8
	: numLoadedObjects * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		loadedObjectsArray = allocateSlotsInOldSpacebytesformatclassIndex(numLoadedObjects, numBytes, 2, ClassArrayCompactIndex);
		goto l4;
	}
	if (numLoadedObjects >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numLoadedObjects);
		longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), 2, ClassArrayCompactIndex));
	}
	else {
		longAtput(newObj, ((((long)(((usqLong) numLoadedObjects))) << (numSlotsFullShift())) + (2LL << (formatShift()))) + ClassArrayCompactIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	loadedObjectsArray = newObj;
l4:	/* end allocateSlots:format:classIndex: */;
	if (!(loadedObjectsArray)) {
		return PrimErrNoMemory;
	}
	/* begin enterClassesIntoClassTableFrom:to: */
	objOop = objectAfter(objectStartingAt(segmentStart));
	while ((objOop < segmentLimit)
	 && (((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0)) {
		/* begin setIsRememberedOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(1LL << (rememberedBitShift()))));
		if (((errorCode1 = enterIntoClassTable(objOop))) != 0) {
			oop = objOop;
			objOop = objectAfter(objectStartingAt(segmentStart));
			while (objOop < oop) {
				expungeFromClassTable(objOop);
				/* begin objectAfter:limit: */
				numSlots13 = byteAt(objOop + 7);
				numSlots4 = (numSlots13 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
					: numSlots13);
				if (numSlots4 == 0) {
					slotBytes2 = 8;
				}
				else {
					slotBytes2 = ((long)numSlots4) << (shiftForWord());
				}
				followingWordAddress = (objOop + BaseHeaderSize) + slotBytes2;
				if (oopisGreaterThanOrEqualTo(followingWordAddress, segmentLimit)) {
					objOop = segmentLimit;
					goto l1;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
			l1:	/* end objectAfter:limit: */;
			}
			errorCode = errorCode1;
			goto l3;
		}
		/* begin objectAfter:limit: */
		numSlots14 = byteAt(objOop + 7);
		numSlots5 = (numSlots14 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots14);
		if (numSlots5 == 0) {
			slotBytes3 = 8;
		}
		else {
			slotBytes3 = ((long)numSlots5) << (shiftForWord());
		}
		followingWordAddress1 = (objOop + BaseHeaderSize) + slotBytes3;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, segmentLimit)) {
			objOop = segmentLimit;
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	errorCode = 0;
l3:	/* end enterClassesIntoClassTableFrom:to: */;
	if (errorCode != 0) {
		return errorCode;
	}
	/* begin assignClassIndicesAndPinFrom:to:outPointers:filling: */
	numSlots7 = byteAt(segmentStart + 7);
	objOop2 = (numSlots7 == (numSlotsMask())
		? segmentStart + BaseHeaderSize
		: segmentStart);
	fillIdx = 0;
	while (objOop2 < segmentLimit) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(loadedObjectsArray)));
		longAtput((loadedObjectsArray + BaseHeaderSize) + (((long)fillIdx) << (shiftForWord())), objOop2);

		/* In the segment, class indices are offset indexes into the segment data,
		   or into outPointers.  See mapOopsFrom:to:outPointers:outHashes:. */
		fillIdx += 1;
		classRef = ((longAt(objOop2)) & (classIndexMask())) - 16;
		if (classRef & TopHashBit) {
			classOop = longAt((outPointerArray + BaseHeaderSize) + (((long)(classRef - TopHashBit)) << (shiftForWord())));
		}
		else {
			classOop = (classRef * 8) + segmentStart;
		}
		classIndex2 = (long32At(classOop + 4)) & (identityHashHalfWordMask());
		assert((classIndex2 > (lastClassIndexPun()))
		 && ((classOrNilAtIndex(classIndex2)) == classOop));
		/* begin setClassIndexOf:to: */
		assert(((classIndex2 >= 0) && (classIndex2 <= (classIndexMask()))));
		longAtput(objOop2, ((longAt(objOop2)) & (~(classIndexMask()))) + classIndex2);
		if (((oopisLessThan(objOop2, GIV(newSpaceLimit)))
		 && (oopisGreaterThanOrEqualTo(objOop2, GIV(newSpaceStart))))
		 && (((((usqInt) (longAt(objOop2))) >> 30) & 1) != 0)) {
			oldClone = cloneInOldSpaceForPinning(objOop2);
			if (oldClone != 0) {
				/* begin setIsPinnedOf:to: */
				longAtput(oldClone, (longAt(oldClone)) | (1LL << 30));
				/* begin forward:to: */
				classIndex11 = isForwardedObjectClassIndexPun();
				assert(((classIndex11 >= 0) && (classIndex11 <= (classIndexMask()))));
				assert(((7 >= 0) && (7 <= (formatMask()))));
				longAtput(objOop2, ((longAt(objOop2)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex11 + (7LL << (formatShift()))));
				
#        if IMMUTABILITY
				/* begin setIsImmutableOf:to: */
				longAtput(objOop2, (longAt(objOop2)) & (~(1LL << 23)));

#        endif /* IMMUTABILITY */

				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(objOop2));
				assert(!(isOopForwarded(oldClone)));
				if (isOldObject(objOop2)) {

					/* most stores into young objects */
					if (((oldClone & (tagMask())) == 0)
					 && (oopisLessThan(oldClone, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(objOop2))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(objOop2);
						}
					}
				}
				longAtput((objOop2 + BaseHeaderSize) + (0LL << (shiftForWord())), oldClone);
				if ((byteAt(objOop2 + 7)) == 0) {
					byteAtput(objOop2 + 7, 1);
				}
			}
		}
		/* begin objectAfter:limit: */
		numSlots16 = byteAt(objOop2 + 7);
		numSlots22 = (numSlots16 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop2 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots16);
		if (numSlots22 == 0) {
			slotBytes5 = 8;
		}
		else {
			slotBytes5 = ((long)numSlots22) << (shiftForWord());
		}
		followingWordAddress3 = (objOop2 + BaseHeaderSize) + slotBytes5;
		if (oopisGreaterThanOrEqualTo(followingWordAddress3, segmentLimit)) {
			objOop2 = segmentLimit;
			goto l7;
		}
		flag("endianness");
		followingWord3 = longAt(followingWordAddress3);
		objOop2 = ((((usqInt) followingWord3) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress3 + BaseHeaderSize
			: followingWordAddress3);
	l7:	/* end objectAfter:limit: */;
	}
	if ((byteAt(segmentWordArray + 7)) == (numSlotsMask())) {
		/* begin rawOverflowSlotsOf:put: */
		flag("endianness");
		longAtput(segmentWordArray - BaseHeaderSize, (((long)(numSlotsMask())) << 56) + (8 / BytesPerOop));
		8 / BytesPerOop;
	}
	else {
		byteAtput(segmentWordArray + 7, 8 / BytesPerOop);
	}
	/* begin forward:to: */
	classIndex = isForwardedObjectClassIndexPun();
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((7 >= 0) && (7 <= (formatMask()))));
	longAtput(segmentWordArray, ((longAt(segmentWordArray)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex + (7LL << (formatShift()))));
	
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(segmentWordArray, (longAt(segmentWordArray)) & (~(1LL << 23)));

#  endif /* IMMUTABILITY */

	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(segmentWordArray));
	assert(!(isOopForwarded(loadedObjectsArray)));
	if (isOldObject(segmentWordArray)) {

		/* most stores into young objects */
		if (((loadedObjectsArray & (tagMask())) == 0)
		 && (oopisLessThan(loadedObjectsArray, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(segmentWordArray))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(segmentWordArray);
			}
		}
	}
	longAtput((segmentWordArray + BaseHeaderSize) + (0LL << (shiftForWord())), loadedObjectsArray);
	if ((byteAt(segmentWordArray + 7)) == 0) {
		byteAtput(segmentWordArray + 7, 1);
	}
	runLeakCheckerFor(GCModeImageSegment);
	/* begin objectStartingAt: */
	numSlots1 = byteAt(segmentStart + 7);
	return (numSlots1 == (numSlotsMask())
		? segmentStart + BaseHeaderSize
		: segmentStart);
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

	/* SpurMemoryManager>>#longPrintInstancesOf: */
void
longPrintInstancesOf(sqInt aClassOop)
{
    sqInt classIndex;

	classIndex = (long32At(aClassOop + 4)) & (identityHashHalfWordMask());
	if (classIndex != 0) {
		longPrintInstancesWithClassIndex(classIndex);
	}
}


/*	Scan the heap printing any and all objects whose classIndex equals the
	argument. 
 */

	/* SpurMemoryManager>>#longPrintInstancesWithClassIndex: */
void
longPrintInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((longAt(objOop)) & (classIndexMask())) == classIndex) {
			longPrintOop(objOop);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			longPrintOop(objOop1);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			objOop1 = limit;
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			longPrintOop(objOop1);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}


/*	Scan the heap long printing the oops of any and all objects that refer to
	anOop 
 */

	/* SpurMemoryManager>>#longPrintReferencesTo: */
void
longPrintReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt i;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    usqInt numSlots5;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prntObj;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	prntObj = 0;
	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots4 = byteAt(address + 7);
	objOop1 = (numSlots4 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) <= 5)
		 || (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
				i = (literalCountOfMethodHeader(methodHeaderOf(objOop1))) + LiteralStart;
			}
			else {
				if (((longAt(objOop1)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(objOop1));
				}
				else {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
					numSlots = byteAt(objOop1 + 7);
					i = (numSlots == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots);
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
					printHex(objOop1);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					prntObj = 1;
					i = 0;
				}
			}
			if (prntObj) {
				prntObj = 0;
				longPrintOop(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) <= 5)
		 || (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
				i = (literalCountOfMethodHeader(methodHeaderOf(objOop1))) + LiteralStart;
			}
			else {
				if (((longAt(objOop1)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(objOop1));
				}
				else {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
					numSlots = byteAt(objOop1 + 7);
					i = (numSlots == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots);
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
					printHex(objOop1);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					prntObj = 1;
					i = 0;
				}
			}
			if (prntObj) {
				prntObj = 0;
				longPrintOop(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if ((((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) <= 5)
			 || (((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
				if (((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
					i = (literalCountOfMethodHeader(methodHeaderOf(objOop11))) + LiteralStart;
				}
				else {
					if (((longAt(objOop11)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						i = CtxtTempFrameStart + (fetchStackPointerOf(objOop11));
					}
					else {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objOop11)) > (isForwardedObjectClassIndexPun()));
						numSlots = byteAt(objOop11 + 7);
						i = (numSlots == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
							: numSlots);
					}
				}
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((objOop11 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
						printHex(objOop11);
						print(" @ ");
						printNum(i);
						/* begin cr */
						printf("\n");
						prntObj = 1;
						i = 0;
					}
				}
				if (prntObj) {
					prntObj = 0;
					longPrintOop(objOop11);
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots5 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots5 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots5) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Now scan, adding out pointers to the outPointersArray; all objects in
	arrayOfObjects have had their hashes set to point to their copies in
	segmentWordArray. Answer the
	outIndex if the scan succeded. Fail if outPointers is too small and answer
	-1.  */

	/* SpurMemoryManager>>#mapOopsFrom:to:outPointers:outHashes: */
static sqInt NoDbgRegParms
mapOopsFromtooutPointersoutHashes(sqInt segStart, sqInt segAddr, sqInt outPointerArray, sqInt savedOutHashes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt followingWord;
    sqInt followingWordAddress;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt i;
    sqInt iLimiT;
    sqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt objOop;
    sqInt oop;
    sqInt outIndex;
    usqInt p;
    sqInt segIndex;
    sqInt slotBytes;
    sqInt valueWord;
    sqInt valueWord1;

	outIndex = 0;
	/* begin fillObj:numSlots:with: */
	flag("endianness");
	assert((classIndexOf(outPointerArray)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(outPointerArray + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(outPointerArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	assert(oopisLessThan(((outPointerArray + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(outPointerArray)));
	for (p = (((usqInt)(outPointerArray + BaseHeaderSize))); p <= (((usqInt)(((outPointerArray + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8) {
		longAtput(p, GIV(nilObj));
	}
	/* begin objectStartingAt: */
	numSlots2 = byteAt(segStart + 7);
	objOop = (numSlots2 == (numSlotsMask())
		? segStart + BaseHeaderSize
		: segStart);
	while (objOop < segAddr) {
		oop = fetchClassOfNonImm(objOop);
		if (!(((((usqInt) (longAt(oop))) >> 55) & 1) != 0)) {

			/* oop is a new outPointer; allocate its oop */
			/* begin newOutPointer:at:in:hashes: */
			if (outIndex >= (numSlotsOf(outPointerArray))) {

				/* no room in outPointers; fail */
				outIndex = 0;
				goto l2;
			}
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(outPointerArray)));
			if (isOldObject(outPointerArray)) {

				/* most stores into young objects */
				if (((oop & (tagMask())) == 0)
				 && (oopisLessThan(oop, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(outPointerArray))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(outPointerArray);
					}
				}
			}
			longAtput((outPointerArray + BaseHeaderSize) + (((long)outIndex) << (shiftForWord())), oop);
			/* begin storeLong32:ofObject:withValue: */
			valueWord = (long32At(oop + 4)) & (identityHashHalfWordMask());
			long32Atput((savedOutHashes + BaseHeaderSize) + (((long)outIndex) << 2), valueWord);
			/* begin setHashBitsOf:to: */
			hash1 = outIndex + TopHashBit;
			flag("endianness");
			assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
			long32Atput(oop + 4, ((((long32At(oop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop)));
			longAtput(oop, (longAt(oop)) | (1LL << 55));
			outIndex += 1;
		l2:	/* end newOutPointer:at:in:hashes: */;
			if (outIndex == 0) {

				/* no room in outPointers; fail */
				return -1;
			}
		}
		segIndex = (long32At(oop + 4)) & (identityHashHalfWordMask());
		/* begin setClassIndexOf:to: */
		classIndex = segIndex + 16;
		assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
		longAtput(objOop, ((longAt(objOop)) & (~(classIndexMask()))) + classIndex);
		for (i = 0, iLimiT = ((numPointerSlotsOf(objOop)) - 1); i <= iLimiT; i += 1) {
			oop = longAt((objOop + BaseHeaderSize) + (((long)i) << (shiftForWord())));
			if ((oop & (tagMask())) == 0) {
				if (!(((((usqInt) (longAt(oop))) >> 55) & 1) != 0)) {

					/* oop is a new outPointer; allocate its oop */
					/* begin newOutPointer:at:in:hashes: */
					if (outIndex >= (numSlotsOf(outPointerArray))) {

						/* no room in outPointers; fail */
						outIndex = 0;
						goto l3;
					}
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(outPointerArray)));
					if (isOldObject(outPointerArray)) {

						/* most stores into young objects */
						if (((oop & (tagMask())) == 0)
						 && (oopisLessThan(oop, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(outPointerArray))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(outPointerArray);
							}
						}
					}
					longAtput((outPointerArray + BaseHeaderSize) + (((long)outIndex) << (shiftForWord())), oop);
					/* begin storeLong32:ofObject:withValue: */
					valueWord1 = (long32At(oop + 4)) & (identityHashHalfWordMask());
					long32Atput((savedOutHashes + BaseHeaderSize) + (((long)outIndex) << 2), valueWord1);
					/* begin setHashBitsOf:to: */
					hash2 = outIndex + TopHashBit;
					flag("endianness");
					assert(((hash2 >= 0) && (hash2 <= (identityHashHalfWordMask()))));
					long32Atput(oop + 4, ((((long32At(oop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash2);
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(oop)));
					longAtput(oop, (longAt(oop)) | (1LL << 55));
					outIndex += 1;
				l3:	/* end newOutPointer:at:in:hashes: */;
					if (outIndex == 0) {

						/* no room in outPointers; fail */
						return -1;
					}
				}
				/* begin mappedInSegmentOopOf: */
				hash = (long32At(oop + 4)) & (identityHashHalfWordMask());
				oop = (hash & TopHashBit
					? ((hash - TopHashBit) * BytesPerOop) + TopOopBit
					: hash * 8);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop)));
				longAtput((objOop + BaseHeaderSize) + (((long)i) << (shiftForWord())), oop);
			}
		}
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots3 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots3 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, segAddr)) {
			objOop = segAddr;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return outIndex;
}


/*	Ensure the class of the argument is marked, pushing it on the markStack if
	not already marked.
	And for one-way become, which can create duplicate entries in the class
	table, make sure
	objOop's classIndex refers to the classObj's actual classIndex.
	Note that this is recursive, but the metaclass chain should terminate
	quickly. 
 */

	/* SpurMemoryManager>>#markAndTraceClassOf: */
static void NoDbgRegParms
markAndTraceClassOf(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classObj;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt realClassIndex;

	classIndex = (longAt(objOop)) & (classIndexMask());
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift());
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (classTablePage == GIV(nilObj)) {
		classObj = GIV(nilObj);
		goto l1;
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1LL << (classTableMajorIndexShift())) - 1);
	classObj = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
l1:	/* end classOrNilAtIndex: */;
	assert(objCouldBeClassObj(classObj));
	realClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	if (classIndex != realClassIndex) {
		/* begin setClassIndexOf:to: */
		assert(((realClassIndex >= 0) && (realClassIndex <= (classIndexMask()))));
		longAtput(objOop, ((longAt(objOop)) & (~(classIndexMask()))) + realClassIndex);
	}
	if (!(((((usqInt) (longAt(classObj))) >> 55) & 1) != 0)) {
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(classObj)));
		longAtput(classObj, (longAt(classObj)) | (1LL << 55));
		markAndTraceClassOf(classObj);
		pushonObjStack(classObj, GIV(markStack));
	}
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such
	as the markStack or the ephemeronQueue. It is a linked list of
	segments, with the hot end at the head of the list. It is a word object.
	The stack pointer is in ObjStackTopx and 0 means empty. */

	/* SpurMemoryManager>>#markAndTraceObjStack:andContents: */
static void NoDbgRegParms
markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt field;
    sqInt field1;
    sqInt fmt;
    sqInt format1;
    sqInt format11;
    sqInt header;
    sqInt index;
    sqInt index1;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt numStrongSlots;
    sqInt objOop1;
    sqInt objToScan;
    sqInt scanLargeObject;
    sqInt sp;

	numStrongSlots = 0;
	if (stackOrNil == GIV(nilObj)) {
		return;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(stackOrNil)));
	longAtput(stackOrNil, (longAt(stackOrNil)) | (1LL << 55));
	assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
	field = longAt((stackOrNil + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
	if (field != 0) {
		markAndTraceObjStackandContents(field, markAndTraceContents);
	}
	field = stackOrNil;
	while (1) {
		field = longAt((field + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())));
		if (!(field != 0)) break;
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(field)));
		longAtput(field, (longAt(field)) | (1LL << 55));
	}
	if (!markAndTraceContents) {
		return;
	}
	index = (longAt((stackOrNil + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())))) + ObjStackNextx;
	while (index >= ObjStackFixedSlots) {
		field = longAt((stackOrNil + BaseHeaderSize) + (((long)index) << (shiftForWord())));
		if (!((field & (tagMask())) != 0)) {
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((field & (tagMask())) != 0) {
				goto l1;
			}
			assert(!(isForwarded(field)));
			if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
				goto l1;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(field)));
			longAtput(field, (longAt(field)) | (1LL << 55));
			format1 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
			if ((format1 >= (sixtyFourBitIndexableFormat()))
			 && (format1 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(field)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(field);
				}
				goto l1;
			}
			if (format1 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(field, GIV(weaklingStack));
				goto l1;
			}
			if ((format1 == 5)
			 && (activeAndDeferredScan(field))) {
				goto l1;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan = field;
			do {
				if ((objToScan & (tagMask())) != 0) {
					scanLargeObject = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt = (((usqInt) (longAt(objToScan))) >> (formatShift())) & (formatMask());
					assert((fmt != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan))));
					if (fmt <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan)) > (isForwardedObjectClassIndexPun()));
						numSlots1 = byteAt(objToScan + 7);
						numSlots = (numSlots1 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan - BaseHeaderSize))) << 8)))) >> 8
							: numSlots1);
						if (fmt <= 2) {
							numStrongSlots = numSlots;
							goto l5;
						}
						if (fmt == (indexablePointersFormat())) {
							if (((longAt(objToScan)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan);
								/* begin fetchStackPointerOf: */
								sp = longAt((objToScan + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp) & 7) == 1))) {
									contextSize = 0;
									goto l4;
								}
								assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan)));
								contextSize = (sp >> 3);
							l4:	/* end fetchStackPointerOf: */;
								numStrongSlots = CtxtTempFrameStart + contextSize;
								goto l5;
							}
							numStrongSlots = numSlots;
							goto l5;
						}
						if (fmt == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop1 = fetchClassOfNonImm(objToScan);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots = (((longAt((objOop1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l5;
						}
					}
					if (fmt == 7) {
						numStrongSlots = 1;
						goto l5;
					}
					if (fmt < (firstCompiledMethodFormat())) {
						numStrongSlots = 0;
						goto l5;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan));
					header = longAt((objToScan + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header) & 7) == 1));
					numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots = numLiterals + LiteralStart;
				l5:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject = numStrongSlots > 64;
				}
				if (scanLargeObject) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan & (tagMask())) != 0) {
						index1 = (objToScan >> 3);
						objToScan = topOfObjStack(GIV(markStack));
					}
					else {
						index1 = numStrongSlots;
						markAndTraceClassOf(objToScan);
					}
					while (index1 > 0) {
						index1 -= 1;
						field1 = longAt((objToScan + BaseHeaderSize) + (((long)index1) << (shiftForWord())));
						if ((field1 & (tagMask())) == 0) {
							if (((longAt(field1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field1 = fixFollowedFieldofObjectwithInitialValue(index1, objToScan, field1);
							}
							if ((field1 & (tagMask())) != 0) {
								goto l3;
							}
							assert(!(isForwarded(field1)));
							if (((((usqInt) (longAt(field1))) >> 55) & 1) != 0) {
								goto l3;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field1)));
							longAtput(field1, (longAt(field1)) | (1LL << 55));
							format11 = (((usqInt) (longAt(field1))) >> (formatShift())) & (formatMask());
							if ((format11 >= (sixtyFourBitIndexableFormat()))
							 && (format11 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field1)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field1);
								}
								goto l3;
							}
							if (format11 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field1, GIV(weaklingStack));
								goto l3;
							}
							if ((format11 == 5)
							 && (activeAndDeferredScan(field1))) {
								goto l3;
							}
							/* end markAndShouldScan:; fall through */
							if (index1 > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan) {
									pushonObjStack(objToScan, GIV(markStack));
								}
								pushonObjStack(((index1 << 3) | 1), GIV(markStack));
							}
							objToScan = field1;
							index1 = -1;
						l3:	;

						}
					}
					if (index1 >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan = popObjStack(GIV(markStack));
						if (objToScan == field) {
							objToScan = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index1 = numStrongSlots;
					markAndTraceClassOf(objToScan);
					while (index1 > 0) {
						index1 -= 1;
						field1 = longAt((objToScan + BaseHeaderSize) + (((long)index1) << (shiftForWord())));
						if ((field1 & (tagMask())) == 0) {
							if (((longAt(field1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field1 = fixFollowedFieldofObjectwithInitialValue(index1, objToScan, field1);
							}
							if ((field1 & (tagMask())) != 0) {
								goto l2;
							}
							assert(!(isForwarded(field1)));
							if (((((usqInt) (longAt(field1))) >> 55) & 1) != 0) {
								goto l2;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field1)));
							longAtput(field1, (longAt(field1)) | (1LL << 55));
							format11 = (((usqInt) (longAt(field1))) >> (formatShift())) & (formatMask());
							if ((format11 >= (sixtyFourBitIndexableFormat()))
							 && (format11 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field1)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field1);
								}
								goto l2;
							}
							if (format11 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field1, GIV(weaklingStack));
								goto l2;
							}
							if ((format11 == 5)
							 && (activeAndDeferredScan(field1))) {
								goto l2;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field1, GIV(markStack));
							if (((byteAt(field1 + 7)) > 64)
							 && (((numStrongSlots = numStrongSlotsOfInephemeral(field1))) > 64)) {
								pushonObjStack(((numStrongSlots << 3) | 1), GIV(markStack));
							}
						l2:	;

						}
					}
					objToScan = popObjStack(GIV(markStack));
				}
			} while(objToScan != null);
		l1:	/* end markAndTrace: */;
		}
		index -= 1;
	}
}


/*	Mark the argument, and all objects reachable from it, and any remaining
	objects on the mark stack. Follow forwarding pointers in the scan. */
/*	if markAndTrace: is to follow and eliminate forwarding pointers
	in its scan it cannot be handed an r-value which is forwarded.
	The assert for this is in markAndShouldScan: */

	/* SpurMemoryManager>>#markAndTrace: */
void
markAndTrace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt field;
    sqInt fmt;
    sqInt format1;
    sqInt format11;
    sqInt header;
    sqInt index;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt numStrongSlots;
    sqInt objOop1;
    sqInt objToScan;
    sqInt scanLargeObject;
    sqInt sp;

	numStrongSlots = 0;

	/* inline markAndShouldScan: */
	if ((objOop & (tagMask())) != 0) {
		return;

	}
	assert(!(isForwarded(objOop)));
	if (((((usqInt) (longAt(objOop))) >> 55) & 1) != 0) {
		return;

	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop)));
	longAtput(objOop, (longAt(objOop)) | (1LL << 55));
	format1 = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	if ((format1 >= (sixtyFourBitIndexableFormat()))
	 && (format1 < (firstCompiledMethodFormat()))) {

		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if (((longAt(objOop)) & (classIndexMask())) > 0x1F) {
			markAndTraceClassOf(objOop);
		}
		return;

	}
	if (format1 == (weakArrayFormat())) {

		/* push weaklings on the weakling stack to scan later */
		pushonObjStack(objOop, GIV(weaklingStack));
		return;

	}
	if ((format1 == 5)
	 && (activeAndDeferredScan(objOop))) {
		return;

	}
	/* end markAndShouldScan:; fall through */
;
	/* begin markLoopFrom: */

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan = objOop;
	do {
		if ((objToScan & (tagMask())) != 0) {
			scanLargeObject = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt = (((usqInt) (longAt(objToScan))) >> (formatShift())) & (formatMask());
			assert((fmt != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan))));
			if (fmt <= 5) {
				/* begin numSlotsOf: */
				flag("endianness");
				assert((classIndexOf(objToScan)) > (isForwardedObjectClassIndexPun()));
				numSlots1 = byteAt(objToScan + 7);
				numSlots = (numSlots1 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objToScan - BaseHeaderSize))) << 8)))) >> 8
					: numSlots1);
				if (fmt <= 2) {
					numStrongSlots = numSlots;
					goto l4;
				}
				if (fmt == (indexablePointersFormat())) {
					if (((longAt(objToScan)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objToScan);
						/* begin fetchStackPointerOf: */
						sp = longAt((objToScan + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
						if (!((((sp) & 7) == 1))) {
							contextSize = 0;
							goto l3;
						}
						assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan)));
						contextSize = (sp >> 3);
					l3:	/* end fetchStackPointerOf: */;
						numStrongSlots = CtxtTempFrameStart + contextSize;
						goto l4;
					}
					numStrongSlots = numSlots;
					goto l4;
				}
				if (fmt == (weakArrayFormat())) {
					/* begin fixedFieldsOfClass: */
					objOop1 = fetchClassOfNonImm(objToScan);
					/* begin fixedFieldsOfClassFormat: */
					numStrongSlots = (((longAt((objOop1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
					goto l4;
				}
			}
			if (fmt == 7) {
				numStrongSlots = 1;
				goto l4;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				numStrongSlots = 0;
				goto l4;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objToScan));
			header = longAt((objToScan + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
			/* begin literalCountOfMethodHeader: */
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots = numLiterals + LiteralStart;
		l4:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject = numStrongSlots > 64;
		}
		if (scanLargeObject) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if ((objToScan & (tagMask())) != 0) {
				index = (objToScan >> 3);
				objToScan = topOfObjStack(GIV(markStack));
			}
			else {
				index = numStrongSlots;
				markAndTraceClassOf(objToScan);
			}
			while (index > 0) {
				index -= 1;
				field = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
				if ((field & (tagMask())) == 0) {
					if (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
					}
					if ((field & (tagMask())) != 0) {
						goto l1;
					}
					assert(!(isForwarded(field)));
					if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
						goto l1;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field)));
					longAtput(field, (longAt(field)) | (1LL << 55));
					format11 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
					if ((format11 >= (sixtyFourBitIndexableFormat()))
					 && (format11 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field);
						}
						goto l1;
					}
					if (format11 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field, GIV(weaklingStack));
						goto l1;
					}
					if ((format11 == 5)
					 && (activeAndDeferredScan(field))) {
						goto l1;
					}
					/* end markAndShouldScan:; fall through */
					if (index > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan) {
							pushonObjStack(objToScan, GIV(markStack));
						}
						pushonObjStack(((index << 3) | 1), GIV(markStack));
					}
					objToScan = field;
					index = -1;
				l1:	;

				}
			}
			if (index >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan = popObjStack(GIV(markStack));
				if (objToScan == objOop) {
					objToScan = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index = numStrongSlots;
			markAndTraceClassOf(objToScan);
			while (index > 0) {
				index -= 1;
				field = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
				if ((field & (tagMask())) == 0) {
					if (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
					}
					if ((field & (tagMask())) != 0) {
						goto l2;
					}
					assert(!(isForwarded(field)));
					if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
						goto l2;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field)));
					longAtput(field, (longAt(field)) | (1LL << 55));
					format11 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
					if ((format11 >= (sixtyFourBitIndexableFormat()))
					 && (format11 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field);
						}
						goto l2;
					}
					if (format11 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field, GIV(weaklingStack));
						goto l2;
					}
					if ((format11 == 5)
					 && (activeAndDeferredScan(field))) {
						goto l2;
					}
					/* end markAndShouldScan:; fall through */
					pushonObjStack(field, GIV(markStack));
					if (((byteAt(field + 7)) > 64)
					 && (((numStrongSlots = numStrongSlotsOfInephemeral(field))) > 64)) {
						pushonObjStack(((numStrongSlots << 3) | 1), GIV(markStack));
					}
				l2:	;

				}
			}
			objToScan = popObjStack(GIV(markStack));
		}
	} while(objToScan != null);
}


/*	Go through the unscanned ephemerons, marking the inactive ones, and
	removing them from the unscanned ephemerons. Answer if any inactive
	ones were found. We cannot fire the ephemerons until all are found to
	be active since scan-marking an inactive ephemeron later in the set may
	render a previously-observed active ephemeron as inactive. */

	/* SpurMemoryManager>>#markInactiveEphemerons */
static sqInt
markInactiveEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt ephemeron;
    sqInt field;
    sqInt fmt;
    sqInt format1;
    sqInt format11;
    sqInt foundInactive;
    sqInt header;
    sqInt index;
    sqInt key;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt numStrongSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objToScan;
    sqInt oop;
    usqInt ptr;
    sqInt scanLargeObject;
    sqInt sp;

	numStrongSlots = 0;
	foundInactive = 0;
	ptr = (GIV(unscannedEphemerons).start);
	while (ptr < ((GIV(unscannedEphemerons).top))) {
		/* begin followedKeyOfEphemeron: */
		objOop = (ephemeron = longAt(ptr));
		assert((isNonImmediate(objOop))
		 && (isEphemeron(objOop)));
		/* begin followOopField:ofObject: */
		oop = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
		if (((oop & (tagMask())) == 0)
		 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			oop = fixFollowedFieldofObjectwithInitialValue(0, objOop, oop);
		}
		key = oop;
		if (((key & (tagMask())) != 0)
		 || (((((usqInt) (longAt(key))) >> 55) & 1) != 0)) {

			/* Now remove the inactive ephemeron from the set, and scan-mark it.
			   Scan-marking it may add more ephemerons to the set. */
			foundInactive = 1;
			(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) - BytesPerWord);
			if (((GIV(unscannedEphemerons).top)) > ptr) {
				longAtput(ptr, longAt((GIV(unscannedEphemerons).top)));
			}
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((ephemeron & (tagMask())) != 0) {
				goto l1;
			}
			assert(!(isForwarded(ephemeron)));
			if (((((usqInt) (longAt(ephemeron))) >> 55) & 1) != 0) {
				goto l1;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(ephemeron)));
			longAtput(ephemeron, (longAt(ephemeron)) | (1LL << 55));
			format1 = (((usqInt) (longAt(ephemeron))) >> (formatShift())) & (formatMask());
			if ((format1 >= (sixtyFourBitIndexableFormat()))
			 && (format1 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(ephemeron)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(ephemeron);
				}
				goto l1;
			}
			if (format1 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(ephemeron, GIV(weaklingStack));
				goto l1;
			}
			if ((format1 == 5)
			 && (activeAndDeferredScan(ephemeron))) {
				goto l1;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan = ephemeron;
			do {
				if ((objToScan & (tagMask())) != 0) {
					scanLargeObject = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt = (((usqInt) (longAt(objToScan))) >> (formatShift())) & (formatMask());
					assert((fmt != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan))));
					if (fmt <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan)) > (isForwardedObjectClassIndexPun()));
						numSlots1 = byteAt(objToScan + 7);
						numSlots = (numSlots1 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan - BaseHeaderSize))) << 8)))) >> 8
							: numSlots1);
						if (fmt <= 2) {
							numStrongSlots = numSlots;
							goto l5;
						}
						if (fmt == (indexablePointersFormat())) {
							if (((longAt(objToScan)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan);
								/* begin fetchStackPointerOf: */
								sp = longAt((objToScan + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp) & 7) == 1))) {
									contextSize = 0;
									goto l4;
								}
								assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan)));
								contextSize = (sp >> 3);
							l4:	/* end fetchStackPointerOf: */;
								numStrongSlots = CtxtTempFrameStart + contextSize;
								goto l5;
							}
							numStrongSlots = numSlots;
							goto l5;
						}
						if (fmt == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop1 = fetchClassOfNonImm(objToScan);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots = (((longAt((objOop1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l5;
						}
					}
					if (fmt == 7) {
						numStrongSlots = 1;
						goto l5;
					}
					if (fmt < (firstCompiledMethodFormat())) {
						numStrongSlots = 0;
						goto l5;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan));
					header = longAt((objToScan + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header) & 7) == 1));
					numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots = numLiterals + LiteralStart;
				l5:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject = numStrongSlots > 64;
				}
				if (scanLargeObject) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan & (tagMask())) != 0) {
						index = (objToScan >> 3);
						objToScan = topOfObjStack(GIV(markStack));
					}
					else {
						index = numStrongSlots;
						markAndTraceClassOf(objToScan);
					}
					while (index > 0) {
						index -= 1;
						field = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
						if ((field & (tagMask())) == 0) {
							if (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
							}
							if ((field & (tagMask())) != 0) {
								goto l3;
							}
							assert(!(isForwarded(field)));
							if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
								goto l3;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field)));
							longAtput(field, (longAt(field)) | (1LL << 55));
							format11 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
							if ((format11 >= (sixtyFourBitIndexableFormat()))
							 && (format11 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field);
								}
								goto l3;
							}
							if (format11 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field, GIV(weaklingStack));
								goto l3;
							}
							if ((format11 == 5)
							 && (activeAndDeferredScan(field))) {
								goto l3;
							}
							/* end markAndShouldScan:; fall through */
							if (index > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan) {
									pushonObjStack(objToScan, GIV(markStack));
								}
								pushonObjStack(((index << 3) | 1), GIV(markStack));
							}
							objToScan = field;
							index = -1;
						l3:	;

						}
					}
					if (index >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan = popObjStack(GIV(markStack));
						if (objToScan == ephemeron) {
							objToScan = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index = numStrongSlots;
					markAndTraceClassOf(objToScan);
					while (index > 0) {
						index -= 1;
						field = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
						if ((field & (tagMask())) == 0) {
							if (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
							}
							if ((field & (tagMask())) != 0) {
								goto l2;
							}
							assert(!(isForwarded(field)));
							if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
								goto l2;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field)));
							longAtput(field, (longAt(field)) | (1LL << 55));
							format11 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
							if ((format11 >= (sixtyFourBitIndexableFormat()))
							 && (format11 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field);
								}
								goto l2;
							}
							if (format11 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field, GIV(weaklingStack));
								goto l2;
							}
							if ((format11 == 5)
							 && (activeAndDeferredScan(field))) {
								goto l2;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field, GIV(markStack));
							if (((byteAt(field + 7)) > 64)
							 && (((numStrongSlots = numStrongSlotsOfInephemeral(field))) > 64)) {
								pushonObjStack(((numStrongSlots << 3) | 1), GIV(markStack));
							}
						l2:	;

						}
					}
					objToScan = popObjStack(GIV(markStack));
				}
			} while(objToScan != null);
		l1:	/* end markAndTrace: */;
		}
		else {
			ptr += BytesPerWord;
		}
	}
	return foundInactive;
}


/*	for profiling */
/*	Mark all accessible objects.
	objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged is true if all
	objects are unmarked and/or if unmarked classes shoud be removed from the
	class table. */
/*	If the incremental collector is running mark bits may be set; stop it and
	clear them if necessary.
 */

	/* SpurMemoryManager>>#markObjects: */
static void NoDbgRegParms NeverInline
markObjects(sqInt objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cascade0;
    sqInt classIndex;
    sqInt classOrNil;
    sqInt classTablePage;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt contextSize11;
    sqInt contextSize12;
    sqInt contextSize2;
    sqInt contextSize21;
    sqInt contextSize22;
    sqInt contextSize3;
    sqInt contextSize31;
    sqInt contextSize4;
    sqInt contextSize41;
    sqInt contextSize5;
    sqInt contextSize6;
    sqInt contextSize7;
    sqInt contextSize8;
    sqInt field;
    sqInt field1;
    sqInt field11;
    sqInt field12;
    sqInt field2;
    sqInt field21;
    sqInt field22;
    sqInt field3;
    sqInt field31;
    sqInt field4;
    sqInt field41;
    sqInt field5;
    sqInt field6;
    sqInt field7;
    sqInt field8;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt11;
    sqInt fmt12;
    sqInt fmt2;
    sqInt fmt21;
    sqInt fmt22;
    sqInt fmt3;
    sqInt fmt31;
    sqInt fmt4;
    sqInt fmt41;
    sqInt fmt5;
    sqInt fmt6;
    sqInt fmt7;
    sqInt fmt8;
    sqInt format1;
    sqInt format11;
    sqInt format110;
    sqInt format111;
    sqInt format1111;
    sqInt format112;
    sqInt format113;
    sqInt format114;
    sqInt format115;
    sqInt format116;
    sqInt format117;
    sqInt format12;
    sqInt format121;
    sqInt format122;
    sqInt format13;
    sqInt format131;
    sqInt format132;
    sqInt format14;
    sqInt format141;
    sqInt format142;
    sqInt format15;
    sqInt format151;
    sqInt format16;
    sqInt format161;
    sqInt format17;
    sqInt format171;
    sqInt format18;
    sqInt format181;
    sqInt format19;
    sqInt format191;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header2;
    sqInt header21;
    sqInt header22;
    sqInt header3;
    sqInt header31;
    sqInt header4;
    sqInt header41;
    sqInt header5;
    sqInt header6;
    sqInt header7;
    sqInt header8;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt iLimiT;
    sqInt index;
    sqInt index1;
    sqInt index11;
    sqInt index12;
    sqInt index2;
    sqInt index21;
    sqInt index22;
    sqInt index3;
    sqInt index31;
    sqInt index4;
    sqInt index41;
    sqInt index5;
    sqInt index6;
    sqInt index7;
    sqInt index8;
    sqInt j;
    sqInt jLimiT;
    sqInt largestFree;
    sqInt numLiterals;
    sqInt numLiterals1;
    sqInt numLiterals11;
    sqInt numLiterals12;
    sqInt numLiterals2;
    sqInt numLiterals21;
    sqInt numLiterals22;
    sqInt numLiterals3;
    sqInt numLiterals31;
    sqInt numLiterals4;
    sqInt numLiterals41;
    sqInt numLiterals5;
    sqInt numLiterals6;
    sqInt numLiterals7;
    sqInt numLiterals8;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots111;
    usqInt numSlots112;
    usqInt numSlots12;
    usqInt numSlots121;
    usqInt numSlots122;
    usqInt numSlots13;
    usqInt numSlots131;
    usqInt numSlots14;
    usqInt numSlots141;
    usqInt numSlots15;
    usqInt numSlots16;
    usqInt numSlots17;
    usqInt numSlots18;
    usqInt numSlots2;
    usqInt numSlots21;
    usqInt numSlots22;
    usqInt numSlots3;
    usqInt numSlots31;
    usqInt numSlots32;
    usqInt numSlots4;
    usqInt numSlots41;
    usqInt numSlots5;
    usqInt numSlots51;
    usqInt numSlots6;
    usqInt numSlots7;
    usqInt numSlots8;
    usqInt numSlots9;
    sqInt numStrongSlots;
    sqInt numStrongSlots1;
    sqInt numStrongSlots11;
    sqInt numStrongSlots12;
    sqInt numStrongSlots2;
    sqInt numStrongSlots21;
    sqInt numStrongSlots22;
    sqInt numStrongSlots3;
    sqInt numStrongSlots31;
    sqInt numStrongSlots4;
    sqInt numStrongSlots41;
    sqInt numStrongSlots5;
    sqInt numStrongSlots6;
    sqInt numStrongSlots7;
    sqInt numStrongSlots8;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop111;
    sqInt objOop112;
    sqInt objOop12;
    sqInt objOop121;
    sqInt objOop122;
    sqInt objOop13;
    sqInt objOop131;
    sqInt objOop132;
    sqInt objOop14;
    sqInt objOop141;
    sqInt objOop15;
    sqInt objOop151;
    sqInt objOop16;
    sqInt objOop17;
    sqInt objOop18;
    sqInt objOop19;
    sqInt objOop2;
    sqInt objOop21;
    sqInt objOop22;
    sqInt objOop3;
    sqInt objOop31;
    usqInt objOop4;
    sqInt objOop41;
    sqInt objOop5;
    sqInt objToScan;
    sqInt objToScan1;
    sqInt objToScan11;
    sqInt objToScan12;
    sqInt objToScan2;
    sqInt objToScan21;
    sqInt objToScan22;
    sqInt objToScan3;
    sqInt objToScan31;
    sqInt objToScan4;
    sqInt objToScan41;
    sqInt objToScan5;
    sqInt objToScan6;
    sqInt objToScan7;
    sqInt objToScan8;
    sqInt oop;
    usqInt oop1;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt referent3;
    sqInt referent4;
    sqInt scanLargeObject;
    sqInt scanLargeObject1;
    sqInt scanLargeObject11;
    sqInt scanLargeObject12;
    sqInt scanLargeObject2;
    sqInt scanLargeObject21;
    sqInt scanLargeObject22;
    sqInt scanLargeObject3;
    sqInt scanLargeObject31;
    sqInt scanLargeObject4;
    sqInt scanLargeObject41;
    sqInt scanLargeObject5;
    sqInt scanLargeObject6;
    sqInt scanLargeObject7;
    sqInt scanLargeObject8;
    usqInt sizeOfUnusedEden;
    sqInt sp;
    sqInt sp1;
    sqInt sp11;
    sqInt sp12;
    sqInt sp2;
    sqInt sp21;
    sqInt sp22;
    sqInt sp3;
    sqInt sp31;
    sqInt sp4;
    sqInt sp41;
    sqInt sp5;
    sqInt sp6;
    sqInt sp7;
    sqInt sp8;
    StackPage *thePage;

	numStrongSlots = 0;
	numStrongSlots1 = 0;
	numStrongSlots11 = 0;
	numStrongSlots12 = 0;
	numStrongSlots2 = 0;
	numStrongSlots21 = 0;
	numStrongSlots22 = 0;
	numStrongSlots3 = 0;
	numStrongSlots31 = 0;
	numStrongSlots4 = 0;
	numStrongSlots41 = 0;
	numStrongSlots5 = 0;
	numStrongSlots6 = 0;
	numStrongSlots7 = 0;
	numStrongSlots8 = 0;
	runLeakCheckerFor(GCModeFull);
	/* begin shutDownIncrementalGC: */
	flag("need to implement the inc GC first...");
	if (objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged) {
		assert(allObjectsUnmarked());
	}
	/* begin initializeUnscannedEphemerons */
	largestFree = findLargestFreeChunk();
	sizeOfUnusedEden = (((eden()).limit)) - GIV(freeStart);
	if ((largestFree != null)
	 && ((numSlotsOfAny(largestFree)) > (sizeOfUnusedEden / BytesPerWord))) {
		(GIV(unscannedEphemerons).start = (largestFree + BaseHeaderSize) + ((4 + 1) * BytesPerWord));
		(GIV(unscannedEphemerons).limit = addressAfter(largestFree));
	}
	else {
		(GIV(unscannedEphemerons).start = GIV(freeStart));
		(GIV(unscannedEphemerons).limit = ((eden()).limit));
	}
	(GIV(unscannedEphemerons).top = (GIV(unscannedEphemerons).start));
	/* begin initializeMarkStack */
	ensureRoomOnObjStackAt(MarkStackRootIndex);
	/* begin initializeWeaklingStack */
	ensureRoomOnObjStackAt(WeaklingStackRootIndex);
	/* begin markAccessibleObjectsAndFireEphemerons */
	assert(validClassTableRootPages());
	assert(allBridgesMarked());

	/* This must come first to enable stack page reclamation.  It clears
	   the trace flags on stack pages and so must precede any marking.
	   Otherwise it will clear the trace flags of reached pages. */
	GIV(marking) = 1;
	/* begin initStackPageGC */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i2 = 0; i2 < GIV(numStackPages); i2 += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i2, GIV(pages));
		(thePage->trace = StackPageUnreached);
	}
	/* begin markAndTraceHiddenRoots */
	markAndTraceObjStackandContents(GIV(markStack), 0);
	markAndTraceObjStackandContents(GIV(weaklingStack), 0);
	markAndTraceObjStackandContents(GIV(mournQueue), 1);
	/* begin setIsMarkedOf:to: */
	objOop13 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)RememberedSetRootIndex) << (shiftForWord())));
	assert(!(isFreeObject(objOop13)));
	longAtput(objOop13, (longAt(objOop13)) | (1LL << 55));
	/* begin setIsMarkedOf:to: */
	assert((firstIndexableField(objectAfter(GIV(trueObj)))) == GIV(freeLists));
	objOop2 = objectAfter(GIV(trueObj));
	assert(!(isFreeObject(objOop2)));
	longAtput(objOop2, (longAt(objOop2)) | (1LL << 55));
	if (isWeakFormat((((usqInt) (longAt(GIV(classTableFirstPage)))) >> (formatShift())) & (formatMask()))) {
		/* begin markAndTrace: */

		/* inline markAndShouldScan: */
		if ((GIV(hiddenRootsObj) & (tagMask())) != 0) {
			goto l12;
		}
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> 55) & 1) != 0) {
			goto l12;
		}
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(GIV(hiddenRootsObj))));
		longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1LL << 55));
		format14 = (((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (formatShift())) & (formatMask());
		if ((format14 >= (sixtyFourBitIndexableFormat()))
		 && (format14 < (firstCompiledMethodFormat()))) {

			/* avoid pushing non-pointer objects on the markStack. */
			/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
			if (((longAt(GIV(hiddenRootsObj))) & (classIndexMask())) > 0x1F) {
				markAndTraceClassOf(GIV(hiddenRootsObj));
			}
			goto l12;
		}
		if (format14 == (weakArrayFormat())) {

			/* push weaklings on the weakling stack to scan later */
			pushonObjStack(GIV(hiddenRootsObj), GIV(weaklingStack));
			goto l12;
		}
		if ((format14 == 5)
		 && (activeAndDeferredScan(GIV(hiddenRootsObj)))) {
			goto l12;
		}
		/* end markAndShouldScan:; fall through */
;
		/* begin markLoopFrom: */

		/* To avoid overflowing the mark stack when we encounter large objects, we
		   push the obj, then its numStrongSlots, and then index the object from the stack. */
		objToScan2 = GIV(hiddenRootsObj);
		do {
			if ((objToScan2 & (tagMask())) != 0) {
				scanLargeObject2 = 1;
			}
			else {
				/* begin numStrongSlotsOfInephemeral: */
				fmt2 = (((usqInt) (longAt(objToScan2))) >> (formatShift())) & (formatMask());
				assert((fmt2 != (ephemeronFormat()))
				 || (isMarked(keyOfEphemeron(objToScan2))));
				if (fmt2 <= 5) {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objToScan2)) > (isForwardedObjectClassIndexPun()));
					numSlots12 = byteAt(objToScan2 + 7);
					numSlots3 = (numSlots12 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objToScan2 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots12);
					if (fmt2 <= 2) {
						numStrongSlots2 = numSlots3;
						goto l8;
					}
					if (fmt2 == (indexablePointersFormat())) {
						if (((longAt(objToScan2)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
							setTraceFlagOnContextsFramesPageIfNeeded(objToScan2);
							/* begin fetchStackPointerOf: */
							sp2 = longAt((objToScan2 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
							if (!((((sp2) & 7) == 1))) {
								contextSize2 = 0;
								goto l7;
							}
							assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(objToScan2)));
							contextSize2 = (sp2 >> 3);
						l7:	/* end fetchStackPointerOf: */;
							numStrongSlots2 = CtxtTempFrameStart + contextSize2;
							goto l8;
						}
						numStrongSlots2 = numSlots3;
						goto l8;
					}
					if (fmt2 == (weakArrayFormat())) {
						/* begin fixedFieldsOfClass: */
						objOop11 = fetchClassOfNonImm(objToScan2);
						/* begin fixedFieldsOfClassFormat: */
						numStrongSlots2 = (((longAt((objOop11 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						goto l8;
					}
				}
				if (fmt2 == 7) {
					numStrongSlots2 = 1;
					goto l8;
				}
				if (fmt2 < (firstCompiledMethodFormat())) {
					numStrongSlots2 = 0;
					goto l8;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objToScan2));
				header2 = longAt((objToScan2 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				/* begin literalCountOfMethodHeader: */
				assert((((header2) & 7) == 1));
				numLiterals2 = ((header2 >> 3)) & AlternateHeaderNumLiteralsMask;
				numStrongSlots2 = numLiterals2 + LiteralStart;
			l8:	/* end numStrongSlotsOfInephemeral: */;
				scanLargeObject2 = numStrongSlots2 > 64;
			}
			if (scanLargeObject2) {

				/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
				if ((objToScan2 & (tagMask())) != 0) {
					index2 = (objToScan2 >> 3);
					objToScan2 = topOfObjStack(GIV(markStack));
				}
				else {
					index2 = numStrongSlots2;
					markAndTraceClassOf(objToScan2);
				}
				while (index2 > 0) {
					index2 -= 1;
					field2 = longAt((objToScan2 + BaseHeaderSize) + (((long)index2) << (shiftForWord())));
					if ((field2 & (tagMask())) == 0) {
						if (((longAt(field2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field2 = fixFollowedFieldofObjectwithInitialValue(index2, objToScan2, field2);
						}
						if ((field2 & (tagMask())) != 0) {
							goto l13;
						}
						assert(!(isForwarded(field2)));
						if (((((usqInt) (longAt(field2))) >> 55) & 1) != 0) {
							goto l13;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field2)));
						longAtput(field2, (longAt(field2)) | (1LL << 55));
						format12 = (((usqInt) (longAt(field2))) >> (formatShift())) & (formatMask());
						if ((format12 >= (sixtyFourBitIndexableFormat()))
						 && (format12 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field2)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field2);
							}
							goto l13;
						}
						if (format12 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field2, GIV(weaklingStack));
							goto l13;
						}
						if ((format12 == 5)
						 && (activeAndDeferredScan(field2))) {
							goto l13;
						}
						/* end markAndShouldScan:; fall through */
						if (index2 > 0) {
							if ((topOfObjStack(GIV(markStack))) != objToScan2) {
								pushonObjStack(objToScan2, GIV(markStack));
							}
							pushonObjStack(((index2 << 3) | 1), GIV(markStack));
						}
						objToScan2 = field2;
						index2 = -1;
					l13:	;
					}
				}
				if (index2 >= 0) {

					/* if loop terminated without finding an unmarked referent, switch to top of stack. */
					objToScan2 = popObjStack(GIV(markStack));
					if (objToScan2 == GIV(hiddenRootsObj)) {
						objToScan2 = popObjStack(GIV(markStack));
					}
				}
			}
			else {

				/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
				index2 = numStrongSlots2;
				markAndTraceClassOf(objToScan2);
				while (index2 > 0) {
					index2 -= 1;
					field2 = longAt((objToScan2 + BaseHeaderSize) + (((long)index2) << (shiftForWord())));
					if ((field2 & (tagMask())) == 0) {
						if (((longAt(field2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field2 = fixFollowedFieldofObjectwithInitialValue(index2, objToScan2, field2);
						}
						if ((field2 & (tagMask())) != 0) {
							goto l11;
						}
						assert(!(isForwarded(field2)));
						if (((((usqInt) (longAt(field2))) >> 55) & 1) != 0) {
							goto l11;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field2)));
						longAtput(field2, (longAt(field2)) | (1LL << 55));
						format12 = (((usqInt) (longAt(field2))) >> (formatShift())) & (formatMask());
						if ((format12 >= (sixtyFourBitIndexableFormat()))
						 && (format12 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field2)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field2);
							}
							goto l11;
						}
						if (format12 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field2, GIV(weaklingStack));
							goto l11;
						}
						if ((format12 == 5)
						 && (activeAndDeferredScan(field2))) {
							goto l11;
						}
						/* end markAndShouldScan:; fall through */
						pushonObjStack(field2, GIV(markStack));
						if (((byteAt(field2 + 7)) > 64)
						 && (((numStrongSlots2 = numStrongSlotsOfInephemeral(field2))) > 64)) {
							pushonObjStack(((numStrongSlots2 << 3) | 1), GIV(markStack));
						}
					l11:	;
					}
				}
				objToScan2 = popObjStack(GIV(markStack));
			}
		} while(objToScan2 != null);
	l12:	/* end markAndTrace: */;
		goto l16;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(GIV(hiddenRootsObj))));
	longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1LL << 55));
	/* begin markAndTrace: */

	/* inline markAndShouldScan: */
	if ((GIV(classTableFirstPage) & (tagMask())) != 0) {
		goto l15;
	}
	assert(!(isForwarded(GIV(classTableFirstPage))));
	if (((((usqInt) (longAt(GIV(classTableFirstPage)))) >> 55) & 1) != 0) {
		goto l15;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(GIV(classTableFirstPage))));
	longAtput(GIV(classTableFirstPage), (longAt(GIV(classTableFirstPage))) | (1LL << 55));
	format111 = (((usqInt) (longAt(GIV(classTableFirstPage)))) >> (formatShift())) & (formatMask());
	if ((format111 >= (sixtyFourBitIndexableFormat()))
	 && (format111 < (firstCompiledMethodFormat()))) {

		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if (((longAt(GIV(classTableFirstPage))) & (classIndexMask())) > 0x1F) {
			markAndTraceClassOf(GIV(classTableFirstPage));
		}
		goto l15;
	}
	if (format111 == (weakArrayFormat())) {

		/* push weaklings on the weakling stack to scan later */
		pushonObjStack(GIV(classTableFirstPage), GIV(weaklingStack));
		goto l15;
	}
	if ((format111 == 5)
	 && (activeAndDeferredScan(GIV(classTableFirstPage)))) {
		goto l15;
	}
	/* end markAndShouldScan:; fall through */
;
	/* begin markLoopFrom: */

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan1 = GIV(classTableFirstPage);
	do {
		if ((objToScan1 & (tagMask())) != 0) {
			scanLargeObject1 = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt1 = (((usqInt) (longAt(objToScan1))) >> (formatShift())) & (formatMask());
			assert((fmt1 != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan1))));
			if (fmt1 <= 5) {
				/* begin numSlotsOf: */
				flag("endianness");
				assert((classIndexOf(objToScan1)) > (isForwardedObjectClassIndexPun()));
				numSlots11 = byteAt(objToScan1 + 7);
				numSlots2 = (numSlots11 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objToScan1 - BaseHeaderSize))) << 8)))) >> 8
					: numSlots11);
				if (fmt1 <= 2) {
					numStrongSlots1 = numSlots2;
					goto l10;
				}
				if (fmt1 == (indexablePointersFormat())) {
					if (((longAt(objToScan1)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objToScan1);
						/* begin fetchStackPointerOf: */
						sp1 = longAt((objToScan1 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
						if (!((((sp1) & 7) == 1))) {
							contextSize1 = 0;
							goto l9;
						}
						assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(objToScan1)));
						contextSize1 = (sp1 >> 3);
					l9:	/* end fetchStackPointerOf: */;
						numStrongSlots1 = CtxtTempFrameStart + contextSize1;
						goto l10;
					}
					numStrongSlots1 = numSlots2;
					goto l10;
				}
				if (fmt1 == (weakArrayFormat())) {
					/* begin fixedFieldsOfClass: */
					objOop12 = fetchClassOfNonImm(objToScan1);
					/* begin fixedFieldsOfClassFormat: */
					numStrongSlots1 = (((longAt((objOop12 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
					goto l10;
				}
			}
			if (fmt1 == 7) {
				numStrongSlots1 = 1;
				goto l10;
			}
			if (fmt1 < (firstCompiledMethodFormat())) {
				numStrongSlots1 = 0;
				goto l10;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objToScan1));
			header1 = longAt((objToScan1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
			/* begin literalCountOfMethodHeader: */
			assert((((header1) & 7) == 1));
			numLiterals1 = ((header1 >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots1 = numLiterals1 + LiteralStart;
		l10:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject1 = numStrongSlots1 > 64;
		}
		if (scanLargeObject1) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if ((objToScan1 & (tagMask())) != 0) {
				index1 = (objToScan1 >> 3);
				objToScan1 = topOfObjStack(GIV(markStack));
			}
			else {
				index1 = numStrongSlots1;
				markAndTraceClassOf(objToScan1);
			}
			while (index1 > 0) {
				index1 -= 1;
				field1 = longAt((objToScan1 + BaseHeaderSize) + (((long)index1) << (shiftForWord())));
				if ((field1 & (tagMask())) == 0) {
					if (((longAt(field1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field1 = fixFollowedFieldofObjectwithInitialValue(index1, objToScan1, field1);
					}
					if ((field1 & (tagMask())) != 0) {
						goto l14;
					}
					assert(!(isForwarded(field1)));
					if (((((usqInt) (longAt(field1))) >> 55) & 1) != 0) {
						goto l14;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field1)));
					longAtput(field1, (longAt(field1)) | (1LL << 55));
					format13 = (((usqInt) (longAt(field1))) >> (formatShift())) & (formatMask());
					if ((format13 >= (sixtyFourBitIndexableFormat()))
					 && (format13 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field1)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field1);
						}
						goto l14;
					}
					if (format13 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field1, GIV(weaklingStack));
						goto l14;
					}
					if ((format13 == 5)
					 && (activeAndDeferredScan(field1))) {
						goto l14;
					}
					/* end markAndShouldScan:; fall through */
					if (index1 > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan1) {
							pushonObjStack(objToScan1, GIV(markStack));
						}
						pushonObjStack(((index1 << 3) | 1), GIV(markStack));
					}
					objToScan1 = field1;
					index1 = -1;
				l14:	;
				}
			}
			if (index1 >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan1 = popObjStack(GIV(markStack));
				if (objToScan1 == GIV(classTableFirstPage)) {
					objToScan1 = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index1 = numStrongSlots1;
			markAndTraceClassOf(objToScan1);
			while (index1 > 0) {
				index1 -= 1;
				field1 = longAt((objToScan1 + BaseHeaderSize) + (((long)index1) << (shiftForWord())));
				if ((field1 & (tagMask())) == 0) {
					if (((longAt(field1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field1 = fixFollowedFieldofObjectwithInitialValue(index1, objToScan1, field1);
					}
					if ((field1 & (tagMask())) != 0) {
						goto l6;
					}
					assert(!(isForwarded(field1)));
					if (((((usqInt) (longAt(field1))) >> 55) & 1) != 0) {
						goto l6;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field1)));
					longAtput(field1, (longAt(field1)) | (1LL << 55));
					format13 = (((usqInt) (longAt(field1))) >> (formatShift())) & (formatMask());
					if ((format13 >= (sixtyFourBitIndexableFormat()))
					 && (format13 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field1)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field1);
						}
						goto l6;
					}
					if (format13 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field1, GIV(weaklingStack));
						goto l6;
					}
					if ((format13 == 5)
					 && (activeAndDeferredScan(field1))) {
						goto l6;
					}
					/* end markAndShouldScan:; fall through */
					pushonObjStack(field1, GIV(markStack));
					if (((byteAt(field1 + 7)) > 64)
					 && (((numStrongSlots1 = numStrongSlotsOfInephemeral(field1))) > 64)) {
						pushonObjStack(((numStrongSlots1 << 3) | 1), GIV(markStack));
					}
				l6:	;
				}
			}
			objToScan1 = popObjStack(GIV(markStack));
		}
	} while(objToScan1 != null);
l15:	/* end markAndTrace: */;
	for (i3 = 1; i3 < GIV(numClassTablePages); i3 += 1) {
		/* begin setIsMarkedOf:to: */
		objOop = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i3) << (shiftForWord())));
		assert(!(isFreeObject(objOop)));
		longAtput(objOop, (longAt(objOop)) | (1LL << 55));
	}
l16:	/* end markAndTraceHiddenRoots */;
	/* begin markAndTraceExtraRoots */
	assert(GIV(remapBufferCount) == 0);
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!(((oop & (tagMask())) != 0)
			 || (((longAt(oop)) & (classIndexMask())) == 0))) {
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((oop & (tagMask())) != 0) {
				goto l1;
			}
			assert(!(isForwarded(oop)));
			if (((((usqInt) (longAt(oop))) >> 55) & 1) != 0) {
				goto l1;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop)));
			longAtput(oop, (longAt(oop)) | (1LL << 55));
			format1 = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
			if ((format1 >= (sixtyFourBitIndexableFormat()))
			 && (format1 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(oop)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(oop);
				}
				goto l1;
			}
			if (format1 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(oop, GIV(weaklingStack));
				goto l1;
			}
			if ((format1 == 5)
			 && (activeAndDeferredScan(oop))) {
				goto l1;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan = oop;
			do {
				if ((objToScan & (tagMask())) != 0) {
					scanLargeObject = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt = (((usqInt) (longAt(objToScan))) >> (formatShift())) & (formatMask());
					assert((fmt != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan))));
					if (fmt <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan)) > (isForwardedObjectClassIndexPun()));
						numSlots1 = byteAt(objToScan + 7);
						numSlots = (numSlots1 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan - BaseHeaderSize))) << 8)))) >> 8
							: numSlots1);
						if (fmt <= 2) {
							numStrongSlots = numSlots;
							goto l5;
						}
						if (fmt == (indexablePointersFormat())) {
							if (((longAt(objToScan)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan);
								/* begin fetchStackPointerOf: */
								sp = longAt((objToScan + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp) & 7) == 1))) {
									contextSize = 0;
									goto l4;
								}
								assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan)));
								contextSize = (sp >> 3);
							l4:	/* end fetchStackPointerOf: */;
								numStrongSlots = CtxtTempFrameStart + contextSize;
								goto l5;
							}
							numStrongSlots = numSlots;
							goto l5;
						}
						if (fmt == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop1 = fetchClassOfNonImm(objToScan);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots = (((longAt((objOop1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l5;
						}
					}
					if (fmt == 7) {
						numStrongSlots = 1;
						goto l5;
					}
					if (fmt < (firstCompiledMethodFormat())) {
						numStrongSlots = 0;
						goto l5;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan));
					header = longAt((objToScan + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header) & 7) == 1));
					numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots = numLiterals + LiteralStart;
				l5:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject = numStrongSlots > 64;
				}
				if (scanLargeObject) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan & (tagMask())) != 0) {
						index = (objToScan >> 3);
						objToScan = topOfObjStack(GIV(markStack));
					}
					else {
						index = numStrongSlots;
						markAndTraceClassOf(objToScan);
					}
					while (index > 0) {
						index -= 1;
						field = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
						if ((field & (tagMask())) == 0) {
							if (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
							}
							if ((field & (tagMask())) != 0) {
								goto l3;
							}
							assert(!(isForwarded(field)));
							if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
								goto l3;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field)));
							longAtput(field, (longAt(field)) | (1LL << 55));
							format11 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
							if ((format11 >= (sixtyFourBitIndexableFormat()))
							 && (format11 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field);
								}
								goto l3;
							}
							if (format11 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field, GIV(weaklingStack));
								goto l3;
							}
							if ((format11 == 5)
							 && (activeAndDeferredScan(field))) {
								goto l3;
							}
							/* end markAndShouldScan:; fall through */
							if (index > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan) {
									pushonObjStack(objToScan, GIV(markStack));
								}
								pushonObjStack(((index << 3) | 1), GIV(markStack));
							}
							objToScan = field;
							index = -1;
						l3:	;

						}
					}
					if (index >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan = popObjStack(GIV(markStack));
						if (objToScan == oop) {
							objToScan = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index = numStrongSlots;
					markAndTraceClassOf(objToScan);
					while (index > 0) {
						index -= 1;
						field = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
						if ((field & (tagMask())) == 0) {
							if (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
							}
							if ((field & (tagMask())) != 0) {
								goto l2;
							}
							assert(!(isForwarded(field)));
							if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
								goto l2;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field)));
							longAtput(field, (longAt(field)) | (1LL << 55));
							format11 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
							if ((format11 >= (sixtyFourBitIndexableFormat()))
							 && (format11 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field);
								}
								goto l2;
							}
							if (format11 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field, GIV(weaklingStack));
								goto l2;
							}
							if ((format11 == 5)
							 && (activeAndDeferredScan(field))) {
								goto l2;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field, GIV(markStack));
							if (((byteAt(field + 7)) > 64)
							 && (((numStrongSlots = numStrongSlotsOfInephemeral(field))) > 64)) {
								pushonObjStack(((numStrongSlots << 3) | 1), GIV(markStack));
							}
						l2:	;

						}
					}
					objToScan = popObjStack(GIV(markStack));
				}
			} while(objToScan != null);
		l1:	/* end markAndTrace: */;
		}
	}
	assert(validClassTableRootPages());
	/* begin markAndTraceInterpreterOops: */
	markAndTraceStackPages(1);
	/* begin markAndTrace: */
	objOop3 = GIV(specialObjectsOop);

	/* inline markAndShouldScan: */
	if ((objOop3 & (tagMask())) != 0) {
		goto l39;
	}
	assert(!(isForwarded(objOop3)));
	if (((((usqInt) (longAt(objOop3))) >> 55) & 1) != 0) {
		goto l39;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop3)));
	longAtput(objOop3, (longAt(objOop3)) | (1LL << 55));
	format16 = (((usqInt) (longAt(objOop3))) >> (formatShift())) & (formatMask());
	if ((format16 >= (sixtyFourBitIndexableFormat()))
	 && (format16 < (firstCompiledMethodFormat()))) {

		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if (((longAt(objOop3)) & (classIndexMask())) > 0x1F) {
			markAndTraceClassOf(objOop3);
		}
		goto l39;
	}
	if (format16 == (weakArrayFormat())) {

		/* push weaklings on the weakling stack to scan later */
		pushonObjStack(objOop3, GIV(weaklingStack));
		goto l39;
	}
	if ((format16 == 5)
	 && (activeAndDeferredScan(objOop3))) {
		goto l39;
	}
	/* end markAndShouldScan:; fall through */
;
	/* begin markLoopFrom: */

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan6 = objOop3;
	do {
		if ((objToScan6 & (tagMask())) != 0) {
			scanLargeObject6 = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt7 = (((usqInt) (longAt(objToScan6))) >> (formatShift())) & (formatMask());
			assert((fmt7 != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan6))));
			if (fmt7 <= 5) {
				/* begin numSlotsOf: */
				flag("endianness");
				assert((classIndexOf(objToScan6)) > (isForwardedObjectClassIndexPun()));
				numSlots17 = byteAt(objToScan6 + 7);
				numSlots8 = (numSlots17 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objToScan6 - BaseHeaderSize))) << 8)))) >> 8
					: numSlots17);
				if (fmt7 <= 2) {
					numStrongSlots6 = numSlots8;
					goto l23;
				}
				if (fmt7 == (indexablePointersFormat())) {
					if (((longAt(objToScan6)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objToScan6);
						/* begin fetchStackPointerOf: */
						sp7 = longAt((objToScan6 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
						if (!((((sp7) & 7) == 1))) {
							contextSize7 = 0;
							goto l22;
						}
						assert((ReceiverIndex + ((sp7 >> 3))) < (lengthOf(objToScan6)));
						contextSize7 = (sp7 >> 3);
					l22:	/* end fetchStackPointerOf: */;
						numStrongSlots6 = CtxtTempFrameStart + contextSize7;
						goto l23;
					}
					numStrongSlots6 = numSlots8;
					goto l23;
				}
				if (fmt7 == (weakArrayFormat())) {
					/* begin fixedFieldsOfClass: */
					objOop111 = fetchClassOfNonImm(objToScan6);
					/* begin fixedFieldsOfClassFormat: */
					numStrongSlots6 = (((longAt((objOop111 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
					goto l23;
				}
			}
			if (fmt7 == 7) {
				numStrongSlots6 = 1;
				goto l23;
			}
			if (fmt7 < (firstCompiledMethodFormat())) {
				numStrongSlots6 = 0;
				goto l23;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objToScan6));
			header7 = longAt((objToScan6 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
			/* begin literalCountOfMethodHeader: */
			assert((((header7) & 7) == 1));
			numLiterals7 = ((header7 >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots6 = numLiterals7 + LiteralStart;
		l23:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject6 = numStrongSlots6 > 64;
		}
		if (scanLargeObject6) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if ((objToScan6 & (tagMask())) != 0) {
				index6 = (objToScan6 >> 3);
				objToScan6 = topOfObjStack(GIV(markStack));
			}
			else {
				index6 = numStrongSlots6;
				markAndTraceClassOf(objToScan6);
			}
			while (index6 > 0) {
				index6 -= 1;
				field6 = longAt((objToScan6 + BaseHeaderSize) + (((long)index6) << (shiftForWord())));
				if ((field6 & (tagMask())) == 0) {
					if (((longAt(field6)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field6 = fixFollowedFieldofObjectwithInitialValue(index6, objToScan6, field6);
					}
					if ((field6 & (tagMask())) != 0) {
						goto l20;
					}
					assert(!(isForwarded(field6)));
					if (((((usqInt) (longAt(field6))) >> 55) & 1) != 0) {
						goto l20;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field6)));
					longAtput(field6, (longAt(field6)) | (1LL << 55));
					format113 = (((usqInt) (longAt(field6))) >> (formatShift())) & (formatMask());
					if ((format113 >= (sixtyFourBitIndexableFormat()))
					 && (format113 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field6)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field6);
						}
						goto l20;
					}
					if (format113 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field6, GIV(weaklingStack));
						goto l20;
					}
					if ((format113 == 5)
					 && (activeAndDeferredScan(field6))) {
						goto l20;
					}
					/* end markAndShouldScan:; fall through */
					if (index6 > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan6) {
							pushonObjStack(objToScan6, GIV(markStack));
						}
						pushonObjStack(((index6 << 3) | 1), GIV(markStack));
					}
					objToScan6 = field6;
					index6 = -1;
				l20:	;

				}
			}
			if (index6 >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan6 = popObjStack(GIV(markStack));
				if (objToScan6 == objOop3) {
					objToScan6 = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index6 = numStrongSlots6;
			markAndTraceClassOf(objToScan6);
			while (index6 > 0) {
				index6 -= 1;
				field6 = longAt((objToScan6 + BaseHeaderSize) + (((long)index6) << (shiftForWord())));
				if ((field6 & (tagMask())) == 0) {
					if (((longAt(field6)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field6 = fixFollowedFieldofObjectwithInitialValue(index6, objToScan6, field6);
					}
					if ((field6 & (tagMask())) != 0) {
						goto l21;
					}
					assert(!(isForwarded(field6)));
					if (((((usqInt) (longAt(field6))) >> 55) & 1) != 0) {
						goto l21;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field6)));
					longAtput(field6, (longAt(field6)) | (1LL << 55));
					format113 = (((usqInt) (longAt(field6))) >> (formatShift())) & (formatMask());
					if ((format113 >= (sixtyFourBitIndexableFormat()))
					 && (format113 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field6)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field6);
						}
						goto l21;
					}
					if (format113 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field6, GIV(weaklingStack));
						goto l21;
					}
					if ((format113 == 5)
					 && (activeAndDeferredScan(field6))) {
						goto l21;
					}
					/* end markAndShouldScan:; fall through */
					pushonObjStack(field6, GIV(markStack));
					if (((byteAt(field6 + 7)) > 64)
					 && (((numStrongSlots6 = numStrongSlotsOfInephemeral(field6))) > 64)) {
						pushonObjStack(((numStrongSlots6 << 3) | 1), GIV(markStack));
					}
				l21:	;

				}
			}
			objToScan6 = popObjStack(GIV(markStack));
		}
	} while(objToScan6 != null);
l39:	/* end markAndTrace: */;
	if (!((GIV(newMethod) & (tagMask())) != 0)) {
		/* begin markAndTrace: */
		objOop4 = GIV(newMethod);

		/* inline markAndShouldScan: */
		if ((objOop4 & (tagMask())) != 0) {
			goto l51;
		}
		assert(!(isForwarded(objOop4)));
		if (((((usqInt) (longAt(objOop4))) >> 55) & 1) != 0) {
			goto l51;
		}
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(objOop4)));
		longAtput(objOop4, (longAt(objOop4)) | (1LL << 55));
		format114 = (((usqInt) (longAt(objOop4))) >> (formatShift())) & (formatMask());
		if ((format114 >= (sixtyFourBitIndexableFormat()))
		 && (format114 < (firstCompiledMethodFormat()))) {

			/* avoid pushing non-pointer objects on the markStack. */
			/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
			if (((longAt(objOop4)) & (classIndexMask())) > 0x1F) {
				markAndTraceClassOf(objOop4);
			}
			goto l51;
		}
		if (format114 == (weakArrayFormat())) {

			/* push weaklings on the weakling stack to scan later */
			pushonObjStack(objOop4, GIV(weaklingStack));
			goto l51;
		}
		if ((format114 == 5)
		 && (activeAndDeferredScan(objOop4))) {
			goto l51;
		}
		/* end markAndShouldScan:; fall through */
;
		/* begin markLoopFrom: */

		/* To avoid overflowing the mark stack when we encounter large objects, we
		   push the obj, then its numStrongSlots, and then index the object from the stack. */
		objToScan7 = objOop4;
		do {
			if ((objToScan7 & (tagMask())) != 0) {
				scanLargeObject7 = 1;
			}
			else {
				/* begin numStrongSlotsOfInephemeral: */
				fmt11 = (((usqInt) (longAt(objToScan7))) >> (formatShift())) & (formatMask());
				assert((fmt11 != (ephemeronFormat()))
				 || (isMarked(keyOfEphemeron(objToScan7))));
				if (fmt11 <= 5) {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objToScan7)) > (isForwardedObjectClassIndexPun()));
					numSlots111 = byteAt(objToScan7 + 7);
					numSlots21 = (numSlots111 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objToScan7 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots111);
					if (fmt11 <= 2) {
						numStrongSlots7 = numSlots21;
						goto l25;
					}
					if (fmt11 == (indexablePointersFormat())) {
						if (((longAt(objToScan7)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
							setTraceFlagOnContextsFramesPageIfNeeded(objToScan7);
							/* begin fetchStackPointerOf: */
							sp11 = longAt((objToScan7 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
							if (!((((sp11) & 7) == 1))) {
								contextSize11 = 0;
								goto l24;
							}
							assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(objToScan7)));
							contextSize11 = (sp11 >> 3);
						l24:	/* end fetchStackPointerOf: */;
							numStrongSlots7 = CtxtTempFrameStart + contextSize11;
							goto l25;
						}
						numStrongSlots7 = numSlots21;
						goto l25;
					}
					if (fmt11 == (weakArrayFormat())) {
						/* begin fixedFieldsOfClass: */
						objOop121 = fetchClassOfNonImm(objToScan7);
						/* begin fixedFieldsOfClassFormat: */
						numStrongSlots7 = (((longAt((objOop121 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						goto l25;
					}
				}
				if (fmt11 == 7) {
					numStrongSlots7 = 1;
					goto l25;
				}
				if (fmt11 < (firstCompiledMethodFormat())) {
					numStrongSlots7 = 0;
					goto l25;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objToScan7));
				header11 = longAt((objToScan7 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				/* begin literalCountOfMethodHeader: */
				assert((((header11) & 7) == 1));
				numLiterals11 = ((header11 >> 3)) & AlternateHeaderNumLiteralsMask;
				numStrongSlots7 = numLiterals11 + LiteralStart;
			l25:	/* end numStrongSlotsOfInephemeral: */;
				scanLargeObject7 = numStrongSlots7 > 64;
			}
			if (scanLargeObject7) {

				/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
				if ((objToScan7 & (tagMask())) != 0) {
					index7 = (objToScan7 >> 3);
					objToScan7 = topOfObjStack(GIV(markStack));
				}
				else {
					index7 = numStrongSlots7;
					markAndTraceClassOf(objToScan7);
				}
				while (index7 > 0) {
					index7 -= 1;
					field7 = longAt((objToScan7 + BaseHeaderSize) + (((long)index7) << (shiftForWord())));
					if ((field7 & (tagMask())) == 0) {
						if (((longAt(field7)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field7 = fixFollowedFieldofObjectwithInitialValue(index7, objToScan7, field7);
						}
						if ((field7 & (tagMask())) != 0) {
							goto l37;
						}
						assert(!(isForwarded(field7)));
						if (((((usqInt) (longAt(field7))) >> 55) & 1) != 0) {
							goto l37;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field7)));
						longAtput(field7, (longAt(field7)) | (1LL << 55));
						format17 = (((usqInt) (longAt(field7))) >> (formatShift())) & (formatMask());
						if ((format17 >= (sixtyFourBitIndexableFormat()))
						 && (format17 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field7)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field7);
							}
							goto l37;
						}
						if (format17 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field7, GIV(weaklingStack));
							goto l37;
						}
						if ((format17 == 5)
						 && (activeAndDeferredScan(field7))) {
							goto l37;
						}
						/* end markAndShouldScan:; fall through */
						if (index7 > 0) {
							if ((topOfObjStack(GIV(markStack))) != objToScan7) {
								pushonObjStack(objToScan7, GIV(markStack));
							}
							pushonObjStack(((index7 << 3) | 1), GIV(markStack));
						}
						objToScan7 = field7;
						index7 = -1;
					l37:	;

					}
				}
				if (index7 >= 0) {

					/* if loop terminated without finding an unmarked referent, switch to top of stack. */
					objToScan7 = popObjStack(GIV(markStack));
					if (objToScan7 == objOop4) {
						objToScan7 = popObjStack(GIV(markStack));
					}
				}
			}
			else {

				/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
				index7 = numStrongSlots7;
				markAndTraceClassOf(objToScan7);
				while (index7 > 0) {
					index7 -= 1;
					field7 = longAt((objToScan7 + BaseHeaderSize) + (((long)index7) << (shiftForWord())));
					if ((field7 & (tagMask())) == 0) {
						if (((longAt(field7)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field7 = fixFollowedFieldofObjectwithInitialValue(index7, objToScan7, field7);
						}
						if ((field7 & (tagMask())) != 0) {
							goto l36;
						}
						assert(!(isForwarded(field7)));
						if (((((usqInt) (longAt(field7))) >> 55) & 1) != 0) {
							goto l36;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field7)));
						longAtput(field7, (longAt(field7)) | (1LL << 55));
						format17 = (((usqInt) (longAt(field7))) >> (formatShift())) & (formatMask());
						if ((format17 >= (sixtyFourBitIndexableFormat()))
						 && (format17 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field7)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field7);
							}
							goto l36;
						}
						if (format17 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field7, GIV(weaklingStack));
							goto l36;
						}
						if ((format17 == 5)
						 && (activeAndDeferredScan(field7))) {
							goto l36;
						}
						/* end markAndShouldScan:; fall through */
						pushonObjStack(field7, GIV(markStack));
						if (((byteAt(field7 + 7)) > 64)
						 && (((numStrongSlots7 = numStrongSlotsOfInephemeral(field7))) > 64)) {
							pushonObjStack(((numStrongSlots7 << 3) | 1), GIV(markStack));
						}
					l36:	;

					}
				}
				objToScan7 = popObjStack(GIV(markStack));
			}
		} while(objToScan7 != null);
	l51:	/* end markAndTrace: */;
	}
	/* begin traceProfileState */
	/* begin followForwardingPointersInProfileState */
	if (((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileProcess)));
		referent = longAt((GIV(profileProcess) + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		GIV(profileProcess) = referent;
	}
	if (((longAt(GIV(profileMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileMethod)));
		referent1 = longAt((GIV(profileMethod) + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent1 & (tagMask())) == 0)
		 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		GIV(profileMethod) = referent1;
	}
	if (((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileSemaphore)));
		referent2 = longAt((GIV(profileSemaphore) + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent2 & (tagMask())) == 0)
		 && (((longAt(referent2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent2 = longAt((referent2 + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		GIV(profileSemaphore) = referent2;
	}

	/* begin markAndTrace: */
	objOop22 = GIV(profileProcess);

	/* inline markAndShouldScan: */
	if ((objOop22 & (tagMask())) != 0) {
		goto l69;
	}
	assert(!(isForwarded(objOop22)));
	if (((((usqInt) (longAt(objOop22))) >> 55) & 1) != 0) {
		goto l69;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop22)));
	longAtput(objOop22, (longAt(objOop22)) | (1LL << 55));
	format122 = (((usqInt) (longAt(objOop22))) >> (formatShift())) & (formatMask());
	if ((format122 >= (sixtyFourBitIndexableFormat()))
	 && (format122 < (firstCompiledMethodFormat()))) {

		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if (((longAt(objOop22)) & (classIndexMask())) > 0x1F) {
			markAndTraceClassOf(objOop22);
		}
		goto l69;
	}
	if (format122 == (weakArrayFormat())) {

		/* push weaklings on the weakling stack to scan later */
		pushonObjStack(objOop22, GIV(weaklingStack));
		goto l69;
	}
	if ((format122 == 5)
	 && (activeAndDeferredScan(objOop22))) {
		goto l69;
	}
	/* end markAndShouldScan:; fall through */
;
	/* begin markLoopFrom: */

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan22 = objOop22;
	do {
		if ((objToScan22 & (tagMask())) != 0) {
			scanLargeObject22 = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt8 = (((usqInt) (longAt(objToScan22))) >> (formatShift())) & (formatMask());
			assert((fmt8 != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan22))));
			if (fmt8 <= 5) {
				/* begin numSlotsOf: */
				flag("endianness");
				assert((classIndexOf(objToScan22)) > (isForwardedObjectClassIndexPun()));
				numSlots18 = byteAt(objToScan22 + 7);
				numSlots9 = (numSlots18 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objToScan22 - BaseHeaderSize))) << 8)))) >> 8
					: numSlots18);
				if (fmt8 <= 2) {
					numStrongSlots22 = numSlots9;
					goto l74;
				}
				if (fmt8 == (indexablePointersFormat())) {
					if (((longAt(objToScan22)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objToScan22);
						/* begin fetchStackPointerOf: */
						sp8 = longAt((objToScan22 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
						if (!((((sp8) & 7) == 1))) {
							contextSize8 = 0;
							goto l53;
						}
						assert((ReceiverIndex + ((sp8 >> 3))) < (lengthOf(objToScan22)));
						contextSize8 = (sp8 >> 3);
					l53:	/* end fetchStackPointerOf: */;
						numStrongSlots22 = CtxtTempFrameStart + contextSize8;
						goto l74;
					}
					numStrongSlots22 = numSlots9;
					goto l74;
				}
				if (fmt8 == (weakArrayFormat())) {
					/* begin fixedFieldsOfClass: */
					objOop112 = fetchClassOfNonImm(objToScan22);
					/* begin fixedFieldsOfClassFormat: */
					numStrongSlots22 = (((longAt((objOop112 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
					goto l74;
				}
			}
			if (fmt8 == 7) {
				numStrongSlots22 = 1;
				goto l74;
			}
			if (fmt8 < (firstCompiledMethodFormat())) {
				numStrongSlots22 = 0;
				goto l74;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objToScan22));
			header8 = longAt((objToScan22 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
			/* begin literalCountOfMethodHeader: */
			assert((((header8) & 7) == 1));
			numLiterals8 = ((header8 >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots22 = numLiterals8 + LiteralStart;
		l74:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject22 = numStrongSlots22 > 64;
		}
		if (scanLargeObject22) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if ((objToScan22 & (tagMask())) != 0) {
				index22 = (objToScan22 >> 3);
				objToScan22 = topOfObjStack(GIV(markStack));
			}
			else {
				index22 = numStrongSlots22;
				markAndTraceClassOf(objToScan22);
			}
			while (index22 > 0) {
				index22 -= 1;
				field22 = longAt((objToScan22 + BaseHeaderSize) + (((long)index22) << (shiftForWord())));
				if ((field22 & (tagMask())) == 0) {
					if (((longAt(field22)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field22 = fixFollowedFieldofObjectwithInitialValue(index22, objToScan22, field22);
					}
					if ((field22 & (tagMask())) != 0) {
						goto l70;
					}
					assert(!(isForwarded(field22)));
					if (((((usqInt) (longAt(field22))) >> 55) & 1) != 0) {
						goto l70;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field22)));
					longAtput(field22, (longAt(field22)) | (1LL << 55));
					format171 = (((usqInt) (longAt(field22))) >> (formatShift())) & (formatMask());
					if ((format171 >= (sixtyFourBitIndexableFormat()))
					 && (format171 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field22)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field22);
						}
						goto l70;
					}
					if (format171 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field22, GIV(weaklingStack));
						goto l70;
					}
					if ((format171 == 5)
					 && (activeAndDeferredScan(field22))) {
						goto l70;
					}
					/* end markAndShouldScan:; fall through */
					if (index22 > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan22) {
							pushonObjStack(objToScan22, GIV(markStack));
						}
						pushonObjStack(((index22 << 3) | 1), GIV(markStack));
					}
					objToScan22 = field22;
					index22 = -1;
				l70:	;

				}
			}
			if (index22 >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan22 = popObjStack(GIV(markStack));
				if (objToScan22 == objOop22) {
					objToScan22 = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index22 = numStrongSlots22;
			markAndTraceClassOf(objToScan22);
			while (index22 > 0) {
				index22 -= 1;
				field22 = longAt((objToScan22 + BaseHeaderSize) + (((long)index22) << (shiftForWord())));
				if ((field22 & (tagMask())) == 0) {
					if (((longAt(field22)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field22 = fixFollowedFieldofObjectwithInitialValue(index22, objToScan22, field22);
					}
					if ((field22 & (tagMask())) != 0) {
						goto l66;
					}
					assert(!(isForwarded(field22)));
					if (((((usqInt) (longAt(field22))) >> 55) & 1) != 0) {
						goto l66;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field22)));
					longAtput(field22, (longAt(field22)) | (1LL << 55));
					format171 = (((usqInt) (longAt(field22))) >> (formatShift())) & (formatMask());
					if ((format171 >= (sixtyFourBitIndexableFormat()))
					 && (format171 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field22)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field22);
						}
						goto l66;
					}
					if (format171 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field22, GIV(weaklingStack));
						goto l66;
					}
					if ((format171 == 5)
					 && (activeAndDeferredScan(field22))) {
						goto l66;
					}
					/* end markAndShouldScan:; fall through */
					pushonObjStack(field22, GIV(markStack));
					if (((byteAt(field22 + 7)) > 64)
					 && (((numStrongSlots22 = numStrongSlotsOfInephemeral(field22))) > 64)) {
						pushonObjStack(((numStrongSlots22 << 3) | 1), GIV(markStack));
					}
				l66:	;

				}
			}
			objToScan22 = popObjStack(GIV(markStack));
		}
	} while(objToScan22 != null);
l69:	/* end markAndTrace: */;
	/* begin markAndTrace: */
	objOop31 = GIV(profileMethod);

	/* inline markAndShouldScan: */
	if ((objOop31 & (tagMask())) != 0) {
		goto l65;
	}
	assert(!(isForwarded(objOop31)));
	if (((((usqInt) (longAt(objOop31))) >> 55) & 1) != 0) {
		goto l65;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop31)));
	longAtput(objOop31, (longAt(objOop31)) | (1LL << 55));
	format132 = (((usqInt) (longAt(objOop31))) >> (formatShift())) & (formatMask());
	if ((format132 >= (sixtyFourBitIndexableFormat()))
	 && (format132 < (firstCompiledMethodFormat()))) {

		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if (((longAt(objOop31)) & (classIndexMask())) > 0x1F) {
			markAndTraceClassOf(objOop31);
		}
		goto l65;
	}
	if (format132 == (weakArrayFormat())) {

		/* push weaklings on the weakling stack to scan later */
		pushonObjStack(objOop31, GIV(weaklingStack));
		goto l65;
	}
	if ((format132 == 5)
	 && (activeAndDeferredScan(objOop31))) {
		goto l65;
	}
	/* end markAndShouldScan:; fall through */
;
	/* begin markLoopFrom: */

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan31 = objOop31;
	do {
		if ((objToScan31 & (tagMask())) != 0) {
			scanLargeObject31 = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt12 = (((usqInt) (longAt(objToScan31))) >> (formatShift())) & (formatMask());
			assert((fmt12 != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan31))));
			if (fmt12 <= 5) {
				/* begin numSlotsOf: */
				flag("endianness");
				assert((classIndexOf(objToScan31)) > (isForwardedObjectClassIndexPun()));
				numSlots112 = byteAt(objToScan31 + 7);
				numSlots22 = (numSlots112 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objToScan31 - BaseHeaderSize))) << 8)))) >> 8
					: numSlots112);
				if (fmt12 <= 2) {
					numStrongSlots31 = numSlots22;
					goto l67;
				}
				if (fmt12 == (indexablePointersFormat())) {
					if (((longAt(objToScan31)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objToScan31);
						/* begin fetchStackPointerOf: */
						sp12 = longAt((objToScan31 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
						if (!((((sp12) & 7) == 1))) {
							contextSize12 = 0;
							goto l71;
						}
						assert((ReceiverIndex + ((sp12 >> 3))) < (lengthOf(objToScan31)));
						contextSize12 = (sp12 >> 3);
					l71:	/* end fetchStackPointerOf: */;
						numStrongSlots31 = CtxtTempFrameStart + contextSize12;
						goto l67;
					}
					numStrongSlots31 = numSlots22;
					goto l67;
				}
				if (fmt12 == (weakArrayFormat())) {
					/* begin fixedFieldsOfClass: */
					objOop122 = fetchClassOfNonImm(objToScan31);
					/* begin fixedFieldsOfClassFormat: */
					numStrongSlots31 = (((longAt((objOop122 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
					goto l67;
				}
			}
			if (fmt12 == 7) {
				numStrongSlots31 = 1;
				goto l67;
			}
			if (fmt12 < (firstCompiledMethodFormat())) {
				numStrongSlots31 = 0;
				goto l67;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objToScan31));
			header12 = longAt((objToScan31 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
			/* begin literalCountOfMethodHeader: */
			assert((((header12) & 7) == 1));
			numLiterals12 = ((header12 >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots31 = numLiterals12 + LiteralStart;
		l67:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject31 = numStrongSlots31 > 64;
		}
		if (scanLargeObject31) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if ((objToScan31 & (tagMask())) != 0) {
				index31 = (objToScan31 >> 3);
				objToScan31 = topOfObjStack(GIV(markStack));
			}
			else {
				index31 = numStrongSlots31;
				markAndTraceClassOf(objToScan31);
			}
			while (index31 > 0) {
				index31 -= 1;
				field31 = longAt((objToScan31 + BaseHeaderSize) + (((long)index31) << (shiftForWord())));
				if ((field31 & (tagMask())) == 0) {
					if (((longAt(field31)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field31 = fixFollowedFieldofObjectwithInitialValue(index31, objToScan31, field31);
					}
					if ((field31 & (tagMask())) != 0) {
						goto l63;
					}
					assert(!(isForwarded(field31)));
					if (((((usqInt) (longAt(field31))) >> 55) & 1) != 0) {
						goto l63;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field31)));
					longAtput(field31, (longAt(field31)) | (1LL << 55));
					format181 = (((usqInt) (longAt(field31))) >> (formatShift())) & (formatMask());
					if ((format181 >= (sixtyFourBitIndexableFormat()))
					 && (format181 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field31)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field31);
						}
						goto l63;
					}
					if (format181 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field31, GIV(weaklingStack));
						goto l63;
					}
					if ((format181 == 5)
					 && (activeAndDeferredScan(field31))) {
						goto l63;
					}
					/* end markAndShouldScan:; fall through */
					if (index31 > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan31) {
							pushonObjStack(objToScan31, GIV(markStack));
						}
						pushonObjStack(((index31 << 3) | 1), GIV(markStack));
					}
					objToScan31 = field31;
					index31 = -1;
				l63:	;

				}
			}
			if (index31 >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan31 = popObjStack(GIV(markStack));
				if (objToScan31 == objOop31) {
					objToScan31 = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index31 = numStrongSlots31;
			markAndTraceClassOf(objToScan31);
			while (index31 > 0) {
				index31 -= 1;
				field31 = longAt((objToScan31 + BaseHeaderSize) + (((long)index31) << (shiftForWord())));
				if ((field31 & (tagMask())) == 0) {
					if (((longAt(field31)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field31 = fixFollowedFieldofObjectwithInitialValue(index31, objToScan31, field31);
					}
					if ((field31 & (tagMask())) != 0) {
						goto l62;
					}
					assert(!(isForwarded(field31)));
					if (((((usqInt) (longAt(field31))) >> 55) & 1) != 0) {
						goto l62;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field31)));
					longAtput(field31, (longAt(field31)) | (1LL << 55));
					format181 = (((usqInt) (longAt(field31))) >> (formatShift())) & (formatMask());
					if ((format181 >= (sixtyFourBitIndexableFormat()))
					 && (format181 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field31)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field31);
						}
						goto l62;
					}
					if (format181 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field31, GIV(weaklingStack));
						goto l62;
					}
					if ((format181 == 5)
					 && (activeAndDeferredScan(field31))) {
						goto l62;
					}
					/* end markAndShouldScan:; fall through */
					pushonObjStack(field31, GIV(markStack));
					if (((byteAt(field31 + 7)) > 64)
					 && (((numStrongSlots31 = numStrongSlotsOfInephemeral(field31))) > 64)) {
						pushonObjStack(((numStrongSlots31 << 3) | 1), GIV(markStack));
					}
				l62:	;

				}
			}
			objToScan31 = popObjStack(GIV(markStack));
		}
	} while(objToScan31 != null);
l65:	/* end markAndTrace: */;
	/* begin markAndTrace: */
	objOop41 = GIV(profileSemaphore);

	/* inline markAndShouldScan: */
	if ((objOop41 & (tagMask())) != 0) {
		goto l64;
	}
	assert(!(isForwarded(objOop41)));
	if (((((usqInt) (longAt(objOop41))) >> 55) & 1) != 0) {
		goto l64;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop41)));
	longAtput(objOop41, (longAt(objOop41)) | (1LL << 55));
	format142 = (((usqInt) (longAt(objOop41))) >> (formatShift())) & (formatMask());
	if ((format142 >= (sixtyFourBitIndexableFormat()))
	 && (format142 < (firstCompiledMethodFormat()))) {

		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if (((longAt(objOop41)) & (classIndexMask())) > 0x1F) {
			markAndTraceClassOf(objOop41);
		}
		goto l64;
	}
	if (format142 == (weakArrayFormat())) {

		/* push weaklings on the weakling stack to scan later */
		pushonObjStack(objOop41, GIV(weaklingStack));
		goto l64;
	}
	if ((format142 == 5)
	 && (activeAndDeferredScan(objOop41))) {
		goto l64;
	}
	/* end markAndShouldScan:; fall through */
;
	/* begin markLoopFrom: */

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan41 = objOop41;
	do {
		if ((objToScan41 & (tagMask())) != 0) {
			scanLargeObject41 = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt22 = (((usqInt) (longAt(objToScan41))) >> (formatShift())) & (formatMask());
			assert((fmt22 != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan41))));
			if (fmt22 <= 5) {
				/* begin numSlotsOf: */
				flag("endianness");
				assert((classIndexOf(objToScan41)) > (isForwardedObjectClassIndexPun()));
				numSlots122 = byteAt(objToScan41 + 7);
				numSlots32 = (numSlots122 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objToScan41 - BaseHeaderSize))) << 8)))) >> 8
					: numSlots122);
				if (fmt22 <= 2) {
					numStrongSlots41 = numSlots32;
					goto l57;
				}
				if (fmt22 == (indexablePointersFormat())) {
					if (((longAt(objToScan41)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objToScan41);
						/* begin fetchStackPointerOf: */
						sp22 = longAt((objToScan41 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
						if (!((((sp22) & 7) == 1))) {
							contextSize22 = 0;
							goto l60;
						}
						assert((ReceiverIndex + ((sp22 >> 3))) < (lengthOf(objToScan41)));
						contextSize22 = (sp22 >> 3);
					l60:	/* end fetchStackPointerOf: */;
						numStrongSlots41 = CtxtTempFrameStart + contextSize22;
						goto l57;
					}
					numStrongSlots41 = numSlots32;
					goto l57;
				}
				if (fmt22 == (weakArrayFormat())) {
					/* begin fixedFieldsOfClass: */
					objOop132 = fetchClassOfNonImm(objToScan41);
					/* begin fixedFieldsOfClassFormat: */
					numStrongSlots41 = (((longAt((objOop132 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
					goto l57;
				}
			}
			if (fmt22 == 7) {
				numStrongSlots41 = 1;
				goto l57;
			}
			if (fmt22 < (firstCompiledMethodFormat())) {
				numStrongSlots41 = 0;
				goto l57;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objToScan41));
			header22 = longAt((objToScan41 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
			/* begin literalCountOfMethodHeader: */
			assert((((header22) & 7) == 1));
			numLiterals22 = ((header22 >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots41 = numLiterals22 + LiteralStart;
		l57:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject41 = numStrongSlots41 > 64;
		}
		if (scanLargeObject41) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if ((objToScan41 & (tagMask())) != 0) {
				index41 = (objToScan41 >> 3);
				objToScan41 = topOfObjStack(GIV(markStack));
			}
			else {
				index41 = numStrongSlots41;
				markAndTraceClassOf(objToScan41);
			}
			while (index41 > 0) {
				index41 -= 1;
				field41 = longAt((objToScan41 + BaseHeaderSize) + (((long)index41) << (shiftForWord())));
				if ((field41 & (tagMask())) == 0) {
					if (((longAt(field41)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field41 = fixFollowedFieldofObjectwithInitialValue(index41, objToScan41, field41);
					}
					if ((field41 & (tagMask())) != 0) {
						goto l59;
					}
					assert(!(isForwarded(field41)));
					if (((((usqInt) (longAt(field41))) >> 55) & 1) != 0) {
						goto l59;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field41)));
					longAtput(field41, (longAt(field41)) | (1LL << 55));
					format191 = (((usqInt) (longAt(field41))) >> (formatShift())) & (formatMask());
					if ((format191 >= (sixtyFourBitIndexableFormat()))
					 && (format191 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field41)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field41);
						}
						goto l59;
					}
					if (format191 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field41, GIV(weaklingStack));
						goto l59;
					}
					if ((format191 == 5)
					 && (activeAndDeferredScan(field41))) {
						goto l59;
					}
					/* end markAndShouldScan:; fall through */
					if (index41 > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan41) {
							pushonObjStack(objToScan41, GIV(markStack));
						}
						pushonObjStack(((index41 << 3) | 1), GIV(markStack));
					}
					objToScan41 = field41;
					index41 = -1;
				l59:	;

				}
			}
			if (index41 >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan41 = popObjStack(GIV(markStack));
				if (objToScan41 == objOop41) {
					objToScan41 = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index41 = numStrongSlots41;
			markAndTraceClassOf(objToScan41);
			while (index41 > 0) {
				index41 -= 1;
				field41 = longAt((objToScan41 + BaseHeaderSize) + (((long)index41) << (shiftForWord())));
				if ((field41 & (tagMask())) == 0) {
					if (((longAt(field41)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

						/* fixFollowedField: is /not/ inlined */
						field41 = fixFollowedFieldofObjectwithInitialValue(index41, objToScan41, field41);
					}
					if ((field41 & (tagMask())) != 0) {
						goto l55;
					}
					assert(!(isForwarded(field41)));
					if (((((usqInt) (longAt(field41))) >> 55) & 1) != 0) {
						goto l55;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field41)));
					longAtput(field41, (longAt(field41)) | (1LL << 55));
					format191 = (((usqInt) (longAt(field41))) >> (formatShift())) & (formatMask());
					if ((format191 >= (sixtyFourBitIndexableFormat()))
					 && (format191 < (firstCompiledMethodFormat()))) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field41)) & (classIndexMask())) > 0x1F) {
							markAndTraceClassOf(field41);
						}
						goto l55;
					}
					if (format191 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						pushonObjStack(field41, GIV(weaklingStack));
						goto l55;
					}
					if ((format191 == 5)
					 && (activeAndDeferredScan(field41))) {
						goto l55;
					}
					/* end markAndShouldScan:; fall through */
					pushonObjStack(field41, GIV(markStack));
					if (((byteAt(field41 + 7)) > 64)
					 && (((numStrongSlots41 = numStrongSlotsOfInephemeral(field41))) > 64)) {
						pushonObjStack(((numStrongSlots41 << 3) | 1), GIV(markStack));
					}
				l55:	;

				}
			}
			objToScan41 = popObjStack(GIV(markStack));
		}
	} while(objToScan41 != null);
l64:	/* end markAndTrace: */;
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveCheckMethod) != null)
	 && (GIV(longRunningPrimitiveCheckSequenceNumber) != GIV(statCheckForEvents))) {
		if (((longAt(GIV(longRunningPrimitiveCheckMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(longRunningPrimitiveCheckMethod)));
			referent3 = longAt((GIV(longRunningPrimitiveCheckMethod) + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent3 & (tagMask())) == 0)
			 && (((longAt(referent3)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent3 = longAt((referent3 + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			GIV(longRunningPrimitiveCheckMethod) = referent3;
		}
		/* begin markAndTrace: */
		objOop5 = GIV(longRunningPrimitiveCheckMethod);

		/* inline markAndShouldScan: */
		if ((objOop5 & (tagMask())) != 0) {
			goto l76;
		}
		assert(!(isForwarded(objOop5)));
		if (((((usqInt) (longAt(objOop5))) >> 55) & 1) != 0) {
			goto l76;
		}
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(objOop5)));
		longAtput(objOop5, (longAt(objOop5)) | (1LL << 55));
		format117 = (((usqInt) (longAt(objOop5))) >> (formatShift())) & (formatMask());
		if ((format117 >= (sixtyFourBitIndexableFormat()))
		 && (format117 < (firstCompiledMethodFormat()))) {

			/* avoid pushing non-pointer objects on the markStack. */
			/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
			if (((longAt(objOop5)) & (classIndexMask())) > 0x1F) {
				markAndTraceClassOf(objOop5);
			}
			goto l76;
		}
		if (format117 == (weakArrayFormat())) {

			/* push weaklings on the weakling stack to scan later */
			pushonObjStack(objOop5, GIV(weaklingStack));
			goto l76;
		}
		if ((format117 == 5)
		 && (activeAndDeferredScan(objOop5))) {
			goto l76;
		}
		/* end markAndShouldScan:; fall through */
;
		/* begin markLoopFrom: */

		/* To avoid overflowing the mark stack when we encounter large objects, we
		   push the obj, then its numStrongSlots, and then index the object from the stack. */
		objToScan8 = objOop5;
		do {
			if ((objToScan8 & (tagMask())) != 0) {
				scanLargeObject8 = 1;
			}
			else {
				/* begin numStrongSlotsOfInephemeral: */
				fmt31 = (((usqInt) (longAt(objToScan8))) >> (formatShift())) & (formatMask());
				assert((fmt31 != (ephemeronFormat()))
				 || (isMarked(keyOfEphemeron(objToScan8))));
				if (fmt31 <= 5) {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objToScan8)) > (isForwardedObjectClassIndexPun()));
					numSlots131 = byteAt(objToScan8 + 7);
					numSlots41 = (numSlots131 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objToScan8 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots131);
					if (fmt31 <= 2) {
						numStrongSlots8 = numSlots41;
						goto l75;
					}
					if (fmt31 == (indexablePointersFormat())) {
						if (((longAt(objToScan8)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
							setTraceFlagOnContextsFramesPageIfNeeded(objToScan8);
							/* begin fetchStackPointerOf: */
							sp31 = longAt((objToScan8 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
							if (!((((sp31) & 7) == 1))) {
								contextSize31 = 0;
								goto l54;
							}
							assert((ReceiverIndex + ((sp31 >> 3))) < (lengthOf(objToScan8)));
							contextSize31 = (sp31 >> 3);
						l54:	/* end fetchStackPointerOf: */;
							numStrongSlots8 = CtxtTempFrameStart + contextSize31;
							goto l75;
						}
						numStrongSlots8 = numSlots41;
						goto l75;
					}
					if (fmt31 == (weakArrayFormat())) {
						/* begin fixedFieldsOfClass: */
						objOop141 = fetchClassOfNonImm(objToScan8);
						/* begin fixedFieldsOfClassFormat: */
						numStrongSlots8 = (((longAt((objOop141 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						goto l75;
					}
				}
				if (fmt31 == 7) {
					numStrongSlots8 = 1;
					goto l75;
				}
				if (fmt31 < (firstCompiledMethodFormat())) {
					numStrongSlots8 = 0;
					goto l75;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objToScan8));
				header31 = longAt((objToScan8 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				/* begin literalCountOfMethodHeader: */
				assert((((header31) & 7) == 1));
				numLiterals31 = ((header31 >> 3)) & AlternateHeaderNumLiteralsMask;
				numStrongSlots8 = numLiterals31 + LiteralStart;
			l75:	/* end numStrongSlotsOfInephemeral: */;
				scanLargeObject8 = numStrongSlots8 > 64;
			}
			if (scanLargeObject8) {

				/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
				if ((objToScan8 & (tagMask())) != 0) {
					index8 = (objToScan8 >> 3);
					objToScan8 = topOfObjStack(GIV(markStack));
				}
				else {
					index8 = numStrongSlots8;
					markAndTraceClassOf(objToScan8);
				}
				while (index8 > 0) {
					index8 -= 1;
					field8 = longAt((objToScan8 + BaseHeaderSize) + (((long)index8) << (shiftForWord())));
					if ((field8 & (tagMask())) == 0) {
						if (((longAt(field8)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field8 = fixFollowedFieldofObjectwithInitialValue(index8, objToScan8, field8);
						}
						if ((field8 & (tagMask())) != 0) {
							goto l61;
						}
						assert(!(isForwarded(field8)));
						if (((((usqInt) (longAt(field8))) >> 55) & 1) != 0) {
							goto l61;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field8)));
						longAtput(field8, (longAt(field8)) | (1LL << 55));
						format151 = (((usqInt) (longAt(field8))) >> (formatShift())) & (formatMask());
						if ((format151 >= (sixtyFourBitIndexableFormat()))
						 && (format151 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field8)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field8);
							}
							goto l61;
						}
						if (format151 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field8, GIV(weaklingStack));
							goto l61;
						}
						if ((format151 == 5)
						 && (activeAndDeferredScan(field8))) {
							goto l61;
						}
						/* end markAndShouldScan:; fall through */
						if (index8 > 0) {
							if ((topOfObjStack(GIV(markStack))) != objToScan8) {
								pushonObjStack(objToScan8, GIV(markStack));
							}
							pushonObjStack(((index8 << 3) | 1), GIV(markStack));
						}
						objToScan8 = field8;
						index8 = -1;
					l61:	;

					}
				}
				if (index8 >= 0) {

					/* if loop terminated without finding an unmarked referent, switch to top of stack. */
					objToScan8 = popObjStack(GIV(markStack));
					if (objToScan8 == objOop5) {
						objToScan8 = popObjStack(GIV(markStack));
					}
				}
			}
			else {

				/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
				index8 = numStrongSlots8;
				markAndTraceClassOf(objToScan8);
				while (index8 > 0) {
					index8 -= 1;
					field8 = longAt((objToScan8 + BaseHeaderSize) + (((long)index8) << (shiftForWord())));
					if ((field8 & (tagMask())) == 0) {
						if (((longAt(field8)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field8 = fixFollowedFieldofObjectwithInitialValue(index8, objToScan8, field8);
						}
						if ((field8 & (tagMask())) != 0) {
							goto l58;
						}
						assert(!(isForwarded(field8)));
						if (((((usqInt) (longAt(field8))) >> 55) & 1) != 0) {
							goto l58;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field8)));
						longAtput(field8, (longAt(field8)) | (1LL << 55));
						format151 = (((usqInt) (longAt(field8))) >> (formatShift())) & (formatMask());
						if ((format151 >= (sixtyFourBitIndexableFormat()))
						 && (format151 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field8)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field8);
							}
							goto l58;
						}
						if (format151 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field8, GIV(weaklingStack));
							goto l58;
						}
						if ((format151 == 5)
						 && (activeAndDeferredScan(field8))) {
							goto l58;
						}
						/* end markAndShouldScan:; fall through */
						pushonObjStack(field8, GIV(markStack));
						if (((byteAt(field8 + 7)) > 64)
						 && (((numStrongSlots8 = numStrongSlotsOfInephemeral(field8))) > 64)) {
							pushonObjStack(((numStrongSlots8 << 3) | 1), GIV(markStack));
						}
					l58:	;

					}
				}
				objToScan8 = popObjStack(GIV(markStack));
			}
		} while(objToScan8 != null);
	l76:	/* end markAndTrace: */;
	}
	if (GIV(longRunningPrimitiveCheckSemaphore) != null) {
		if (((longAt(GIV(longRunningPrimitiveCheckSemaphore))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(longRunningPrimitiveCheckSemaphore)));
			referent4 = longAt((GIV(longRunningPrimitiveCheckSemaphore) + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent4 & (tagMask())) == 0)
			 && (((longAt(referent4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent4 = longAt((referent4 + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			GIV(longRunningPrimitiveCheckSemaphore) = referent4;
		}
		/* begin markAndTrace: */
		objOop19 = GIV(longRunningPrimitiveCheckSemaphore);

		/* inline markAndShouldScan: */
		if ((objOop19 & (tagMask())) != 0) {
			goto l73;
		}
		assert(!(isForwarded(objOop19)));
		if (((((usqInt) (longAt(objOop19))) >> 55) & 1) != 0) {
			goto l73;
		}
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(objOop19)));
		longAtput(objOop19, (longAt(objOop19)) | (1LL << 55));
		format116 = (((usqInt) (longAt(objOop19))) >> (formatShift())) & (formatMask());
		if ((format116 >= (sixtyFourBitIndexableFormat()))
		 && (format116 < (firstCompiledMethodFormat()))) {

			/* avoid pushing non-pointer objects on the markStack. */
			/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
			if (((longAt(objOop19)) & (classIndexMask())) > 0x1F) {
				markAndTraceClassOf(objOop19);
			}
			goto l73;
		}
		if (format116 == (weakArrayFormat())) {

			/* push weaklings on the weakling stack to scan later */
			pushonObjStack(objOop19, GIV(weaklingStack));
			goto l73;
		}
		if ((format116 == 5)
		 && (activeAndDeferredScan(objOop19))) {
			goto l73;
		}
		/* end markAndShouldScan:; fall through */
;
		/* begin markLoopFrom: */

		/* To avoid overflowing the mark stack when we encounter large objects, we
		   push the obj, then its numStrongSlots, and then index the object from the stack. */
		objToScan12 = objOop19;
		do {
			if ((objToScan12 & (tagMask())) != 0) {
				scanLargeObject12 = 1;
			}
			else {
				/* begin numStrongSlotsOfInephemeral: */
				fmt41 = (((usqInt) (longAt(objToScan12))) >> (formatShift())) & (formatMask());
				assert((fmt41 != (ephemeronFormat()))
				 || (isMarked(keyOfEphemeron(objToScan12))));
				if (fmt41 <= 5) {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objToScan12)) > (isForwardedObjectClassIndexPun()));
					numSlots141 = byteAt(objToScan12 + 7);
					numSlots51 = (numSlots141 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objToScan12 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots141);
					if (fmt41 <= 2) {
						numStrongSlots12 = numSlots51;
						goto l68;
					}
					if (fmt41 == (indexablePointersFormat())) {
						if (((longAt(objToScan12)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
							setTraceFlagOnContextsFramesPageIfNeeded(objToScan12);
							/* begin fetchStackPointerOf: */
							sp41 = longAt((objToScan12 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
							if (!((((sp41) & 7) == 1))) {
								contextSize41 = 0;
								goto l72;
							}
							assert((ReceiverIndex + ((sp41 >> 3))) < (lengthOf(objToScan12)));
							contextSize41 = (sp41 >> 3);
						l72:	/* end fetchStackPointerOf: */;
							numStrongSlots12 = CtxtTempFrameStart + contextSize41;
							goto l68;
						}
						numStrongSlots12 = numSlots51;
						goto l68;
					}
					if (fmt41 == (weakArrayFormat())) {
						/* begin fixedFieldsOfClass: */
						objOop151 = fetchClassOfNonImm(objToScan12);
						/* begin fixedFieldsOfClassFormat: */
						numStrongSlots12 = (((longAt((objOop151 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						goto l68;
					}
				}
				if (fmt41 == 7) {
					numStrongSlots12 = 1;
					goto l68;
				}
				if (fmt41 < (firstCompiledMethodFormat())) {
					numStrongSlots12 = 0;
					goto l68;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objToScan12));
				header41 = longAt((objToScan12 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				/* begin literalCountOfMethodHeader: */
				assert((((header41) & 7) == 1));
				numLiterals41 = ((header41 >> 3)) & AlternateHeaderNumLiteralsMask;
				numStrongSlots12 = numLiterals41 + LiteralStart;
			l68:	/* end numStrongSlotsOfInephemeral: */;
				scanLargeObject12 = numStrongSlots12 > 64;
			}
			if (scanLargeObject12) {

				/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
				if ((objToScan12 & (tagMask())) != 0) {
					index12 = (objToScan12 >> 3);
					objToScan12 = topOfObjStack(GIV(markStack));
				}
				else {
					index12 = numStrongSlots12;
					markAndTraceClassOf(objToScan12);
				}
				while (index12 > 0) {
					index12 -= 1;
					field12 = longAt((objToScan12 + BaseHeaderSize) + (((long)index12) << (shiftForWord())));
					if ((field12 & (tagMask())) == 0) {
						if (((longAt(field12)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field12 = fixFollowedFieldofObjectwithInitialValue(index12, objToScan12, field12);
						}
						if ((field12 & (tagMask())) != 0) {
							goto l56;
						}
						assert(!(isForwarded(field12)));
						if (((((usqInt) (longAt(field12))) >> 55) & 1) != 0) {
							goto l56;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field12)));
						longAtput(field12, (longAt(field12)) | (1LL << 55));
						format161 = (((usqInt) (longAt(field12))) >> (formatShift())) & (formatMask());
						if ((format161 >= (sixtyFourBitIndexableFormat()))
						 && (format161 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field12)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field12);
							}
							goto l56;
						}
						if (format161 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field12, GIV(weaklingStack));
							goto l56;
						}
						if ((format161 == 5)
						 && (activeAndDeferredScan(field12))) {
							goto l56;
						}
						/* end markAndShouldScan:; fall through */
						if (index12 > 0) {
							if ((topOfObjStack(GIV(markStack))) != objToScan12) {
								pushonObjStack(objToScan12, GIV(markStack));
							}
							pushonObjStack(((index12 << 3) | 1), GIV(markStack));
						}
						objToScan12 = field12;
						index12 = -1;
					l56:	;

					}
				}
				if (index12 >= 0) {

					/* if loop terminated without finding an unmarked referent, switch to top of stack. */
					objToScan12 = popObjStack(GIV(markStack));
					if (objToScan12 == objOop19) {
						objToScan12 = popObjStack(GIV(markStack));
					}
				}
			}
			else {

				/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
				index12 = numStrongSlots12;
				markAndTraceClassOf(objToScan12);
				while (index12 > 0) {
					index12 -= 1;
					field12 = longAt((objToScan12 + BaseHeaderSize) + (((long)index12) << (shiftForWord())));
					if ((field12 & (tagMask())) == 0) {
						if (((longAt(field12)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field12 = fixFollowedFieldofObjectwithInitialValue(index12, objToScan12, field12);
						}
						if ((field12 & (tagMask())) != 0) {
							goto l52;
						}
						assert(!(isForwarded(field12)));
						if (((((usqInt) (longAt(field12))) >> 55) & 1) != 0) {
							goto l52;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field12)));
						longAtput(field12, (longAt(field12)) | (1LL << 55));
						format161 = (((usqInt) (longAt(field12))) >> (formatShift())) & (formatMask());
						if ((format161 >= (sixtyFourBitIndexableFormat()))
						 && (format161 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field12)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field12);
							}
							goto l52;
						}
						if (format161 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field12, GIV(weaklingStack));
							goto l52;
						}
						if ((format161 == 5)
						 && (activeAndDeferredScan(field12))) {
							goto l52;
						}
						/* end markAndShouldScan:; fall through */
						pushonObjStack(field12, GIV(markStack));
						if (((byteAt(field12 + 7)) > 64)
						 && (((numStrongSlots12 = numStrongSlotsOfInephemeral(field12))) > 64)) {
							pushonObjStack(((numStrongSlots12 << 3) | 1), GIV(markStack));
						}
					l52:	;

					}
				}
				objToScan12 = popObjStack(GIV(markStack));
			}
		} while(objToScan12 != null);
	l73:	/* end markAndTrace: */;
	}
	if (!(GIV(tempOop) == 0)) {
		/* begin markAndTrace: */
		objOop18 = GIV(tempOop);

		/* inline markAndShouldScan: */
		if ((objOop18 & (tagMask())) != 0) {
			goto l49;
		}
		assert(!(isForwarded(objOop18)));
		if (((((usqInt) (longAt(objOop18))) >> 55) & 1) != 0) {
			goto l49;
		}
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(objOop18)));
		longAtput(objOop18, (longAt(objOop18)) | (1LL << 55));
		format115 = (((usqInt) (longAt(objOop18))) >> (formatShift())) & (formatMask());
		if ((format115 >= (sixtyFourBitIndexableFormat()))
		 && (format115 < (firstCompiledMethodFormat()))) {

			/* avoid pushing non-pointer objects on the markStack. */
			/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
			if (((longAt(objOop18)) & (classIndexMask())) > 0x1F) {
				markAndTraceClassOf(objOop18);
			}
			goto l49;
		}
		if (format115 == (weakArrayFormat())) {

			/* push weaklings on the weakling stack to scan later */
			pushonObjStack(objOop18, GIV(weaklingStack));
			goto l49;
		}
		if ((format115 == 5)
		 && (activeAndDeferredScan(objOop18))) {
			goto l49;
		}
		/* end markAndShouldScan:; fall through */
;
		/* begin markLoopFrom: */

		/* To avoid overflowing the mark stack when we encounter large objects, we
		   push the obj, then its numStrongSlots, and then index the object from the stack. */
		objToScan11 = objOop18;
		do {
			if ((objToScan11 & (tagMask())) != 0) {
				scanLargeObject11 = 1;
			}
			else {
				/* begin numStrongSlotsOfInephemeral: */
				fmt21 = (((usqInt) (longAt(objToScan11))) >> (formatShift())) & (formatMask());
				assert((fmt21 != (ephemeronFormat()))
				 || (isMarked(keyOfEphemeron(objToScan11))));
				if (fmt21 <= 5) {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objToScan11)) > (isForwardedObjectClassIndexPun()));
					numSlots121 = byteAt(objToScan11 + 7);
					numSlots31 = (numSlots121 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objToScan11 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots121);
					if (fmt21 <= 2) {
						numStrongSlots11 = numSlots31;
						goto l27;
					}
					if (fmt21 == (indexablePointersFormat())) {
						if (((longAt(objToScan11)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
							setTraceFlagOnContextsFramesPageIfNeeded(objToScan11);
							/* begin fetchStackPointerOf: */
							sp21 = longAt((objToScan11 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
							if (!((((sp21) & 7) == 1))) {
								contextSize21 = 0;
								goto l26;
							}
							assert((ReceiverIndex + ((sp21 >> 3))) < (lengthOf(objToScan11)));
							contextSize21 = (sp21 >> 3);
						l26:	/* end fetchStackPointerOf: */;
							numStrongSlots11 = CtxtTempFrameStart + contextSize21;
							goto l27;
						}
						numStrongSlots11 = numSlots31;
						goto l27;
					}
					if (fmt21 == (weakArrayFormat())) {
						/* begin fixedFieldsOfClass: */
						objOop131 = fetchClassOfNonImm(objToScan11);
						/* begin fixedFieldsOfClassFormat: */
						numStrongSlots11 = (((longAt((objOop131 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						goto l27;
					}
				}
				if (fmt21 == 7) {
					numStrongSlots11 = 1;
					goto l27;
				}
				if (fmt21 < (firstCompiledMethodFormat())) {
					numStrongSlots11 = 0;
					goto l27;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objToScan11));
				header21 = longAt((objToScan11 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				/* begin literalCountOfMethodHeader: */
				assert((((header21) & 7) == 1));
				numLiterals21 = ((header21 >> 3)) & AlternateHeaderNumLiteralsMask;
				numStrongSlots11 = numLiterals21 + LiteralStart;
			l27:	/* end numStrongSlotsOfInephemeral: */;
				scanLargeObject11 = numStrongSlots11 > 64;
			}
			if (scanLargeObject11) {

				/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
				if ((objToScan11 & (tagMask())) != 0) {
					index11 = (objToScan11 >> 3);
					objToScan11 = topOfObjStack(GIV(markStack));
				}
				else {
					index11 = numStrongSlots11;
					markAndTraceClassOf(objToScan11);
				}
				while (index11 > 0) {
					index11 -= 1;
					field11 = longAt((objToScan11 + BaseHeaderSize) + (((long)index11) << (shiftForWord())));
					if ((field11 & (tagMask())) == 0) {
						if (((longAt(field11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field11 = fixFollowedFieldofObjectwithInitialValue(index11, objToScan11, field11);
						}
						if ((field11 & (tagMask())) != 0) {
							goto l50;
						}
						assert(!(isForwarded(field11)));
						if (((((usqInt) (longAt(field11))) >> 55) & 1) != 0) {
							goto l50;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field11)));
						longAtput(field11, (longAt(field11)) | (1LL << 55));
						format18 = (((usqInt) (longAt(field11))) >> (formatShift())) & (formatMask());
						if ((format18 >= (sixtyFourBitIndexableFormat()))
						 && (format18 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field11)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field11);
							}
							goto l50;
						}
						if (format18 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field11, GIV(weaklingStack));
							goto l50;
						}
						if ((format18 == 5)
						 && (activeAndDeferredScan(field11))) {
							goto l50;
						}
						/* end markAndShouldScan:; fall through */
						if (index11 > 0) {
							if ((topOfObjStack(GIV(markStack))) != objToScan11) {
								pushonObjStack(objToScan11, GIV(markStack));
							}
							pushonObjStack(((index11 << 3) | 1), GIV(markStack));
						}
						objToScan11 = field11;
						index11 = -1;
					l50:	;

					}
				}
				if (index11 >= 0) {

					/* if loop terminated without finding an unmarked referent, switch to top of stack. */
					objToScan11 = popObjStack(GIV(markStack));
					if (objToScan11 == objOop18) {
						objToScan11 = popObjStack(GIV(markStack));
					}
				}
			}
			else {

				/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
				index11 = numStrongSlots11;
				markAndTraceClassOf(objToScan11);
				while (index11 > 0) {
					index11 -= 1;
					field11 = longAt((objToScan11 + BaseHeaderSize) + (((long)index11) << (shiftForWord())));
					if ((field11 & (tagMask())) == 0) {
						if (((longAt(field11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field11 = fixFollowedFieldofObjectwithInitialValue(index11, objToScan11, field11);
						}
						if ((field11 & (tagMask())) != 0) {
							goto l48;
						}
						assert(!(isForwarded(field11)));
						if (((((usqInt) (longAt(field11))) >> 55) & 1) != 0) {
							goto l48;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field11)));
						longAtput(field11, (longAt(field11)) | (1LL << 55));
						format18 = (((usqInt) (longAt(field11))) >> (formatShift())) & (formatMask());
						if ((format18 >= (sixtyFourBitIndexableFormat()))
						 && (format18 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field11)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field11);
							}
							goto l48;
						}
						if (format18 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field11, GIV(weaklingStack));
							goto l48;
						}
						if ((format18 == 5)
						 && (activeAndDeferredScan(field11))) {
							goto l48;
						}
						/* end markAndShouldScan:; fall through */
						pushonObjStack(field11, GIV(markStack));
						if (((byteAt(field11 + 7)) > 64)
						 && (((numStrongSlots11 = numStrongSlotsOfInephemeral(field11))) > 64)) {
							pushonObjStack(((numStrongSlots11 << 3) | 1), GIV(markStack));
						}
					l48:	;

					}
				}
				objToScan11 = popObjStack(GIV(markStack));
			}
		} while(objToScan11 != null);
	l49:	/* end markAndTrace: */;
	}
	if (!(GIV(tempOop2) == 0)) {
		/* begin markAndTrace: */
		objOop21 = GIV(tempOop2);

		/* inline markAndShouldScan: */
		if ((objOop21 & (tagMask())) != 0) {
			goto l47;
		}
		assert(!(isForwarded(objOop21)));
		if (((((usqInt) (longAt(objOop21))) >> 55) & 1) != 0) {
			goto l47;
		}
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(objOop21)));
		longAtput(objOop21, (longAt(objOop21)) | (1LL << 55));
		format121 = (((usqInt) (longAt(objOop21))) >> (formatShift())) & (formatMask());
		if ((format121 >= (sixtyFourBitIndexableFormat()))
		 && (format121 < (firstCompiledMethodFormat()))) {

			/* avoid pushing non-pointer objects on the markStack. */
			/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
			if (((longAt(objOop21)) & (classIndexMask())) > 0x1F) {
				markAndTraceClassOf(objOop21);
			}
			goto l47;
		}
		if (format121 == (weakArrayFormat())) {

			/* push weaklings on the weakling stack to scan later */
			pushonObjStack(objOop21, GIV(weaklingStack));
			goto l47;
		}
		if ((format121 == 5)
		 && (activeAndDeferredScan(objOop21))) {
			goto l47;
		}
		/* end markAndShouldScan:; fall through */
;
		/* begin markLoopFrom: */

		/* To avoid overflowing the mark stack when we encounter large objects, we
		   push the obj, then its numStrongSlots, and then index the object from the stack. */
		objToScan21 = objOop21;
		do {
			if ((objToScan21 & (tagMask())) != 0) {
				scanLargeObject21 = 1;
			}
			else {
				/* begin numStrongSlotsOfInephemeral: */
				fmt3 = (((usqInt) (longAt(objToScan21))) >> (formatShift())) & (formatMask());
				assert((fmt3 != (ephemeronFormat()))
				 || (isMarked(keyOfEphemeron(objToScan21))));
				if (fmt3 <= 5) {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objToScan21)) > (isForwardedObjectClassIndexPun()));
					numSlots13 = byteAt(objToScan21 + 7);
					numSlots4 = (numSlots13 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objToScan21 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots13);
					if (fmt3 <= 2) {
						numStrongSlots21 = numSlots4;
						goto l29;
					}
					if (fmt3 == (indexablePointersFormat())) {
						if (((longAt(objToScan21)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
							setTraceFlagOnContextsFramesPageIfNeeded(objToScan21);
							/* begin fetchStackPointerOf: */
							sp3 = longAt((objToScan21 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
							if (!((((sp3) & 7) == 1))) {
								contextSize3 = 0;
								goto l28;
							}
							assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(objToScan21)));
							contextSize3 = (sp3 >> 3);
						l28:	/* end fetchStackPointerOf: */;
							numStrongSlots21 = CtxtTempFrameStart + contextSize3;
							goto l29;
						}
						numStrongSlots21 = numSlots4;
						goto l29;
					}
					if (fmt3 == (weakArrayFormat())) {
						/* begin fixedFieldsOfClass: */
						objOop14 = fetchClassOfNonImm(objToScan21);
						/* begin fixedFieldsOfClassFormat: */
						numStrongSlots21 = (((longAt((objOop14 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						goto l29;
					}
				}
				if (fmt3 == 7) {
					numStrongSlots21 = 1;
					goto l29;
				}
				if (fmt3 < (firstCompiledMethodFormat())) {
					numStrongSlots21 = 0;
					goto l29;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objToScan21));
				header3 = longAt((objToScan21 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				/* begin literalCountOfMethodHeader: */
				assert((((header3) & 7) == 1));
				numLiterals3 = ((header3 >> 3)) & AlternateHeaderNumLiteralsMask;
				numStrongSlots21 = numLiterals3 + LiteralStart;
			l29:	/* end numStrongSlotsOfInephemeral: */;
				scanLargeObject21 = numStrongSlots21 > 64;
			}
			if (scanLargeObject21) {

				/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
				if ((objToScan21 & (tagMask())) != 0) {
					index21 = (objToScan21 >> 3);
					objToScan21 = topOfObjStack(GIV(markStack));
				}
				else {
					index21 = numStrongSlots21;
					markAndTraceClassOf(objToScan21);
				}
				while (index21 > 0) {
					index21 -= 1;
					field21 = longAt((objToScan21 + BaseHeaderSize) + (((long)index21) << (shiftForWord())));
					if ((field21 & (tagMask())) == 0) {
						if (((longAt(field21)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field21 = fixFollowedFieldofObjectwithInitialValue(index21, objToScan21, field21);
						}
						if ((field21 & (tagMask())) != 0) {
							goto l46;
						}
						assert(!(isForwarded(field21)));
						if (((((usqInt) (longAt(field21))) >> 55) & 1) != 0) {
							goto l46;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field21)));
						longAtput(field21, (longAt(field21)) | (1LL << 55));
						format19 = (((usqInt) (longAt(field21))) >> (formatShift())) & (formatMask());
						if ((format19 >= (sixtyFourBitIndexableFormat()))
						 && (format19 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field21)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field21);
							}
							goto l46;
						}
						if (format19 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field21, GIV(weaklingStack));
							goto l46;
						}
						if ((format19 == 5)
						 && (activeAndDeferredScan(field21))) {
							goto l46;
						}
						/* end markAndShouldScan:; fall through */
						if (index21 > 0) {
							if ((topOfObjStack(GIV(markStack))) != objToScan21) {
								pushonObjStack(objToScan21, GIV(markStack));
							}
							pushonObjStack(((index21 << 3) | 1), GIV(markStack));
						}
						objToScan21 = field21;
						index21 = -1;
					l46:	;

					}
				}
				if (index21 >= 0) {

					/* if loop terminated without finding an unmarked referent, switch to top of stack. */
					objToScan21 = popObjStack(GIV(markStack));
					if (objToScan21 == objOop21) {
						objToScan21 = popObjStack(GIV(markStack));
					}
				}
			}
			else {

				/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
				index21 = numStrongSlots21;
				markAndTraceClassOf(objToScan21);
				while (index21 > 0) {
					index21 -= 1;
					field21 = longAt((objToScan21 + BaseHeaderSize) + (((long)index21) << (shiftForWord())));
					if ((field21 & (tagMask())) == 0) {
						if (((longAt(field21)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field21 = fixFollowedFieldofObjectwithInitialValue(index21, objToScan21, field21);
						}
						if ((field21 & (tagMask())) != 0) {
							goto l44;
						}
						assert(!(isForwarded(field21)));
						if (((((usqInt) (longAt(field21))) >> 55) & 1) != 0) {
							goto l44;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field21)));
						longAtput(field21, (longAt(field21)) | (1LL << 55));
						format19 = (((usqInt) (longAt(field21))) >> (formatShift())) & (formatMask());
						if ((format19 >= (sixtyFourBitIndexableFormat()))
						 && (format19 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field21)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field21);
							}
							goto l44;
						}
						if (format19 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field21, GIV(weaklingStack));
							goto l44;
						}
						if ((format19 == 5)
						 && (activeAndDeferredScan(field21))) {
							goto l44;
						}
						/* end markAndShouldScan:; fall through */
						pushonObjStack(field21, GIV(markStack));
						if (((byteAt(field21 + 7)) > 64)
						 && (((numStrongSlots21 = numStrongSlotsOfInephemeral(field21))) > 64)) {
							pushonObjStack(((numStrongSlots21 << 3) | 1), GIV(markStack));
						}
					l44:	;

					}
				}
				objToScan21 = popObjStack(GIV(markStack));
			}
		} while(objToScan21 != null);
	l47:	/* end markAndTrace: */;
	}
	for (i4 = 1, iLimiT = (remapBufferCount()); i4 <= iLimiT; i4 += 1) {
		oop1 = GIV(remapBuffer)[i4];
		if (!((((oop1) & 7) == 1))) {
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((oop1 & (tagMask())) != 0) {
				goto l45;
			}
			assert(!(isForwarded(oop1)));
			if (((((usqInt) (longAt(oop1))) >> 55) & 1) != 0) {
				goto l45;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop1)));
			longAtput(oop1, (longAt(oop1)) | (1LL << 55));
			format131 = (((usqInt) (longAt(oop1))) >> (formatShift())) & (formatMask());
			if ((format131 >= (sixtyFourBitIndexableFormat()))
			 && (format131 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(oop1)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(oop1);
				}
				goto l45;
			}
			if (format131 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(oop1, GIV(weaklingStack));
				goto l45;
			}
			if ((format131 == 5)
			 && (activeAndDeferredScan(oop1))) {
				goto l45;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan3 = oop1;
			do {
				if ((objToScan3 & (tagMask())) != 0) {
					scanLargeObject3 = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt4 = (((usqInt) (longAt(objToScan3))) >> (formatShift())) & (formatMask());
					assert((fmt4 != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan3))));
					if (fmt4 <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan3)) > (isForwardedObjectClassIndexPun()));
						numSlots14 = byteAt(objToScan3 + 7);
						numSlots5 = (numSlots14 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan3 - BaseHeaderSize))) << 8)))) >> 8
							: numSlots14);
						if (fmt4 <= 2) {
							numStrongSlots3 = numSlots5;
							goto l31;
						}
						if (fmt4 == (indexablePointersFormat())) {
							if (((longAt(objToScan3)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan3);
								/* begin fetchStackPointerOf: */
								sp4 = longAt((objToScan3 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp4) & 7) == 1))) {
									contextSize4 = 0;
									goto l30;
								}
								assert((ReceiverIndex + ((sp4 >> 3))) < (lengthOf(objToScan3)));
								contextSize4 = (sp4 >> 3);
							l30:	/* end fetchStackPointerOf: */;
								numStrongSlots3 = CtxtTempFrameStart + contextSize4;
								goto l31;
							}
							numStrongSlots3 = numSlots5;
							goto l31;
						}
						if (fmt4 == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop15 = fetchClassOfNonImm(objToScan3);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots3 = (((longAt((objOop15 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l31;
						}
					}
					if (fmt4 == 7) {
						numStrongSlots3 = 1;
						goto l31;
					}
					if (fmt4 < (firstCompiledMethodFormat())) {
						numStrongSlots3 = 0;
						goto l31;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan3));
					header4 = longAt((objToScan3 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header4) & 7) == 1));
					numLiterals4 = ((header4 >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots3 = numLiterals4 + LiteralStart;
				l31:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject3 = numStrongSlots3 > 64;
				}
				if (scanLargeObject3) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan3 & (tagMask())) != 0) {
						index3 = (objToScan3 >> 3);
						objToScan3 = topOfObjStack(GIV(markStack));
					}
					else {
						index3 = numStrongSlots3;
						markAndTraceClassOf(objToScan3);
					}
					while (index3 > 0) {
						index3 -= 1;
						field3 = longAt((objToScan3 + BaseHeaderSize) + (((long)index3) << (shiftForWord())));
						if ((field3 & (tagMask())) == 0) {
							if (((longAt(field3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field3 = fixFollowedFieldofObjectwithInitialValue(index3, objToScan3, field3);
							}
							if ((field3 & (tagMask())) != 0) {
								goto l42;
							}
							assert(!(isForwarded(field3)));
							if (((((usqInt) (longAt(field3))) >> 55) & 1) != 0) {
								goto l42;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field3)));
							longAtput(field3, (longAt(field3)) | (1LL << 55));
							format110 = (((usqInt) (longAt(field3))) >> (formatShift())) & (formatMask());
							if ((format110 >= (sixtyFourBitIndexableFormat()))
							 && (format110 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field3)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field3);
								}
								goto l42;
							}
							if (format110 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field3, GIV(weaklingStack));
								goto l42;
							}
							if ((format110 == 5)
							 && (activeAndDeferredScan(field3))) {
								goto l42;
							}
							/* end markAndShouldScan:; fall through */
							if (index3 > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan3) {
									pushonObjStack(objToScan3, GIV(markStack));
								}
								pushonObjStack(((index3 << 3) | 1), GIV(markStack));
							}
							objToScan3 = field3;
							index3 = -1;
						l42:	;

						}
					}
					if (index3 >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan3 = popObjStack(GIV(markStack));
						if (objToScan3 == oop1) {
							objToScan3 = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index3 = numStrongSlots3;
					markAndTraceClassOf(objToScan3);
					while (index3 > 0) {
						index3 -= 1;
						field3 = longAt((objToScan3 + BaseHeaderSize) + (((long)index3) << (shiftForWord())));
						if ((field3 & (tagMask())) == 0) {
							if (((longAt(field3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field3 = fixFollowedFieldofObjectwithInitialValue(index3, objToScan3, field3);
							}
							if ((field3 & (tagMask())) != 0) {
								goto l40;
							}
							assert(!(isForwarded(field3)));
							if (((((usqInt) (longAt(field3))) >> 55) & 1) != 0) {
								goto l40;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field3)));
							longAtput(field3, (longAt(field3)) | (1LL << 55));
							format110 = (((usqInt) (longAt(field3))) >> (formatShift())) & (formatMask());
							if ((format110 >= (sixtyFourBitIndexableFormat()))
							 && (format110 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field3)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field3);
								}
								goto l40;
							}
							if (format110 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field3, GIV(weaklingStack));
								goto l40;
							}
							if ((format110 == 5)
							 && (activeAndDeferredScan(field3))) {
								goto l40;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field3, GIV(markStack));
							if (((byteAt(field3 + 7)) > 64)
							 && (((numStrongSlots3 = numStrongSlotsOfInephemeral(field3))) > 64)) {
								pushonObjStack(((numStrongSlots3 << 3) | 1), GIV(markStack));
							}
						l40:	;

						}
					}
					objToScan3 = popObjStack(GIV(markStack));
				}
			} while(objToScan3 != null);
		l45:	/* end markAndTrace: */;
		}
	}
	for (i4 = 1; i4 <= GIV(jmpDepth); i4 += 1) {
		oop1 = GIV(suspendedCallbacks)[i4];
		if (!((((oop1) & 7) == 1))) {
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((oop1 & (tagMask())) != 0) {
				goto l43;
			}
			assert(!(isForwarded(oop1)));
			if (((((usqInt) (longAt(oop1))) >> 55) & 1) != 0) {
				goto l43;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop1)));
			longAtput(oop1, (longAt(oop1)) | (1LL << 55));
			format141 = (((usqInt) (longAt(oop1))) >> (formatShift())) & (formatMask());
			if ((format141 >= (sixtyFourBitIndexableFormat()))
			 && (format141 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(oop1)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(oop1);
				}
				goto l43;
			}
			if (format141 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(oop1, GIV(weaklingStack));
				goto l43;
			}
			if ((format141 == 5)
			 && (activeAndDeferredScan(oop1))) {
				goto l43;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan4 = oop1;
			do {
				if ((objToScan4 & (tagMask())) != 0) {
					scanLargeObject4 = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt5 = (((usqInt) (longAt(objToScan4))) >> (formatShift())) & (formatMask());
					assert((fmt5 != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan4))));
					if (fmt5 <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan4)) > (isForwardedObjectClassIndexPun()));
						numSlots15 = byteAt(objToScan4 + 7);
						numSlots6 = (numSlots15 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan4 - BaseHeaderSize))) << 8)))) >> 8
							: numSlots15);
						if (fmt5 <= 2) {
							numStrongSlots4 = numSlots6;
							goto l33;
						}
						if (fmt5 == (indexablePointersFormat())) {
							if (((longAt(objToScan4)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan4);
								/* begin fetchStackPointerOf: */
								sp5 = longAt((objToScan4 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp5) & 7) == 1))) {
									contextSize5 = 0;
									goto l32;
								}
								assert((ReceiverIndex + ((sp5 >> 3))) < (lengthOf(objToScan4)));
								contextSize5 = (sp5 >> 3);
							l32:	/* end fetchStackPointerOf: */;
								numStrongSlots4 = CtxtTempFrameStart + contextSize5;
								goto l33;
							}
							numStrongSlots4 = numSlots6;
							goto l33;
						}
						if (fmt5 == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop16 = fetchClassOfNonImm(objToScan4);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots4 = (((longAt((objOop16 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l33;
						}
					}
					if (fmt5 == 7) {
						numStrongSlots4 = 1;
						goto l33;
					}
					if (fmt5 < (firstCompiledMethodFormat())) {
						numStrongSlots4 = 0;
						goto l33;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan4));
					header5 = longAt((objToScan4 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header5) & 7) == 1));
					numLiterals5 = ((header5 >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots4 = numLiterals5 + LiteralStart;
				l33:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject4 = numStrongSlots4 > 64;
				}
				if (scanLargeObject4) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan4 & (tagMask())) != 0) {
						index4 = (objToScan4 >> 3);
						objToScan4 = topOfObjStack(GIV(markStack));
					}
					else {
						index4 = numStrongSlots4;
						markAndTraceClassOf(objToScan4);
					}
					while (index4 > 0) {
						index4 -= 1;
						field4 = longAt((objToScan4 + BaseHeaderSize) + (((long)index4) << (shiftForWord())));
						if ((field4 & (tagMask())) == 0) {
							if (((longAt(field4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field4 = fixFollowedFieldofObjectwithInitialValue(index4, objToScan4, field4);
							}
							if ((field4 & (tagMask())) != 0) {
								goto l38;
							}
							assert(!(isForwarded(field4)));
							if (((((usqInt) (longAt(field4))) >> 55) & 1) != 0) {
								goto l38;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field4)));
							longAtput(field4, (longAt(field4)) | (1LL << 55));
							format1111 = (((usqInt) (longAt(field4))) >> (formatShift())) & (formatMask());
							if ((format1111 >= (sixtyFourBitIndexableFormat()))
							 && (format1111 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field4)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field4);
								}
								goto l38;
							}
							if (format1111 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field4, GIV(weaklingStack));
								goto l38;
							}
							if ((format1111 == 5)
							 && (activeAndDeferredScan(field4))) {
								goto l38;
							}
							/* end markAndShouldScan:; fall through */
							if (index4 > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan4) {
									pushonObjStack(objToScan4, GIV(markStack));
								}
								pushonObjStack(((index4 << 3) | 1), GIV(markStack));
							}
							objToScan4 = field4;
							index4 = -1;
						l38:	;

						}
					}
					if (index4 >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan4 = popObjStack(GIV(markStack));
						if (objToScan4 == oop1) {
							objToScan4 = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index4 = numStrongSlots4;
					markAndTraceClassOf(objToScan4);
					while (index4 > 0) {
						index4 -= 1;
						field4 = longAt((objToScan4 + BaseHeaderSize) + (((long)index4) << (shiftForWord())));
						if ((field4 & (tagMask())) == 0) {
							if (((longAt(field4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field4 = fixFollowedFieldofObjectwithInitialValue(index4, objToScan4, field4);
							}
							if ((field4 & (tagMask())) != 0) {
								goto l17;
							}
							assert(!(isForwarded(field4)));
							if (((((usqInt) (longAt(field4))) >> 55) & 1) != 0) {
								goto l17;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field4)));
							longAtput(field4, (longAt(field4)) | (1LL << 55));
							format1111 = (((usqInt) (longAt(field4))) >> (formatShift())) & (formatMask());
							if ((format1111 >= (sixtyFourBitIndexableFormat()))
							 && (format1111 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field4)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field4);
								}
								goto l17;
							}
							if (format1111 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field4, GIV(weaklingStack));
								goto l17;
							}
							if ((format1111 == 5)
							 && (activeAndDeferredScan(field4))) {
								goto l17;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field4, GIV(markStack));
							if (((byteAt(field4 + 7)) > 64)
							 && (((numStrongSlots4 = numStrongSlotsOfInephemeral(field4))) > 64)) {
								pushonObjStack(((numStrongSlots4 << 3) | 1), GIV(markStack));
							}
						l17:	;

						}
					}
					objToScan4 = popObjStack(GIV(markStack));
				}
			} while(objToScan4 != null);
		l43:	/* end markAndTrace: */;
		}
		oop1 = GIV(suspendedMethods)[i4];
		if (!((((oop1) & 7) == 1))) {
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((oop1 & (tagMask())) != 0) {
				goto l41;
			}
			assert(!(isForwarded(oop1)));
			if (((((usqInt) (longAt(oop1))) >> 55) & 1) != 0) {
				goto l41;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop1)));
			longAtput(oop1, (longAt(oop1)) | (1LL << 55));
			format15 = (((usqInt) (longAt(oop1))) >> (formatShift())) & (formatMask());
			if ((format15 >= (sixtyFourBitIndexableFormat()))
			 && (format15 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(oop1)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(oop1);
				}
				goto l41;
			}
			if (format15 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(oop1, GIV(weaklingStack));
				goto l41;
			}
			if ((format15 == 5)
			 && (activeAndDeferredScan(oop1))) {
				goto l41;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan5 = oop1;
			do {
				if ((objToScan5 & (tagMask())) != 0) {
					scanLargeObject5 = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt6 = (((usqInt) (longAt(objToScan5))) >> (formatShift())) & (formatMask());
					assert((fmt6 != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan5))));
					if (fmt6 <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan5)) > (isForwardedObjectClassIndexPun()));
						numSlots16 = byteAt(objToScan5 + 7);
						numSlots7 = (numSlots16 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan5 - BaseHeaderSize))) << 8)))) >> 8
							: numSlots16);
						if (fmt6 <= 2) {
							numStrongSlots5 = numSlots7;
							goto l35;
						}
						if (fmt6 == (indexablePointersFormat())) {
							if (((longAt(objToScan5)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan5);
								/* begin fetchStackPointerOf: */
								sp6 = longAt((objToScan5 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp6) & 7) == 1))) {
									contextSize6 = 0;
									goto l34;
								}
								assert((ReceiverIndex + ((sp6 >> 3))) < (lengthOf(objToScan5)));
								contextSize6 = (sp6 >> 3);
							l34:	/* end fetchStackPointerOf: */;
								numStrongSlots5 = CtxtTempFrameStart + contextSize6;
								goto l35;
							}
							numStrongSlots5 = numSlots7;
							goto l35;
						}
						if (fmt6 == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop17 = fetchClassOfNonImm(objToScan5);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots5 = (((longAt((objOop17 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l35;
						}
					}
					if (fmt6 == 7) {
						numStrongSlots5 = 1;
						goto l35;
					}
					if (fmt6 < (firstCompiledMethodFormat())) {
						numStrongSlots5 = 0;
						goto l35;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan5));
					header6 = longAt((objToScan5 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header6) & 7) == 1));
					numLiterals6 = ((header6 >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots5 = numLiterals6 + LiteralStart;
				l35:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject5 = numStrongSlots5 > 64;
				}
				if (scanLargeObject5) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan5 & (tagMask())) != 0) {
						index5 = (objToScan5 >> 3);
						objToScan5 = topOfObjStack(GIV(markStack));
					}
					else {
						index5 = numStrongSlots5;
						markAndTraceClassOf(objToScan5);
					}
					while (index5 > 0) {
						index5 -= 1;
						field5 = longAt((objToScan5 + BaseHeaderSize) + (((long)index5) << (shiftForWord())));
						if ((field5 & (tagMask())) == 0) {
							if (((longAt(field5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field5 = fixFollowedFieldofObjectwithInitialValue(index5, objToScan5, field5);
							}
							if ((field5 & (tagMask())) != 0) {
								goto l18;
							}
							assert(!(isForwarded(field5)));
							if (((((usqInt) (longAt(field5))) >> 55) & 1) != 0) {
								goto l18;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field5)));
							longAtput(field5, (longAt(field5)) | (1LL << 55));
							format112 = (((usqInt) (longAt(field5))) >> (formatShift())) & (formatMask());
							if ((format112 >= (sixtyFourBitIndexableFormat()))
							 && (format112 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field5)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field5);
								}
								goto l18;
							}
							if (format112 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field5, GIV(weaklingStack));
								goto l18;
							}
							if ((format112 == 5)
							 && (activeAndDeferredScan(field5))) {
								goto l18;
							}
							/* end markAndShouldScan:; fall through */
							if (index5 > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan5) {
									pushonObjStack(objToScan5, GIV(markStack));
								}
								pushonObjStack(((index5 << 3) | 1), GIV(markStack));
							}
							objToScan5 = field5;
							index5 = -1;
						l18:	;

						}
					}
					if (index5 >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan5 = popObjStack(GIV(markStack));
						if (objToScan5 == oop1) {
							objToScan5 = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index5 = numStrongSlots5;
					markAndTraceClassOf(objToScan5);
					while (index5 > 0) {
						index5 -= 1;
						field5 = longAt((objToScan5 + BaseHeaderSize) + (((long)index5) << (shiftForWord())));
						if ((field5 & (tagMask())) == 0) {
							if (((longAt(field5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field5 = fixFollowedFieldofObjectwithInitialValue(index5, objToScan5, field5);
							}
							if ((field5 & (tagMask())) != 0) {
								goto l19;
							}
							assert(!(isForwarded(field5)));
							if (((((usqInt) (longAt(field5))) >> 55) & 1) != 0) {
								goto l19;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field5)));
							longAtput(field5, (longAt(field5)) | (1LL << 55));
							format112 = (((usqInt) (longAt(field5))) >> (formatShift())) & (formatMask());
							if ((format112 >= (sixtyFourBitIndexableFormat()))
							 && (format112 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field5)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field5);
								}
								goto l19;
							}
							if (format112 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field5, GIV(weaklingStack));
								goto l19;
							}
							if ((format112 == 5)
							 && (activeAndDeferredScan(field5))) {
								goto l19;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field5, GIV(markStack));
							if (((byteAt(field5 + 7)) > 64)
							 && (((numStrongSlots5 = numStrongSlotsOfInephemeral(field5))) > 64)) {
								pushonObjStack(((numStrongSlots5 << 3) | 1), GIV(markStack));
							}
						l19:	;

						}
					}
					objToScan5 = popObjStack(GIV(markStack));
				}
			} while(objToScan5 != null);
		l41:	/* end markAndTrace: */;
		}
	}
	assert(validObjStacks());
	markWeaklingsAndMarkAndFireEphemerons();
	assert(validObjStacks());
	GIV(marking) = 0;
	/* begin expungeDuplicateAndUnmarkedClasses: */
	for (i1 = 1; i1 < GIV(numClassTablePages); i1 += 1) {

		/* Avoid expunging the puns by not scanning the 0th page. */
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i1) << (shiftForWord())));
		for (j = 0, jLimiT = ((1LL << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
			classOrNil = longAt((classTablePage + BaseHeaderSize) + (((long)j) << (shiftForWord())));
			classIndex = (((long)i1) << (classTableMajorIndexShift())) + j;
			assert((classOrNil == GIV(nilObj))
			 || (addressCouldBeClassObj(classOrNil)));
			if (classOrNil == GIV(nilObj)) {
				if (classIndex < GIV(classTableIndex)) {
					GIV(classTableIndex) = classIndex;
				}
			}
			else {
				if ((objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged
				 && (!(((((usqInt) (longAt(classOrNil))) >> 55) & 1) != 0)))
				 || (((long32At(classOrNil + 4)) & (identityHashHalfWordMask())) != classIndex)) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(classTablePage)));
					longAtput((classTablePage + BaseHeaderSize) + (((long)j) << (shiftForWord())), GIV(nilObj));
					assert((objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged
					 && (!(isMarked(classOrNil))))
					 || ((classAtIndex(rawHashBitsOf(classOrNil))) == classOrNil));
					if (classIndex < GIV(classTableIndex)) {
						GIV(classTableIndex) = classIndex;
					}
				}
			}
		}
	}
	assert(GIV(classTableIndex) >= (1LL << (classTableMajorIndexShift())));
	nilUnmarkedWeaklingSlots();
}


/*	After the initial scan-mark is complete ephemerons can be processed.
	Weaklings have accumulated on the weaklingStack, but more may be
	uncovered during ephemeron processing. So trace the strong slots
	of the weaklings, and as ephemerons are processed ensure any newly
	reached weaklings are also traced. */

	/* SpurMemoryManager>>#markWeaklingsAndMarkAndFireEphemerons */
static void
markWeaklingsAndMarkAndFireEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt contextSize1;
    sqInt contextSize2;
    sqInt ephemeron;
    sqInt field;
    sqInt field1;
    sqInt field2;
    sqInt field3;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt format1;
    sqInt format11;
    sqInt format12;
    sqInt format13;
    sqInt format14;
    sqInt format15;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt key;
    sqInt numLiterals;
    sqInt numLiterals1;
    sqInt numLiterals2;
    sqInt numOnThisPage;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt numStrongSlots;
    sqInt numStrongSlots1;
    sqInt numStrongSlots2;
    sqInt numToEnumerate;
    sqInt numToEnumerateOnThisPage;
    sqInt numTracedWeaklings;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop13;
    sqInt objStackPage;
    sqInt objToScan;
    sqInt objToScan1;
    sqInt objToScan2;
    sqInt oop;
    sqInt p;
    usqInt ptr;
    sqInt scanLargeObject;
    sqInt scanLargeObject1;
    sqInt scanLargeObject2;
    sqInt size;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt topIndex;
    sqInt weakling;
    sqInt weakReferenceOop;

	numStrongSlots = 0;
	numStrongSlots1 = 0;
	numStrongSlots2 = 0;
	numTracedWeaklings = 0;
	while(1) {
		markAndTraceUntracedReachableStackPages();
		do {
			/* begin objStack:from:do: */
			eassert(isValidObjStack(GIV(weaklingStack)));
			size = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
			objStackPage = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
			while (objStackPage != 0) {
				size += ObjStackLimit;
				assert((fetchPointerofObject(ObjStackTopx, objStackPage)) == ObjStackLimit);
				objStackPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
			}
			numToEnumerate = size - numTracedWeaklings;
			objStackPage = GIV(weaklingStack);
			while (numToEnumerate > 0) {
				numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
				numToEnumerateOnThisPage = ((numToEnumerate < numOnThisPage) ? numToEnumerate : numOnThisPage);
				topIndex = (numOnThisPage + ObjStackFixedSlots) - 1;
				for (i1 = topIndex; i1 >= ((topIndex - numToEnumerateOnThisPage) + 1); i1 += -1) {
					assert(isWeak(fetchPointerofObject(i1, objStackPage)));
					weakling = longAt((objStackPage + BaseHeaderSize) + (((long)i1) << (shiftForWord())));
					assert(!((isForwarded(weakling))));
					markAndTraceClassOf(weakling);
					for (i = 0, iLimiT = ((numStrongSlotsOfWeakling(weakling)) - 1); i <= iLimiT; i += 1) {
						/* begin followObjField:ofObject: */
						objOop = longAt((weakling + BaseHeaderSize) + (((long)i) << (shiftForWord())));
						assert(isNonImmediate(objOop));
						if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop = fixFollowedFieldofObjectwithInitialValue(i, weakling, objOop);
						}
						field = objOop;
						if (!(((field & (tagMask())) != 0)
							 || (((((usqInt) (longAt(field))) >> 55) & 1) != 0))) {
							/* begin markAndTrace: */

							/* inline markAndShouldScan: */
							if ((field & (tagMask())) != 0) {
								goto l19;
							}
							assert(!(isForwarded(field)));
							if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
								goto l19;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field)));
							longAtput(field, (longAt(field)) | (1LL << 55));
							format1 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
							if ((format1 >= (sixtyFourBitIndexableFormat()))
							 && (format1 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field);
								}
								goto l19;
							}
							if (format1 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field, GIV(weaklingStack));
								goto l19;
							}
							if ((format1 == 5)
							 && (activeAndDeferredScan(field))) {
								goto l19;
							}
							/* end markAndShouldScan:; fall through */
;
							/* begin markLoopFrom: */

							/* To avoid overflowing the mark stack when we encounter large objects, we
							   push the obj, then its numStrongSlots, and then index the object from the stack. */
							objToScan = field;
							do {
								if ((objToScan & (tagMask())) != 0) {
									scanLargeObject = 1;
								}
								else {
									/* begin numStrongSlotsOfInephemeral: */
									fmt = (((usqInt) (longAt(objToScan))) >> (formatShift())) & (formatMask());
									assert((fmt != (ephemeronFormat()))
									 || (isMarked(keyOfEphemeron(objToScan))));
									if (fmt <= 5) {
										/* begin numSlotsOf: */
										flag("endianness");
										assert((classIndexOf(objToScan)) > (isForwardedObjectClassIndexPun()));
										numSlots1 = byteAt(objToScan + 7);
										numSlots = (numSlots1 == (numSlotsMask())
											? ((usqInt) (((unsigned long)(((long)(longAt(objToScan - BaseHeaderSize))) << 8)))) >> 8
											: numSlots1);
										if (fmt <= 2) {
											numStrongSlots = numSlots;
											goto l20;
										}
										if (fmt == (indexablePointersFormat())) {
											if (((longAt(objToScan)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
												setTraceFlagOnContextsFramesPageIfNeeded(objToScan);
												/* begin fetchStackPointerOf: */
												sp = longAt((objToScan + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
												if (!((((sp) & 7) == 1))) {
													contextSize = 0;
													goto l18;
												}
												assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan)));
												contextSize = (sp >> 3);
											l18:	/* end fetchStackPointerOf: */;
												numStrongSlots = CtxtTempFrameStart + contextSize;
												goto l20;
											}
											numStrongSlots = numSlots;
											goto l20;
										}
										if (fmt == (weakArrayFormat())) {
											/* begin fixedFieldsOfClass: */
											objOop11 = fetchClassOfNonImm(objToScan);
											/* begin fixedFieldsOfClassFormat: */
											numStrongSlots = (((longAt((objOop11 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
											goto l20;
										}
									}
									if (fmt == 7) {
										numStrongSlots = 1;
										goto l20;
									}
									if (fmt < (firstCompiledMethodFormat())) {
										numStrongSlots = 0;
										goto l20;
									}
									/* begin methodHeaderOf: */
									assert(isCompiledMethod(objToScan));
									header = longAt((objToScan + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
									/* begin literalCountOfMethodHeader: */
									assert((((header) & 7) == 1));
									numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
									numStrongSlots = numLiterals + LiteralStart;
								l20:	/* end numStrongSlotsOfInephemeral: */;
									scanLargeObject = numStrongSlots > 64;
								}
								if (scanLargeObject) {

									/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
									if ((objToScan & (tagMask())) != 0) {
										index = (objToScan >> 3);
										objToScan = topOfObjStack(GIV(markStack));
									}
									else {
										index = numStrongSlots;
										markAndTraceClassOf(objToScan);
									}
									while (index > 0) {
										index -= 1;
										field1 = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
										if ((field1 & (tagMask())) == 0) {
											if (((longAt(field1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

												/* fixFollowedField: is /not/ inlined */
												field1 = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field1);
											}
											if ((field1 & (tagMask())) != 0) {
												goto l16;
											}
											assert(!(isForwarded(field1)));
											if (((((usqInt) (longAt(field1))) >> 55) & 1) != 0) {
												goto l16;
											}
											/* begin setIsMarkedOf:to: */
											assert(!(isFreeObject(field1)));
											longAtput(field1, (longAt(field1)) | (1LL << 55));
											format13 = (((usqInt) (longAt(field1))) >> (formatShift())) & (formatMask());
											if ((format13 >= (sixtyFourBitIndexableFormat()))
											 && (format13 < (firstCompiledMethodFormat()))) {

												/* avoid pushing non-pointer objects on the markStack. */
												/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
												if (((longAt(field1)) & (classIndexMask())) > 0x1F) {
													markAndTraceClassOf(field1);
												}
												goto l16;
											}
											if (format13 == (weakArrayFormat())) {

												/* push weaklings on the weakling stack to scan later */
												pushonObjStack(field1, GIV(weaklingStack));
												goto l16;
											}
											if ((format13 == 5)
											 && (activeAndDeferredScan(field1))) {
												goto l16;
											}
											/* end markAndShouldScan:; fall through */
											if (index > 0) {
												if ((topOfObjStack(GIV(markStack))) != objToScan) {
													pushonObjStack(objToScan, GIV(markStack));
												}
												pushonObjStack(((index << 3) | 1), GIV(markStack));
											}
											objToScan = field1;
											index = -1;
										l16:	;

										}
									}
									if (index >= 0) {

										/* if loop terminated without finding an unmarked referent, switch to top of stack. */
										objToScan = popObjStack(GIV(markStack));
										if (objToScan == field) {
											objToScan = popObjStack(GIV(markStack));
										}
									}
								}
								else {

									/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
									index = numStrongSlots;
									markAndTraceClassOf(objToScan);
									while (index > 0) {
										index -= 1;
										field1 = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
										if ((field1 & (tagMask())) == 0) {
											if (((longAt(field1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

												/* fixFollowedField: is /not/ inlined */
												field1 = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field1);
											}
											if ((field1 & (tagMask())) != 0) {
												goto l17;
											}
											assert(!(isForwarded(field1)));
											if (((((usqInt) (longAt(field1))) >> 55) & 1) != 0) {
												goto l17;
											}
											/* begin setIsMarkedOf:to: */
											assert(!(isFreeObject(field1)));
											longAtput(field1, (longAt(field1)) | (1LL << 55));
											format13 = (((usqInt) (longAt(field1))) >> (formatShift())) & (formatMask());
											if ((format13 >= (sixtyFourBitIndexableFormat()))
											 && (format13 < (firstCompiledMethodFormat()))) {

												/* avoid pushing non-pointer objects on the markStack. */
												/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
												if (((longAt(field1)) & (classIndexMask())) > 0x1F) {
													markAndTraceClassOf(field1);
												}
												goto l17;
											}
											if (format13 == (weakArrayFormat())) {

												/* push weaklings on the weakling stack to scan later */
												pushonObjStack(field1, GIV(weaklingStack));
												goto l17;
											}
											if ((format13 == 5)
											 && (activeAndDeferredScan(field1))) {
												goto l17;
											}
											/* end markAndShouldScan:; fall through */
											pushonObjStack(field1, GIV(markStack));
											if (((byteAt(field1 + 7)) > 64)
											 && (((numStrongSlots = numStrongSlotsOfInephemeral(field1))) > 64)) {
												pushonObjStack(((numStrongSlots << 3) | 1), GIV(markStack));
											}
										l17:	;

										}
									}
									objToScan = popObjStack(GIV(markStack));
								}
							} while(objToScan != null);
						l19:	/* end markAndTrace: */;
						}
					}

				}
				numToEnumerate -= numToEnumerateOnThisPage;
				objStackPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
			}
			numTracedWeaklings = size;
		} while((sizeOfObjStack(GIV(weaklingStack))) > numTracedWeaklings);
		if (((GIV(unscannedEphemerons).top)) == ((GIV(unscannedEphemerons).start))) {
			markAndTraceUntracedReachableStackPages();
			freeUntracedStackPages();
			return;
		}
		if (!(markInactiveEphemerons())) {
			/* begin fireAllUnscannedEphemerons */
			assert(!(noUnscannedEphemerons()));
			assert(allUnscannedEphemeronsAreActive());
			for (p = ((GIV(unscannedEphemerons).start)); p <= (((GIV(unscannedEphemerons).top)) - BytesPerWord); p += 1) {
				/* begin fireEphemeron: */
				queueMourner(longAt(p));
				/* begin signalFinalization: */
				weakReferenceOop = longAt(p);
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
			}
		}
		/* begin markAllUnscannedEphemerons */
		assert(!(noUnscannedEphemerons()));
		assert(allUnscannedEphemeronsAreActive());
		ptr = ((GIV(unscannedEphemerons).top)) - BytesPerWord;
		while (ptr >= ((GIV(unscannedEphemerons).start))) {
			/* begin followedKeyOfEphemeron: */
			objOop1 = (ephemeron = longAt(ptr));
			assert((isNonImmediate(objOop1))
			 && (isEphemeron(objOop1)));
			/* begin followOopField:ofObject: */
			oop = longAt((objOop1 + BaseHeaderSize) + (0LL << (shiftForWord())));
			if (((oop & (tagMask())) == 0)
			 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				oop = fixFollowedFieldofObjectwithInitialValue(0, objOop1, oop);
			}
			key = oop;
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((key & (tagMask())) != 0) {
				goto l2;
			}
			assert(!(isForwarded(key)));
			if (((((usqInt) (longAt(key))) >> 55) & 1) != 0) {
				goto l2;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(key)));
			longAtput(key, (longAt(key)) | (1LL << 55));
			format11 = (((usqInt) (longAt(key))) >> (formatShift())) & (formatMask());
			if ((format11 >= (sixtyFourBitIndexableFormat()))
			 && (format11 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(key)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(key);
				}
				goto l2;
			}
			if (format11 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(key, GIV(weaklingStack));
				goto l2;
			}
			if ((format11 == 5)
			 && (activeAndDeferredScan(key))) {
				goto l2;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan1 = key;
			do {
				if ((objToScan1 & (tagMask())) != 0) {
					scanLargeObject1 = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt1 = (((usqInt) (longAt(objToScan1))) >> (formatShift())) & (formatMask());
					assert((fmt1 != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan1))));
					if (fmt1 <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan1)) > (isForwardedObjectClassIndexPun()));
						numSlots11 = byteAt(objToScan1 + 7);
						numSlots2 = (numSlots11 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan1 - BaseHeaderSize))) << 8)))) >> 8
							: numSlots11);
						if (fmt1 <= 2) {
							numStrongSlots1 = numSlots2;
							goto l13;
						}
						if (fmt1 == (indexablePointersFormat())) {
							if (((longAt(objToScan1)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan1);
								/* begin fetchStackPointerOf: */
								sp1 = longAt((objToScan1 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp1) & 7) == 1))) {
									contextSize1 = 0;
									goto l12;
								}
								assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(objToScan1)));
								contextSize1 = (sp1 >> 3);
							l12:	/* end fetchStackPointerOf: */;
								numStrongSlots1 = CtxtTempFrameStart + contextSize1;
								goto l13;
							}
							numStrongSlots1 = numSlots2;
							goto l13;
						}
						if (fmt1 == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop12 = fetchClassOfNonImm(objToScan1);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots1 = (((longAt((objOop12 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l13;
						}
					}
					if (fmt1 == 7) {
						numStrongSlots1 = 1;
						goto l13;
					}
					if (fmt1 < (firstCompiledMethodFormat())) {
						numStrongSlots1 = 0;
						goto l13;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan1));
					header1 = longAt((objToScan1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header1) & 7) == 1));
					numLiterals1 = ((header1 >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots1 = numLiterals1 + LiteralStart;
				l13:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject1 = numStrongSlots1 > 64;
				}
				if (scanLargeObject1) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan1 & (tagMask())) != 0) {
						index1 = (objToScan1 >> 3);
						objToScan1 = topOfObjStack(GIV(markStack));
					}
					else {
						index1 = numStrongSlots1;
						markAndTraceClassOf(objToScan1);
					}
					while (index1 > 0) {
						index1 -= 1;
						field2 = longAt((objToScan1 + BaseHeaderSize) + (((long)index1) << (shiftForWord())));
						if ((field2 & (tagMask())) == 0) {
							if (((longAt(field2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field2 = fixFollowedFieldofObjectwithInitialValue(index1, objToScan1, field2);
							}
							if ((field2 & (tagMask())) != 0) {
								goto l6;
							}
							assert(!(isForwarded(field2)));
							if (((((usqInt) (longAt(field2))) >> 55) & 1) != 0) {
								goto l6;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field2)));
							longAtput(field2, (longAt(field2)) | (1LL << 55));
							format14 = (((usqInt) (longAt(field2))) >> (formatShift())) & (formatMask());
							if ((format14 >= (sixtyFourBitIndexableFormat()))
							 && (format14 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field2)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field2);
								}
								goto l6;
							}
							if (format14 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field2, GIV(weaklingStack));
								goto l6;
							}
							if ((format14 == 5)
							 && (activeAndDeferredScan(field2))) {
								goto l6;
							}
							/* end markAndShouldScan:; fall through */
							if (index1 > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan1) {
									pushonObjStack(objToScan1, GIV(markStack));
								}
								pushonObjStack(((index1 << 3) | 1), GIV(markStack));
							}
							objToScan1 = field2;
							index1 = -1;
						l6:	;

						}
					}
					if (index1 >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan1 = popObjStack(GIV(markStack));
						if (objToScan1 == key) {
							objToScan1 = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index1 = numStrongSlots1;
					markAndTraceClassOf(objToScan1);
					while (index1 > 0) {
						index1 -= 1;
						field2 = longAt((objToScan1 + BaseHeaderSize) + (((long)index1) << (shiftForWord())));
						if ((field2 & (tagMask())) == 0) {
							if (((longAt(field2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field2 = fixFollowedFieldofObjectwithInitialValue(index1, objToScan1, field2);
							}
							if ((field2 & (tagMask())) != 0) {
								goto l7;
							}
							assert(!(isForwarded(field2)));
							if (((((usqInt) (longAt(field2))) >> 55) & 1) != 0) {
								goto l7;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field2)));
							longAtput(field2, (longAt(field2)) | (1LL << 55));
							format14 = (((usqInt) (longAt(field2))) >> (formatShift())) & (formatMask());
							if ((format14 >= (sixtyFourBitIndexableFormat()))
							 && (format14 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field2)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field2);
								}
								goto l7;
							}
							if (format14 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field2, GIV(weaklingStack));
								goto l7;
							}
							if ((format14 == 5)
							 && (activeAndDeferredScan(field2))) {
								goto l7;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field2, GIV(markStack));
							if (((byteAt(field2 + 7)) > 64)
							 && (((numStrongSlots1 = numStrongSlotsOfInephemeral(field2))) > 64)) {
								pushonObjStack(((numStrongSlots1 << 3) | 1), GIV(markStack));
							}
						l7:	;

						}
					}
					objToScan1 = popObjStack(GIV(markStack));
				}
			} while(objToScan1 != null);
		l2:	/* end markAndTrace: */;
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((ephemeron & (tagMask())) != 0) {
				goto l3;
			}
			assert(!(isForwarded(ephemeron)));
			if (((((usqInt) (longAt(ephemeron))) >> 55) & 1) != 0) {
				goto l3;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(ephemeron)));
			longAtput(ephemeron, (longAt(ephemeron)) | (1LL << 55));
			format12 = (((usqInt) (longAt(ephemeron))) >> (formatShift())) & (formatMask());
			if ((format12 >= (sixtyFourBitIndexableFormat()))
			 && (format12 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(ephemeron)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(ephemeron);
				}
				goto l3;
			}
			if (format12 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(ephemeron, GIV(weaklingStack));
				goto l3;
			}
			if ((format12 == 5)
			 && (activeAndDeferredScan(ephemeron))) {
				goto l3;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan2 = ephemeron;
			do {
				if ((objToScan2 & (tagMask())) != 0) {
					scanLargeObject2 = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt2 = (((usqInt) (longAt(objToScan2))) >> (formatShift())) & (formatMask());
					assert((fmt2 != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan2))));
					if (fmt2 <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan2)) > (isForwardedObjectClassIndexPun()));
						numSlots12 = byteAt(objToScan2 + 7);
						numSlots3 = (numSlots12 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan2 - BaseHeaderSize))) << 8)))) >> 8
							: numSlots12);
						if (fmt2 <= 2) {
							numStrongSlots2 = numSlots3;
							goto l15;
						}
						if (fmt2 == (indexablePointersFormat())) {
							if (((longAt(objToScan2)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan2);
								/* begin fetchStackPointerOf: */
								sp2 = longAt((objToScan2 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp2) & 7) == 1))) {
									contextSize2 = 0;
									goto l14;
								}
								assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(objToScan2)));
								contextSize2 = (sp2 >> 3);
							l14:	/* end fetchStackPointerOf: */;
								numStrongSlots2 = CtxtTempFrameStart + contextSize2;
								goto l15;
							}
							numStrongSlots2 = numSlots3;
							goto l15;
						}
						if (fmt2 == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop13 = fetchClassOfNonImm(objToScan2);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots2 = (((longAt((objOop13 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l15;
						}
					}
					if (fmt2 == 7) {
						numStrongSlots2 = 1;
						goto l15;
					}
					if (fmt2 < (firstCompiledMethodFormat())) {
						numStrongSlots2 = 0;
						goto l15;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan2));
					header2 = longAt((objToScan2 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header2) & 7) == 1));
					numLiterals2 = ((header2 >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots2 = numLiterals2 + LiteralStart;
				l15:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject2 = numStrongSlots2 > 64;
				}
				if (scanLargeObject2) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan2 & (tagMask())) != 0) {
						index2 = (objToScan2 >> 3);
						objToScan2 = topOfObjStack(GIV(markStack));
					}
					else {
						index2 = numStrongSlots2;
						markAndTraceClassOf(objToScan2);
					}
					while (index2 > 0) {
						index2 -= 1;
						field3 = longAt((objToScan2 + BaseHeaderSize) + (((long)index2) << (shiftForWord())));
						if ((field3 & (tagMask())) == 0) {
							if (((longAt(field3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field3 = fixFollowedFieldofObjectwithInitialValue(index2, objToScan2, field3);
							}
							if ((field3 & (tagMask())) != 0) {
								goto l8;
							}
							assert(!(isForwarded(field3)));
							if (((((usqInt) (longAt(field3))) >> 55) & 1) != 0) {
								goto l8;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field3)));
							longAtput(field3, (longAt(field3)) | (1LL << 55));
							format15 = (((usqInt) (longAt(field3))) >> (formatShift())) & (formatMask());
							if ((format15 >= (sixtyFourBitIndexableFormat()))
							 && (format15 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field3)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field3);
								}
								goto l8;
							}
							if (format15 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field3, GIV(weaklingStack));
								goto l8;
							}
							if ((format15 == 5)
							 && (activeAndDeferredScan(field3))) {
								goto l8;
							}
							/* end markAndShouldScan:; fall through */
							if (index2 > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan2) {
									pushonObjStack(objToScan2, GIV(markStack));
								}
								pushonObjStack(((index2 << 3) | 1), GIV(markStack));
							}
							objToScan2 = field3;
							index2 = -1;
						l8:	;

						}
					}
					if (index2 >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan2 = popObjStack(GIV(markStack));
						if (objToScan2 == ephemeron) {
							objToScan2 = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index2 = numStrongSlots2;
					markAndTraceClassOf(objToScan2);
					while (index2 > 0) {
						index2 -= 1;
						field3 = longAt((objToScan2 + BaseHeaderSize) + (((long)index2) << (shiftForWord())));
						if ((field3 & (tagMask())) == 0) {
							if (((longAt(field3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field3 = fixFollowedFieldofObjectwithInitialValue(index2, objToScan2, field3);
							}
							if ((field3 & (tagMask())) != 0) {
								goto l9;
							}
							assert(!(isForwarded(field3)));
							if (((((usqInt) (longAt(field3))) >> 55) & 1) != 0) {
								goto l9;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field3)));
							longAtput(field3, (longAt(field3)) | (1LL << 55));
							format15 = (((usqInt) (longAt(field3))) >> (formatShift())) & (formatMask());
							if ((format15 >= (sixtyFourBitIndexableFormat()))
							 && (format15 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field3)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field3);
								}
								goto l9;
							}
							if (format15 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field3, GIV(weaklingStack));
								goto l9;
							}
							if ((format15 == 5)
							 && (activeAndDeferredScan(field3))) {
								goto l9;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field3, GIV(markStack));
							if (((byteAt(field3 + 7)) > 64)
							 && (((numStrongSlots2 = numStrongSlotsOfInephemeral(field3))) > 64)) {
								pushonObjStack(((numStrongSlots2 << 3) | 1), GIV(markStack));
							}
						l9:	;

						}
					}
					objToScan2 = popObjStack(GIV(markStack));
				}
			} while(objToScan2 != null);
		l3:	/* end markAndTrace: */;
			(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) - BytesPerWord);
			if (ptr < ((GIV(unscannedEphemerons).top))) {

				/* not the last entry; remove it by overwriting it with the last
				   ephemeron (which must have been newly added by markAndTrace:). */
				longAtput(ptr, longAt((GIV(unscannedEphemerons).top)));
			}
			ptr -= BytesPerWord;
		}
	}
}


/*	Answer one of the objects in the SpecialObjectsArray, if in range,
	otherwise answer nil.
 */

	/* SpurMemoryManager>>#maybeSplObj: */
sqInt
maybeSplObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (index < (numSlotsOf(GIV(specialObjectsOop)))
		? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)index) << (shiftForWord())))
		: 0);
}


/*	Answer the method header of a CompiledMethod object. */

	/* SpurMemoryManager>>#methodHeaderOf: */
static sqInt NoDbgRegParms
methodHeaderOf(sqInt methodObj)
{
	assert(isCompiledMethod(methodObj));
	return longAt((methodObj + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
}


/*	Move the sequence of movable objects starting at startAddress. Answer the
	start of the next sequence of movable objects after a possible run of
	unmovable objects,
	or the limit, if there are no more movable objects, or 0 if no more
	compaction can be
	done. Compaction is done when the search through the freeList has reached
	the address from which objects are being moved from.
	
	There are two broad cases to be dealt with here. One is a run of smallish
	objects that can easily be moved into free chunks. The other is a large
	object that is unlikely
	to fit in the typical free chunk. This second pig needs careful handling;
	it needs to be
	moved to the lowest place it will fit and not cause the scan to skip lots
	of smaller
	free chunks looking in vain for somewhere to put it. */

	/* SpurMemoryManager>>#moveARunOfObjectsStartingAt:upTo: */
static sqInt NoDbgRegParms
moveARunOfObjectsStartingAtupTo(usqInt startAddress, usqInt limit)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunkBytes;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt dest;
    usqInt destination;
    usqInt endOfFree;
    usqInt freeBytes;
    usqInt freeChunk;
    usqInt here;
    sqInt hereObj;
    sqInt hereObjHeader;
    usqInt maxFreeChunk;
    sqInt moved;
    sqInt newChunk;
    usqInt next;
    usqInt nextFree;
    usqInt nextNext;
    usqInt nextNextFree;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    usqInt numSlots5;
    usqInt numSlots6;
    sqInt obj2;
    sqInt obj21;
    sqInt pigBytes;
    usqInt prevFree;
    usqInt prevFreeChunk;
    usqInt prevPrevFree;
    usqInt prevPrevFreeChunk;
    sqInt slotBytes;
    sqInt slotBytes1;
    usqInt there;
    usqInt thisFreeChunk;
    sqInt usedChunk;

	nextNext = 0;
	nextNextFree = 0;
	here = startAddress;
	/* begin objectStartingAt: */
	numSlots6 = byteAt(startAddress + 7);
	hereObj = (numSlots6 == (numSlotsMask())
		? startAddress + BaseHeaderSize
		: startAddress);
	hereObjHeader = longAt(hereObj);
	prevPrevFreeChunk = (prevFreeChunk = 0);
	thisFreeChunk = (maxFreeChunk = GIV(firstFreeChunk));
	while (thisFreeChunk != 0) {

		/* skip any initial immobile objects */
		while (!((((((usqInt) hereObjHeader) >> 30) & 1) == 0)
		 && ((hereObjHeader & (classIndexMask())) > (isForwardedObjectClassIndexPun())))) {
			/* begin addressAfter: */
			numSlots1 = byteAt(hereObj + 7);
			numSlots = (numSlots1 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(hereObj - BaseHeaderSize))) << 8)))) >> 8
				: numSlots1);
			if (numSlots == 0) {
				slotBytes = 8;
			}
			else {
				slotBytes = ((long)numSlots) << (shiftForWord());
			}
			here = (hereObj + BaseHeaderSize) + slotBytes;
			if (here >= limit) {
				return (maxFreeChunk >= startAddress
					? 0
					: limit);
			}
			/* begin objectStartingAt: */
			numSlots2 = byteAt(here + 7);
			hereObj = (numSlots2 == (numSlotsMask())
				? here + BaseHeaderSize
				: here);
			hereObjHeader = longAt(hereObj);
		}
		assert((isFreeObject(GIV(firstFreeChunk)))
		 && (isFreeObject(thisFreeChunk)));
		freeBytes = bytesInObject(thisFreeChunk);
		nextFree = ((usqInt)((longAt((thisFreeChunk + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ prevFreeChunk));
		destination = ((byteAt(thisFreeChunk + 7)) == (numSlotsMask())
			? thisFreeChunk - BaseHeaderSize
			: thisFreeChunk);
		endOfFree = destination + freeBytes;
		moved = 0;
		maxFreeChunk = ((maxFreeChunk < nextFree) ? nextFree : maxFreeChunk);
		assert((nextFree == 0)
		 || (isFreeObject(nextFree)));
		while (1) {
			/* begin addressAfter: */
			numSlots11 = byteAt(hereObj + 7);
			numSlots3 = (numSlots11 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(hereObj - BaseHeaderSize))) << 8)))) >> 8
				: numSlots11);
			if (numSlots3 == 0) {
				slotBytes1 = 8;
			}
			else {
				slotBytes1 = ((long)numSlots3) << (shiftForWord());
			}
			there = (hereObj + BaseHeaderSize) + slotBytes1;
			if (!(((((((usqInt) hereObjHeader) >> 30) & 1) == 0)
			 && ((hereObjHeader & (classIndexMask())) > (isForwardedObjectClassIndexPun())))
			 && ((freeBytes > ((there - here) + 8))
			 || (freeBytes == (there - here))))) break;
			moved = 1;
			memcpy(((void *)destination), ((void *)here), there - here);
			/* begin forwardUnchecked:to: */
			obj2 = destination + (hereObj - here);
			assert((isInOldSpace(hereObj))
			 && (isInOldSpace(obj2)));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(hereObj)));
			longAtput((hereObj + BaseHeaderSize) + (0LL << (shiftForWord())), obj2);
			/* begin set:classIndexTo:formatTo: */
			classIndex = isForwardedObjectClassIndexPun();
			assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
			assert(((7 >= 0) && (7 <= (formatMask()))));
			longAtput(hereObj, ((longAt(hereObj)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex + (7LL << (formatShift()))));
			destination += there - here;
			freeBytes -= there - here;
			/* begin objectStartingAt: */
			numSlots4 = byteAt(there + 7);
			hereObj = (numSlots4 == (numSlotsMask())
				? there + BaseHeaderSize
				: there);
			here = there;
			hereObjHeader = longAt(hereObj);
		}
		if (moved) {

			/* we did overwrite it; we need to repair the free list */
			if (nextFree != 0) {
				nextNextFree = ((usqInt)((longAt((nextFree + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ thisFreeChunk));
				assert(isFreeObject(nextFree));
			}
			if ((destination > thisFreeChunk)
			 && (destination < endOfFree)) {

				/* if false, filled entire free chunk */
				thisFreeChunk = initFreeChunkWithBytesat(endOfFree - destination, destination);
				/* begin inSortedFreeListLink:to:given: */
				if (prevFreeChunk == 0) {
					GIV(firstFreeChunk) = thisFreeChunk;
				}
				else {
					/* begin storePointer:ofFreeChunk:withUncheckedValue: */
					assert(isFreeObject(prevFreeChunk));
					longAtput((prevFreeChunk + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFreeChunk ^ thisFreeChunk);
				}
				/* begin inSortedFreeListLink:to:given: */
				if (thisFreeChunk == 0) {
					GIV(firstFreeChunk) = nextFree;
				}
				else {
					/* begin storePointer:ofFreeChunk:withUncheckedValue: */
					assert(isFreeObject(thisFreeChunk));
					longAtput((thisFreeChunk + BaseHeaderSize) + (0LL << (shiftForWord())), prevFreeChunk ^ nextFree);
				}
				if (nextFree != 0) {
					/* begin inSortedFreeListLink:to:given: */
					if (nextFree == 0) {
						GIV(firstFreeChunk) = nextNextFree;
					}
					else {
						/* begin storePointer:ofFreeChunk:withUncheckedValue: */
						assert(isFreeObject(nextFree));
						longAtput((nextFree + BaseHeaderSize) + (0LL << (shiftForWord())), thisFreeChunk ^ nextNextFree);
					}
				}
				prevPrevFreeChunk = prevFreeChunk;
				prevFreeChunk = thisFreeChunk;
				thisFreeChunk = nextFree;
			}
			else {
				/* begin inSortedFreeListLink:to:given: */
				if (prevFreeChunk == 0) {
					GIV(firstFreeChunk) = nextFree;
				}
				else {
					/* begin storePointer:ofFreeChunk:withUncheckedValue: */
					assert(isFreeObject(prevFreeChunk));
					longAtput((prevFreeChunk + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFreeChunk ^ nextFree);
				}
				if (nextFree != 0) {
					/* begin inSortedFreeListLink:to:given: */
					if (nextFree == 0) {
						GIV(firstFreeChunk) = nextNextFree;
					}
					else {
						/* begin storePointer:ofFreeChunk:withUncheckedValue: */
						assert(isFreeObject(nextFree));
						longAtput((nextFree + BaseHeaderSize) + (0LL << (shiftForWord())), prevFreeChunk ^ nextNextFree);
					}
				}
				thisFreeChunk = nextFree;
			}
		}
		else {

			/* out of space (or immobile object); move on up the free list... */
			prevPrevFreeChunk = prevFreeChunk;
			prevFreeChunk = thisFreeChunk;
			thisFreeChunk = nextFree;
		}
		if (!((((((usqInt) hereObjHeader) >> 30) & 1) == 0)
			 && ((hereObjHeader & (classIndexMask())) > (isForwardedObjectClassIndexPun())))) {
			return (maxFreeChunk >= startAddress
				? 0
				: there);
		}
		if ((there - here) >= ((8 * BytesPerOop) * 8)) {

			/* 256b in 32 bit, 512b in 64 bit */
			/* begin tryToMovePig:at:end: */
			prevPrevFree = (prevFree = 0);
			freeChunk = GIV(firstFreeChunk);
			pigBytes = there - here;
			while ((freeChunk != 0)
			 && (freeChunk < hereObj)) {
				next = ((usqInt)((longAt((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ prevFree));
				dest = ((byteAt(freeChunk + 7)) == (numSlotsMask())
					? freeChunk - BaseHeaderSize
					: freeChunk);

				/* N.B. *must* add allocationUnit, not subtract, to avoid unsigned arithmetic issues when chunkBytes = 0 */
				chunkBytes = (addressAfter(freeChunk)) - dest;
				if ((chunkBytes == pigBytes)
				 || (chunkBytes > (pigBytes + 8))) {
					memcpy(((void *)dest), ((void *)here), pigBytes);
					/* begin forwardUnchecked:to: */
					obj21 = dest + (hereObj - here);
					assert((isInOldSpace(hereObj))
					 && (isInOldSpace(obj21)));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(hereObj)));
					longAtput((hereObj + BaseHeaderSize) + (0LL << (shiftForWord())), obj21);
					/* begin set:classIndexTo:formatTo: */
					classIndex1 = isForwardedObjectClassIndexPun();
					assert(((classIndex1 >= 0) && (classIndex1 <= (classIndexMask()))));
					assert(((7 >= 0) && (7 <= (formatMask()))));
					longAtput(hereObj, ((longAt(hereObj)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex1 + (7LL << (formatShift()))));
					if (next != 0) {
						nextNext = ((usqInt)((longAt((next + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ freeChunk));
					}
					if (pigBytes < chunkBytes) {

						/* if false, filled entire free chunk */
						newChunk = initFreeChunkWithBytesat(chunkBytes - pigBytes, dest + pigBytes);
						/* begin inSortedFreeListLink:to:given: */
						if (prevFree == 0) {
							GIV(firstFreeChunk) = newChunk;
						}
						else {
							/* begin storePointer:ofFreeChunk:withUncheckedValue: */
							assert(isFreeObject(prevFree));
							longAtput((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree ^ newChunk);
						}
						/* begin inSortedFreeListLink:to:given: */
						if (newChunk == 0) {
							GIV(firstFreeChunk) = next;
						}
						else {
							/* begin storePointer:ofFreeChunk:withUncheckedValue: */
							assert(isFreeObject(newChunk));
							longAtput((newChunk + BaseHeaderSize) + (0LL << (shiftForWord())), prevFree ^ next);
						}
						if (next != 0) {
							/* begin inSortedFreeListLink:to:given: */
							if (next == 0) {
								GIV(firstFreeChunk) = nextNext;
							}
							else {
								/* begin storePointer:ofFreeChunk:withUncheckedValue: */
								assert(isFreeObject(next));
								longAtput((next + BaseHeaderSize) + (0LL << (shiftForWord())), newChunk ^ nextNext);
							}
						}
					}
					else {
						/* begin inSortedFreeListLink:to:given: */
						if (prevFree == 0) {
							GIV(firstFreeChunk) = next;
						}
						else {
							/* begin storePointer:ofFreeChunk:withUncheckedValue: */
							assert(isFreeObject(prevFree));
							longAtput((prevFree + BaseHeaderSize) + (0LL << (shiftForWord())), prevPrevFree ^ next);
						}
						if (next != 0) {
							/* begin inSortedFreeListLink:to:given: */
							if (next == 0) {
								GIV(firstFreeChunk) = nextNext;
							}
							else {
								/* begin storePointer:ofFreeChunk:withUncheckedValue: */
								assert(isFreeObject(next));
								longAtput((next + BaseHeaderSize) + (0LL << (shiftForWord())), prevFree ^ nextNext);
							}
						}
					}
					usedChunk = freeChunk;
					goto l1;
				}
				prevPrevFree = prevFree;
				prevFree = freeChunk;
				freeChunk = next;
			}
			usedChunk = 0;
		l1:	/* end tryToMovePig:at:end: */;
			/* begin objectStartingAt: */
			numSlots5 = byteAt(there + 7);
			hereObj = (numSlots5 == (numSlotsMask())
				? there + BaseHeaderSize
				: there);
			here = there;

			/* In general it's a bad idea to reset the enumeration; it leads to N^2 behaviour
			   when encountering pigs.  But if the move affected the enumeration this is
			   simpler than resetting the list pointers. */
			hereObjHeader = longAt(hereObj);
			if ((usedChunk == prevPrevFreeChunk)
			 || ((usedChunk == prevFreeChunk)
			 || (usedChunk == thisFreeChunk))) {

				/* reset the scan for free space back to the start of the list */
				prevPrevFreeChunk = (prevFreeChunk = 0);
				thisFreeChunk = GIV(firstFreeChunk);
			}
		}
		if (((here > startAddress)
		 && (there >= limit))
		 || (maxFreeChunk >= startAddress)) {
			return (maxFreeChunk >= startAddress
				? 0
				: there);
		}
	}
	return here;
}


/*	Use a slight variation on D.H. Lehmer's linear congruential generator from
	1951. See e.g. http://en.wikipedia.org/wiki/Linear_congruential_generator. */

	/* SpurMemoryManager>>#newObjectHash */
static sqInt
newObjectHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;

	do {
		GIV(lastHash) = GIV(lastHash) * 16807;

		/* adding the top bits gives much better spread.  See below: */
		hash = GIV(lastHash) + (((usqInt) GIV(lastHash)) >> 4);
	} while((hash & (identityHashHalfWordMask())) == 0);
	return hash;
}

	/* SpurMemoryManager>>#newSpaceIsEmpty */
static sqInt
newSpaceIsEmpty(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(freeStart) == (((eden()).start)))
	 && (GIV(pastSpaceStart) == (((pastSpace()).start)));
}


/*	Answer the next free free chunk using the xor trick to use only one field,
	see e.g.
	The Art of Computer Programming, Vol 1, D.E. Knuth, 3rd Ed, Sec 2.2.4
	`Circular Lists', exercise. 18
	http://en.wikipedia.org/wiki/XOR_linked_list. */

	/* SpurMemoryManager>>#nextInSortedFreeListLink:given: */
usqInt
nextInSortedFreeListLinkgiven(sqInt freeChunk, sqInt prevFree)
{
	return ((usqInt)((longAt((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ prevFree));
}

	/* SpurMemoryManager>>#nilObject */
sqInt
nilObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}


/*	Nil the unmarked slots in the weaklings on the
	weakling stack, finalizing those that lost references.
	Finally, empty the weaklingStack. */
/*	for profiling */

	/* SpurMemoryManager>>#nilUnmarkedWeaklingSlots */
static void NeverInline
nilUnmarkedWeaklingSlots(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anyUnmarked;
    sqInt anyUnmarked1;
    sqInt cascade0;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt numOnThisPage;
    sqInt numToEnumerate;
    sqInt numToEnumerateOnThisPage;
    sqInt objStackPage;
    sqInt referent;
    sqInt size;
    sqInt topIndex;
    sqInt weakling;

	eassert(allOldMarkedWeakObjectsOnWeaklingStack());
	if (GIV(weaklingStack) == GIV(nilObj)) {
		return;
	}
	/* begin objStack:from:do: */
	eassert(isValidObjStack(GIV(weaklingStack)));
	size = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
	objStackPage = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
	while (objStackPage != 0) {
		size += ObjStackLimit;
		assert((fetchPointerofObject(ObjStackTopx, objStackPage)) == ObjStackLimit);
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
	}
	numToEnumerate = size;
	objStackPage = GIV(weaklingStack);
	while (numToEnumerate > 0) {
		numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
		numToEnumerateOnThisPage = ((numToEnumerate < numOnThisPage) ? numToEnumerate : numOnThisPage);
		topIndex = (numOnThisPage + ObjStackFixedSlots) - 1;
		for (i = topIndex; i >= ((topIndex - numToEnumerateOnThisPage) + 1); i += -1) {
			assert(isWeak(fetchPointerofObject(i, objStackPage)));
			weakling = longAt((objStackPage + BaseHeaderSize) + (((long)i) << (shiftForWord())));
			/* begin nilUnmarkedWeaklingSlotsIn: */
			anyUnmarked1 = 0;
			assert(allStrongSlotsOfWeaklingAreMarked(weakling));
			for (i1 = (numStrongSlotsOfWeakling(weakling)), iLimiT = ((numSlotsOf(weakling)) - 1); i1 <= iLimiT; i1 += 1) {
				referent = longAt((weakling + BaseHeaderSize) + (((long)i1) << (shiftForWord())));
				if ((referent & (tagMask())) == 0) {
					if (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
						referent = fixFollowedFieldofObjectwithInitialValue(i1, weakling, referent);
					}
					if (!(((referent & (tagMask())) != 0)
						 || (((((usqInt) (longAt(referent))) >> 55) & 1) != 0))) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(weakling)));
						longAtput((weakling + BaseHeaderSize) + (((long)i1) << (shiftForWord())), GIV(nilObj));
						anyUnmarked1 = 1;
					}
				}
			}
			anyUnmarked = anyUnmarked1;
			if (anyUnmarked) {
				/* begin fireFinalization: */
				if (GIV(newFinalization)) {
					queueMourner(weakling);
				}
				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
			}

		}
		numToEnumerate -= numToEnumerateOnThisPage;
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
	}
	emptyObjStack(GIV(weaklingStack));
}

	/* SpurMemoryManager>>#noCheckClassAtIndex: */
static sqInt NoDbgRegParms
noCheckClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	/* begin fetchPointer:ofObject: */
	fieldIndex = ((usqInt) classIndex) >> (classTableMajorIndexShift());
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	/* begin fetchPointer:ofObject: */
	fieldIndex1 = classIndex & ((1LL << (classTableMajorIndexShift())) - 1);
	return longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
}


/*	Push an element on an objStack. Split from push:onObjStack: for testing. */

	/* SpurMemoryManager>>#noCheckPush:onObjStack: */
static sqInt NoDbgRegParms
noCheckPushonObjStack(sqInt objOop, sqInt objStack)
{
    sqInt topx;

	eassert(isValidObjStack(objStack));
	topx = longAt((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
	if (topx >= ObjStackLimit) {
		noCheckPushonObjStack(objOop, ensureRoomOnObjStackAt(longAt((objStack + BaseHeaderSize) + (((long)ObjStackMyx) << (shiftForWord())))));
	}
	else {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + (((long)(ObjStackFixedSlots + topx)) << (shiftForWord())), objOop);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())), topx + 1);
	}
	return objOop;
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

	/* SpurMemoryManager>>#noFixupFollowField:ofObject: */
static sqInt NoDbgRegParms
noFixupFollowFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;
    sqInt referent;

	objOop = longAt((anObject + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(objOop));
		referent = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		objOop = referent;
	}
	return objOop;
}

	/* SpurMemoryManager>>#noInlineFollowForwarded: */
static sqInt NoDbgRegParms
noInlineFollowForwarded(sqInt objOop)
{
    sqInt referent;

	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(objOop));
	referent = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
	while (((referent & (tagMask())) == 0)
	 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
	}
	return referent;
}

	/* SpurMemoryManager>>#nonIndexablePointerFormat */
sqInt
nonIndexablePointerFormat(void)
{
	return 1;
}

	/* SpurMemoryManager>>#noUnscannedEphemerons */
static sqInt
noUnscannedEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(unscannedEphemerons).top)) == ((GIV(unscannedEphemerons).start));
}


/*	Answer the number of indexable bytes in the given non-immediate
	byte-indexable object.
 */

	/* SpurMemoryManager>>#numBytesOfBytes: */
static sqInt NoDbgRegParms
numBytesOfBytes(sqInt objOop)
{
    sqInt fmt;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	return (((long)(numSlotsOf(objOop))) << (shiftForWord())) - (fmt & 7);
}


/*	Answer the number of indexable bytes in the given non-immediate object.
	Does not adjust the size of contexts by stackPointer. */

	/* SpurMemoryManager>>#numBytesOf: */
sqInt
numBytesOf(sqInt objOop)
{
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(objOop + 7);
	numBytes = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	numBytes = ((long)numBytes) << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat())) {
		return numBytes - (((long)(fmt & 3)) << 1);
	}
	return numBytes - (((long)(fmt & 1)) << 2);
}

	/* SpurMemoryManager>>#numberOfForwarders */
static sqInt
numberOfForwarders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    sqInt n;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	n = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
			n += 1;
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		if (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
			n += 1;
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			objOop1 = limit;
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
			n += 1;
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	return n;
}


/*	Answer the number of pointer fields in the given object.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numPointerSlotsOf: */
sqInt
numPointerSlotsOf(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    usqInt numSlots;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	if (fmt <= 5) {
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
			contextSize = (sp >> 3);
		l1:	/* end fetchStackPointerOf: */;
			return CtxtTempFrameStart + contextSize;
		}
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(objOop + 7);
		return (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);
	}
	if (fmt == 7) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header = longAt((objOop + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}


/*	A private internal version of numSlotsOf: that is happy to be applied to
	free or forwarded objects.
 */

	/* SpurMemoryManager>>#numSlotsOfAny: */
static usqInt NoDbgRegParms
numSlotsOfAny(sqInt objOop)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	return (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
}

	/* SpurMemoryManager>>#numSlotsOf: */
usqInt
numSlotsOf(sqInt objOop)
{
    usqInt numSlots;

	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(objOop + 7);
	return (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
}


/*	Answer the number of strong pointer fields in the given object,
	which is .expected not to be an active ephemeron.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numStrongSlotsOfInephemeral: */
static sqInt NoDbgRegParms
numStrongSlotsOfInephemeral(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	assert((fmt != (ephemeronFormat()))
	 || (isMarked(keyOfEphemeron(objOop))));
	if (fmt <= 5) {
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
		numSlots1 = byteAt(objOop + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (fmt <= 2) {
			return numSlots;
		}
		if (fmt == (indexablePointersFormat())) {
			if (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(objOop);
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l1;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
				contextSize = (sp >> 3);
			l1:	/* end fetchStackPointerOf: */;
				return CtxtTempFrameStart + contextSize;
			}
			return numSlots;
		}
		if (fmt == (weakArrayFormat())) {
			/* begin fixedFieldsOfClass: */
			objOop1 = fetchClassOfNonImm(objOop);
			/* begin fixedFieldsOfClassFormat: */
			return (((longAt((objOop1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
		}
	}
	if (fmt == 7) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header = longAt((objOop + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}


/*	Answer the number of strong pointer fields in the given weakling. */

	/* SpurMemoryManager>>#numStrongSlotsOfWeakling: */
sqInt
numStrongSlotsOfWeakling(sqInt objOop)
{
    sqInt objOop1;

	assert((formatOf(objOop)) == (weakArrayFormat()));
	/* begin fixedFieldsOfClass: */
	objOop1 = fetchClassOfNonImm(objOop);
	/* begin fixedFieldsOfClassFormat: */
	return (((longAt((objOop1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#objectAfter: */
sqInt
objectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt followingWordAddress3;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;
    sqInt slotBytes3;

	if (oopisLessThan(objOop, GIV(newSpaceLimit))) {
		if (oopisGreaterThanOrEqualToandLessThan(objOop, ((eden()).start), GIV(freeStart))) {
			/* begin objectAfter:limit: */
			numSlots1 = byteAt(objOop + 7);
			numSlots = (numSlots1 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
				: numSlots1);
			if (numSlots == 0) {
				slotBytes = 8;
			}
			else {
				slotBytes = ((long)numSlots) << (shiftForWord());
			}
			followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
				return GIV(freeStart);
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			return ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
		}
		if (oopisGreaterThanOrEqualToandLessThan(objOop, ((pastSpace()).start), GIV(pastSpaceStart))) {
			/* begin objectAfter:limit: */
			numSlots11 = byteAt(objOop + 7);
			numSlots2 = (numSlots11 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
				: numSlots11);
			if (numSlots2 == 0) {
				slotBytes1 = 8;
			}
			else {
				slotBytes1 = ((long)numSlots2) << (shiftForWord());
			}
			followingWordAddress1 = (objOop + BaseHeaderSize) + slotBytes1;
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart))) {
				return GIV(pastSpaceStart);
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			return ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		}
		/* begin objectAfter:limit: */
		limit = futureSurvivorStart();
		/* begin addressAfter: */
		numSlots12 = byteAt(objOop + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress2 = (objOop + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			return limit;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		return ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	}
	/* begin objectAfter:limit: */
	numSlots13 = byteAt(objOop + 7);
	numSlots4 = (numSlots13 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots13);
	if (numSlots4 == 0) {
		slotBytes3 = 8;
	}
	else {
		slotBytes3 = ((long)numSlots4) << (shiftForWord());
	}
	followingWordAddress3 = (objOop + BaseHeaderSize) + slotBytes3;
	if (oopisGreaterThanOrEqualTo(followingWordAddress3, GIV(endOfMemory))) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord3 = longAt(followingWordAddress3);
	return ((((usqInt) followingWord3) >> (numSlotsFullShift())) == (numSlotsMask())
		? followingWordAddress3 + BaseHeaderSize
		: followingWordAddress3);
}

	/* SpurMemoryManager>>#objectBefore: */
sqInt
objectBefore(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt o;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prev;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	prev = null;
	if (oopisLessThan(objOop, GIV(newSpaceLimit))) {
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj = (prevObj = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		/* begin objectStartingAt: */
		address = ((pastSpace()).start);
		numSlots = byteAt(address + 7);
		objOop1 = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		limit = GIV(pastSpaceStart);
		while (oopisLessThan(objOop1, limit)) {
			if (oopisGreaterThanOrEqualTo(objOop1, objOop)) {
				return prev;
			}
			prev = objOop1;

			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			numSlots11 = byteAt(objOop1 + 7);
			numSlots2 = (numSlots11 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots11);
			if (numSlots2 == 0) {
				slotBytes = 8;
			}
			else {
				slotBytes = ((long)numSlots2) << (shiftForWord());
			}
			followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
			if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
				objOop1 = limit;
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
		l1:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address1 = ((eden()).start);
		numSlots1 = byteAt(address1 + 7);
		objOop1 = (numSlots1 == (numSlotsMask())
			? address1 + BaseHeaderSize
			: address1);
		while (oopisLessThan(objOop1, GIV(freeStart))) {
			if (oopisGreaterThanOrEqualTo(objOop1, objOop)) {
				return prev;
			}
			prev = objOop1;

			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			numSlots12 = byteAt(objOop1 + 7);
			numSlots3 = (numSlots12 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots12);
			if (numSlots3 == 0) {
				slotBytes1 = 8;
			}
			else {
				slotBytes1 = ((long)numSlots3) << (shiftForWord());
			}
			followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
				objOop1 = GIV(freeStart);
				goto l2;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		l2:	/* end objectAfter:limit: */;
		}
		return prev;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop2 = GIV(nilObj);
	while (1) {
		assert((objOop2 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop2, GIV(endOfMemory)))) break;
		assert((long64At(objOop2)) != 0);
		if (oopisGreaterThanOrEqualTo(objOop2, objOop)) {
			return prev;
		}
		prev = objOop2;

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop2;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop2 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop2 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop2 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop2 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop2 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	return prev;
}


/*	For enumerating objects find the header of the first object in a space.
	If the object starts with an overflow size field it will start at the next
	allocationUnit. c.f. numSlotsOf: */

	/* SpurMemoryManager>>#objectStartingAt: */
static sqInt NoDbgRegParms
objectStartingAt(sqInt address)
{
    usqInt numSlots;

	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
}


/*	This message is deprecated but supported for a while via a tweak to
	sqVirtualMachine.[ch] Use fetchLong32, fetchLong64 or fetchPointer instead
	for new code
 */

	/* SpurMemoryManager>>#obsoleteDontUseThisFetchWord:ofObject: */
sqInt
obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (((long)fieldIndex) << 2));
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

	/* SpurMemoryManager>>#okayOop: */
static sqInt NoDbgRegParms
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqInt oop;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */
	oop = ((usqInt) signedOop);
	if ((oop & (tagMask())) != 0) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = (longAt(oop)) & (classIndexMask()))) >= 16)) {
		error("oop is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask()))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask()))) {
		error("oop header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	if ((fmt == 6) || (fmt == 8)) {
		error("oop has an unknown format type");
		return 0;
	}
	if ((fmt == 7) != (classIndex == (isForwardedObjectClassIndexPun()))) {
		error("oop has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1LL << 22) | (1LL << (22 + 32));
	if (((long64At(oop)) & unusedBits) != 0) {
		error("some unused header bits are set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = ((1LL << 0x1F) | (1LL << 30)) | (1LL << (rememberedBitShift()));
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		error("some header bits unused in young objects are set; should be zero");
		return 0;
	}
	return 1;
}


/*	in an effort to fix a compiler bug with two-way become post r3427 */
/*	Allocate two new objects, n1 & n2. Copy the contents appropriately.
	Convert obj1 and obj2 into forwarding objects pointing to n2 and n1
	respectively  */

	/* SpurMemoryManager>>#outOfPlaceBecome:and:copyHashFlag: */
static void NoDbgRegParms NeverInline
outOfPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt clone1;
    sqInt clone2;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt hash3;

	clone1 = (((longAt(obj1)) & (classIndexMask())) == ClassMethodContextCompactIndex
		? cloneContext(obj1)
		: clone(obj1));
	clone2 = (((longAt(obj2)) & (classIndexMask())) == ClassMethodContextCompactIndex
		? cloneContext(obj2)
		: clone(obj2));
	if (copyHashFlag) {
		/* begin setHashBitsOf:to: */
		hash = (long32At(obj1 + 4)) & (identityHashHalfWordMask());
		flag("endianness");
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		long32Atput(clone1 + 4, ((((long32At(clone1 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
		/* begin setHashBitsOf:to: */
		hash1 = (long32At(obj2 + 4)) & (identityHashHalfWordMask());
		flag("endianness");
		assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
		long32Atput(clone2 + 4, ((((long32At(clone2 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
	}
	else {
		/* begin setHashBitsOf:to: */
		hash2 = (long32At(obj2 + 4)) & (identityHashHalfWordMask());
		flag("endianness");
		assert(((hash2 >= 0) && (hash2 <= (identityHashHalfWordMask()))));
		long32Atput(clone1 + 4, ((((long32At(clone1 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash2);
		/* begin setHashBitsOf:to: */
		hash3 = (long32At(obj1 + 4)) & (identityHashHalfWordMask());
		flag("endianness");
		assert(((hash3 >= 0) && (hash3 <= (identityHashHalfWordMask()))));
		long32Atput(clone2 + 4, ((((long32At(clone2 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash3);
	}
	/* begin forward:to: */
	classIndex = isForwardedObjectClassIndexPun();
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((7 >= 0) && (7 <= (formatMask()))));
	longAtput(obj1, ((longAt(obj1)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex + (7LL << (formatShift()))));
	
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(obj1, (longAt(obj1)) & (~(1LL << 23)));

#  endif /* IMMUTABILITY */

	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(obj1));
	assert(!(isOopForwarded(clone2)));
	if (isOldObject(obj1)) {

		/* most stores into young objects */
		if (((clone2 & (tagMask())) == 0)
		 && (oopisLessThan(clone2, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(obj1))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(obj1);
			}
		}
	}
	longAtput((obj1 + BaseHeaderSize) + (0LL << (shiftForWord())), clone2);
	if ((byteAt(obj1 + 7)) == 0) {
		byteAtput(obj1 + 7, 1);
	}
	/* begin forward:to: */
	classIndex1 = isForwardedObjectClassIndexPun();
	assert(((classIndex1 >= 0) && (classIndex1 <= (classIndexMask()))));
	assert(((7 >= 0) && (7 <= (formatMask()))));
	longAtput(obj2, ((longAt(obj2)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex1 + (7LL << (formatShift()))));
	
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(obj2, (longAt(obj2)) & (~(1LL << 23)));

#  endif /* IMMUTABILITY */

	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(obj2));
	assert(!(isOopForwarded(clone1)));
	if (isOldObject(obj2)) {

		/* most stores into young objects */
		if (((clone1 & (tagMask())) == 0)
		 && (oopisLessThan(clone1, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(obj2))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(obj2);
			}
		}
	}
	longAtput((obj2 + BaseHeaderSize) + (0LL << (shiftForWord())), clone1);
	if ((byteAt(obj2 + 7)) == 0) {
		byteAtput(obj2 + 7, 1);
	}
	if (((isYoungObject(obj1)) != (isYoungObject(clone2)))
	 || ((isYoungObject(obj2)) != (isYoungObject(clone1)))) {
		GIV(becomeEffectsFlags) = GIV(becomeEffectsFlags) | OldBecameNewFlag;
	}
}


/*	Attempt to pin objOop, which must not be immediate.
	If the attempt succeeds answer objOop's (possibly moved) oop.
	If the attept fails, which can only occur if there is no memory, answer 0. */

	/* SpurMemoryManager>>#pinObject: */
sqInt
pinObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt i;
    sqInt oldClone;
    sqInt referent;
    SpurSegmentInfo *seg;

	assert(isNonImmediate(objOop));
	flag("policy decision here. if already old, do we clone in a segment containing pinned objects or merely pin?");
	if (isOldObject(objOop)) {
		/* begin segmentContainingObj: */
		for (i = (GIV(numSegments) - 1); i >= 0; i += -1) {
			if (objOop >= (((GIV(segments)[i]).segStart))) {
				seg = (&(GIV(segments)[i]));
				goto l1;
			}
		}
		seg = null;
	l1:	/* end segmentContainingObj: */;
		if ((seg->containsPinned)) {
			/* begin setIsPinnedOf:to: */
			longAtput(objOop, (longAt(objOop)) | (1LL << 30));
			return objOop;
		}
		if (!(someSegmentContainsPinned())) {
			/* begin setIsPinnedOf:to: */
			longAtput(objOop, (longAt(objOop)) | (1LL << 30));
			(seg->containsPinned = 1);
			return objOop;
		}
	}
	oldClone = cloneInOldSpaceForPinning(objOop);
	if (oldClone != 0) {
		GIV(becomeEffectsFlags) = becomeEffectFlagsFor(objOop);
		/* begin setIsPinnedOf:to: */
		longAtput(oldClone, (longAt(oldClone)) | (1LL << 30));
		/* begin forward:to: */
		classIndex = isForwardedObjectClassIndexPun();
		assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
		assert(((7 >= 0) && (7 <= (formatMask()))));
		longAtput(objOop, ((longAt(objOop)) & (~((((long)(formatMask())) << (formatShift())) + (classIndexMask())))) + (classIndex + (7LL << (formatShift()))));
		
#    if IMMUTABILITY
		/* begin setIsImmutableOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(1LL << 23)));

#    endif /* IMMUTABILITY */

		/* begin storePointer:ofForwarder:withValue: */
		assert(isForwarded(objOop));
		assert(!(isOopForwarded(oldClone)));
		if (isOldObject(objOop)) {

			/* most stores into young objects */
			if (((oldClone & (tagMask())) == 0)
			 && (oopisLessThan(oldClone, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(objOop);
				}
			}
		}
		longAtput((objOop + BaseHeaderSize) + (0LL << (shiftForWord())), oldClone);
		if ((byteAt(objOop + 7)) == 0) {
			byteAtput(objOop + 7, 1);
		}
		/* begin followSpecialObjectsOop */
		if (((longAt(GIV(specialObjectsOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(specialObjectsOop)));
			referent = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent & (tagMask())) == 0)
			 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			GIV(specialObjectsOop) = referent;
		}
		followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0);
		/* begin postBecomeAction: */
		spurPostBecomeAction(GIV(becomeEffectsFlags));

		postBecomeScanClassTable(GIV(becomeEffectsFlags));
		GIV(becomeEffectsFlags) = 0;
	}
	return oldClone;
}

	/* SpurMemoryManager>>#popObjStack: */
static sqInt NoDbgRegParms
popObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt myx;
    sqInt nextPage;
    sqInt top;
    sqInt topx;

	eassert(isValidObjStack(objStack));
	topx = longAt((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	topx -= 1;
	top = longAt((objStack + BaseHeaderSize) + (((long)(topx + ObjStackFixedSlots)) << (shiftForWord())));
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(objStack)) == (wordIndexableFormat()));
	longAtput((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())), topx);
	if ((topx == 0)
	 && (((nextPage = longAt((objStack + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord()))))) != 0)) {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		longAtput((nextPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())), objStack);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())), 0);
		myx = longAt((objStack + BaseHeaderSize) + (((long)ObjStackMyx) << (shiftForWord())));
		/* begin updateRootOfObjStackAt:with: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (isOldObject(GIV(hiddenRootsObj))) {

			/* most stores into young objects */
			if (((nextPage & (tagMask())) == 0)
			 && (oopisLessThan(nextPage, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)myx) << (shiftForWord())), nextPage);
		
		switch (myx) {
		case MarkStackRootIndex:
			GIV(markStack) = nextPage;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = nextPage;
			break;
		case MournQueueRootIndex:
			GIV(mournQueue) = nextPage;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		eassert(isValidObjStack(nextPage));
	}
	else {
		eassert(isValidObjStack(objStack));
	}
	return top;
}


/*	Pop and return the possibly remapped object from the remap buffer.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#popRemappableOop */
sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	Scan the class table post-become (iff an active class object was becommed)
	to ensure no
	forwarding pointers, and no unhashed classes exist in the class table.
	
	Note that one-way become can cause duplications in the class table.
	When can these be eliminated? We use the classTableBitmap to mark
	classTable entries
	(not the classes themselves, since marking a class doesn't help in knowing
	if its index is used).
	On image load, and during incrememtal scan-mark and full GC, classIndices
	are marked.
	We can somehow avoid following classes from the classTable until after
	this mark phase. */

	/* SpurMemoryManager>>#postBecomeScanClassTable: */
static void NoDbgRegParms
postBecomeScanClassTable(sqInt effectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt i;
    sqInt j;
    sqInt jLimiT;
    sqInt page;
    sqInt referent;

	assert(validClassTableRootPages());
	if (!(effectsFlags & BecamePointerObjectFlag)) {
		return;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		assert(!(isForwarded(page)));
		for (j = 0, jLimiT = ((numSlotsOf(page)) - 1); j <= jLimiT; j += 1) {
			classOrNil = longAt((page + BaseHeaderSize) + (((long)j) << (shiftForWord())));
			if (classOrNil != GIV(nilObj)) {
				if (((longAt(classOrNil)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(classOrNil));
					referent = longAt((classOrNil + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					classOrNil = referent;
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(page)));
					if (isOldObject(page)) {

						/* most stores into young objects */
						if (((classOrNil & (tagMask())) == 0)
						 && (oopisLessThan(classOrNil, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(page))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(page);
							}
						}
					}
					longAtput((page + BaseHeaderSize) + (((long)j) << (shiftForWord())), classOrNil);
				}
				if (((long32At(classOrNil + 4)) & (identityHashHalfWordMask())) == 0) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(page)));
					longAtput((page + BaseHeaderSize) + (((long)j) << (shiftForWord())), GIV(nilObj));
					if (((((long)i) << (classTableMajorIndexShift())) + j) < GIV(classTableIndex)) {
						GIV(classTableIndex) = (((long)i) << (classTableMajorIndexShift())) + j;
					}
				}
			}
		}
	}
	assert(GIV(classTableIndex) >= (1LL << (classTableMajorIndexShift())));
}

	/* SpurMemoryManager>>#primitiveErrorTable */
sqInt
primitiveErrorTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
}

	/* SpurMemoryManager>>#printForwarders */
void
printForwarders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
			printHex(objOop1);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop2 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop2, limit)) {
		if (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
			printHex(objOop2);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop2;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop2 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop2 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress2 = (objOop2 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			objOop2 = limit;
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop2 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop2 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop2, GIV(freeStart))) {
		if (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
			printHex(objOop2);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop2;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop2 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop2 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress1 = (objOop2 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop2 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop2 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}


/*	This version goes through memory, printing all free chunks.
	Other versions go through the free lists. This one will show
	all free chunks even if the free lists are corrupt. */

	/* SpurMemoryManager>>#printFreeChunks */
void
printFreeChunks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt seenNewFreeChunk;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	seenNewFreeChunk = 0;
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit)) {
		if (((longAt(objOop)) & (classIndexMask())) == 0) {
			if (!seenNewFreeChunk) {
				print("NewSpace CONTAINS FREE OBJECT(S)!!");
				/* begin cr */
				printf("\n");
				seenNewFreeChunk = 1;
			}
			/* begin printFreeChunk: */
			printFreeChunkprintAsTreeNode(objOop, 1);
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (((longAt(objOop)) & (classIndexMask())) == 0) {
			if (!seenNewFreeChunk) {
				print("NewSpace CONTAINS FREE OBJECT(S)!!");
				/* begin cr */
				printf("\n");
				seenNewFreeChunk = 1;
			}
			/* begin printFreeChunk: */
			printFreeChunkprintAsTreeNode(objOop, 1);
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == 0) {
			/* begin printFreeChunk: */
			printFreeChunkprintAsTreeNode(objOop1, 1);
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printFreeChunk: */
void
printFreeChunk(sqInt freeChunk)
{
	printFreeChunkprintAsTreeNode(freeChunk, 1);
}

	/* SpurMemoryManager>>#printFreeChunk:printAsTreeNode: */
static void NoDbgRegParms
printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode)
{
    usqInt numBytes;
    void *p;
    void *p1;
    void *p2;
    void *p3;

	numBytes = bytesInObject(freeChunk);
	print("freeChunk ");
	/* begin printHexPtrnp: */
	printf("0x%lx", ((unsigned long) (oopForPointer(((void *) freeChunk)))));
	print(" bytes ");
	printNum(numBytes);
	print(" next ");
	/* begin printHexPtrnp: */
	p3 = ((void *) (longAt((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())))));
	/* begin printHexnp: */
	printf("0x%lx", ((unsigned long) (oopForPointer(p3))));
	if ((numBytes >= (64 * 8))
	 && (printAsTreeNode)) {
		print(" ^ ");
		/* begin printHexPtrnp: */
		p = ((void *) (longAt((freeChunk + BaseHeaderSize) + (2LL << (shiftForWord())))));
		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) (oopForPointer(p))));
		print(" < ");
		/* begin printHexPtrnp: */
		p1 = ((void *) (longAt((freeChunk + BaseHeaderSize) + (3LL << (shiftForWord())))));
		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) (oopForPointer(p1))));
		print(" > ");
		/* begin printHexPtrnp: */
		p2 = ((void *) (longAt((freeChunk + BaseHeaderSize) + (4LL << (shiftForWord())))));
		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) (oopForPointer(p2))));
	}
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printFreeListHeads */
void
printFreeListHeads(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt expectedMask;
    sqInt i;
    sqInt iLimiT;

	expectedMask = 0;
	for (i = 0, iLimiT = (64 - 1); i <= iLimiT; i += 1) {
		printHex(GIV(freeLists)[i]);
		if ((GIV(freeLists)[i]) != 0) {
			expectedMask += 1LL << i;
		}
		if (((i + 1) % (((usqInt) 32) >> 3)) == 0) {
			/* begin cr */
			printf("\n");
		}
		else {
			print("  ");
		}
	}
	/* begin cr */
	printf("\n");
	print("mask: ");
	/* begin printHexnp: */
	printf("0x%lx", ((unsigned long) GIV(freeListsMask)));
	print(" expected: ");
	/* begin printHexnp: */
	printf("0x%lx", ((unsigned long) expectedMask));
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printFreeList: */
void
printFreeList(sqInt chunkOrIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeChunk;

	if ((chunkOrIndex >= 0)
	 && (chunkOrIndex < 64)) {
		printFreeList(GIV(freeLists)[chunkOrIndex]);
		return;
	}
	freeChunk = chunkOrIndex;
	while (freeChunk != 0) {
		/* begin printFreeChunk: */
		printFreeChunkprintAsTreeNode(freeChunk, 1);
		freeChunk = longAt((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())));
	}
}

	/* SpurMemoryManager>>#printFreeTree */
void
printFreeTree(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFreeTreeChunk(GIV(freeLists)[0]);
}


/*	Slang is blind-sided by the inlining of printFreeTreeChunk: into
	printFreeTree. 
 */

	/* SpurMemoryManager>>#printFreeTreeChunk: */
static void NoDbgRegParms
printFreeTreeChunk(sqInt chunkOrZero)
{
	if (chunkOrZero > 0) {
		printFreeTreeChunk(longAt((chunkOrZero + BaseHeaderSize) + (3LL << (shiftForWord()))));
		/* begin printFreeChunk: */
		printFreeChunkprintAsTreeNode(chunkOrZero, 1);
		printFreeTreeChunk(longAt((chunkOrZero + BaseHeaderSize) + (4LL << (shiftForWord()))));
	}
}


/*	N.B. No safety bounds checks!! We need to look e.g. at corpses. */

	/* SpurMemoryManager>>#printHeaderOf: */
void
printHeaderOf(sqInt objOop)
{
    sqInt aByte;
    sqInt aByte1;
    sqInt aByte2;
    sqInt aByte3;
    sqInt aByte4;
    sqInt n;
    sqInt n1;
    sqInt n2;
    sqInt n3;
    sqInt n4;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin printHexnp: */
	printf("0x%lx", ((unsigned long) objOop));
	if ((numSlotsOfAny(objOop)) >= (numSlotsMask())) {
		print(" hdr16 slotf ");
		/* begin printHexnp: */
		numSlots = byteAt((objOop - 8) + 7);
		n = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt((objOop - 8) - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);
		printf("0x%lx", ((unsigned long) n));
		print(" slotc ");
		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) (((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8)));
		/* begin space */
		putchar(' ');
	}
	else {
		print(" hdr8 slots ");
		/* begin printHexnp: */
		numSlots1 = byteAt(objOop + 7);
		n1 = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		printf("0x%lx", ((unsigned long) n1));
	}
	/* begin space */
	putchar(' ');
	/* begin printChar: */
	aByte = (((((usqInt) (longAt(objOop))) >> 55) & 1) != 0
		? 'M'
		: 'm');
	putchar(aByte);
	/* begin printChar: */
	aByte1 = (((((usqInt) (longAt(objOop))) >> 0x1F) & 1) != 0
		? 'G'
		: 'g');
	putchar(aByte1);
	/* begin printChar: */
	aByte2 = (((((usqInt) (longAt(objOop))) >> 30) & 1) != 0
		? 'P'
		: 'p');
	putchar(aByte2);
	/* begin printChar: */
	aByte3 = (((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0
		? 'R'
		: 'r');
	putchar(aByte3);
	/* begin printChar: */
	aByte4 = (((((usqInt) (longAt(objOop))) >> 23) & 1) != 0
		? 'I'
		: 'i');
	putchar(aByte4);
	print(" hash ");
	/* begin printHexnp: */
	n2 = (long32At(objOop + 4)) & (identityHashHalfWordMask());
	printf("0x%lx", ((unsigned long) n2));
	print(" fmt ");
	/* begin printHexnp: */
	n3 = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	printf("0x%lx", ((unsigned long) n3));
	print(" cidx ");
	/* begin printHexnp: */
	n4 = (longAt(objOop)) & (classIndexMask());
	printf("0x%lx", ((unsigned long) n4));
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printHeaderTypeOf: */
static void NoDbgRegParms
printHeaderTypeOf(sqInt objOop)
{
    sqInt aByte;
    sqInt aByte1;
    sqInt aByte2;
    sqInt aByte3;
    sqInt aByte4;

	print(((numSlotsOfAny(objOop)) >= (numSlotsMask())
		? " hdr16 "
		: " hdr8 "));
	/* begin printChar: */
	aByte = (((((usqInt) (longAt(objOop))) >> 23) & 1) != 0
		? 'i'
		: '.');
	putchar(aByte);
	/* begin printChar: */
	aByte1 = (((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0
		? 'r'
		: '.');
	putchar(aByte1);
	/* begin printChar: */
	aByte2 = (((((usqInt) (longAt(objOop))) >> 30) & 1) != 0
		? 'p'
		: '.');
	putchar(aByte2);
	/* begin printChar: */
	aByte3 = (((((usqInt) (longAt(objOop))) >> 55) & 1) != 0
		? 'm'
		: '.');
	putchar(aByte3);
	/* begin printChar: */
	aByte4 = (((((usqInt) (longAt(objOop))) >> 0x1F) & 1) != 0
		? 'g'
		: '.');
	putchar(aByte4);
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

	/* SpurMemoryManager>>#printInstancesOf: */
void
printInstancesOf(sqInt aClassOop)
{
    sqInt classIndex;

	classIndex = (long32At(aClassOop + 4)) & (identityHashHalfWordMask());
	if (classIndex != 0) {
		printInstancesWithClassIndex(classIndex);
	}
}


/*	Scan the heap printing the oops of any and all objects whose classIndex
	equals the argument.
 */

	/* SpurMemoryManager>>#printInstancesWithClassIndex: */
void
printInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((longAt(objOop)) & (classIndexMask())) == classIndex) {
			printHex(objOop);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			printHex(objOop1);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			objOop1 = limit;
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			printHex(objOop1);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}


/*	Print the objects in the classTable that have bad hashes. */

	/* SpurMemoryManager>>#printInvalidClassTableEntries */
void
printInvalidClassTableEntries(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt classOrNil1;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt j;
    sqInt jLimiT;
    sqInt page;

	if (!(validClassTableRootPages())) {
		print("class table invalid; cannot print");
		/* begin cr */
		printf("\n");
		return;
	}
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		for (j = 0, jLimiT = ((1LL << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
			classOrNil1 = longAt((page + BaseHeaderSize) + (((long)j) << (shiftForWord())));
			if (classOrNil1 != GIV(nilObj)) {
				index = (((long)i) << (classTableMajorIndexShift())) + j;
				if ((((longAt(classOrNil1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
				 || ((((hash = (long32At(classOrNil1 + 4)) & (identityHashHalfWordMask()))) == 0)
				 || ((noCheckClassAtIndex(hash)) != classOrNil1))) {
					print("entry ");
					printHex(index);
					print(" oop ");
					printHex(classOrNil1);
					print(" hash ");
					printHex(hash);
					print(" => ");
					printHex(classAtIndex(hash));
					/* begin cr */
					printf("\n");
				}

			}
		}
	}
}


/*	Scan the heap printing the oops of any and all methods that refer to anOop */

	/* SpurMemoryManager>>#printMethodReferencesTo: */
void
printMethodReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt i;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
			i = ((literalCountOfMethodHeader(methodHeaderOf(objOop1))) + LiteralStart) - 1;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
					printHex(objOop1);
					print(" @ ");
					printNum(i);
					/* begin space */
					putchar(' ');
					printOopShort(objOop1);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
			i = ((literalCountOfMethodHeader(methodHeaderOf(objOop1))) + LiteralStart) - 1;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
					printHex(objOop1);
					print(" @ ");
					printNum(i);
					/* begin space */
					putchar(' ');
					printOopShort(objOop1);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
				i = ((literalCountOfMethodHeader(methodHeaderOf(objOop11))) + LiteralStart) - 1;
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((objOop11 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
						printHex(objOop11);
						print(" @ ");
						printNum(i);
						/* begin space */
						putchar(' ');
						printOopShort(objOop11);
						/* begin cr */
						printf("\n");
						i = 0;
					}
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printObjectsFrom:to: */
void
printObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, endAddress)) {
		if (!((((longAt(oop)) & (classIndexMask())) == 0)
			 || (((longAt(oop)) & (classIndexMask())) == 3))) {
			printOop(oop);
		}
		oop = objectAfter(oop);
	}
}


/*	Scan the heap printing the oops of any and all objects whose hash equals
	the argument.
 */

	/* SpurMemoryManager>>#printObjectsWithHash: */
void
printObjectsWithHash(sqInt hash)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((long32At(objOop + 4)) & (identityHashHalfWordMask())) == hash) {
			shortPrintOop(objOop);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		if (((long32At(objOop1 + 4)) & (identityHashHalfWordMask())) == hash) {
			shortPrintOop(objOop1);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			objOop1 = limit;
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((long32At(objOop1 + 4)) & (identityHashHalfWordMask())) == hash) {
			shortPrintOop(objOop1);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:pageType: */
static void NoDbgRegParms
printObjStackPagemyIndexpageType(sqInt objStackPage, sqInt myx, sqInt pageType)
{
    sqInt freeOrNextPage;
    sqInt isFirstPage;
    sqInt isFreePage;
    sqInt isNextPage;
    sqInt page;

	isFirstPage = pageType == ObjStackMyx;
	isNextPage = pageType == ObjStackNextx;
	isFreePage = pageType == ObjStackFreex;
	printObjStackPagemyIndextag(objStackPage, myx, (isFirstPage
		? "head"
		: (isFreePage
				? "free"
				: "next")));
	if (isFirstPage
	 || (isNextPage)) {
		/* begin tab */
		putchar('	');
		print("topx: ");
		printNum(longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord()))));
		print(" next: ");
		printHex(longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord()))));
		if (isFirstPage) {
			print(" free: ");
			printHex(longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord()))));
		}
		/* begin cr */
		printf("\n");
	}
	if (isFirstPage) {
		freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())));
		while (freeOrNextPage != 0) {
			printObjStackPagemyIndexpageType(freeOrNextPage, myx, ObjStackFreex);
			page = longAt((freeOrNextPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())));
			if ((page == freeOrNextPage)
			 || (page == objStackPage)) {
				print("circularity in free page list!!");
				/* begin cr */
				printf("\n");
				page = 0;
			}
			freeOrNextPage = page;
		}
	}
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
	if (freeOrNextPage != 0) {
		printObjStackPagemyIndexpageType(freeOrNextPage, myx, ObjStackNextx);
	}
}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:tag: */
static void NoDbgRegParms
printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType)
{
	print(pageType);
	/* begin space */
	putchar(' ');
	printHex(objStackPage);
	/* begin space */
	putchar(' ');
	print("cx ");
	printNum((longAt(objStackPage)) & (classIndexMask()));
	print(" (");
	printNum(19);
	print(") fmt ");
	printNum((((usqInt) (longAt(objStackPage))) >> (formatShift())) & (formatMask()));
	print(" (");
	printNum(sixtyFourBitIndexableFormat());
	print(") sz ");
	printNum(numSlotsOfAny(objStackPage));
	print(" (");
	printNum(ObjStackPageSlots);
	print(") myx: ");
	printNum(longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackMyx) << (shiftForWord()))));
	print(" (");
	printNum(myx);
	print((((((usqInt) (longAt(objStackPage))) >> 55) & 1) != 0
		? ") mkd"
		: ") unmkd"));
	/* begin cr */
	printf("\n");
}

	/* SpurMemoryManager>>#printObjStack: */
void
printObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (objStack == GIV(nilObj)) {
		print("nil");
		/* begin cr */
		printf("\n");
	}
	else {
		printObjStackPagemyIndexpageType(objStack, longAt((objStack + BaseHeaderSize) + (((long)ObjStackMyx) << (shiftForWord()))), ObjStackMyx);
	}
}

	/* SpurMemoryManager>>#printOopsFrom:to: */
void
printOopsFromto(sqInt startAddress, sqInt endAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt limit;
    sqInt oop;

	oop = objectBefore(startAddress);
	limit = (((((unsigned long)endAddress)) < GIV(endOfMemory)) ? (((unsigned long)endAddress)) : GIV(endOfMemory));
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, limit)) {
		printHex(oop);
		print("/");
		printNum(oop);
		/* begin space */
		putchar(' ');
		print((((longAt(oop)) & (classIndexMask())) == 0
			? "free"
			: (((longAt(oop)) & (classIndexMask())) == 3
					? "bridge"
					: (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0
							? "forwarder"
							: "object"))));
		/* begin cr */
		printf("\n");
		oop = objectAfter(oop);
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

	/* SpurMemoryManager>>#printReferencesTo: */
void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt contextSize;
    sqInt fmt;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt header;
    sqInt i;
    usqInt limit;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    usqInt numSlots5;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;
    sqInt sp;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots4 = byteAt(address + 7);
	objOop1 = (numSlots4 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		/* begin numPointerSlotsOf: */
		fmt = (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask());
		if (fmt <= 5) {
			if ((fmt == (indexablePointersFormat()))
			 && (((longAt(objOop1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop1 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l6;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop1)));
				contextSize = (sp >> 3);
			l6:	/* end fetchStackPointerOf: */;
				i = CtxtTempFrameStart + contextSize;
				goto l7;
			}
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
			numSlots = byteAt(objOop1 + 7);
			i = (numSlots == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots);
			goto l7;
		}
		if (fmt == 7) {
			i = 1;
			goto l7;
		}
		if (fmt < (firstCompiledMethodFormat())) {
			i = 0;
			goto l7;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(objOop1));
		header = longAt((objOop1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
		/* begin literalCountOfMethodHeader: */
		assert((((header) & 7) == 1));
		numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
		i = numLiterals + LiteralStart;
	l7:	/* end numPointerSlotsOf: */;
		while (((i -= 1)) >= 0) {
			if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
				printHex(objOop1);
				print(" @ ");
				printNum(i);
				/* begin space */
				putchar(' ');
				printOopShort(objOop1);
				/* begin cr */
				printf("\n");
				i = 0;
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		/* begin numPointerSlotsOf: */
		fmt = (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask());
		if (fmt <= 5) {
			if ((fmt == (indexablePointersFormat()))
			 && (((longAt(objOop1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop1 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l8;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop1)));
				contextSize = (sp >> 3);
			l8:	/* end fetchStackPointerOf: */;
				i = CtxtTempFrameStart + contextSize;
				goto l9;
			}
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
			numSlots = byteAt(objOop1 + 7);
			i = (numSlots == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots);
			goto l9;
		}
		if (fmt == 7) {
			i = 1;
			goto l9;
		}
		if (fmt < (firstCompiledMethodFormat())) {
			i = 0;
			goto l9;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(objOop1));
		header = longAt((objOop1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
		/* begin literalCountOfMethodHeader: */
		assert((((header) & 7) == 1));
		numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
		i = numLiterals + LiteralStart;
	l9:	/* end numPointerSlotsOf: */;
		while (((i -= 1)) >= 0) {
			if (anOop == (longAt((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
				printHex(objOop1);
				print(" @ ");
				printNum(i);
				/* begin space */
				putchar(' ');
				printOopShort(objOop1);
				/* begin cr */
				printf("\n");
				i = 0;
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l4;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l4:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			/* begin numPointerSlotsOf: */
			fmt = (((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask());
			if (fmt <= 5) {
				if ((fmt == (indexablePointersFormat()))
				 && (((longAt(objOop11)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp = longAt((objOop11 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
					if (!((((sp) & 7) == 1))) {
						contextSize = 0;
						goto l10;
					}
					assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop11)));
					contextSize = (sp >> 3);
				l10:	/* end fetchStackPointerOf: */;
					i = CtxtTempFrameStart + contextSize;
					goto l11;
				}
				/* begin numSlotsOf: */
				flag("endianness");
				assert((classIndexOf(objOop11)) > (isForwardedObjectClassIndexPun()));
				numSlots = byteAt(objOop11 + 7);
				i = (numSlots == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
					: numSlots);
				goto l11;
			}
			if (fmt == 7) {
				i = 1;
				goto l11;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				i = 0;
				goto l11;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objOop11));
			header = longAt((objOop11 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
			/* begin literalCountOfMethodHeader: */
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			i = numLiterals + LiteralStart;
		l11:	/* end numPointerSlotsOf: */;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop11 + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
					printHex(objOop11);
					print(" @ ");
					printNum(i);
					/* begin space */
					putchar(' ');
					printOopShort(objOop11);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots5 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots5 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots5) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l5:	/* end objectAfter:limit: */;
	}
	}

	/* SpurMemoryManager>>#printSortedFreeList */
void
printSortedFreeList(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt freeChunk;
    usqInt nextFree;
    usqInt prevFree;

	if (!((GIV(firstFreeChunk) > 0)
		 && (GIV(lastFreeChunk) > GIV(firstFreeChunk)))) {
		print("sorted free list empty or corrupt");
		/* begin cr */
		printf("\n");
		return;
	}
	freeChunk = GIV(firstFreeChunk);
	prevFree = 0;
	while (1) {
		if (!((addressCouldBeObj(freeChunk))
			 && (((longAt(freeChunk)) & (classIndexMask())) == 0))) {
			/* begin printHexnp: */
			printf("0x%lx", ((unsigned long) freeChunk));
			print(" is not a free chunk!");
			/* begin cr */
			printf("\n");
			return;
		}
		printFreeChunkprintAsTreeNode(freeChunk, 0);
		if (!(freeChunk != GIV(lastFreeChunk))) break;
		nextFree = ((usqInt)((longAt((freeChunk + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ prevFree));
		prevFree = freeChunk;
		freeChunk = nextFree;
	}
}


/*	Attempt to push anEphemeron on the unscanned ephemerons stack
	and answer if the attempt succeeded. Note that the ephemeron
	stack overflowing isn't a disaster; it simply means treating the
	ephemeron as strong in this GC cycle. */

	/* SpurMemoryManager>>#pushOnUnscannedEphemeronsStack: */
static sqInt NoDbgRegParms
pushOnUnscannedEphemeronsStack(sqInt anEphemeron)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isEphemeron(anEphemeron));
	if (((GIV(unscannedEphemerons).top)) >= ((GIV(unscannedEphemerons).limit))) {
		return 0;
	}
	longAtput((GIV(unscannedEphemerons).top), anEphemeron);
	(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) + BytesPerWord);
	return 1;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that
	objects in temporary variables are properly remapped.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#pushRemappableOop: */
void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
}

	/* SpurMemoryManager>>#push:onObjStack: */
static sqInt NoDbgRegParms
pushonObjStack(sqInt objOop, sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(objOop));
	if ((objOop & (tagMask())) != 0) {
		assert(objStack == GIV(markStack));
		assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
			? fetchPointerofObject(ObjStackNextx, objStack)
			: objStack))));
	}
	else {

		/* There should be no weaklings on the mark stack. */
		assert(!((objStack == GIV(markStack))
 && (isWeakNonImm(objOop))));
		assert((objStack != GIV(weaklingStack))
		 || (isWeakNonImm(objOop)));
	}
	return noCheckPushonObjStack(objOop, objStack);
}


/*	Add the ephemeron to the queue and make it non-ephemeral, to avoid
	subsequent firing.
	Alas this means that other ephemerons on the same object not identified in
	this sccavenge
	or GC will not fire until later. But that's life. */

	/* SpurMemoryManager>>#queueMourner: */
static void NoDbgRegParms
queueMourner(sqInt anEphemeronOrWeakArray)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((isNonImmediate(anEphemeronOrWeakArray))
	 && (((formatOf(anEphemeronOrWeakArray)) == (ephemeronFormat()))
	 || ((formatOf(anEphemeronOrWeakArray)) == (weakArrayFormat()))));
	assert(!((isonObjStack(anEphemeronOrWeakArray, GIV(mournQueue)))));
	ensureRoomOnObjStackAt(MournQueueRootIndex);
	pushonObjStack(anEphemeronOrWeakArray, GIV(mournQueue));
	if (((((usqInt) (longAt(anEphemeronOrWeakArray))) >> (formatShift())) & (formatMask())) == 5) {
		/* begin setFormatOf:to: */
		assert(((1 >= 0) && (1 <= (formatMask()))));
		longAtput(anEphemeronOrWeakArray, ((longAt(anEphemeronOrWeakArray)) & (~(((long)(formatMask())) << (formatShift())))) + (1LL << (formatShift())));
	}
}

	/* SpurMemoryManager>>#rawHashBitsOf: */
static sqInt NoDbgRegParms
rawHashBitsOf(sqInt objOop)
{
	flag("endianness");
	return (long32At(objOop + 4)) & (identityHashHalfWordMask());
}


/*	Rebuild the free lists from the doubly-linked free list. */

	/* SpurMemoryManager>>#rebuildFreeListsForPigCompact */
static void
rebuildFreeListsForPigCompact(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytes;
    usqInt free;
    sqInt freeObj;
    usqInt nextFree;
    usqInt prevFree;
    usqInt prevPrevFree;
    sqInt start;

	assert(checkTraversableSortedFreeList());
	GIV(totalFreeOldSpace) = 0;
	/* begin sortedFreeListDo: */
	free = GIV(firstFreeChunk);
	prevPrevFree = (prevFree = 0);
	while (free != 0) {
		nextFree = ((usqInt)((longAt((free + BaseHeaderSize) + (0LL << (shiftForWord())))) ^ prevFree));
		assert(isFreeObject(free));
		assert((nextFree == 0)
		 || ((nextFree > free)
		 && (isFreeObject(nextFree))));
		assert((prevFree == 0)
		 || (prevFree < free));
		bytes = bytesInObject(free);
		start = ((byteAt(free + 7)) == (numSlotsMask())
			? free - BaseHeaderSize
			: free);
		/* begin addFreeChunkWithBytes:at: */
		freeChunkWithBytesat(bytes, start);
		GIV(totalFreeOldSpace) += bytes;

		prevPrevFree = prevFree;
		prevFree = free;
		free = nextFree;
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
}


/*	Scavenge or simply follow objOop. Answer the new location of objOop.
	The send should have been guarded by a send of shouldRemapOop:.
	The method is called remapObj: for compatibility with ObjectMemory. */

	/* SpurMemoryManager>>#remapObj: */
sqInt
remapObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt resolvedObj;

	assert(shouldRemapOop(objOop));
	if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(objOop));
		referent = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		resolvedObj = referent;
	}
	else {
		assert(!((isInFutureSpace(objOop))));
		resolvedObj = objOop;
	}
	if (GIV(scavengeInProgress)
	 && ((((resolvedObj & (tagMask())) == 0)
	 && (isYoungObject(resolvedObj)))
	 && (!(oopisGreaterThanOrEqualToandLessThan(resolvedObj, ((futureSpace()).start), futureSurvivorStart()))))) {
		return copyAndForward(resolvedObj);
	}
	return resolvedObj;
}


/*	Remove the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#removeGCRoot: */
sqInt
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		if (varLoc == (GIV(extraRoots)[i])) {

			/* swap varLoc with last entry */
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Enumerate the objects in objArray, unmarking them and restoring their
	hashes from the corresponding 32-bit slots in savedHashes. The first
	unused entry in
	objArray will have a non-hash value entry in savedHashes. Free
	savedHashes.  */

	/* SpurMemoryManager>>#restoreObjectsIn:savedHashes: */
static void NoDbgRegParms
restoreObjectsInsavedHashes(sqInt objArray, sqInt savedHashes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt i;
    sqInt iLimiT;
    sqInt oop;

	for (i = 0, iLimiT = ((numSlotsOf(objArray)) - 1); i <= iLimiT; i += 1) {
		if (((hash = long32At((savedHashes + BaseHeaderSize) + (((long)i) << 2)))) > (identityHashHalfWordMask())) {
			if (oopisGreaterThanOrEqualToandLessThan(savedHashes, GIV(oldSpaceStart), GIV(endOfMemory))) {
				freeObject(savedHashes);
			}
			return;
		}
		oop = longAt((objArray + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		/* begin setHashBitsOf:to: */
		flag("endianness");
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		long32Atput(oop + 4, ((((long32At(oop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(oop)));
		longAtput(oop, (longAt(oop)) & (~(1LL << 55)));
	}
	if (oopisGreaterThanOrEqualToandLessThan(savedHashes, GIV(oldSpaceStart), GIV(endOfMemory))) {
		freeObject(savedHashes);
	}
}

	/* SpurMemoryManager>>#runLeakCheckerForFreeSpace: */
static void NoDbgRegParms
runLeakCheckerForFreeSpace(sqInt gcModes)
{
	if (gcModes & GCModeFreeSpace) {
		reverseDisplayFromto(16, 19);
		clearLeakMapAndMapAccessibleFreeSpace();
		assert(checkHeapFreeSpaceIntegrity());
	}
}

	/* SpurMemoryManager>>#runLeakCheckerFor: */
static void NoDbgRegParms
runLeakCheckerFor(sqInt gcModes)
{
	/* begin inLineRunLeakCheckerFor:excludeUnmarkedNewSpaceObjs:classIndicesShouldBeValid: */
	if (gcModes & checkForLeaks) {
		if (gcModes & GCModeFull) {
			reverseDisplayFromto(0, 7);
		}
		else {
			reverseDisplayFromto(8, 15);
		}
		clearLeakMapAndMapAccessibleObjects();
		assert(checkHeapIntegrityclassIndicesShouldBeValid(0, 1));
		assert(checkInterpreterIntegrity());
		assert(checkStackIntegrity());
		assert(checkCodeIntegrity(gcModes));
	}
	return;
}

	/* SpurMemoryManager>>#runLeakCheckerFor:excludeUnmarkedNewSpaceObjs:classIndicesShouldBeValid: */
static void NoDbgRegParms
runLeakCheckerForexcludeUnmarkedNewSpaceObjsclassIndicesShouldBeValid(sqInt gcModes, sqInt excludeUnmarkedNewSpaceObjs, sqInt classIndicesShouldBeValid)
{
	/* begin inLineRunLeakCheckerFor:excludeUnmarkedNewSpaceObjs:classIndicesShouldBeValid: */
	if (gcModes & checkForLeaks) {
		if (gcModes & GCModeFull) {
			reverseDisplayFromto(0, 7);
		}
		else {
			reverseDisplayFromto(8, 15);
		}
		clearLeakMapAndMapAccessibleObjects();
		assert(checkHeapIntegrityclassIndicesShouldBeValid(excludeUnmarkedNewSpaceObjs, classIndicesShouldBeValid));
		assert(checkInterpreterIntegrity());
		assert(checkStackIntegrity());
		assert(checkCodeIntegrity(gcModes));
	}
}


/*	Run the scavenger. */

	/* SpurMemoryManager>>#scavengingGCTenuringIf: */
static void NoDbgRegParms
scavengingGCTenuringIf(sqInt tenuringCriterion)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt probe;

	assert(GIV(remapBufferCount) == 0);
	if (!(asserta(((((eden()).limit)) - GIV(freeStart)) > (interpreterAllocationReserveBytes())))) {
		/* begin tab */
		putchar('	');
		printNum((((eden()).limit)) - GIV(freeStart));
		/* begin space */
		putchar(' ');
		printNum(interpreterAllocationReserveBytes());
		/* begin space */
		putchar(' ');
		printNum((interpreterAllocationReserveBytes()) - ((((eden()).limit)) - GIV(freeStart)));
		/* begin cr */
		printf("\n");
	}
	/* begin checkMemoryMap */
	assert(isYoungObject(GIV(newSpaceStart)));
	assert(isYoungObject(GIV(newSpaceLimit) - BytesPerWord));
	assert(!(isOldObject(GIV(newSpaceStart))));
	assert(!(isOldObject(GIV(newSpaceLimit) - BytesPerWord)));
	assert(!(isYoungObject(GIV(newSpaceLimit))));
	assert(!(isYoungObject(GIV(oldSpaceStart))));
	assert(!(isYoungObject(GIV(endOfMemory))));
	assert(isOldObject(GIV(newSpaceLimit)));
	assert(isOldObject(GIV(oldSpaceStart)));
	assert(isOldObject(GIV(endOfMemory)));
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	runLeakCheckerFor(GCModeNewSpace);
	/* begin preGCAction: */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	/* begin flushMethodCacheFrom:to: */
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if (!((GIV(methodCache)[probe + MethodCacheSelector]) == 0)) {
			if ((((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheSelector], GIV(newSpaceStart)))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheSelector], GIV(newSpaceLimit))))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheClass], GIV(newSpaceStart)))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheClass], GIV(newSpaceLimit)))))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheMethod], GIV(newSpaceStart)))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheMethod], GIV(newSpaceLimit))))) {
				GIV(methodCache)[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}
	for (i = 1; i <= NSMethodCacheSize; i += 1) {
		GIV(nsMethodCache)[i] = 0;
	}

	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	doScavenge(tenuringCriterion);
	GIV(statScavenges) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statSGCDeltaUsecs) = GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statScavengeGCUsecs) += GIV(statSGCDeltaUsecs);
	GIV(statRootTableCount) = rememberedSetSize();
	/* begin postGCAction: */
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	runLeakCheckerFor(GCModeNewSpace);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeNewSpace)) == (GCModeFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
}


/*	Reduce the number of indexable fields in objOop, a pointer object, to
	nSlots. Convert the
	unused residual to a free chunk. Without changes to
	numSlotsForShortening:toIndexableSize: this only works for arrayFormat and
	longFormat objects.
	Answer the number of bytes returned to free memory, which may be zero if
	no change
	was possible. */

	/* SpurMemoryManager>>#shorten:toIndexableSize: */
static sqInt NoDbgRegParms
shortentoIndexableSize(sqInt objOop, sqInt indexableSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesBefore;
    usqInt delta;
    sqInt format;
    sqInt freeChunk;
    sqInt numSlots;

	
	switch ((((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask())) {
	case 2:
		numSlots = indexableSize;

		break;
	case firstLongFormat():
	case (firstLongFormat()) + 1:
		numSlots = ((indexableSize * 4) + (BytesPerWord - 1)) / BytesPerWord;

		break;
	default:
		error("Case not found and no otherwise clause");
		numSlots = -1;
	}
	if (numSlots == (numSlotsOf(objOop))) {
		return 0;
	}
	bytesBefore = bytesInObject(objOop);
	if ((byteAt(objOop + 7)) == (numSlotsMask())) {
		/* begin rawOverflowSlotsOf:put: */
		flag("endianness");
		longAtput(objOop - BaseHeaderSize, (((long)(numSlotsMask())) << 56) + numSlots);
	}
	else {
		assert(numSlots < (numSlotsMask()));
		byteAtput(objOop + 7, numSlots);
	}

	/* We have options.
	   1. we can clone the object and forward to the clone.
	   2. if the following object has a short header we can given it a large header. */
	delta = bytesBefore - (bytesInObject(objOop));
	flag("deal with it, dude");
	if (delta <= 8) {
		error("shorten:toIndexableSize: attempted to shorten to allocationUnit!");
	}
	freeChunk = initFreeChunkWithBytesat(delta, addressAfter(objOop));
	if (oopisGreaterThanOrEqualToandLessThan(objOop, GIV(oldSpaceStart), GIV(endOfMemory))) {
		GIV(totalFreeOldSpace) += delta;
		addToFreeListbytes(freeChunk, delta);
	}
	else {
		/* begin setClassIndexOf:to: */
		assert(((19 >= 0) && (19 <= (classIndexMask()))));
		longAtput(freeChunk, ((longAt(freeChunk)) & (~(classIndexMask()))) + 19);
		/* begin setFormatOf:to: */
		format = firstLongFormat();
		assert(((format >= 0) && (format <= (formatMask()))));
		longAtput(freeChunk, ((longAt(freeChunk)) & (~(((long)(formatMask())) << (formatShift())))) + (((long)format) << (formatShift())));
	}
	return delta;
}

	/* SpurMemoryManager>>#shortPrintObjectsFrom:to: */
void
shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, endAddress)) {
		if (!(((longAt(oop)) & (classIndexMask())) == 0)) {
			shortPrintOop(oop);
		}
		oop = objectAfter(oop);
	}
}


/*	Answer if the obj should be scavenged (or simply followed). The method is
	called shouldRemapObj: for compatibility with ObjectMemory. We test for
	being already
	scavenged because mapStackPages via mapInterpreterOops may be applied
	twice in the context of a global GC where a scavenge, followed by a
	scan-mark-free, and
	final compaction passes may result in scvenged fields being visited twice. */

	/* SpurMemoryManager>>#shouldRemapObj: */
sqInt
shouldRemapObj(sqInt objOop)
{
	return (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(objOop))
	 && (!(oopisGreaterThanOrEqualToandLessThan(objOop, ((futureSpace()).start), futureSurvivorStart()))));
}


/*	Answer if the oop should be scavenged.. The method is called
	shouldRemapOop: for compatibility with ObjectMemory. */

	/* SpurMemoryManager>>#shouldRemapOop: */
sqInt
shouldRemapOop(sqInt oop)
{
	return ((oop & (tagMask())) == 0)
	 && ((((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(oop))
	 && (!(oopisGreaterThanOrEqualToandLessThan(oop, ((futureSpace()).start), futureSurvivorStart())))));
}


/*	For compatibility with ObjectMemory, answer the size of a free chunk in
	bytes. Do *not* use internally. */

	/* SpurMemoryManager>>#sizeOfFree: */
static usqInt NoDbgRegParms
sizeOfFree(sqInt objOop)
{
	assert(isFreeObject(objOop));
	return bytesInObject(objOop);
}

	/* SpurMemoryManager>>#sizeOfObjStack: */
static sqInt NoDbgRegParms
sizeOfObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objStackPage;
    sqInt total;

	if (objStack == GIV(nilObj)) {
		return 0;
	}
	total = longAt((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
	objStackPage = objStack;
	while (1) {
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((long)ObjStackNextx) << (shiftForWord())));
		if (!(objStackPage != 0)) break;
		total += ObjStackLimit;
		assert((fetchPointerofObject(ObjStackTopx, objStackPage)) == ObjStackLimit);
	}
	return total;
}


/*	*DO NOT CONFUSE THIS WITH numSlotsOf:.
	This is an ObjectMemory compatibility method with questionable semantics.
	Answers the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	Otherwise return the number of words. */

	/* SpurMemoryManager>>#slotSizeOf: */
sqInt
slotSizeOf(sqInt oop)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	if ((oop & (tagMask())) != 0) {
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (((long)numSlots) << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}


/*	Return one of the objects in the specialObjectsArray */

	/* SpurMemoryManager>>#splObj: */
sqInt
splObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)index) << (shiftForWord())));
}


/*	Answer the start of objOop, which is either the address of the overflow
	size word, or objOop itself, depending on the size of the object. This may
	be applied to any kind of object, normal, forwarders or free chunks. */

	/* SpurMemoryManager>>#startOfObject: */
static sqInt NoDbgRegParms
startOfObject(sqInt objOop)
{
	return ((byteAt(objOop + 7)) == (numSlotsMask())
		? objOop - BaseHeaderSize
		: objOop);
}


/*	A renaming for the Cogit, which couldn't make sense of GIV(newSpaceLimit) */

	/* SpurMemoryManager>>#storeCheckBoundary */
usqInt
storeCheckBoundary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newSpaceLimit);
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
	This primitive will store a binary image segment (in the same format as
	objercts in the heap) of the
	set of objects in arrayOfObjects. All pointers from within the set to
	objects outside the set will be
	copied into the array of outPointers. In their place in the image segment
	will be an oop equal to the
	offset in the outPointer array (the first would be 4). but with the high
	bit set.
	
	Since Spur has a class table the load primitive must insert classes that
	have instances in the class
	table. This primitive marks such classes using the isRemembered bit, which
	isn't meaningful as a
	remembered bit in the segment.
	
	The primitive expects the segmentWordArray and outPointerArray to be more
	than adequately long.
	In this case it returns normally, and truncates the two arrays to exactly
	the right size.
	
	The primitive can fail for the following reasons with the specified
	failure codes:
	PrimErrWritePastObject:	the segmentWordArray is too small
	PrimErrBadIndex:			the outPointerArray is too small
	PrimErrNoMemory:			additional allocations failed
	PrimErrLimitExceeded:		there is no room in the hash field to store object
	oops.  */

	/* SpurMemoryManager>>#storeImageSegmentInto:outPointers:roots: */
static sqInt NoDbgRegParms
storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt arrayOfObjects;
    sqInt count;
    sqInt endSeg;
    sqInt fillValue;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt formatField;
    sqInt formatField1;
    sqInt freeChunk;
    sqInt hash;
    sqInt here;
    sqInt hereLimiT;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt iLimiT2;
    sqInt limit;
    usqInt limit1;
    usqInt newObj;
    usqInt newObj1;
    sqInt newSegAddrOrError;
    usqInt numBytes;
    usqInt numBytes1;
    sqInt numBytes2;
    sqInt numBytes3;
    sqInt numSlots;
    sqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots111;
    usqInt numSlots12;
    usqInt numSlots121;
    usqInt numSlots13;
    usqInt numSlots14;
    usqInt numSlots2;
    usqInt numSlots21;
    usqInt numSlots3;
    usqInt numSlots31;
    sqInt numSlots4;
    usqInt numSlots41;
    sqInt numSlots5;
    usqInt numSlots6;
    usqInt numSlots7;
    usqInt numSlots8;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop2;
    sqInt objOop3;
    sqInt oop;
    sqInt oop1;
    sqInt outIndex;
    usqInt p;
    usqInt p1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt ptr;
    sqInt savedInHashes;
    sqInt savedOutHashes;
    sqInt segAddr;
    sqInt segStart;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes11;
    sqInt slotBytes2;
    sqInt slotBytes3;
    sqInt start;
    sqInt tempObjOop;
    sqInt there;
    sqInt valueWord;

	runLeakCheckerFor(GCModeImageSegment);
	/* begin objectsReachableFromRoots: */
	assert(isArray(arrayOfRoots));
	assert(allObjectsUnmarked());
	/* begin markObjectsIn: */
	assert(!(isFreeObject(arrayOfRoots)));
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) | (1LL << 55));
	for (i1 = 0, iLimiT1 = ((numSlotsOf(arrayOfRoots)) - 1); i1 <= iLimiT1; i1 += 1) {
		/* begin followField:ofObject: */
		objOop11 = longAt((arrayOfRoots + BaseHeaderSize) + (((long)i1) << (shiftForWord())));
		if (((objOop11 & (tagMask())) == 0)
		 && (((longAt(objOop11)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop11 = fixFollowedFieldofObjectwithInitialValue(i1, arrayOfRoots, objOop11);
		}
		oop1 = objOop11;
		if ((oop1 & (tagMask())) == 0) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop1)));
			longAtput(oop1, (longAt(oop1)) | (1LL << 55));
		}
	}
	markObjects(0);
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	assert(noUnscannedEphemerons());
	freeChunk = allocateLargestFreeChunk();
	ptr = (start = freeChunk + BaseHeaderSize);
	/* begin addressAfter: */
	numSlots12 = byteAt(freeChunk + 7);
	numSlots7 = (numSlots12 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(freeChunk - BaseHeaderSize))) << 8)))) >> 8
		: numSlots12);
	if (numSlots7 == 0) {
		slotBytes1 = 8;
	}
	else {
		slotBytes1 = ((long)numSlots7) << (shiftForWord());
	}
	limit = (freeChunk + BaseHeaderSize) + slotBytes1;

	/* First put the arrayOfRoots; order is important. */
	count = 0;
	count += 1;
	if (ptr < limit) {
		longAtput(ptr, arrayOfRoots);
		ptr += BytesPerOop;
	}
	for (i2 = 0, iLimiT2 = ((numSlotsOf(arrayOfRoots)) - 1); i2 <= iLimiT2; i2 += 1) {
		oop = longAt((arrayOfRoots + BaseHeaderSize) + (((long)i2) << (shiftForWord())));
		if ((oop & (tagMask())) == 0) {
			pushonObjStack(oop, GIV(markStack));
		}
	}
	while (!(isEmptyObjStack(GIV(markStack)))) {
		objOop2 = popObjStack(GIV(markStack));
		count += 1;
		if (ptr < limit) {
			longAtput(ptr, objOop2);
			ptr += BytesPerOop;
		}
		oop = fetchClassOfNonImm(objOop2);
		if (!(((((usqInt) (longAt(oop))) >> 55) & 1) != 0)) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(objOop2)));
			longAtput(objOop2, (longAt(objOop2)) | (1LL << 55));
			pushonObjStack(oop, GIV(markStack));
		}
		if ((((longAt(objOop2)) & (classIndexMask())) == ClassMethodContextCompactIndex)
		 && ((((((longAt((objOop2 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(objOop2))))) {

			/* widow now, before the loop */
			for (i2 = 0, iLimiT2 = ((numSlotsOfMarriedContext(objOop2)) - 1); i2 <= iLimiT2; i2 += 1) {
				oop = fetchPointerofMarriedContext(i2, objOop2);
				if (!(((oop & (tagMask())) != 0)
					 || (((((usqInt) (longAt(oop))) >> 55) & 1) != 0))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop2)));
					longAtput(objOop2, (longAt(objOop2)) | (1LL << 55));
					pushonObjStack(oop, GIV(markStack));
				}
			}
		}
		else {
			for (i2 = 0, iLimiT2 = ((numPointerSlotsOf(objOop2)) - 1); i2 <= iLimiT2; i2 += 1) {
				oop = longAt((objOop2 + BaseHeaderSize) + (((long)i2) << (shiftForWord())));
				if (!(((oop & (tagMask())) != 0)
					 || (((((usqInt) (longAt(oop))) >> 55) & 1) != 0))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop2)));
					longAtput(objOop2, (longAt(objOop2)) | (1LL << 55));
					pushonObjStack(oop, GIV(markStack));
				}
			}
		}
	}
	/* begin unmarkAllObjects */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop3 = GIV(nilObj);
	while (1) {
		assert((objOop3 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop3, GIV(endOfMemory)))) break;
		assert((long64At(objOop3)) != 0);
		if (((((usqInt) (longAt(objOop3))) >> 55) & 1) != 0) {
			if (((longAt(objOop3)) & (classIndexMask())) > 0x1F) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop3)));
				longAtput(objOop3, (longAt(objOop3)) & (~(1LL << 55)));
			}
			else {
				if (!(((longAt(objOop3)) & (classIndexMask())) == 3)) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop3)));
					longAtput(objOop3, (longAt(objOop3)) & (~(1LL << 55)));
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop3;
		/* begin objectAfter:limit: */
		numSlots111 = byteAt(objOop3 + 7);
		numSlots21 = (numSlots111 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop3 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots111);
		if (numSlots21 == 0) {
			slotBytes3 = 8;
		}
		else {
			slotBytes3 = ((long)numSlots21) << (shiftForWord());
		}
		followingWordAddress = (objOop3 + BaseHeaderSize) + slotBytes3;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop3 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop3 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots8 = byteAt(address + 7);
	objOop12 = (numSlots8 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit1 = GIV(pastSpaceStart);
	while (oopisLessThan(objOop12, limit1)) {
		if (((((usqInt) (longAt(objOop12))) >> 55) & 1) != 0) {
			if (((longAt(objOop12)) & (classIndexMask())) > 0x1F) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop12)));
				longAtput(objOop12, (longAt(objOop12)) & (~(1LL << 55)));
			}
			else {
				if (!(((longAt(objOop12)) & (classIndexMask())) == 3)) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop12)));
					longAtput(objOop12, (longAt(objOop12)) & (~(1LL << 55)));
				}
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop12;
		/* begin objectAfter:limit: */
		numSlots121 = byteAt(objOop12 + 7);
		numSlots31 = (numSlots121 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop12 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots121);
		if (numSlots31 == 0) {
			slotBytes11 = 8;
		}
		else {
			slotBytes11 = ((long)numSlots31) << (shiftForWord());
		}
		followingWordAddress2 = (objOop12 + BaseHeaderSize) + slotBytes11;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit1)) {
			objOop12 = limit1;
			goto l6;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop12 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots14 = byteAt(address1 + 7);
	objOop12 = (numSlots14 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop12, GIV(freeStart))) {
		if (((((usqInt) (longAt(objOop12))) >> 55) & 1) != 0) {
			if (((longAt(objOop12)) & (classIndexMask())) > 0x1F) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop12)));
				longAtput(objOop12, (longAt(objOop12)) & (~(1LL << 55)));
			}
			else {
				if (!(((longAt(objOop12)) & (classIndexMask())) == 3)) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop12)));
					longAtput(objOop12, (longAt(objOop12)) & (~(1LL << 55)));
				}
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop12;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop12 + 7);
		numSlots41 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop12 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots41 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots41) << (shiftForWord());
		}
		followingWordAddress1 = (objOop12 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop12 = GIV(freeStart);
			goto l4;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop12 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l4:	/* end objectAfter:limit: */;
	}
	
	/* Now try and allocate the result */
	GIV(totalFreeOldSpace) -= bytesInObject(freeChunk);
	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8))) {

		/* can't split a single word */
		freeChunkWithBytesat(bytesInObject(freeChunk), ((byteAt(freeChunk + 7)) == (numSlotsMask())
			? freeChunk - BaseHeaderSize
			: freeChunk));
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCModeFreeSpace | GCModeImageSegment)) == (GCModeFreeSpace | GCModeImageSegment))) {
			runLeakCheckerForFreeSpace(GCModeFreeSpace);
		}
		arrayOfObjects = ((count << 3) | 1);
		goto l3;
	}
	/* begin setFormatOf:to: */
	assert(((2 >= 0) && (2 <= (formatMask()))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(((long)(formatMask())) << (formatShift())))) + (2LL << (formatShift())));
	/* begin setClassIndexOf:to: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask()))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(classIndexMask()))) + ClassArrayCompactIndex);
	shortentoIndexableSize(freeChunk, count);
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt) (longAt(freeChunk))) >> (rememberedBitShift())) & 1) != 0)) {
		remember(freeChunk);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeImageSegment)) == (GCModeFreeSpace | GCModeImageSegment))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	runLeakCheckerFor(GCModeImageSegment);
	arrayOfObjects = freeChunk;
l3:	/* end objectsReachableFromRoots: */;
	if (!(arrayOfObjects)) {
		return PrimErrNoMemory;
	}
	assert(allObjectsUnmarked());
	/* begin allocateSlots:format:classIndex: */
	numBytes2 = (numSlotsOf(arrayOfObjects)) * 4;
	numSlots4 = (numBytes2 + (BytesPerWord - 1)) / BytesPerWord;
	formatField = firstLongFormat();
	if (numSlots4 >= (numSlotsMask())) {
		if ((((usqInt) numSlots4) >> 56) > 0) {
			savedInHashes = null;
			goto l1;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots4 * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots4 < 1
	? 8
	: numSlots4 * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		savedInHashes = allocateSlotsInOldSpacebytesformatclassIndex(numSlots4, numBytes, formatField, 18);
		goto l1;
	}
	if (numSlots4 >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots4);
		longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), formatField, 18));
	}
	else {
		longAtput(newObj, ((((long)(((usqLong) numSlots4))) << (numSlotsFullShift())) + (((long)formatField) << (formatShift()))) + 18);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	savedInHashes = newObj;
l1:	/* end allocateSlots:format:classIndex: */;
	/* begin allocateSlots:format:classIndex: */
	numBytes3 = (numSlotsOf(outPointerArray)) * 4;
	numSlots5 = (numBytes3 + (BytesPerWord - 1)) / BytesPerWord;
	formatField1 = firstLongFormat();
	if (numSlots5 >= (numSlotsMask())) {
		if ((((usqInt) numSlots5) >> 56) > 0) {
			savedOutHashes = null;
			goto l2;
		}
		newObj1 = GIV(freeStart) + BaseHeaderSize;
		numBytes1 = (BaseHeaderSize + BaseHeaderSize) + (numSlots5 * BytesPerOop);
	}
	else {
		newObj1 = GIV(freeStart);
		numBytes1 = BaseHeaderSize + ((numSlots5 < 1
	? 8
	: numSlots5 * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		savedOutHashes = allocateSlotsInOldSpacebytesformatclassIndex(numSlots5, numBytes1, formatField1, 18);
		goto l2;
	}
	if (numSlots5 >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots5);
		longAtput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), formatField1, 18));
	}
	else {
		longAtput(newObj1, ((((long)(((usqLong) numSlots5))) << (numSlotsFullShift())) + (((long)formatField1) << (formatShift()))) + 18);
	}
	assert((numBytes1 % (allocationUnit())) == 0);
	assert((newObj1 % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes1;
	savedOutHashes = newObj1;
l2:	/* end allocateSlots:format:classIndex: */;
	if ((savedInHashes == null)
	 || (savedOutHashes == null)) {
		freeObject(arrayOfObjects);
		return PrimErrNoMemory;
	}
	fillValue = (((long)((identityHashHalfWordMask()) + 1)) << 32) + ((identityHashHalfWordMask()) + 1);
	/* begin fillObj:numSlots:with: */
	flag("endianness");
	assert((classIndexOf(savedInHashes)) > (isForwardedObjectClassIndexPun()));
	numSlots2 = byteAt(savedInHashes + 7);
	numSlots = (numSlots2 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(savedInHashes - BaseHeaderSize))) << 8)))) >> 8
		: numSlots2);
	assert(oopisLessThan(((savedInHashes + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(savedInHashes)));
	for (p = (((usqInt)(savedInHashes + BaseHeaderSize))); p <= (((usqInt)(((savedInHashes + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8) {
		longAtput(p, fillValue);
	}
	/* begin fillObj:numSlots:with: */
	flag("endianness");
	assert((classIndexOf(savedOutHashes)) > (isForwardedObjectClassIndexPun()));
	numSlots3 = byteAt(savedOutHashes + 7);
	numSlots1 = (numSlots3 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(savedOutHashes - BaseHeaderSize))) << 8)))) >> 8
		: numSlots3);
	assert(oopisLessThan(((savedOutHashes + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1, addressAfter(savedOutHashes)));
	for (p1 = (((usqInt)(savedOutHashes + BaseHeaderSize))); p1 <= (((usqInt)(((savedOutHashes + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1))); p1 += 8) {
		longAtput(p1, fillValue);
	}
	/* begin moveClassesForwardsIn: */

	/* if > 0, this is the index of the first non-class past the first element. */
	there = 0;
	for (here = 1, hereLimiT = ((numSlotsOf(arrayOfObjects)) - 1); here <= hereLimiT; here += 1) {
		objOop1 = longAt((arrayOfObjects + BaseHeaderSize) + (((long)here) << (shiftForWord())));
		hash = (long32At(objOop1 + 4)) & (identityHashHalfWordMask());
		if ((hash > 0x1F)
		 && ((classOrNilAtIndex(hash)) == objOop1)) {
			if (there > 0) {

				/* if there is zero we're in a run of classes at the start so don't move */
				tempObjOop = longAt((arrayOfObjects + BaseHeaderSize) + (((long)there) << (shiftForWord())));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(arrayOfObjects)));
				longAtput((arrayOfObjects + BaseHeaderSize) + (((long)there) << (shiftForWord())), objOop1);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(arrayOfObjects)));
				longAtput((arrayOfObjects + BaseHeaderSize) + (((long)here) << (shiftForWord())), tempObjOop);
				there += 1;
			}
		}
		else {
			if (there == 0) {
				there = here;
			}
		}
	}
	segAddr = segmentWordArray + BaseHeaderSize;
	/* begin addressAfter: */
	numSlots11 = byteAt(segmentWordArray + 7);
	numSlots6 = (numSlots11 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(segmentWordArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots11);
	if (numSlots6 == 0) {
		slotBytes = 8;
	}
	else {
		slotBytes = ((long)numSlots6) << (shiftForWord());
	}
	endSeg = (segmentWordArray + BaseHeaderSize) + slotBytes;
	if (segAddr >= endSeg) {
		return PrimErrGenericFailure;
	}
	long32Atput(segAddr, imageSegmentVersion());
	long32Atput(segAddr + 4, imageSegmentVersion());

	/* Copy all reachable objects to the segment. */
	segStart = (segAddr += 8);
	for (i = 0, iLimiT = ((numSlotsOf(arrayOfObjects)) - 1); i <= iLimiT; i += 1) {
		objOop = longAt((arrayOfObjects + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		assert(!(((isImmediate(objOop))
 || (isForwarded(objOop)))));
		/* begin storeLong32:ofObject:withValue: */
		valueWord = (long32At(objOop + 4)) & (identityHashHalfWordMask());
		long32Atput((savedInHashes + BaseHeaderSize) + (((long)i) << 2), valueWord);
		newSegAddrOrError = copyObjtoAddrstartAtstopAt(objOop, segAddr, segStart, endSeg);
		if (newSegAddrOrError < segStart) {
			/* begin return:restoringObjectsIn:savedHashes:and:savedHashes: */
			restoreObjectsInsavedHashes(arrayOfObjects, savedInHashes);
			restoreObjectsInsavedHashes(outPointerArray, savedOutHashes);
			runLeakCheckerFor(GCModeImageSegment);
			assert(allObjectsUnmarked());
			return newSegAddrOrError;
		}
		segAddr = newSegAddrOrError;
	}
	if ((endSeg != segAddr)
	 && ((endSeg - segAddr) < (BaseHeaderSize + BytesPerOop))) {
		/* begin return:restoringObjectsIn:savedHashes:and:savedHashes: */
		restoreObjectsInsavedHashes(arrayOfObjects, savedInHashes);
		restoreObjectsInsavedHashes(outPointerArray, savedOutHashes);
		runLeakCheckerFor(GCModeImageSegment);
		assert(allObjectsUnmarked());
		return PrimErrWritePastObject;
	}
	if (((outIndex = mapOopsFromtooutPointersoutHashes(segStart, segAddr, outPointerArray, savedOutHashes))) < 0) {

		/* no room in outPointers; fail */
		/* begin return:restoringObjectsIn:savedHashes:and:savedHashes: */
		restoreObjectsInsavedHashes(arrayOfObjects, savedInHashes);
		restoreObjectsInsavedHashes(outPointerArray, savedOutHashes);
		runLeakCheckerFor(GCModeImageSegment);
		assert(allObjectsUnmarked());
		return PrimErrBadIndex;
	}
	shortentoIndexableSize(segmentWordArray, (segAddr - (segmentWordArray + BaseHeaderSize)) / 4);
	shortentoIndexableSize(outPointerArray, outIndex);
	/* begin return:restoringObjectsIn:savedHashes:and:savedHashes: */
	restoreObjectsInsavedHashes(arrayOfObjects, savedInHashes);
	restoreObjectsInsavedHashes(outPointerArray, savedOutHashes);
	runLeakCheckerFor(GCModeImageSegment);
	assert(allObjectsUnmarked());
	return PrimNoErr;
}

	/* SpurMemoryManager>>#storePointerUnchecked:ofObject:withValue: */
sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(!(isForwarded(objOop)));
	return longAtput((objOop + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */

	/* SpurMemoryManager>>#storePointer:ofObject:withValue: */
sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!(isForwarded(objOop)));
	if (isOldObject(objOop)) {

		/* most stores into young objects */
		if (((valuePointer & (tagMask())) == 0)
		 && (oopisLessThan(valuePointer, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop);
			}
		}
	}
	return longAtput((objOop + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())), valuePointer);
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory. */

	/* SpurMemoryManager>>#stringForCString: */
sqInt
stringForCString(const char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt formatField;
    sqInt len;
    usqInt newObj;
    sqInt newString;
    usqInt numBytes;
    sqInt numSlots;

	len = strlen(aCString);
	/* begin allocateSlots:format:classIndex: */
	numSlots = (len + (BytesPerWord - 1)) / BytesPerWord;
	formatField = (firstByteFormat()) + ((8 - len) & (BytesPerWord - 1));
	if (numSlots >= (numSlotsMask())) {
		if ((((usqInt) numSlots) >> 56) > 0) {
			newString = null;
			goto l1;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		newString = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, ClassByteStringCompactIndex);
		goto l1;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((long)(numSlotsMask())) << (numSlotsFullShift())) + numSlots);
		longAtput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), formatField, ClassByteStringCompactIndex));
	}
	else {
		longAtput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)formatField) << (formatShift()))) + ClassByteStringCompactIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	newString = newObj;
l1:	/* end allocateSlots:format:classIndex: */;
	if (!(newString == null)) {
		strncpy(((char *) (newString + BaseHeaderSize)), aCString, len);
	}
	return newString;
}


/*	This is ObjectMemory's funky entry-point into its incremental GC,
	which is a stop-the-world a young generation reclaimer. In Spur
	we run the scavenger. Answer if space is not low. */

	/* SpurMemoryManager>>#sufficientSpaceAfterGC: */
static sqInt NoDbgRegParms
sufficientSpaceAfterGC(sqInt numBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt heapSizePostGC;

	assert(numBytes == 0);
	scavengingGCTenuringIf(TenureByAge);
	heapSizePostGC = (GIV(endOfMemory) - GIV(nilObj)) - GIV(totalFreeOldSpace);
	if (((((double) (heapSizePostGC - GIV(heapSizeAtPreviousGC)) )) / GIV(heapSizeAtPreviousGC)) >= GIV(heapGrowthToSizeGCRatio)) {
		fullGC();
	}
	while ((GIV(totalFreeOldSpace) < GIV(growHeadroom))
	 && ((growOldSpaceByAtLeast(0)) != null)) {
		if (GIV(totalFreeOldSpace) >= GIV(growHeadroom)) {
			return 1;
		}
	}
	if (GIV(lowSpaceThreshold) > GIV(totalFreeOldSpace)) {

		/* space is low */

		/* avoid signalling low space twice */
		GIV(lowSpaceThreshold) = 0;
		return 0;
	}
	return 1;
}


/*	On load, swizzle the pointers in an obj stack. Answer the obj stack's oop. */

	/* SpurMemoryManager>>#swizzleObjStackAt: */
static sqInt NoDbgRegParms
swizzleObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt firstPage;
    sqInt index;
    sqInt page;
    sqInt stackOrNil;

	firstPage = (stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)objStackRootIndex) << (shiftForWord()))));
	if (stackOrNil == GIV(nilObj)) {
		return stackOrNil;
	}
	do {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		assert((fetchPointerofObject(ObjStackMyx, stackOrNil)) == objStackRootIndex);

		/* swizzle fields including ObjStackNextx, excluding ObjStackFreex and leave field containing the next link. */
		index = (longAt((stackOrNil + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())))) + ObjStackNextx;
		do {
			field = longAt((stackOrNil + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			if (!((field == 0)
				 || ((field & (tagMask())) != 0))) {
				field = swizzleObj(field);
				/* begin storePointer:ofObjStack:withValue: */
				assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
				longAtput((stackOrNil + BaseHeaderSize) + (((long)index) << (shiftForWord())), field);
			}
		} while(((index -= 1)) >= ObjStackNextx);
	} while(((stackOrNil = field)) != 0);
	if (((stackOrNil = longAt((firstPage + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord()))))) != 0) {
		page = firstPage;
		do {
			stackOrNil = swizzleObj(stackOrNil);
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(page)) == (wordIndexableFormat()));
			longAtput((page + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord())), stackOrNil);
			page = stackOrNil;
		} while(((stackOrNil = longAt((page + BaseHeaderSize) + (((long)ObjStackFreex) << (shiftForWord()))))) != 0);
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)objStackRootIndex) << (shiftForWord())));
}


/*	Do an incremental GC that tenures all surviving young objects to old
	space. 
 */

	/* SpurMemoryManager>>#tenuringIncrementalGC */
void
tenuringIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt savedTenuringThreshold;

	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
}


/*	This assert is tricky. push:onObjStack: may call topOfObjStack: just after
	pushing an
	empty page on the stack, and will ask if the second page is valid. */

	/* SpurMemoryManager>>#topOfObjStack: */
static sqInt NoDbgRegParms
topOfObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt topx;

	eassert(isValidObjStackPagemyIndexfirstPage(objStack, fetchPointerofObject(ObjStackMyx, objStack), objStack == (fetchPointerofObject(fetchPointerofObject(ObjStackMyx, objStack), GIV(hiddenRootsObj)))));
	topx = longAt((objStack + BaseHeaderSize) + (((long)ObjStackTopx) << (shiftForWord())));
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	return longAt((objStack + BaseHeaderSize) + (((long)((topx + ObjStackFixedSlots) - 1)) << (shiftForWord())));
}


/*	Answers the top of the remappable oop stack. Useful when writing loops.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#topRemappableOop */
sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}


/*	This method both computes the actual number of free bytes by traversing
	all free objects
	on the free lists/tree, and checks that the tree is valid. It is used
	mainly by checkFreeSpace. */

	/* SpurMemoryManager>>#totalFreeListBytes */
static usqInt
totalFreeListBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInChunk;
    sqInt cameFrom;
    sqInt i;
    sqInt iLimiT;
    sqInt largeChild;
    sqInt listNode;
    sqInt nextNode;
    sqInt smallChild;
    usqInt totalFreeBytes;
    sqInt treeNode;
    sqInt treeNode1;

	totalFreeBytes = 0;
	for (i = 1, iLimiT = (64 - 1); i <= iLimiT; i += 1) {
		bytesInChunk = i * 8;
		listNode = GIV(freeLists)[i];
		while (listNode != 0) {
			totalFreeBytes += bytesInChunk;
			assert(isValidFreeObject(listNode));
			assert(bytesInChunk == (bytesInObject(listNode)));
			nextNode = longAt((listNode + BaseHeaderSize) + (0LL << (shiftForWord())));
			assert(nextNode != listNode);
			listNode = nextNode;
		}
	}
	/* begin freeTreeNodesDo: */
	treeNode1 = GIV(freeLists)[0];
	if (treeNode1 == 0) {
		goto l1;
	}
	cameFrom = -1;
	do {
		assert((bytesInObject(treeNode1)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = longAt((treeNode1 + BaseHeaderSize) + (3LL << (shiftForWord())));
		largeChild = longAt((treeNode1 + BaseHeaderSize) + (4LL << (shiftForWord())));
		assert((smallChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */
			bytesInChunk = bytesInObject(treeNode1);
			assert((bytesInChunk / (allocationUnit())) >= (numFreeLists()));
			listNode = treeNode1;
			while (listNode != 0) {

				/* self printFreeChunk: listNode */
				assert(isValidFreeObject(listNode));
				assert((listNode == treeNode1)
				 || ((fetchPointerofFreeChunk(freeChunkParentIndex(), listNode)) == 0));
				totalFreeBytes += bytesInChunk;
				assert(bytesInChunk == (bytesInObject(listNode)));
				nextNode = longAt((listNode + BaseHeaderSize) + (0LL << (shiftForWord())));
				assert(nextNode != listNode);
				listNode = nextNode;
			}
			treeNode1 = treeNode1;

			cameFrom = treeNode1;
			treeNode1 = longAt((treeNode1 + BaseHeaderSize) + (2LL << (shiftForWord())));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode1 = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode1 = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode1 != 0);
l1:	/* end freeTreeNodesDo: */;
	return totalFreeBytes;
}

	/* SpurMemoryManager>>#trueObject */
sqInt
trueObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(trueObj);
}


/*	Unlink a freeTreeNode. Assumes the node has no list (null next link). */

	/* SpurMemoryManager>>#unlinkSolitaryFreeTreeNode: */
static void NoDbgRegParms
unlinkSolitaryFreeTreeNode(sqInt freeTreeNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt larger;
    sqInt parent;
    sqInt smaller;

	assert((fetchPointerofFreeChunk(freeChunkNextIndex(), freeTreeNode)) == 0);
	smaller = longAt((freeTreeNode + BaseHeaderSize) + (3LL << (shiftForWord())));
	larger = longAt((freeTreeNode + BaseHeaderSize) + (4LL << (shiftForWord())));
	parent = longAt((freeTreeNode + BaseHeaderSize) + (2LL << (shiftForWord())));
	if (parent == 0) {

		/* no parent; stitch the subnodes back into the root */
		if (smaller == 0) {
			if (larger != 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(larger));
				assert(1);
				longAtput((larger + BaseHeaderSize) + (2LL << (shiftForWord())), 0);
			}
			GIV(freeLists)[0] = larger;
		}
		else {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(smaller));
			assert(1);
			longAtput((smaller + BaseHeaderSize) + (2LL << (shiftForWord())), 0);
			GIV(freeLists)[0] = smaller;
			if (larger != 0) {
				addFreeSubTree(larger);
			}
		}
	}
	else {

		/* parent; stitch back into appropriate side of parent. */
		if (smaller == 0) {
			/* begin storePointer:ofFreeChunk:withValue: */
			fieldIndex = (freeTreeNode == (longAt((parent + BaseHeaderSize) + (3LL << (shiftForWord()))))
				? 3
				: 4);
			assert(isFreeObject(parent));
			assert((larger == 0)
			 || (isFreeObject(larger)));
			longAtput((parent + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())), larger);
			if (larger != 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(larger));
				assert((parent == 0)
				 || (isFreeObject(parent)));
				longAtput((larger + BaseHeaderSize) + (2LL << (shiftForWord())), parent);
			}
		}
		else {
			/* begin storePointer:ofFreeChunk:withValue: */
			fieldIndex1 = (freeTreeNode == (longAt((parent + BaseHeaderSize) + (3LL << (shiftForWord()))))
				? 3
				: 4);
			assert(isFreeObject(parent));
			assert((smaller == 0)
			 || (isFreeObject(smaller)));
			longAtput((parent + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())), smaller);
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(smaller));
			assert((parent == 0)
			 || (isFreeObject(parent)));
			longAtput((smaller + BaseHeaderSize) + (2LL << (shiftForWord())), parent);
			if (larger != 0) {
				addFreeSubTree(larger);
			}
		}
	}
}

	/* SpurMemoryManager>>#unpinObject: */
sqInt
unpinObject(sqInt objOop)
{
	assert(isNonImmediate(objOop));
	/* begin setIsPinnedOf:to: */
	longAtput(objOop, (longAt(objOop)) & (~(1LL << 30)));
	return 0;
}


/*	Check the hashes of classes in the table. The tricky thing here is that
	classes may be duplicated
	in the table. So each entry must be in the table at its hash, even if it
	is elsewhere in the table. */

	/* SpurMemoryManager>>#validClassTableHashes */
static sqInt
validClassTableHashes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt classOrNil1;
    sqInt hash;
    sqInt i;
    sqInt ignored;
    sqInt j;
    sqInt jLimiT;
    sqInt page;

	if (!(validClassTableRootPages())) {
		return 0;
	}
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		for (j = 0, jLimiT = ((1LL << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
			classOrNil1 = longAt((page + BaseHeaderSize) + (((long)j) << (shiftForWord())));
			if (classOrNil1 != GIV(nilObj)) {
				ignored = (((long)i) << (classTableMajorIndexShift())) + j;
				if (((longAt(classOrNil1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					return 0;
				}
				hash = (long32At(classOrNil1 + 4)) & (identityHashHalfWordMask());
				if (hash == 0) {
					return 0;
				}
				if ((noCheckClassAtIndex(hash)) != classOrNil1) {
					return 0;
				}

			}
		}
	}
	return 1;
}


/*	Answer if hiddenRootsObj is of the right size with the
	expected contents, and if numClassTablePages is correct. */

	/* SpurMemoryManager>>#validClassTableRootPages */
static sqInt
validClassTableRootPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt obj;

	if (!((numSlotsOf(GIV(hiddenRootsObj))) == ((1LL << (22 - (classTableMajorIndexShift()))) + 8))) {
		return 0;
	}
	if (!((GIV(numClassTablePages) > 1)
		 && (GIV(numClassTablePages) <= (1LL << (22 - (classTableMajorIndexShift())))))) {
		return 0;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		obj = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if (!((addressCouldBeObj(obj))
			 && ((numSlotsOf(obj)) == (1LL << (classTableMajorIndexShift()))))) {
			return 0;
		}
	}
	for (i = GIV(numClassTablePages), iLimiT = ((1LL << (22 - (classTableMajorIndexShift()))) - 1); i <= iLimiT; i += 1) {
		if ((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)i) << (shiftForWord())))) != GIV(nilObj)) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#validFreeTree */
sqInt
validFreeTree(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (validFreeTreeChunkparent(GIV(freeLists)[0], 0)) == null;
}

	/* SpurMemoryManager>>#validFreeTreeChunk:parent: */
static const char * NoDbgRegParms
validFreeTreeChunkparent(sqInt chunk, sqInt parent)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    const char *reason;

	if (chunk == 0) {
		return null;
	}
	if (!(((chunk & (BaseHeaderSize - 1)) == 0)
		 && (oopisGreaterThanOrEqualToandLessThan(chunk, GIV(oldSpaceStart), GIV(endOfMemory))))) {
		return "not in old space";
	}
	if (((bytesInObject(chunk)) / 8) < 64) {
		return "too small";
	}
	if (parent != (longAt((chunk + BaseHeaderSize) + (2LL << (shiftForWord()))))) {
		return "bad parent";
	}
	reason = validFreeTreeChunkparent(longAt((chunk + BaseHeaderSize) + (3LL << (shiftForWord()))), chunk);
	if (!(reason == null)) {
		return reason;
	}
	reason = validFreeTreeChunkparent(longAt((chunk + BaseHeaderSize) + (4LL << (shiftForWord()))), chunk);
	if (!(reason == null)) {
		return reason;
	}
	return null;
}

	/* SpurMemoryManager>>#validObjStacks */
static sqInt
validObjStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(markStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(markStack))))
	 && (((GIV(weaklingStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(weaklingStack))))
	 && ((GIV(mournQueue) == GIV(nilObj))
	 || (isValidObjStack(GIV(mournQueue)))));
}


/*	1 = big, 0 = little */

	/* SpurMemoryManager>>#vmEndianness */
sqInt
vmEndianness(void)
{
	return VMBIGENDIAN;
}

	/* SpurSegmentInfo>>#segLimit */
static usqInt NoDbgRegParms
segLimit(SpurSegmentInfo * self_in_segLimit)
{
	return ((self_in_segLimit->segSize)) + ((self_in_segLimit->segStart));
}

	/* SpurSegmentManager>>#addSegmentOfSize: */
static SpurSegmentInfo * NoDbgRegParms
addSegmentOfSize(sqInt ammount)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocatedSize;
    sqInt i;
    sqInt idx;
    sqInt lastSegIndex;
    SpurSegmentInfo *newSeg;
    sqInt newSegIndex;
    void *segAddress;
    sqInt segAddress1;
    sqInt segIndex;

	allocatedSize = 0;
	newSegIndex = 0;
	segAddress = sqAllocateMemorySegmentOfSizeAboveAllocatedSizeInto(ammount, firstGapOfSizeAtLeast(ammount), (&allocatedSize));
	if (!(segAddress == null)) {
		/* begin insertSegmentFor: */
		segAddress1 = ((unsigned long)segAddress);
		assert(segAddress1 >= (segLimit(&GIV(segments)[0])));
		if (GIV(numSegments) == GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos();
		}
		assert(GIV(numSegments) < GIV(numSegInfos));
		segIndex = (lastSegIndex = GIV(numSegments) - 1);
		GIV(numSegments) += 1;
		while(1) {
			if (segAddress1 >= ((((GIV(segments)[segIndex]).segSize)) + (((GIV(segments)[segIndex]).segStart)))) {
				segIndex += 1;
				for (idx = lastSegIndex; idx >= segIndex; idx += -1) {
					GIV(segments)[idx + 1] = (GIV(segments)[idx]);
				}
				newSegIndex = segIndex;
				goto l1;
			}
			segIndex -= 1;
		}
	l1:	/* end insertSegmentFor: */;
		newSeg = (&(GIV(segments)[newSegIndex]));
		(newSeg->segStart = ((unsigned long)segAddress));
		(newSeg->segSize = allocatedSize);
		bridgeFromto((&(GIV(segments)[newSegIndex - 1])), newSeg);
		bridgeFromto(newSeg, (!(newSegIndex == (GIV(numSegments) - 1))
			? (&(GIV(segments)[newSegIndex + 1]))
			: 0));
		for (i = 0; i < GIV(numSegments); i += 1) {
			assert(isInSegments(((GIV(segments)[i]).segStart)));
			assert(isInSegments((segLimit(&GIV(segments)[i])) - BytesPerWord));
			assert((!(isInSegments(segLimit(&GIV(segments)[i]))))
			 || ((i < (GIV(numSegments) - 1))
			 && ((segLimit(&GIV(segments)[i])) == (((GIV(segments)[i + 1]).segStart)))));
			assert((!(isInSegments((((GIV(segments)[i]).segStart)) - BytesPerWord)))
			 || ((i > 0)
			 && ((segLimit(&GIV(segments)[i - 1])) == (((GIV(segments)[i]).segStart)))));
		}
		return newSeg;
	}
	return null;
}


/*	Adjust swizzles by firstSegmentShift. Also computes segStarts as
	they were in the image when it was written, so that oops' segments
	can be determined and hence oops correctly swizzled. */

	/* SpurSegmentManager>>#adjustSegmentSwizzlesBy: */
static void NoDbgRegParms
adjustSegmentSwizzlesBy(sqInt firstSegmentShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt oldBaseAddr;
    SpurSegmentInfo *segInfo;

	oldBaseAddr = GIV(oldSpaceStart) - firstSegmentShift;
	for (i = 0; i < GIV(numSegments); i += 1) {
		segInfo = (&(GIV(segments)[i]));
		(segInfo->segStart = ((segInfo->segStart)) + oldBaseAddr);
		(segInfo->swizzle = ((segInfo->swizzle)) - oldBaseAddr);
	}
	GIV(canSwizzle) = 1;
}

	/* SpurSegmentManager>>#allBridgesMarked */
static sqInt
allBridgesMarked(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt bridgeObj;
    sqInt i;
    usqInt numSlots;

	for (i = 0; i < GIV(numSegments); i += 1) {
		/* begin objectStartingAt: */
		address = (((((&(GIV(segments)[i])))->segSize)) + ((((&(GIV(segments)[i])))->segStart))) - (2 * BaseHeaderSize);
		numSlots = byteAt(address + 7);
		bridgeObj = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		assert(isValidSegmentBridge(bridgeObj));
		if (!(((((usqInt) (longAt(bridgeObj))) >> 55) & 1) != 0)) {
			return 0;
		}
	}
	return 1;
}


/*	Increase the number of allocated segInfos by 16. */

	/* SpurSegmentManager>>#allocateOrExtendSegmentInfos */
static void
allocateOrExtendSegmentInfos(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newNumSegs;

	if (GIV(numSegInfos) == 0) {
		GIV(numSegInfos) = 16;
		GIV(segments) = calloc(GIV(numSegInfos), sizeof(SpurSegmentInfo));
		return;
	}
	newNumSegs = GIV(numSegInfos) + 16;
	GIV(segments) = realloc(GIV(segments), newNumSegs * (sizeof(SpurSegmentInfo)));
	if (GIV(segments) == 0) {
		error("out of memory; cannot allocate more segments");
	}
	memset(GIV(segments) + GIV(numSegInfos), 0, (newNumSegs - GIV(numSegInfos)) * (sizeof(SpurSegmentInfo)));
	GIV(numSegInfos) = newNumSegs;
}

	/* SpurSegmentManager>>#bridgeAt: */
static sqInt NoDbgRegParms
bridgeAt(sqInt segIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (((((&(GIV(segments)[segIndex])))->segSize)) + ((((&(GIV(segments)[segIndex])))->segStart))) - (2 * BaseHeaderSize);
	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
}

	/* SpurSegmentManager>>#bridgeFor: */
static sqInt NoDbgRegParms
bridgeFor(SpurSegmentInfo *aSegment)
{
    sqInt address;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (((aSegment->segSize)) + ((aSegment->segStart))) - (2 * BaseHeaderSize);
	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
}


/*	Create a bridge from aSegment to the next segment,
	or create a terminating bridge if there is no next segment. */

	/* SpurSegmentManager>>#bridgeFrom:to: */
static void NoDbgRegParms
bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil)
{
    usqInt bridgeSpan;
    sqInt clifton;
    usqInt segEnd;

	segEnd = ((aSegment->segSize)) + ((aSegment->segStart));

	/* clifton is where the Avon bridge begins... */
	clifton = segEnd - (2 * BaseHeaderSize);
	if (nextSegmentOrNil == null) {
		bridgeSpan = 2 * BaseHeaderSize;
	}
	else {
		bridgeSpan = (((nextSegmentOrNil->segStart)) - segEnd) + (2 * BaseHeaderSize);
	}
	initSegmentBridgeWithBytesat(bridgeSpan, clifton);
	assert((addressAfter(objectStartingAt(clifton))) == ((nextSegmentOrNil == null
		? segLimit(aSegment)
		: (nextSegmentOrNil->segStart))));
}

	/* SpurSegmentManager>>#checkSegments */
static void
checkSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(numSegments) >= 1);
	for (i = 0; i < GIV(numSegments); i += 1) {
		assert(addressCouldBeObj(((GIV(segments)[i]).segStart)));
		assert(isValidSegmentBridge(bridgeAt(i)));
	}
	assert(((segLimit(&GIV(segments)[GIV(numSegments) - 1])) - (bridgeSize())) == (endOfMemory()));
}


/*	The image has been loaded, old segments reconstructed, and the heap
	swizzled into a single contiguous segment. Collapse the segments into one. */

	/* SpurSegmentManager>>#collapseSegmentsPostSwizzle */
static void
collapseSegmentsPostSwizzle(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurSegmentInfo * cascade0;

	GIV(canSwizzle) = 0;
	GIV(numSegments) = 1;
	cascade0 = (&(GIV(segments)[0]));
	(cascade0->segStart = oldSpaceStart());
	(cascade0->segSize = (endOfMemory()) - (oldSpaceStart()));
	assert(isSegmentBridge(bridgeAt(0)));
	assert((numSlotsOfAny(bridgeAt(0))) == 0);
}


/*	Answer the segment limit of the first segment followed by a gap of at
	least size bytes.
 */

	/* SpurSegmentManager>>#firstGapOfSizeAtLeast: */
static void * NoDbgRegParms
firstGapOfSizeAtLeast(sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt bridge;
    sqInt i;
    usqInt numSlots;

	for (i = 0; i <= (GIV(numSegments) - 2); i += 1) {
		/* begin objectStartingAt: */
		address = (((((&(GIV(segments)[i])))->segSize)) + ((((&(GIV(segments)[i])))->segStart))) - (2 * BaseHeaderSize);
		numSlots = byteAt(address + 7);
		bridge = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		if (((bytesInObject(bridge)) - (2 * BaseHeaderSize)) >= size) {
			return ((void *)((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart))));
		}
	}
	return ((void *)((((GIV(segments)[GIV(numSegments) - 1]).segSize)) + (((GIV(segments)[GIV(numSegments) - 1]).segStart))));
}

	/* SpurSegmentManager>>#isEmptySegment: */
static sqInt NoDbgRegParms
isEmptySegment(SpurSegmentInfo *seg)
{
    sqInt address;
    sqInt firstObj;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (seg->segStart);
	numSlots = byteAt(address + 7);
	firstObj = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	return (((longAt(firstObj)) & (classIndexMask())) == 0)
	 && ((addressAfter(firstObj)) == ((((seg->segSize)) + ((seg->segStart))) - (2 * BaseHeaderSize)));
}

	/* SpurSegmentManager>>#isInSegments: */
static sqInt NoDbgRegParms
isInSegments(usqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < ((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart)))) {
			return 1;
		}
	}
	return 0;
}


/*	bridges bridge the gaps between segments. They are the last object in each
	segment. 
 */

	/* SpurSegmentManager>>#isValidSegmentBridge: */
static sqInt NoDbgRegParms
isValidSegmentBridge(sqInt objOop)
{
	return ((addressCouldBeObj(objOop))
	 || (objOop == (endOfMemory())))
	 && ((((longAt(objOop)) & (classIndexMask())) == 3)
	 && (((byteAt(objOop + 7)) == (numSlotsMask()))
	 || ((numSlotsOfAny(objOop)) == 0)));
}

	/* SpurSegmentManager>>#lastBridge */
static sqInt
lastBridge(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (((((&(GIV(segments)[GIV(numSegments) - 1])))->segSize)) + ((((&(GIV(segments)[GIV(numSegments) - 1])))->segStart))) - (2 * BaseHeaderSize);
	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
}


/*	Answer the the next non-empty segment or nil. The size of a segment
	includes that of its bridge. A segment containing just a free object and a
	bridge will still
	have a size of manager bridgeSize after shortening it in
	prepareForSnapshot. 
 */

	/* SpurSegmentManager>>#nextNonEmptySegmentAfter: */
static SpurSegmentInfo * NoDbgRegParms
nextNonEmptySegmentAfter(sqInt i)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nextx;

	nextx = i;
	while(1) {
		if (((nextx += 1)) >= GIV(numSegments)) {
			return null;
		}
		if ((((GIV(segments)[nextx]).segSize)) > (2 * BaseHeaderSize)) {
			return (&(GIV(segments)[nextx]));
		}
	}
}


/*	Restore all shortened segments to their proper size, re-freeing the
	trailing space.
 */

	/* SpurSegmentManager>>#postSnapshot */
static void
postSnapshot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt bytes;
    usqInt freeChunk;
    sqInt i;
    sqInt newEndOfMemory;
    SpurSegmentInfo *seg;


	/* Set endOfMemory first, to avoid assert fails in freeChunkWithBytes:at:. */
	seg = (&(GIV(segments)[GIV(numSegments) - 1]));
	if (((seg->lastFreeObject)) == null) {
		assert((endOfMemory()) == ((segLimit(seg)) - (bridgeSize())));
	}
	else {
		/* begin setEndOfMemory: */
		newEndOfMemory = (((seg->savedSegSize)) + ((seg->segStart))) - (2 * BaseHeaderSize);
		GIV(endOfMemory) = newEndOfMemory;
		if (GIV(freeOldSpaceStart) > newEndOfMemory) {
			GIV(freeOldSpaceStart) = newEndOfMemory;
		}
	}
	for (i = (GIV(numSegments) - 1); i >= 0; i += -1) {
		seg = (&(GIV(segments)[i]));
		freeChunk = (seg->lastFreeObject);
		if (!(freeChunk == null)) {
			address = (((seg->segSize)) + ((seg->segStart))) - (2 * BaseHeaderSize);
			(seg->segSize = (seg->savedSegSize));
			bridgeFromto(seg, (i < (GIV(numSegments) - 1)
				? (&(GIV(segments)[i + 1]))
				: 0));
			/* begin addFreeChunkWithBytes:at: */
			bytes = ((((seg->segSize)) + ((seg->segStart))) - address) - (2 * BaseHeaderSize);
			freeChunkWithBytesat(bytes, address);
			GIV(totalFreeOldSpace) += bytes;
		}
	}
	checkSegments();
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
}


/*	shorten all segments by any trailing free space. */

	/* SpurSegmentManager>>#prepareForSnapshot */
static void NeverInline
prepareForSnapshot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    SpurSegmentInfo * cascade0;
    sqInt followingWord;
    sqInt followingWordAddress;
    usqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt largeChild;
    sqInt limit;
    sqInt newEndOfMemory;
    sqInt next;
    sqInt node;
    usqInt numSlots;
    usqInt numSlots1;
    SpurSegmentInfo *seg;
    sqInt slotBytes;
    sqInt smallChild;
    sqInt treeNode;

	checkSegments();
	for (i = 0; i < GIV(numSegments); i += 1) {
		cascade0 = (&(GIV(segments)[i]));
		(cascade0->savedSegSize = ((GIV(segments)[i]).segSize));
		(cascade0->lastFreeObject = null);
	}
	/* begin freeTreeNodesDo: */
	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		goto l3;
	}
	cameFrom = -1;
	do {
		assert((bytesInObject(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = longAt((treeNode + BaseHeaderSize) + (3LL << (shiftForWord())));
		largeChild = longAt((treeNode + BaseHeaderSize) + (4LL << (shiftForWord())));
		assert((smallChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */
			node = treeNode;
			while (node != 0) {
				/* begin objectAfter:limit: */
				limit = endOfMemory();
				/* begin addressAfter: */
				numSlots1 = byteAt(node + 7);
				numSlots = (numSlots1 == (numSlotsMask())
					? ((usqInt) (((unsigned long)(((long)(longAt(node - BaseHeaderSize))) << 8)))) >> 8
					: numSlots1);
				if (numSlots == 0) {
					slotBytes = 8;
				}
				else {
					slotBytes = ((long)numSlots) << (shiftForWord());
				}
				followingWordAddress = (node + BaseHeaderSize) + slotBytes;
				if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
					next = limit;
					goto l5;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				next = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
			l5:	/* end objectAfter:limit: */;
				if (((longAt(next)) & (classIndexMask())) == 3) {
					/* begin segmentContainingObj: */
					for (i1 = (GIV(numSegments) - 1); i1 >= 0; i1 += -1) {
						if (node >= (((GIV(segments)[i1]).segStart))) {
							seg = (&(GIV(segments)[i1]));
							goto l4;
						}
					}
					seg = null;
				l4:	/* end segmentContainingObj: */;
					(seg->lastFreeObject = node);
					node = 0;
				}
				else {
					node = longAt((node + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
			}
			treeNode = treeNode;

			cameFrom = treeNode;
			treeNode = longAt((treeNode + BaseHeaderSize) + (2LL << (shiftForWord())));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode != 0);
l3:	/* end freeTreeNodesDo: */;
	for (i = 0; i < GIV(numSegments); i += 1) {
		freeChunk = ((GIV(segments)[i]).lastFreeObject);
		if (!(freeChunk == null)) {
			detachFreeObject(freeChunk);
			((GIV(segments)[i]).segSize = ((((byteAt(freeChunk + 7)) == (numSlotsMask())
	? freeChunk - BaseHeaderSize
	: freeChunk)) + (2 * BaseHeaderSize)) - (((GIV(segments)[i]).segStart)));
			bridgeFromto((&(GIV(segments)[i])), (i < (GIV(numSegments) - 1)
				? (&(GIV(segments)[i + 1]))
				: 0));
		}
	}
	/* begin setEndOfMemory: */
	newEndOfMemory = ((((GIV(segments)[GIV(numSegments) - 1]).segSize)) + (((GIV(segments)[GIV(numSegments) - 1]).segStart))) - (2 * BaseHeaderSize);
	GIV(endOfMemory) = newEndOfMemory;
	if (GIV(freeOldSpaceStart) > newEndOfMemory) {
		GIV(freeOldSpaceStart) = newEndOfMemory;
	}
}


/*	Read numBytes of image data from f into memory at memoryBaseForImageRead.
	Answer the number of bytes written. In addition, read each segment, build
	up the
	segment info for swizzling, while eliminating the bridge objects at the
	end of each
	segment that specify the distance to and the size of the subsequent
	segment.  */

	/* SpurSegmentManager>>#readHeapFromImageFile:dataBytes: */
static sqInt NoDbgRegParms
readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bridge;
    usqInt bridgehead;
    usqLong bridgeSpan;
    sqInt bytesRead;
    usqInt newBase;
    usqInt nextSegmentSize;
    usqLong oldBase;
    SpurSegmentInfo *segInfo;
    sqInt totalBytesRead;

	allocateOrExtendSegmentInfos();
	GIV(numSegments) = (totalBytesRead = 0);

	/* N.B. still must be adjusted by oldBaseAddr. */
	oldBase = 0;
	newBase = oldSpaceStart();
	nextSegmentSize = GIV(firstSegmentSize);
	bridgehead = (GIV(firstSegmentSize) + (oldSpaceStart())) - (2 * BaseHeaderSize);
	while (1) {
		segInfo = (&(GIV(segments)[GIV(numSegments)]));
		(segInfo->segStart = oldBase);
		(segInfo->segSize = nextSegmentSize);
		(segInfo->swizzle = newBase - oldBase);
		bytesRead = sqImageFileRead(pointerForOop(newBase), sizeof(char), nextSegmentSize, f);
		if (bytesRead > 0) {
			totalBytesRead += bytesRead;
		}
		if (bytesRead != nextSegmentSize) {
			return totalBytesRead;
		}
		if (((GIV(numSegments) += 1)) >= GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos();
		}
		bridge = bridgehead + BaseHeaderSize;
		bridgeSpan = ((byteAt(bridgehead + 7)) == 0
			? 0
			: BytesPerOop * (((usqInt) (((unsigned long)(((long)(longAt(bridge - BaseHeaderSize))) << 8)))) >> 8));
		oldBase = (oldBase + nextSegmentSize) + bridgeSpan;
		newBase = (newBase + nextSegmentSize) - (2 * BaseHeaderSize);
		nextSegmentSize = ((usqInt)(long64At(bridge)));
		if (!(nextSegmentSize != 0)) break;
		bridgehead = (bridgehead - (2 * BaseHeaderSize)) + nextSegmentSize;
	}
	assert((newBase - (oldSpaceStart())) == (totalBytesRead - (GIV(numSegments) * (bridgeSize()))));
	/* begin setFreeOldSpaceStart: */
	GIV(freeOldSpaceStart) = newBase;
	GIV(firstSegmentSize) = null;
	return totalBytesRead;
}

	/* SpurSegmentManager>>#segmentContainingObj: */
EXPORT(SpurSegmentInfo *)
segmentContainingObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = (GIV(numSegments) - 1); i >= 0; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return (&(GIV(segments)[i]));
		}
	}
	return null;
}

	/* SpurSegmentManager>>#shrinkObjectMemory: */
static void NoDbgRegParms
shrinkObjectMemory(usqInt delta)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurSegmentInfo *best;
    usqInt currentEnd;
    sqInt delta1;
    SpurSegmentInfo *emptySeg;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt j;
    SpurSegmentInfo *seg;
    SpurSegmentInfo *segInfo;
    usqInt shrinkage;

	i2 = 0;
	shrinkage = delta;
	while (1) {
		/* begin findEmptySegNearestInSizeTo: */
		best = null;
		delta1 = shrinkage;
		for (i = 0; i < GIV(numSegments); i += 1) {
			seg = (&(GIV(segments)[i]));
			if (isEmptySegment(seg)) {
				if (best == null) {
					best = seg;
				}
				else {
					if ((shrinkage >= (((seg->segSize)) * 0.75))
					 && ((abs(((seg->segSize)) - shrinkage)) < delta1)) {
						best = seg;
						delta1 = abs(((seg->segSize)) - shrinkage);
					}
				}
			}
		}
		emptySeg = best;
		if (!(emptySeg != null)) break;
		if (((emptySeg->segSize)) > shrinkage) {
			return;
		}
		shrinkage -= (emptySeg->segSize);
		detachFreeObject(objectStartingAt((emptySeg->segStart)));
		/* begin removeSegment: */
		for (i1 = 0; i1 < GIV(numSegments); i1 += 1) {
			if (((emptySeg->segStart)) == (((GIV(segments)[i1]).segStart))) {
				i2 = i1;
				goto l1;
			}
		}
		error("segment not found");
	l1:	/* end indexOfSegment: */;
		assert(i2 > 0);
		sqDeallocateMemorySegmentAtOfSize(((void *)((emptySeg->segStart))), (emptySeg->segSize));
		for (j = i2; j < GIV(numSegments); j += 1) {
			GIV(segments)[j] = (GIV(segments)[j + 1]);
		}
		GIV(numSegments) -= 1;
		bridgeFromto((&(GIV(segments)[i2 - 1])), (i2 <= (GIV(numSegments) - 1)
			? (&(GIV(segments)[i2]))
			: 0));
		/* begin setLastSegment: */
		segInfo = ((SpurSegmentInfo *) ((&(GIV(segments)[GIV(numSegments) - 1]))));
		currentEnd = (((segInfo->segSize)) + ((segInfo->segStart))) - (2 * BaseHeaderSize);
		if (currentEnd <= GIV(endOfMemory)) {
			GIV(endOfMemory) = currentEnd;
			if (GIV(freeOldSpaceStart) > currentEnd) {
				GIV(freeOldSpaceStart) = currentEnd;
			}
		}
	}
}

	/* SpurSegmentManager>>#someSegmentContainsPinned */
static sqInt
someSegmentContainsPinned(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (((GIV(segments)[i]).containsPinned)) {
			return 1;
		}
	}
	return 0;
}

	/* SpurSegmentManager>>#swizzleObj: */
static sqInt NoDbgRegParms
swizzleObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(canSwizzle));
	for (i = (GIV(numSegments) - 1); i >= 1; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return objOop + (((GIV(segments)[i]).swizzle));
		}
	}
	return objOop + (((GIV(segments)[0]).swizzle));
}

	/* SpurSegmentManager>>#totalBytesInSegments */
static usqInt
totalBytesInSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt total;

	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		total += ((GIV(segments)[i]).segSize);
	}
	return total;
}

	/* SpurSegmentManager>>#writeImageSegmentsToFile: */
static sqInt NoDbgRegParms
writeImageSegmentsToFile(sqImageFile aBinaryStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt total;

	assert(((endOfMemory()) == (segLimit(&GIV(segments)[GIV(numSegments) - 1])))
	 || (((endOfMemory()) + (bridgeSize())) == (segLimit(&GIV(segments)[GIV(numSegments) - 1]))));
	if (!(GIV(firstSegmentSize) == null)) {
		assert(GIV(firstSegmentSize) == (((GIV(segments)[0]).segSize)));
	}
	assert((((GIV(segments)[0]).segSize)) > 0);
	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		if ((((GIV(segments)[i]).segSize)) > (2 * BaseHeaderSize)) {
			total += writeSegmentnextSegmenttoFile((&(GIV(segments)[i])), nextNonEmptySegmentAfter(i), aBinaryStream);
		}
	}
	return total;
}


/*	Write the segment contents, the size of and the distance to the next
	segment to aBinaryStream.
 */

	/* SpurSegmentManager>>#writeSegment:nextSegment:toFile: */
static sqInt NoDbgRegParms
writeSegmentnextSegmenttoFile(SpurSegmentInfo *segment, SpurSegmentInfo *nextSegment, sqImageFile aBinaryStream)
{
    usqLong firstSavedBridgeWord;
    sqInt nWritten;
    usqInt pier1;
    sqInt pier2;
    usqLong secondSavedBridgeWord;

	pier1 = (((segment->segSize)) + ((segment->segStart))) - (2 * BaseHeaderSize);
	pier2 = pier1 + BaseHeaderSize;
	assert(isValidSegmentBridge(bridgeFor(segment)));
	assert((startOfObject(bridgeFor(segment))) == pier1);
	firstSavedBridgeWord = long64At(pier1);
	secondSavedBridgeWord = long64At(pier2);
	bridgeFromto(segment, nextSegment);
	long64Atput(pier2, (nextSegment == null
		? 0
		: (nextSegment->segSize)));
	nWritten = sqImageFileWrite(((void *)((segment->segStart))), 1, (segment->segSize), aBinaryStream);
	long64Atput(pier1, firstSavedBridgeWord);
	long64Atput(pier2, secondSavedBridgeWord);
	return nWritten;
}

	/* StackInterpreter>>#accessModifierOfMethod: */
static sqInt NoDbgRegParms
accessModifierOfMethod(sqInt methodObj)
{
    sqInt header;

	/* begin accessModifierOfMethodHeader: */
	assert(isCompiledMethod(methodObj));
	header = longAt((methodObj + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	return (EnforceAccessControl
		? (((usqInt) header) >> MethodHeaderFlagBitPosition) & 3
		: AccessModifierPublic);
}


/*	Answer the current activeProcess. */
/*	useful for VM debugging */

	/* StackInterpreter>>#activeProcess */
sqInt
activeProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;

	/* begin fetchPointer:ofObject: */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	return longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
}


/*	Add the given process to the end of the given linked list
	and set the backpointer of process to its new list. */

	/* StackInterpreter>>#addLastLink:toList: */
static void NoDbgRegParms
addLastLinktoList(sqInt proc, sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLink;

	assert(!((isForwarded(proc))));
	assert(!((isForwarded(aList))));
	assert((fetchPointerofObject(NextLinkIndex, proc)) == (nilObject()));
	if (isEmptyList(aList)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if (isOldObject(aList)) {

			/* most stores into young objects */
			if (((proc & (tagMask())) == 0)
			 && (oopisLessThan(proc, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aList))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(aList);
				}
			}
		}
		longAtput((aList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())), proc);
	}
	else {
		lastLink = longAt((aList + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())));
		assert(lastLink != proc);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(lastLink)));
		if (isOldObject(lastLink)) {

			/* most stores into young objects */
			if (((proc & (tagMask())) == 0)
			 && (oopisLessThan(proc, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(lastLink))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(lastLink);
				}
			}
		}
		longAtput((lastLink + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())), proc);
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(aList)));
	if (isOldObject(aList)) {

		/* most stores into young objects */
		if (((proc & (tagMask())) == 0)
		 && (oopisLessThan(proc, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(aList))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(aList);
			}
		}
	}
	longAtput((aList + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())), proc);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(proc)));
	if (isOldObject(proc)) {

		/* most stores into young objects */
		if (((aList & (tagMask())) == 0)
		 && (oopisLessThan(aList, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(proc))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(proc);
			}
		}
	}
	longAtput((proc + BaseHeaderSize) + (((long)MyListIndex) << (shiftForWord())), aList);
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */

	/* StackInterpreter>>#addNewMethodToCache: */
static void NoDbgRegParms
addNewMethodToCache(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt hash;
    sqInt methodHeader;
    sqInt p;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt probe;


	/* drop low-order zeros from addresses (if classObj not classTag) */
	hash = GIV(messageSelector) ^ (classTagForClass(classObj));
	if (((GIV(newMethod) & (tagMask())) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
		/* begin primitiveIndexOfMethod:header: */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
		if (methodHeader & AlternateHeaderHasPrimFlag) {
			firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
			primitiveIndex = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
		}
		else {
			primitiveIndex = 0;
		}

		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	}
	else {
		assert(!((isNonImmediate(GIV(newMethod)))
 && (isForwarded(GIV(newMethod)))));
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == 0) {

			/* Found an empty entry -- use it */
			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = (classTagForClass(classObj));
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));

			/* this for primitiveExternalMethod */
			GIV(lastMethodCacheProbeWrite) = probe;
			return;
		}
	}

	/* first probe */
	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = (classTagForClass(classObj));
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));

	/* this for primitiveExternalMethod */
	/* ...and zap the following entries */
	GIV(lastMethodCacheProbeWrite) = probe;
	for (p = 1; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}

	/* StackInterpreter>>#addNewMethodToNSCache: */
static void NoDbgRegParms
addNewMethodToNSCache(sqInt rule)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt firstBytecode;
    usqInt hash;
    sqInt methodHeader;
    sqInt p;
    sqInt primBits;
    sqInt primitiveIndex;
    usqInt probe;

	classObj = GIV(lkupClass);
	hash = (GIV(messageSelector) ^ GIV(lkupClassTag)) ^ (GIV(method) ^ rule);
	assert(!((rule == LookupRuleOrdinary)));
	if (((GIV(newMethod) & (tagMask())) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
		/* begin primitiveIndexOfMethod:header: */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
		if (methodHeader & AlternateHeaderHasPrimFlag) {
			firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
			primitiveIndex = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
		}
		else {
			primitiveIndex = 0;
		}

		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	}
	else {
		assert(!((isNonImmediate(GIV(newMethod)))
 && (isForwarded(GIV(newMethod)))));
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & NSMethodCacheMask;
		if ((GIV(nsMethodCache)[probe + NSMethodCacheSelector]) == 0) {

			/* Found an empty entry -- use it */
			GIV(nsMethodCache)[probe + NSMethodCacheSelector] = GIV(messageSelector);
			GIV(nsMethodCache)[probe + NSMethodCacheClassTag] = GIV(lkupClassTag);
			GIV(nsMethodCache)[probe + NSMethodCacheCallingMethod] = GIV(method);
			GIV(nsMethodCache)[probe + NSMethodCacheDepthOrLookupRule] = rule;
			GIV(nsMethodCache)[probe + NSMethodCacheTargetMethod] = GIV(newMethod);
			GIV(nsMethodCache)[probe + NSMethodCachePrimFunction] = (((long) primitiveFunctionPointer));
			GIV(nsMethodCache)[probe + NSMethodCacheActualReceiver] = GIV(localAbsentReceiverOrZero);
			return;
		}
	}

	/* first probe */
	probe = hash & NSMethodCacheMask;
	GIV(nsMethodCache)[probe + NSMethodCacheSelector] = GIV(messageSelector);
	GIV(nsMethodCache)[probe + NSMethodCacheClassTag] = GIV(lkupClassTag);
	GIV(nsMethodCache)[probe + NSMethodCacheCallingMethod] = GIV(method);
	GIV(nsMethodCache)[probe + NSMethodCacheDepthOrLookupRule] = rule;
	GIV(nsMethodCache)[probe + NSMethodCacheTargetMethod] = GIV(newMethod);
	GIV(nsMethodCache)[probe + NSMethodCachePrimFunction] = (((long) primitiveFunctionPointer));
	GIV(nsMethodCache)[probe + NSMethodCacheActualReceiver] = GIV(localAbsentReceiverOrZero);
	for (p = 1; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & NSMethodCacheMask;
		GIV(nsMethodCache)[probe + NSMethodCacheSelector] = 0;
	}
}


/*	Answer if maybeClassObj looks like a class object */

	/* StackInterpreter>>#addressCouldBeClassObj: */
static sqInt NoDbgRegParms
addressCouldBeClassObj(sqInt maybeClassObj)
{
	return (addressCouldBeObj(maybeClassObj))
	 && (objCouldBeClassObj(maybeClassObj));
}

	/* StackInterpreter>>#allOnesAsCharStar */
static char *
allOnesAsCharStar(void)
{
	return ((char *) (((usqInt) -1)));
}


/*	for Cogit */

	/* StackInterpreter>>#argumentCountOfClosure: */
sqInt
argumentCountOfClosure(sqInt closurePointer)
{
    sqInt oop;

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((closurePointer + BaseHeaderSize) + (((long)ClosureNumArgsIndex) << (shiftForWord())));
	assert((((oop) & 7) == 1));
	return (oop >> 3);
}

	/* StackInterpreter>>#argumentCountOfMethodHeader: */
sqInt
argumentCountOfMethodHeader(sqInt header)
{
	return (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
}

	/* StackInterpreter>>#argumentCountOf: */
sqInt
argumentCountOf(sqInt methodPointer)
{
    sqInt header;

	/* begin argumentCountOfMethodHeader: */
	assert(isCompiledMethod(methodPointer));
	header = longAt((methodPointer + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	return (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
}


/*	Return the address of first indexable field of resulting array object, or
	fail if
	the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#arrayValueOf: */
void *
arrayValueOf(sqInt arrayOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (((arrayOop & (tagMask())) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(arrayOop))) >> (formatShift())) & (formatMask())))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Returns an integer object */

	/* StackInterpreter>>#asciiOfCharacter: */
static sqInt NoDbgRegParms
asciiOfCharacter(sqInt characterObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((characterObj & (tagMask())) == 2) {
		return characterObj - ((characterTag()) - 1);
	}
	GIV(primFailCode) = PrimErrBadArgument;
	return ConstZero;
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s: */
void
assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp)
{
	assertValidExecutionPointersimbarline(lip, lifp, lisp, !0, __LINE__);
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s:imbar:line: */
static void NoDbgRegParms
assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assertl(inInterpreter, ln);
	assertl(GIV(stackPage) == (mostRecentlyUsedPage()), ln);
	/* begin assertValidStackLimits: */
	assertl((GIV(stackLimit) == ((GIV(stackPage)->realStackLimit)))
	 || (GIV(stackLimit) == (allOnesAsCharStar())), ln);
	assertl((((GIV(stackPage)->stackLimit)) == ((GIV(stackPage)->realStackLimit)))
	 || (((GIV(stackPage)->stackLimit)) == (allOnesAsCharStar())), ln);
	assertl(addressIsInPage(GIV(stackPage), lfp), ln);
	assertl(lsp < lfp, ln);
	assertl(lfp > lsp, ln);
	assertl(lsp >= (((GIV(stackPage)->realStackLimit)) - (stackLimitOffset())), ln);
	assertl(((lfp - lsp) / BytesPerOop) < LargeContextSlots, ln);
	assertl(validInstructionPointerinFrame(lip, lfp), ln);
	assertl((frameIsBlockActivation(lfp))
	 || ((pushedReceiverOrClosureOfFrame(lfp)) == (frameReceiver(lfp))), ln);
	assertl(GIV(method) == (frameMethod(lfp)), ln);
	assertl((methodUsesAlternateBytecodeSet(GIV(method))) == (GIV(bytecodeSetSelector) == 256), ln);

}


/*	convert true and false (Smalltalk) to true or false(C) */

	/* StackInterpreter>>#booleanValueOf: */
sqInt
booleanValueOf(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (obj == GIV(trueObj)) {
		return 1;
	}
	if (obj == GIV(falseObj)) {
		return 0;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	return null;
}


/*	Re-enter the interpreter for executing a callback */
/*	For now, do not allow a callback unless we're in a primitiveResponse */

	/* StackInterpreter>>#callbackEnter: */
EXPORT(sqInt)
callbackEnter(sqInt *callbackID)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt xArray;

	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	if (!(asserta(GIV(jmpDepth) < MaxJumpBuf))) {
		return 0;
	}

	/* Suspend the currently active process */
	GIV(jmpDepth) += 1;
	GIV(suspendedCallbacks)[GIV(jmpDepth)] = (fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord()))))));
	GIV(suspendedMethods)[GIV(jmpDepth)] = GIV(newMethod);
	/* begin signalExternalSemaphores */
	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ExternalObjectsArray) << (shiftForWord())));
	doSignalExternalSemaphores(numSlotsOf(xArray));
	if ((GIV(suspendedCallbacks)[GIV(jmpDepth)]) == (fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord()))))))) {
		transferTo(wakeHighestPriority());
	}
	forceInterruptCheck();
	if ((setjmp(GIV(jmpBuf)[GIV(jmpDepth)])) == 0) {

		/* Fill in callbackID */
		callbackID[0] = GIV(jmpDepth);
		interpret();
	}
	putToSleepyieldingIf(fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord()))))), GIV(preemptionYields));
	transferTo(GIV(suspendedCallbacks)[GIV(jmpDepth)]);

	/* see comment above */
	GIV(newMethod) = GIV(suspendedMethods)[GIV(jmpDepth)];
	/* begin argumentCountOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	GIV(argumentCount) = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;

	/* clean out the primPops etc since we'll be returning via primitive */
	GIV(jmpDepth) -= 1;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	return 1;
}


/*	Leave from a previous callback */
/*	For now, do not allow a callback return unless we're in a
	primitiveResponse 
 */

	/* StackInterpreter>>#callbackLeave: */
EXPORT(sqInt)
callbackLeave(sqInt cbID)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	if (!(cbID == GIV(jmpDepth))) {
		return 0;
	}
	if (cbID < 1) {
		return 0;
	}
	longjmp(GIV(jmpBuf)[GIV(jmpDepth)], 1);
	return null;
}


/*	Context switch should not be allowed on every method activation. In
	particular the implementation of ensure: and ifCurtailed: depends on there
	being no
	suspension point on failing primitive 198 (primitiveMarkUnwindMethod).
	slowPrimitiveResponse states
	``N.B. This means there is no suspension point on primitive failure
	which methods such as ensure: and ifCurtailed: rely on.''
	Rather than prevent context switch on all primitives but the ones we
	really need
	to be suspension points (primitiveSignal et al) we choose to allow context
	switch for all but primitiveMarkUnwindMethod. */

	/* StackInterpreter>>#canContextSwitchIfActivating:header: */
sqInt
canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt firstBytecode;
    sqInt primBits;
    sqInt primitiveIndex;

	if (methodHeader & AlternateHeaderHasPrimFlag) {
		firstBytecode = (theMethod + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
		primitiveIndex = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
	}
	else {
		primitiveIndex = 0;
	}

	return 
#  if 1
		primitiveIndex != 198
#  else /* 1 */
		(primitiveIndex == 0)
			 || ((((primitiveIndex >= 85) && (primitiveIndex <= 88)))
			 || (primitiveIndex == 167))
#  endif /* 1 */
		;
}


/*	Above ObjectMemory, arg must lie in range 0-255! */

	/* StackInterpreter>>#characterForAscii: */
sqInt
characterForAscii(sqInt ascii)
{
    sqInt objOop;

	return (((long)ascii) << (numTagBits())) + (characterTag());
}


/*	Ensure that all accessible objects in the heap are okay. */

	/* StackInterpreter>>#checkAllAccessibleObjectsOkay */
sqInt
checkAllAccessibleObjectsOkay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt ok;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	ok = 1;
	/* begin allObjectsDoSafely: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		ok = ok && (checkOkayFields(objOop1));


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		ok = ok && (checkOkayFields(objOop1));


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			ok = ok && (checkOkayFields(objOop11));

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	return ok;
}


/*	This is a no-op in the StackVM */

	/* StackInterpreter>>#checkCodeIntegrity: */
static sqInt NoDbgRegParms
checkCodeIntegrity(sqInt fullGCFlag)
{
	return 1;
}


/*	Check for a hit of the longRunningPrimitive probe and if so attempt to
	signal the
	longRunningPrimitiveCheckSemaphore. Answer if a process switch occurred as
	a result. */

	/* StackInterpreter>>#checkDeliveryOfLongRunningPrimitiveSignal */
static sqInt
checkDeliveryOfLongRunningPrimitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((GIV(longRunningPrimitiveCheckSemaphore) != null)
	 && (GIV(longRunningPrimitiveSignalUndelivered)))) {

		/* but not yet delivered */
		GIV(longRunningPrimitiveSignalUndelivered) = 0;

		/* Signal the LRP check semaphore if it is present */
		GIV(longRunningPrimitiveGCUsecs) = ((GIV(gcStartUsecs) < GIV(longRunningPrimitiveStopUsecs))
		 && (GIV(statGCEndUsecs) > GIV(longRunningPrimitiveStartUsecs))
			? GIV(statGCEndUsecs) - GIV(gcStartUsecs)
			: 0);
		return synchronousSignal(GIV(longRunningPrimitiveCheckSemaphore));
	}
	return 0;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#checkedIntegerValueOf: */
sqInt
checkedIntegerValueOf(sqInt intOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((intOop) & 7) == 1)) {
		return (intOop >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	In Spur a primitive may fail due to encountering a forwarder. On failure,
	check the accessorDepth for the primitive and if non-negative scan the
	args to the depth, following any forwarders. Answer if any are found so
	the prim can be retried. The primitive index is derived from newMethod.
	If the primitive is 118, then primitiveDoPrimitiveWithArgs sets newMethod
	to a SmallInteger whose value is the primitive it is evaluating. */

	/* StackInterpreter>>#checkForAndFollowForwardedPrimitiveState */
static sqInt
checkForAndFollowForwardedPrimitiveState(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    signed char accessorDepth;
    sqInt firstBytecode;
    sqInt found;
    sqInt index;
    sqInt methodHeader;
    sqInt oop;
    sqInt primBits;
    sqInt primIndex;
    signed char primitiveAccessorDepthTable[MaxPrimitiveIndex + 2 /* 577 */] = {
/*0*/	-1,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0,-1,-1, 0, 0, 0, 0, 0, 0,-1,
/*20*/	0, 0, 0,-1,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0,-1,-1,-1, 0, 0, 0,
/*40*/	0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,
/*60*/	0, 0, 1,-1,-1,-1,-1,-1, 0, 0,-1,-1, 0, 1, 1, 0, 0, 0, 0, 0,
/*80*/	-1,-1,-1, 0,-1,-1, 0, 0, 1,-1,-1, 0, 0, 0, 0,-1,-1,-1, 0, 0,
/*100*/	1, 1, 0, 2,-1, 1,-1,-1,-1,-1, 0, 0,-1,-1,-1, 1, 1,-1, 1, 0,
/*120*/	-1, 0,-1,-1, 0, 0, 0, 0, 0,-1,-1,-1, 1, 0, 0,-1, 0,-1,-1,-1,
/*140*/	-1, 1,-1, 1, 0, 0,-1,-1, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*160*/	0, 0,-1, 0, 0, 1, 1,-1, 1, 0, 0, 1,-1, 1, 1,-1,-1,-1,-1,-1,
/*180*/	0,-1,-1, 0, 0, 0, 1, 1, 1, 0,-1,-1,-1,-1,-1, 1, 2,-1,-1,-1,
/*200*/	0, 2, 2, 2, 2, 2, 2,-1,-1,-1, 1, 1, 1, 0,-1, 1,-1,-1, 3,-1,
/*220*/	-1, 2, 2,-1,-1,-1,-1,-1,-1,-1, 0,-1, 2, 0,-1,-1,-1,-1,-1,-1,
/*240*/	-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1, 0, 1,-1, 0,-1,-1,-1,-1,-1,
/*260*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*280*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*300*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*320*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*340*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*360*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*380*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*400*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*420*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*440*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*460*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*480*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*500*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*520*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
/*540*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,
/*560*/	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0,-1,-1
	};
    sqInt referent;
    sqInt scannedStackFrame;

	assert(failed());
	found = (scannedStackFrame = 0);
	if ((((GIV(newMethod)) & 7) == 1)) {
		primIndex = (GIV(newMethod) >> 3);
	}
	else {
		assert(GIV(argumentCount) == (argumentCountOf(GIV(newMethod))));
		/* begin primitiveIndexOfMethod:header: */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
		if (methodHeader & AlternateHeaderHasPrimFlag) {
			firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
			primIndex = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
		}
		else {
			primIndex = 0;
		}

	}

	/* For the method-executing primitives, failure could have been in those primitives or the
	   primitives of the methods they execute.  Find out which failed by seeing what is in effect. */
	accessorDepth = primitiveAccessorDepthTable[primIndex];
	if (((primIndex == 117)
	 && (primitiveFunctionPointer != primitiveExternalCall))
	 || ((primIndex == 218)
	 && (primitiveFunctionPointer != primitiveDoNamedPrimitiveWithArgs))) {
		accessorDepth = ((fetchPointerofObject(2, longAt((GIV(newMethod) + BaseHeaderSize) + (((long)(0 + LiteralStart)) << (shiftForWord()))))) >> 3);
	}
	else {
		assert(saneFunctionPointerForFailureOfPrimIndex(primIndex));
	}
	assert(((accessorDepth >= -127) && (accessorDepth <= 0x7F)));
	if (accessorDepth >= 0) {
		for (index = 0; index <= GIV(argumentCount); index += 1) {
			oop = longAt(GIV(stackPointer) + (index * BytesPerWord));
			if ((oop & (tagMask())) == 0) {
				if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					assert(index < GIV(argumentCount));
					found = 1;
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(oop));
					referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					oop = referent;
					longAtput(GIV(stackPointer) + (index * BytesPerWord), oop);
					if (!scannedStackFrame) {
						scannedStackFrame = 1;
						followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((GIV(argumentCount) + 1) * BytesPerWord));
					}
				}
				if ((((oop & (tagMask())) == 0)
				 && (isAnyPointerFormat((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask()))))
				 && (followForwardedObjectFieldstoDepth(oop, accessorDepth))) {
					found = 1;
				}
			}
		}
	}
	return found;
}


/*	Check for possible interrupts and handle one if necessary.
	Answer if a context switch has occurred. */

	/* StackInterpreter>>#checkForEventsMayContextSwitch: */
static sqInt NoDbgRegParms
checkForEventsMayContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong now;
    sqInt objOop;
    sqInt sema;
    sqInt switched;


	/* restore the stackLimit if it has been smashed. */
	GIV(statCheckForEvents) += 1;
	/* begin restoreStackLimit */
	(GIV(stackPage)->stackLimit = (GIV(stackPage)->realStackLimit));
	GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	ioSynchronousCheckForEvents();
	if (GIV(needGCFlag)) {

		/* sufficientSpaceAfterGC: runs the incremental GC and
		   then, if not enough space is available, the fullGC. */
		if (!(sufficientSpaceAfterGC(0))) {
			setSignalLowSpaceFlagAndSaveProcess();
		}
	}
	if (!mayContextSwitch) {
		return 0;
	}
	switched = 0;
	if ((GIV(profileProcess) != GIV(nilObj))
	 || ((GIV(nextProfileTick) > 0)
	 && ((ioHighResClock()) >= GIV(nextProfileTick)))) {

		/* Take a sample (if not already done so) for the profiler if it is active.  This
		   must be done before any of the synchronousSignals below or else we will
		   attribute a pause in ioRelinquishProcessor to the newly activated process. */
		GIV(nextProfileTick) = 0;
		if (GIV(profileProcess) == GIV(nilObj)) {
			/* begin fetchPointer:ofObject: */
			objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
			GIV(profileProcess) = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
			GIV(profileMethod) = GIV(nilObj);
		}
		if ((GIV(profileSemaphore) != GIV(nilObj))
		 && (synchronousSignal(GIV(profileSemaphore)))) {
			switched = 1;
		}
	}
	if (checkDeliveryOfLongRunningPrimitiveSignal()) {
		switched = 1;
	}
	if (GIV(signalLowSpace)) {
		GIV(signalLowSpace) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheLowSpaceSemaphore) << (shiftForWord())));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (((now = ioUTCMicroseconds())) >= GIV(nextPollUsecs)) {
		GIV(statIOProcessEvents) += 1;
		ioProcessEvents();

		/* msecs to wait before next call to ioProcessEvents.  Note that strictly
		   speaking we might need to update 'now' at this point since
		   ioProcessEvents could take a very long time on some platforms */
		GIV(nextPollUsecs) = now + 20000;
	}

	if (GIV(interruptPending)) {

		/* reset interrupt flag */
		GIV(interruptPending) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheInterruptSemaphore) << (shiftForWord())));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (GIV(nextWakeupUsecs) != 0) {
		if (now >= GIV(nextWakeupUsecs)) {

			/* set timer interrupt to 0 for 'no timer' */
			GIV(nextWakeupUsecs) = 0;
			sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheTimerSemaphore) << (shiftForWord())));
			if ((sema != GIV(nilObj))
			 && (synchronousSignal(sema))) {
				switched = 1;
			}
		}
	}
	if (GIV(pendingFinalizationSignals) > 0) {
		GIV(pendingFinalizationSignals) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheFinalizationSemaphore) << (shiftForWord())));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (signalExternalSemaphores()) {
		switched = 1;
	}
	return switched;
}


/*	Read and verify the image file version number and return true if the the
	given image file needs to be byte-swapped. As a side effect, position the
	file stream just after the version number of the image header. This code
	prints a warning and does a hard-exit if it cannot find a valid version
	number. 
 */
/*	This code is based on C code by Ian Piumarta. */

	/* StackInterpreter>>#checkImageVersionFrom:startingAt: */
static sqInt NoDbgRegParms
checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset)
{
    sqInt firstVersion;
    sqInt version;
    int w;
    int w1;
    int w2;


	/* check the version number */
	sqImageFileSeek(f, imageOffset);
	version = (firstVersion = getWord32FromFileswap(f, 0));
	if ((version == (imageFormatVersion()))
	 || (0)) {
		return 0;
	}
	sqImageFileSeek(f, imageOffset);
	/* begin getWord32FromFile:swap: */
	w2 = 0;
	sqImageFileRead((&w2), sizeof(int), 1, f);
	version = byteSwapped(w2);
	if ((version == (imageFormatVersion()))
	 || (0)) {
		return 1;
	}
	if (imageOffset == 0) {

		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */
		sqImageFileSeek(f, 512);
		/* begin getWord32FromFile:swap: */
		w = 0;
		sqImageFileRead((&w), sizeof(int), 1, f);
		version = w;
		if ((version == (imageFormatVersion()))
		 || (0)) {
			return 0;
		}
		sqImageFileSeek(f, 512);
		/* begin getWord32FromFile:swap: */
		w1 = 0;
		sqImageFileRead((&w1), sizeof(int), 1, f);
		version = byteSwapped(w1);
		if ((version == (imageFormatVersion()))
		 || (0)) {
			return 1;
		}
	}
	print("This interpreter (vers. ");
	printNum(imageFormatVersion());
	print(") cannot read image file (vers. ");
	printNum(firstVersion);
	print(").");
	/* begin cr */
	printf("\n");
	print("Press CR to quit...");
	getchar();
	ioExitWithErrorCode(1);
	return 0;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all oops in the interpreter's state
	points to a header. Answer if all checks pass. */

	/* StackInterpreter>>#checkInterpreterIntegrity */
static sqInt
checkInterpreterIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;

	ok = 1;
	if (!(checkOopIntegritynamed(GIV(specialObjectsOop), "specialObjectsOop"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(newMethod), "newMethod"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileProcess), "profileProcess"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileMethod), "profileMethod"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileSemaphore), "profileSemaphore"))) {
		ok = 0;
	}
	if (!(GIV(tempOop) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop), "tempOop"))) {
			ok = 0;
		}
	}
	if (!(GIV(tempOop2) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop2), "tempOop2"))) {
			ok = 0;
		}
	}
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		if (!(checkOopIntegritynamedindex(GIV(suspendedCallbacks)[i], "suspendedCallbacks", i))) {
			ok = 0;
		}
		if (!(checkOopIntegritynamedindex(GIV(suspendedMethods)[i], "suspendedMethods", i))) {
			ok = 0;
		}
	}
	return ok;
}


/*	Another version of isWidowedContext: for debugging.
	This will not bereave a widowed context. */

	/* StackInterpreter>>#checkIsStillMarriedContext:currentFP: */
static sqInt NoDbgRegParms
checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *limitFP;
    char *maybeFP;
    sqInt maybeFrameCtxt;
    sqInt referent;
    sqInt senderOop;
    StackPage *thePage;

	if (!((((aContext & (tagMask())) == 0)
		 && (((longAt(aContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && (((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)))) {
		return 0;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	maybeFP = pointerForOop(senderOop - 1);
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(maybeFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	limitFP = ((thePage == GIV(stackPage))
	 && (currentFP != null)
		? currentFP
		: (thePage->headFP));
	if (!((maybeFP >= limitFP)
		 && ((((((sqInt)(pointerForOop(longAt(maybeFP + FoxSavedFP))))) & (tagMask())) == 0)
		 && (((withSmallIntegerTags(pointerForOop(longAt(maybeFP + FoxSavedFP)))) == (longAt((aContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())))))
		 && ((byteAt((maybeFP + FoxFrameFlags) + 2)) != 0))))) {
		return 0;
	}

	/* On Spur we need to follow the context to check for a match, but since the VM is
	   only speculating about maybeFrame being a frame, and only speculating about
	   maybeContext being a context, we need to be sure before we can safely follow. */
	maybeFrameCtxt = longAt(maybeFP + FoxThisContext);
	if ((isFrameonPage(maybeFP, thePage))
	 && (((longAt(maybeFrameCtxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(maybeFrameCtxt));
		referent = longAt((maybeFrameCtxt + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		maybeFrameCtxt = referent;
	}
	return maybeFrameCtxt == aContext;
}


/*	Check if the argument is an ok object.
	If this is a pointers object, check that its fields are all okay oops. */

	/* StackInterpreter>>#checkOkayFields: */
static sqInt NoDbgRegParms
checkOkayFields(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldOop;
    sqInt hasYoung;
    sqInt i;

	if ((oop == null)
	 || (oop == 0)) {
		return 1;
	}
	if ((((oop) & 7) == 1)) {
		return 1;
	}
	if (!(checkOkayOop(oop))) {
		return 0;
	}
	if (!(checkOopHasOkayClass(oop))) {
		return 0;
	}
	if (!((((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) <= 5)
		 || (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return 1;
	}
	hasYoung = 0;
	if (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
		i = ((literalCountOfMethodHeader(methodHeaderOf(oop))) + LiteralStart) - 1;
	}
	else {
		if (((oop & (tagMask())) == 0)
		 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
		}
		else {
			i = (lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask()))) - 1;
		}
	}
	while (i >= 0) {
		fieldOop = longAt((oop + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if (!((((fieldOop) & 7) == 1))) {
			hasYoung = hasYoung
			 || (((fieldOop & (tagMask())) == 0)
			 && (oopisLessThan(fieldOop, GIV(newSpaceLimit))));
			if (!(checkOkayOop(fieldOop))) {
				return 0;
			}
			if (!(checkOopHasOkayClass(fieldOop))) {
				return 0;
			}
		}
		i -= 1;
	}
	if (hasYoung) {
		/* begin checkOkayYoungReferrer: */
		if (oopisLessThan(oop, GIV(newSpaceLimit))) {
			return 1;
		}
		if (!(((((usqInt) (longAt(oop))) >> (rememberedBitShift())) & 1) != 0)) {
			print("remembered bit is not set in ");
			printHex(oop);
			/* begin cr */
			printf("\n");
			return 0;
		}
		if (isInRememberedSet(oop)) {
			return 1;
		}
		printHex(oop);
		print(" has remembered bit set but is not in remembered set");
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

	/* StackInterpreter>>#checkOkayInterpreterObjects: */
sqInt
checkOkayInterpreterObjects(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt ok;
    sqInt oop;
    long oopOrZero;

	ok = 1;
	ok = ok && (checkOkayFields(GIV(nilObj)));
	ok = ok && (checkOkayFields(GIV(falseObj)));
	ok = ok && (checkOkayFields(GIV(trueObj)));
	ok = ok && (checkOkayFields(GIV(specialObjectsOop)));
	ok = ok && (checkOkayFields(GIV(messageSelector)));
	ok = ok && (checkOkayFields(GIV(newMethod)));
	ok = ok && (checkOkayFields(GIV(lkupClass)));
	for (i = 0; i < MethodCacheEntries; i += MethodCacheEntrySize) {
		oopOrZero = GIV(methodCache)[i + MethodCacheSelector];
		if (!(oopOrZero == 0)) {
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheSelector]));
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheMethod]));
		}
	}
	for (i = 1, iLimiT = (remapBufferCount()); i <= iLimiT; i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!((oop & (tagMask())) != 0)) {
			ok = ok && (checkOkayFields(oop));
		}
	}
	ok = ok && (checkOkayStackZone(writeBack));
	return ok;
}

	/* StackInterpreter>>#checkOkayStackPage: */
static sqInt NoDbgRegParms
checkOkayStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt ok;
    sqInt oop;
    char *theFP;
    char *theSP;

	theSP = (thePage->headSP);
	theFP = (thePage->headFP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	ok = 1;
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((((oop) & 7) == 1))) {
				ok = ok && (checkOkayFields(oop));
			}
			theSP += BytesPerWord;
		}
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			ok = ok && (checkOkayFields(longAt(theFP + FoxThisContext)));
		}
		ok = ok && (checkOkayFields(longAt(theFP + FoxMethod)));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */
	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((((oop) & 7) == 1))) {
			ok = ok && (checkOkayFields(oop));
		}
		theSP += BytesPerWord;
	}
	return ok;
}


/*	Check that all objects in the stack zone are okay */

	/* StackInterpreter>>#checkOkayStackZone: */
static sqInt NoDbgRegParms
checkOkayStackZone(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;
    StackPage *thePage;

	if (writeBack) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			ok = ok && (checkOkayStackPage(thePage));
		}
	}
	return ok;
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil. */

	/* StackInterpreter>>#checkProfileTick: */
static void NoDbgRegParms
checkProfileTick(sqInt aPrimitiveMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;

	assert(GIV(nextProfileTick) != 0);
	if ((ioHighResClock()) >= GIV(nextProfileTick)) {
		/* begin fetchPointer:ofObject: */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
		GIV(profileProcess) = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
		if (!GIV(primFailCode)) {
			GIV(profileMethod) = aPrimitiveMethod;
		}
		else {
			GIV(profileMethod) = GIV(nilObj);
		}
		forceInterruptCheck();
		GIV(nextProfileTick) = 0;
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccesibleObjects has set a bit at each
	object's header. Scan all objects accessible from the stack
	checking that every pointer points to a header. Answer if no
	dangling pointers were detected. */

	/* StackInterpreter>>#checkStackIntegrity */
static sqInt
checkStackIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt ok;
    sqInt oop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			if (thePage == GIV(stackPage)) {
				theSP = GIV(stackPointer);
				theFP = GIV(framePointer);
			}
			else {
				theSP = (thePage->headSP);
				theFP = (thePage->headFP);
			}
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & (tagMask())) == 0)
					 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame temp", theFP, theSP);
						ok = 0;
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					oop = longAt(theFP + FoxThisContext);
					if (((oop & (tagMask())) != 0)
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame ctxt", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!(((oop & (tagMask())) == 0)
						 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
						printFrameThingandFrameat("frame ctxt should be context", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((((oop & (tagMask())) == 0)
						 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex))
						 && (((((longAt((oop + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)))) {
						printFrameThingandFrameat("frame ctxt should be married", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((((oop & (tagMask())) == 0)
						 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex))
						 && ((((((longAt((oop + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
						 && ((frameOfMarriedContext(oop)) == theFP)))) {
						printFrameThingandFrameat("frame ctxt should be married to this frame ", theFP, theFP + FoxThisContext);
						ok = 0;
					}
				}
				oop = longAt(theFP + FoxMethod);
				if (((oop & (tagMask())) != 0)
				 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame mthd", theFP, theFP + FoxMethod);
					ok = 0;
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & (tagMask())) == 0)
				 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame arg", theFP, theSP);
					ok = 0;
				}
				theSP += BytesPerWord;
			}
		}
	}
	return ok;
}


/*	Check if aClass's name is className */

	/* StackInterpreter>>#classNameOf:Is: */
static sqInt NoDbgRegParms
classNameOfIs(sqInt aClass, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt length;
    sqInt name;
    char *srcName;

	if ((lengthOfformat(aClass, (((usqInt) (longAt(aClass))) >> (formatShift())) & (formatMask()))) <= GIV(classNameIndex)) {
		return 0;
	}
	name = longAt((aClass + BaseHeaderSize) + (((long)GIV(classNameIndex)) << (shiftForWord())));
	if (!(((name & (tagMask())) == 0)
		 && (((((usqInt) (longAt(name))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		return 0;
	}
	length = stSizeOf(name);
	srcName = ((char *) (arrayValueOf(name)));
	for (i = 0; i < length; i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}


/*	Does thisCntx have aContext in its sender chain?
	Cheapo implementation above extant machinery. */

	/* StackInterpreter>>#context:hasSender: */
static sqInt NoDbgRegParms
contexthasSender(sqInt thisCntx, sqInt aContext)
{
    sqInt handlerOrNilOrZero;

	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(-1, thisCntx, aContext);
	return handlerOrNilOrZero == 0;
}


/*	For asserts. Check that theIP maps back correctly to the context's pc.
	The CallPrimitive bytecode presents a complication. */

	/* StackInterpreter>>#context:hasValidInversePCMappingOf:in: */
static sqInt NoDbgRegParms
contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP)
{
    sqInt encodedip;
    sqInt methodHeader;
    sqInt pc;

	pc = longAt((aContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())));
	/* begin contextInstructionPointer:frame: */
	assert(validInstructionPointerinFrame(theIP + 1, theFP));
	encodedip = (((((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1);
	return (pc == encodedip)
	 || (((methodHeader = methodHeaderOf(longAt((aContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord()))))),
	(methodHeader & AlternateHeaderHasPrimFlag)
		 && ((((encodedip >> 3)) - ((pc >> 3))) == (3))));
}


/*	for Cogit */

	/* StackInterpreter>>#copiedValueCountOfClosure: */
sqInt
copiedValueCountOfClosure(sqInt closurePointer)
{
	return (numSlotsOf(closurePointer)) - ClosureFirstCopiedValueIndex;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

	/* StackInterpreter>>#copyBits */
sqInt
copyBits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=copyBitsFrom:to:at: and call it. This entire mechanism
	should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#copyBitsFrom:to:at: */
sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}

	/* StackInterpreter>>#couldBeProcess: */
static sqInt NoDbgRegParms NeverInline
couldBeProcess(sqInt oop)
{
	return (addressCouldBeObj(oop))
	 && ((((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) <= 5)
	 && ((!(((oop & (tagMask())) == 0)
 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex)))
	 && (((lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask()))) > MyListIndex)
	 && (isContext(longAt((oop + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord()))))))));
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#cr */
static void
cr(void)
{
	printf("\n");
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message
	object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand: */

	/* StackInterpreter>>#createActualMessageTo: */
static void NoDbgRegParms
createActualMessageTo(sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt classObj;
    sqInt classObj1;
    sqInt i;
    sqInt knownClassIndex;
    sqInt knownClassIndex1;
    sqInt message;
    usqInt newObj;
    usqInt newObj1;
    usqInt newObj2;
    usqInt newObj3;
    usqInt numBytes;
    usqInt numBytes1;
    usqInt numBytes2;
    usqInt numBytes3;
    sqInt numSlots;
    sqInt numSlots1;
    sqInt numSlots2;
    sqInt objFormat;
    sqInt objFormat1;
    char *sp;


	/* This is a useful break-point */
	assert((isImmediate(GIV(messageSelector)))
	 || (addressCouldBeObj(GIV(messageSelector))));
	/* begin mnuBreakpoint:receiver: */
	mnuBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), null);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
	 && (ClassArrayCompactIndex != 0));
	assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(GIV(argumentCount) < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((GIV(argumentCount) < 1
	? 8
	: GIV(argumentCount) * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			argumentArray = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) GIV(argumentCount)))) << (numSlotsFullShift())) + (2LL << (formatShift()))) + ClassArrayCompactIndex);
	GIV(freeStart) += numBytes;
	argumentArray = newObj;
l1:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	numSlots = MessageLookupClassIndex + 1;
	assert((numSlots >= 0)
	 && (ClassMessageCompactIndex != 0));
	assert((1) == (instSpecOfClass(knownClassAtIndex(ClassMessageCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj1 = GIV(freeStart);
	numBytes1 = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes1 % (allocationUnit())) == 0);
	assert((newObj1 % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes1) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			message = 0;
			goto l2;
		}
	}
	long64Atput(newObj1, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (1LL << (formatShift()))) + ClassMessageCompactIndex);
	GIV(freeStart) += numBytes1;
	message = newObj1;
l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

	for (i = ((GIV(argumentCount) - 1) * BytesPerOop); i >= 0; i += (-BytesPerOop)) {
		longAtput((argumentArray + BaseHeaderSize) + i, popStack());
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(message)));
	longAtput((message + BaseHeaderSize) + (((long)MessageSelectorIndex) << (shiftForWord())), GIV(messageSelector));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(message)));
	longAtput((message + BaseHeaderSize) + (((long)MessageArgumentsIndex) << (shiftForWord())), argumentArray);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(message)));
	longAtput((message + BaseHeaderSize) + (((long)MessageLookupClassIndex) << (shiftForWord())), lookupClass);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), message);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = 1;
}


/*	Return the default number of stack pages allocate at startup.
	This default suits Qwaq Forums (specifically general rendering).
	It is probably a bit high for normal use but QF is profligate with
	processes. The actual value can be set via vmParameterAt: and/or a
	preference in the ini file. */

	/* StackInterpreter>>#defaultNumStackPages */
static sqInt
defaultNumStackPages(void)
{
	return 160;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

	/* StackInterpreter>>#displayBitsOf:Left:Top:Right:Bottom: */
static sqInt NoDbgRegParms
displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt d;
    sqInt dispBits;
    sqInt dispBitsIndex;
    sqInt displayObj;
    sqInt h;
    sqInt left;
    sqInt right;
    sqInt successBoolean;
    sqInt surfaceHandle;
    sqInt top;
    sqInt w;

	d = 0;
	dispBits = 0;
	h = 0;
	w = 0;
	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheDisplay) << (shiftForWord())));
	if (!(aForm == displayObj)) {
		return null;
	}
	/* begin success: */
	successBoolean = (((displayObj & (tagMask())) == 0)
	 && (((((usqInt) (longAt(displayObj))) >> (formatShift())) & (formatMask())) <= 5))
	 && ((lengthOfformat(displayObj, (((usqInt) (longAt(displayObj))) >> (formatShift())) & (formatMask()))) >= 4);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		dispBits = longAt((displayObj + BaseHeaderSize) + (0LL << (shiftForWord())));
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		d = fetchIntegerofObject(3, displayObj);
	}
	if (l < 0) {
		left = 0;
	}
	else {
		left = l;
	}
	if (r > w) {
		right = w;
	}
	else {
		right = r;
	}
	if (t < 0) {
		top = 0;
	}
	else {
		top = t;
	}
	if (b > h) {
		bottom = h;
	}
	else {
		bottom = b;
	}
	if (!((left <= right)
		 && (top <= bottom))) {
		return null;
	}
	if (!GIV(primFailCode)) {
		if ((((dispBits) & 7) == 1)) {
			surfaceHandle = (dispBits >> 3);
			if (showSurfaceFn == 0) {
				showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin");
				if (showSurfaceFn == 0) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					return null;
				}
			}
			((sqInt (*)(sqInt, sqInt, sqInt, sqInt, sqInt))showSurfaceFn)(surfaceHandle, left, top, right-left, bottom-top);
		}
		else {
			assert(isNonImmediate(dispBits));

			/* index in memory byte array */
			dispBitsIndex = dispBits + BaseHeaderSize;
			ioShowDisplay(dispBitsIndex, w, h, d, left, right, top, bottom);
		}
	}
}

	/* StackInterpreter>>#divorceAllFrames */
static sqInt
divorceAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *aPage;
    sqInt i;

	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
l1:	/* end ensureFrameIsMarried:SP: */;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			divorceFramesIn(aPage);
		}
	}
	/* begin zeroStackPage */
	assert((GIV(stackPage) == 0)
	 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
	GIV(stackPage) = 0;
	return activeContext;
}

	/* StackInterpreter>>#divorceFramesIn: */
static void NoDbgRegParms
divorceFramesIn(StackPage *aStackPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    char *calleeFP;
    sqInt theContext;
    char *theFP;
    sqInt theIP;
    char *theSP;
    sqInt valuePointer;

	GIV(statStackPageDivorce) += 1;
	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	theIP = longAt(theSP);

	/* theSP points at hottest item on frame's stack */
	theSP += BytesPerWord;
	calleeContext = null;
	while (1) {
		/* begin ensureFrameIsMarried:SP: */
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			theContext = longAt(theFP + FoxThisContext);
			goto l1;
		}
		theContext = marryFrameSP(theFP, theSP);
	l1:	/* end ensureFrameIsMarried:SP: */;
		updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(validInstructionPointerinFrame(theIP + 1, theFP));
		valuePointer = (((((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1);
		assert(!(isForwarded(theContext)));
		longAtput((theContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), valuePointer);
		assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));
		if (calleeContext != null) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(calleeContext)));
			if (isOldObject(calleeContext)) {

				/* most stores into young objects */
				if (((theContext & (tagMask())) == 0)
				 && (oopisLessThan(theContext, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(calleeContext))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(calleeContext);
					}
				}
			}
			longAtput((calleeContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), theContext);
		}
		calleeContext = theContext;
		calleeFP = theFP;
		theIP = ((sqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;

		/* theSP points at stacked hottest item on frame's stack */
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((calleeFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	if (isOldObject(theContext)) {

		/* most stores into young objects */
		if ((((longAt(calleeFP + FoxCallerContext)) & (tagMask())) == 0)
		 && (oopisLessThan(longAt(calleeFP + FoxCallerContext), GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(theContext))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(theContext);
			}
		}
	}
	longAtput((theContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), longAt(calleeFP + FoxCallerContext));
	(aStackPage->baseFP = 0);
}


/*	Rounds negative results towards negative infinity, rather than zero. */

	/* StackInterpreter>>#doPrimitiveDiv:by: */
static sqInt NoDbgRegParms
doPrimitiveDivby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt posArg;
    sqInt posRcvr;
    sqInt result;

	integerArg = 0;
	integerRcvr = 0;
	if (((((rcvr) & 7) == 1))
	 && ((((arg) & 7) == 1))) {
		integerRcvr = (rcvr >> 3);
		integerArg = (arg >> 3);
		/* begin success: */
		if (!(integerArg != 0)) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {

			/* round negative result toward negative infinity */
			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */
			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	/* begin success: */
	if (!((((((usqInt) result) >> 60) + 1) & 15) <= 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return result;
}

	/* StackInterpreter>>#doPrimitiveMod:by: */
static sqInt NoDbgRegParms
doPrimitiveModby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;

	integerArg = 0;
	integerRcvr = 0;
	if (((((rcvr) & 7) == 1))
	 && ((((arg) & 7) == 1))) {
		integerRcvr = (rcvr >> 3);
		integerArg = (arg >> 3);
		/* begin success: */
		if (!(integerArg != 0)) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}

	/* ensure that the result has the same sign as the integerArg */
	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	}
	else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}
	/* begin success: */
	if (!((((((usqInt) integerResult) >> 60) + 1) & 15) <= 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return integerResult;
}


/*	Signal the external semaphore with the given index. Answer if a context
	switch occurs as a result. Do not bounds check. This has been done in the
	caller.  */

	/* StackInterpreter>>#doSignalSemaphoreWithIndex: */
sqInt
doSignalSemaphoreWithIndex(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ExternalObjectsArray) << (shiftForWord())));
	assert(isArray(xArray));

	/* Note: semaphore indices are 1-based */
	sema = longAt((xArray + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord())));
	assert(!(isOopForwarded(sema)));
	return (((sema & (tagMask())) == 0)
	 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord())))))))
	 && (synchronousSignal(sema));
}

	/* StackInterpreter>>#dummyReferToProxy */
static void
dummyReferToProxy(void)
{
	interpreterProxy = interpreterProxy;
}


/*	Dummy definition to allow the StackInterpreter to link against the Cog
	run-time. 
 */

	/* StackInterpreter>>#dumpPrimTraceLog */
void
dumpPrimTraceLog(void)
{
}


/*	This is used to implement outer sends and outer expressions in Newspeak. */

	/* StackInterpreter>>#enclosingObjectAt:withObject:withMixin: */
static sqInt NoDbgRegParms
enclosingObjectAtwithObjectwithMixin(sqInt depth, sqInt methodReceiver, sqInt methodMixin)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt enclosingObject;
    sqInt mixinApplication;
    sqInt objOop;
    sqInt objOop1;
    sqInt tagBits;
    sqInt targetMixin;

	enclosingObject = methodReceiver;
	targetMixin = methodMixin;
	count = 0;
	while (count < depth) {
		count += 1;
		assert(!((targetMixin == (nilObject()))));
		mixinApplication = findApplicationOfTargetMixinstartingAtBehavior(targetMixin, (((tagBits = enclosingObject & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
			: fetchClassOfNonImm(enclosingObject)));
		assert(!((mixinApplication == (nilObject()))));
		/* begin followObjField:ofObject: */
		objOop = longAt((mixinApplication + BaseHeaderSize) + (((long)EnclosingObjectIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop));
		if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(EnclosingObjectIndex, mixinApplication, objOop);
		}
		enclosingObject = objOop;
		/* begin followObjField:ofObject: */
		objOop1 = longAt((targetMixin + BaseHeaderSize) + (((long)EnclosingMixinIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop1));
		if (((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(EnclosingMixinIndex, targetMixin, objOop1);
		}
		targetMixin = objOop1;
	}
	return enclosingObject;
}


/*	Answerr the caller context for a frame. If the frame has a caller
	frame that doesn't have a context, then marry the caller frame. */

	/* StackInterpreter>>#ensureCallerContext: */
static sqInt NoDbgRegParms
ensureCallerContext(char *theFP)
{
    char *callerFP;
    char *theSP;

	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		return longAt(theFP + FoxCallerContext);
	}
	/* begin ensureFrameIsMarried:SP: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
	if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP)));
		return longAt(callerFP + FoxThisContext);
	}
	return marryFrameSP(callerFP, theSP);
}


/*	Ensure the image data has been updated to suit the current VM. */

	/* StackInterpreter>>#ensureImageFormatIsUpToDate: */
static void NoDbgRegParms
ensureImageFormatIsUpToDate(sqInt swapBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt fmt;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord11;
    sqInt followingWord2;
    sqInt followingWord3;
    sqInt followingWord4;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress11;
    sqInt followingWordAddress2;
    sqInt followingWordAddress3;
    sqInt followingWordAddress4;
    usqInt limit;
    usqInt limit1;
    sqInt methodHeader;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots111;
    usqInt numSlots12;
    usqInt numSlots121;
    usqInt numSlots13;
    usqInt numSlots14;
    usqInt numSlots15;
    usqInt numSlots2;
    usqInt numSlots21;
    usqInt numSlots3;
    usqInt numSlots31;
    usqInt numSlots4;
    usqInt numSlots5;
    usqInt numSlots6;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop13;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj2;
    sqInt prevObj3;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj2;
    sqInt prevPrevObj3;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes11;
    sqInt slotBytes2;
    sqInt slotBytes3;
    sqInt slotBytes4;
    sqInt stopAddr;
    sqInt swapFloatWords;
    sqInt temp;
    sqInt temp1;
    sqInt wordAddr;

	if (swapBytes) {
		/* begin reverseBytesInImage */
		addr = GIV(oldSpaceStart);
		while (oopisLessThan(addr, GIV(endOfMemory))) {
			longAtput(addr, byteSwapped(longAt(addr)));
			addr += BytesPerWord;
		}
		/* begin updateObjectsPostByteSwap */
		swapFloatWords = VMBIGENDIAN != GIV(imageFloatsBigEndian);
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		
		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj = (prevObj = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		/* begin objectStartingAt: */
		address = ((pastSpace()).start);
		numSlots = byteAt(address + 7);
		objOop1 = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		limit = GIV(pastSpaceStart);
		while (oopisLessThan(objOop1, limit)) {
			assert(isEnumerableObjectNoAssert(objOop1));
			fmt = (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask());
			if (fmt >= (firstByteFormat())) {

				/* oop contains bytes */
				wordAddr = objOop1 + BaseHeaderSize;
				if (fmt >= (firstCompiledMethodFormat())) {

					/* compiled method; start after methodHeader and literals */
					methodHeader = longAt(objOop1 + BaseHeaderSize);
					wordAddr += ((literalCountOfMethodHeader(methodHeader)) + LiteralStart) * BytesPerOop;
				}
				/* begin reverseBytesFrom:to: */
				stopAddr = objOop1 + ((((long)(numSlotsOf(objOop1))) << (shiftForWord())) + BaseHeaderSize);
				addr1 = wordAddr;
				while (oopisLessThan(addr1, stopAddr)) {
					longAtput(addr1, byteSwapped(longAt(addr1)));
					addr1 += BytesPerWord;
				}
			}
			if (fmt == (firstLongFormat())) {

				/* Bitmap, Float etc */
				if (swapFloatWords
				 && (((longAt(objOop1)) & (classIndexMask())) == ClassFloatCompactIndex)) {
					temp1 = longAt(objOop1 + BaseHeaderSize);
					longAtput(objOop1 + BaseHeaderSize, longAt((objOop1 + BaseHeaderSize) + 4));
					longAtput((objOop1 + BaseHeaderSize) + 4, temp1);
				}
				else {
									}
			}


			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			numSlots11 = byteAt(objOop1 + 7);
			numSlots2 = (numSlots11 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots11);
			if (numSlots2 == 0) {
				slotBytes = 8;
			}
			else {
				slotBytes = ((long)numSlots2) << (shiftForWord());
			}
			followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
			if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
				objOop1 = limit;
				goto l3;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
		l3:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address1 = ((eden()).start);
		numSlots1 = byteAt(address1 + 7);
		objOop1 = (numSlots1 == (numSlotsMask())
			? address1 + BaseHeaderSize
			: address1);
		while (oopisLessThan(objOop1, GIV(freeStart))) {
			assert(isEnumerableObjectNoAssert(objOop1));
			fmt = (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask());
			if (fmt >= (firstByteFormat())) {

				/* oop contains bytes */
				wordAddr = objOop1 + BaseHeaderSize;
				if (fmt >= (firstCompiledMethodFormat())) {

					/* compiled method; start after methodHeader and literals */
					methodHeader = longAt(objOop1 + BaseHeaderSize);
					wordAddr += ((literalCountOfMethodHeader(methodHeader)) + LiteralStart) * BytesPerOop;
				}
				/* begin reverseBytesFrom:to: */
				stopAddr = objOop1 + ((((long)(numSlotsOf(objOop1))) << (shiftForWord())) + BaseHeaderSize);
				addr1 = wordAddr;
				while (oopisLessThan(addr1, stopAddr)) {
					longAtput(addr1, byteSwapped(longAt(addr1)));
					addr1 += BytesPerWord;
				}
			}
			if (fmt == (firstLongFormat())) {

				/* Bitmap, Float etc */
				if (swapFloatWords
				 && (((longAt(objOop1)) & (classIndexMask())) == ClassFloatCompactIndex)) {
					temp1 = longAt(objOop1 + BaseHeaderSize);
					longAtput(objOop1 + BaseHeaderSize, longAt((objOop1 + BaseHeaderSize) + 4));
					longAtput((objOop1 + BaseHeaderSize) + 4, temp1);
				}
				else {
									}
			}


			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			numSlots12 = byteAt(objOop1 + 7);
			numSlots3 = (numSlots12 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots12);
			if (numSlots3 == 0) {
				slotBytes1 = 8;
			}
			else {
				slotBytes1 = ((long)numSlots3) << (shiftForWord());
			}
			followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
				objOop1 = GIV(freeStart);
				goto l2;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		l2:	/* end objectAfter:limit: */;
		}
		/* begin allOldSpaceObjectsDo: */
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj2 = (prevObj2 = null);
		objOop12 = GIV(nilObj);
		while (1) {
			assert((objOop12 % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop12, GIV(endOfMemory)))) break;
			assert((long64At(objOop12)) != 0);
			if (isEnumerableObject(objOop12)) {
				fmt = (((usqInt) (longAt(objOop12))) >> (formatShift())) & (formatMask());
				if (fmt >= (firstByteFormat())) {

					/* oop contains bytes */
					wordAddr = objOop12 + BaseHeaderSize;
					if (fmt >= (firstCompiledMethodFormat())) {

						/* compiled method; start after methodHeader and literals */
						methodHeader = longAt(objOop12 + BaseHeaderSize);
						wordAddr += ((literalCountOfMethodHeader(methodHeader)) + LiteralStart) * BytesPerOop;
					}
					/* begin reverseBytesFrom:to: */
					stopAddr = objOop12 + ((((long)(numSlotsOf(objOop12))) << (shiftForWord())) + BaseHeaderSize);
					addr1 = wordAddr;
					while (oopisLessThan(addr1, stopAddr)) {
						longAtput(addr1, byteSwapped(longAt(addr1)));
						addr1 += BytesPerWord;
					}
				}
				if (fmt == (firstLongFormat())) {

					/* Bitmap, Float etc */
					if (swapFloatWords
					 && (((longAt(objOop12)) & (classIndexMask())) == ClassFloatCompactIndex)) {
						temp1 = longAt(objOop12 + BaseHeaderSize);
						longAtput(objOop12 + BaseHeaderSize, longAt((objOop12 + BaseHeaderSize) + 4));
						longAtput((objOop12 + BaseHeaderSize) + 4, temp1);
					}
					else {
											}
				}

			}

			prevPrevObj2 = prevObj2;
			prevObj2 = objOop12;
			/* begin objectAfter:limit: */
			numSlots14 = byteAt(objOop12 + 7);
			numSlots5 = (numSlots14 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop12 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots14);
			if (numSlots5 == 0) {
				slotBytes3 = 8;
			}
			else {
				slotBytes3 = ((long)numSlots5) << (shiftForWord());
			}
			followingWordAddress3 = (objOop12 + BaseHeaderSize) + slotBytes3;
			if (oopisGreaterThanOrEqualTo(followingWordAddress3, GIV(endOfMemory))) {
				objOop12 = GIV(endOfMemory);
				goto l6;
			}
			flag("endianness");
			followingWord3 = longAt(followingWordAddress3);
			objOop12 = ((((usqInt) followingWord3) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress3 + BaseHeaderSize
				: followingWordAddress3);
		l6:	/* end objectAfter:limit: */;
		}
			}
	else {
		/* begin convertFloatsToPlatformOrder */
		if (VMBIGENDIAN == GIV(imageFloatsBigEndian)) {
			goto l1;
		}
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		
		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj1 = (prevObj1 = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		/* begin objectStartingAt: */
		address2 = ((pastSpace()).start);
		numSlots4 = byteAt(address2 + 7);
		objOop11 = (numSlots4 == (numSlotsMask())
			? address2 + BaseHeaderSize
			: address2);
		limit1 = GIV(pastSpaceStart);
		while (oopisLessThan(objOop11, limit1)) {
			assert(isEnumerableObjectNoAssert(objOop11));
			if (((longAt(objOop11)) & (classIndexMask())) == ClassFloatCompactIndex) {
				temp = long32At(objOop11 + BaseHeaderSize);
				long32Atput(objOop11 + BaseHeaderSize, long32At((objOop11 + BaseHeaderSize) + 4));
				long32Atput((objOop11 + BaseHeaderSize) + 4, temp);
			}


			prevPrevObj1 = prevObj1;
			prevObj1 = objOop11;
			/* begin objectAfter:limit: */
			numSlots111 = byteAt(objOop11 + 7);
			numSlots21 = (numSlots111 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots111);
			if (numSlots21 == 0) {
				slotBytes2 = 8;
			}
			else {
				slotBytes2 = ((long)numSlots21) << (shiftForWord());
			}
			followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
			if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit1)) {
				objOop11 = limit1;
				goto l4;
			}
			flag("endianness");
			followingWord2 = longAt(followingWordAddress2);
			objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress2 + BaseHeaderSize
				: followingWordAddress2);
		l4:	/* end objectAfter:limit: */;
		}
		/* begin objectStartingAt: */
		address11 = ((eden()).start);
		numSlots13 = byteAt(address11 + 7);
		objOop11 = (numSlots13 == (numSlotsMask())
			? address11 + BaseHeaderSize
			: address11);
		while (oopisLessThan(objOop11, GIV(freeStart))) {
			assert(isEnumerableObjectNoAssert(objOop11));
			if (((longAt(objOop11)) & (classIndexMask())) == ClassFloatCompactIndex) {
				temp = long32At(objOop11 + BaseHeaderSize);
				long32Atput(objOop11 + BaseHeaderSize, long32At((objOop11 + BaseHeaderSize) + 4));
				long32Atput((objOop11 + BaseHeaderSize) + 4, temp);
			}


			prevPrevObj1 = prevObj1;
			prevObj1 = objOop11;
			/* begin objectAfter:limit: */
			numSlots121 = byteAt(objOop11 + 7);
			numSlots31 = (numSlots121 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots121);
			if (numSlots31 == 0) {
				slotBytes11 = 8;
			}
			else {
				slotBytes11 = ((long)numSlots31) << (shiftForWord());
			}
			followingWordAddress11 = (objOop11 + BaseHeaderSize) + slotBytes11;
			if (oopisGreaterThanOrEqualTo(followingWordAddress11, GIV(freeStart))) {
				objOop11 = GIV(freeStart);
				goto l5;
			}
			flag("endianness");
			followingWord11 = longAt(followingWordAddress11);
			objOop11 = ((((usqInt) followingWord11) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress11 + BaseHeaderSize
				: followingWordAddress11);
		l5:	/* end objectAfter:limit: */;
		}
		/* begin allOldSpaceObjectsDo: */
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj3 = (prevObj3 = null);
		objOop13 = GIV(nilObj);
		while (1) {
			assert((objOop13 % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop13, GIV(endOfMemory)))) break;
			assert((long64At(objOop13)) != 0);
			if (isEnumerableObject(objOop13)) {
				if (((longAt(objOop13)) & (classIndexMask())) == ClassFloatCompactIndex) {
					temp = long32At(objOop13 + BaseHeaderSize);
					long32Atput(objOop13 + BaseHeaderSize, long32At((objOop13 + BaseHeaderSize) + 4));
					long32Atput((objOop13 + BaseHeaderSize) + 4, temp);
				}

			}

			prevPrevObj3 = prevObj3;
			prevObj3 = objOop13;
			/* begin objectAfter:limit: */
			numSlots15 = byteAt(objOop13 + 7);
			numSlots6 = (numSlots15 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(objOop13 - BaseHeaderSize))) << 8)))) >> 8
				: numSlots15);
			if (numSlots6 == 0) {
				slotBytes4 = 8;
			}
			else {
				slotBytes4 = ((long)numSlots6) << (shiftForWord());
			}
			followingWordAddress4 = (objOop13 + BaseHeaderSize) + slotBytes4;
			if (oopisGreaterThanOrEqualTo(followingWordAddress4, GIV(endOfMemory))) {
				objOop13 = GIV(endOfMemory);
				goto l7;
			}
			flag("endianness");
			followingWord4 = longAt(followingWordAddress4);
			objOop13 = ((((usqInt) followingWord4) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress4 + BaseHeaderSize
				: followingWordAddress4);
		l7:	/* end objectAfter:limit: */;
		}
	l1:	/* end convertFloatsToPlatformOrder */;
	}
}


/*	Divorce a single frame and its context. If it is not the top frame of a
	stack this means splitting its stack. */

	/* StackInterpreter>>#externalDivorceFrame:andContext: */
static void NoDbgRegParms
externalDivorceFrameandContext(char *theFP, sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerCtx;
    char *callerFP;
    char *callerFP1;
    sqInt callerIP;
    char *callerSP;
    char *frameAbove;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt onCurrent;
    sqInt theIP;
    StackPage *thePage;
    char *theSP;
    char *theSP1;
    sqInt valuePointer;


	/* stackPage needs to have current head pointers to avoid confusion. */
	assert((GIV(stackPage) == 0)
	 || (GIV(stackPage) == (mostRecentlyUsedPage())));
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((onCurrent = thePage == GIV(stackPage)))) {
		markStackPageNextMostRecentlyUsed(thePage);
	}
	theSP = findSPOfon(theFP, thePage);
	updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		callerCtx = longAt(theFP + FoxCallerContext);
		goto l2;
	}
	/* begin ensureFrameIsMarried:SP: */
	assert(!(isBaseFrame(theFP)));
	theSP1 = (theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
	if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP1)));
		callerCtx = longAt(callerFP1 + FoxThisContext);
		goto l3;
	}
	callerCtx = marryFrameSP(callerFP1, theSP1);
l3:	/* end ensureFrameIsMarried:SP: */;
l2:	/* end ensureCallerContext: */;
	if (((frameAbove = findFrameAboveinPage(theFP, thePage))) == 0) {

		/* If we're divorcing the top frame we can simply peel it off. */
		theIP = longAt((thePage->headSP));
	}
	else {

		/* othewise move all frames above to a new stack and then peel the frame off. */
		/* begin newStackPage */
		lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
		if (((lruOrFree->baseFP)) == 0) {
			newPage = lruOrFree;
			goto l1;
		}
		divorceFramesIn(lruOrFree);
		newPage = lruOrFree;
	l1:	/* end newStackPage */;
		theIP = oopForPointer(pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
		frameAbove = moveFramesInthroughtoPage(thePage, frameAbove, newPage);
		if (onCurrent) {
			/* begin setStackPageAndLimit: */
			assert(newPage != 0);
			GIV(stackPage) = newPage;
			if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
				GIV(stackLimit) = (GIV(stackPage)->stackLimit);
			}
			markStackPageMostRecentlyUsed(newPage);
			GIV(framePointer) = (GIV(stackPage)->headFP);
			GIV(stackPointer) = (GIV(stackPage)->headSP);
		}
		else {
			markStackPageMostRecentlyUsed(newPage);
		}
		assert((frameCallerContext(frameAbove)) == ctxt);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(validInstructionPointerinFrame(theIP + 1, theFP));
	valuePointer = (((((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1);
	assert(!(isForwarded(ctxt)));
	longAtput((ctxt + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(ctxt)));
	if (isOldObject(ctxt)) {

		/* most stores into young objects */
		if (((callerCtx & (tagMask())) == 0)
		 && (oopisLessThan(callerCtx, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(ctxt))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(ctxt);
			}
		}
	}
	longAtput((ctxt + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), callerCtx);
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* theFP is a base frame; it is now alone; free the entire page */
		freeStackPage(thePage);
	}
	else {
		callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
		callerSP = (frameCallerSP(theFP)) - BytesPerWord;
		longAtput(callerSP, callerIP);
		/* begin setHeadFP:andSP:inPage: */
		assert(callerSP < callerFP);
		assert((callerSP < ((thePage->baseAddress)))
		 && (callerSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((callerFP < ((thePage->baseAddress)))
		 && (callerFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(thePage->headFP = callerFP);
		(thePage->headSP = callerSP);
	}
}


/*	Ensure aFramePtr is a base frame. Then we can assign its sender.
	Answer the possibly moved location of the frame. */

	/* StackInterpreter>>#externalEnsureIsBaseFrame: */
static char * NoDbgRegParms
externalEnsureIsBaseFrame(char *aFramePtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt onCurrent;
    char *theFP;
    StackPage *thePage;

	if ((longAt(aFramePtr + FoxSavedFP)) == 0) {
		return aFramePtr;
	}
	theFP = aFramePtr;
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));

	/* Storing the frame's sender with its caller's context
	   has the side effect of making theFP a base frame. */
	onCurrent = thePage == GIV(stackPage);
	theFP = storeSenderOfFramewithValue(theFP, ensureCallerContext(theFP));
	if (onCurrent) {
		assert(GIV(stackPage) != thePage);
		GIV(framePointer) = (GIV(stackPage)->headFP);
		GIV(stackPointer) = (GIV(stackPage)->headSP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	return theFP;
}


/*	Fetch an instance variable from a maybe married context.
	If the context is still married compute the value of the
	relevant inst var from the spouse frame's state. */

	/* StackInterpreter>>#externalInstVar:ofContext: */
static sqInt NoDbgRegParms
externalInstVarofContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isContext(aContext));
	if (!((offset <= StackPointerIndex)
		 && (((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)))) {
		return longAt((aContext + BaseHeaderSize) + (((long)offset) << (shiftForWord())));
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	return ((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(aContext)))
		? fetchPointerofMarriedContext(offset, aContext)
		: longAt((aContext + BaseHeaderSize) + (((long)offset) << (shiftForWord()))));
}

	/* StackInterpreter>>#externalInstVar:ofContext:put: */
static sqInt NoDbgRegParms
externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index1;
    sqInt onCurrentPage;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	assert(isContext(maybeMarriedContext));
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(!((isObjImmutable(maybeMarriedContext))));
	if (!((((((longAt((maybeMarriedContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(maybeMarriedContext))))) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(maybeMarriedContext)));
		if (isOldObject(maybeMarriedContext)) {

			/* most stores into young objects */
			if (((anOop & (tagMask())) == 0)
			 && (oopisLessThan(anOop, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(maybeMarriedContext))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(maybeMarriedContext);
				}
			}
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((long)index) << (shiftForWord())), anOop);
		if (index == StackPointerIndex) {
		}
		return null;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((maybeMarriedContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFP = pointerForOop(senderOop - 1);
	/* begin stackPageFor: */
	index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index1, GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (index == SenderIndex) {
		storeSenderOfFramewithValue(theFP, anOop);
	}
	else {
		externalDivorceFrameandContext(theFP, maybeMarriedContext);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(maybeMarriedContext)));
		if (isOldObject(maybeMarriedContext)) {

			/* most stores into young objects */
			if (((anOop & (tagMask())) == 0)
			 && (oopisLessThan(anOop, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(maybeMarriedContext))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(maybeMarriedContext);
				}
			}
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((long)index) << (shiftForWord())), anOop);
		if (index == StackPointerIndex) {
		}
	}
	if (onCurrentPage) {
		GIV(framePointer) = (GIV(stackPage)->headFP);
		GIV(stackPointer) = (GIV(stackPage)->headSP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(pageListIsWellFormed());
	assert(validStackPageBaseFrames());
}


/*	Invoke a quick primitive.
	Called under the assumption that primFunctionPtr has been preloaded */

	/* StackInterpreter>>#externalQuickPrimitiveResponse */
static sqInt
externalQuickPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt localPrimIndex;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;

	assert(isPrimitiveFunctionPointerAnIndex());
	localPrimIndex = ((sqInt) primitiveFunctionPointer);
	assert((localPrimIndex > 0xFF)
	 && (localPrimIndex < 520));
	if (localPrimIndex >= 264) {
		/* begin pop:thenPush: */
		oop = longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((long)(localPrimIndex - 264)) << (shiftForWord())));
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 256) {
		return 1;
	}
	if (localPrimIndex == 257) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return 1;
	}
	if (localPrimIndex == 258) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp2;
		return 1;
	}
	if (localPrimIndex == 259) {
		/* begin pop:thenPush: */
		longAtput((sp3 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp3;
		return 1;
	}
	/* begin pop:thenPush: */
	longAtput((sp4 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((localPrimIndex - 261) << 3) | 1));
	GIV(stackPointer) = sp4;
	return 1;
}


/*	not inlined for breakpoint value... */

	/* StackInterpreter>>#failUnbalancedPrimitive */
static void
failUnbalancedPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the address of first indexable field of resulting array object, or fail if
	the instance variable does not contain an indexable bytes or words object.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchArray:ofObject: */
void *
fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOop;

	arrayOop = longAt((objectPointer + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	/* begin arrayValueOf: */
	if (((arrayOop & (tagMask())) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(arrayOop))) >> (formatShift())) & (formatMask())))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return null;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchFloat:ofObject: */
double
fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt floatOop;

	floatOop = longAt((objectPointer + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	return floatValueOf(floatOop);
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchInteger:ofObject: */
sqInt
fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt intOop;

	intOop = longAt((objectPointer + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	/* begin checkedIntegerValueOf: */
	if ((((intOop) & 7) == 1)) {
		return (intOop >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Fetch a slot from a married context. Compute the value
	of the relevant inst var from the spouse frame's state.
	
	This method assumes frame pointers have been written back. */

	/* StackInterpreter>>#fetchPointer:ofMarriedContext: */
static sqInt NoDbgRegParms
fetchPointerofMarriedContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt frameNumArgs;
    sqInt senderOop;
    sqInt senderOop1;
    char *spouseFP;
    char *theSP;

	assert(isContext(aContext));
	assert((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer)));
	assert(checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer)));
	if (offset <= ReceiverIndex) {
		if (!(offset <= StackPointerIndex)) {
			return longAt((aContext + BaseHeaderSize) + (((long)offset) << (shiftForWord())));
		}
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		spouseFP = pointerForOop(senderOop - 1);
		if (offset == SenderIndex) {
			/* begin ensureCallerContext: */
			callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
			if (callerFP == 0) {

				/* base frame, context in saved ip slot (or base of stack in Cog) */
				return longAt(spouseFP + FoxCallerContext);
			}
			/* begin ensureFrameIsMarried:SP: */
			assert(!(isBaseFrame(spouseFP)));
			theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((spouseFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
			if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
				assert(isContext(frameContext(callerFP)));
				return longAt(callerFP + FoxThisContext);
			}
			return marryFrameSP(callerFP, theSP);
		}
		if (offset == StackPointerIndex) {
			return (((stackPointerIndexForFrame(spouseFP)) << 3) | 1);
		}
		if (offset == InstructionPointerIndex) {
			return instructionPointerForFramecurrentFPcurrentIP(spouseFP, GIV(framePointer), GIV(instructionPointer));
		}
	}
	/* begin frameOfMarriedContext: */
	senderOop1 = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop1) & 7) == 1));
	spouseFP = pointerForOop(senderOop1 - 1);
	return ((((offset - ReceiverIndex) >= 1) && ((offset - ReceiverIndex) <= (stackPointerIndexForFrame(spouseFP))))
		? ((offset - (ReceiverIndex + 1)) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
				? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord))
				: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord)))
		: GIV(nilObj));
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

	/* StackInterpreter>>#fetchStackPointerOf: */
static sqInt NoDbgRegParms
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = longAt((aContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
	if (!((((sp) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext)));
	return (sp >> 3);
}


/*	This is used to implement implicit receiver and enclosing object lookup
	for Newspeak. Find the mixin applcation of which aClass is a subclass that
	is an application of targetMixin. This is an implementation derived from
	
	<ContextPart> findApplicationOf: targetMixin startingAt: aBehavior
	 */

	/* StackInterpreter>>#findApplicationOfTargetMixin:startingAtBehavior: */
static sqInt NoDbgRegParms
findApplicationOfTargetMixinstartingAtBehavior(sqInt targetMixin, sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mixin;
    sqInt mixinApplication;
    sqInt objOop;

	mixinApplication = aBehavior;
	while (!((mixinApplication == GIV(nilObj))
	 || ((mixinApplication == targetMixin)
	 || (((mixin = followObjFieldofObject(MixinIndex, mixinApplication))) == targetMixin)))) {
		/* begin followObjField:ofObject: */
		objOop = longAt((mixinApplication + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop));
		if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, mixinApplication, objOop);
		}
		mixinApplication = objOop;
	}
	if (mixinApplication == GIV(nilObj)) {
		print("looking for ");
		/* begin cr */
		printf("\n");
		longPrintOop(targetMixin);
		/* begin cr */
		printf("\n");
		print(" in behavior ");
		/* begin cr */
		printf("\n");
		longPrintOop(aBehavior);
		/* begin cr */
		printf("\n");
	}
	return mixinApplication;
}

	/* StackInterpreter>>#findClassContainingMethod:startingAt: */
static sqInt NoDbgRegParms
findClassContainingMethodstartingAt(sqInt meth, sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt currClass;
    sqInt i;
    sqInt methodArray;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt referent3;

	if (((classObj & (tagMask())) == 0)
	 && (((longAt(classObj)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(classObj));
		referent = longAt((classObj + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		currClass = referent;
	}
	else {
		currClass = classObj;
	}
	do {
		assert(!(isForwarded(currClass)));
		if (!(addressCouldBeClassObj(currClass))) {
			return GIV(nilObj);
		}
		/* begin noFixupFollowField:ofObject: */
		objOop1 = longAt((currClass + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
		if (((objOop1 & (tagMask())) == 0)
		 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(objOop1));
			referent1 = longAt((objOop1 + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent1 & (tagMask())) == 0)
			 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			objOop1 = referent1;
		}
		classDict = objOop1;
		assert(!(isForwarded(classDict)));
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(classDict + 7);
		classDictSize = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(classDict - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);
		if (classDictSize > MethodArrayIndex) {
			/* begin noFixupFollowField:ofObject: */
			objOop = longAt((classDict + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
			if (((objOop & (tagMask())) == 0)
			 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(objOop));
				referent2 = longAt((objOop + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent2 & (tagMask())) == 0)
				 && (((longAt(referent2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent2 = longAt((referent2 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				objOop = referent2;
			}
			methodArray = objOop;
			assert(!(isForwarded(methodArray)));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (noFixupFollowFieldofObject(i, methodArray))) {
					return currClass;
				}
				i += 1;
			}
		}
		/* begin noFixupFollowField:ofObject: */
		objOop2 = longAt((currClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop2 & (tagMask())) == 0)
		 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(objOop2));
			referent3 = longAt((objOop2 + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent3 & (tagMask())) == 0)
			 && (((longAt(referent3)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent3 = longAt((referent3 + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			objOop2 = referent3;
		}
		currClass = objOop2;
	} while(!(currClass == GIV(nilObj)));
	return currClass;
}

	/* StackInterpreter>>#findClassOfMethod:forReceiver: */
sqInt
findClassOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rclass;
    sqInt tagBits;

	if ((((rcvr & (tagMask())) != 0)
	 || (addressCouldBeObj(rcvr)))
	 && (!(((rcvr & (tagMask())) == 0)
 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))))) {
		rclass = findClassContainingMethodstartingAt(meth, (((tagBits = rcvr & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
			: fetchClassOfNonImm(rcvr)));
		if (rclass != GIV(nilObj)) {
			return rclass;
		}
	}
	if (!((addressCouldBeObj(meth))
		 && (((((usqInt) (longAt(meth))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return GIV(nilObj);
	}
	return findClassContainingMethodstartingAt(meth, safeMethodClassOf(meth));
}


/*	Answer the frame above theFP (adjacent frame nearest head end).
	If theFP is the head frame answer 0. */

	/* StackInterpreter>>#findFrameAbove:inPage: */
static char * NoDbgRegParms
findFrameAboveinPage(char *theFP, StackPage *thePage)
{
    char *callerFP;
    char *fp;

	fp = (thePage->headFP);
	if (fp == theFP) {
		return 0;
	}
	while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
		if (callerFP == theFP) {
			return fp;
		}
		fp = callerFP;
	}
	error("did not find theFP in stack page");
	return 0;
}

	/* StackInterpreter>>#findHomeForContext: */
static sqInt NoDbgRegParms
findHomeForContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;
    sqInt tagBits;

	if (!(((aContext & (tagMask())) == 0)
		 && (((longAt(aContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return null;
	}
	closureOrNil = longAt((aContext + BaseHeaderSize) + (((long)ClosureIndex) << (shiftForWord())));
	if (closureOrNil == GIV(nilObj)) {
		return aContext;
	}
	if (((((tagBits = closureOrNil & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(closureOrNil))) != (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassBlockClosure) << (shiftForWord()))))) {
		return null;
	}
	return findHomeForContext(longAt((closureOrNil + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord()))));
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromFP:SP:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */
/*	Being mutually-recursive with findMethodWithPrimitive:FromFP:UpToContext:
	gives the author's type inference algorithm headaches. Wimp out by
	declaring the return type.
 */

	/* StackInterpreter>>#findMethodWithPrimitive:FromContext:UpToContext: */
static sqInt NoDbgRegParms
findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt senderContext1;
    sqInt senderOop;
    char *startFP;
    sqInt theContext;
    char *theFP;
    char *theFPAbove;
    sqInt theMethod;
    sqInt theMethod1;
    char *theSP;

	assert((senderContext == (nilObject()))
	 || (isContext(senderContext)));
	assert((homeContext == (nilObject()))
	 || (isContext(homeContext)));
	theContext = senderContext;
	while (1) {
		if (theContext == GIV(nilObj)) {
			return theContext;
		}
		if (((((longAt((theContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) break;
		if (theContext == homeContext) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((longAt((theContext + BaseHeaderSize) + (((long)ClosureIndex) << (shiftForWord())))) != GIV(nilObj)))) {
			theMethod = longAt((theContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
			if ((primitiveIndexOfMethodheader(theMethod, methodHeaderOf(theMethod))) == primitive) {
				return theContext;
			}
		}
		theContext = longAt((theContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	}
	if (isWidowedContext(theContext)) {
		return GIV(nilObj);
	}
	/* begin findMethodWithPrimitive:FromFP:UpToContext: */
	senderOop = longAt((theContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	startFP = pointerForOop(senderOop - 1);
	theFP = startFP;
	theFPAbove = startFP;
	do {
		if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
		 && (homeContext == (longAt(theFP + FoxThisContext)))) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((byteAt((theFP + FoxFrameFlags) + 3)) != 0))) {
			theMethod1 = longAt(theFP + FoxMethod);
			if ((primitiveIndexOfMethodheader(theMethod1, methodHeaderOf(theMethod1))) == primitive) {
				if (theFP == theFPAbove) {
					theSP = findSPOfon(theFP, stackPageFor(theFP));
				}
				else {
					/* begin frameCallerStackPointer: */
					assert(!(isBaseFrame(theFPAbove)));
					theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(theFP)));
					return longAt(theFP + FoxThisContext);
				}
				return marryFrameSP(theFP, theSP);
			}
		}
		theFPAbove = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	} while(theFP != 0);
	senderContext1 = longAt(theFPAbove + FoxCallerContext);
	if (!(((senderContext1 & (tagMask())) == 0)
		 && (((longAt(senderContext1)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromContextUpToContext(primitive, senderContext1, homeContext);
}


/*	Find the compiled method to be run when the current 
	messageSelector is sent to the given class, setting the values 
	of 'newMethod' and 'primitiveIndex'. */

	/* StackInterpreter>>#findNewMethodInClassTag: */
static sqInt NoDbgRegParms
findNewMethodInClassTag(sqInt classTagArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt classTag;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt ok;

	ok = lookupInMethodCacheSelclassTag(GIV(messageSelector), classTagArg);
	if (!ok) {

		/* entry was not found in the cache; look it up the hard way */
		classTag = classTagArg;
		if ((((GIV(messageSelector) & (tagMask())) == 0)
		 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
		 || (classTag == (isForwardedObjectClassIndexPun()))) {
			if (((GIV(messageSelector) & (tagMask())) == 0)
			 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
			}
			if (classTag == (isForwardedObjectClassIndexPun())) {
				classTag = handleForwardedSendFaultForTag(classTag);
			}
			ok = lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag);
			if (ok) {
				return null;
			}
		}
		/* begin classAtIndex: */
		assert((classTag <= (tagMask()))
		 || (classTag >= (arrayClassIndexPun())));
		/* begin fetchPointer:ofObject: */
		fieldIndex = ((usqInt) classTag) >> (classTableMajorIndexShift());
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
		if (classTablePage == GIV(nilObj)) {
			GIV(lkupClass) = null;
			goto l1;
		}
		/* begin fetchPointer:ofObject: */
		fieldIndex1 = classTag & ((1LL << (classTableMajorIndexShift())) - 1);
		GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((long)fieldIndex1) << (shiftForWord())));
	l1:	/* end classAtIndex: */;
		lookupOrdinarySend();

		addNewMethodToCache(GIV(lkupClass));
	}
}

	/* StackInterpreter>>#findSelectorOfMethod: */
sqInt
findSelectorOfMethod(sqInt methArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt classObj;
    sqInt i;
    sqInt meth;
    sqInt methodArray;
    usqInt numSlots;
    sqInt referent;
    sqInt selector;

	if (!(addressCouldBeObj(methArg))) {
		return GIV(nilObj);
	}
	if (((longAt(methArg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(methArg));
		referent = longAt((methArg + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		meth = referent;
	}
	else {
		meth = methArg;
	}
	if (!(((meth & (tagMask())) == 0)
		 && (((((usqInt) (longAt(meth))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return GIV(nilObj);
	}
	selector = maybeSelectorOfMethod(meth);
	if (!(selector == null)) {
		return selector;
	}

	classObj = safeMethodClassOf(meth);
	if (addressCouldBeClassObj(classObj)) {
		classDict = longAt((classObj + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(classDict + 7);
		classDictSize = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(classDict - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);
		if (classDictSize > MethodArrayIndex) {
			methodArray = longAt((classDict + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (longAt((methodArray + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
					return longAt((classDict + BaseHeaderSize) + (((long)(i + SelectorStart)) << (shiftForWord())));
				}
				i += 1;
			}
		}
	}
	return GIV(nilObj);
}


/*	Search for the stack pointer for theFP. This points to the hottest item on
	the frame's stack.
	DO NOT CALL THIS WITH theFP == localFP OR theFP == framePointer! */

	/* StackInterpreter>>#findSPOf:on: */
static char * NoDbgRegParms
findSPOfon(char *theFP, StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *prevFrame;
    char *startFrame;
    char *theSP;

	/* begin findSPOrNilOf:on:startingFrom: */
	startFrame = (thePage->headFP);
	assert(!(isFree(thePage)));
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {

			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = theFP + FoxReceiver;
			goto l1;
		}
		theSP = (thePage == GIV(stackPage)
			? (thePage->headSP)
			: ((thePage->headSP)) + BytesPerWord);
		goto l1;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			/* begin frameCallerSP: */
			assert(!(isBaseFrame(prevFrame)));
			theSP = (prevFrame + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((prevFrame + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
			goto l1;
		}
	}
	theSP = null;
l1:	/* end findSPOrNilOf:on:startingFrom: */;
	if (theSP != null) {
		return theSP;
	}
	error("did not find theFP in stack page");
	return 0;
}


/*	Like #stackFloatValue: but access method arguments left-to-right */

	/* StackInterpreter>>#floatArg: */
double
floatArg(sqInt index)
{
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	return floatValueOf(oop);
}


/*	methodObj is a CompiledMethod containing an external primitive. Flush the
	function address and session ID of the CM
 */

	/* StackInterpreter>>#flushExternalPrimitiveOf: */
static sqInt NoDbgRegParms
flushExternalPrimitiveOf(sqInt methodObj)
{
    sqInt lit;

	if (!((literalCountOfMethodHeader(methodHeaderOf(methodObj))) > 0)) {
		return null;
	}
	lit = longAt((methodObj + BaseHeaderSize) + (((long)(0 + LiteralStart)) << (shiftForWord())));
	if (!((((lit & (tagMask())) == 0)
		 && (((((usqInt) (longAt(lit))) >> (formatShift())) & (formatMask())) == 2))
		 && ((lengthOfformat(lit, (((usqInt) (longAt(lit))) >> (formatShift())) & (formatMask()))) == 4))) {
		return null;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + BaseHeaderSize) + (2LL << (shiftForWord())), ConstZero);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + BaseHeaderSize) + (3LL << (shiftForWord())), ConstZero);
}


/*	Flush the method cache. The method cache is flushed on every programming
	change and garbage collect.
 */

	/* StackInterpreter>>#flushMethodCache */
static void
flushMethodCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;

	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	for (i = 1; i <= NSMethodCacheSize; i += 1) {
		GIV(nsMethodCache)[i] = 0;
	}


	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	follow pointers in the current stack frame up to theSP. */

	/* StackInterpreter>>#followForwardedFrameContents:stackPointer: */
static void NoDbgRegParms
followForwardedFrameContentsstackPointer(char *theFP, char *theSP)
{
    sqInt oop;
    char *ptr;
    sqInt referent;
    char * toDoLimit1;
    char * toDoLimit2;

	for (ptr = theSP, toDoLimit1 = (theFP + FoxReceiver); ptr <= toDoLimit1; ptr += BytesPerWord) {
		oop = longAt(ptr);
		if (((oop & (tagMask())) == 0)
		 && (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
			longAtput(ptr, followForwarded(oop));
		}
	}
	for (ptr = ((theFP + FoxCallerSavedIP) + BytesPerWord), toDoLimit2 = (theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))); ptr <= toDoLimit2; ptr += BytesPerWord) {
		oop = longAt(ptr);
		if (((oop & (tagMask())) == 0)
		 && (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop));
			referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent & (tagMask())) == 0)
			 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			oop = referent;
			longAtput(ptr, oop);
		}
	}
	if ((byteAt((theFP + FoxFrameFlags) + 3)) != 0) {
		assert(oop == (longAt(theFP + (frameStackedReceiverOffset(theFP)))));
		followForwardedObjectFieldstoDepth(oop, 0);
	}
	assert(!(isForwarded(frameMethodObject(theFP))));
	if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
		assert(!(isForwarded(frameContext(theFP))));
	}
}


/*	Spur's become: is lazy, turning the becommed object into a forwarding
	object to the other.
	The read-barrier is minimised by arranging that forwarding pointers will
	fail a method cache
	probe, since notionally objects' internals are accessed only via sending
	messages to them,
	the exception is primitives that access the internals of the non-receiver
	argument(s). 
	To avoid a read barrier on bytecode, literal and inst var fetch and
	non-local return, we scan
	the receivers (including the stacked receiver for non-local return) and
	method references
	in the stack zone and follow any forwarded ones. This is of course way
	cheaper than
	scanning all of memory as in the old become. */

	/* StackInterpreter>>#followForwardingPointersInStackZone: */
static void NoDbgRegParms
followForwardingPointersInStackZone(sqInt theBecomeEffectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    char *callerFP;
    sqInt delta;
    sqInt i;
    sqInt newOop;
    sqInt oop;
    sqInt ptr;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt referent3;
    char *theFP;
    char *theIPPtr;
    StackPage *thePage;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (theBecomeEffectsFlags & BecameCompiledMethodFlag) {
		if (((longAt(GIV(method))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			theIPPtr = GIV(instructionPointer) - GIV(method);
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(method)));
			referent = longAt((GIV(method) + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent & (tagMask())) == 0)
			 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			GIV(method) = referent;
			GIV(instructionPointer) = GIV(method) + theIPPtr;
		}
		if (((GIV(newMethod) & (tagMask())) == 0)
		 && (((longAt(GIV(newMethod))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(newMethod)));
			referent1 = longAt((GIV(newMethod) + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent1 & (tagMask())) == 0)
			 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			GIV(newMethod) = referent1;
		}
	}
	assert(GIV(stackPage) != 0);
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage));

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			theIPPtr = (thePage == GIV(stackPage)
				? 0
				: (thePage->headSP));
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theIPPtr)));
				oop = longAt(theFP + FoxReceiver);
				if (((oop & (tagMask())) == 0)
				 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					longAtput(theFP + FoxReceiver, followForwarded(oop));
				}
				if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
				 && (((longAt(longAt(theFP + FoxThisContext))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
					longAtput(theFP + FoxThisContext, followForwarded(longAt(theFP + FoxThisContext)));
				}
				oop = longAt(theFP + FoxMethod);
				if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(oop));
					referent2 = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent2 & (tagMask())) == 0)
					 && (((longAt(referent2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent2 = longAt((referent2 + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					newOop = referent2;
					if (theIPPtr != 0) {
						assert((longAt(theIPPtr)) > (frameMethod(theFP)));
						delta = newOop - oop;
						longAtput(theIPPtr, (longAt(theIPPtr)) + delta);
					}
					longAtput(theFP + FoxMethod, (oop = newOop));
				}
				ptr = ((sqInt)(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))));
				oop = longAt(ptr);
				if (((oop & (tagMask())) == 0)
				 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					longAtput(ptr, followForwarded(oop));
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theIPPtr = ((sqInt)(theFP + FoxCallerSavedIP));
				theFP = callerFP;
			}
			assert(theFP == ((thePage->baseFP)));
			oop = longAt(theFP + FoxCallerContext);
			if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin frameCallerContext:put: */
				assert(isUnambiguouslyForwarder(oop));
				referent3 = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent3 & (tagMask())) == 0)
				 && (((longAt(referent3)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent3 = longAt((referent3 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				aValue = referent3;
				longAtput(theFP + FoxCallerContext, aValue);
			}
		}
	}
}


/*	Force an interrupt check ASAP.
	Must set the stack page's limit before stackLimit to avoid
	a race condition if this is called from an interrupt handler. */

	/* StackInterpreter>>#forceInterruptCheck */
sqInt
forceInterruptCheck(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*iccFunc)();
    StackPage *thePage;


	/* Do _not_ set stackLimit until the stack system has been initialized.
	   stackLimit is the initialization flag for the stack system. */
	if (GIV(stackLimit) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	if ((thePage != null)
	 && (thePage != 0)) {
		(thePage->stackLimit = ((char *) (((usqInt) -1))));
	}
	GIV(stackLimit) = ((char *) (((usqInt) -1)));
	sqLowLevelMFence();
	if (((iccFunc = interruptCheckChain)) != null) {
		iccFunc();
	}
	GIV(statForceInterruptCheck) += 1;
}


/*	Force an interrupt check ASAP. This version is the
	entry-point to forceInterruptCheck for the heartbeat
	timer to allow for repeatable debugging. */

	/* StackInterpreter>>#forceInterruptCheckFromHeartbeat */
void
forceInterruptCheckFromHeartbeat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!suppressHeartbeatFlag) {
		/* begin checkForLongRunningPrimitive */
		if (GIV(longRunningPrimitiveCheckSemaphore) == null) {
			goto l1;
		}
		if ((GIV(longRunningPrimitiveStartUsecs) > 0)
		 && ((GIV(longRunningPrimitiveCheckMethod) == GIV(newMethod))
		 && (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)))) {
			GIV(longRunningPrimitiveStopUsecs) = ioUTCMicroseconds();
			assert(GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs));
			goto l1;
		}
		if (GIV(longRunningPrimitiveStopUsecs) == 0) {
			GIV(longRunningPrimitiveCheckSequenceNumber) = GIV(statCheckForEvents);
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
			GIV(longRunningPrimitiveStartUsecs) = ioUTCMicroseconds();
			sqLowLevelMFence();
		}
	l1:	/* end checkForLongRunningPrimitive */;
		forceInterruptCheck();
	}
}

	/* StackInterpreter>>#frameCallerContext: */
static sqInt NoDbgRegParms
frameCallerContext(char *theFP)
{
	return longAt(theFP + FoxCallerContext);
}


/*	Answer the SP of the caller provided theFP is not a base frame.
	This points to the hottest item on the caller frame's stack. */

	/* StackInterpreter>>#frameCallerSP: */
static char * NoDbgRegParms
frameCallerSP(char *theFP)
{
	assert(!(isBaseFrame(theFP)));
	return (theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
}

	/* StackInterpreter>>#frameContext: */
static sqInt NoDbgRegParms
frameContext(char *theFP)
{
	return longAt(theFP + FoxThisContext);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* StackInterpreter>>#frameHasContext: */
static sqInt NoDbgRegParms
frameHasContext(char *theFP)
{
	return (byteAt((theFP + FoxFrameFlags) + 2)) != 0;
}


/*	<Integer> */

	/* StackInterpreter>>#frameIsBlockActivation: */
static sqInt NoDbgRegParms
frameIsBlockActivation(char *theFP)
{
	return (byteAt((theFP + FoxFrameFlags) + 3)) != 0;
}


/*	Homonym of frameMethod: for compatibility with CoInterpreter */

	/* StackInterpreter>>#frameMethodObject: */
static sqInt NoDbgRegParms
frameMethodObject(char *theFP)
{
	return longAt(theFP + FoxMethod);
}

	/* StackInterpreter>>#frameMethod: */
static sqInt NoDbgRegParms
frameMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* StackInterpreter>>#frameNumArgs: */
static sqInt NoDbgRegParms
frameNumArgs(char *theFP)
{
	return byteAt((theFP + FoxFrameFlags) + 1);
}

	/* StackInterpreter>>#frameOfMarriedContext: */
static char * NoDbgRegParms
frameOfMarriedContext(sqInt aContext)
{
    sqInt senderOop;

	senderOop = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	return pointerForOop(senderOop - 1);
}

	/* StackInterpreter>>#frameReceiver: */
static sqInt NoDbgRegParms
frameReceiver(char *theFP)
{
	return longAt(theFP + FoxReceiver);
}


/*	Answer the offset in bytes from the the frame pointer to its stacked
	receiver. The receiver of a message send or the closure of a block
	activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#frameStackedReceiverOffset: */
static sqInt NoDbgRegParms
frameStackedReceiverOffset(char *theFP)
{
	return (FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()));
}


/*	Free any untraced stack pages. */

	/* StackInterpreter>>#freeUntracedStackPages */
static void
freeUntracedStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if ((!(isFree(thePage)))
		 && (((thePage->trace)) == StackPageUnreached)) {
			assert(noMarkedContextsOnPage(thePage));
			freeStackPage(thePage);
		}
		assert(((thePage->trace = StackPageTraceInvalid)) != 0);
	}
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used
	in some platform's code when the Smalltalk window is brought to the front
	or uncovered.
 */

	/* StackInterpreter>>#fullDisplayUpdate */
sqInt
fullDisplayUpdate(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt displayObj;
    sqInt h;
    sqInt w;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheDisplay) << (shiftForWord())));
	if ((((displayObj & (tagMask())) == 0)
	 && (((((usqInt) (longAt(displayObj))) >> (formatShift())) & (formatMask())) <= 5))
	 && ((lengthOfformat(displayObj, (((usqInt) (longAt(displayObj))) >> (formatShift())) & (formatMask()))) >= 4)) {
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		displayBitsOfLeftTopRightBottom(displayObj, 0, 0, w, h);
		ioForceDisplayUpdate();
	}
	return null;
}


/*	Find an actual function pointer for this primitiveIndex. This is an
	opportunity to specialise the prim for the relevant class (format for
	example). Default for now is simply the entry in the base primitiveTable. */

	/* StackInterpreter>>#functionPointerFor:inClass: */
void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void)

{
	return (primIdx > MaxPrimitiveIndex
		? 0
		: primitiveTable[primIdx]);
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. 
 */

	/* StackInterpreter>>#getCurrentBytecode */
sqInt
getCurrentBytecode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return byteAt(GIV(instructionPointer));
}

	/* StackInterpreter>>#getFullScreenFlag */
sqInt
getFullScreenFlag(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(fullScreenFlag);
}

	/* StackInterpreter>>#getInterruptKeycode */
sqInt
getInterruptKeycode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptKeycode);
}

	/* StackInterpreter>>#getInterruptPending */
sqInt
getInterruptPending(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptPending);
}

	/* StackInterpreter>>#getNextWakeupUsecs */
usqLong
getNextWakeupUsecs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nextWakeupUsecs);
}

	/* StackInterpreter>>#getSavedWindowSize */
sqInt
getSavedWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(savedWindowSize);
}


/*	For Alien FFI */

	/* StackInterpreter>>#getStackPointer */
sqInt *
getStackPointer(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((sqInt *) GIV(stackPointer));
}


/*	return the global session ID value */

	/* StackInterpreter>>#getThisSessionID */
sqInt
getThisSessionID(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(globalSessionID);
}


/*	Answer the next 32 bit word read from aFile, byte-swapped according to the
	swapFlag. 
 */

	/* StackInterpreter>>#getWord32FromFile:swap: */
static sqInt NoDbgRegParms
getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    int w;

	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, aFile);
	return (swapFlag
		? byteSwapped(w)
		: w);
}


/*	Handle a send fault that is due to a send using a forwarded selector.
	Unforward the selector and follow the current method and special
	selectors array to unforward the source of the forwarded selector. */

	/* StackInterpreter>>#handleForwardedSelectorFaultFor: */
static sqInt NoDbgRegParms
handleForwardedSelectorFaultFor(sqInt selectorOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;

	assert(isOopForwarded(selectorOop));
	/* begin followForwardedFieldsInCurrentMethod */
	followForwardedObjectFieldstoDepth(GIV(method), 0);
	followForwardedObjectFieldstoDepth(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord()))), 0);
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(selectorOop));
	referent = longAt((selectorOop + BaseHeaderSize) + (0LL << (shiftForWord())));
	while (((referent & (tagMask())) == 0)
	 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
	}
	return referent;
}


/*	Handle a send fault that may be due to a send to a forwarded object.
	Unforward the receiver on the stack and answer its actual class. */

	/* StackInterpreter>>#handleForwardedSendFaultForTag: */
static sqInt NoDbgRegParms
handleForwardedSendFaultForTag(sqInt classTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt referent;
    sqInt tagBits;

	assert(isForwardedClassTag(classTag));

	/* should *not* be a super send, so the receiver should be forwarded. */
	rcvr = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	assert(isOopForwarded(rcvr));
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(rcvr));
	referent = longAt((rcvr + BaseHeaderSize) + (0LL << (shiftForWord())));
	while (((referent & (tagMask())) == 0)
	 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
	}
	rcvr = referent;
	longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((GIV(argumentCount) + 1) * BytesPerWord));
	if ((((longAt(GIV(framePointer) + FoxReceiver)) & (tagMask())) == 0)
	 && (((((usqInt) (longAt(longAt(GIV(framePointer) + FoxReceiver)))) >> (formatShift())) & (formatMask())) <= 5)) {
		followForwardedObjectFieldstoDepth(longAt(GIV(framePointer) + FoxReceiver), 0);
	}
	return (((tagBits = rcvr & (tagMask()))) != 0
		? tagBits
		: (longAt(rcvr)) & (classIndexMask()));
}


/*	Handle a special send fault that may be due to a special selector
	send accessing a forwarded object. obj is forwarded.
	Unforward stack contents and and inst vars and answer obj's target. */

	/* StackInterpreter>>#handleSpecialSelectorSendFaultFor:fp:sp: */
static sqInt NoDbgRegParms
handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP)
{
    sqInt rcvr;
    sqInt referent;

	assert(isOopForwarded(obj));
	followForwardedFrameContentsstackPointer(theFP, theSP);
	rcvr = longAt(theFP + FoxReceiver);
	if (((rcvr & (tagMask())) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= 5)) {
		followForwardedObjectFieldstoDepth(rcvr, 0);
	}
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(obj));
	referent = longAt((obj + BaseHeaderSize) + (0LL << (shiftForWord())));
	while (((referent & (tagMask())) == 0)
	 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
	}
	return referent;
}


/*	Check for stack overflow, moving frames to another stack if so. */

	/* StackInterpreter>>#handleStackOverflow */
static void
handleStackOverflow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *callerFP1;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt overflowCount;
    char *overflowLimitAddress;
    char *theFP;
    char *theSP;


	/* After checkForInterrupts another event check may have been forced, setting both
	   stackLimit and stackPage stackLimit to all ones.  So here we must check against
	   the real stackLimit, not the effective stackLimit. */
	if (!(GIV(stackPointer) < ((GIV(stackPage)->realStackLimit)))) {
		return;
	}

	/* The stack has overflowed this page.  If the system is executing some recursive algorithm,
	   e.g. fibonacci, then the system could thrash overflowing the stack if the call soon returns
	   back to the current page.  To avoid thrashing, since overflow is quite slow, we can move
	   more than one frame.  The idea is to record which page has overflowed, and the first
	   time it overflows move one frame, the second time two frames, and so on.  We move no
	   more frames than would leave the page half occupied. */
	GIV(statStackOverflow) += 1;
	theFP = GIV(framePointer);
	if (GIV(stackPage) == GIV(overflowedPage)) {
		overflowLimitAddress = ((GIV(stackPage)->baseAddress)) - GIV(overflowLimit);
		overflowCount = (GIV(extraFramesToMoveOnOverflow) += 1);
		while ((((overflowCount -= 1)) >= 0)
		 && ((((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) < overflowLimitAddress)
		 && (!((longAt(callerFP + FoxSavedFP)) == 0)))) {
			theFP = callerFP;
		}
	}
	else {
		GIV(overflowedPage) = GIV(stackPage);
		GIV(extraFramesToMoveOnOverflow) = 0;
	}
	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		longAt(theFP + FoxCallerContext);
		goto l1;
	}
	/* begin ensureFrameIsMarried:SP: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
	if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP1)));
		longAt(callerFP1 + FoxThisContext);
		goto l3;
	}
	marryFrameSP(callerFP1, theSP);
l3:	/* end ensureFrameIsMarried:SP: */;
l1:	/* end ensureCallerContext: */;
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		newPage = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
l2:	/* end newStackPage */;
	moveFramesInthroughtoPage(GIV(stackPage), theFP, newPage);
	/* begin setStackPageAndLimit: */
	assert(newPage != 0);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	
	/* To overflow the stack this must be a new frame, but in Cog base frames are married. */
	assert(!(frameHasContext(GIV(framePointer))));
	assert(validInstructionPointerinMethodframePointer(GIV(instructionPointer) + 1, GIV(method), GIV(framePointer)));

}


/*	The stackPointer is below the stackLimit. This is either because of a
	stack overflow or the setting of stackLimit to indicate a possible
	interrupt. Check for interrupts and stackOverflow and deal with each
	appropriately. Answer if a context switch occurred. */

	/* StackInterpreter>>#handleStackOverflowOrEventAllowContextSwitch: */
static sqInt NoDbgRegParms
handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt switched;


	/* If the stackLimit differs from the realStackLimit then the stackLimit
	   has been set to indicate an event or interrupt that needs servicing. */
	if (GIV(stackLimit) == ((GIV(stackPage)->realStackLimit))) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		switched = 0;
	}
	else {
		switched = checkForEventsMayContextSwitch(mayContextSwitch);
	}
	handleStackOverflow();
	return switched;
}


/*	A negative header selects the alternate bytecode set. */

	/* StackInterpreter>>#headerIndicatesAlternateBytecodeSet: */
sqInt
headerIndicatesAlternateBytecodeSet(sqInt methodHeader)
{
	return (((int) methodHeader)) < 0;
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize
	and e.g. stackPageByteSize. */

	/* StackInterpreter>>#highBit: */
sqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;


	/* so it shows up in senders... */
	shifted = anUnsignedValue;
	bitNo = 0;
	
#  if BytesPerWord > 4
	if (!(shifted < (1LL << 32))) {
		shifted = ((usqInt) shifted) >> 32;
		bitNo += 32;
	}

#  endif /* BytesPerWord > 4 */

	if (!(shifted < (1LL << 16))) {
		shifted = ((usqInt) shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (1LL << 8))) {
		shifted = ((usqInt) shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (1LL << 4))) {
		shifted = ((usqInt) shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (1LL << 2))) {
		shifted = ((usqInt) shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (1LL << 1))) {
		shifted = ((usqInt) shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	If thePage is the stackPage and the stackPointer and/or the framePointer
	are pointing within it,
	answer if thePage's heapSP and headFP are equal to the stackPointer and
	framePointer respectively.
 */

	/* StackInterpreter>>#ifCurrentStackPageHasValidHeadPointers: */
static sqInt NoDbgRegParms
ifCurrentStackPageHasValidHeadPointers(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (thePage == GIV(stackPage)) {
		if ((((thePage->lastAddress)) < GIV(framePointer))
		 && (GIV(framePointer) < ((thePage->baseAddress)))) {
			if (((thePage->headFP)) != GIV(framePointer)) {
				return 0;
			}
		}
		if ((((thePage->lastAddress)) < GIV(stackPointer))
		 && (GIV(stackPointer) < ((thePage->baseAddress)))) {
			if (((thePage->headSP)) != GIV(stackPointer)) {
				return 0;
			}
		}
	}
	return 1;
}

	/* StackInterpreter>>#iframeMethod: */
static usqInt NoDbgRegParms
iframeMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null.
	This is a noop in the stack VM since the C stack pointers are always
	elsewhere (e.g., in some C function running the interpreter). */

	/* StackInterpreter>>#ifValidWriteBackStack:Pointers:Save:To: */
void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP)
{
}


/*	Return a magic constant that changes when the image format changes.
	Since the image reading code uses this to detect byte ordering, one
	must avoid version numbers that are invariant under byte reversal. */

	/* StackInterpreter>>#imageFormatVersion */
static sqInt
imageFormatVersion(void)
{
    sqInt isSpurFlag;

	isSpurFlag = 16;
	return (68003) + isSpurFlag;
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

	/* StackInterpreter>>#includesBehavior:ThatOf: */
sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		/* begin followField:ofObject: */
		objOop = longAt((theClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop & (tagMask())) == 0)
		 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass, objOop);
		}
		theClass = objOop;
	}
	return 0;
}


/*	Like inlineLookupInMethodCacheSel:classTag:, but the cache is additionally
	key'd by the calling method and lookupRule/depth and additionally answers
	localAbsentReceiverOrZero. 
 */

	/* StackInterpreter>>#inlineLookupInNSMethodCacheSel:classTag:method:lookupRule: */
static sqInt NoDbgRegParms
inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(sqInt selector, sqInt classTag, sqInt callingMethod, sqInt lookupRule)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt probe;

	hash = (selector ^ classTag) ^ (callingMethod ^ lookupRule);

	/* first probe */
	probe = hash & NSMethodCacheMask;
	if (((((GIV(nsMethodCache)[probe + NSMethodCacheSelector]) == selector)
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheClassTag]) == classTag))
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheCallingMethod]) == callingMethod))
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheDepthOrLookupRule]) == lookupRule)) {
		GIV(newMethod) = GIV(nsMethodCache)[probe + NSMethodCacheTargetMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe + NSMethodCachePrimFunction]));
		GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe + NSMethodCacheActualReceiver];
		return 1;
	}

	/* second probe */
	probe = (((usqInt) hash) >> 1) & NSMethodCacheMask;
	if (((((GIV(nsMethodCache)[probe + NSMethodCacheSelector]) == selector)
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheClassTag]) == classTag))
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheCallingMethod]) == callingMethod))
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheDepthOrLookupRule]) == lookupRule)) {
		GIV(newMethod) = GIV(nsMethodCache)[probe + NSMethodCacheTargetMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe + NSMethodCachePrimFunction]));
		GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe + NSMethodCacheActualReceiver];
		return 1;
	}
	probe = (((usqInt) hash) >> 2) & NSMethodCacheMask;
	if (((((GIV(nsMethodCache)[probe + NSMethodCacheSelector]) == selector)
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheClassTag]) == classTag))
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheCallingMethod]) == callingMethod))
	 && ((GIV(nsMethodCache)[probe + NSMethodCacheDepthOrLookupRule]) == lookupRule)) {
		GIV(newMethod) = GIV(nsMethodCache)[probe + NSMethodCacheTargetMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe + NSMethodCachePrimFunction]));
		GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe + NSMethodCacheActualReceiver];
		return 1;
	}
	return 0;
}


/*	Answer the bytecode pc object (i.e. SmallInteger) for an active frame. The
	bytecode pc is derived from the frame's pc. If the frame is the top frame
	on the current stack
	the frame pc is whatever the current instruction pointer is. If the frame
	is the top
	frame on some other stack the frame pc is the value on top of stack.
	Otherwise the
	frame pc is the saved pc of the frame above. Once the frame pc is found it
	must be
	mapped to a bytecode pc. */

	/* StackInterpreter>>#instructionPointerForFrame:currentFP:currentIP: */
static sqInt NoDbgRegParms
instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *fp;
    sqInt index;
    char *theFPAbove;
    sqInt theIP;
    StackPage *thePage;

	if (spouseFP == currentFP) {
		theIP = oopForPointer(instrPtr);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(spouseFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		/* begin findFrameAbove:inPage: */
		fp = (thePage->headFP);
		if (fp == spouseFP) {
			theFPAbove = 0;
			goto l1;
		}
		while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
			if (callerFP == spouseFP) {
				theFPAbove = fp;
				goto l1;
			}
			fp = callerFP;
		}
		error("did not find theFP in stack page");
		theFPAbove = 0;
	l1:	/* end findFrameAbove:inPage: */;
		theIP = (theFPAbove == 0
			? longAt((thePage->headSP))
			: oopForPointer(pointerForOop(longAt(theFPAbove + FoxCallerSavedIP))));
	}
	/* begin contextInstructionPointer:frame: */
	assert(validInstructionPointerinFrame(theIP + 1, spouseFP));
	return (((((theIP - (longAt(spouseFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1);
}


/*	Like #stackIntegerValue: but access method arguments left-to-right */

	/* StackInterpreter>>#integerArg: */
sqInt
integerArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0;
	}
	/* begin checkedIntegerValueOf: */
	if ((((oop) & 7) == 1)) {
		return (oop >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	At a rough approximation we may need to allocate up to a couple
	of page's worth of contexts when switching stack pages, assigning
	to senders, etc. But the snapshot primitive voids all stack pages.
	So a safe margin is the size of a large context times the maximum
	number of frames per page times the number of pages. */

	/* StackInterpreter>>#interpreterAllocationReserveBytes */
static sqInt
interpreterAllocationReserveBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maxFramesPerPage;
    sqInt maxUsedBytesPerPage;

	maxUsedBytesPerPage = (stackPageFrameBytes()) + ((FrameSlots + 64) * BytesPerWord);
	maxFramesPerPage = (maxUsedBytesPerPage / BytesPerWord) / FrameSlots;
	return ((maxFramesPerPage * LargeContextSlots) * BytesPerOop) * GIV(numStackPages);
}


/*	the vm has to convert aFilenameString via any canonicalization and
	char-mapping and put the result in aCharBuffer.
	Note the resolveAliases flag - this is an awful artefact of OSX and Apples
	demented alias handling. When opening a file, the flag must be true, when
	closing or renaming it must be false. Sigh.
 */

	/* StackInterpreter>>#ioFilename:fromString:ofLength:resolveAliases: */
void
ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean)
{
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
}


/*	A base frame (first frame in a stack page) is so marked by having a null
	saved fp.
 */

	/* StackInterpreter>>#isBaseFrame: */
static sqInt NoDbgRegParms
isBaseFrame(char *theFP)
{
	return (longAt(theFP + FoxSavedFP)) == 0;
}

	/* StackInterpreter>>#isEmptyList: */
static sqInt NoDbgRegParms
isEmptyList(sqInt aLinkedList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!(isForwarded(aLinkedList)));
	return (longAt((aLinkedList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())))) == GIV(nilObj);
}

	/* StackInterpreter>>#isFloatObject: */
sqInt
isFloatObject(sqInt oop)
{
    sqInt tagBits;

	return (((tagBits = oop & (tagMask()))) != 0
		? tagBits == (smallFloatTag())
		: ((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
}

	/* StackInterpreter>>#isFrame:onPage: */
static sqInt NoDbgRegParms
isFrameonPage(char *aFrame, StackPage *aPage)
{
    char *prevFP;
    char *theFP;

	assert(!((isFree(aPage))));
	theFP = (aPage->headFP);
	prevFP = theFP - BytesPerWord;
	while (1) {
		if (theFP == aFrame) {
			return 1;
		}
		if (!((theFP > prevFP)
		 && (theFP < ((aPage->baseFP))))) break;
		prevFP = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	}
	return 0;
}


/*	Answer if the argument, which can be any object, is a live context. */

	/* StackInterpreter>>#isLiveContext: */
static sqInt NoDbgRegParms
isLiveContext(sqInt oop)
{
	assert(!((isOopForwarded(oop))));
	if (!(((oop & (tagMask())) == 0)
		 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if (isNonImmediate(longAt((oop + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) {
		return ((((longAt((oop + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord()))))) & 7) == 1);
	}
	return !(isWidowedContext(oop));
}


/*	For compatibility with CoInterpreter. Needed to avoid
	slowPrimitiveResponse failing within ceSend:to:numArgs: et al with an
	unbalanced stack. */

	/* StackInterpreter>>#isMachineCodeFrame: */
static sqInt NoDbgRegParms
isMachineCodeFrame(char *theFP)
{
	return 0;
}

	/* StackInterpreter>>#isMarriedOrWidowedContext: */
static sqInt NoDbgRegParms
isMarriedOrWidowedContext(sqInt aContext)
{
	return ((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1);
}


/*	We save slots in the method cache by using the primitiveFunctionPointer
	to hold either a function pointer or the index of a quick primitive. Since
	quick primitive indices are small they can't be confused with function
	addresses. */

	/* StackInterpreter>>#isPrimitiveFunctionPointerAnIndex */
static sqInt
isPrimitiveFunctionPointerAnIndex(void)
{
	return (((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex;
}

	/* StackInterpreter>>#isQuickPrimitiveIndex: */
sqInt
isQuickPrimitiveIndex(sqInt anInteger)
{
	return ((anInteger >= 256) && (anInteger <= 519));
}


/*	Reading the sender, instructionPointer and stackPointer inst vars of a
	context must take
	account of potentially married contexts and fetch the state from the
	frame. method,
	closureOrNil and receiver can safely be fetched from the context without
	checking. 
 */

	/* StackInterpreter>>#isReadMediatedContextInstVarIndex: */
sqInt
isReadMediatedContextInstVarIndex(sqInt index)
{
	return index <= StackPointerIndex;
}

	/* StackInterpreter>>#isSingleContext: */
static sqInt NoDbgRegParms
isSingleContext(sqInt aContext)
{
	/* begin isNonImmediate: */
	return ((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())))) & (tagMask())) == 0;
}


/*	See if the argument is married to a live frame or not. i.e. see if there
	is a matching
	frame whose frameContext field is aOnceMarriedContext, or a forwarder to
	it. If aOnceMarriedContext is not married to a live frame, turn it into a
	bereaved single context.
	This version is for use during scavenging when stack references may be
	forwarded. Following what appear to be references to forwarded objects on
	the stack is dangerous;
	an instruction ponter may be correctly aligned and may point to bytes that
	just happen
	to look like a forwarder. So it is only safe to follow fields that we know
	are frameContext
	fields; hence the stack page is walked to check that aOnceMarriedContext
	is pointing to
	a live frame. This only has to happen during scavenging because after a
	become: all
	frameContext fields have been followed and so there is no need to follow
	forwarders.  */

	/* StackInterpreter>>#isWidowedContextDuringGC: */
static sqInt NoDbgRegParms
isWidowedContextDuringGC(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt index;
    char *maybeFrame;
    sqInt maybeFrameCtxt;
    sqInt referent;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    StackPage *thePage;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	maybeFrame = pointerForOop(senderOop - 1);
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(maybeFrame, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((isFree(thePage))
		 || (maybeFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		/* begin withoutSmallIntegerTags: */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())));
		assert((((anInteger) & 7) == 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1);
		if (((pointerForOop(longAt(maybeFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((maybeFrame + FoxFrameFlags) + 2)) != 0)) {

			/* On Spur we need to follow the context to check for a match, but since the VM is
			   only speculating about maybeFrame being a frame, and only speculating about
			   maybeContext being a context, we need to be sure before we can safely follow. */
			maybeFrameCtxt = longAt(maybeFrame + FoxThisContext);
			if ((isFrameonPage(maybeFrame, thePage))
			 && (((longAt(maybeFrameCtxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(maybeFrameCtxt));
				referent = longAt((maybeFrameCtxt + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent & (tagMask())) == 0)
				 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				maybeFrameCtxt = referent;
				/* begin setFrameContext:to: */
				longAtput(maybeFrame + FoxThisContext, maybeFrameCtxt);
			}
			if (maybeFrameCtxt == aOnceMarriedContext) {

				/* It is still married! */
				return 0;
			}
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
	return 1;
}


/*	See if the argument is married to a live frame or not.
	If it is not, turn it into a bereaved single context. This version is safe
	for use
	only when no frameContext fields may be forwarded (as maybe the case
	when scavenging). Post become: all frameContext fields are followed, and
	hence nrmally no following of frameCOtext fields is necessary. But during
	a scavenge one must use isWidowedContextDuringGC:. */

	/* StackInterpreter>>#isWidowedContext: */
static sqInt NoDbgRegParms
isWidowedContext(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt index;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFrame = pointerForOop(senderOop - 1);
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((isFree(thePage))
		 || (theFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		/* begin withoutSmallIntegerTags: */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())));
		assert((((anInteger) & 7) == 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1);
		if (((pointerForOop(longAt(theFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((theFrame + FoxFrameFlags) + 2)) != 0)) {
			assert(!(((isFrameonPage(theFrame, thePage))
 && (isForwarded(frameContext(theFrame))))));
			if ((longAt(theFrame + FoxThisContext)) == aOnceMarriedContext) {

				/* It is still married! */
				return 0;
			}
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
	return 1;
}


/*	Wrining any inst vars of a context must take account of potentially
	married contexts
	and set the state in the frame. Inst vars in subclasses don't need
	mediation; subclasses
	can't marry. */

	/* StackInterpreter>>#isWriteMediatedContextInstVarIndex: */
sqInt
isWriteMediatedContextInstVarIndex(sqInt index)
{
	return index <= ReceiverIndex;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOfClass: */
sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt oopClass;
    sqInt tagBits;

	oopClass = (((tagBits = oop & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(oop));
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		/* begin followField:ofObject: */
		objOop = longAt((oopClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop & (tagMask())) == 0)
		 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, oopClass, objOop);
		}
		oopClass = objOop;
	}
	return 0;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOf: */
sqInt
isKindOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt oopClass;
    sqInt tagBits;

	oopClass = (((tagBits = oop & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(oop));
	while (!(oopClass == GIV(nilObj))) {
		if (classNameOfIs(oopClass, className)) {
			return 1;
		}
		/* begin followField:ofObject: */
		objOop = longAt((oopClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop & (tagMask())) == 0)
		 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, oopClass, objOop);
		}
		oopClass = objOop;
	}
	return 0;
}


/*	Support for external primitives */

	/* StackInterpreter>>#is:MemberOf: */
sqInt
isMemberOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oopClass;
    sqInt tagBits;

	oopClass = (((tagBits = oop & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(oop));
	return classNameOfIs(oopClass, className);
}

	/* StackInterpreter>>#lengthOfNameOfClass: */
static sqInt NoDbgRegParms
lengthOfNameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt objOop;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(classOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(classOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (numSlots == GIV(metaclassNumSlots)) {
		return lengthOfNameOfClass(longAt((classOop + BaseHeaderSize) + (((long)GIV(thisClassIndex)) << (shiftForWord()))));
	}
	if (numSlots <= GIV(classNameIndex)) {
		return 0;
	}
	/* begin lengthOf: */
	objOop = longAt((classOop + BaseHeaderSize) + (((long)GIV(classNameIndex)) << (shiftForWord())));
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(objOop + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots11);
	if (fmt <= 5) {
		return numSlots2;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (((long)numSlots2) << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (((long)numSlots2) << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (((long)numSlots2) << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots2;
	}
	return 0;
}

	/* StackInterpreter>>#literal:ofMethod: */
sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return longAt((methodPointer + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=loadBitBltFrom and call it. This entire mechanism should
	eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#loadBitBltFrom: */
sqInt
loadBitBltFrom(sqInt bb)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}

	/* StackInterpreter>>#loadInitialContext */
void
loadInitialContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt objOop;

	runLeakCheckerFor(GCModeFull);
	/* begin fetchPointer:ofObject: */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	activeProc = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
	activeContext = longAt((activeProc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())));
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}

	/* StackInterpreter>>#longPrintOop: */
void
longPrintOop(sqInt oop)
{
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt class;
    sqInt column;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt lastIndex;
    sqInt len;
    sqInt n;
    sqInt n1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt startIP;

	if (((oop & (tagMask())) != 0)
	 || ((!(addressCouldBeObj(oop)))
	 || (((oop & (8 - 1)) != 0)
	 || ((((longAt(oop)) & (classIndexMask())) == 0)
	 || (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))))) {
		printOop(oop);
		return;
	}
	printHex(oop);
	class = fetchClassOfNonImm(oop);
	if (class == null) {
		print(" has a nil class!!");
	}
	else {
		print(": a(n) ");
		printNameOfClasscount(class, 5);
		print(" (");
		/* begin printHexnp: */
		n = (longAt(oop)) & (classIndexMask());
		printf("0x%lx", ((unsigned long) n));
		print("=>");

		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) class));
		print(")");
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	print(" format ");
	/* begin printHexnp: */
	printf("0x%lx", ((unsigned long) fmt));
	if (fmt > 5) {
		print(" nbytes ");
		printNum(numBytesOf(oop));
	}
	else {
		if ((fmt >= 2)
		 && ((fmt <= (weakArrayFormat()))
		 || (fmt >= (sixtyFourBitIndexableFormat())))) {
			/* begin lengthOf:format: */
			fmt1 = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
			/* begin numSlotsOfAny: */
			numSlots2 = byteAt(oop + 7);
			numSlots = (numSlots2 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
				: numSlots2);
			if (fmt1 <= 5) {
				len = numSlots;
				goto l1;
			}
			if (fmt1 >= (firstByteFormat())) {

				/* bytes, including CompiledMethod */
				len = (((long)numSlots) << (shiftForWord())) - (fmt1 & 7);
				goto l1;
			}
			if (fmt1 >= (firstShortFormat())) {
				len = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt1 & 3);
				goto l1;
			}
			if (fmt1 >= (firstLongFormat())) {
				len = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt1 & 1);
				goto l1;
			}
			if (fmt1 == (sixtyFourBitIndexableFormat())) {
				len = numSlots;
				goto l1;
			}
			len = 0;
		l1:	/* end lengthOf:format: */;
			print(" size ");
			printNum(len - (fixedFieldsOfformatlength(oop, fmt, len)));
		}
	}
	printHeaderTypeOf(oop);
	print(" hash ");
	/* begin printHexnp: */
	n1 = (long32At(oop + 4)) & (identityHashHalfWordMask());
	printf("0x%lx", ((unsigned long) n1));
	/* begin cr */
	printf("\n");
	if (((fmt >= (firstByteFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {
		printStringOf(oop);
		/* begin cr */
		printf("\n");

		return;
	}
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstByteFormat()) - 1)))) {
		for (i = 0, iLimiT = (((((((usqInt) (numBytesOf(oop))) >> 2) < 256) ? (((usqInt) (numBytesOf(oop))) >> 2) : 256)) - 1); i <= iLimiT; i += 1) {
			fieldOop = long32At((oop + BaseHeaderSize) + (((long)i) << 2));
			/* begin space */
			putchar(' ');
			printNum(i);
			/* begin space */
			putchar(' ');
			printHex(fieldOop);
			/* begin space */
			putchar(' ');
			/* begin cr */
			printf("\n");
		}
		return;
	}
	startIP = (((lastPointerOf(oop)) + BytesPerOop) - BaseHeaderSize) / BytesPerOop;
	lastIndex = ((256 < startIP) ? 256 : startIP);
	if (lastIndex > 0) {
		for (i = 1; i <= lastIndex; i += 1) {
			fieldOop = longAt((oop + BaseHeaderSize) + (((long)(i - 1)) << (shiftForWord())));
			/* begin space */
			putchar(' ');
			printNum(i - 1);
			/* begin space */
			putchar(' ');
			printHex(fieldOop);
			/* begin space */
			putchar(' ');
			if ((i == 1)
			 && (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
				/* begin printMethodHeaderOop: */
				printOopShort(fieldOop);
				/* return self */
			}
			else {
				printOopShort(fieldOop);
			}
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf:format: */
		fmt2 = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
		/* begin numSlotsOfAny: */
		numSlots3 = byteAt(oop + 7);
		numSlots1 = (numSlots3 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots3);
		if (fmt2 <= 5) {
			lastIndex = numSlots1;
			goto l2;
		}
		if (fmt2 >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			lastIndex = (((long)numSlots1) << (shiftForWord())) - (fmt2 & 7);
			goto l2;
		}
		if (fmt2 >= (firstShortFormat())) {
			lastIndex = (((long)numSlots1) << ((shiftForWord()) - 1)) - (fmt2 & 3);
			goto l2;
		}
		if (fmt2 >= (firstLongFormat())) {
			lastIndex = (((long)numSlots1) << ((shiftForWord()) - 2)) - (fmt2 & 1);
			goto l2;
		}
		if (fmt2 == (sixtyFourBitIndexableFormat())) {
			lastIndex = numSlots1;
			goto l2;
		}
		lastIndex = 0;
	l2:	/* end lengthOf:format: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				printf("0x%08x: ", oop+BaseHeaderSize+index-1);
			}
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			printf(" %02x/%-3d", byte,byte);
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				/* begin cr */
				printf("\n");
			}
		}
		if (!(column == 1)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > lastIndex) {
			print("...");
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Answer the relevant long store temp bytecode, which indicates it has a
	primitive error code.
 */
/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#longStoreBytecodeForHeader: */
sqInt
longStoreBytecodeForHeader(sqInt methodHeader)
{
	return ((((int) methodHeader)) < 0
				? AltLongStoreBytecode
				: LongStoreBytecode);
}


/*	This method implements a simple method lookup cache. If an entry for the
	given selector and classTag is found in the cache, set the values of
	'newMethod' and
	'primitiveFunctionPointer' and answer true. Otherwise, answer false. */

	/* StackInterpreter>>#lookupInMethodCacheSel:classTag: */
static sqInt NoDbgRegParms
lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt probe;

	/* begin inlineLookupInMethodCacheSel:classTag: */

	/* shift drops two low-order zeros from addresses */
	hash = selector ^ classTag;

	/* first probe */
	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}

	/* second probe */
	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}


/*	A shared part of the lookup for implicit receiver sends that found a
	lexically visible
	method, and self and outer sends.
 */

	/* StackInterpreter>>#lookupLexical:from:rule: */
static sqInt NoDbgRegParms
lookupLexicalfromrule(sqInt selector, sqInt mixin, sqInt rule)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt dictionary;
    sqInt found;
    sqInt hash;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt mixinApplication;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt receiverClass;
    sqInt tagBits;
    sqInt wrapAround;

	receiverClass = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(GIV(localAbsentReceiver)));

	/* MNU lookup starts here. */
	GIV(lkupClass) = receiverClass;
	mixinApplication = findApplicationOfTargetMixinstartingAtBehavior(mixin, receiverClass);
	/* begin followObjField:ofObject: */
	objOop = longAt((mixinApplication + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
	assert(isNonImmediate(objOop));
	if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, mixinApplication, objOop);
	}
	dictionary = objOop;
	/* begin lookupMethodInDictionary: */
	flag("endianness");
	assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(dictionary + 7);
	length = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(dictionary - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);

	/* Use linear search on small dictionaries; its cheaper.
	   Also the limit can be set to force linear search of all dictionaries, which supports the
	   booting of images that need rehashing (e.g. because a tracer has generated an image
	   with different hashes but hasn't rehashed it yet.) */
	mask = (length - SelectorStart) - 1;
	if (mask <= GIV(methodDictLinearSearchLimit)) {
		index = 0;
		while (index <= mask) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)(index + SelectorStart)) << (shiftForWord())));
			if (((nextSelector & (tagMask())) == 0)
			 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop5 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop5));
				if (((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop5 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop5);
				}
				methodArray = objOop5;
				/* begin followField:ofObject: */
				objOop2 = longAt((methodArray + BaseHeaderSize) + (((long)index) << (shiftForWord())));
				if (((objOop2 & (tagMask())) == 0)
				 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop2);
				}
				GIV(newMethod) = objOop2;
				found = 1;
				goto l1;
			}
			index += 1;
		}
		found = 0;
		goto l1;
	}

	/* It is assumed that there are some nils in this dictionary, and search will
	   stop when one is encountered. However, if there are no nils, then wrapAround
	   will be detected the second time the loop gets to the end of the table. */
	index = SelectorStart + (mask & (((GIV(messageSelector) & (tagMask())) != 0
	? (GIV(messageSelector) >> 3)
	: (/* begin hashBitsOf: */
		(objOop3 = GIV(messageSelector)),
		(hash = (long32At(objOop3 + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(objOop3 + 4, ((((long32At(objOop3 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
	wrapAround = 0;
	while (1) {
		nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
		if (nextSelector == GIV(nilObj)) {
			found = 0;
			goto l1;
		}
		if (((nextSelector & (tagMask())) == 0)
		 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
		}
		if (nextSelector == GIV(messageSelector)) {
			/* begin followObjField:ofObject: */
			objOop1 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
			assert(isNonImmediate(objOop1));
			if (((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop1);
			}
			methodArray = objOop1;
			/* begin followField:ofObject: */
			objOop4 = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
			if (((objOop4 & (tagMask())) == 0)
			 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop4 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop4);
			}
			GIV(newMethod) = objOop4;
			found = 1;
			goto l1;
		}
		index += 1;
		if (index == length) {
			if (wrapAround) {
				found = 0;
				goto l1;
			}
			wrapAround = 1;
			index = SelectorStart;
		}
	}
	found = 0;
l1:	/* end lookupMethodInDictionary: */;
	if (found
	 && ((accessModifierOfMethod(GIV(newMethod))) == AccessModifierPrivate)) {
		return rule;
	}
	return lookupProtectedstartingAtrule(selector, receiverClass, rule);
}

	/* StackInterpreter>>#lookupMethodInClass: */
static sqInt NoDbgRegParms
lookupMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt hash;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt wrapAround;

	assert(addressCouldBeClassObj(class));
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop));
		if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {

			/* MethodDict pointer is nil (hopefully due a swapped out stub)
			   -- raise exception #cannotInterpret:. */
			createActualMessageTo(class);
			GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorCannotInterpret) << (shiftForWord())));
			/* begin sendBreakpoint:receiver: */
			sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), null);
			return lookupMethodInClass(followFieldofObject(SuperclassIndex, currentClass));
		}
		/* begin lookupMethodInDictionary: */
		flag("endianness");
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(dictionary - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)(index + SelectorStart)) << (shiftForWord())));
				if (((nextSelector & (tagMask())) == 0)
				 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop5 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
					assert(isNonImmediate(objOop5));
					if (((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						objOop5 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop5);
					}
					methodArray = objOop5;
					/* begin followField:ofObject: */
					objOop2 = longAt((methodArray + BaseHeaderSize) + (((long)index) << (shiftForWord())));
					if (((objOop2 & (tagMask())) == 0)
					 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop2 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop2);
					}
					GIV(newMethod) = objOop2;
					found = 1;
					goto l1;
				}
				index += 1;
			}
			found = 0;
			goto l1;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & (tagMask())) != 0
	? (GIV(messageSelector) >> 3)
	: (/* begin hashBitsOf: */
		(objOop3 = GIV(messageSelector)),
		(hash = (long32At(objOop3 + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(objOop3 + 4, ((((long32At(objOop3 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (((nextSelector & (tagMask())) == 0)
			 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop11 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop11));
				if (((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop11 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop11);
				}
				methodArray = objOop11;
				/* begin followField:ofObject: */
				objOop4 = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
				if (((objOop4 & (tagMask())) == 0)
				 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop4 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop4);
				}
				GIV(newMethod) = objOop4;
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l1:	/* end lookupMethodInDictionary: */;
		if (found) {
			return currentClass;
		}
		/* begin followField:ofObject: */
		objOop1 = longAt((currentClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop1 & (tagMask())) == 0)
		 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1);
		}
		currentClass = objOop1;
	}
	if (GIV(messageSelector) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorDoesNotUnderstand) << (shiftForWord()))))) {
		error("Recursive not understood error encountered");
	}
	createActualMessageTo(class);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorDoesNotUnderstand) << (shiftForWord())));
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOfformat(GIV(messageSelector), (((usqInt) (longAt(GIV(messageSelector)))) >> (formatShift())) & (formatMask())), null);
	return lookupMethodInClass(class);
}


/*	A send lookup failed. Replace the arguments on the stack with a Message
	and lookup
	#doesNotUndestand: starting at lkupClass. Note that MNU lookup ignores
	access modifiers.
	This makes it different from an ordinary send of #doesNotUnderstand:,
	which must only
	find public methods.
	IN: lkupClass
	IN: messageSelector
	IN: argumentCount
	OUT: newMethod
	OUT: primitiveIndex
	RESULT: LookupRuleMNU */

	/* StackInterpreter>>#lookupMNU */
static sqInt
lookupMNU(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt hash;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt wrapAround;

	createActualMessageTo(GIV(lkupClass));
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorDoesNotUnderstand) << (shiftForWord())));
	currentClass = GIV(lkupClass);
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop));
		if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		/* begin lookupMethodInDictionary: */
		flag("endianness");
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(dictionary - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)(index + SelectorStart)) << (shiftForWord())));
				if (((nextSelector & (tagMask())) == 0)
				 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop5 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
					assert(isNonImmediate(objOop5));
					if (((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						objOop5 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop5);
					}
					methodArray = objOop5;
					/* begin followField:ofObject: */
					objOop2 = longAt((methodArray + BaseHeaderSize) + (((long)index) << (shiftForWord())));
					if (((objOop2 & (tagMask())) == 0)
					 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop2 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop2);
					}
					GIV(newMethod) = objOop2;
					found = 1;
					goto l1;
				}
				index += 1;
			}
			found = 0;
			goto l1;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & (tagMask())) != 0
	? (GIV(messageSelector) >> 3)
	: (/* begin hashBitsOf: */
		(objOop3 = GIV(messageSelector)),
		(hash = (long32At(objOop3 + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(objOop3 + 4, ((((long32At(objOop3 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (((nextSelector & (tagMask())) == 0)
			 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop11 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop11));
				if (((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop11 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop11);
				}
				methodArray = objOop11;
				/* begin followField:ofObject: */
				objOop4 = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
				if (((objOop4 & (tagMask())) == 0)
				 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop4 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop4);
				}
				GIV(newMethod) = objOop4;
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l1:	/* end lookupMethodInDictionary: */;
		if (found) {
			return LookupRuleMNU;
		}
		/* begin followField:ofObject: */
		objOop1 = longAt((currentClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop1 & (tagMask())) == 0)
		 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1);
		}
		currentClass = objOop1;
	}
	error("Recursive not understood error encountered");
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

	/* StackInterpreter>>#lookupOrdinaryNoMNUEtcInClass: */
static sqInt NoDbgRegParms
lookupOrdinaryNoMNUEtcInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt hash;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop21;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt wrapAround;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop));
		if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {
			/* begin followField:ofObject: */
			objOop1 = longAt((currentClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
			if (((objOop1 & (tagMask())) == 0)
			 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1);
			}
			GIV(lkupClass) = objOop1;
			return SelectorCannotInterpret;
		}
		/* begin lookupMethodInDictionary: */
		flag("endianness");
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(dictionary - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)(index + SelectorStart)) << (shiftForWord())));
				if (((nextSelector & (tagMask())) == 0)
				 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop5 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
					assert(isNonImmediate(objOop5));
					if (((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						objOop5 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop5);
					}
					methodArray = objOop5;
					/* begin followField:ofObject: */
					objOop21 = longAt((methodArray + BaseHeaderSize) + (((long)index) << (shiftForWord())));
					if (((objOop21 & (tagMask())) == 0)
					 && (((longAt(objOop21)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop21 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop21);
					}
					GIV(newMethod) = objOop21;
					found = 1;
					goto l1;
				}
				index += 1;
			}
			found = 0;
			goto l1;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & (tagMask())) != 0
	? (GIV(messageSelector) >> 3)
	: (/* begin hashBitsOf: */
		(objOop3 = GIV(messageSelector)),
		(hash = (long32At(objOop3 + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(objOop3 + 4, ((((long32At(objOop3 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (((nextSelector & (tagMask())) == 0)
			 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop11 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop11));
				if (((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop11 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop11);
				}
				methodArray = objOop11;
				/* begin followField:ofObject: */
				objOop4 = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
				if (((objOop4 & (tagMask())) == 0)
				 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop4 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop4);
				}
				GIV(newMethod) = objOop4;
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l1:	/* end lookupMethodInDictionary: */;
		if (found) {
			if ((accessModifierOfMethod(GIV(newMethod))) == AccessModifierPublic) {
				addNewMethodToCache(class);
				return 0;
			}
			if ((accessModifierOfMethod(GIV(newMethod))) == AccessModifierProtected) {
				GIV(lkupClass) = class;
				return SelectorDoesNotUnderstand;
			}
		}

		/* begin followField:ofObject: */
		objOop2 = longAt((currentClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop2 & (tagMask())) == 0)
		 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop2 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop2);
		}
		currentClass = objOop2;
	}
	GIV(lkupClass) = class;
	return SelectorDoesNotUnderstand;
}


/*	Do the full lookup for an ordinary send (i.e., a Newspeak or Smalltalk
	ordinary send or a Smalltalk super send).
	IN: lkupClass
	IN: messageSelector
	IN: argumentCount
	OUT: newMethod
	OUT: primitiveIndex
	RESULT: LookupRuleOrdinary or LookupRuleMNU
 */

	/* StackInterpreter>>#lookupOrdinarySend */
static sqInt
lookupOrdinarySend(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt hash;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt wrapAround;

	assert(addressCouldBeClassObj(GIV(lkupClass)));
	currentClass = GIV(lkupClass);
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop));
		if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		/* begin lookupMethodInDictionary: */
		flag("endianness");
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(dictionary - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)(index + SelectorStart)) << (shiftForWord())));
				if (((nextSelector & (tagMask())) == 0)
				 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop5 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
					assert(isNonImmediate(objOop5));
					if (((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						objOop5 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop5);
					}
					methodArray = objOop5;
					/* begin followField:ofObject: */
					objOop2 = longAt((methodArray + BaseHeaderSize) + (((long)index) << (shiftForWord())));
					if (((objOop2 & (tagMask())) == 0)
					 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop2 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop2);
					}
					GIV(newMethod) = objOop2;
					found = 1;
					goto l1;
				}
				index += 1;
			}
			found = 0;
			goto l1;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & (tagMask())) != 0
	? (GIV(messageSelector) >> 3)
	: (/* begin hashBitsOf: */
		(objOop3 = GIV(messageSelector)),
		(hash = (long32At(objOop3 + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(objOop3 + 4, ((((long32At(objOop3 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (((nextSelector & (tagMask())) == 0)
			 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop11 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop11));
				if (((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop11 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop11);
				}
				methodArray = objOop11;
				/* begin followField:ofObject: */
				objOop4 = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
				if (((objOop4 & (tagMask())) == 0)
				 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop4 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop4);
				}
				GIV(newMethod) = objOop4;
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l1:	/* end lookupMethodInDictionary: */;
		if (found) {
			if ((accessModifierOfMethod(GIV(newMethod))) == AccessModifierPublic) {
				return LookupRuleOrdinary;
			}
			if ((accessModifierOfMethod(GIV(newMethod))) == AccessModifierProtected) {
				return lookupMNU();
			}
		}
		/* begin followField:ofObject: */
		objOop1 = longAt((currentClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop1 & (tagMask())) == 0)
		 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1);
		}
		currentClass = objOop1;
	}
	return lookupMNU();
}


/*	A shared part of the lookup for self, outer or implicit receiver sends
	that did not find a
	private lexically visible method, and (Newspeak) super sends.
 */

	/* StackInterpreter>>#lookupProtected:startingAt:rule: */
static sqInt NoDbgRegParms
lookupProtectedstartingAtrule(sqInt selector, sqInt mixinApplication, sqInt rule)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt hash;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt wrapAround;

	currentClass = mixinApplication;
	while (!(currentClass == GIV(nilObj))) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop));
		if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		/* begin lookupMethodInDictionary: */
		flag("endianness");
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(dictionary - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)(index + SelectorStart)) << (shiftForWord())));
				if (((nextSelector & (tagMask())) == 0)
				 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop5 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
					assert(isNonImmediate(objOop5));
					if (((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						objOop5 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop5);
					}
					methodArray = objOop5;
					/* begin followField:ofObject: */
					objOop2 = longAt((methodArray + BaseHeaderSize) + (((long)index) << (shiftForWord())));
					if (((objOop2 & (tagMask())) == 0)
					 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop2 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop2);
					}
					GIV(newMethod) = objOop2;
					found = 1;
					goto l1;
				}
				index += 1;
			}
			found = 0;
			goto l1;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & (tagMask())) != 0
	? (GIV(messageSelector) >> 3)
	: (/* begin hashBitsOf: */
		(objOop3 = GIV(messageSelector)),
		(hash = (long32At(objOop3 + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(objOop3 + 4, ((((long32At(objOop3 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (((nextSelector & (tagMask())) == 0)
			 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop11 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop11));
				if (((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop11 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop11);
				}
				methodArray = objOop11;
				/* begin followField:ofObject: */
				objOop4 = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
				if (((objOop4 & (tagMask())) == 0)
				 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop4 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop4);
				}
				GIV(newMethod) = objOop4;
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l1:	/* end lookupMethodInDictionary: */;
		if (found
		 && (!((accessModifierOfMethod(GIV(newMethod))) == AccessModifierPrivate))) {
			return rule;
		}
		/* begin followField:ofObject: */
		objOop1 = longAt((currentClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop1 & (tagMask())) == 0)
		 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1);
		}
		currentClass = objOop1;
	}
	return lookupMNU();
}


/*	Lookup selector in class. Answer the method or nil. This is a debugging
	routine.  */

	/* StackInterpreter>>#lookupSelector:inClass: */
sqInt
lookupSelectorinClass(sqInt selector, sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt hash;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt meth;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt wrapAround;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
		assert(isNonImmediate(objOop));
		if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {
			return null;
		}
		/* begin lookupMethodFor:InDictionary: */
		flag("endianness");
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(dictionary + 7);
		length = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(dictionary - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);
		mask = (length - SelectorStart) - 1;

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((selector & (tagMask())) != 0
	? (selector >> 3)
	: (/* begin hashBitsOf: */
		(hash = (long32At(selector + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(selector + 4, ((((long32At(selector + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			if (nextSelector == GIV(nilObj)) {
				meth = null;
				goto l1;
			}
			if (((nextSelector & (tagMask())) == 0)
			 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == selector) {
				/* begin followObjField:ofObject: */
				objOop2 = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop2));
				if (((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop2);
				}
				methodArray = objOop2;
				/* begin followField:ofObject: */
				objOop11 = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
				if (((objOop11 & (tagMask())) == 0)
				 && (((longAt(objOop11)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop11 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop11);
				}
				meth = objOop11;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					meth = null;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		meth = null;
	l1:	/* end lookupMethodFor:InDictionary: */;
		if (!(meth == null)) {
			return meth;
		}
		/* begin followField:ofObject: */
		objOop1 = longAt((currentClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
		if (((objOop1 & (tagMask())) == 0)
		 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1);
		}
		currentClass = objOop1;
	}
	return null;
}


/*	<Integer> */
/*	Marry aContext with the base frame of a new stack page. Build the base
	frame to reflect the context's state. Answer the new page. */

	/* StackInterpreter>>#makeBaseFrameFor: */
static StackPage * NoDbgRegParms
makeBaseFrameFor(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    StackPage *lruOrFree;
    sqInt maybeClosure;
    sqInt numArgs;
    sqInt objOop;
    sqInt objOop1;
    sqInt oop;
    sqInt oop1;
    StackPage *page;
    char *pointer;
    sqInt rcvr;
    sqInt stackPtrIndex;
    sqInt theIP;
    sqInt theMethod;
    char *value;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert(isContext(aContext));
	assert(isSingleContext(aContext));
	assert(goodContextSize(aContext));
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		page = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree);
	page = lruOrFree;
l1:	/* end newStackPage */;
	pointer = (page->baseAddress);
	theIP = longAt((aContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())));
	/* begin followObjField:ofObject: */
	objOop = longAt((aContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
	assert(isNonImmediate(objOop));
	if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		objOop = fixFollowedFieldofObjectwithInitialValue(MethodIndex, aContext, objOop);
	}
	theMethod = objOop;
	if (!((((theIP) & 7) == 1))) {
		error("context is not resumable");
	}
	theIP = (theIP >> 3);
	/* begin followField:ofObject: */
	objOop1 = longAt((aContext + BaseHeaderSize) + (((long)ReceiverIndex) << (shiftForWord())));
	if (((objOop1 & (tagMask())) == 0)
	 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, aContext, objOop1);
	}
	rcvr = objOop1;
	maybeClosure = longAt((aContext + BaseHeaderSize) + (((long)ClosureIndex) << (shiftForWord())));
	if (maybeClosure != GIV(nilObj)) {
		if (((longAt(maybeClosure)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
			maybeClosure = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, aContext, maybeClosure);
		}
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((maybeClosure + BaseHeaderSize) + (((long)ClosureNumArgsIndex) << (shiftForWord())));
		assert((((oop) & 7) == 1));
		numArgs = (oop >> 3);
		longAtput(pointer, maybeClosure);
	}
	else {
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(theMethod));
		header = longAt((theMethod + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));

		/* If this is a synthetic context its IP could be pointing at the CallPrimitive opcode.  If so, skip it. */
		numArgs = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
		if ((header & AlternateHeaderHasPrimFlag)
		 && (theIP == (1 + (((((literalCountOfMethodHeader(header)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize)))) {
			theIP += 3;
		}
		longAtput(pointer, rcvr);
	}
	for (i = 1; i <= numArgs; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((long)(ReceiverIndex + i)) << (shiftForWord()))));
	}
	longAtput((pointer -= BytesPerWord), followObjFieldofObject(SenderIndex, aContext));
	longAtput((pointer -= BytesPerWord), 0);
	(page->baseFP = pointer);
	(page->headFP = pointer);
	longAtput((pointer -= BytesPerWord), theMethod);
	longAtput((pointer -= BytesPerWord), (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (1LL << ((BytesPerWord * 8) - 16))) + ((maybeClosure != GIV(nilObj)
	? 1LL << ((BytesPerWord * 8) - 24)
	: 0))
		: ((1 + (((long)numArgs) << 8)) + (1LL << 16)) + ((maybeClosure != GIV(nilObj)
	? 1LL << 24
	: 0))));
	assert(frameHasContext((page->baseFP)));
	assert((frameNumArgs((page->baseFP))) == numArgs);
	longAtput((pointer -= BytesPerWord), aContext);
	longAtput((pointer -= BytesPerWord), rcvr);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
	assert((((oop1) & 7) == 1));
	stackPtrIndex = (oop1 >> 3);
	assert((ReceiverIndex + stackPtrIndex) < (lengthOf(aContext)));
	for (i = (numArgs + 1); i <= stackPtrIndex; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((long)(ReceiverIndex + i)) << (shiftForWord()))));
	}
	/* begin iframeInstructionPointerForIndex:method: */
	assert(((theIP >= (((LiteralStart + (literalCountOf(theMethod))) * BytesPerOop) + 1)) && (theIP <= (lengthOf(theMethod)))));
	theIP = ((theMethod + theIP) + BaseHeaderSize) - 2;
	longAtput((pointer -= BytesPerWord), theIP);
	(page->headSP = pointer);
	assert(contexthasValidInversePCMappingOfin(aContext, theIP, (page->baseFP)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	value = (page->baseFP);
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer = (oopForPointer(value)) + 1;
	assert(!(isForwarded(aContext)));
	longAtput((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(((oopForPointer(0)) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(0)) + 1;
	assert(!(isForwarded(aContext)));
	longAtput((aContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), valuePointer1);
	assert(((((fetchPointerofObject(SenderIndex, aContext))) & 7) == 1));
	assert((frameOfMarriedContext(aContext)) == ((page->baseFP)));
	assert(validStackPageBaseFrame(page));
	return page;
}


/*	make a Point xValue@yValue.
	We know both will be integers so no value nor root checking is needed */

	/* StackInterpreter>>#makePointwithxValue:yValue: */
sqInt
makePointwithxValueyValue(sqInt xValue, sqInt yValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt pointResult;

	/* begin eeInstantiateSmallClass:numSlots: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassPoint) << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((long)XIndex) << (shiftForWord())), ((xValue << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((long)YIndex) << (shiftForWord())), ((yValue << 3) | 1));
	return pointResult;
}


/*	Map all oops in the interpreter's state to their new values 
	during garbage collection or a become: operation. */
/*	Assume: All traced variables contain valid oops. */

	/* StackInterpreter>>#mapInterpreterOops */
static void
mapInterpreterOops(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt oop;

	mapStackPages();
	/* begin mapVMRegisters */
	if ((((longAt(GIV(method))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(GIV(method)))
	 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(method), ((futureSpace()).start), futureSurvivorStart()))))) {

		/* *rel to method */
		GIV(instructionPointer) -= GIV(method);
		GIV(method) = remapObj(GIV(method));
		GIV(instructionPointer) += GIV(method);
	}
	if (((GIV(newMethod) & (tagMask())) == 0)
	 && ((((longAt(GIV(newMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(GIV(newMethod)))
	 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(newMethod), ((futureSpace()).start), futureSurvivorStart())))))) {

		/* maybe oop due to object-as-method */
		GIV(newMethod) = remapObj(GIV(newMethod));
	}
	/* begin mapProfileState */
	if ((((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(GIV(profileProcess)))
	 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(profileProcess), ((futureSpace()).start), futureSurvivorStart()))))) {
		GIV(profileProcess) = remapObj(GIV(profileProcess));
	}
	if ((((longAt(GIV(profileMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(GIV(profileMethod)))
	 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(profileMethod), ((futureSpace()).start), futureSurvivorStart()))))) {
		GIV(profileMethod) = remapObj(GIV(profileMethod));
	}
	if ((((longAt(GIV(profileSemaphore))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(GIV(profileSemaphore)))
	 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(profileSemaphore), ((futureSpace()).start), futureSurvivorStart()))))) {
		GIV(profileSemaphore) = remapObj(GIV(profileSemaphore));
	}
	sqLowLevelMFence();
	if (!(GIV(longRunningPrimitiveCheckMethod) == null)) {
		if (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)) {
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
		}
		else {
			if ((((longAt(GIV(longRunningPrimitiveCheckMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
			 || ((isYoungObject(GIV(longRunningPrimitiveCheckMethod)))
			 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(longRunningPrimitiveCheckMethod), ((futureSpace()).start), futureSurvivorStart()))))) {
				GIV(longRunningPrimitiveCheckMethod) = remapObj(GIV(longRunningPrimitiveCheckMethod));
			}
		}
		sqLowLevelMFence();
	}
	if (!(GIV(longRunningPrimitiveCheckSemaphore) == null)) {
		if ((((longAt(GIV(longRunningPrimitiveCheckSemaphore))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
		 || ((isYoungObject(GIV(longRunningPrimitiveCheckSemaphore)))
		 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(longRunningPrimitiveCheckSemaphore), ((futureSpace()).start), futureSurvivorStart()))))) {
			GIV(longRunningPrimitiveCheckSemaphore) = remapObj(GIV(longRunningPrimitiveCheckSemaphore));
		}
	}
	/* begin remapCallbackState */
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		oop = GIV(suspendedCallbacks)[i];
		if (((oop & (tagMask())) == 0)
		 && ((((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
		 || ((isYoungObject(oop))
		 && (!(oopisGreaterThanOrEqualToandLessThan(oop, ((futureSpace()).start), futureSurvivorStart())))))) {
			GIV(suspendedCallbacks)[i] = (remapObj(oop));
		}
		oop = GIV(suspendedMethods)[i];
		if ((((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
		 || ((isYoungObject(oop))
		 && (!(oopisGreaterThanOrEqualToandLessThan(oop, ((futureSpace()).start), futureSurvivorStart()))))) {
			GIV(suspendedMethods)[i] = (remapObj(oop));
		}
	}
	if ((GIV(tempOop) != 0)
	 && (((GIV(tempOop) & (tagMask())) == 0)
	 && ((((longAt(GIV(tempOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(GIV(tempOop)))
	 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(tempOop), ((futureSpace()).start), futureSurvivorStart()))))))) {
		GIV(tempOop) = remapObj(GIV(tempOop));
	}
	if ((GIV(tempOop2) != 0)
	 && (((GIV(tempOop2) & (tagMask())) == 0)
	 && ((((longAt(GIV(tempOop2))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
	 || ((isYoungObject(GIV(tempOop2)))
	 && (!(oopisGreaterThanOrEqualToandLessThan(GIV(tempOop2), ((futureSpace()).start), futureSurvivorStart()))))))) {
		GIV(tempOop2) = remapObj(GIV(tempOop2));
	}
}

	/* StackInterpreter>>#mapStackPages */
static void NeverInline
mapStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt numLivePages;
    sqInt oop;
    char *theFP;
    sqInt theIP;
    char *theIPPtr;
    StackPage *thePage;
    char *theSP;

	theIP = 0;
	numLivePages = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage));
			numLivePages += 1;
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = 0;
			}
			else {
				theIPPtr = theSP;
				theSP += BytesPerWord;
			}
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert(addressIsInPage(thePage, theSP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theIPPtr)));
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & (tagMask())) == 0)
					 && ((((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
					 || ((isYoungObject(oop))
					 && (!(oopisGreaterThanOrEqualToandLessThan(oop, ((futureSpace()).start), futureSurvivorStart())))))) {
						longAtput(theSP, remapObj(oop));
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					if ((((longAt(longAt(theFP + FoxThisContext))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
					 || ((isYoungObject(longAt(theFP + FoxThisContext)))
					 && (!(oopisGreaterThanOrEqualToandLessThan(longAt(theFP + FoxThisContext), ((futureSpace()).start), futureSurvivorStart()))))) {
						longAtput(theFP + FoxThisContext, remapObj(longAt(theFP + FoxThisContext)));
					}
					assert((isMarriedOrWidowedContext(frameContext(theFP)))
					 && ((frameOfMarriedContext(frameContext(theFP))) == theFP));

				}
				if ((((longAt(longAt(theFP + FoxMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
				 || ((isYoungObject(longAt(theFP + FoxMethod)))
				 && (!(oopisGreaterThanOrEqualToandLessThan(longAt(theFP + FoxMethod), ((futureSpace()).start), futureSurvivorStart()))))) {
					if (theIPPtr != 0) {
						assert((longAt(theIPPtr)) > (frameMethod(theFP)));
						theIP = (longAt(theIPPtr)) - (longAt(theFP + FoxMethod));
					}
					longAtput(theFP + FoxMethod, remapObj(longAt(theFP + FoxMethod)));
					if (theIPPtr != 0) {
						longAtput(theIPPtr, theIP + (longAt(theFP + FoxMethod)));
					}
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = ((theIPPtr = theFP + FoxCallerSavedIP)) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerSavedIP */
			theSP = theFP + FoxCallerContext;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & (tagMask())) == 0)
				 && ((((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)
				 || ((isYoungObject(oop))
				 && (!(oopisGreaterThanOrEqualToandLessThan(oop, ((futureSpace()).start), futureSurvivorStart())))))) {
					longAtput(theSP, remapObj(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}
	/* begin recordLivePagesOnMapping: */
	GIV(statNumMaps) += 1;
	GIV(statPageCountWhenMappingSum) += numLivePages;
	GIV(statMaxPageCountWhenMapping) = ((GIV(statMaxPageCountWhenMapping) < numLivePages) ? numLivePages : GIV(statMaxPageCountWhenMapping));
}


/*	GC of pages. Throwing away all stack pages on full GC is simple but
	dangerous because it causes us to allocate lots of contexts immediately
	before a GC.
	Reclaiming pages whose top context is not referenced is poor because it
	would take N incrementalGCs to reclaim N unused pages. Only the page whose
	top context is not referred to by the bottom context of any other page
	would be
	reclaimed. Not until the next GC would the page whose top contect is the
	previously reclaimed page's base frame's bottom context be reclaimed.
	
	Better is to not mark stack pages until their contexts are encountered. We
	can eagerly trace the active page and the page reachable from its bottom
	context if any, and so on. Other pages can be marked when we encounter a
	married context. */

	/* StackInterpreter>>#markAndTraceStackPages: */
static sqInt NoDbgRegParms
markAndTraceStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt i;
    sqInt i1;
    sqInt index;
    void *pointer;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    StackPage *thePage1;

	if (!fullGCFlag) {
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if (!(isFree(thePage))) {
				markAndTraceStackPage(thePage);
			}
		}
		return null;
	}
	if (GIV(stackPage) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	do {
		markAndTraceStackPage(thePage);
		/* begin frameCallerContext: */
		theFP = (thePage->baseFP);
		context = longAt(theFP + FoxCallerContext);
		if ((((context & (tagMask())) == 0)
		 && (((longAt(context)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && ((((((longAt((context + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && ((((((longAt((context + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(context)))))) {
			/* begin stackPageFor: */
			senderOop = longAt((context + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1));
			pointer = pointerForOop(senderOop - 1);
			/* begin stackPageAt: */
			index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
			thePage = stackPageAtpages(index, GIV(pages));
			assert(!(isFree(thePage)));
		}
	} while(((thePage->trace)) < StackPageTraced);
}

	/* StackInterpreter>>#markAndTraceStackPage: */
static void NoDbgRegParms
markAndTraceStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt contextSize2;
    sqInt contextSize3;
    sqInt field;
    sqInt field1;
    sqInt field2;
    sqInt field3;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt fmt3;
    sqInt format1;
    sqInt format11;
    sqInt format12;
    sqInt format13;
    sqInt format14;
    sqInt format15;
    sqInt format16;
    sqInt format17;
    char *frameRcvrOffset;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt index3;
    sqInt numLiterals;
    sqInt numLiterals1;
    sqInt numLiterals2;
    sqInt numLiterals3;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt numStrongSlots;
    sqInt numStrongSlots1;
    sqInt numStrongSlots2;
    sqInt numStrongSlots3;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop13;
    sqInt objOop14;
    sqInt objToScan;
    sqInt objToScan1;
    sqInt objToScan2;
    sqInt objToScan3;
    sqInt oop;
    sqInt referent;
    sqInt referent1;
    sqInt scanLargeObject;
    sqInt scanLargeObject1;
    sqInt scanLargeObject2;
    sqInt scanLargeObject3;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    char *theFP;
    char *theSP;

	numStrongSlots = 0;
	numStrongSlots1 = 0;
	numStrongSlots2 = 0;
	numStrongSlots3 = 0;
	assert(!(isFree(thePage)));
	assert(ifCurrentStackPageHasValidHeadPointers(thePage));
	assert(((thePage->trace)) != StackPageTraced);
	(thePage->trace = StackPageTraced);
	theSP = (thePage->headSP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	theFP = (thePage->headFP);
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (((oop & (tagMask())) == 0)
			 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop));
				referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent & (tagMask())) == 0)
				 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				oop = referent;
				longAtput(theSP, oop);
			}
			if (!((oop & (tagMask())) != 0)) {
				/* begin markAndTrace: */

				/* inline markAndShouldScan: */
				if ((oop & (tagMask())) != 0) {
					goto l1;
				}
				assert(!(isForwarded(oop)));
				if (((((usqInt) (longAt(oop))) >> 55) & 1) != 0) {
					goto l1;
				}
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(oop)));
				longAtput(oop, (longAt(oop)) | (1LL << 55));
				format1 = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
				if ((format1 >= (sixtyFourBitIndexableFormat()))
				 && (format1 < (firstCompiledMethodFormat()))) {

					/* avoid pushing non-pointer objects on the markStack. */
					/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
					if (((longAt(oop)) & (classIndexMask())) > 0x1F) {
						markAndTraceClassOf(oop);
					}
					goto l1;
				}
				if (format1 == (weakArrayFormat())) {

					/* push weaklings on the weakling stack to scan later */
					pushonObjStack(oop, GIV(weaklingStack));
					goto l1;
				}
				if ((format1 == 5)
				 && (activeAndDeferredScan(oop))) {
					goto l1;
				}
				/* end markAndShouldScan:; fall through */
;
				/* begin markLoopFrom: */

				/* To avoid overflowing the mark stack when we encounter large objects, we
				   push the obj, then its numStrongSlots, and then index the object from the stack. */
				objToScan = oop;
				do {
					if ((objToScan & (tagMask())) != 0) {
						scanLargeObject = 1;
					}
					else {
						/* begin numStrongSlotsOfInephemeral: */
						fmt = (((usqInt) (longAt(objToScan))) >> (formatShift())) & (formatMask());
						assert((fmt != (ephemeronFormat()))
						 || (isMarked(keyOfEphemeron(objToScan))));
						if (fmt <= 5) {
							/* begin numSlotsOf: */
							flag("endianness");
							assert((classIndexOf(objToScan)) > (isForwardedObjectClassIndexPun()));
							numSlots1 = byteAt(objToScan + 7);
							numSlots = (numSlots1 == (numSlotsMask())
								? ((usqInt) (((unsigned long)(((long)(longAt(objToScan - BaseHeaderSize))) << 8)))) >> 8
								: numSlots1);
							if (fmt <= 2) {
								numStrongSlots = numSlots;
								goto l14;
							}
							if (fmt == (indexablePointersFormat())) {
								if (((longAt(objToScan)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
									setTraceFlagOnContextsFramesPageIfNeeded(objToScan);
									/* begin fetchStackPointerOf: */
									sp = longAt((objToScan + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
									if (!((((sp) & 7) == 1))) {
										contextSize = 0;
										goto l13;
									}
									assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan)));
									contextSize = (sp >> 3);
								l13:	/* end fetchStackPointerOf: */;
									numStrongSlots = CtxtTempFrameStart + contextSize;
									goto l14;
								}
								numStrongSlots = numSlots;
								goto l14;
							}
							if (fmt == (weakArrayFormat())) {
								/* begin fixedFieldsOfClass: */
								objOop11 = fetchClassOfNonImm(objToScan);
								/* begin fixedFieldsOfClassFormat: */
								numStrongSlots = (((longAt((objOop11 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
								goto l14;
							}
						}
						if (fmt == 7) {
							numStrongSlots = 1;
							goto l14;
						}
						if (fmt < (firstCompiledMethodFormat())) {
							numStrongSlots = 0;
							goto l14;
						}
						/* begin methodHeaderOf: */
						assert(isCompiledMethod(objToScan));
						header = longAt((objToScan + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
						/* begin literalCountOfMethodHeader: */
						assert((((header) & 7) == 1));
						numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
						numStrongSlots = numLiterals + LiteralStart;
					l14:	/* end numStrongSlotsOfInephemeral: */;
						scanLargeObject = numStrongSlots > 64;
					}
					if (scanLargeObject) {

						/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
						if ((objToScan & (tagMask())) != 0) {
							index = (objToScan >> 3);
							objToScan = topOfObjStack(GIV(markStack));
						}
						else {
							index = numStrongSlots;
							markAndTraceClassOf(objToScan);
						}
						while (index > 0) {
							index -= 1;
							field = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
							if ((field & (tagMask())) == 0) {
								if (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

									/* fixFollowedField: is /not/ inlined */
									field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
								}
								if ((field & (tagMask())) != 0) {
									goto l5;
								}
								assert(!(isForwarded(field)));
								if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
									goto l5;
								}
								/* begin setIsMarkedOf:to: */
								assert(!(isFreeObject(field)));
								longAtput(field, (longAt(field)) | (1LL << 55));
								format14 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
								if ((format14 >= (sixtyFourBitIndexableFormat()))
								 && (format14 < (firstCompiledMethodFormat()))) {

									/* avoid pushing non-pointer objects on the markStack. */
									/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
									if (((longAt(field)) & (classIndexMask())) > 0x1F) {
										markAndTraceClassOf(field);
									}
									goto l5;
								}
								if (format14 == (weakArrayFormat())) {

									/* push weaklings on the weakling stack to scan later */
									pushonObjStack(field, GIV(weaklingStack));
									goto l5;
								}
								if ((format14 == 5)
								 && (activeAndDeferredScan(field))) {
									goto l5;
								}
								/* end markAndShouldScan:; fall through */
								if (index > 0) {
									if ((topOfObjStack(GIV(markStack))) != objToScan) {
										pushonObjStack(objToScan, GIV(markStack));
									}
									pushonObjStack(((index << 3) | 1), GIV(markStack));
								}
								objToScan = field;
								index = -1;
							l5:	;

							}
						}
						if (index >= 0) {

							/* if loop terminated without finding an unmarked referent, switch to top of stack. */
							objToScan = popObjStack(GIV(markStack));
							if (objToScan == oop) {
								objToScan = popObjStack(GIV(markStack));
							}
						}
					}
					else {

						/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
						index = numStrongSlots;
						markAndTraceClassOf(objToScan);
						while (index > 0) {
							index -= 1;
							field = longAt((objToScan + BaseHeaderSize) + (((long)index) << (shiftForWord())));
							if ((field & (tagMask())) == 0) {
								if (((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

									/* fixFollowedField: is /not/ inlined */
									field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
								}
								if ((field & (tagMask())) != 0) {
									goto l6;
								}
								assert(!(isForwarded(field)));
								if (((((usqInt) (longAt(field))) >> 55) & 1) != 0) {
									goto l6;
								}
								/* begin setIsMarkedOf:to: */
								assert(!(isFreeObject(field)));
								longAtput(field, (longAt(field)) | (1LL << 55));
								format14 = (((usqInt) (longAt(field))) >> (formatShift())) & (formatMask());
								if ((format14 >= (sixtyFourBitIndexableFormat()))
								 && (format14 < (firstCompiledMethodFormat()))) {

									/* avoid pushing non-pointer objects on the markStack. */
									/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
									if (((longAt(field)) & (classIndexMask())) > 0x1F) {
										markAndTraceClassOf(field);
									}
									goto l6;
								}
								if (format14 == (weakArrayFormat())) {

									/* push weaklings on the weakling stack to scan later */
									pushonObjStack(field, GIV(weaklingStack));
									goto l6;
								}
								if ((format14 == 5)
								 && (activeAndDeferredScan(field))) {
									goto l6;
								}
								/* end markAndShouldScan:; fall through */
								pushonObjStack(field, GIV(markStack));
								if (((byteAt(field + 7)) > 64)
								 && (((numStrongSlots = numStrongSlotsOfInephemeral(field))) > 64)) {
									pushonObjStack(((numStrongSlots << 3) | 1), GIV(markStack));
								}
							l6:	;

							}
						}
						objToScan = popObjStack(GIV(markStack));
					}
				} while(objToScan != null);
			l1:	/* end markAndTrace: */;
			}
			theSP += BytesPerWord;
		}
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			/* begin markAndTrace: */
			objOop = longAt(theFP + FoxThisContext);

			/* inline markAndShouldScan: */
			if ((objOop & (tagMask())) != 0) {
				goto l2;
			}
			assert(!(isForwarded(objOop)));
			if (((((usqInt) (longAt(objOop))) >> 55) & 1) != 0) {
				goto l2;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(objOop)));
			longAtput(objOop, (longAt(objOop)) | (1LL << 55));
			format11 = (((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask());
			if ((format11 >= (sixtyFourBitIndexableFormat()))
			 && (format11 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(objOop)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(objOop);
				}
				goto l2;
			}
			if (format11 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(objOop, GIV(weaklingStack));
				goto l2;
			}
			if ((format11 == 5)
			 && (activeAndDeferredScan(objOop))) {
				goto l2;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan1 = objOop;
			do {
				if ((objToScan1 & (tagMask())) != 0) {
					scanLargeObject1 = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt1 = (((usqInt) (longAt(objToScan1))) >> (formatShift())) & (formatMask());
					assert((fmt1 != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan1))));
					if (fmt1 <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan1)) > (isForwardedObjectClassIndexPun()));
						numSlots11 = byteAt(objToScan1 + 7);
						numSlots2 = (numSlots11 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan1 - BaseHeaderSize))) << 8)))) >> 8
							: numSlots11);
						if (fmt1 <= 2) {
							numStrongSlots1 = numSlots2;
							goto l16;
						}
						if (fmt1 == (indexablePointersFormat())) {
							if (((longAt(objToScan1)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan1);
								/* begin fetchStackPointerOf: */
								sp1 = longAt((objToScan1 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp1) & 7) == 1))) {
									contextSize1 = 0;
									goto l15;
								}
								assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(objToScan1)));
								contextSize1 = (sp1 >> 3);
							l15:	/* end fetchStackPointerOf: */;
								numStrongSlots1 = CtxtTempFrameStart + contextSize1;
								goto l16;
							}
							numStrongSlots1 = numSlots2;
							goto l16;
						}
						if (fmt1 == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop12 = fetchClassOfNonImm(objToScan1);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots1 = (((longAt((objOop12 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l16;
						}
					}
					if (fmt1 == 7) {
						numStrongSlots1 = 1;
						goto l16;
					}
					if (fmt1 < (firstCompiledMethodFormat())) {
						numStrongSlots1 = 0;
						goto l16;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan1));
					header1 = longAt((objToScan1 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header1) & 7) == 1));
					numLiterals1 = ((header1 >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots1 = numLiterals1 + LiteralStart;
				l16:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject1 = numStrongSlots1 > 64;
				}
				if (scanLargeObject1) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan1 & (tagMask())) != 0) {
						index1 = (objToScan1 >> 3);
						objToScan1 = topOfObjStack(GIV(markStack));
					}
					else {
						index1 = numStrongSlots1;
						markAndTraceClassOf(objToScan1);
					}
					while (index1 > 0) {
						index1 -= 1;
						field1 = longAt((objToScan1 + BaseHeaderSize) + (((long)index1) << (shiftForWord())));
						if ((field1 & (tagMask())) == 0) {
							if (((longAt(field1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field1 = fixFollowedFieldofObjectwithInitialValue(index1, objToScan1, field1);
							}
							if ((field1 & (tagMask())) != 0) {
								goto l7;
							}
							assert(!(isForwarded(field1)));
							if (((((usqInt) (longAt(field1))) >> 55) & 1) != 0) {
								goto l7;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field1)));
							longAtput(field1, (longAt(field1)) | (1LL << 55));
							format15 = (((usqInt) (longAt(field1))) >> (formatShift())) & (formatMask());
							if ((format15 >= (sixtyFourBitIndexableFormat()))
							 && (format15 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field1)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field1);
								}
								goto l7;
							}
							if (format15 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field1, GIV(weaklingStack));
								goto l7;
							}
							if ((format15 == 5)
							 && (activeAndDeferredScan(field1))) {
								goto l7;
							}
							/* end markAndShouldScan:; fall through */
							if (index1 > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan1) {
									pushonObjStack(objToScan1, GIV(markStack));
								}
								pushonObjStack(((index1 << 3) | 1), GIV(markStack));
							}
							objToScan1 = field1;
							index1 = -1;
						l7:	;

						}
					}
					if (index1 >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan1 = popObjStack(GIV(markStack));
						if (objToScan1 == objOop) {
							objToScan1 = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index1 = numStrongSlots1;
					markAndTraceClassOf(objToScan1);
					while (index1 > 0) {
						index1 -= 1;
						field1 = longAt((objToScan1 + BaseHeaderSize) + (((long)index1) << (shiftForWord())));
						if ((field1 & (tagMask())) == 0) {
							if (((longAt(field1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field1 = fixFollowedFieldofObjectwithInitialValue(index1, objToScan1, field1);
							}
							if ((field1 & (tagMask())) != 0) {
								goto l8;
							}
							assert(!(isForwarded(field1)));
							if (((((usqInt) (longAt(field1))) >> 55) & 1) != 0) {
								goto l8;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field1)));
							longAtput(field1, (longAt(field1)) | (1LL << 55));
							format15 = (((usqInt) (longAt(field1))) >> (formatShift())) & (formatMask());
							if ((format15 >= (sixtyFourBitIndexableFormat()))
							 && (format15 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field1)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field1);
								}
								goto l8;
							}
							if (format15 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field1, GIV(weaklingStack));
								goto l8;
							}
							if ((format15 == 5)
							 && (activeAndDeferredScan(field1))) {
								goto l8;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field1, GIV(markStack));
							if (((byteAt(field1 + 7)) > 64)
							 && (((numStrongSlots1 = numStrongSlotsOfInephemeral(field1))) > 64)) {
								pushonObjStack(((numStrongSlots1 << 3) | 1), GIV(markStack));
							}
						l8:	;

						}
					}
					objToScan1 = popObjStack(GIV(markStack));
				}
			} while(objToScan1 != null);
		l2:	/* end markAndTrace: */;
		}
		/* begin markAndTrace: */
		objOop1 = longAt(theFP + FoxMethod);

		/* inline markAndShouldScan: */
		if ((objOop1 & (tagMask())) != 0) {
			goto l3;
		}
		assert(!(isForwarded(objOop1)));
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			goto l3;
		}
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(objOop1)));
		longAtput(objOop1, (longAt(objOop1)) | (1LL << 55));
		format12 = (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask());
		if ((format12 >= (sixtyFourBitIndexableFormat()))
		 && (format12 < (firstCompiledMethodFormat()))) {

			/* avoid pushing non-pointer objects on the markStack. */
			/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
			if (((longAt(objOop1)) & (classIndexMask())) > 0x1F) {
				markAndTraceClassOf(objOop1);
			}
			goto l3;
		}
		if (format12 == (weakArrayFormat())) {

			/* push weaklings on the weakling stack to scan later */
			pushonObjStack(objOop1, GIV(weaklingStack));
			goto l3;
		}
		if ((format12 == 5)
		 && (activeAndDeferredScan(objOop1))) {
			goto l3;
		}
		/* end markAndShouldScan:; fall through */
;
		/* begin markLoopFrom: */

		/* To avoid overflowing the mark stack when we encounter large objects, we
		   push the obj, then its numStrongSlots, and then index the object from the stack. */
		objToScan2 = objOop1;
		do {
			if ((objToScan2 & (tagMask())) != 0) {
				scanLargeObject2 = 1;
			}
			else {
				/* begin numStrongSlotsOfInephemeral: */
				fmt2 = (((usqInt) (longAt(objToScan2))) >> (formatShift())) & (formatMask());
				assert((fmt2 != (ephemeronFormat()))
				 || (isMarked(keyOfEphemeron(objToScan2))));
				if (fmt2 <= 5) {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objToScan2)) > (isForwardedObjectClassIndexPun()));
					numSlots12 = byteAt(objToScan2 + 7);
					numSlots3 = (numSlots12 == (numSlotsMask())
						? ((usqInt) (((unsigned long)(((long)(longAt(objToScan2 - BaseHeaderSize))) << 8)))) >> 8
						: numSlots12);
					if (fmt2 <= 2) {
						numStrongSlots2 = numSlots3;
						goto l18;
					}
					if (fmt2 == (indexablePointersFormat())) {
						if (((longAt(objToScan2)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
							setTraceFlagOnContextsFramesPageIfNeeded(objToScan2);
							/* begin fetchStackPointerOf: */
							sp2 = longAt((objToScan2 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
							if (!((((sp2) & 7) == 1))) {
								contextSize2 = 0;
								goto l17;
							}
							assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(objToScan2)));
							contextSize2 = (sp2 >> 3);
						l17:	/* end fetchStackPointerOf: */;
							numStrongSlots2 = CtxtTempFrameStart + contextSize2;
							goto l18;
						}
						numStrongSlots2 = numSlots3;
						goto l18;
					}
					if (fmt2 == (weakArrayFormat())) {
						/* begin fixedFieldsOfClass: */
						objOop13 = fetchClassOfNonImm(objToScan2);
						/* begin fixedFieldsOfClassFormat: */
						numStrongSlots2 = (((longAt((objOop13 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
						goto l18;
					}
				}
				if (fmt2 == 7) {
					numStrongSlots2 = 1;
					goto l18;
				}
				if (fmt2 < (firstCompiledMethodFormat())) {
					numStrongSlots2 = 0;
					goto l18;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objToScan2));
				header2 = longAt((objToScan2 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
				/* begin literalCountOfMethodHeader: */
				assert((((header2) & 7) == 1));
				numLiterals2 = ((header2 >> 3)) & AlternateHeaderNumLiteralsMask;
				numStrongSlots2 = numLiterals2 + LiteralStart;
			l18:	/* end numStrongSlotsOfInephemeral: */;
				scanLargeObject2 = numStrongSlots2 > 64;
			}
			if (scanLargeObject2) {

				/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
				if ((objToScan2 & (tagMask())) != 0) {
					index2 = (objToScan2 >> 3);
					objToScan2 = topOfObjStack(GIV(markStack));
				}
				else {
					index2 = numStrongSlots2;
					markAndTraceClassOf(objToScan2);
				}
				while (index2 > 0) {
					index2 -= 1;
					field2 = longAt((objToScan2 + BaseHeaderSize) + (((long)index2) << (shiftForWord())));
					if ((field2 & (tagMask())) == 0) {
						if (((longAt(field2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field2 = fixFollowedFieldofObjectwithInitialValue(index2, objToScan2, field2);
						}
						if ((field2 & (tagMask())) != 0) {
							goto l9;
						}
						assert(!(isForwarded(field2)));
						if (((((usqInt) (longAt(field2))) >> 55) & 1) != 0) {
							goto l9;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field2)));
						longAtput(field2, (longAt(field2)) | (1LL << 55));
						format16 = (((usqInt) (longAt(field2))) >> (formatShift())) & (formatMask());
						if ((format16 >= (sixtyFourBitIndexableFormat()))
						 && (format16 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field2)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field2);
							}
							goto l9;
						}
						if (format16 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field2, GIV(weaklingStack));
							goto l9;
						}
						if ((format16 == 5)
						 && (activeAndDeferredScan(field2))) {
							goto l9;
						}
						/* end markAndShouldScan:; fall through */
						if (index2 > 0) {
							if ((topOfObjStack(GIV(markStack))) != objToScan2) {
								pushonObjStack(objToScan2, GIV(markStack));
							}
							pushonObjStack(((index2 << 3) | 1), GIV(markStack));
						}
						objToScan2 = field2;
						index2 = -1;
					l9:	;

					}
				}
				if (index2 >= 0) {

					/* if loop terminated without finding an unmarked referent, switch to top of stack. */
					objToScan2 = popObjStack(GIV(markStack));
					if (objToScan2 == objOop1) {
						objToScan2 = popObjStack(GIV(markStack));
					}
				}
			}
			else {

				/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
				index2 = numStrongSlots2;
				markAndTraceClassOf(objToScan2);
				while (index2 > 0) {
					index2 -= 1;
					field2 = longAt((objToScan2 + BaseHeaderSize) + (((long)index2) << (shiftForWord())));
					if ((field2 & (tagMask())) == 0) {
						if (((longAt(field2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

							/* fixFollowedField: is /not/ inlined */
							field2 = fixFollowedFieldofObjectwithInitialValue(index2, objToScan2, field2);
						}
						if ((field2 & (tagMask())) != 0) {
							goto l10;
						}
						assert(!(isForwarded(field2)));
						if (((((usqInt) (longAt(field2))) >> 55) & 1) != 0) {
							goto l10;
						}
						/* begin setIsMarkedOf:to: */
						assert(!(isFreeObject(field2)));
						longAtput(field2, (longAt(field2)) | (1LL << 55));
						format16 = (((usqInt) (longAt(field2))) >> (formatShift())) & (formatMask());
						if ((format16 >= (sixtyFourBitIndexableFormat()))
						 && (format16 < (firstCompiledMethodFormat()))) {

							/* avoid pushing non-pointer objects on the markStack. */
							/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
							if (((longAt(field2)) & (classIndexMask())) > 0x1F) {
								markAndTraceClassOf(field2);
							}
							goto l10;
						}
						if (format16 == (weakArrayFormat())) {

							/* push weaklings on the weakling stack to scan later */
							pushonObjStack(field2, GIV(weaklingStack));
							goto l10;
						}
						if ((format16 == 5)
						 && (activeAndDeferredScan(field2))) {
							goto l10;
						}
						/* end markAndShouldScan:; fall through */
						pushonObjStack(field2, GIV(markStack));
						if (((byteAt(field2 + 7)) > 64)
						 && (((numStrongSlots2 = numStrongSlotsOfInephemeral(field2))) > 64)) {
							pushonObjStack(((numStrongSlots2 << 3) | 1), GIV(markStack));
						}
					l10:	;

					}
				}
				objToScan2 = popObjStack(GIV(markStack));
			}
		} while(objToScan2 != null);
	l3:	/* end markAndTrace: */;
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */
	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (((oop & (tagMask())) == 0)
		 && (((longAt(oop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop));
			referent1 = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
			while (((referent1 & (tagMask())) == 0)
			 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
			}
			oop = referent1;
			longAtput(theSP, oop);
		}
		if (!((oop & (tagMask())) != 0)) {
			/* begin markAndTrace: */

			/* inline markAndShouldScan: */
			if ((oop & (tagMask())) != 0) {
				goto l4;
			}
			assert(!(isForwarded(oop)));
			if (((((usqInt) (longAt(oop))) >> 55) & 1) != 0) {
				goto l4;
			}
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop)));
			longAtput(oop, (longAt(oop)) | (1LL << 55));
			format13 = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
			if ((format13 >= (sixtyFourBitIndexableFormat()))
			 && (format13 < (firstCompiledMethodFormat()))) {

				/* avoid pushing non-pointer objects on the markStack. */
				/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
				if (((longAt(oop)) & (classIndexMask())) > 0x1F) {
					markAndTraceClassOf(oop);
				}
				goto l4;
			}
			if (format13 == (weakArrayFormat())) {

				/* push weaklings on the weakling stack to scan later */
				pushonObjStack(oop, GIV(weaklingStack));
				goto l4;
			}
			if ((format13 == 5)
			 && (activeAndDeferredScan(oop))) {
				goto l4;
			}
			/* end markAndShouldScan:; fall through */
;
			/* begin markLoopFrom: */

			/* To avoid overflowing the mark stack when we encounter large objects, we
			   push the obj, then its numStrongSlots, and then index the object from the stack. */
			objToScan3 = oop;
			do {
				if ((objToScan3 & (tagMask())) != 0) {
					scanLargeObject3 = 1;
				}
				else {
					/* begin numStrongSlotsOfInephemeral: */
					fmt3 = (((usqInt) (longAt(objToScan3))) >> (formatShift())) & (formatMask());
					assert((fmt3 != (ephemeronFormat()))
					 || (isMarked(keyOfEphemeron(objToScan3))));
					if (fmt3 <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objToScan3)) > (isForwardedObjectClassIndexPun()));
						numSlots13 = byteAt(objToScan3 + 7);
						numSlots4 = (numSlots13 == (numSlotsMask())
							? ((usqInt) (((unsigned long)(((long)(longAt(objToScan3 - BaseHeaderSize))) << 8)))) >> 8
							: numSlots13);
						if (fmt3 <= 2) {
							numStrongSlots3 = numSlots4;
							goto l20;
						}
						if (fmt3 == (indexablePointersFormat())) {
							if (((longAt(objToScan3)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(objToScan3);
								/* begin fetchStackPointerOf: */
								sp3 = longAt((objToScan3 + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
								if (!((((sp3) & 7) == 1))) {
									contextSize3 = 0;
									goto l19;
								}
								assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(objToScan3)));
								contextSize3 = (sp3 >> 3);
							l19:	/* end fetchStackPointerOf: */;
								numStrongSlots3 = CtxtTempFrameStart + contextSize3;
								goto l20;
							}
							numStrongSlots3 = numSlots4;
							goto l20;
						}
						if (fmt3 == (weakArrayFormat())) {
							/* begin fixedFieldsOfClass: */
							objOop14 = fetchClassOfNonImm(objToScan3);
							/* begin fixedFieldsOfClassFormat: */
							numStrongSlots3 = (((longAt((objOop14 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
							goto l20;
						}
					}
					if (fmt3 == 7) {
						numStrongSlots3 = 1;
						goto l20;
					}
					if (fmt3 < (firstCompiledMethodFormat())) {
						numStrongSlots3 = 0;
						goto l20;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objToScan3));
					header3 = longAt((objToScan3 + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
					/* begin literalCountOfMethodHeader: */
					assert((((header3) & 7) == 1));
					numLiterals3 = ((header3 >> 3)) & AlternateHeaderNumLiteralsMask;
					numStrongSlots3 = numLiterals3 + LiteralStart;
				l20:	/* end numStrongSlotsOfInephemeral: */;
					scanLargeObject3 = numStrongSlots3 > 64;
				}
				if (scanLargeObject3) {

					/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
					if ((objToScan3 & (tagMask())) != 0) {
						index3 = (objToScan3 >> 3);
						objToScan3 = topOfObjStack(GIV(markStack));
					}
					else {
						index3 = numStrongSlots3;
						markAndTraceClassOf(objToScan3);
					}
					while (index3 > 0) {
						index3 -= 1;
						field3 = longAt((objToScan3 + BaseHeaderSize) + (((long)index3) << (shiftForWord())));
						if ((field3 & (tagMask())) == 0) {
							if (((longAt(field3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field3 = fixFollowedFieldofObjectwithInitialValue(index3, objToScan3, field3);
							}
							if ((field3 & (tagMask())) != 0) {
								goto l11;
							}
							assert(!(isForwarded(field3)));
							if (((((usqInt) (longAt(field3))) >> 55) & 1) != 0) {
								goto l11;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field3)));
							longAtput(field3, (longAt(field3)) | (1LL << 55));
							format17 = (((usqInt) (longAt(field3))) >> (formatShift())) & (formatMask());
							if ((format17 >= (sixtyFourBitIndexableFormat()))
							 && (format17 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field3)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field3);
								}
								goto l11;
							}
							if (format17 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field3, GIV(weaklingStack));
								goto l11;
							}
							if ((format17 == 5)
							 && (activeAndDeferredScan(field3))) {
								goto l11;
							}
							/* end markAndShouldScan:; fall through */
							if (index3 > 0) {
								if ((topOfObjStack(GIV(markStack))) != objToScan3) {
									pushonObjStack(objToScan3, GIV(markStack));
								}
								pushonObjStack(((index3 << 3) | 1), GIV(markStack));
							}
							objToScan3 = field3;
							index3 = -1;
						l11:	;

						}
					}
					if (index3 >= 0) {

						/* if loop terminated without finding an unmarked referent, switch to top of stack. */
						objToScan3 = popObjStack(GIV(markStack));
						if (objToScan3 == oop) {
							objToScan3 = popObjStack(GIV(markStack));
						}
					}
				}
				else {

					/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
					index3 = numStrongSlots3;
					markAndTraceClassOf(objToScan3);
					while (index3 > 0) {
						index3 -= 1;
						field3 = longAt((objToScan3 + BaseHeaderSize) + (((long)index3) << (shiftForWord())));
						if ((field3 & (tagMask())) == 0) {
							if (((longAt(field3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {

								/* fixFollowedField: is /not/ inlined */
								field3 = fixFollowedFieldofObjectwithInitialValue(index3, objToScan3, field3);
							}
							if ((field3 & (tagMask())) != 0) {
								goto l12;
							}
							assert(!(isForwarded(field3)));
							if (((((usqInt) (longAt(field3))) >> 55) & 1) != 0) {
								goto l12;
							}
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(field3)));
							longAtput(field3, (longAt(field3)) | (1LL << 55));
							format17 = (((usqInt) (longAt(field3))) >> (formatShift())) & (formatMask());
							if ((format17 >= (sixtyFourBitIndexableFormat()))
							 && (format17 < (firstCompiledMethodFormat()))) {

								/* avoid pushing non-pointer objects on the markStack. */
								/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
								if (((longAt(field3)) & (classIndexMask())) > 0x1F) {
									markAndTraceClassOf(field3);
								}
								goto l12;
							}
							if (format17 == (weakArrayFormat())) {

								/* push weaklings on the weakling stack to scan later */
								pushonObjStack(field3, GIV(weaklingStack));
								goto l12;
							}
							if ((format17 == 5)
							 && (activeAndDeferredScan(field3))) {
								goto l12;
							}
							/* end markAndShouldScan:; fall through */
							pushonObjStack(field3, GIV(markStack));
							if (((byteAt(field3 + 7)) > 64)
							 && (((numStrongSlots3 = numStrongSlotsOfInephemeral(field3))) > 64)) {
								pushonObjStack(((numStrongSlots3 << 3) | 1), GIV(markStack));
							}
						l12:	;

						}
					}
					objToScan3 = popObjStack(GIV(markStack));
				}
			} while(objToScan3 != null);
		l4:	/* end markAndTrace: */;
		}
		theSP += BytesPerWord;
	}
}


/*	Trace any untraced pages */

	/* StackInterpreter>>#markAndTraceUntracedReachableStackPages */
static void
markAndTraceUntracedReachableStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt foundToBeTracedPage;
    sqInt i;
    StackPage *thePage;

	do {
		foundToBeTracedPage = 0;
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if ((!(isFree(thePage)))
			 && (((thePage->trace)) == StackPageReachedButUntraced)) {
				foundToBeTracedPage = 1;
				markAndTraceStackPage(thePage);
			}
		}
	} while(foundToBeTracedPage);
}


/*	This is a helper for primitiveObjectPointsTo so it *does not* check the
	frameContext field because that is an implicit self-reference not present
	in the state .
 */

	/* StackInterpreter>>#marriedContext:pointsTo:stackDeltaForCurrentFrame: */
static sqInt NoDbgRegParms
marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *rcvrOffset;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	/* begin frameOfMarriedContext: */
	senderOop = longAt((spouseContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFP = pointerForOop(senderOop - 1);
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer) + (stackDeltaForCurrentFrame * BytesPerWord);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		theSP = findSPOfon(theFP, thePage);
	}
	if ((((anOop) & 7) == 1)) {

		/* Check stack and instruction pointer fields. */
		if ((anOop == (((((((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1))) << 3) | 1)))
		 || (anOop == (externalInstVarofContext(InstructionPointerIndex, spouseContext)))) {
			return 1;
		}
	}
	else {

		/* Check method and sender fields, avoiding unnecessarily reifying sender context. */
		if (anOop == (longAt(theFP + FoxMethod))) {
			return 1;
		}
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			if (anOop == (longAt(theFP + FoxCallerContext))) {
				return 1;
			}
		}
		else {
			if (((byteAt(((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxFrameFlags) + 2)) != 0)
			 && (anOop == (longAt((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxThisContext)))) {
				return 1;
			}
		}
	}
	rcvrOffset = theFP + FoxReceiver;
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	rcvrOffset = theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())));
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	return 0;
}


/*	Establish aContext at the base of a new stackPage, make the stackPage the
	active one and set-up the interreter registers. This is used to boot the
	system and bring it back after a snapshot. */

	/* StackInterpreter>>#marryContextInNewStackPageAndInitializeInterpreterRegisters: */
static void NoDbgRegParms
marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    StackPage *newPage;
    sqInt top;

	assert(GIV(stackPage) == 0);
	newPage = makeBaseFrameFor(aContext);
	/* begin setStackPageAndLimit: */
	assert(newPage != 0);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	/* begin setMethod: */
	aMethodObj = longAt(((GIV(stackPage)->headFP)) + FoxMethod);
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
}


/*	Marry an unmarried frame. This means creating a spouse context
	initialized with a subset of the frame's state (state through the last
	argument) that references the frame. */

	/* StackInterpreter>>#marryFrame:SP: */
static sqInt NoDbgRegParms
marryFrameSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;
    sqInt frameNumArgs;
    sqInt i;
    sqInt methodHeader;
    sqInt methodObj;
    sqInt numArgs;
    sqInt numSlots;
    sqInt numStack;
    sqInt numTemps;
    sqInt theContext;
    char *value;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	/* begin marryFrame:SP:copyTemps: */
	assert(!(frameHasContext(theFP)));
	assert(addressCouldBeOop(longAt(theSP)));
	/* begin methodHeaderOf: */
	methodObj = longAt(theFP + FoxMethod);
	assert(isCompiledMethod(methodObj));
	methodHeader = longAt((methodObj + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	numStack = (((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
	if ((byteAt((theFP + FoxFrameFlags) + 3)) != 0) {
		closureOrNil = longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()))));
	}
	else {
		closureOrNil = GIV(nilObj);
	}
	numSlots = ((methodHeader & LargeContextBit) != 0
		? LargeContextSlots
		: SmallContextSlots);
	theContext = allocateNewSpaceSlotsformatclassIndex(numSlots, indexablePointersFormat(), ClassMethodContextCompactIndex);
	assert((numStack + ReceiverIndex) <= numSlots);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(((oopForPointer(theFP)) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(theFP)) + 1;
	assert(!(isForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	value = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer2 = (oopForPointer(value)) + 1;
	assert(!(isForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), valuePointer2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())), ((numStack << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())), longAt(theFP + FoxMethod));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((long)ClosureIndex) << (shiftForWord())), closureOrNil);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((long)ReceiverIndex) << (shiftForWord())), longAt(theFP + FoxReceiver));
	for (i = 1; i <= numArgs; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		longAtput((theContext + BaseHeaderSize) + (((long)(ReceiverIndex + i)) << (shiftForWord())), longAt((theFP + FoxCallerSavedIP) + (((numArgs - i) + 1) * BytesPerWord)));
	}
	for (i = (numArgs + 1); i <= numStack; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		longAtput((theContext + BaseHeaderSize) + (((long)(ReceiverIndex + i)) << (shiftForWord())), GIV(nilObj));
	}
	/* begin setFrameContext:to: */
	longAtput(theFP + FoxThisContext, theContext);
	/* begin setFrameHasContext: */
	byteAtput((theFP + FoxFrameFlags) + 2, 1);
	assert(frameHasContext(theFP));
	assert((frameOfMarriedContext(theContext)) == theFP);
	assert((numStack + ReceiverIndex) < (lengthOf(theContext)));
	return theContext;
}


/*	Answer the selector of a method, assuming its penultimate literal is
	either a symbol or a pointer object whose first slot references the method
	and whose second slot is a symbol (i.e. an AdditionalMethodState). If a
	Symbol can't be found answer nil. This isn't satisfactory, as it puts a
	lot of information
	into the VM, but it is needed for adequate crash debugging at Cadence. */

	/* StackInterpreter>>#maybeSelectorOfMethod: */
static sqInt NoDbgRegParms
maybeSelectorOfMethod(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeSelector;
    sqInt offset;
    sqInt penultimateLiteral;

	assert(isOopCompiledMethod(methodObj));
	/* begin penultimateLiteralOf: */
	assert(isOopCompiledMethod(methodObj));
	/* begin literal:ofMethod: */
	offset = (literalCountOfMethodHeader(methodHeaderOf(methodObj))) - 2;
	penultimateLiteral = longAt((methodObj + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
	if (((penultimateLiteral & (tagMask())) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(penultimateLiteral))) >> (formatShift())) & (formatMask())))) {
		return (((longAt(penultimateLiteral)) & (classIndexMask())) == (fetchClassTagOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorDoesNotUnderstand) << (shiftForWord())))))
			? penultimateLiteral
			: 0);
	}
	return ((((penultimateLiteral & (tagMask())) == 0)
	 && (((((usqInt) (longAt(penultimateLiteral))) >> (formatShift())) & (formatMask())) <= 5))
	 && (((numSlotsOf(penultimateLiteral)) >= 2)
	 && (((longAt((penultimateLiteral + BaseHeaderSize) + (0LL << (shiftForWord())))) == methodObj)
	 && (((maybeSelector = longAt((penultimateLiteral + BaseHeaderSize) + (1LL << (shiftForWord())))),
	(((maybeSelector & (tagMask())) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(maybeSelector))) >> (formatShift())) & (formatMask()))))
		 && (((longAt(maybeSelector)) & (classIndexMask())) == (fetchClassTagOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorDoesNotUnderstand) << (shiftForWord()))))))))))
		? maybeSelector
		: 0);
}

	/* StackInterpreter>>#methodArgumentCount */
sqInt
methodArgumentCount(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(argumentCount);
}


/*	Like #stackValue: but access method arguments left-to-right */

	/* StackInterpreter>>#methodArg: */
sqInt
methodArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((index > GIV(argumentCount)) + 1) {
		fprintf(stderr,"[VM]: Attempt to access method args beyond range\n");
		printCallStack();
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return longAt(GIV(stackPointer) + ((GIV(argumentCount) - index) * BytesPerWord));
}

	/* StackInterpreter>>#methodClassAssociationOf: */
sqInt
methodClassAssociationOf(sqInt methodPointer)
{
    sqInt offset;

	/* begin literal:ofMethod: */
	offset = (literalCountOfMethodHeader(methodHeaderOf(methodPointer))) - 1;
	return longAt((methodPointer + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
}


/*	Using a read barrier here simplifies the become implementation and costs
	very little
	because the class index and ValueIndex of the association almost certainly
	share a cache line.
 */

	/* StackInterpreter>>#methodClassOf: */
sqInt
methodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt offset;

	/* begin followLiteral:ofMethod: */
	offset = (literalCountOfMethodHeader(methodHeaderOf(methodPointer))) - 1;
	/* begin followField:ofObject: */
	objOop2 = longAt((methodPointer + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
	if (((objOop2 & (tagMask())) == 0)
	 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop2 = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, methodPointer, objOop2);
	}
	literal = objOop2;
	return (literal == GIV(nilObj)
		? literal
		: (/* begin followField:ofObject: */
			(objOop = longAt((literal + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())))),
			(((objOop & (tagMask())) == 0)
				 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))
					? (objOop = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop))
					: 0),
			objOop));
}

	/* StackInterpreter>>#methodHeaderIndicatesLargeFrame: */
static sqInt NoDbgRegParms
methodHeaderIndicatesLargeFrame(sqInt methodHeader)
{
	return (methodHeader & LargeContextBit) != 0;
}

	/* StackInterpreter>>#methodPrimitiveIndex */
sqInt
methodPrimitiveIndex(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt methodHeader;
    sqInt primBits;

	if (!((addressCouldBeObj(GIV(newMethod)))
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return -1;
	}
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	return (methodHeader & AlternateHeaderHasPrimFlag
		? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8))
		: 0);
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnValue: */
sqInt
methodReturnValue(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	A negative header selects the alternate bytecode set. */

	/* StackInterpreter>>#methodUsesAlternateBytecodeSet: */
sqInt
methodUsesAlternateBytecodeSet(sqInt aMethodObj)
{
    sqInt methodHeader;

	/* begin headerIndicatesAlternateBytecodeSet: */
	assert(isCompiledMethod(aMethodObj));
	methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	return (((int) methodHeader)) < 0;
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

	/* StackInterpreter>>#moduleUnloaded: */
EXPORT(void)
moduleUnloaded(char *aModuleName)
{
	if ((strcmp(aModuleName, "SurfacePlugin")) == 0) {

		/* Surface plugin went away. Should never happen. But  then, who knows */
		showSurfaceFn = 0;
	}
}


/*	Move frames from the hot end of oldPage through to theFP to newPage.
	This has the effect of making theFP a base frame which can be stored into.
	Answer theFP's new location. */

	/* StackInterpreter>>#moveFramesIn:through:toPage: */
static char * NoDbgRegParms
moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage)
{
    char *callerFP;
    sqInt callerIP;
    int delta;
    char *fpInNewPage;
    char *newFP;
    char *newSP;
    char *offsetCallerFP;
    char *source;
    sqInt stackedReceiverOffset;
    sqInt theContext;
    char *theFP1;
    sqInt valuePointer;
    sqInt valuePointer1;

	newSP = ((newPage->baseAddress)) + BytesPerWord;

	/* First move the data.  We will fix up frame pointers later. */
	stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()));
	for (source = (theFP + stackedReceiverOffset); source >= ((oldPage->headSP)); source += (-BytesPerWord)) {
		newSP -= BytesPerWord;
		longAtput(newSP, longAt(source));
	}
	delta = newSP - ((oldPage->headSP));
	newFP = ((newPage->baseAddress)) - stackedReceiverOffset;
	/* begin setHeadFP:andSP:inPage: */
	theFP1 = ((oldPage->headFP)) + delta;
	assert(newSP < theFP1);
	assert((newSP < ((newPage->baseAddress)))
	 && (newSP > (((newPage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((theFP1 < ((newPage->baseAddress)))
	 && (theFP1 > (((newPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(newPage->headFP = theFP1);
	(newPage->headSP = newSP);
	(newPage->baseFP = newFP);
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(!(isBaseFrame(theFP)));
	assert(frameHasContext(callerFP));
	callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
	longAtput(theFP + stackedReceiverOffset, callerIP);
	assert((callerFP < ((oldPage->baseAddress)))
	 && (callerFP > (((oldPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(oldPage->headFP = callerFP);
	(oldPage->headSP = theFP + stackedReceiverOffset);
	longAtput(newFP + FoxCallerContext, longAt(callerFP + FoxThisContext));
	longAtput(newFP + FoxSavedFP, 0);
	fpInNewPage = (newPage->headFP);
	do {
		offsetCallerFP = pointerForOop(longAt(fpInNewPage + FoxSavedFP));
		if (offsetCallerFP != 0) {
			offsetCallerFP += delta;
		}
		longAtput(fpInNewPage + FoxSavedFP, oopForPointer(offsetCallerFP));
		if ((byteAt((fpInNewPage + FoxFrameFlags) + 2)) != 0) {
			theContext = longAt(fpInNewPage + FoxThisContext);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(((oopForPointer(fpInNewPage)) & (BytesPerWord - 1)) == 0);
			valuePointer = (oopForPointer(fpInNewPage)) + 1;
			assert(!(isForwarded(theContext)));
			longAtput((theContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), valuePointer);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(((oopForPointer(offsetCallerFP)) & (BytesPerWord - 1)) == 0);
			valuePointer1 = (oopForPointer(offsetCallerFP)) + 1;
			assert(!(isForwarded(theContext)));
			longAtput((theContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), valuePointer1);
		}
		fpInNewPage = offsetCallerFP;
	} while(fpInNewPage != 0);
	return newFP;
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass: */
static char * NoDbgRegParms
nameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(classOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(classOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = longAt((classOop + BaseHeaderSize) + (((long)GIV(thisClassIndex)) << (shiftForWord())));
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClass(longAt((classOop + BaseHeaderSize) + (((long)GIV(thisClassIndex)) << (shiftForWord()))));
		}
		return "bad class";
	}
	if (!((numSlots > GIV(classNameIndex))
		 && (((maybeNameOop = longAt((classOop + BaseHeaderSize) + (((long)GIV(classNameIndex)) << (shiftForWord())))),
		((maybeNameOop & (tagMask())) == 0)
			 && (((((usqInt) (longAt(maybeNameOop))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))))) {
		return "bad class";
	}
	return firstIndexableField(maybeNameOop);
}

	/* StackInterpreter>>#noInlineTemporary:in: */
static sqInt NoDbgRegParms
noInlineTemporaryin(sqInt offset, char *theFP)
{
    sqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord))
		: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord)));
}

	/* StackInterpreter>>#noInlineTemporary:in:put: */
static sqInt NoDbgRegParms
noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop)
{
    sqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAtput((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord), valueOop)
		: longAtput(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord), valueOop));
}


/*	Answer true if there are no marked contexts on thePage. */

	/* StackInterpreter>>#noMarkedContextsOnPage: */
static sqInt NoDbgRegParms
noMarkedContextsOnPage(StackPage *thePage)
{
    char *theFP;

	assert(!(isFree(thePage)));
	theFP = (thePage->headFP);
	do {
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			if (((((usqInt) (longAt(longAt(theFP + FoxThisContext)))) >> 55) & 1) != 0) {
				return 0;
			}
		}
	} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
	return 1;
}


/*	Answer the number of effective pointer fields in the given context. */

	/* StackInterpreter>>#numSlotsOfMarriedContext: */
static sqInt NoDbgRegParms
numSlotsOfMarriedContext(sqInt aContext)
{
    sqInt contextSize;

	contextSize = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
	return CtxtTempFrameStart + contextSize;
}

	/* StackInterpreter>>#numStkPages */
static sqInt
numStkPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(numStackPages);
}


/*	Answer if objOop looks like a class object. WIth Spur be lenient if the
	object doesn't
	yet have a hash (i.e. is not yet in the classTable), and accept forwarding
	pointers. 
 */

	/* StackInterpreter>>#objCouldBeClassObj: */
static sqInt NoDbgRegParms
objCouldBeClassObj(sqInt objOop)
{
    sqInt fieldOop;

	return (((((usqInt) (longAt(objOop))) >> (formatShift())) & (formatMask())) <= 5)
	 && (((numSlotsOfAny(objOop)) > InstanceSpecificationIndex)
	 && (((fieldOop = longAt((objOop + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())))),
	(((fieldOop & (tagMask())) == 0)
		 && ((((((usqInt) (longAt(fieldOop))) >> (formatShift())) & (formatMask())) <= 5)
		 || ((((fieldOop & (tagMask())) == 0)
		 && (((longAt(fieldOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
		 && (isPointers(followForwarded(fieldOop))))))
		 && (((fieldOop = longAt((objOop + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())))),
		(((fieldOop & (tagMask())) == 0)
			 && ((((((usqInt) (longAt(fieldOop))) >> (formatShift())) & (formatMask())) <= 5)
			 || ((((fieldOop & (tagMask())) == 0)
			 && (((longAt(fieldOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
			 && (isPointers(followForwarded(fieldOop))))))
			 && (((((longAt((objOop + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord()))))) & 7) == 1)))))));
}


/*	Like #stackObjectValue: but access method arguments left-to-right */

	/* StackInterpreter>>#objectArg: */
sqInt
objectArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0;
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}

	/* StackInterpreter>>#penultimateLiteralOf: */
sqInt
penultimateLiteralOf(sqInt aMethodOop)
{
    sqInt offset;

	assert(isOopCompiledMethod(aMethodOop));
	/* begin literal:ofMethod: */
	offset = (literalCountOfMethodHeader(methodHeaderOf(aMethodOop))) - 2;
	return longAt((aMethodOop + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#popStack */
sqInt
popStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	return top;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop: */
sqInt
pop(sqInt nItems)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(stackPointer) += nItems * BytesPerWord;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop:thenPush: */
void
popthenPush(sqInt nItems, sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) + ((nItems - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	integerValue is interpreted as POSITIVE, e.g. as the result of Bitmap>at:.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* StackInterpreter>>#positive32BitIntegerFor: */
sqInt
positive32BitIntegerFor(sqInt integerValue)
{
	return (((integerValue & 0xFFFFFFFFULL) << 3) | 1);

}


/*	Answer a Large Positive Integer object for the given integer value. N.B.
	will *not* cause a GC. */

	/* StackInterpreter>>#positive64BitIntegerFor: */
sqInt
positive64BitIntegerFor(sqLong integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt highWord;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt sz;

	if ((integerValue >= 0)
	 && ((((((unsigned sqLong)integerValue) >> 60) + 1) & 15) <= 1)) {
		return ((integerValue << 3) | 1);
	}
	sz = 8;

	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = (firstByteFormat()) + ((8 - sz) & (BytesPerWord - 1));
	numSlots = 8 / BytesPerOop;
	assert((numSlots >= 0)
	 && (ClassLargePositiveIntegerCompactIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
l1:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	
#  if VMBIGENDIAN
	byteAtput((newLargeInteger + BaseHeaderSize) + 7, (((unsigned sqLong)integerValue) >> 56) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 6, (((unsigned sqLong)integerValue) >> 48) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 5, (((unsigned sqLong)integerValue) >> 40) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 4, (((unsigned sqLong)integerValue) >> 32) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((unsigned sqLong)integerValue) >> 24) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((unsigned sqLong)integerValue) >> 16) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((unsigned sqLong)integerValue) >> 8) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#  else /* VMBIGENDIAN */
	long64Atput((newLargeInteger + BaseHeaderSize) + (0LL << 3), integerValue);

#  endif /* VMBIGENDIAN */

	return newLargeInteger;
}


/*	With 0 args answers whether ioProcessEvents is enabled and being called.
	With 1 arg expects a boolean which will enable ioProcessEvents if true and
	disable it if false, answering its previous state. */

	/* StackInterpreter>>#primitiveEventProcessingControl */
EXPORT(void)
primitiveEventProcessingControl(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt enabled;
    char *sp;
    char *sp1;

	enabled = inIOProcessEvents >= 0;
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			if (inIOProcessEvents < 0) {
				inIOProcessEvents = 0;
			}
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				inIOProcessEvents = -1;
			}
			else {
				GIV(primFailCode) = PrimErrBadArgument;
				return;
			}
		}
		/* begin pop:thenPushBool: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp1;
		return;
	}
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	Note: With the Squeak V0 format we now have 10 bits of primitive index,
	but they are in
	two places for temporary backward compatibility. The time to unpack is
	negligible, since the derived primitive function pointer is stored in the
	method cache. With the new
	format we assume a 3-byte CallPrimitive with a little-endian 16-bit
	primitive index. */

	/* StackInterpreter>>#primitiveIndexOfMethod:header: */
sqInt
primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt firstBytecode;
    sqInt primBits;

	return (methodHeader & AlternateHeaderHasPrimFlag
		? ((firstBytecode = (theMethod + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8))
		: 0);
}

	/* StackInterpreter>>#primitiveIndexOf: */
sqInt
primitiveIndexOf(sqInt methodPointer)
{
    sqInt firstBytecode;
    sqInt methodHeader;
    sqInt primBits;

	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(methodPointer));
	methodHeader = longAt((methodPointer + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	return (methodHeader & AlternateHeaderHasPrimFlag
		? ((firstBytecode = (methodPointer + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8))
		: 0);
}

	/* StackInterpreter>>#printActivationNameForSelector:startClass: */
static void NoDbgRegParms
printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classDict;
    usqInt classDictSize;
    sqInt currClass;
    sqInt i;
    sqInt methClass;
    usqInt numSlots;
    sqInt objOop;

	if (addressCouldBeObj(startClass)) {
		/* begin findClassForSelector:lookupClass:do: */
		currClass = startClass;
		do {
			classDict = longAt((currClass + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
			numSlots = byteAt(classDict + 7);
			classDictSize = (numSlots == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(classDict - BaseHeaderSize))) << 8)))) >> 8
				: numSlots);
			i = SelectorStart;
			while (i < classDictSize) {
				if (aSelector == (longAt((classDict + BaseHeaderSize) + (((long)i) << (shiftForWord()))))) {
					methClass = currClass;

					goto l1;
				}
				i += 1;
			}
			/* begin followField:ofObject: */
			objOop = longAt((currClass + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
			if (((objOop & (tagMask())) == 0)
			 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currClass, objOop);
			}
			currClass = objOop;
		} while(!(currClass == GIV(nilObj)));
		methClass = null;

	l1:	/* end findClassForSelector:lookupClass:do: */;
		if ((methClass == null)
		 || (startClass == methClass)) {
			printNameOfClasscount(methClass, 5);
			/* begin printChar: */
			putchar('>');
			if (!(methClass)) {
				printStringOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorDoesNotUnderstand) << (shiftForWord()))));
				print(" ");
			}
		}
		else {
			printNameOfClasscount(startClass, 5);
			/* begin printChar: */
			putchar('(');
			printNameOfClasscount(methClass, 5);
			/* begin printChar: */
			putchar(')');
			/* begin printChar: */
			putchar('>');
		}
	}
	else {
		print("INVALID CLASS");
	}
	if (((aSelector & (tagMask())) != 0)
	 || (addressCouldBeObj(aSelector))) {
		if (((aSelector & (tagMask())) == 0)
		 && (((((usqInt) (longAt(aSelector))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))) {
			printStringOf(aSelector);
		}
		else {
			printOopShort(aSelector);
		}
	}
	else {
		print("INVALID SELECTOR");
	}
}

	/* StackInterpreter>>#printActivationNameFor:receiver:isBlock:firstTemporary: */
static void NoDbgRegParms
printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt methClass;
    sqInt methodSel;
    sqInt rclass;
    sqInt tagBits;
    sqInt tagBits1;

	if (isBlock) {
		print("[] in ");
	}
	/* begin findClassOfMethod:forReceiver: */
	if ((((anObject & (tagMask())) != 0)
	 || (addressCouldBeObj(anObject)))
	 && (!(((anObject & (tagMask())) == 0)
 && (((longAt(anObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))))) {
		rclass = findClassContainingMethodstartingAt(aMethod, (((tagBits1 = anObject & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits1) << (shiftForWord())))
			: fetchClassOfNonImm(anObject)));
		if (rclass != GIV(nilObj)) {
			methClass = rclass;
			goto l1;
		}
	}
	if (!((addressCouldBeObj(aMethod))
		 && (((((usqInt) (longAt(aMethod))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		methClass = GIV(nilObj);
		goto l1;
	}
	methClass = findClassContainingMethodstartingAt(aMethod, safeMethodClassOf(aMethod));
l1:	/* end findClassOfMethod:forReceiver: */;
	methodSel = findSelectorOfMethod(aMethod);
	if ((((anObject & (tagMask())) != 0)
	 || (addressCouldBeObj(anObject)))
	 && ((!(((anObject & (tagMask())) == 0)
 && (((longAt(anObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))))
	 && (addressCouldBeClassObj((classObj = (((tagBits = anObject & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(anObject))))))) {
		if ((classObj == methClass)
		 || ((methClass == null)
		 || (methClass == GIV(nilObj)))) {
			printNameOfClasscount(classObj, 5);
		}
		else {
			printNameOfClasscount(classObj, 5);
			print("(");
			printNameOfClasscount(methClass, 5);
			print(")");
		}
	}
	else {
		print("INVALID RECEIVER");
	}
	print(">");
	if (((methodSel & (tagMask())) != 0)
	 || (addressCouldBeObj(methodSel))) {
		if (methodSel == GIV(nilObj)) {
			print("(nil)");
		}
		else {
			printStringOf(methodSel);
		}
	}
	else {
		print("INVALID SELECTOR");
	}
	if ((methodSel == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorDoesNotUnderstand) << (shiftForWord())))))
	 && ((addressCouldBeObj(maybeMessage))
	 && ((fetchClassOfNonImm(maybeMessage)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassMessage) << (shiftForWord()))))))) {

		/* print arg message selector */
		methodSel = longAt((maybeMessage + BaseHeaderSize) + (((long)MessageSelectorIndex) << (shiftForWord())));
		print(" ");
		printStringOf(methodSel);
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */

	/* StackInterpreter>>#printAllStacks */
void
printAllStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt classIdx;
    sqInt classObj;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord11;
    sqInt followingWord2;
    sqInt followingWord3;
    sqInt followingWord4;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress11;
    sqInt followingWordAddress2;
    sqInt followingWordAddress3;
    sqInt followingWordAddress4;
    usqInt limit;
    usqInt limit1;
    sqInt mutexClass;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots111;
    usqInt numSlots12;
    usqInt numSlots121;
    usqInt numSlots13;
    usqInt numSlots14;
    usqInt numSlots2;
    usqInt numSlots21;
    usqInt numSlots3;
    usqInt numSlots31;
    usqInt numSlots4;
    usqInt numSlots5;
    usqInt numSlots6;
    usqInt numSlots7;
    usqInt numSlots8;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    usqInt p;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj2;
    sqInt prevObj3;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj2;
    sqInt prevPrevObj3;
    sqInt pri;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;
    sqInt semaphoreClass;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes11;
    sqInt slotBytes2;
    sqInt slotBytes3;
    sqInt slotBytes4;
    sqInt tagBits;

	/* begin fetchPointer:ofObject: */
	objOop1 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	proc = longAt((objOop1 + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
	printNameOfClasscount((((tagBits = proc & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(proc)), 5);
	/* begin space */
	putchar(' ');
	printHex(proc);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, proc));
	/* begin cr */
	printf("\n");
	printCallStackFP(GIV(framePointer));
	/* begin fetchPointer:ofObject: */
	objOop2 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	schedLists = longAt((objOop2 + BaseHeaderSize) + (((long)ProcessListsIndex) << (shiftForWord())));
	if (GIV(highestRunnableProcessPriority) == 0) {
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(schedLists)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(schedLists + 7);
		p = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(schedLists - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);
	}
	else {
		p = GIV(highestRunnableProcessPriority);
	}
	for (pri = (p - 1); pri >= 0; pri += -1) {
		processList = longAt((schedLists + BaseHeaderSize) + (((long)pri) << (shiftForWord())));
		if (!(isEmptyList(processList))) {
			/* begin cr */
			printf("\n");
			print("processes at priority ");
			printNum(pri + 1);
			printProcsOnList(processList);
		}
	}
	/* begin cr */
	printf("\n");
	print("suspended processes");
	semaphoreClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord())));
	mutexClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassMutex) << (shiftForWord())));
	/* begin compactIndexOfClass: */
	assert((rawHashBitsOf(semaphoreClass)) != 0);
	semaphoreClass = (long32At(semaphoreClass + 4)) & (identityHashHalfWordMask());
	/* begin compactIndexOfClass: */
	assert((rawHashBitsOf(mutexClass)) != 0);
	mutexClass = (long32At(mutexClass + 4)) & (identityHashHalfWordMask());
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop3 = GIV(nilObj);
	while (1) {
		assert((objOop3 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop3, GIV(endOfMemory)))) break;
		assert((long64At(objOop3)) != 0);
		classIdx = (longAt(objOop3)) & (classIndexMask());
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop3);
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop3;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop3 + 7);
		numSlots4 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop3 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop3 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop3 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop3 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots5 = byteAt(address + 7);
	objOop = (numSlots5 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop, limit)) {
		classIdx = (longAt(objOop)) & (classIndexMask());
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop);
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots1 = byteAt(objOop + 7);
		numSlots2 = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots6 = byteAt(address1 + 7);
	objOop = (numSlots6 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		classIdx = (longAt(objOop)) & (classIndexMask());
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop);
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots3 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	
}

	/* StackInterpreter>>#printCallStack */
void
printCallStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(framePointer) == null) {
		printCallStackOf(fetchPointerofObject(SuspendedContextIndex, fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))))));
	}
	else {
		printCallStackFP(GIV(framePointer));
	}
}

	/* StackInterpreter>>#printCallStackFP: */
static sqInt NoDbgRegParms
printCallStackFP(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	context = shortReversePrintFrameAndCallers(theFP);
	while (!(context == GIV(nilObj))) {
		if (((((longAt((context + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
}

	/* StackInterpreter>>#printCallStackOf: */
sqInt
printCallStackOf(sqInt aContextOrProcessOrFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	if ((((((usqInt)aContextOrProcessOrFrame)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)aContextOrProcessOrFrame)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)aContextOrProcessOrFrame)) <= (((usqInt)GIV(pages))))))) {
		return printCallStackFP(((char *) aContextOrProcessOrFrame));
	}
	if (couldBeProcess(aContextOrProcessOrFrame)) {
		return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord()))));
	}
	context = aContextOrProcessOrFrame;
	while (!(context == GIV(nilObj))) {
		if (((((longAt((context + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
}

	/* StackInterpreter>>#printCallStackOf:currentFP: */
static sqInt NoDbgRegParms
printCallStackOfcurrentFP(sqInt aContext, char *currFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt index;
    sqInt referent;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	ctxt = aContext;
	while (!(ctxt == GIV(nilObj))) {
		if (((((longAt((ctxt + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((ctxt + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1));
			theFP = pointerForOop(senderOop - 1);
			if (checkIsStillMarriedContextcurrentFP(ctxt, currFP)) {
				/* begin stackPageFor: */
				index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
				thePage = stackPageAtpages(index, GIV(pages));
				if (isFree(thePage)) {
					/* begin printHexPtr: */
					printHex(oopForPointer(theFP));
					print(" is on a free page?!");
					/* begin cr */
					printf("\n");
					return null;
				}
				shortPrintFrameAndCallers(theFP);
				theFP = (thePage->baseFP);
				ctxt = longAt(theFP + FoxCallerContext);
				if (((longAt(ctxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(ctxt));
					referent = longAt((ctxt + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					ctxt = referent;
				}
			}
			else {
				print("widowed caller frame ");
				/* begin printHexPtr: */
				printHex(oopForPointer(theFP));
				/* begin cr */
				printf("\n");
				return null;
			}
		}
		else {
			shortPrintContext(ctxt);
			ctxt = longAt((ctxt + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		}
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#printChar: */
void
printChar(sqInt aByte)
{
	putchar(aByte);
}


/*	Print the call stack of aContext until it links to a frame. */

	/* StackInterpreter>>#printContextCallStackOf: */
static sqInt NoDbgRegParms
printContextCallStackOf(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;

	ctxt = aContext;
	while (!((ctxt == GIV(nilObj))
	 || (((((longAt((ctxt + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)))) {
		shortPrintContext(ctxt);
		ctxt = longAt((ctxt + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	}
	return ctxt;
}

	/* StackInterpreter>>#printContext: */
void
printContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ip;
    void *p;
    void *p1;
    sqInt sender;
    sqInt sp;

	shortPrintContext(aContext);
	sender = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	ip = longAt((aContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())));
	if ((((sender) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			print("married (assuming framePointer valid)");
			/* begin cr */
			printf("\n");
		}
		else {
			print("widowed (assuming framePointer valid)");
			/* begin cr */
			printf("\n");
		}
		print("sender   ");
		printNum(sender);
		print(" (");
		/* begin printHexPtr: */
		assert((((sender) & 7) == 1));
		p = pointerForOop(sender - 1);
		printHex(oopForPointer(p));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		print("ip       ");
		printNum(ip);
		print(" (");
		/* begin printHexPtr: */
		assert((((ip) & 7) == 1));
		p1 = pointerForOop(ip - 1);
		printHex(oopForPointer(p1));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
	}
	else {
		print("sender   ");
		shortPrintOop(sender);
		print("ip       ");
		if (ip == GIV(nilObj)) {
			shortPrintOop(ip);
		}
		else {
			printNum(ip);
			print(" (");
			printNum((ip >> 3));
			/* begin space */
			putchar(' ');
			printHex((ip >> 3));
			/* begin printChar: */
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
	sp = longAt((aContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
	sp = ((sp < ((lengthOfformat(aContext, (((usqInt) (longAt(aContext))) >> (formatShift())) & (formatMask()))) - ReceiverIndex)) ? sp : ((lengthOfformat(aContext, (((usqInt) (longAt(aContext))) >> (formatShift())) & (formatMask()))) - ReceiverIndex));
	print("sp       ");
	printNum(sp);
	print(" (");
	printNum((sp >> 3));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	print("method   ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord()))));
	print("closure  ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((long)ClosureIndex) << (shiftForWord()))));
	print("receiver ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((long)ReceiverIndex) << (shiftForWord()))));
	sp = (sp >> 3);
	for (i = 1; i <= sp; i += 1) {
		print("       ");
		printNum(i);
		/* begin space */
		putchar(' ');
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (((long)(ReceiverIndex + i)) << (shiftForWord()))));
	}
}

	/* StackInterpreter>>#printExternalHeadFrame */
void
printExternalHeadFrame(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFrameWithSP(GIV(framePointer), GIV(stackPointer));
}

	/* StackInterpreter>>#printFrameAndCallers:SP:short: */
static sqInt NoDbgRegParms
printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		printFrameAndCallersSPshort(pointerForOop(longAt(theFP + FoxSavedFP)), frameCallerSP(theFP), printShort);
	}
	if (printShort) {
		shortPrintFrame(theFP);
		return null;
	}
	/* begin cr */
	printf("\n");
	printFrameWithSP(theFP, theSP);
}

	/* StackInterpreter>>#printFrameFlagsForFP: */
static void NoDbgRegParms
printFrameFlagsForFP(char *theFP)
{
    char *address;
    sqInt it;

	address = theFP + FoxFrameFlags;
	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	print(":       flags: ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		printNum(it);
	}
	print("  numArgs: ");
	printNum(byteAt((theFP + FoxFrameFlags) + 1));
	print(((byteAt((theFP + FoxFrameFlags) + 2)) != 0
		? " hasContext"
		: " noContext"));
	print(((byteAt((theFP + FoxFrameFlags) + 3)) != 0
		? " isBlock"
		: " notBlock"));
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrameOop:at: */
static void NoDbgRegParms
printFrameOopat(char *name, char *address)
{
    sqInt i;
    sqInt iLimiT;
    sqInt it;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	for (i = 1, iLimiT = (12 - (strlen(name))); i <= iLimiT; i += 1) {
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	/* begin tab */
	putchar('	');
	/* begin printChar: */
	putchar('=');
	printOopShort(it);
	/* begin cr */
	printf("\n");
}


/*	use export: not api, so it won't be written to cointerp.h. cogit.c is
	unaware of StackPage
 */

	/* StackInterpreter>>#printFramesInPage: */
EXPORT(void)
printFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 0);
}

	/* StackInterpreter>>#printFramesOnStackPageListInUse */
EXPORT(void)
printFramesOnStackPageListInUse(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			print("page ");
			/* begin printHexPtrnp: */
			printf("0x%lx", ((unsigned long) (oopForPointer(page))));
			/* begin cr */
			printf("\n");
			printFramesInPage(page);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#printFrameThing:andFrame:at: */
static void NoDbgRegParms
printFrameThingandFrameat(char *name, char *theFP, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil");
		}
		else {
			printNum(it);
		}
	}
	print(" frame: ");
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP));
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrameThing:at: */
static void NoDbgRegParms
printFrameThingat(char *name, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil");
		}
		else {
			printNum(it);
		}
	}
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrame: */
sqInt
printFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *frameAbove;
    sqInt index;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		/* begin printHexPtr: */
		printHex(oopForPointer(theFP));
		print(" is not in the stack zone?!");
		/* begin cr */
		printf("\n");
		return null;
	}
	frameAbove = null;
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (isFree(thePage)) {
			/* begin printHexPtr: */
			printHex(oopForPointer(theFP));
			print(" is on a free page?!");
			/* begin cr */
			printf("\n");
			return null;
		}
		if ((thePage != GIV(stackPage))
		 && (theFP == ((thePage->headFP)))) {
			theSP = (thePage->headSP);
		}
		else {
			/* begin safeFindFrameAbove:on:startingFrom: */
			startFrame = ((thePage == GIV(stackPage))
			 && (((GIV(framePointer) >= ((thePage->realStackLimit))) && (GIV(framePointer) <= ((thePage->baseAddress)))))
				? GIV(framePointer)
				: (thePage->headFP));
			assert(!(isFree(thePage)));
			if (startFrame == theFP) {
				frameAbove = null;
				goto l1;
			}
			aFrame = startFrame;
			while (1) {
				prevFrame = aFrame;
				aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
				if (!(aFrame != 0)) break;
				if (theFP == aFrame) {
					frameAbove = prevFrame;
					goto l1;
				}
			}
			frameAbove = null;
		l1:	/* end safeFindFrameAbove:on:startingFrom: */;
			theSP = (!(frameAbove == null)
				? (/* begin frameCallerSP: */
					assert(!(isBaseFrame(frameAbove))),
					(frameAbove + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord)
				: 0);
		}
	}
	if (!(theSP)) {
		print("could not find sp; using bogus value");
		/* begin cr */
		printf("\n");
		theSP = theFP + FoxReceiver;
	}
	printFrameWithSP(theFP, theSP);
	if (!(frameAbove == null)) {
		printFrameThingat("frame pc", frameAbove + FoxCallerSavedIP);
	}
}

	/* StackInterpreter>>#printFrame:WithSP: */
sqInt
printFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *addr;
    sqInt i;
    sqInt numArgs;
    sqInt theMethod;
    sqInt topThing;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		/* begin printHexPtr: */
		printHex(oopForPointer(theFP));
		print(" is not in the stack zone?!");
		/* begin cr */
		printf("\n");
		return null;
	}
	theMethod = longAt(theFP + FoxMethod);
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	shortPrintFrame(theFP);
	printFrameOopat("rcvr/clsr", (theFP + FoxCallerSavedIP) + ((numArgs + 1) * BytesPerWord));
	for (i = numArgs; i >= 1; i += -1) {
		printFrameOopat("arg", (theFP + FoxCallerSavedIP) + (i * BytesPerWord));
	}
	printFrameThingat("cllr ip/ctxt", theFP + FoxCallerSavedIP);
	printFrameThingat("saved fp", theFP + FoxSavedFP);
	printFrameOopat("method", theFP + FoxMethod);
	printFrameFlagsForFP(theFP);
	printFrameThingat("context", theFP + FoxThisContext);
	printFrameOopat("receiver", theFP + FoxReceiver);
	topThing = longAt(theSP);
	if ((topThing >= theMethod)
	 && (topThing <= (theMethod + ((((long)(numSlotsOf(theMethod))) << (shiftForWord())) + BaseHeaderSize)))) {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= (theSP + BytesPerWord); addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr);
		}
		printFrameThingat("frame ip", theSP);
	}
	else {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= theSP; addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr);
		}
	}
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles)  */

	/* StackInterpreter>>#printHex: */
void
printHex(sqInt n)
{
    char buf[35];
    sqInt len;


	/* large enough for a 64-bit value in hex plus the null plus 16 spaces */
	memset(buf,' ',34);
	len = sprintf(buf + 2 + 2 * BytesPerWord, "0x%lx", (unsigned long)(n));
	printf("%s", buf + len);
	}


/*	Print all methods whose penultimate literal is either selector,
	or an object whose first inst var is the method and whose
	second is selector (e.g. an AdditionalMethodState). */

	/* StackInterpreter>>#printLikelyImplementorsOfSelector: */
void
printLikelyImplementorsOfSelector(sqInt selector)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt aByte1;
    sqInt aByte2;
    sqInt address;
    sqInt address1;
    sqInt classLookupKey;
    sqInt classLookupKey1;
    sqInt classLookupKey2;
    sqInt classOop;
    sqInt classOop1;
    sqInt classOop2;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt i;
    sqInt i1;
    sqInt i2;
    usqInt limit;
    sqInt methodClassAssociation;
    sqInt n;
    sqInt n1;
    sqInt n11;
    sqInt n12;
    sqInt n2;
    sqInt n3;
    char *name;
    char *name1;
    char *name2;
    sqInt nameLen;
    sqInt nameLen1;
    sqInt nameLen2;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop13;
    sqInt objOop14;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt offset;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt tagBits2;
    sqInt theClass1;
    sqInt theClass11;
    sqInt theClass12;

	/* begin allObjectsDo: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
		 && ((maybeSelectorOfMethod(objOop1)) == selector)) {

			/* try and print the key of the method class association (the name of the implementing class) */
			/* begin literal:ofMethod: */
			offset = (literalCountOfMethodHeader(methodHeaderOf(objOop1))) - 1;
			methodClassAssociation = longAt((objOop1 + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
			/* begin printHexnp: */
			printf("0x%lx", ((unsigned long) objOop1));
			/* begin space */
			putchar(' ');
			/* begin printOopShortInner: */
			oop = ((((methodClassAssociation & (tagMask())) == 0)
			 && (((((usqInt) (longAt(methodClassAssociation))) >> (formatShift())) & (formatMask())) <= 5))
			 && ((numSlotsOf(methodClassAssociation)) >= 2)
				? longAt((methodClassAssociation + BaseHeaderSize) + (0LL << (shiftForWord())))
				: methodClassAssociation);
			if ((oop & (tagMask())) != 0) {
				if ((oop & (tagMask())) == 2) {
					/* begin printChar: */
					putchar('$');
					/* begin printChar: */
					aByte = ((usqInt) (((usqInt)oop))) >> (numTagBits());
					putchar(aByte);
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					n = ((usqInt) (((usqInt)oop))) >> (numTagBits());
					printf("0x%lx", ((unsigned long) n));
					/* begin printChar: */
					putchar(')');

					goto l13;
				}
				if ((((oop) & 7) == 1)) {
					printNum((oop >> 3));
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) ((oop >> 3))));
					/* begin printChar: */
					putchar(')');

					goto l13;
				}
				if ((oop & (tagMask())) == (smallFloatTag())) {
					printFloat(dbgFloatValueOf(oop));
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) oop));
					/* begin printChar: */
					putchar(')');

					goto l13;
				}
				print("unknown immediate ");
				/* begin printHexnp: */
				printf("0x%lx", ((unsigned long) oop));

				goto l13;
			}
			if (!(addressCouldBeObj(oop))) {
				print(((oop & (8 - 1)) != 0
					? " is misaligned"
					: whereIs(oop)));
				goto l13;
			}
			if (((longAt(oop)) & (classIndexMask())) == 0) {
				print(" is a free chunk");
				goto l13;
			}
			if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				print(" is a forwarder to ");
				/* begin printHexnp: */
				assert(isUnambiguouslyForwarder(oop));
				referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent & (tagMask())) == 0)
				 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				n1 = referent;
				printf("0x%lx", ((unsigned long) n1));

				goto l13;
			}
			if ((((tagBits = oop & (tagMask()))) != 0
				? tagBits == (smallFloatTag())
				: ((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex)) {
				printFloat(dbgFloatValueOf(oop));
				goto l13;
			}
			classOop = fetchClassOfNonImm(oop);
			if (!(addressCouldBeObj(classOop))) {
				print("a ??");
				goto l13;
			}
			if ((numSlotsOf(classOop)) == GIV(metaclassNumSlots)) {
				printNameOfClasscount(oop, 5);
				goto l13;
			}
			if (oop == GIV(nilObj)) {
				print("nil");
				goto l13;
			}
			if (oop == GIV(trueObj)) {
				print("true");
				goto l13;
			}
			if (oop == GIV(falseObj)) {
				print("false");
				goto l13;
			}
			nameLen = lengthOfNameOfClass(classOop);
			if (nameLen == 0) {
				print("a ??");
				goto l13;
			}
			name = nameOfClass(classOop);
			if (nameLen == 10) {
				if ((strncmp(name, "ByteString", 10)) == 0) {

					/* strncmp is weird */
					/* begin printChar: */
					putchar('\'');
					printStringOf(oop);
					/* begin printChar: */
					putchar('\'');

					goto l13;
				}
				if ((strncmp(name, "ByteSymbol", 10)) == 0) {

					/* strncmp is weird */
					/* begin printChar: */
					putchar('#');
					printStringOf(oop);
					goto l13;
				}
			}
			if ((nameLen == 9)
			 && ((strncmp(name, "Character", 9)) == 0)) {
				/* begin printChar: */
				putchar('$');
				/* begin printChar: */
				putchar(((longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())))) >> 3));

				goto l13;
			}
			print("a(n) ");
			for (i = 0; i < nameLen; i += 1) {
				/* begin printChar: */
				putchar(name[i]);
			}
			if ((((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) <= 5)
			 && (((instanceSizeOf(classOop)) == (ValueIndex + 1))
			 && (isBytes(longAt((oop + BaseHeaderSize) + (((long)KeyIndex) << (shiftForWord()))))))) {
				classLookupKey = fetchClassOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord()))));
				while (1) {
					if (classLookupKey == GIV(nilObj)) {
						goto l13;
					}
					if ((instanceSizeOf(classLookupKey)) == (KeyIndex + 1)) break;
					/* begin followField:ofObject: */
					objOop2 = longAt((classLookupKey + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
					if (((objOop2 & (tagMask())) == 0)
					 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop2 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey, objOop2);
					}
					classLookupKey = objOop2;
				}
				if (classLookupKey == GIV(nilObj)) {
					goto l14;
				}
				theClass1 = classOop;
				while (1) {
					if (theClass1 == classLookupKey) {
						goto l15;
					}
					if (!(theClass1 != GIV(nilObj))) break;
					/* begin followField:ofObject: */
					objOop11 = longAt((theClass1 + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
					if (((objOop11 & (tagMask())) == 0)
					 && (((longAt(objOop11)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop11 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass1, objOop11);
					}
					theClass1 = objOop11;
				}
				goto l14;
			l15:	;
				/* begin space */
				putchar(' ');
				printOopShort(longAt((oop + BaseHeaderSize) + (((long)KeyIndex) << (shiftForWord()))));
				print(" -> ");
				/* begin printHexnp: */
				printf("0x%lx", ((unsigned long) (longAt((oop + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord()))))));
			l14:	;
			}
		l13:	/* end printOopShortInner: */;
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
		 && ((maybeSelectorOfMethod(objOop1)) == selector)) {

			/* try and print the key of the method class association (the name of the implementing class) */
			/* begin literal:ofMethod: */
			offset = (literalCountOfMethodHeader(methodHeaderOf(objOop1))) - 1;
			methodClassAssociation = longAt((objOop1 + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
			/* begin printHexnp: */
			printf("0x%lx", ((unsigned long) objOop1));
			/* begin space */
			putchar(' ');
			/* begin printOopShortInner: */
			oop1 = ((((methodClassAssociation & (tagMask())) == 0)
			 && (((((usqInt) (longAt(methodClassAssociation))) >> (formatShift())) & (formatMask())) <= 5))
			 && ((numSlotsOf(methodClassAssociation)) >= 2)
				? longAt((methodClassAssociation + BaseHeaderSize) + (0LL << (shiftForWord())))
				: methodClassAssociation);
			if ((oop1 & (tagMask())) != 0) {
				if ((oop1 & (tagMask())) == 2) {
					/* begin printChar: */
					putchar('$');
					/* begin printChar: */
					aByte1 = ((usqInt) (((usqInt)oop1))) >> (numTagBits());
					putchar(aByte1);
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					n2 = ((usqInt) (((usqInt)oop1))) >> (numTagBits());
					printf("0x%lx", ((unsigned long) n2));
					/* begin printChar: */
					putchar(')');

					goto l16;
				}
				if ((((oop1) & 7) == 1)) {
					printNum((oop1 >> 3));
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) ((oop1 >> 3))));
					/* begin printChar: */
					putchar(')');

					goto l16;
				}
				if ((oop1 & (tagMask())) == (smallFloatTag())) {
					printFloat(dbgFloatValueOf(oop1));
					/* begin printChar: */
					putchar('(');
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) oop1));
					/* begin printChar: */
					putchar(')');

					goto l16;
				}
				print("unknown immediate ");
				/* begin printHexnp: */
				printf("0x%lx", ((unsigned long) oop1));

				goto l16;
			}
			if (!(addressCouldBeObj(oop1))) {
				print(((oop1 & (8 - 1)) != 0
					? " is misaligned"
					: whereIs(oop1)));
				goto l16;
			}
			if (((longAt(oop1)) & (classIndexMask())) == 0) {
				print(" is a free chunk");
				goto l16;
			}
			if (((longAt(oop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				print(" is a forwarder to ");
				/* begin printHexnp: */
				assert(isUnambiguouslyForwarder(oop1));
				referent1 = longAt((oop1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent1 & (tagMask())) == 0)
				 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				n11 = referent1;
				printf("0x%lx", ((unsigned long) n11));

				goto l16;
			}
			if ((((tagBits1 = oop1 & (tagMask()))) != 0
				? tagBits1 == (smallFloatTag())
				: ((longAt(oop1)) & (classIndexMask())) == ClassFloatCompactIndex)) {
				printFloat(dbgFloatValueOf(oop1));
				goto l16;
			}
			classOop1 = fetchClassOfNonImm(oop1);
			if (!(addressCouldBeObj(classOop1))) {
				print("a ??");
				goto l16;
			}
			if ((numSlotsOf(classOop1)) == GIV(metaclassNumSlots)) {
				printNameOfClasscount(oop1, 5);
				goto l16;
			}
			if (oop1 == GIV(nilObj)) {
				print("nil");
				goto l16;
			}
			if (oop1 == GIV(trueObj)) {
				print("true");
				goto l16;
			}
			if (oop1 == GIV(falseObj)) {
				print("false");
				goto l16;
			}
			nameLen1 = lengthOfNameOfClass(classOop1);
			if (nameLen1 == 0) {
				print("a ??");
				goto l16;
			}
			name1 = nameOfClass(classOop1);
			if (nameLen1 == 10) {
				if ((strncmp(name1, "ByteString", 10)) == 0) {

					/* strncmp is weird */
					/* begin printChar: */
					putchar('\'');
					printStringOf(oop1);
					/* begin printChar: */
					putchar('\'');

					goto l16;
				}
				if ((strncmp(name1, "ByteSymbol", 10)) == 0) {

					/* strncmp is weird */
					/* begin printChar: */
					putchar('#');
					printStringOf(oop1);
					goto l16;
				}
			}
			if ((nameLen1 == 9)
			 && ((strncmp(name1, "Character", 9)) == 0)) {
				/* begin printChar: */
				putchar('$');
				/* begin printChar: */
				putchar(((longAt((oop1 + BaseHeaderSize) + (0LL << (shiftForWord())))) >> 3));

				goto l16;
			}
			print("a(n) ");
			for (i1 = 0; i1 < nameLen1; i1 += 1) {
				/* begin printChar: */
				putchar(name1[i1]);
			}
			if ((((((usqInt) (longAt(oop1))) >> (formatShift())) & (formatMask())) <= 5)
			 && (((instanceSizeOf(classOop1)) == (ValueIndex + 1))
			 && (isBytes(longAt((oop1 + BaseHeaderSize) + (((long)KeyIndex) << (shiftForWord()))))))) {
				classLookupKey1 = fetchClassOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord()))));
				while (1) {
					if (classLookupKey1 == GIV(nilObj)) {
						goto l16;
					}
					if ((instanceSizeOf(classLookupKey1)) == (KeyIndex + 1)) break;
					/* begin followField:ofObject: */
					objOop3 = longAt((classLookupKey1 + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
					if (((objOop3 & (tagMask())) == 0)
					 && (((longAt(objOop3)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop3 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey1, objOop3);
					}
					classLookupKey1 = objOop3;
				}
				if (classLookupKey1 == GIV(nilObj)) {
					goto l17;
				}
				theClass11 = classOop1;
				while (1) {
					if (theClass11 == classLookupKey1) {
						goto l18;
					}
					if (!(theClass11 != GIV(nilObj))) break;
					/* begin followField:ofObject: */
					objOop12 = longAt((theClass11 + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
					if (((objOop12 & (tagMask())) == 0)
					 && (((longAt(objOop12)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop12 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass11, objOop12);
					}
					theClass11 = objOop12;
				}
				goto l17;
			l18:	;
				/* begin space */
				putchar(' ');
				printOopShort(longAt((oop1 + BaseHeaderSize) + (((long)KeyIndex) << (shiftForWord()))));
				print(" -> ");
				/* begin printHexnp: */
				printf("0x%lx", ((unsigned long) (longAt((oop1 + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord()))))));
			l17:	;
			}
		l16:	/* end printOopShortInner: */;
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop14 = GIV(nilObj);
	while (1) {
		assert((objOop14 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop14, GIV(endOfMemory)))) break;
		assert((long64At(objOop14)) != 0);
		if (isEnumerableObject(objOop14)) {
			if ((((((usqInt) (longAt(objOop14))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
			 && ((maybeSelectorOfMethod(objOop14)) == selector)) {

				/* try and print the key of the method class association (the name of the implementing class) */
				/* begin literal:ofMethod: */
				offset = (literalCountOfMethodHeader(methodHeaderOf(objOop14))) - 1;
				methodClassAssociation = longAt((objOop14 + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
				/* begin printHexnp: */
				printf("0x%lx", ((unsigned long) objOop14));
				/* begin space */
				putchar(' ');
				/* begin printOopShortInner: */
				oop2 = ((((methodClassAssociation & (tagMask())) == 0)
				 && (((((usqInt) (longAt(methodClassAssociation))) >> (formatShift())) & (formatMask())) <= 5))
				 && ((numSlotsOf(methodClassAssociation)) >= 2)
					? longAt((methodClassAssociation + BaseHeaderSize) + (0LL << (shiftForWord())))
					: methodClassAssociation);
				if ((oop2 & (tagMask())) != 0) {
					if ((oop2 & (tagMask())) == 2) {
						/* begin printChar: */
						putchar('$');
						/* begin printChar: */
						aByte2 = ((usqInt) (((usqInt)oop2))) >> (numTagBits());
						putchar(aByte2);
						/* begin printChar: */
						putchar('(');
						/* begin printHexnp: */
						n3 = ((usqInt) (((usqInt)oop2))) >> (numTagBits());
						printf("0x%lx", ((unsigned long) n3));
						/* begin printChar: */
						putchar(')');

						goto l19;
					}
					if ((((oop2) & 7) == 1)) {
						printNum((oop2 >> 3));
						/* begin printChar: */
						putchar('(');
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) ((oop2 >> 3))));
						/* begin printChar: */
						putchar(')');

						goto l19;
					}
					if ((oop2 & (tagMask())) == (smallFloatTag())) {
						printFloat(dbgFloatValueOf(oop2));
						/* begin printChar: */
						putchar('(');
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) oop2));
						/* begin printChar: */
						putchar(')');

						goto l19;
					}
					print("unknown immediate ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) oop2));

					goto l19;
				}
				if (!(addressCouldBeObj(oop2))) {
					print(((oop2 & (8 - 1)) != 0
						? " is misaligned"
						: whereIs(oop2)));
					goto l19;
				}
				if (((longAt(oop2)) & (classIndexMask())) == 0) {
					print(" is a free chunk");
					goto l19;
				}
				if (((longAt(oop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					print(" is a forwarder to ");
					/* begin printHexnp: */
					assert(isUnambiguouslyForwarder(oop2));
					referent2 = longAt((oop2 + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent2 & (tagMask())) == 0)
					 && (((longAt(referent2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent2 = longAt((referent2 + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					n12 = referent2;
					printf("0x%lx", ((unsigned long) n12));

					goto l19;
				}
				if ((((tagBits2 = oop2 & (tagMask()))) != 0
					? tagBits2 == (smallFloatTag())
					: ((longAt(oop2)) & (classIndexMask())) == ClassFloatCompactIndex)) {
					printFloat(dbgFloatValueOf(oop2));
					goto l19;
				}
				classOop2 = fetchClassOfNonImm(oop2);
				if (!(addressCouldBeObj(classOop2))) {
					print("a ??");
					goto l19;
				}
				if ((numSlotsOf(classOop2)) == GIV(metaclassNumSlots)) {
					printNameOfClasscount(oop2, 5);
					goto l19;
				}
				if (oop2 == GIV(nilObj)) {
					print("nil");
					goto l19;
				}
				if (oop2 == GIV(trueObj)) {
					print("true");
					goto l19;
				}
				if (oop2 == GIV(falseObj)) {
					print("false");
					goto l19;
				}
				nameLen2 = lengthOfNameOfClass(classOop2);
				if (nameLen2 == 0) {
					print("a ??");
					goto l19;
				}
				name2 = nameOfClass(classOop2);
				if (nameLen2 == 10) {
					if ((strncmp(name2, "ByteString", 10)) == 0) {

						/* strncmp is weird */
						/* begin printChar: */
						putchar('\'');
						printStringOf(oop2);
						/* begin printChar: */
						putchar('\'');

						goto l19;
					}
					if ((strncmp(name2, "ByteSymbol", 10)) == 0) {

						/* strncmp is weird */
						/* begin printChar: */
						putchar('#');
						printStringOf(oop2);
						goto l19;
					}
				}
				if ((nameLen2 == 9)
				 && ((strncmp(name2, "Character", 9)) == 0)) {
					/* begin printChar: */
					putchar('$');
					/* begin printChar: */
					putchar(((longAt((oop2 + BaseHeaderSize) + (0LL << (shiftForWord())))) >> 3));

					goto l19;
				}
				print("a(n) ");
				for (i2 = 0; i2 < nameLen2; i2 += 1) {
					/* begin printChar: */
					putchar(name2[i2]);
				}
				if ((((((usqInt) (longAt(oop2))) >> (formatShift())) & (formatMask())) <= 5)
				 && (((instanceSizeOf(classOop2)) == (ValueIndex + 1))
				 && (isBytes(longAt((oop2 + BaseHeaderSize) + (((long)KeyIndex) << (shiftForWord()))))))) {
					classLookupKey2 = fetchClassOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord()))));
					while (1) {
						if (classLookupKey2 == GIV(nilObj)) {
							goto l19;
						}
						if ((instanceSizeOf(classLookupKey2)) == (KeyIndex + 1)) break;
						/* begin followField:ofObject: */
						objOop4 = longAt((classLookupKey2 + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
						if (((objOop4 & (tagMask())) == 0)
						 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							objOop4 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey2, objOop4);
						}
						classLookupKey2 = objOop4;
					}
					if (classLookupKey2 == GIV(nilObj)) {
						goto l20;
					}
					theClass12 = classOop2;
					while (1) {
						if (theClass12 == classLookupKey2) {
							goto l21;
						}
						if (!(theClass12 != GIV(nilObj))) break;
						/* begin followField:ofObject: */
						objOop13 = longAt((theClass12 + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
						if (((objOop13 & (tagMask())) == 0)
						 && (((longAt(objOop13)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							objOop13 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass12, objOop13);
						}
						theClass12 = objOop13;
					}
					goto l20;
				l21:	;
					/* begin space */
					putchar(' ');
					printOopShort(longAt((oop2 + BaseHeaderSize) + (((long)KeyIndex) << (shiftForWord()))));
					print(" -> ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) (longAt((oop2 + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord()))))));
				l20:	;
				}
			l19:	/* end printOopShortInner: */;
				/* begin cr */
				printf("\n");
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop14;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop14 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop14 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop14 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop14 = GIV(endOfMemory);
			goto l12;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop14 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l12:	/* end objectAfter:limit: */;
	}
	}

	/* StackInterpreter>>#printMethodCache */
void
printMethodCache(void)
{
	printMethodCacheFor(-1);
}

	/* StackInterpreter>>#printMethodCacheFor: */
void
printMethodCacheFor(sqInt thing)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long c;
    sqInt i;
    long m;
    long p;
    long s;

	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = GIV(methodCache)[i + MethodCacheSelector];
		c = GIV(methodCache)[i + MethodCacheClass];
		m = GIV(methodCache)[i + MethodCacheMethod];
		p = GIV(methodCache)[i + MethodCachePrimFunction];
		if (((thing == -1)
		 || ((s == thing)
		 || ((c == thing)
		 || ((p == thing)
		 || (m == thing)))))
		 && ((((s & (tagMask())) != 0)
		 || (addressCouldBeObj(s)))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c))
		 || (addressCouldBeClassObj(classAtIndex(c))))))) {
			printNum(i);
			/* begin cr */
			printf("\n");
			/* begin tab */
			putchar('	');
			if (((((usqInt) (longAt(s))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())) {
				printf("%lx %.*s\n", s, (int)(numBytesOf(s)), (char *)firstIndexableField(s));
			}
			else {
				shortPrintOop(s);
			}
			/* begin tab */
			putchar('	');
			if (addressCouldBeClassObj(c)) {
				shortPrintOop(c);
			}
			else {
				printNum(c);
				/* begin space */
				putchar(' ');
				shortPrintOop(classAtIndex(c));
			}
			/* begin tab */
			putchar('	');
			shortPrintOop(m);
			/* begin tab */
			putchar('	');
			if (p > 1024) {
				/* begin printHexnp: */
				printf("0x%lx", ((unsigned long) p));
			}
			else {
				printNum(p);
			}
			/* begin cr */
			printf("\n");
		}
	}
}

	/* StackInterpreter>>#printMethodDictionaryOf: */
void
printMethodDictionaryOf(sqInt behavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt dictionary;
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	/* begin printMethodDictionary: */
	dictionary = longAt((behavior + BaseHeaderSize) + (((long)MethodDictionaryIndex) << (shiftForWord())));
	methodArray = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
	for (index = SelectorStart, indexLimiT = ((numSlotsOf(dictionary)) - 1); index <= indexLimiT; index += 1) {
		selector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
			printOopShort(selector);
			print(" => ");
			printOopShort(meth);
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
}

	/* StackInterpreter>>#printMethodDictionary: */
void
printMethodDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	methodArray = longAt((dictionary + BaseHeaderSize) + (((long)MethodArrayIndex) << (shiftForWord())));
	for (index = SelectorStart, indexLimiT = ((numSlotsOf(dictionary)) - 1); index <= indexLimiT; index += 1) {
		selector = longAt((dictionary + BaseHeaderSize) + (((long)index) << (shiftForWord())));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + BaseHeaderSize) + (((long)(index - SelectorStart)) << (shiftForWord())));
			printOopShort(selector);
			print(" => ");
			printOopShort(meth);
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

	/* StackInterpreter>>#printNameOfClass:count: */
static void NoDbgRegParms
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;

	if (!(GIV(classNameIndex))) {
		print("??nil cnidx??");
		return;
	}
	if ((classOop == null)
	 || ((classOop == 0)
	 || (cnt <= 0))) {
		print("bad class");
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(classOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(classOop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if ((numSlots == GIV(metaclassNumSlots))
	 && (GIV(metaclassNumSlots) > GIV(thisClassIndex))) {
		printNameOfClasscount(longAt((classOop + BaseHeaderSize) + (((long)GIV(thisClassIndex)) << (shiftForWord()))), cnt - 1);
		print(" class");
	}
	else {
		if (numSlots <= GIV(classNameIndex)) {
			print("bad class");
		}
		else {
			printStringOf(longAt((classOop + BaseHeaderSize) + (((long)GIV(classNameIndex)) << (shiftForWord()))));
		}
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#printNum: */
static void NoDbgRegParms
printNum(sqInt n)
{
	printf("%ld", (long) n);
}

	/* StackInterpreter>>#printOopShort: */
static void NoDbgRegParms
printOopShort(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt classLookupKey;
    sqInt classOop;
    sqInt i;
    sqInt n;
    sqInt n1;
    char *name;
    sqInt nameLen;
    sqInt objOop;
    sqInt objOop1;
    sqInt referent;
    sqInt tagBits;
    sqInt theClass1;

	/* begin printOopShortInner: */
	if ((oop & (tagMask())) != 0) {
		if ((oop & (tagMask())) == 2) {
			/* begin printChar: */
			putchar('$');
			/* begin printChar: */
			aByte = ((usqInt) (((usqInt)oop))) >> (numTagBits());
			putchar(aByte);
			/* begin printChar: */
			putchar('(');
			/* begin printHexnp: */
			n = ((usqInt) (((usqInt)oop))) >> (numTagBits());
			printf("0x%lx", ((unsigned long) n));
			/* begin printChar: */
			putchar(')');

			goto l3;
		}
		if ((((oop) & 7) == 1)) {
			printNum((oop >> 3));
			/* begin printChar: */
			putchar('(');
			/* begin printHexnp: */
			printf("0x%lx", ((unsigned long) ((oop >> 3))));
			/* begin printChar: */
			putchar(')');

			goto l3;
		}
		if ((oop & (tagMask())) == (smallFloatTag())) {
			printFloat(dbgFloatValueOf(oop));
			/* begin printChar: */
			putchar('(');
			/* begin printHexnp: */
			printf("0x%lx", ((unsigned long) oop));
			/* begin printChar: */
			putchar(')');

			goto l3;
		}
		print("unknown immediate ");
		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) oop));

		goto l3;
	}
	if (!(addressCouldBeObj(oop))) {
		print(((oop & (8 - 1)) != 0
			? " is misaligned"
			: whereIs(oop)));
		goto l3;
	}
	if (((longAt(oop)) & (classIndexMask())) == 0) {
		print(" is a free chunk");
		goto l3;
	}
	if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		print(" is a forwarder to ");
		/* begin printHexnp: */
		assert(isUnambiguouslyForwarder(oop));
		referent = longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		n1 = referent;
		printf("0x%lx", ((unsigned long) n1));

		goto l3;
	}
	if ((((tagBits = oop & (tagMask()))) != 0
		? tagBits == (smallFloatTag())
		: ((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex)) {
		printFloat(dbgFloatValueOf(oop));
		goto l3;
	}
	classOop = fetchClassOfNonImm(oop);
	if (!(addressCouldBeObj(classOop))) {
		print("a ??");
		goto l3;
	}
	if ((numSlotsOf(classOop)) == GIV(metaclassNumSlots)) {
		printNameOfClasscount(oop, 5);
		goto l3;
	}
	if (oop == GIV(nilObj)) {
		print("nil");
		goto l3;
	}
	if (oop == GIV(trueObj)) {
		print("true");
		goto l3;
	}
	if (oop == GIV(falseObj)) {
		print("false");
		goto l3;
	}
	nameLen = lengthOfNameOfClass(classOop);
	if (nameLen == 0) {
		print("a ??");
		goto l3;
	}
	name = nameOfClass(classOop);
	if (nameLen == 10) {
		if ((strncmp(name, "ByteString", 10)) == 0) {

			/* strncmp is weird */
			/* begin printChar: */
			putchar('\'');
			printStringOf(oop);
			/* begin printChar: */
			putchar('\'');

			goto l3;
		}
		if ((strncmp(name, "ByteSymbol", 10)) == 0) {

			/* strncmp is weird */
			/* begin printChar: */
			putchar('#');
			printStringOf(oop);
			goto l3;
		}
	}
	if ((nameLen == 9)
	 && ((strncmp(name, "Character", 9)) == 0)) {
		/* begin printChar: */
		putchar('$');
		/* begin printChar: */
		putchar(((longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord())))) >> 3));

		goto l3;
	}
	print("a(n) ");
	for (i = 0; i < nameLen; i += 1) {
		/* begin printChar: */
		putchar(name[i]);
	}
	if ((((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) <= 5)
	 && (((instanceSizeOf(classOop)) == (ValueIndex + 1))
	 && (isBytes(longAt((oop + BaseHeaderSize) + (((long)KeyIndex) << (shiftForWord()))))))) {
		classLookupKey = fetchClassOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord()))));
		while (1) {
			if (classLookupKey == GIV(nilObj)) {
				goto l3;
			}
			if ((instanceSizeOf(classLookupKey)) == (KeyIndex + 1)) break;
			/* begin followField:ofObject: */
			objOop = longAt((classLookupKey + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
			if (((objOop & (tagMask())) == 0)
			 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey, objOop);
			}
			classLookupKey = objOop;
		}
		if (classLookupKey == GIV(nilObj)) {
			goto l1;
		}
		theClass1 = classOop;
		while (1) {
			if (theClass1 == classLookupKey) {
				goto l2;
			}
			if (!(theClass1 != GIV(nilObj))) break;
			/* begin followField:ofObject: */
			objOop1 = longAt((theClass1 + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
			if (((objOop1 & (tagMask())) == 0)
			 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass1, objOop1);
			}
			theClass1 = objOop1;
		}
		goto l1;
	l2:	;
		/* begin space */
		putchar(' ');
		printOopShort(longAt((oop + BaseHeaderSize) + (((long)KeyIndex) << (shiftForWord()))));
		print(" -> ");
		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) (longAt((oop + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord()))))));
	l1:	;
	}
l3:	/* end printOopShortInner: */;
	flush();
}

	/* StackInterpreter>>#printOop: */
void
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt cls;
    sqInt column;
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt lastIndex;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt startIP;

	if ((oop & (tagMask())) != 0) {
		shortPrintOop(oop);
		return;
	}
	printHex(oop);
	if (!(addressCouldBeObj(oop))) {
		(print(((oop & (8 - 1)) != 0
				? " is misaligned"
				: whereIs(oop))),
		/* begin cr */
		printf("\n"));
		return;
	}
	if (((longAt(oop)) & (classIndexMask())) == 0) {
		print(" is a free chunk of size ");
		printNum(sizeOfFree(oop));
		print(" 0th: ");
		printHex(longAt((oop + BaseHeaderSize) + (0LL << (shiftForWord()))));
		printHeaderTypeOf(oop);

		/* begin cr */
		printf("\n");
		return;
	}
	if (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		print(" is a forwarded object to ");
		printHex(followForwarded(oop));
		print(" of slot size ");
		printNum(numSlotsOfAny(oop));
		printHeaderTypeOf(oop);
		/* begin cr */
		printf("\n");
		return;
	}
	print(": a(n) ");
	printNameOfClasscount((cls = fetchClassOfNonImm(oop)), 5);
	if (cls == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassFloat) << (shiftForWord()))))) {
		(/* begin cr */
		printf("\n"),
		printFloat(dbgFloatValueOf(oop)),
		/* begin cr */
		printf("\n"));
		return;
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	if (fmt > 5) {
		print(" nbytes ");
		printNum(numBytesOf(oop));
	}
	/* begin cr */
	printf("\n");
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassAlien) << (shiftForWord()))))) {
			print(" datasize ");
			printNum(sizeOfAlienData(oop));
			print(((longAt(oop + BaseHeaderSize)) < 0
				? " indirect @ "
				: ((longAt(oop + BaseHeaderSize)) == 0
						? " pointer @ "
						: " direct @ ")));
			(printHex(((usqInt)(startOfAlienData(oop)))),
			/* begin cr */
			printf("\n"));
			return;
		}
		if (((oop & (tagMask())) == 0)
		 && (((((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1))))) {
			lastIndex = ((64 < ((numBytesOf(oop)) / BytesPerWord)) ? 64 : ((numBytesOf(oop)) / BytesPerWord));
			if (lastIndex > 0) {
				for (index = 1; index <= lastIndex; index += 1) {
					/* begin space */
					putchar(' ');
					printHex(long32At((oop + BaseHeaderSize) + (((long)(index - 1)) << 2)));
					if ((index % 5) == 0) {
						/* begin cr */
						printf("\n");
					}
				}
				if (!((lastIndex % 5) == 0)) {
					/* begin cr */
					printf("\n");
				}
			}
			return;
		}
		(printStringOf(oop),
		/* begin cr */
		printf("\n"));
		return;
	}
	startIP = (((lastPointerOf(oop)) + BytesPerOop) - BaseHeaderSize) / BytesPerOop;
	lastIndex = ((256 < startIP) ? 256 : startIP);
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(longAt((oop + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord()))));
			/* begin space */
			putchar(' ');
			if ((index % 5) == 0) {
				/* begin cr */
				printf("\n");
			}
		}
		if (!((lastIndex % 5) == 0)) {
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf:format: */
		fmt1 = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
		/* begin numSlotsOfAny: */
		numSlots1 = byteAt(oop + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (fmt1 <= 5) {
			lastIndex = numSlots;
			goto l1;
		}
		if (fmt1 >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			lastIndex = (((long)numSlots) << (shiftForWord())) - (fmt1 & 7);
			goto l1;
		}
		if (fmt1 >= (firstShortFormat())) {
			lastIndex = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt1 & 3);
			goto l1;
		}
		if (fmt1 >= (firstLongFormat())) {
			lastIndex = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt1 & 1);
			goto l1;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat())) {
			lastIndex = numSlots;
			goto l1;
		}
		lastIndex = 0;
	l1:	/* end lengthOf:format: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				printf("0x%08x: ", oop+BaseHeaderSize+index-1);
			}
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			printf(" %02x/%-3d", byte,byte);
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				/* begin cr */
				printf("\n");
			}
		}
		if (!(column == 1)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			/* begin cr */
			printf("\n");
		}
	}
}

	/* StackInterpreter>>#printProcessStack: */
void
printProcessStack(sqInt aProcess)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctx;
    sqInt objOop;
    sqInt tagBits;

	/* begin cr */
	printf("\n");
	printNameOfClasscount((((tagBits = aProcess & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((long)tagBits) << (shiftForWord())))
		: fetchClassOfNonImm(aProcess)), 5);
	/* begin space */
	putchar(' ');
	printHex(aProcess);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, aProcess));
	/* begin cr */
	printf("\n");
	/* begin followField:ofObject: */
	objOop = longAt((aProcess + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuspendedContextIndex, aProcess, objOop);
	}
	ctx = objOop;
	if (!(ctx == GIV(nilObj))) {
		printCallStackOfcurrentFP(ctx, GIV(framePointer));
	}
}

	/* StackInterpreter>>#printProcsOnList: */
sqInt
printProcsOnList(sqInt procList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstProc;
    sqInt objOop;
    sqInt proc;

	proc = (firstProc = followFieldofObject(FirstLinkIndex, procList));
	while (!(proc == GIV(nilObj))) {
		printProcessStack(proc);
		/* begin followField:ofObject: */
		objOop = longAt((proc + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())));
		if (((objOop & (tagMask())) == 0)
		 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, proc, objOop);
		}
		proc = objOop;
		if (proc == firstProc) {
			warning("circular process list!!");
			return null;
		}
	}
}

	/* StackInterpreter>>#printStackCallStackOf: */
sqInt
printStackCallStackOf(sqInt aContextOrProcessOrFrame)
{
    sqInt context;
    char *theFP;

	if (addressCouldBeObj(aContextOrProcessOrFrame)) {
		if ((((aContextOrProcessOrFrame & (tagMask())) == 0)
		 && (((longAt(aContextOrProcessOrFrame)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && (checkIsStillMarriedContextcurrentFP(aContextOrProcessOrFrame, null))) {
			return printStackCallStackOf(((sqInt)(frameOfMarriedContext(aContextOrProcessOrFrame))));
		}
		if (couldBeProcess(aContextOrProcessOrFrame)) {
			return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord()))));
		}
		return null;
	}

	theFP = ((void *)aContextOrProcessOrFrame);
	while(1) {
		context = shortReversePrintFrameAndCallers(theFP);
		if (!((((((longAt((context + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
			 && (((theFP = frameOfMarriedContext(context)),
			checkIsStillMarriedContextcurrentFP(context, theFP))))) {
			return null;
		}
	}
}

	/* StackInterpreter>>#printStackPageList */
void
printStackPageList(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		/* begin printStackPage: */
		printStackPageuseCount(page, -1);
		/* begin cr */
		printf("\n");
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#printStackPageListInUse */
void
printStackPageListInUse(void)
{
    sqInt n;
    StackPage *page;

	page = mostRecentlyUsedPage();
	n = 0;
	do {
		if (!(isFree(page))) {
			printStackPageuseCount(page, (n += 1));
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#printStackPages */
void
printStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *page;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin printStackPage: */
		page = stackPageAtpages(i, GIV(pages));
		printStackPageuseCount(page, -1);
		/* begin cr */
		printf("\n");
	}
}

	/* StackInterpreter>>#printStackPagesInUse */
void
printStackPagesInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt n;

	n = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		if (!(isFree(stackPageAt(i)))) {
			printStackPageuseCount(stackPageAt(i), (n += 1));
			/* begin cr */
			printf("\n");
		}
	}
}

	/* StackInterpreter>>#printStackPage:useCount: */
static void NoDbgRegParms
printStackPageuseCount(StackPage *page, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *p;
    void *p1;
    void *p2;
    void *p3;
    void *p4;
    void *p5;
    void *p6;
    void *p7;
    void *p8;

	print("page ");
	/* begin printHexPtr: */
	printHex(oopForPointer(page));
	print(" (");
	printNum(pageIndexFor((page->realStackLimit)));
	if (n >= 0) {
		print(",");
		printNum(n);
	}
	print(")  (trace: ");
	printNum((page->trace));
	/* begin printChar: */
	putchar(')');
	if (isFree(page)) {
		print(" (free)");
	}
	if (page == (mostRecentlyUsedPage())) {
		print(" (MRU)");
	}
	if (((page->prevPage)) == (mostRecentlyUsedPage())) {
		print(" (LRU)");
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	putchar('	');
	print("ba: ");
	/* begin printHexPtr: */
	p3 = (page->baseAddress);
	printHex(oopForPointer(p3));
	print(" - sl: ");
	/* begin printHexPtr: */
	p4 = (page->realStackLimit);
	printHex(oopForPointer(p4));
	print(" - sl-so: ");
	/* begin printHexPtr: */
	p5 = ((page->realStackLimit)) - ((FrameSlots + 64) * BytesPerWord);
	printHex(oopForPointer(p5));
	print(" - la:");
	/* begin printHexPtr: */
	p6 = (page->lastAddress);
	printHex(oopForPointer(p6));
	if (!(isFree(page))) {
		/* begin cr */
		printf("\n");
		/* begin tab */
		putchar('	');
		print("baseFP ");
		/* begin printHexPtr: */
		p = (page->baseFP);
		printHex(oopForPointer(p));
		/* begin tab */
		putchar('	');
		print("headFP ");
		/* begin printHexPtr: */
		p1 = (page->headFP);
		printHex(oopForPointer(p1));
		/* begin tab */
		putchar('	');
		print("headSP ");
		/* begin printHexPtr: */
		p2 = (page->headSP);
		printHex(oopForPointer(p2));
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	putchar('	');
	print("prev ");
	/* begin printHexPtr: */
	p7 = ((void *) (page->prevPage));
	printHex(oopForPointer(p7));
	print(" (");
	printNum(pageIndexForstackMemorybytesPerPage((((page->prevPage))->realStackLimit), GIV(stackMemory), GIV(bytesPerPage)));
	/* begin printChar: */
	putchar(')');
	/* begin tab */
	putchar('	');
	print("next ");
	/* begin printHexPtr: */
	p8 = ((void *) (page->nextPage));
	printHex(oopForPointer(p8));
	print(" (");
	printNum(pageIndexForstackMemorybytesPerPage((((page->nextPage))->realStackLimit), GIV(stackMemory), GIV(bytesPerPage)));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printStackReferencesTo: */
void
printStackReferencesTo(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					if (oop == (longAt(theSP))) {
						print("FP: ");
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) theFP));
						print(" @ ");
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) theSP));
						/* begin cr */
						printf("\n");
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					if (oop == (longAt(theFP + FoxThisContext))) {
						print("FP: ");
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) theFP));
						print(" CTXT");
						/* begin cr */
						printf("\n");
					}
				}
				if (oop == (longAt(theFP + FoxMethod))) {
					print("FP: ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) theFP));
					print(" MTHD");
					/* begin cr */
					printf("\n");
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerContext */
			theSP = theFP + FoxCallerSavedIP;
			while (theSP <= ((thePage->baseAddress))) {
				if (oop == (longAt(theSP))) {
					print("FP: ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) theFP));
					print(" @ ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) theSP));
					/* begin cr */
					printf("\n");
				}
				theSP += BytesPerWord;
			}
		}
	}
}

	/* StackInterpreter>>#printStringOf: */
static void NoDbgRegParms
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    sqInt fmt;
    sqInt i;
    sqInt len;
    sqInt max;

	if ((oop & (tagMask())) != 0) {
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		return;
	}
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	if (fmt < (firstByteFormat())) {
		return;
	}
	cnt = ((((max = 128)) < ((len = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask()))))) ? ((max = 128)) : ((len = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())))));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteArray) << (shiftForWord()))), GIV(classByteArrayCompactIndex)))
	 || ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassLargePositiveInteger) << (shiftForWord()))), ClassLargePositiveIntegerCompactIndex))
	 || (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassLargeNegativeInteger) << (shiftForWord()))), ClassLargeNegativeIntegerCompactIndex)))) {
		while (i < cnt) {
			printHex(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			if ((byteAt((oop + BaseHeaderSize) + i)) == 13) {

				/* Character cr asInteger */
				print("<CR>");
				if ((i + 1) < len) {
					print("...");
				}
				return;
			}
			/* begin printChar: */
			putchar(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	if (len > max) {
		print("...");
	}
	flush();
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#print: */
void
print(char *s)
{
	fputs(s, stdout);
}

	/* StackInterpreter>>#pushBool: */
void
pushBool(sqInt trueOrFalse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	The receiver of a message send or the closure of a block activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#pushedReceiverOrClosureOfFrame: */
static sqInt NoDbgRegParms
pushedReceiverOrClosureOfFrame(char *theFP)
{
	return longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()))));
}

	/* StackInterpreter>>#pushFloat: */
void
pushFloat(double f)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = floatObjectOf(f);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

	/* StackInterpreter>>#pushInteger: */
sqInt
pushInteger(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), ((integerValue << 3) | 1));
	GIV(stackPointer) = sp;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#push: */
void
push(sqInt object)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Append aLong to aFile in this platform's 'natural' byte order. aLong is
	either 32 or 64 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putLong:toFile: */
static void NoDbgRegParms
putLongtoFile(long aLong, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aLong), sizeof(long), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Append the 16-bit aShort to aFile in this platform's 'natural' byte order.
	(Bytes will be swapped, if necessary, when the image is read on a
	different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putShort:toFile: */
static void NoDbgRegParms
putShorttoFile(short aShort, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aShort), sizeof(short), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Save the given process on the scheduler process list for its priority,
	adding to the back if yieldImplicitly or to the front if not
	yieldImplicitly. 
 */

	/* StackInterpreter>>#putToSleep:yieldingIf: */
static void NoDbgRegParms
putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt objOop;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aProcess + BaseHeaderSize) + (((long)PriorityIndex) << (shiftForWord())));
	assert((((oop) & 7) == 1));
	priority = (oop >> 3);
	if ((GIV(highestRunnableProcessPriority) != 0)
	 && (priority > GIV(highestRunnableProcessPriority))) {
		GIV(highestRunnableProcessPriority) = priority;
	}
	/* begin fetchPointer:ofObject: */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	processLists = longAt((objOop + BaseHeaderSize) + (((long)ProcessListsIndex) << (shiftForWord())));
	processList = longAt((processLists + BaseHeaderSize) + (((long)(priority - 1)) << (shiftForWord())));
	if (yieldImplicitly) {
		addLastLinktoList(aProcess, processList);
	}
	else {
		/* begin addFirstLink:toList: */
		assert(!(isForwarded(processList)));
		assert((fetchPointerofObject(NextLinkIndex, aProcess)) == (nilObject()));
		firstLink = longAt((processList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())));
		assert(firstLink != aProcess);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(processList)));
		if (isOldObject(processList)) {

			/* most stores into young objects */
			if (((aProcess & (tagMask())) == 0)
			 && (oopisLessThan(aProcess, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(processList))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(processList);
				}
			}
		}
		longAtput((processList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())), aProcess);
		if (firstLink == GIV(nilObj)) {

			/* a.k.a. (self isEmptyList: aList) */
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(processList)));
			if (isOldObject(processList)) {

				/* most stores into young objects */
				if (((aProcess & (tagMask())) == 0)
				 && (oopisLessThan(aProcess, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(processList))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(processList);
					}
				}
			}
			longAtput((processList + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())), aProcess);
		}
		else {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aProcess)));
			if (isOldObject(aProcess)) {

				/* most stores into young objects */
				if (((firstLink & (tagMask())) == 0)
				 && (oopisLessThan(firstLink, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(aProcess))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(aProcess);
					}
				}
			}
			longAtput((aProcess + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())), firstLink);
		}
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aProcess)));
		if (isOldObject(aProcess)) {

			/* most stores into young objects */
			if (((processList & (tagMask())) == 0)
			 && (oopisLessThan(processList, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aProcess))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(aProcess);
				}
			}
		}
		longAtput((aProcess + BaseHeaderSize) + (((long)MyListIndex) << (shiftForWord())), processList);
	}
}


/*	Append aWord32 to aFile in this platform's 'natural' byte order. aWord32
	is 32 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putWord32:toFile: */
static void NoDbgRegParms
putWord32toFile(int aWord32, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aWord32), 4, 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Return the integer value of the field without verifying that it is an
	integer value! For use in time-critical places where the integer-ness of
	the field can be guaranteed.
 */

	/* StackInterpreter>>#quickFetchInteger:ofObject: */
static sqInt NoDbgRegParms
quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt oop;

	oop = longAt((objectPointer + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())));
	assert((((oop) & 7) == 1));
	return (oop >> 3);
}


/*	Anwer true if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

	/* StackInterpreter>>#readableFormat: */
sqInt
readableFormat(sqInt imageVersion)
{
	return (imageVersion == (imageFormatVersion()))
	 || (0);
}


/*	Read an image from the given file stream, allocating an amount of memory
	to its object heap.
	
	V3: desiredHeapSize is the total size of the heap. Fail if the image has
	an unknown format or
	requires more than the specified amount of memory.
	
	Spur: desiredHeapSize is ignored; this routine will attempt to provide at
	least extraVMMemory's
	ammount of free space after the image is loaded, taking any free space in
	teh image into account.
	extraVMMemory is stored in the image header and is accessible as
	vmParameterAt: 23. If
	extraVMMemory is 0, the value defaults to the default grow headroom. Fail
	if the image has an
	unknown format or if sufficient memory cannot be allocated.
	
	Details: This method detects when the image was stored on a machine with
	the opposite byte
	ordering from this machine and swaps the bytes automatically. Furthermore,
	it allows the header
	information to start 512 bytes into the file, since some file transfer
	programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix
	area could also be used to store an exec command on Unix systems, allowing
	one to launch
	Smalltalk by invoking the image name as a command. */

	/* StackInterpreter>>#readImageFromFile:HeapSize:StartingAt: */
size_t
readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualEdenBytes;
    usqInt allocationReserve;
    SpurNewSpaceSpace *aNewSpace;
    sqInt anObject;
    sqInt aValue;
    sqInt baseOfHeap;
    sqInt bit;
    sqInt bytes;
    sqInt bytesRead;
    usqInt bytesToShift;
    sqInt classArrayClass;
    sqInt classArrayObj;
    size_t dataSize;
    sqInt edenBytes;
    sqInt firstSegSize;
    sqInt freeOldSpaceInImage;
    sqInt hdrEdenBytes;
    sqInt hdrMaxExtSemTabSize;
    sqInt hdrNumStackPages;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt headroom;
    sqInt headroom1;
    usqInt heapSize;
    usqInt heapSize1;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    usqInt limit;
    sqInt maxFramesPerPage;
    sqInt maxUsedBytesPerPage;
    sqInt memEnd;
    sqInt memLimit;
    usqInt minimumMemory;
    usqInt numSlots;
    sqInt objOop;
    sqInt oldBaseAddr;
    sqInt oldStart;
    sqInt oop;
    sqInt p;
    sqInt seed;
    sqInt survivorBytes;
    sqInt swapBytes;
    sqInt totalBytes;
    sqInt w;
    int w1;
    short w10;
    short w11;
    sqInt w12;
    sqInt w13;
    sqInt w14;
    sqInt w2;
    sqInt w3;
    sqInt w4;
    sqInt w5;
    int w6;
    short w7;
    short w8;
    int w9;


	/* guess Metaclass instSize */
	GIV(metaclassNumSlots) = 6;

	/* guess (Class instVarIndexFor: 'name' ifAbsent: []) - 1 */
	GIV(classNameIndex) = 6;
	swapBytes = checkImageVersionFromstartingAt(f, imageOffset);

	/* record header start position */
	headerStart = (sqImageFilePosition(f)) - 4;
	/* begin getWord32FromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(int), 1, f);
	headerSize = (swapBytes
		? byteSwapped(w1)
		: w1);
	/* begin getLongFromFile:swap: */
	w2 = 0;
	sqImageFileRead((&w2), sizeof(w2), 1, f);
	dataSize = (swapBytes
		? byteSwapped(w2)
		: w2);
	/* begin getLongFromFile:swap: */
	w3 = 0;
	sqImageFileRead((&w3), sizeof(w3), 1, f);
	oldBaseAddr = (swapBytes
		? byteSwapped(w3)
		: w3);
	/* begin specialObjectsOop: */
	w13 = 0;
	sqImageFileRead((&w13), sizeof(w13), 1, f);
	anObject = (swapBytes
		? byteSwapped(w13)
		: w13);
	GIV(specialObjectsOop) = anObject;
	/* begin lastHash: */
	w14 = 0;
	sqImageFileRead((&w14), sizeof(w14), 1, f);
	seed = (swapBytes
		? byteSwapped(w14)
		: w14);
	GIV(lastHash) = seed;
	/* begin getLongFromFile:swap: */
	w4 = 0;
	sqImageFileRead((&w4), sizeof(w4), 1, f);
	GIV(savedWindowSize) = (swapBytes
		? byteSwapped(w4)
		: w4);
	/* begin getLongFromFile:swap: */
	w5 = 0;
	sqImageFileRead((&w5), sizeof(w5), 1, f);
	headerFlags = (swapBytes
		? byteSwapped(w5)
		: w5);
	/* begin setImageHeaderFlagsFrom: */

	/* so as to preserve unrecognised flags. */
	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;
	GIV(imageFloatsBigEndian) = ((headerFlags & 2) == 0
		? 1
		: 0);
	GIV(preemptionYields) = (headerFlags & 16) == 0;
	GIV(newFinalization) = (headerFlags & 64) != 0;
	/* begin getWord32FromFile:swap: */
	w6 = 0;
	sqImageFileRead((&w6), sizeof(int), 1, f);
	extraVMMemory = (swapBytes
		? byteSwapped(w6)
		: w6);
	/* begin getShortFromFile:swap: */
	w7 = 0;
	sqImageFileRead((&w7), sizeof(short), 1, f);
	hdrNumStackPages = (swapBytes
		? byteSwapped(w7)
		: w7);
	GIV(numStackPages) = (desiredNumStackPages != 0
		? desiredNumStackPages
		: (hdrNumStackPages == 0
				? defaultNumStackPages()
				: hdrNumStackPages));

	/* pad to word boundary.  This slot can be used for anything else that will fit in 16 bits.
	   It is used for the cog code size in Cog.  Preserve it to be polite to other VMs. */
	desiredNumStackPages = hdrNumStackPages;
	/* begin getShortFromFile:swap: */
	w8 = 0;
	sqImageFileRead((&w8), sizeof(short), 1, f);
	GIV(theUnknownShort) = (swapBytes
		? byteSwapped(w8)
		: w8);
	/* begin getWord32FromFile:swap: */
	w9 = 0;
	sqImageFileRead((&w9), sizeof(int), 1, f);
	hdrEdenBytes = (swapBytes
		? byteSwapped(w9)
		: w9);
	/* begin edenBytes: */
	bytes = (desiredEdenBytes != 0
		? desiredEdenBytes
		: (hdrEdenBytes == 0
				? defaultEdenBytes()
				: hdrEdenBytes));
	edenBytes = bytes;
	desiredEdenBytes = hdrEdenBytes;
	/* begin getShortFromFile:swap: */
	w10 = 0;
	sqImageFileRead((&w10), sizeof(short), 1, f);
	hdrMaxExtSemTabSize = (swapBytes
		? byteSwapped(w10)
		: w10);
	if (hdrMaxExtSemTabSize != 0) {
		/* begin setMaxExtSemSizeTo: */
		GIV(maxExtSemTabSizeSet) = 1;
		ioSetMaxExtSemTableSize(hdrMaxExtSemTabSize);
	}
	/* begin getShortFromFile:swap: */
	w11 = 0;
	sqImageFileRead((&w11), sizeof(short), 1, f);
	GIV(the2ndUnknownShort) = (swapBytes
		? byteSwapped(w11)
		: w11);
	/* begin getLongFromFile:swap: */
	w12 = 0;
	sqImageFileRead((&w12), sizeof(w12), 1, f);
	firstSegSize = (swapBytes
		? byteSwapped(w12)
		: w12);
	/* begin firstSegmentSize: */
	GIV(firstSegmentSize) = firstSegSize;
	/* begin interpreterAllocationReserveBytes */
	maxUsedBytesPerPage = (stackPageFrameBytes()) + ((FrameSlots + 64) * BytesPerWord);
	maxFramesPerPage = (maxUsedBytesPerPage / BytesPerWord) / FrameSlots;
	allocationReserve = ((maxFramesPerPage * LargeContextSlots) * BytesPerOop) * GIV(numStackPages);
	minimumMemory = (dataSize + edenBytes) + allocationReserve;
	/* begin getLongFromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(w), 1, f);
	freeOldSpaceInImage = (swapBytes
		? byteSwapped(w)
		: w);
	/* begin initialHeadroom:givenFreeOldSpaceInImage: */
	headroom1 = (extraVMMemory == 0
		? (!(GIV(growHeadroom))
				? (16 * 1024) * 1024
				: GIV(growHeadroom))
		: extraVMMemory);
	if (freeOldSpaceInImage >= headroom1) {
		headroom = 0;
		goto l1;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 7) / 8)) {
		headroom = headroom1 / 8;
		goto l1;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 3) / 4)) {
		headroom = headroom1 / 4;
		goto l1;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 5) / 8)) {
		headroom = (headroom1 * 3) / 8;
		goto l1;
	}
	if (freeOldSpaceInImage >= (headroom1 / 2)) {
		headroom = headroom1 / 2;
		goto l1;
	}
	headroom = headroom1;
l1:	/* end initialHeadroom:givenFreeOldSpaceInImage: */;
	/* begin roundUpHeapSize: */
	heapSize1 = ((dataSize + headroom) + edenBytes) + ((headroom > allocationReserve
	? 0
	: allocationReserve));
	bit = (((highBit(heapSize1)) - 1) * 3) / 4;
	heapSize = ((sqInt) ((heapSize1 & ((1LL << bit) - 1)
	? (((heapSize1 | ((1LL << bit) - 1)) - ((1LL << bit) - 1))) + (1LL << bit)
	: heapSize1)));

	/* begin memory: */
	aValue = ((usqInt)(pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))));
	GIV(memory) = aValue;
	if (!(memory())) {
		insufficientMemoryAvailableError();
	}
	/* begin setHeapBase:memoryLimit:endOfMemory: */
	baseOfHeap = memory();
	memLimit = (memory()) + heapSize;
	memEnd = (memory()) + dataSize;
	GIV(newSpaceStart) = baseOfHeap;
	GIV(newSpaceLimit) = (baseOfHeap + edenBytes) + (interpreterAllocationReserveBytes());
	/* begin newSpaceStart:newSpaceBytes:edenBytes: */
	totalBytes = GIV(newSpaceLimit) - GIV(newSpaceStart);
	actualEdenBytes = ((GIV(newSpaceLimit) - GIV(newSpaceStart)) * (7 - 2)) / 7;
	survivorBytes = (((totalBytes - actualEdenBytes) / 2) & ~7);
	actualEdenBytes = (((totalBytes - survivorBytes) - survivorBytes) & ~7);
	assert((((totalBytes - actualEdenBytes) - survivorBytes) - survivorBytes) < (allocationUnit()));
	(GIV(pastSpace).start = GIV(newSpaceStart));
	(GIV(pastSpace).limit = GIV(newSpaceStart) + survivorBytes);
	(GIV(futureSpace).start = (GIV(pastSpace).limit));
	(GIV(futureSpace).limit = ((GIV(pastSpace).limit)) + survivorBytes);
	(GIV(eden).start = (GIV(futureSpace).limit));
	(GIV(eden).limit = ((GIV(futureSpace).limit)) + actualEdenBytes);
	assert(((GIV(futureSpace).limit)) <= (GIV(newSpaceStart) + totalBytes));
	assert(((((GIV(eden).start)) % (allocationUnit())) + (((GIV(eden).limit)) % (allocationUnit()))) == 0);
	assert(((((GIV(pastSpace).start)) % (allocationUnit())) + (((GIV(pastSpace).limit)) % (allocationUnit()))) == 0);
	assert(((((GIV(futureSpace).start)) % (allocationUnit())) + (((GIV(futureSpace).limit)) % (allocationUnit()))) == 0);
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	/* begin initSpaceForAllocationCheck:limit: */
	aNewSpace = ((SpurNewSpaceSpace *) ((&GIV(eden))));
	limit = (GIV(eden).limit);
	if (!(GIV(memory) == null)) {
		if (checkAllocFiller()) {
			for (p = ((aNewSpace->start)); p < limit; p += BytesPerWord) {
				longAtput(p, p);
			}
		}
	}
	GIV(tenuringProportion) = 0.9;
	GIV(freeStart) = ((eden()).start);
	GIV(pastSpaceStart) = ((pastSpace()).start);
	GIV(oldSpaceStart) = GIV(newSpaceLimit);
	GIV(freeOldSpaceStart) = memEnd;
	GIV(endOfMemory) = memLimit;
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = readHeapFromImageFiledataBytes(f, dataSize);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes);
	bytesToShift = GIV(oldSpaceStart) - oldBaseAddr;
	/* begin initializeInterpreter: */
	interpreterProxy = sqGetInterpreterProxy();
	dummyReferToProxy();
	initializeObjectMemory(bytesToShift);
	/* begin checkAssumedCompactClasses */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassArray) << (shiftForWord())))) != (knownClassAtIndex(ClassArrayCompactIndex))) {
		invalidCompactClassError("Array");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassLargeNegativeInteger) << (shiftForWord())))) != (knownClassAtIndex(ClassLargeNegativeIntegerCompactIndex))) {
		invalidCompactClassError("LargeNegativeInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassLargePositiveInteger) << (shiftForWord())))) != (knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))) {
		invalidCompactClassError("LargePositiveInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassFloat) << (shiftForWord())))) != (knownClassAtIndex(ClassFloatCompactIndex))) {
		invalidCompactClassError("Float");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassBlockClosure) << (shiftForWord())))) != (knownClassAtIndex(ClassBlockClosureCompactIndex))) {
		invalidCompactClassError("BlockClosure");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassMethodContext) << (shiftForWord())))) != (knownClassAtIndex(ClassMethodContextCompactIndex))) {
		invalidCompactClassError("MethodContext");
	}
	/* begin compactIndexOfClass: */
	objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassByteArray) << (shiftForWord())));
	assert((rawHashBitsOf(objOop)) != 0);
	GIV(classByteArrayCompactIndex) = (long32At(objOop + 4)) & (identityHashHalfWordMask());
	/* begin initializeExtraClassInstVarIndices */
	classArrayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassArray) << (shiftForWord())));
	classArrayClass = fetchClassOfNonImm(classArrayObj);
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classArrayClass)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(classArrayClass + 7);
	GIV(metaclassNumSlots) = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(classArrayClass - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);

	/* default */
	GIV(thisClassIndex) = 5;
	for (i1 = (InstanceSpecificationIndex + 1), iLimiT = (lengthOfformat(classArrayClass, (((usqInt) (longAt(classArrayClass))) >> (formatShift())) & (formatMask()))); i1 <= iLimiT; i1 += 1) {
		if ((longAt((classArrayClass + BaseHeaderSize) + (((long)(i1 - 1)) << (shiftForWord())))) == classArrayObj) {
			GIV(thisClassIndex) = i1 - 1;
		}
	}

	/* default */
	GIV(classNameIndex) = 6;
	for (i1 = (InstanceSpecificationIndex + 1), iLimiT = (lengthOfformat(classArrayObj, (((usqInt) (longAt(classArrayObj))) >> (formatShift())) & (formatMask()))); i1 <= iLimiT; i1 += 1) {
		oop = longAt((classArrayObj + BaseHeaderSize) + (((long)(i1 - 1)) << (shiftForWord())));
		if ((((oop & (tagMask())) == 0)
		 && (((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
		 && (((lengthOfformat(oop, (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask()))) == 5)
		 && ((strncmp("Array", firstFixedField(oop), 5)) == 0))) {
			GIV(classNameIndex) = i1 - 1;
		}
	}
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	GIV(methodDictLinearSearchLimit) = 8;
	/* begin initialCleanup */
	flushMethodCache();
	/* begin flushExternalPrimitiveTable */
	for (i = 0; i < MaxExternalPrimitiveTableSize; i += 1) {
		externalPrimitiveTable[i] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	GIV(profileSemaphore) = (GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj)));

	/* cmd-. as used for Mac but no other OS */
	GIV(interruptKeycode) = 2094;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = (time(NULL)) + (ioMSecs());
	}
	return dataSize;
}


/*	callbackContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state,
	and mark calloutContext as dead. */

	/* StackInterpreter>>#reestablishContextPriorToCallback: */
EXPORT(sqInt)
reestablishContextPriorToCallback(sqInt callbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutContext;
    sqInt index;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;

	flag("obsolete");
	if (!(isLiveContext(callbackContext))) {
		return 0;
	}
	calloutContext = externalInstVarofContext(SenderIndex, callbackContext);
	if (!(isLiveContext(calloutContext))) {
		return 0;
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (isNonImmediate(longAt((callbackContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) {
		/* begin markContextAsDead: */
		assert(isContext(callbackContext));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(callbackContext)));
		longAtput((callbackContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(callbackContext)));
		longAtput((callbackContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
	}
	else {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - 1);
		if (GIV(framePointer) == theFP) {

			/* common case */
			if ((longAt(theFP + FoxSavedFP)) == 0) {
				freeStackPage(GIV(stackPage));
			}
			else {

				/* calloutContext is immediately below on the same page.  Make it current. */
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(GIV(framePointer) + FoxCallerSavedIP))));
				GIV(stackPointer) = (GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((GIV(framePointer) + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
				GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackContext));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(callbackContext)));
			longAtput((callbackContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(callbackContext)));
			longAtput((callbackContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
		}
	}
	if ((((((longAt((calloutContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(calloutContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((calloutContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop1) & 7) == 1));
		theFP = pointerForOop(senderOop1 - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
	}
	else {
		thePage = makeBaseFrameFor(calloutContext);
		GIV(framePointer) = (thePage->headFP);
		GIV(stackPointer) = (thePage->headSP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	return 1;
}


/*	Remove the first process from the given linked list. */

	/* StackInterpreter>>#removeFirstLinkOfList: */
static sqInt NoDbgRegParms
removeFirstLinkOfList(sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt first;
    sqInt last;
    sqInt next;

	assert(!((isForwarded(aList))));
	first = longAt((aList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())));
	last = longAt((aList + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())));
	assert(!((isForwarded(first))));
	assert(!((isForwarded(last))));
	if (first == last) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		longAtput((aList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		longAtput((aList + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())), GIV(nilObj));
	}
	else {
		next = longAt((first + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if (isOldObject(aList)) {

			/* most stores into young objects */
			if (((next & (tagMask())) == 0)
			 && (oopisLessThan(next, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aList))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(aList);
				}
			}
		}
		longAtput((aList + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())), next);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(first)));
	longAtput((first + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())), GIV(nilObj));
	return first;
}


/*	Make aProcess runnable and if its priority is higher than that of the
	current process, preempt the current process. Answer if the current
	process was preempted. If the current process was preempted then if
	yieldImplicitly add the current process to the back of its run queue,
	causing an implicit yiled to other processes on the run queue, otherwise
	add the current process to the front of its run queue, hence not yielding.
	Blue book behaviour is to yield implicitly but is arguably incorrect. */

	/* StackInterpreter>>#resume:preemptedYieldingIf: */
static sqInt NoDbgRegParms
resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activePriority;
    sqInt activeProc;
    sqInt newPriority;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;

	/* begin fetchPointer:ofObject: */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	activeProc = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (((long)PriorityIndex) << (shiftForWord())));
	assert((((oop) & 7) == 1));
	activePriority = (oop >> 3);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aProcess + BaseHeaderSize) + (((long)PriorityIndex) << (shiftForWord())));
	assert((((oop1) & 7) == 1));
	newPriority = (oop1 >> 3);
	if (newPriority <= activePriority) {
		putToSleepyieldingIf(aProcess, 1);
		return 0;
	}
	putToSleepyieldingIf(activeProc, yieldImplicitly);
	transferTo(aProcess);
	return 1;
}


/*	callbackMethodContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state (via longjmp),
	and mark callbackMethodContext as dead. */

	/* StackInterpreter>>#returnAs:ThroughCallback:Context: */
EXPORT(sqInt)
returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutMethodContext;
    sqInt index;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;

	if (!(((((returnTypeOop) & 7) == 1))
		 && (isLiveContext(callbackMethodContext)))) {
		return 0;
	}
	calloutMethodContext = externalInstVarofContext(SenderIndex, callbackMethodContext);
	if (!(isLiveContext(calloutMethodContext))) {
		return 0;
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (isNonImmediate(longAt((callbackMethodContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) {
		/* begin markContextAsDead: */
		assert(isContext(callbackMethodContext));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(callbackMethodContext)));
		longAtput((callbackMethodContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(callbackMethodContext)));
		longAtput((callbackMethodContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
	}
	else {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackMethodContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - 1);
		if (GIV(framePointer) == theFP) {

			/* common case */
			if ((longAt(theFP + FoxSavedFP)) == 0) {
				freeStackPage(GIV(stackPage));
			}
			else {

				/* calloutMethodContext is immediately below on the same page.  Make it current. */
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(GIV(framePointer) + FoxCallerSavedIP))));
				GIV(stackPointer) = (GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((GIV(framePointer) + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
				GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 3));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackMethodContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackMethodContext));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(callbackMethodContext)));
			longAtput((callbackMethodContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(callbackMethodContext)));
			longAtput((callbackMethodContext + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
		}
	}
	if ((((((longAt((calloutMethodContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(calloutMethodContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((calloutMethodContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop1) & 7) == 1));
		theFP = pointerForOop(senderOop1 - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
	}
	else {
		thePage = makeBaseFrameFor(calloutMethodContext);
		GIV(framePointer) = (thePage->headFP);
		GIV(stackPointer) = (thePage->headSP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin setMethod: */
	GIV(method) = longAt((calloutMethodContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord())));
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);

	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 3));
	return 1;
}


/*	Reverse the given range of Display words (at different bit 
	depths, this will reverse different numbers of pixels). Used to 
	give feedback during VM activities such as garbage 
	collection when debugging. It is assumed that the given 
	word range falls entirely within the first line of the Display. */

	/* StackInterpreter>>#reverseDisplayFrom:to: */
static sqInt NoDbgRegParms
reverseDisplayFromto(sqInt startIndex, sqInt endIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt displayBits;
    sqInt displayObj;
    sqInt primFailCodeValue;
    sqInt ptr;
    sqInt reversed;
    sqInt w;
    sqInt wordEndIndex;
    sqInt wordStartIndex;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheDisplay) << (shiftForWord())));
	if (!((((displayObj & (tagMask())) == 0)
		 && (((((usqInt) (longAt(displayObj))) >> (formatShift())) & (formatMask())) <= 5))
		 && ((lengthOfformat(displayObj, (((usqInt) (longAt(displayObj))) >> (formatShift())) & (formatMask()))) >= 4))) {
		return null;
	}
	w = longAt((displayObj + BaseHeaderSize) + (1LL << (shiftForWord())));
	displayBits = longAt((displayObj + BaseHeaderSize) + (0LL << (shiftForWord())));
	if (((displayBits & (tagMask())) != 0)
	 || (((w & (tagMask())) != 1)
	 || (((((usqInt) (longAt(displayBits))) >> (formatShift())) & (formatMask())) <= 5))) {
		return null;
	}
	wordStartIndex = startIndex * 4;
	wordEndIndex = (((endIndex * 4) < ((((long)(numSlotsOf(displayBits))) << (shiftForWord())) + BaseHeaderSize)) ? (endIndex * 4) : ((((long)(numSlotsOf(displayBits))) << (shiftForWord())) + BaseHeaderSize));
	displayBits += BaseHeaderSize;
	for (ptr = (displayBits + wordStartIndex); ptr <= (displayBits + wordEndIndex); ptr += 4) {
		reversed = (long32At(ptr)) ^ 0xFFFFFFFFULL;
		long32Atput(ptr, reversed);
	}
	primFailCodeValue = GIV(primFailCode);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	displayBitsOfLeftTopRightBottom(displayObj, 0, 0, (w >> 3), 1);
	ioForceDisplayUpdate();
	GIV(primFailCode) = primFailCodeValue;
}


/*	Rewrite an existing entry in the method cache with a new primitive
	function address.
	Used by primitiveExternalCall to make direct calls to found external
	prims, or quickly
	fail not found external prims. */

	/* StackInterpreter>>#rewriteMethodCacheEntryForExternalPrimitiveToFunction: */
static void NoDbgRegParms
rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCacheMethod]) == GIV(newMethod)) {
		GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCachePrimFunction] = (((long) localPrimAddress));
	}
}


/*	Answer if there is room to push n arguments onto the current stack. We
	assume this is called by primitives that check there is enough room in any
	new context, and
	won't actually push the arguments in the current context if the primitive
	fails. With
	this assumption it is safe to answer based on the maximum argument count,
	/not/ the ammount of space in the current frame were it converted to a
	context..  */

	/* StackInterpreter>>#roomToPushNArgs: */
static sqInt NoDbgRegParms
roomToPushNArgs(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cntxSize;

	
	/* simpler code that simply insists args are <= max arg count */
	return n <= (LargeContextSlots - CtxtTempFrameStart);

}


/*	Safe version of methodClassOf: that deals with malformed compiled methods,
	etc, and does not fixup forwarding pointers.. */

	/* StackInterpreter>>#safeMethodClassOf: */
static sqInt NoDbgRegParms
safeMethodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt maybeClass;
    sqInt offset;
    sqInt referent;
    sqInt referent1;

	/* begin literal:ofMethod: */
	offset = (literalCountOfMethodHeader(methodHeaderOf(methodPointer))) - 1;
	literal = longAt((methodPointer + BaseHeaderSize) + (((long)(offset + LiteralStart)) << (shiftForWord())));
	if (((literal & (tagMask())) == 0)
	 && (((longAt(literal)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(literal));
		referent = longAt((literal + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		literal = referent;
	}
	if (!((((literal & (tagMask())) == 0)
		 && (((((usqInt) (longAt(literal))) >> (formatShift())) & (formatMask())) <= 5))
		 && ((numSlotsOf(literal)) > ValueIndex))) {
		return GIV(nilObj);
	}
	maybeClass = longAt((literal + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	if (((maybeClass & (tagMask())) == 0)
	 && (((longAt(maybeClass)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(maybeClass));
		referent1 = longAt((maybeClass + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent1 & (tagMask())) == 0)
		 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		maybeClass = referent1;
	}
	return maybeClass;
}

	/* StackInterpreter>>#saneFunctionPointerForFailureOfPrimIndex: */
static sqInt NoDbgRegParms
saneFunctionPointerForFailureOfPrimIndex(sqInt primIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return primitiveFunctionPointer == (functionPointerForinClass(primIndex, GIV(nilObj)));
}


/*	Send the calllback message to Alien class with the supplied arg(s). Use
	either the
	1 arg invokeCallbackContext: or the 4 arg
	invokeCallback:stack:registers:jmpbuf: message, depending on what selector
	is installed in the specialObjectsArray.
	Note that if invoking the legacy invokeCallback:stack:registers:jmpbuf: we
	pass the
	vmCallbackContext as the jmpbuf argument (see
	reestablishContextPriorToCallback:). The arguments are raw C addresses and
	are converted to integer objects on the way. */

	/* StackInterpreter>>#sendInvokeCallbackContext: */
EXPORT(sqInt)
sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt errorCode;
    sqInt i;
    sqInt integerValue;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    unsigned long value;
    unsigned long value1;
    unsigned long value2;

	/* begin fetchClassTagOfNonImm: */
	classTag = (longAt(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassAlien) << (shiftForWord()))))) & (classIndexMask());
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorInvokeCallback) << (shiftForWord())));
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag))) {
		if ((lookupOrdinaryNoMNUEtcInClass(classAtIndex(classTag))) != 0) {
			return 0;
		}
	}
	if (primitiveFunctionPointer != 0) {
		return 0;
	}
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassAlien) << (shiftForWord()))));
	GIV(stackPointer) = sp3;
	if ((argumentCountOf(GIV(newMethod))) == 4) {
		/* begin push: */
		value = ((usqInt)((vmCallbackContext->thunkp)));
		object = positive64BitIntegerFor(value);

		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		/* begin push: */
		value1 = ((usqInt)((vmCallbackContext->stackp)));
		object1 = positive64BitIntegerFor(value1);

		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		/* begin push: */
		value2 = ((usqInt)((vmCallbackContext->intregargsp)));
		object2 = positive64BitIntegerFor(value2);

		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object2);
		GIV(stackPointer) = sp2;
	}
	/* begin push: */
	object3 = positive64BitIntegerFor(((usqInt)vmCallbackContext));

	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp4;
	/* begin justActivateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	GIV(bytecodeSetSelector) = ((((int) methodHeader)) < 0
		? 256
		: 0);

	/* begin push: */
	object4 = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
	longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp41;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader)) < 0
								? AltLongStoreBytecode
								: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
						goto l5;
					}
				}
				errorCode = ((GIV(primFailCode) << 3) | 1);
			l5:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handleStackOverflow();
	/* begin enterSmalltalkExecutiveFromCallback */
	interpret();
	return 1;
}


/*	Send the 4 argument callback message
	invokeCallback:stack:registers:jmpbuf: to Alien class with the supplied
	args. The arguments are raw C addresses
	and are converted to integer objects on the way. */

	/* StackInterpreter>>#sendInvokeCallback:Stack:Registers:Jmpbuf: */
EXPORT(sqInt)
sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;

	/* begin fetchClassTagOfNonImm: */
	classTag = (longAt(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassAlien) << (shiftForWord()))))) & (classIndexMask());
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SelectorInvokeCallback) << (shiftForWord())));
	GIV(argumentCount) = 4;
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag))) {
		if ((lookupOrdinaryNoMNUEtcInClass(classAtIndex(classTag))) != 0) {
			return 0;
		}
	}
	if (!(((argumentCountOf(GIV(newMethod))) == 4)
		 && (primitiveFunctionPointer == 0))) {
		return 0;
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassAlien) << (shiftForWord()))));
	GIV(stackPointer) = sp;
	/* begin push: */
	object = positive64BitIntegerFor(thunkPtr);

	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp1;
	/* begin push: */
	object1 = positive64BitIntegerFor(stackPtr);

	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp2;
	/* begin push: */
	object2 = positive64BitIntegerFor(regsPtr);

	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object2);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object3 = positive64BitIntegerFor(jmpBufPtr);

	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp4;
	/* begin justActivateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	GIV(bytecodeSetSelector) = ((((int) methodHeader)) < 0
		? 256
		: 0);

	/* begin push: */
	object4 = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
	longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp41;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader)) < 0
								? AltLongStoreBytecode
								: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
						goto l5;
					}
				}
				errorCode = ((GIV(primFailCode) << 3) | 1);
			l5:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handleStackOverflow();
	/* begin enterSmalltalkExecutiveFromCallback */
	interpret();
	return 1;
}

	/* StackInterpreter>>#setBreakMNUSelector: */
void
setBreakMNUSelector(char *aString)
{
	if (((breakSelector = aString)) == null) {

		/* nil's effective length is zero */
		breakSelectorLength = MinSmallInteger;
	}
	else {
		breakSelectorLength = -(strlen(aString));
	}
}

	/* StackInterpreter>>#setBreakSelector: */
void
setBreakSelector(char *aString)
{
	if (((breakSelector = aString)) == null) {

		/* nil's effective length is zero */
		breakSelectorLength = MinSmallInteger;
	}
	else {
		breakSelectorLength = strlen(aString);
	}
}

	/* StackInterpreter>>#setFullScreenFlag: */
void
setFullScreenFlag(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(fullScreenFlag) = value;
}

	/* StackInterpreter>>#setInterruptCheckChain: */
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))())

{
    void (*prevFunction)();

	prevFunction = interruptCheckChain;
	interruptCheckChain = aFunction;
	return prevFunction;
}

	/* StackInterpreter>>#setInterruptKeycode: */
void
setInterruptKeycode(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(interruptKeycode) = value;
}

	/* StackInterpreter>>#setInterruptPending: */
void
setInterruptPending(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	forceInterruptCheck();
	GIV(interruptPending) = value;
}

	/* StackInterpreter>>#setNextWakeupUsecs: */
void
setNextWakeupUsecs(usqLong value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(nextWakeupUsecs) = value;
}

	/* StackInterpreter>>#setSavedWindowSize: */
void
setSavedWindowSize(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(savedWindowSize) = value;
}


/*	The low space semaphore is about to be signaled. Set the signalLowSpace
	flag, and force an interrupt check. Save the currently active process in
	the special
	objects array so that the low space handler will be able to determine the
	process that first triggered a low space condition. The image's low space
	handler is expected
	to nil out the special objects array slot when it handles the low space
	condition.  */

	/* StackInterpreter>>#setSignalLowSpaceFlagAndSaveProcess */
static void
setSignalLowSpaceFlagAndSaveProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt lastSavedProcess;
    sqInt objOop;

	GIV(signalLowSpace) = 1;
	/* begin lowSpaceThreshold: */
	GIV(lowSpaceThreshold) = 0;
	if (GIV(totalFreeOldSpace) < 0) {
		growOldSpaceByAtLeast(0 - GIV(totalFreeOldSpace));
	}
	assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
	lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ProcessSignalingLowSpace) << (shiftForWord())));
	if (lastSavedProcess == GIV(nilObj)) {
		/* begin fetchPointer:ofObject: */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
		activeProc = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
		/* begin splObj:put: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */
			if (((activeProc & (tagMask())) == 0)
			 && (oopisLessThan(activeProc, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ProcessSignalingLowSpace) << (shiftForWord())), activeProc);
	}
	forceInterruptCheck();
}

	/* StackInterpreter>>#setTraceFlagOnContextsFramesPageIfNeeded: */
static void NoDbgRegParms
setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    void *pointer;
    sqInt senderOop;
    StackPage *thePage;

	if ((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContextDuringGC(aContext)))) {
		/* begin stackPageFor: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		pointer = pointerForOop(senderOop - 1);
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(((((thePage->trace)) >= StackPageUnreached) && (((thePage->trace)) <= StackPageTraced)));
		if (((thePage->trace)) == StackPageUnreached) {
			(thePage->trace = StackPageReachedButUntraced);
		}
	}
}

	/* StackInterpreter>>#shortPrintContext: */
static sqInt NoDbgRegParms
shortPrintContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt home;
    char *theFP;

	if (!(((aContext & (tagMask())) == 0)
		 && (((longAt(aContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		printHex(aContext);
		print(" is not a context");
		/* begin cr */
		printf("\n");
		return null;
	}
	printHex(aContext);
	if (((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			print(" I (");

			printHex(((usqInt)theFP));
			print(") ");
		}
		else {
			print(" w ");
		}
	}
	else {
		print(" s ");
	}
	home = findHomeForContext(aContext);
	if (home == null) {
		print(" BOGUS CONTEXT (can't determine home)");
	}
	else {
		printActivationNameForreceiverisBlockfirstTemporary(longAt((aContext + BaseHeaderSize) + (((long)MethodIndex) << (shiftForWord()))), (home == null
			? GIV(nilObj)
			: longAt((home + BaseHeaderSize) + (((long)ReceiverIndex) << (shiftForWord())))), home != aContext, longAt((home + BaseHeaderSize) + (((long)(0 + CtxtTempFrameStart)) << (shiftForWord()))));
	}
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#shortPrintFrameAndCallers: */
static sqInt NoDbgRegParms
shortPrintFrameAndCallers(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	shortPrintFrame(theFP);
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		shortPrintFrameAndCallers(pointerForOop(longAt(theFP + FoxSavedFP)));
	}
}


/*	use export: not api, so it won't be written to cointerp.h. cogit.c is
	unaware of StackPage
 */

	/* StackInterpreter>>#shortPrintFramesInPage: */
EXPORT(void)
shortPrintFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 1);
}

	/* StackInterpreter>>#shortPrintFramesOnStackPageListInUse */
EXPORT(void)
shortPrintFramesOnStackPageListInUse(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			print("page ");
			/* begin printHexPtrnp: */
			printf("0x%lx", ((unsigned long) (oopForPointer(page))));
			/* begin cr */
			printf("\n");
			shortPrintFramesInPage(page);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#shortPrintFrame: */
static sqInt NoDbgRegParms
shortPrintFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt frameNumArgs;
    sqInt rcvr;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		print("invalid frame pointer");
		/* begin cr */
		printf("\n");
		return null;
	}
	rcvr = longAt(theFP + FoxReceiver);
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP));
	/* begin space */
	putchar(' ');
	printActivationNameForreceiverisBlockfirstTemporary(longAt(theFP + FoxMethod), rcvr, (byteAt((theFP + FoxFrameFlags) + 3)) != 0, (0 < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
		: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord))));
	/* begin space */
	putchar(' ');
	shortPrintOop(rcvr);
}

	/* StackInterpreter>>#shortPrintFrame:AndNCallers: */
void
shortPrintFrameAndNCallers(char *theFP, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((n != 0)
	 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		shortPrintFrame(theFP);
		shortPrintFrameAndNCallers(pointerForOop(longAt(theFP + FoxSavedFP)), n - 1);
	}
}

	/* StackInterpreter>>#shortPrintOop: */
static void NoDbgRegParms
shortPrintOop(sqInt oop)
{
	/* begin printHexnp: */
	printf("0x%lx", ((unsigned long) oop));
	if ((oop & (tagMask())) != 0) {
		if ((((oop) & 7) == 1)) {
			printf("=%ld\n", (long)integerValueOf(oop));
		}
		if ((oop & (tagMask())) == 2) {
			printf("=$%ld ($%lc)\n", (long)characterValueOf(oop), (wint_t)characterValueOf(oop));
		}
		if ((oop & (tagMask())) == (smallFloatTag())) {
			printf("=%g\n", floatValueOf(oop));
		}
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		(print(((oop & (8 - 1)) != 0
				? " is misaligned"
				: whereIs(oop))),
		/* begin cr */
		printf("\n"));
		return;
	}
	if ((((longAt(oop)) & (classIndexMask())) == 0)
	 || (((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
		printOop(oop);
		return;
	}
	print(": a(n) ");
	printNameOfClasscount(fetchClassOfNonImm(oop), 5);
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#shortReversePrintFrameAndCallers: */
static sqInt NoDbgRegParms
shortReversePrintFrameAndCallers(char *aFramePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt caller;
    char *callerFP;
    sqInt referent;
    char *theFP;

	if (aFramePointer == 0) {
		return GIV(nilObj);
	}
	theFP = aFramePointer;
	while (1) {
		shortPrintFrame(theFP);
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(callerFP != 0)) break;
		theFP = callerFP;
	}
	caller = longAt(theFP + FoxCallerContext);
	if (((longAt(caller)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(caller));
		referent = longAt((caller + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		caller = referent;
	}
	return caller;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

	/* StackInterpreter>>#showDisplayBits:Left:Top:Right:Bottom: */
sqInt
showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{
	if (deferDisplayUpdates) {
		return null;
	}
	displayBitsOfLeftTopRightBottom(aForm, l, t, r, b);
}


/*	Signal all requested semaphores. Answer if a context switch has occurred. */

	/* StackInterpreter>>#signalExternalSemaphores */
static sqInt
signalExternalSemaphores(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ExternalObjectsArray) << (shiftForWord())));
	return doSignalExternalSemaphores(numSlotsOf(xArray));
}


/*	Answer a full 32 bit integer object for the given integer value.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* StackInterpreter>>#signed32BitIntegerFor: */
sqInt
signed32BitIntegerFor(sqInt integerValue)
{
	return (((((int) integerValue)) << 3) | 1);

}


/*	Answer a Large Integer object for the given integer value. N.B. will *not*
	cause a GC. */

	/* StackInterpreter>>#signed64BitIntegerFor: */
sqInt
signed64BitIntegerFor(sqLong integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    sqInt largeClass;
    sqLong magnitude;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt sz;

	sz = 0;
	if ((((((unsigned sqLong)integerValue) >> 60) + 1) & 15) <= 1) {
		return ((integerValue << 3) | 1);
	}
	sz = 8;

	if (integerValue < 0) {
		largeClass = ClassLargeNegativeIntegerCompactIndex;
		magnitude = 0 - integerValue;
	}
	else {
		largeClass = ClassLargePositiveIntegerCompactIndex;
		magnitude = integerValue;
	}
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = (firstByteFormat()) + ((8 - sz) & (BytesPerWord - 1));
	numSlots = (sz + 3) / BytesPerOop;
	assert((numSlots >= 0)
	 && (largeClass != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(largeClass))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + largeClass);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
l1:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	
#  if VMBIGENDIAN
	if (sz > 4) {
		byteAtput((newLargeInteger + BaseHeaderSize) + 7, (((unsigned sqLong)magnitude) >> 56) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 6, (((unsigned sqLong)magnitude) >> 48) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 5, (((unsigned sqLong)magnitude) >> 40) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 4, (((unsigned sqLong)magnitude) >> 32) & 0xFF);
	}
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((unsigned sqLong)magnitude) >> 24) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((unsigned sqLong)magnitude) >> 16) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((unsigned sqLong)magnitude) >> 8) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize), magnitude & 0xFF);

#  else /* VMBIGENDIAN */
	if (sz > 4) {
		long32Atput((newLargeInteger + BaseHeaderSize) + (1LL << 2), ((unsigned sqLong)magnitude) >> 32);
		magnitude = magnitude & 0xFFFFFFFFULL;
	}
	long32Atput((newLargeInteger + BaseHeaderSize) + (0LL << 2), magnitude);

#  endif /* VMBIGENDIAN */

	return newLargeInteger;
}


/*	Answer if the method starts with a long store temp bytecode, which
	indicates it has a primitive error code.
 */
/*	249		11111001	i i i i i i i i	jjjjjjjj		Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */

	/* StackInterpreter>>#sizeOfCallPrimitiveBytecode: */
sqInt
sizeOfCallPrimitiveBytecode(sqInt methodHeader)
{
	return 3;
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#sizeOfLongStoreTempBytecode: */
sqInt
sizeOfLongStoreTempBytecode(sqInt methodHeader)
{
	return 2;
}


/*	Return the number of indexable fields of the given object. This method is
	to be called from an automatically generated C primitive. The argument is
	assumed to be a pointer to the first indexable field of a words or bytes
	object; the object header starts 4 bytes before that.
 */
/*	Note: Only called by translated primitive code. */

	/* StackInterpreter>>#sizeOfSTArrayFromCPrimitive: */
sqInt
sizeOfSTArrayFromCPrimitive(void *cPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;

	oop = (oopForPointer(cPtr)) - BaseHeaderSize;
	if (!(((oop & (tagMask())) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask()))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (((long)numSlots) << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}


/*	update state of active context */

	/* StackInterpreter>>#snapshot: */
static sqInt NoDbgRegParms
snapshot(sqInt embedded)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt objOop;
    sqInt oop;
    sqInt rcvr;
    sqInt rcvr1;
    sqInt savedTenuringThreshold;
    void *setMacType;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt stackIndex;
    sqInt table;


	/* For now the stack munging below doesn't deal with more than one argument.
	   It can, and should. */
	rcvr = 0;
	if (GIV(argumentCount) != 0) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp2;

	/* update state of active process */
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(1);
	/* begin fetchPointer:ofObject: */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	activeProc = longAt((objOop + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(activeProc)));
	if (isOldObject(activeProc)) {

		/* most stores into young objects */
		if (((activeContext & (tagMask())) == 0)
		 && (oopisLessThan(activeContext, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(activeProc))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(activeProc);
			}
		}
	}
	longAtput((activeProc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())), activeContext);
	GIV(tempOop) = activeContext;
	/* begin garbageCollectForSnapshot */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
	flag("If we wanted to shrink the rememberedSet prior to snapshot this is the place to do it.");
	GIV(numCompactionPasses) = CompactionPassesForSnapshot;
	fullGC();
	GIV(numCompactionPasses) = CompactionPassesForGC;
	prepareForSnapshot();
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCModeFreeSpace | GCModeFull)) == (GCModeFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpace(GCModeFreeSpace);
	}
	activeContext = GIV(tempOop);
	GIV(tempOop) = 0;
	if (!GIV(primFailCode)) {

		/* Without contexts or stacks simulate
		   rcvr := self popStack. ''pop rcvr''
		   self push: trueObj.
		   to arrange that the snapshot resumes with true.  N.B. stackIndex is one-relative. */
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((activeContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		assert((((oop) & 7) == 1));
		stackIndex = (oop >> 3);
		rcvr = longAt((activeContext + BaseHeaderSize) + (((long)((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord())));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(activeContext)));
		longAtput((activeContext + BaseHeaderSize) + (((long)((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord())), GIV(trueObj));
		writeImageFileIO();
		if ((!GIV(primFailCode))
		 && (!embedded)) {

			/* set Mac file type and creator; this is a noop on other platforms */
			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
			if (!(setMacType == 0)) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(activeContext)));
		longAtput((activeContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())), (((stackIndex - 1) << 3) | 1));
	}
	postSnapshot();
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
	if (!GIV(primFailCode)) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp1;
		/* begin justActivateNewMethod */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
		numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
		numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

		/* could new rcvr be set at point of send? */
		rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		assert(!(isOopForwarded(rcvr1)));
		/* begin push: */
		longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp11;
		/* begin push: */
		longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp21;
		GIV(framePointer) = GIV(stackPointer);
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp3;
		/* begin setMethod:methodHeader: */
		GIV(method) = GIV(newMethod);
		assert(isOopCompiledMethod(GIV(method)));
		assert((methodHeaderOf(GIV(method))) == methodHeader);
		GIV(bytecodeSetSelector) = ((((int) methodHeader)) < 0
			? 256
			: 0);

		/* begin push: */
		object = (VMBIGENDIAN
			? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
			: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp5;
		/* begin push: */
		longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
		GIV(stackPointer) = sp6;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp7;
		}
		GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1;
		if (methodHeader & AlternateHeaderHasPrimFlag) {

			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
			GIV(instructionPointer) += 3;
			if (GIV(primFailCode) != 0) {
				if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader)) < 0
										? AltLongStoreBytecode
										: LongStoreBytecode))) {
					/* begin getErrorObjectFromPrimFailCode */
					if (GIV(primFailCode) > 0) {
						table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
						if (GIV(primFailCode) <= (numSlotsOf(table))) {
							errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
							goto l1;
						}
					}
					errorCode = ((GIV(primFailCode) << 3) | 1);
				l1:	/* end getErrorObjectFromPrimFailCode */;
					longAtPointerput(GIV(stackPointer), errorCode);
				}
				GIV(primFailCode) = 0;
			}
		}
	}
}

	/* StackInterpreter>>#space */
static void
space(void)
{
	/* begin printChar: */
	putchar(' ');
}

	/* StackInterpreter>>#specialSelector: */
sqInt
specialSelector(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord())))) + BaseHeaderSize) + (((long)(index * 2)) << (shiftForWord())));
}


/*	Insulate the stack zone from the effects of a become.
	All receivers must be unfollowed for two reasons:
	1. inst var access is direct with no read barrier
	2. super sends (always to the receiver) have no class check and so don't
	trap for forwarded receivers. This is an issue for primitives that assume
	their receiver
	is valid and don't validate.
	Super sends require an explicit check to ensure receivers in super sends
	are unforwarded.
	e.g. super doSomethingWith: (self become: other) forwards the receiver
	self pushed on the
	stack. So we could avoid following non-pointer receivers. But this is too
	tricky, Instead, we
	always follow receivers.
	Methods must be unfollowed since bytecode access is direct with no read
	barrier. But this only needs to be done if the becomeEffectsFlags indicate
	that a
	CompiledMethod was becommed.
	The scheduler state must be followed, but only if the becomeEffectsFlags
	indicate that a pointer object was becommed. */
/*	For VM profiling */

	/* StackInterpreter>>#spurPostBecomeAction: */
static void NoDbgRegParms
spurPostBecomeAction(sqInt theBecomeEffectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long c;
    long c1;
    sqInt first;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt last;
    sqInt list;
    long m;
    sqInt next;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    sqInt obj3;
    sqInt obj4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt procLists;
    sqInt referent;
    sqInt referent1;
    sqInt referent11;
    sqInt referent2;
    sqInt referent21;
    sqInt referent3;
    sqInt referent31;
    sqInt referent4;
    sqInt referent5;
    sqInt referent6;
    long s;
    long s1;
    sqInt sched;
    sqInt schedAssoc;
    sqInt xArray;

	/* begin flushAtCache */
	for (i = 1; i <= AtCacheTotalSize; i += 1) {
		GIV(atCache)[i] = 0;
	}
	if (theBecomeEffectsFlags != 0) {
		if (theBecomeEffectsFlags & BecameCompiledMethodFlag) {
			/* begin followForwardedMethodsInMethodCache */
			for (i1 = 0; i1 < MethodCacheSize; i1 += MethodCacheEntrySize) {
				c = GIV(methodCache)[i1 + MethodCacheClass];
				s = GIV(methodCache)[i1 + MethodCacheSelector];
				m = GIV(methodCache)[i1 + MethodCacheMethod];
				if ((c != 0)
				 && ((s != 0)
				 && ((m != 0)
				 && (((m & (tagMask())) == 0)
				 && (((longAt(m)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(m));
					referent = longAt((m + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					m = referent;
					GIV(methodCache)[i1 + MethodCacheMethod] = m;
				}
			}
		}
		if (theBecomeEffectsFlags & BecameActiveClassFlag) {
			/* begin flushBecommedClassesInMethodCache */
			for (i2 = 0; i2 < MethodCacheSize; i2 += MethodCacheEntrySize) {
				c1 = GIV(methodCache)[i2 + MethodCacheClass];
				s1 = GIV(methodCache)[i2 + MethodCacheSelector];
				if ((c1 != 0)
				 && ((s1 != 0)
				 && (isForwarded(classOrNilAtIndex(c1))))) {
					GIV(methodCache)[i2 + MethodCacheClass] = 0;
					GIV(methodCache)[i2 + MethodCacheSelector] = 0;
				}
			}
			/* begin flushAtCache */
			for (i11 = 1; i11 <= AtCacheTotalSize; i11 += 1) {
				GIV(atCache)[i11] = 0;
			}
		}
		if (theBecomeEffectsFlags & BecamePointerObjectFlag) {
			/* begin followForwardingPointersInScheduler */

			/* the GC follows pointers in the special objects array for us. */
			schedAssoc = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())));
			assert(!(isForwarded(schedAssoc)));
			followForwardedObjectFieldstoDepth(schedAssoc, 1);
			sched = longAt((schedAssoc + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
			/* begin followObjField:ofObject: */
			objOop4 = longAt((sched + BaseHeaderSize) + (((long)ProcessListsIndex) << (shiftForWord())));
			assert(isNonImmediate(objOop4));
			if (((longAt(objOop4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				objOop4 = fixFollowedFieldofObjectwithInitialValue(ProcessListsIndex, sched, objOop4);
			}
			procLists = objOop4;
			for (i3 = 0, iLimiT = ((numSlotsOf(procLists)) - 1); i3 <= iLimiT; i3 += 1) {
				/* begin followObjField:ofObject: */
				objOop1 = longAt((procLists + BaseHeaderSize) + (((long)i3) << (shiftForWord())));
				assert(isNonImmediate(objOop1));
				if (((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop1 = fixFollowedFieldofObjectwithInitialValue(i3, procLists, objOop1);
				}
				list = objOop1;
				/* begin followObjField:ofObject: */
				objOop2 = longAt((list + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop2));
				if (((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(FirstLinkIndex, list, objOop2);
				}
				first = objOop2;
				/* begin followObjField:ofObject: */
				objOop3 = longAt((list + BaseHeaderSize) + (((long)LastLinkIndex) << (shiftForWord())));
				assert(isNonImmediate(objOop3));
				if (((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(LastLinkIndex, list, objOop3);
				}
				last = objOop3;
				while (first != last) {
					/* begin followObjField:ofObject: */
					objOop = longAt((first + BaseHeaderSize) + (((long)NextLinkIndex) << (shiftForWord())));
					assert(isNonImmediate(objOop));
					if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						objOop = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, first, objOop);
					}
					next = objOop;
					first = next;
				}
			}
			/* begin followForwardingPointersInSpecialObjectsArray */
			obj1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheLowSpaceSemaphore) << (shiftForWord())));
			if (((longAt(obj1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj1));
				referent11 = longAt((obj1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent11 & (tagMask())) == 0)
				 && (((longAt(referent11)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent11 = longAt((referent11 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				obj1 = referent11;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(specialObjectsOop))));
				if (isOldObject(GIV(specialObjectsOop))) {

					/* most stores into young objects */
					if (((obj1 & (tagMask())) == 0)
					 && (oopisLessThan(obj1, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(GIV(specialObjectsOop));
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheLowSpaceSemaphore) << (shiftForWord())), obj1);
			}
			/* begin followSemaphoreIn:at: */
			obj2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheInterruptSemaphore) << (shiftForWord())));
			if (((longAt(obj2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj2));
				referent21 = longAt((obj2 + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent21 & (tagMask())) == 0)
				 && (((longAt(referent21)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent21 = longAt((referent21 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				obj2 = referent21;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(specialObjectsOop))));
				if (isOldObject(GIV(specialObjectsOop))) {

					/* most stores into young objects */
					if (((obj2 & (tagMask())) == 0)
					 && (oopisLessThan(obj2, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(GIV(specialObjectsOop));
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheInterruptSemaphore) << (shiftForWord())), obj2);
			}
			/* begin followSemaphoreIn:at: */
			obj3 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheTimerSemaphore) << (shiftForWord())));
			if (((longAt(obj3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj3));
				referent31 = longAt((obj3 + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent31 & (tagMask())) == 0)
				 && (((longAt(referent31)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent31 = longAt((referent31 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				obj3 = referent31;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(specialObjectsOop))));
				if (isOldObject(GIV(specialObjectsOop))) {

					/* most stores into young objects */
					if (((obj3 & (tagMask())) == 0)
					 && (oopisLessThan(obj3, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(GIV(specialObjectsOop));
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheTimerSemaphore) << (shiftForWord())), obj3);
			}
			/* begin followSemaphoreIn:at: */
			obj4 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheFinalizationSemaphore) << (shiftForWord())));
			if (((longAt(obj4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj4));
				referent4 = longAt((obj4 + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent4 & (tagMask())) == 0)
				 && (((longAt(referent4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent4 = longAt((referent4 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				obj4 = referent4;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(GIV(specialObjectsOop))));
				if (isOldObject(GIV(specialObjectsOop))) {

					/* most stores into young objects */
					if (((obj4 & (tagMask())) == 0)
					 && (oopisLessThan(obj4, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(GIV(specialObjectsOop));
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheFinalizationSemaphore) << (shiftForWord())), obj4);
			}
			xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ExternalObjectsArray) << (shiftForWord())));
			if (((longAt(xArray)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(xArray));
				referent6 = longAt((xArray + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent6 & (tagMask())) == 0)
				 && (((longAt(referent6)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent6 = longAt((referent6 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				xArray = referent6;
				/* begin splObj:put: */
				assert(!(isForwarded(GIV(specialObjectsOop))));
				if (isOldObject(GIV(specialObjectsOop))) {

					/* most stores into young objects */
					if (((xArray & (tagMask())) == 0)
					 && (oopisLessThan(xArray, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(GIV(specialObjectsOop));
						}
					}
				}
				longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ExternalObjectsArray) << (shiftForWord())), xArray);
			}
			for (i4 = 0, iLimiT1 = ((numSlotsOf(xArray)) - 1); i4 <= iLimiT1; i4 += 1) {
				/* begin followSemaphoreIn:at: */
				obj = longAt((xArray + BaseHeaderSize) + (((long)i4) << (shiftForWord())));
				if (((longAt(obj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(obj));
					referent5 = longAt((obj + BaseHeaderSize) + (0LL << (shiftForWord())));
					while (((referent5 & (tagMask())) == 0)
					 && (((longAt(referent5)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent5 = longAt((referent5 + BaseHeaderSize) + (0LL << (shiftForWord())));
					}
					obj = referent5;
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(xArray)));
					if (isOldObject(xArray)) {

						/* most stores into young objects */
						if (((obj & (tagMask())) == 0)
						 && (oopisLessThan(obj, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(xArray))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(xArray);
							}
						}
					}
					longAtput((xArray + BaseHeaderSize) + (((long)i4) << (shiftForWord())), obj);
				}
			}
		}
		if (theBecomeEffectsFlags & (BecamePointerObjectFlag + BecameCompiledMethodFlag)) {
			/* begin followForwardingPointersInProfileState */
			if (((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileProcess)));
				referent1 = longAt((GIV(profileProcess) + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent1 & (tagMask())) == 0)
				 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				GIV(profileProcess) = referent1;
			}
			if (((longAt(GIV(profileMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileMethod)));
				referent2 = longAt((GIV(profileMethod) + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent2 & (tagMask())) == 0)
				 && (((longAt(referent2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent2 = longAt((referent2 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				GIV(profileMethod) = referent2;
			}
			if (((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileSemaphore)));
				referent3 = longAt((GIV(profileSemaphore) + BaseHeaderSize) + (0LL << (shiftForWord())));
				while (((referent3 & (tagMask())) == 0)
				 && (((longAt(referent3)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					referent3 = longAt((referent3 + BaseHeaderSize) + (0LL << (shiftForWord())));
				}
				GIV(profileSemaphore) = referent3;
			}
		}
	}
	followForwardingPointersInStackZone(theBecomeEffectsFlags);
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackFloatValue: */
double
stackFloatValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return floatValueOf(longAt(GIV(stackPointer) + (offset * BytesPerWord)));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackIntegerValue: */
sqInt
stackIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		return (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Answer the actual stackLimit offset in a page. Since stackPageByteSize may
	have chosen to shrink a page
	this may be less than stackPageFrameBytes, but it should be no more than
	stackPageFrameBytes. 
 */

	/* StackInterpreter>>#stackLimitBytes */
static sqInt
stackLimitBytes(void)
{
	return (((stackPageFrameBytes()) < (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord)))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord))));
}


/*	Answer the amount of slots needed to fit a new frame at the point the
	stack limit is checked. A frame looks like this at the point the stack
	limit is checked:
	stacked receiver/closure
	arg0
	...
	argN
	caller's method ip/base frame's sender context
	fp->	saved fp
	method
	method header fields
	context (uninitialized)
	receiver
	first temp
	...
	sp->	Nth temp
	So the amount of headroom is
	the maximum number of arguments + 1 (for stacked receiver and arguments)
	+ the frame size
	+ the max number of temps.
	Since a method's number of temps includes its arguments the actual offset
	is:  */

	/* StackInterpreter>>#stackLimitOffset */
static sqInt
stackLimitOffset(void)
{
	return (FrameSlots + 64) * BytesPerWord;
}


/*	Ensures that the given object is a real object, not a SmallInteger. */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackObjectValue: */
sqInt
stackObjectValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	Answer a page size that is a power-of-two and contains a useful number of
	frames. Room for 256 slots for frames gives around 40 frames a page which
	is a
	good compromise between overflow rate and latency in divorcing a page. */

	/* StackInterpreter>>#stackPageByteSize */
static sqInt
stackPageByteSize(void)
{
    sqInt largeSize;
    sqInt pageBytes;
    sqInt smallSize;

	pageBytes = ((stackPageFrameBytes()) + ((FrameSlots + 64) * BytesPerWord));
	if ((pageBytes & (pageBytes - 1)) == 0) {

		/* = 0 => a power of two */
		return pageBytes;
	}
	largeSize = 1LL << (highBit(pageBytes));
	smallSize = 1LL << ((highBit(pageBytes)) - 1);
	assert((largeSize > pageBytes)
	 && (pageBytes > smallSize));
	return ((pageBytes - smallSize) <= (smallSize / 8)
		? smallSize
		: largeSize);
}


/*	Return a minimum amount of headroom for each stack page (in bytes).
	In a JIT the stack has to have room for interrupt handlers which will run
	on the
	stack. In the interpreter we don't actually need any headroom. */

	/* StackInterpreter>>#stackPageHeadroom */
static sqInt
stackPageHeadroom(void)
{
	return 0;
}


/*	Return the stackPointer of a Context or BlockContext. */

	/* StackInterpreter>>#stackPointerForMaybeMarriedContext: */
static sqInt NoDbgRegParms
stackPointerForMaybeMarriedContext(sqInt aContext)
{
    sqInt sp;
    sqInt sp1;

	if ((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(aContext)))) {
		sp = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
		assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext)));
		return sp;
	}
	/* begin fetchStackPointerOf: */
	sp1 = longAt((aContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
	if (!((((sp1) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext)));
	return (sp1 >> 3);
}


/*	Return the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPointerIndexForFrame: */
static sqInt NoDbgRegParms
stackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    StackPage *thePage;
    char *theSP;

	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	theSP = findSPOfon(theFP, thePage);
	return (((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPositiveMachineIntegerValue: */
usqInt
stackPositiveMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt integerPointer;
    sqInt ok;
    sqInt value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		value = (integerPointer >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return ((unsigned long) null);
		}
		return ((unsigned long) value);
	}
	if ((integerPointer & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return ((unsigned long) 0);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(integerPointer)));
	ccIndex = (longAt(integerPointer)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return ((unsigned long) 0);
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(integerPointer))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((long)(numSlotsOf(integerPointer))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return ((unsigned long) 0);
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return ((unsigned long) (
#if VMBIGENDIAN
	(((((((byteAt((integerPointer + BaseHeaderSize))) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 3))) << 24)) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 4))) << 32)) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 5))) << 40)) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 6))) << 48)) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 7))) << 56)
#else /* VMBIGENDIAN */
	long64At((integerPointer + BaseHeaderSize) + (0LL << 3))
#endif /* VMBIGENDIAN */
	));
	}
	else {
		return ((unsigned long) (
#if VMBIGENDIAN
	(((byteAt((integerPointer + BaseHeaderSize))) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((integerPointer + BaseHeaderSize) + 3))) << 24)
#else /* VMBIGENDIAN */
	long32At((integerPointer + BaseHeaderSize) + (0LL << 2))
#endif /* VMBIGENDIAN */
	));
	}
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackSignedMachineIntegerValue: */
long
stackSignedMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	return signedMachineIntegerValueOf(integerPointer);
}

	/* StackInterpreter>>#stackTop */
sqInt
stackTop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackValue: */
sqInt
stackValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer) + (offset * BytesPerWord));
}


/*	Zero-relative version of CompiledMethod>>startpc. */

	/* StackInterpreter>>#startPCOfMethod: */
sqInt
startPCOfMethod(sqInt aCompiledMethod)
{
	return ((literalCountOfMethodHeader(methodHeaderOf(aCompiledMethod))) + LiteralStart) * BytesPerOop;
}


/*	Return what ST would return for <obj> at: index. */

	/* StackInterpreter>>#stObject:at: */
sqInt
stObjectat(sqInt array, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt integerValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt reasonCode;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt totalLength;

	hdr = long64At(array);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(array + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(array - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l1;
	}
	totalLength = 0;
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(array);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((array + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array)));
			stSize = sp;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(array)));
		stSize = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((((longAt((array + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(array)))))) {
			return noInlineTemporaryin(index - 1, frameOfMarriedContext(array));
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(array)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			return longAt((array + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << (shiftForWord())));
		}
		if (fmt >= (firstByteFormat())) {
			return (((byteAt((array + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
		}
		if (fmt >= (firstShortFormat())) {
			return (((shortAt((array + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 1))) << 3) | 1);
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((array + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 2));
		return (((integerValue & 0xFFFFFFFFULL) << 3) | 1);

	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	return 0;
}


/*	Do what ST would return for <obj> at: index put: value. */

	/* StackInterpreter>>#stObject:at:put: */
sqInt
stObjectatput(sqInt array, sqInt index, sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt reasonCode;
    sqInt signedValueToStore;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt totalLength;
    usqInt unsignedValueToStore;

	hdr = long64At(array);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(array + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(array - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l1;
	}
	totalLength = 0;
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	class = fetchClassOfNonImm(array);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((array + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array)));
			stSize = sp;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(array)));
		stSize = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((((longAt((array + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(array)))))) {
			return noInlineTemporaryinput(index - 1, frameOfMarriedContext(array), value);
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(array)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(array)));
			if (isOldObject(array)) {

				/* most stores into young objects */
				if (((value & (tagMask())) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(array))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(array);
					}
				}
			}
			longAtput((array + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << (shiftForWord())), value);
			goto l3;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			byteAtput((array + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l3;
		}
		if (fmt >= (firstShortFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			shortAtput((array + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 1), signedValueToStore);
			goto l3;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			long32Atput((array + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 2), unsignedValueToStore);
		}
	l3:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
	}
	return value;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#storeInteger:ofObject:withValue: */
sqInt
storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((((usqInt) integerValue) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(objectPointer)));
		longAtput((objectPointer + BaseHeaderSize) + (((long)fieldIndex) << (shiftForWord())), ((integerValue << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return null;
}


/*	Set the sender of a frame. If the frame is a base frame then this is
	trivial; merely store into the FoxCallerSavedIP/FoxCallerContext field. If
	not, then
	split the stack at the frame, moving the frame and those hotter than it to
	a new stack page. In the new stack page the frame will be the base frame
	and storing trivial. Answer the possibly changed location of theFP. */

	/* StackInterpreter>>#storeSenderOfFrame:withValue: */
static char * NoDbgRegParms
storeSenderOfFramewithValue(char *theFP, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt onCurrentPage;
    char *theMovedFP;
    StackPage *thePage;
    char *theSP;

	if ((longAt(theFP + FoxSavedFP)) == 0) {
		longAtput(theFP + FoxCallerContext, anOop);
		return theFP;
	}
	/* begin ensureCallerContext: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		longAt(theFP + FoxCallerContext);
		goto l1;
	}
	/* begin ensureFrameIsMarried:SP: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
	if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP)));
		longAt(callerFP + FoxThisContext);
		goto l3;
	}
	marryFrameSP(callerFP, theSP);
l3:	/* end ensureFrameIsMarried:SP: */;
l1:	/* end ensureCallerContext: */;
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (!onCurrentPage) {

		/* Make sure the frame's page isn't divorced when a new page is allocated. */
		markStackPageNextMostRecentlyUsed(thePage);
	}
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		newPage = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
l2:	/* end newStackPage */;
	theMovedFP = moveFramesInthroughtoPage(thePage, theFP, newPage);
	if (onCurrentPage) {
		/* begin setStackPageAndLimit: */
		assert(newPage != 0);
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
	}
	else {
		markStackPageMostRecentlyUsed(newPage);
	}
	assert(isBaseFrame(theMovedFP));
	longAtput(theMovedFP + FoxCallerContext, anOop);
	return theMovedFP;
}


/*	Return the number of indexable fields in the given object. (i.e., what
	Smalltalk would return for <obj> size).
 */
/*	Note: Assume oop is not a SmallInteger! */

	/* StackInterpreter>>#stSizeOf: */
sqInt
stSizeOf(sqInt oop)
{
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt totalLength;

	hdr = long64At(oop);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(oop - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l1;
	}
	totalLength = 0;
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = fetchClassOfNonImm(oop);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l2:	/* end fixedFieldsOf:format:length: */;
	if (fmt == (indexablePointersFormat())) {
		assert(!(isContextHeader(hdr)));
	}
	return totalLength - fixedFields;
}


/*	Using a read barrier here simplifies the become implementation and costs
	very little because the class index and superclass almost certainly share
	a cache line. */

	/* StackInterpreter>>#superclassOf: */
sqInt
superclassOf(sqInt classPointer)
{
    sqInt objOop;

	/* begin followField:ofObject: */
	objOop = longAt((classPointer + BaseHeaderSize) + (((long)SuperclassIndex) << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop);
	}
	return objOop;
}


/*	Signal the given semaphore from within the interpreter.
	Answer if the current process was preempted. */

	/* StackInterpreter>>#synchronousSignal: */
static sqInt NoDbgRegParms
synchronousSignal(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt excessSignals;
    sqInt proc;
    sqInt referent;

	if (isEmptyList(aSemaphore)) {

		/* no process is waiting on this semaphore */
		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore);
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqInt) (excessSignals + 1)) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(aSemaphore)));
			longAtput((aSemaphore + BaseHeaderSize) + (((long)ExcessSignalsIndex) << (shiftForWord())), (((excessSignals + 1) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		return 0;
	}
	/* begin ensureSemaphoreUnforwardedThroughContext: */
	proc = longAt((aSemaphore + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())));
	if (((longAt(proc)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		followForwardedObjectFieldstoDepth(aSemaphore, 1);
		proc = longAt((aSemaphore + BaseHeaderSize) + (((long)FirstLinkIndex) << (shiftForWord())));
	}
	assert(!((isForwarded(proc))));
	ctxt = longAt((proc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())));
	if (((longAt(ctxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(ctxt));
		referent = longAt((ctxt + BaseHeaderSize) + (0LL << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0LL << (shiftForWord())));
		}
		ctxt = referent;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(proc)));
		if (isOldObject(proc)) {

			/* most stores into young objects */
			if (((ctxt & (tagMask())) == 0)
			 && (oopisLessThan(ctxt, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(proc))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(proc);
				}
			}
		}
		longAtput((proc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())), ctxt);
	}
	return resumepreemptedYieldingIf(removeFirstLinkOfList(aSemaphore), GIV(preemptionYields));
}

	/* StackInterpreter>>#tempCountOf: */
sqInt
tempCountOf(sqInt methodPointer)
{
    sqInt header;

	/* begin temporaryCountOfMethodHeader: */
	assert(isCompiledMethod(methodPointer));
	header = longAt((methodPointer + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	return (((usqInt) header) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#temporaryCountOfMethodHeader: */
sqInt
temporaryCountOfMethodHeader(sqInt header)
{
	return (((usqInt) header) >> MethodHeaderTempCountShift) & 0x3F;
}


/*	Record a process to be awoken on the next interpreter cycle. */

	/* StackInterpreter>>#transferTo: */
static void NoDbgRegParms
transferTo(sqInt newProc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt index;
    StackPage *lastUsedPage;
    StackPage *lruOrFree;
    sqInt newContext;
    StackPage *newPage;
    sqInt oldProc;
    sqInt sched;
    sqInt senderOop;
    char *sp;
    char *theFrame;
    StackPage *thePage;
    sqInt top;

	GIV(statProcessSwitch) += 1;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer) + 1, GIV(framePointer), GIV(stackPointer), !0, __LINE__);
	/* begin fetchPointer:ofObject: */
	sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	oldProc = longAt((sched + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())));
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
l1:	/* end ensureFrameIsMarried:SP: */;
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(oldProc)));
	if (isOldObject(oldProc)) {

		/* most stores into young objects */
		if (((activeContext & (tagMask())) == 0)
		 && (oopisLessThan(activeContext, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(oldProc))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(oldProc);
			}
		}
	}
	longAtput((oldProc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())), activeContext);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(sched)));
	if (isOldObject(sched)) {

		/* most stores into young objects */
		if (((newProc & (tagMask())) == 0)
		 && (oopisLessThan(newProc, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(sched))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(sched);
			}
		}
	}
	longAtput((sched + BaseHeaderSize) + (((long)ActiveProcessIndex) << (shiftForWord())), newProc);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newProc)));
	longAtput((newProc + BaseHeaderSize) + (((long)MyListIndex) << (shiftForWord())), GIV(nilObj));
	/* begin externalSetStackPageAndPointersForSuspendedContextOfProcess: */
	newContext = longAt((newProc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())));
	assert(isContext(newContext));
	if (((((longAt((newContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
		assert(checkIsStillMarriedContextcurrentFP(newContext, GIV(framePointer)));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newProc)));
	longAtput((newProc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())), GIV(nilObj));
	if ((((((longAt((newContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(newContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((newContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFrame = pointerForOop(senderOop - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (theFrame != ((thePage->headFP))) {

			/* explicit assignment of suspendedContext can cause switch to interior frame. */
			/* begin newStackPage */
			lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
			if (((lruOrFree->baseFP)) == 0) {
				newPage = lruOrFree;
				goto l3;
			}
			divorceFramesIn(lruOrFree);
			newPage = lruOrFree;
		l3:	/* end newStackPage */;
			moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFrame, thePage), newPage);
			/* begin markStackPageLeastMostRecentlyUsed: */
			assert(newPage == ((GIV(mostRecentlyUsedPage)->nextPage)));
			lastUsedPage = (newPage->nextPage);
			while (((lastUsedPage->baseFP)) == 0) {
				lastUsedPage = (lastUsedPage->nextPage);
			}
			if (((lastUsedPage->nextPage)) == newPage) {
				goto l2;
			}
			(((newPage->prevPage))->nextPage = (newPage->nextPage));
			(((newPage->nextPage))->prevPage = (newPage->prevPage));
			(((lastUsedPage->prevPage))->nextPage = newPage);
			(newPage->prevPage = (lastUsedPage->prevPage));
			(newPage->nextPage = lastUsedPage);
			(lastUsedPage->prevPage = newPage);
			assert(pageListIsWellFormed());
		l2:	/* end markStackPageLeastMostRecentlyUsed: */;
		}
		assert(((thePage->headFP)) == theFrame);
	}
	else {
		thePage = makeBaseFrameFor(newContext);
		theFrame = (thePage->baseFP);
	}
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	/* begin setMethod: */
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);


	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !0, __LINE__);
}


/*	Update the frame's spouse context with the frame's current state except
	for the
	sender and instruction pointer, which are used to mark the context as
	married. 
 */

	/* StackInterpreter>>#updateStateOfSpouseContextForFrame:WithSP: */
static void NoDbgRegParms
updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char *pointer;
    sqInt tempIndex;
    sqInt theContext;

	assert(frameHasContext(theFP));
	theContext = longAt(theFP + FoxThisContext);
	assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));

	/* update the arguments. this would appear not to be strictly necessary, but is for two reasons.
	   First, the fact that arguments are read-only is only as convention in the Smalltalk compiler;
	   other languages may choose to modify arguments.
	   Second, the Squeak runUntilErrorOrReturnFrom: nightmare pops the stack top, which may, in
	   certain circumstances, be the last argument, and hence the last argument may not have been
	   stored into the context. */
	tempIndex = byteAt((theFP + FoxFrameFlags) + 1);
	pointer = theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)tempIndex) << (shiftForWord())));
	for (i = 1; i <= tempIndex; i += 1) {
		pointer -= BytesPerWord;
		assert(addressCouldBeOop(longAt(pointer)));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		if (isOldObject(theContext)) {

			/* most stores into young objects */
			if ((((longAt(pointer)) & (tagMask())) == 0)
			 && (oopisLessThan(longAt(pointer), GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theContext))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(theContext);
				}
			}
		}
		longAtput((theContext + BaseHeaderSize) + (((long)(ReceiverIndex + i)) << (shiftForWord())), longAt(pointer));
	}
	pointer = (theFP + FoxReceiver) - BytesPerWord;
	while (pointer >= theSP) {
		assert(addressCouldBeOop(longAt(pointer)));
		tempIndex += 1;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		if (isOldObject(theContext)) {

			/* most stores into young objects */
			if ((((longAt(pointer)) & (tagMask())) == 0)
			 && (oopisLessThan(longAt(pointer), GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theContext))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(theContext);
				}
			}
		}
		longAtput((theContext + BaseHeaderSize) + (((long)(ReceiverIndex + tempIndex)) << (shiftForWord())), longAt(pointer));
		pointer -= BytesPerWord;
	}
	assert((ReceiverIndex + tempIndex) < (lengthOf(theContext)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())), ((tempIndex << 3) | 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */

	/* StackInterpreter>>#validInstructionPointer:inFrame: */
static sqInt NoDbgRegParms
validInstructionPointerinFrame(usqInt anInstrPointer, char *fp)
{
	return (anInstrPointer >= ((((longAt(fp + FoxMethod)) + (lastPointerOf(longAt(fp + FoxMethod)))) + BytesPerOop) - 1))
	 && (anInstrPointer < ((((longAt(fp + FoxMethod)) + (numBytesOfBytes(longAt(fp + FoxMethod)))) + BaseHeaderSize) - 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */
/*	-1 for pre-increment in fetchNextBytecode */

	/* StackInterpreter>>#validInstructionPointer:inMethod:framePointer: */
sqInt
validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp)
{
	return (theInstrPointer >= (((aMethod + (lastPointerOf(aMethod))) + BytesPerOop) - 1))
	 && (theInstrPointer < (((aMethod + (numBytesOfBytes(aMethod))) + BaseHeaderSize) - 1));
}


/*	Check that the base frames in all in-use stack pages have a sender and a
	saved context.
 */

	/* StackInterpreter>>#validStackPageBaseFrames */
static sqInt
validStackPageBaseFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt i;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			if (!(validStackPageBaseFrame(aPage))) {
				return 0;
			}
		}
	}
	return 1;
}


/*	Check that the base frame in the stack page has a valid sender context. */

	/* StackInterpreter>>#validStackPageBaseFrame: */
static sqInt NoDbgRegParms
validStackPageBaseFrame(StackPage *aPage)
{
    sqInt senderContextOrNil;
    char *theFP;

	if (!(asserta(isBaseFrame((aPage->baseFP))))) {
		return 0;
	}
	/* begin frameCallerContext: */
	theFP = (aPage->baseFP);
	senderContextOrNil = longAt(theFP + FoxCallerContext);
	if (!(asserta(addressCouldBeObj(senderContextOrNil)))) {
		return 0;
	}
	if (!(asserta((senderContextOrNil == (nilObject()))
		 || (isContext(senderContextOrNil))))) {
		return 0;
	}
	return 1;
}


/*	Void the state associated with the long-running primitive check.
	This is done when a new semaphore is installed or when it appears
	that is longRunningPrimitiveCheckMethod is invalid, e.g. because it
	has eben sampled in the middle of a GC. */

	/* StackInterpreter>>#voidLongRunningPrimitive: */
static void NoDbgRegParms
voidLongRunningPrimitive(char *reason)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(longRunningPrimitiveCheckMethod) = null;
	GIV(longRunningPrimitiveCheckSequenceNumber) == 0;
	GIV(longRunningPrimitiveStartUsecs) = (GIV(longRunningPrimitiveStopUsecs) = 0);
	GIV(longRunningPrimitiveSignalUndelivered) = 1;
	sqLowLevelMFence();
}


/*	Make sure that all VM state that affects the heap contents is voided so
	that the heap is
	ready to be snapshotted. If flushExtPrims is true, flush references to
	external primitives in methods. Answer the activeContext that should be
	stored in the snapshot. */

	/* StackInterpreter>>#voidVMStateForSnapshotFlushingExternalPrimitivesIf: */
static sqInt NoDbgRegParms
voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt address;
    sqInt address1;
    sqInt fmt;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    sqInt i;
    sqInt iLimiT;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	activeContext = divorceAllFrames();
	/* begin bereaveAllMarriedContextsForSnapshotFlushingExternalPrimitivesIf: */
	
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		fmt = (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask());
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(objOop1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			if (((((longAt((objOop1 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {

				/* The stack pages have already been discarded.  Any remaining married contexts are actually widows. */
				/* begin markContextAsDead: */
				assert(isContext(objOop1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
			}
			else {
			}
			for (i = ((fetchStackPointerOf(objOop1)) + CtxtTempFrameStart), iLimiT = ((numSlotsOf(objOop1)) - 1); i <= iLimiT; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
			}
		}
		if (flushExtPrims
		 && (fmt >= (firstCompiledMethodFormat()))) {

			/* Its primitiveExternalCall */
			if ((primitiveIndexOfMethodheader(objOop1, methodHeaderOf(objOop1))) == PrimitiveExternalCallIndex) {
				flushExternalPrimitiveOf(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop1 + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop1 + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop1 = limit;
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		fmt = (((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask());
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(objOop1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			if (((((longAt((objOop1 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {

				/* The stack pages have already been discarded.  Any remaining married contexts are actually widows. */
				/* begin markContextAsDead: */
				assert(isContext(objOop1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
			}
			else {
			}
			for (i = ((fetchStackPointerOf(objOop1)) + CtxtTempFrameStart), iLimiT = ((numSlotsOf(objOop1)) - 1); i <= iLimiT; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
			}
		}
		if (flushExtPrims
		 && (fmt >= (firstCompiledMethodFormat()))) {

			/* Its primitiveExternalCall */
			if ((primitiveIndexOfMethodheader(objOop1, methodHeaderOf(objOop1))) == PrimitiveExternalCallIndex) {
				flushExternalPrimitiveOf(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	/* begin allOldSpaceObjectsDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			fmt = (((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask());
			if ((fmt == (indexablePointersFormat()))
			 && (((longAt(objOop11)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
				if (((((longAt((objOop11 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {

					/* The stack pages have already been discarded.  Any remaining married contexts are actually widows. */
					/* begin markContextAsDead: */
					assert(isContext(objOop11));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop11)));
					longAtput((objOop11 + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop11)));
					longAtput((objOop11 + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
				}
				else {
				}
				for (i = ((fetchStackPointerOf(objOop11)) + CtxtTempFrameStart), iLimiT = ((numSlotsOf(objOop11)) - 1); i <= iLimiT; i += 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop11)));
					longAtput((objOop11 + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
				}
			}
			if (flushExtPrims
			 && (fmt >= (firstCompiledMethodFormat()))) {

				/* Its primitiveExternalCall */
				if ((primitiveIndexOfMethodheader(objOop11, methodHeaderOf(objOop11))) == PrimitiveExternalCallIndex) {
					flushExternalPrimitiveOf(objOop11);
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop11 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop11 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress2 = (objOop11 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop11 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	return activeContext;
}


/*	Return the highest priority process that is ready to run.
	To save time looking at many empty lists before finding a
	runnable process the VM maintains a variable holding the
	highest priority runnable process. If this variable is 0 then the
	VM does not know the highest priority and must search all lists.
	Note: It is a fatal VM error if there is no runnable process. */

	/* StackInterpreter>>#wakeHighestPriority */
static sqInt
wakeHighestPriority(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    usqInt numSlots;
    sqInt objOop;
    sqInt p;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin fetchPointer:ofObject: */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SchedulerAssociation) << (shiftForWord())))) + BaseHeaderSize) + (((long)ValueIndex) << (shiftForWord())));
	schedLists = longAt((objOop + BaseHeaderSize) + (((long)ProcessListsIndex) << (shiftForWord())));
	if (GIV(highestRunnableProcessPriority) == 0) {
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(schedLists)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(schedLists + 7);
		p = (numSlots == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(schedLists - BaseHeaderSize))) << 8)))) >> 8
			: numSlots);
	}
	else {
		p = GIV(highestRunnableProcessPriority);
	}
	while (((p -= 1)) >= 0) {
		processList = longAt((schedLists + BaseHeaderSize) + (((long)p) << (shiftForWord())));
		while (!(isEmptyList(processList))) {

			/* Only answer processes with a runnable suspendedContext.
			   Discard those that aren't; the VM would crash otherwise. */
			proc = removeFirstLinkOfList(processList);
			ctxt = longAt((proc + BaseHeaderSize) + (((long)SuspendedContextIndex) << (shiftForWord())));
			if (isLiveContext(ctxt)) {
				GIV(highestRunnableProcessPriority) = p + 1;
				return proc;
			}
			warning("evicted zombie process from run queue");
		}
	}
	error("scheduler could not find a runnable process");
	return null;
}

	/* StackInterpreter>>#whereIs: */
char *
whereIs(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *where;

	/* begin whereIsMaybeHeapThing: */
	if ((oopisLessThan(anOop, GIV(newSpaceLimit)))
	 && (oopisGreaterThanOrEqualTo(anOop, GIV(newSpaceStart)))) {
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((eden()).start), GIV(freeStart))) {
			where = " is in eden";
			goto l2;
		}
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((futureSpace()).start), futureSurvivorStart())) {
			where = " is in future space";
			goto l2;
		}
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((pastSpace()).start), GIV(pastSpaceStart))) {
			where = " is in past space";
			goto l2;
		}
		where = " is in new space";
		goto l2;
	}
	if (oopisGreaterThanOrEqualToandLessThan(anOop, GIV(oldSpaceStart), GIV(endOfMemory))) {
		if (!((segmentContainingObj(anOop)) == null)) {
			where = " is in old space";
			goto l2;
		}
		where = " is between old space segments";
		goto l2;
	}
	where = null;
l2:	/* end whereIsMaybeHeapThing: */;
	if (!(where == null)) {
		return where;
	}
	/* begin whereIsMaybeStackThing: */
	if (oopisGreaterThanOrEqualToandLessThan(anOop, GIV(stackMemory), GIV(pages))) {
		where = " is in the stack zone";
		goto l1;
	}
	where = null;
l1:	/* end whereIsMaybeStackThing: */;
	if (!(where == null)) {
		return where;
	}
	return " is no where obvious";
}

	/* StackInterpreter>>#withSmallIntegerTags: */
static sqInt NoDbgRegParms
withSmallIntegerTags(char *value)
{
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	return (oopForPointer(value)) + 1;
}


/*	Write the image header and heap contents to imageFile for snapshot. c.f.
	writeImageFileIOSimulation. The game below is to maintain 64-bit alignment
	for all putLong:toFile: occurrences. */

	/* StackInterpreter>>#writeImageFileIO */
static sqInt NeverInline
writeImageFileIO(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesWritten;
    sqImageFile f;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt i;
    usqInt imageBytes;
    extern char imageName[];
    sqInt okToWrite;
    void *sCWIfn;
    usqInt total;

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn != 0) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!okToWrite) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	headerStart = 0;

	/* header size in bytes; do not change! */
	headerSize = 128;
	f = sqImageFileOpen(imageName, "wb");
	if (f == null) {

		/* could not open the image file for writing */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin imageSizeToWrite */
	assert(newSpaceIsEmpty());
	/* begin totalBytesInNonEmptySegments */
	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		if ((((GIV(segments)[i]).segSize)) > (2 * BaseHeaderSize)) {
			total += ((GIV(segments)[i]).segSize);
		}
	}
	imageBytes = total;
	headerStart = sqImageFileStartLocation(f, imageName, headerSize + imageBytes);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart);
	putWord32toFile(imageFormatVersion(), f);
	putWord32toFile(headerSize, f);
	putLongtoFile(imageBytes, f);
	putLongtoFile(GIV(oldSpaceStart), f);
	putLongtoFile(GIV(specialObjectsOop), f);
	putLongtoFile(newObjectHash(), f);
	putLongtoFile(ioScreenSize(), f);
	putLongtoFile((((GIV(fullScreenFlag) + ((VMBIGENDIAN
	? 0
	: 2))) + ((GIV(preemptionYields)
	? 0
	: 16))) + ((GIV(newFinalization)
	? 64
	: 0))) + (((GIV(imageHeaderFlags) | 83) - 83)), f);
	putWord32toFile(extraVMMemory, f);
	putShorttoFile(desiredNumStackPages, f);
	putShorttoFile(GIV(theUnknownShort), f);
	putWord32toFile(desiredEdenBytes, f);
	putShorttoFile((GIV(maxExtSemTabSizeSet)
		? ioGetMaxExtSemTableSize()
		: 0), f);
	putShorttoFile(GIV(the2ndUnknownShort), f);
	putLongtoFile(((GIV(segments)[0]).segSize), f);
	putLongtoFile(GIV(totalFreeOldSpace), f);
	putLongtoFile(0, f);
	putLongtoFile(0, f);


	putLongtoFile(0, f);
	putLongtoFile(0, f);
	putLongtoFile(0, f);


	assert((headerStart + headerSize) == (sqImageFilePosition(f)));
	sqImageFileSeek(f, headerStart + headerSize);
	if (GIV(primFailCode)) {

		/* file write or seek failure */
		sqImageFileClose(f);
		return null;
	}
	bytesWritten = writeImageSegmentsToFile(f);

	/* begin success: */
	if (!(bytesWritten == imageBytes)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	sqImageFileClose(f);
}

	/* StackInterpreterPrimitives>>#cloneContext: */
static sqInt NoDbgRegParms
cloneContext(sqInt aContext)
{
    sqInt cloned;
    sqInt frameNumArgs;
    sqInt i;
    usqInt numSlots;
    sqInt senderOop;
    sqInt sp;
    char *spouseFP;
    usqInt sz;
    sqInt valuePointer;
    sqInt valuePointer1;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(aContext)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(aContext + 7);
	sz = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(aContext - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	cloned = allocateNewSpaceSlotsformatclassIndex(sz, indexablePointersFormat(), ClassMethodContextCompactIndex);
	if (cloned != 0) {
		for (i = 0; i <= StackPointerIndex; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer = externalInstVarofContext(i, aContext);
			assert(!(isForwarded(cloned)));
			longAtput((cloned + BaseHeaderSize) + (((long)i) << (shiftForWord())), valuePointer);
		}
		for (i = MethodIndex; i <= ReceiverIndex; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(cloned)));
			longAtput((cloned + BaseHeaderSize) + (((long)i) << (shiftForWord())), longAt((aContext + BaseHeaderSize) + (((long)i) << (shiftForWord()))));
		}
		if ((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(aContext)))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1));
			spouseFP = pointerForOop(senderOop - 1);
			sp = (stackPointerIndexForFrame(spouseFP)) - 1;
			for (i = 0; i <= sp; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer1 = (i < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
					? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - i) * BytesPerWord))
					: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - i) * BytesPerWord)));
				assert(!(isForwarded(cloned)));
				longAtput((cloned + BaseHeaderSize) + (((long)(i + CtxtTempFrameStart)) << (shiftForWord())), valuePointer1);
			}
		}
		else {
			sp = (fetchStackPointerOf(aContext)) - 1;
			for (i = 0; i <= sp; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(cloned)));
				longAtput((cloned + BaseHeaderSize) + (((long)(i + CtxtTempFrameStart)) << (shiftForWord())), longAt((aContext + BaseHeaderSize) + (((long)(i + CtxtTempFrameStart)) << (shiftForWord()))));
			}
		}
	}
	return cloned;
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#fieldOrSenderFP:ofContext: */
static sqInt NoDbgRegParms
fieldOrSenderFPofContext(sqInt index, sqInt contextObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt senderOop;
    char *spouseFP;
    sqInt tempIndex;

	tempIndex = index - CtxtTempFrameStart;
	if (!((((((longAt((contextObj + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(contextObj))))) {
		return (tempIndex >= (fetchStackPointerOf(contextObj))
			? GIV(nilObj)
			: longAt((contextObj + BaseHeaderSize) + (((long)index) << (shiftForWord()))));
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((contextObj + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - 1);
	if (tempIndex >= (stackPointerIndexForFrame(spouseFP))) {
		return GIV(nilObj);
	}
	return fieldofFrame(index, spouseFP);
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#field:ofFrame: */
static sqInt NoDbgRegParms
fieldofFrame(sqInt index, char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt frameNumArgs;

	
	switch (index) {
	case SenderIndex:
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		return (callerFP == 0
			? longAt(theFP + FoxCallerContext)
			: ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0
					? (assert(checkIsStillMarriedContextcurrentFP(frameContext(callerFP), null)),
						longAt(callerFP + FoxThisContext))
					: ((sqInt)callerFP)));

	case StackPointerIndex:
	case InstructionPointerIndex:
		return ConstZero;

	case MethodIndex:
		return longAt(theFP + FoxMethod);

	case ClosureIndex:
		return ((byteAt((theFP + FoxFrameFlags) + 3)) != 0
			? longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()))))
			: GIV(nilObj));

	case ReceiverIndex:
		return longAt(theFP + FoxReceiver);

	default:
		assert((((index - CtxtTempFrameStart) >= 0) && ((index - CtxtTempFrameStart) <= (stackPointerIndexForFrame(theFP)))));
		return ((index - CtxtTempFrameStart) < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
			? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord))
			: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord)));

	}
}

	/* StackInterpreterPrimitives>>#isAppropriateForCopyObject: */
static sqInt NoDbgRegParms
isAppropriateForCopyObject(sqInt oop)
{
	if (!(((((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask())) <= 5)) {
		return 0;
	}
	if (((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		return !((((((longAt((oop + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
 && (!(isWidowedContext(oop))));
	}
	return 1;
}


/*	Return a shallow copy of the receiver.
	Special-case non-single contexts (because of context-to-stack mapping).
	Can't fail for contexts cuz of image context instantiation code (sigh). */

	/* StackInterpreterPrimitives>>#primitiveClone */
static void
primitiveClone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newCopy;
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	if ((rcvr & (tagMask())) != 0) {
		newCopy = rcvr;
	}
	else {
		if (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
			newCopy = cloneContext(rcvr);
		}
		else {
			if ((GIV(argumentCount) == 0)
			 || (!(((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
				newCopy = clone(rcvr);
			}
			else {
				newCopy = 0;
			}
		}
		if (newCopy == 0) {
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newCopy);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveClosureCopyWithCopiedValues */
static void
primitiveClosureCopyWithCopiedValues(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt context;
    sqInt copiedValues;
    sqInt i;
    sqInt initialIP;
    sqInt integerPointer;
    sqInt knownClassIndex;
    sqInt newClosure;
    sqInt newClosure1;
    usqInt newObj;
    usqInt newObj1;
    sqInt numArgs;
    usqInt numBytes;
    usqInt numBytes1;
    usqInt numCopied;
    sqInt numSlots;
    usqInt numSlots1;
    sqInt numSlots2;
    sqInt objFormat;
    sqInt objFormat1;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		numArgs = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		numArgs = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin closureIn:numArgs:instructionPointer:copiedValues: */
	context = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	initialIP = (GIV(instructionPointer) + 2) - (GIV(method) + BaseHeaderSize);
	copiedValues = longAt(GIV(stackPointer));
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(copiedValues)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(copiedValues + 7);
	numCopied = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(copiedValues - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = indexablePointersFormat();
	numSlots = ClosureFirstCopiedValueIndex + numCopied;
	assert((numSlots >= 0)
	 && (ClassBlockClosureCompactIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newClosure1 = 0;
			goto l2;
		}
	}
	long64Atput(newObj, ((((long)(((usqLong) numSlots))) << (numSlotsFullShift())) + (((long)objFormat) << (formatShift()))) + ClassBlockClosureCompactIndex);
	GIV(freeStart) += numBytes;
	newClosure1 = newObj;
l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newClosure1)));
	longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureOuterContextIndex) << (shiftForWord())), context);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newClosure1)));
	longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureStartPCIndex) << (shiftForWord())), ((initialIP << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newClosure1)));
	longAtput((newClosure1 + BaseHeaderSize) + (((long)ClosureNumArgsIndex) << (shiftForWord())), ((numArgs << 3) | 1));
	for (i = 0; i < numCopied; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(newClosure1)));
		longAtput((newClosure1 + BaseHeaderSize) + (((long)(i + ClosureFirstCopiedValueIndex)) << (shiftForWord())), longAt((copiedValues + BaseHeaderSize) + (((long)i) << (shiftForWord()))));
	}
	newClosure = newClosure1;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newClosure);
	GIV(stackPointer) = sp;
}


/*	Special version of primitiveAt for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAt */
static void
primitiveContextAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt class;
    sqInt class1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqInt frameNumArgs;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    sqInt integerValue;
    sqInt integerValue1;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt reasonCode;
    sqInt senderOop;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    char *sp2;
    char *sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((((index) & 7) == 1))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 3);

	/* Duplicating much of stObject:at:put: here allows stObject:at:put: to omit tests for contexts. */
	aContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	hdr = long64At(aContext);
	if (!((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */
		/* begin stObject:at: */
		hdr1 = long64At(aContext);
		fmt1 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
		/* begin lengthOf:format: */
		numSlots11 = byteAt(aContext + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(aContext - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (fmt1 <= 5) {
			totalLength1 = numSlots2;
			goto l6;
		}
		if (fmt1 >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			totalLength1 = (((long)numSlots2) << (shiftForWord())) - (fmt1 & 7);
			goto l6;
		}
		if (fmt1 >= (firstShortFormat())) {
			totalLength1 = (((long)numSlots2) << ((shiftForWord()) - 1)) - (fmt1 & 3);
			goto l6;
		}
		if (fmt1 >= (firstLongFormat())) {
			totalLength1 = (((long)numSlots2) << ((shiftForWord()) - 2)) - (fmt1 & 1);
			goto l6;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat())) {
			totalLength1 = numSlots2;
			goto l6;
		}
		totalLength1 = 0;
	l6:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 >= (sixtyFourBitIndexableFormat()))
		 || (fmt1 == 2)) {
			fixedFields1 = 0;
			goto l5;
		}
		if (fmt1 < 2) {
			fixedFields1 = totalLength1;
			goto l5;
		}
		class1 = fetchClassOfNonImm(aContext);
		/* begin fixedFieldsOfClassFormat: */
		fixedFields1 = (((longAt((class1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
	l5:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == (indexablePointersFormat()))
		 && ((hdr1 & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if ((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
			 && (!(isWidowedContext(aContext)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((sp4 >> 3))) < (lengthOf(aContext)));
				stSize1 = sp4;
				goto l7;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
			if (!((((sp11) & 7) == 1))) {
				stSize1 = 0;
				goto l7;
			}
			assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(aContext)));
			stSize1 = (sp11 >> 3);
		l7:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1))
			 && ((oopisLessThanOrEqualTo(index, stSize1))
			 && ((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
			 && (!(isWidowedContext(aContext)))))) {
				value = noInlineTemporaryin(index - 1, frameOfMarriedContext(aContext));
				goto l8;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat())
			? (((literalCountOf(aContext)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
		 && (oopisLessThanOrEqualTo(index, stSize1))) {
			/* begin subscript:with:format: */
			if (fmt1 <= 5) {
				value = longAt((aContext + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << (shiftForWord())));
				goto l8;
			}
			if (fmt1 >= (firstByteFormat())) {
				value = (((byteAt((aContext + BaseHeaderSize) + ((index + fixedFields1) - 1))) << 3) | 1);
				goto l8;
			}
			if (fmt1 >= (firstShortFormat())) {
				value = (((shortAt((aContext + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << 1))) << 3) | 1);
				goto l8;
			}
			/* begin positive32BitIntegerFor: */
			integerValue1 = long32At((aContext + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << 2));
			value = (((integerValue1 & 0xFFFFFFFFULL) << 3) | 1);
			goto l8;

		}
		/* begin primitiveFailFor: */
		reasonCode = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
		value = 0;
	l8:	/* end stObject:at: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
		/* begin lengthOf:format: */
		numSlots1 = byteAt(aContext + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(aContext - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (fmt <= 5) {
			totalLength = numSlots;
			goto l1;
		}
		if (fmt >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
			goto l1;
		}
		if (fmt >= (firstLongFormat())) {
			totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
			goto l1;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			totalLength = numSlots;
			goto l1;
		}
		totalLength = 0;
	l1:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt >= (sixtyFourBitIndexableFormat()))
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l4;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l4;
		}
		class = fetchClassOfNonImm(aContext);
		/* begin fixedFieldsOfClassFormat: */
		fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
	l4:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp1 = longAt((aContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext)));
		stSize = (sp1 >> 3);
	l2:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			value = longAt((aContext + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << (shiftForWord())));
			goto l3;
		}
		if (fmt >= (firstByteFormat())) {
			value = (((byteAt((aContext + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l3;
		}
		if (fmt >= (firstShortFormat())) {
			value = (((shortAt((aContext + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 1))) << 3) | 1);
			goto l3;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((aContext + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 2));
		value = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
		goto l3;

	l3:	/* end subscript:with:format: */;
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - 1);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	value = ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
		? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord))
		: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord)));
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp3;
}


/*	Special version of primitiveAtPut for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAtPut */
static void
primitiveContextAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt class;
    sqInt class1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqInt frameNumArgs;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt reasonCode;
    sqInt senderOop;
    sqInt signedValueToStore;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    char *sp2;
    char *sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    usqInt unsignedValueToStore;
    usqInt unsignedValueToStore1;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aContext = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	hdr = long64At(aContext);
	index = (index >> 3);
	if (!((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */
		/* begin stObject:at:put: */
		hdr1 = long64At(aContext);
		fmt1 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
		/* begin lengthOf:format: */
		numSlots11 = byteAt(aContext + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(aContext - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (fmt1 <= 5) {
			totalLength1 = numSlots2;
			goto l6;
		}
		if (fmt1 >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			totalLength1 = (((long)numSlots2) << (shiftForWord())) - (fmt1 & 7);
			goto l6;
		}
		if (fmt1 >= (firstShortFormat())) {
			totalLength1 = (((long)numSlots2) << ((shiftForWord()) - 1)) - (fmt1 & 3);
			goto l6;
		}
		if (fmt1 >= (firstLongFormat())) {
			totalLength1 = (((long)numSlots2) << ((shiftForWord()) - 2)) - (fmt1 & 1);
			goto l6;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat())) {
			totalLength1 = numSlots2;
			goto l6;
		}
		totalLength1 = 0;
	l6:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 >= (sixtyFourBitIndexableFormat()))
		 || (fmt1 == 2)) {
			fixedFields1 = 0;
			goto l7;
		}
		if (fmt1 < 2) {
			fixedFields1 = totalLength1;
			goto l7;
		}
		class1 = fetchClassOfNonImm(aContext);
		/* begin fixedFieldsOfClassFormat: */
		fixedFields1 = (((longAt((class1 + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
	l7:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == (indexablePointersFormat()))
		 && ((hdr1 & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if ((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
			 && (!(isWidowedContext(aContext)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((sp4 >> 3))) < (lengthOf(aContext)));
				stSize1 = sp4;
				goto l8;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
			if (!((((sp11) & 7) == 1))) {
				stSize1 = 0;
				goto l8;
			}
			assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(aContext)));
			stSize1 = (sp11 >> 3);
		l8:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1))
			 && ((oopisLessThanOrEqualTo(index, stSize1))
			 && ((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
			 && (!(isWidowedContext(aContext)))))) {
				noInlineTemporaryinput(index - 1, frameOfMarriedContext(aContext), value);
				goto l9;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat())
			? (((literalCountOf(aContext)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
		 && (oopisLessThanOrEqualTo(index, stSize1))) {
			/* begin subscript:with:storing:format: */
			if (fmt1 <= 5) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(aContext)));
				if (isOldObject(aContext)) {

					/* most stores into young objects */
					if (((value & (tagMask())) == 0)
					 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(aContext))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(aContext);
						}
					}
				}
				longAtput((aContext + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << (shiftForWord())), value);
				goto l5;
			}
			if (fmt1 >= (firstByteFormat())) {
				if (!((((value) & 7) == 1))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l5;
				}
				signedValueToStore1 = (value >> 3);
				if (!((signedValueToStore1 >= 0)
					 && (signedValueToStore1 <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l5;
				}
				byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
				goto l5;
			}
			if (fmt1 >= (firstShortFormat())) {
				if (!((((value) & 7) == 1))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l5;
				}
				signedValueToStore1 = (value >> 3);
				if (!((signedValueToStore1 >= 0)
					 && (signedValueToStore1 <= 0xFFFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l5;
				}
				shortAtput((aContext + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << 1), signedValueToStore1);
				goto l5;
			}
			unsignedValueToStore1 = positive32BitValueOf(value);
			if (!GIV(primFailCode)) {
				long32Atput((aContext + BaseHeaderSize) + (((long)((index + fixedFields1) - 1)) << 2), unsignedValueToStore1);
			}
		l5:	/* end subscript:with:storing:format: */;
		}
		else {
			/* begin primitiveFailFor: */
			reasonCode = (fmt1 <= 1
				? PrimErrBadReceiver
				: PrimErrBadIndex);
			GIV(primFailCode) = reasonCode;
		}
	l9:	/* end stObject:at:put: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((((longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
		/* begin lengthOf:format: */
		numSlots1 = byteAt(aContext + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(aContext - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (fmt <= 5) {
			totalLength = numSlots;
			goto l1;
		}
		if (fmt >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
			goto l1;
		}
		if (fmt >= (firstLongFormat())) {
			totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
			goto l1;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			totalLength = numSlots;
			goto l1;
		}
		totalLength = 0;
	l1:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt >= (sixtyFourBitIndexableFormat()))
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l4;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l4;
		}
		class = fetchClassOfNonImm(aContext);
		/* begin fixedFieldsOfClassFormat: */
		fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
	l4:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp1 = longAt((aContext + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext)));
		stSize = (sp1 >> 3);
	l2:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}
		/* begin subscript:with:storing:format: */
		if (fmt <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aContext)));
			if (isOldObject(aContext)) {

				/* most stores into young objects */
				if (((value & (tagMask())) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(aContext))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(aContext);
					}
				}
			}
			longAtput((aContext + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << (shiftForWord())), value);
			goto l3;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l3;
		}
		if (fmt >= (firstShortFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			shortAtput((aContext + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 1), signedValueToStore);
			goto l3;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			long32Atput((aContext + BaseHeaderSize) + (((long)((index + fixedFields) - 1)) << 2), unsignedValueToStore);
		}
	l3:	/* end subscript:with:storing:format: */;
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - 1);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))) {
		longAtput((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	else {
		longAtput(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp3;
}


/*	Special version of primitiveSize for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextSize */
static void
primitiveContextSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l1;
	}
	totalLength = 0;
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	if ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr)));
			sz = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
		if (!((((sp1) & 7) == 1))) {
			sz = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr)));
		sz = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
	}
	else {
		sz = totalLength - fixedFields;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((sz << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Lift the veil from a context and answer an integer describing its interior
	state. Used for e.g. VM tests so they can verify they're testing what they
	think they're testing.
	0 implies a vanilla heap context.
	Bit 0 = is or was married to a frame
	Bit 1 = is still married to a frame
	Bit 2 = frame is executing machine code
	Bit 3 = has machine code pc (as opposed to nil or a bytecode pc)
	Bit 4 = method is currently compiled to machine code */

	/* StackInterpreterPrimitives>>#primitiveContextXray */
static void
primitiveContextXray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt flags;
    char *sp;

	context = longAt(GIV(stackPointer));
	if (((((longAt((context + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(context, GIV(framePointer))) {
			flags = 3;
		}
		else {
			flags = 1;
		}
	}
	else {
		flags = 0;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((flags << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

	/* StackInterpreterPrimitives>>#primitiveDeferDisplayUpdates */
static void
primitiveDeferDisplayUpdates(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;

	flag = longAt(GIV(stackPointer));
	if (flag == GIV(trueObj)) {
		deferDisplayUpdates = 1;
	}
	else {
		if (flag == GIV(falseObj)) {
			deferDisplayUpdates = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Simulate an primitiveExternalCall invocation (e.g. for the Debugger). Do
	not cache anything.
	e.g. ContextPart>>tryNamedPrimitiveIn: aCompiledMethod for: aReceiver
	withArgs: arguments */

	/* StackInterpreterPrimitives>>#primitiveDoNamedPrimitiveWithArgs */
static void
primitiveDoNamedPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt argumentArray;
    usqInt arraySize;
    sqInt ccIndex;
    sqInt firstBytecode;
    sqInt fmt;
    sqInt fmt1;
    sqInt functionLength;
    sqInt functionName;
    sqInt index;
    sqInt isArray;
    sqInt methodArg;
    sqInt methodHeader;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt nItems;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt numSlots4;
    sqInt primBits;
    sqInt primRcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt spec;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;

	argumentArray = longAt(GIV(stackPointer));
	methodArg = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2))
		 && (((methodArg & (tagMask())) == 0)
		 && (((((usqInt) (longAt(methodArg))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))))) {
		(GIV(primFailCode) = -2);
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	numSlots2 = byteAt(argumentArray + 7);
	arraySize = (numSlots2 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(argumentArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots2);
	if (!(roomToPushNArgs(arraySize))) {
		(GIV(primFailCode) = -2);
		return;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodArg));
	methodHeader = longAt((methodArg + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	if (!((literalCountOfMethodHeader(methodHeader)) > 2)) {
		(GIV(primFailCode) = -3);
		return;
	}

	/* first literal */
	spec = longAt((methodArg + BaseHeaderSize) + (1LL << (shiftForWord())));
	/* begin is:instanceOf:compactClassIndex: */
	if ((spec & (tagMask())) != 0) {
		isArray = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(spec)));
	ccIndex = (longAt(spec)) & (classIndexMask());
	isArray = ClassArrayCompactIndex == ccIndex;
	goto l2;

l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!(isArray
		 && (((lengthOfformat(spec, (((usqInt) (longAt(spec))) >> (formatShift())) & (formatMask()))) == 4)
		 && (((methodHeader & AlternateHeaderHasPrimFlag
			? ((firstBytecode = (methodArg + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8))
			: 0)) == 117)))) {
		(GIV(primFailCode) = -3);
		return;
	}
	if (!(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) == arraySize)) {
		(GIV(primFailCode) = -2);
		return;
	}
	moduleName = longAt((spec + BaseHeaderSize) + (0LL << (shiftForWord())));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		/* begin success: */
		successBoolean = ((moduleName & (tagMask())) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()));
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		/* begin lengthOf:format: */
		fmt = (((usqInt) (longAt(moduleName))) >> (formatShift())) & (formatMask());
		/* begin numSlotsOfAny: */
		numSlots1 = byteAt(moduleName + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(moduleName - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if (fmt <= 5) {
			moduleLength = numSlots;
			goto l1;
		}
		if (fmt >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			moduleLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			moduleLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
			goto l1;
		}
		if (fmt >= (firstLongFormat())) {
			moduleLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
			goto l1;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			moduleLength = numSlots;
			goto l1;
		}
		moduleLength = 0;
	l1:	/* end lengthOf:format: */;
			}
	functionName = longAt((spec + BaseHeaderSize) + (1LL << (shiftForWord())));
	/* begin success: */
	successBoolean1 = ((functionName & (tagMask())) == 0)
	 && (((((usqInt) (longAt(functionName))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()));
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin lengthOf:format: */
	fmt1 = (((usqInt) (longAt(functionName))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(functionName + 7);
	numSlots3 = (numSlots11 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(functionName - BaseHeaderSize))) << 8)))) >> 8
		: numSlots11);
	if (fmt1 <= 5) {
		functionLength = numSlots3;
		goto l3;
	}
	if (fmt1 >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		functionLength = (((long)numSlots3) << (shiftForWord())) - (fmt1 & 7);
		goto l3;
	}
	if (fmt1 >= (firstShortFormat())) {
		functionLength = (((long)numSlots3) << ((shiftForWord()) - 1)) - (fmt1 & 3);
		goto l3;
	}
	if (fmt1 >= (firstLongFormat())) {
		functionLength = (((long)numSlots3) << ((shiftForWord()) - 2)) - (fmt1 & 1);
		goto l3;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat())) {
		functionLength = numSlots3;
		goto l3;
	}
	functionLength = 0;
l3:	/* end lengthOf:format: */;
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = -3);
		return;
	}
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr == 0) {
		(GIV(primFailCode) = -1);
		return;
	}
	/* begin eeInstantiateClassIndex:format:numSlots: */
	numSlots4 = 5;
	assert((numSlots4 >= 0)
	 && (ClassArrayCompactIndex != 0));
	assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
	GIV(tempOop) = allocateNewSpaceSlotsformatclassIndex(numSlots4, 2, ClassArrayCompactIndex);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (argumentArray = popStack());
	assert(!(isForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = (primRcvr = popStack());
	assert(!(isForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (1LL << (shiftForWord())), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer2 = top;
	assert(!(isForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (2LL << (shiftForWord())), valuePointer2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer3 = top1;
	assert(!(isForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (3LL << (shiftForWord())), valuePointer3);
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), primRcvr);
	GIV(stackPointer) = sp5;
	GIV(argumentCount) = arraySize;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (4LL << (shiftForWord())), GIV(newMethod));
	GIV(newMethod) = methodArg;
	/* begin callExternalPrimitive: */
	primitiveFunctionPointer = addr;

	dispatchFunctionPointer(addr);
	/* begin maybeFailForLastObjectOverwrite */
	if (checkAllocFiller) {
		if (((freeStart()) < GIV(scavengeThreshold))
		 && ((longAt(freeStart())) != (freeStart()))) {
			GIV(primFailCode) = PrimErrWritePastObject;
		}
	}
	/* begin maybeRetryFailureDueToForwarding */
	if (GIV(primFailCode)
	 && (checkForAndFollowForwardedPrimitiveState())) {
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
	}
	GIV(newMethod) = longAt((GIV(tempOop) + BaseHeaderSize) + (4LL << (shiftForWord())));

	if (GIV(primFailCode)) {

		/* If primitive failed, then restore state for failure code */
		/* begin pop: */
		nItems = arraySize + 1;
		GIV(stackPointer) += nItems * BytesPerWord;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (3LL << (shiftForWord()))));
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (2LL << (shiftForWord()))));
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (1LL << (shiftForWord()))));
		GIV(stackPointer) = sp3;
		/* begin push: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (0LL << (shiftForWord()))));
		GIV(stackPointer) = sp4;

		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(argumentCount) = 3;
		primitiveFunctionPointer = primitiveDoNamedPrimitiveWithArgs;

		if (GIV(primFailCode) == 1) {
			GIV(primFailCode) = -1;
		}
	}
}

	/* StackInterpreterPrimitives>>#primitiveDoPrimitiveWithArgs */
static void
primitiveDoPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt index;
    sqInt integerPointer;
    sqInt nArgs;
    sqInt nArgs1;
    usqInt numSlots;
    sqInt primIdx;
    char *savedFramePointer;
    char *savedFramePointer1;
    char *savedStackPointer;
    char *savedStackPointer1;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt successBoolean;

	nArgs = 0;
	nArgs1 = 0;
	savedFramePointer = 0;
	savedFramePointer1 = 0;
	savedStackPointer = 0;
	savedStackPointer1 = 0;
	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(argumentArray - BaseHeaderSize))) << 8)))) >> 8
		: numSlots);
	/* begin success: */
	successBoolean = roomToPushNArgs(arraySize);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		primIdx = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		primIdx = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primIdx > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIdx])));
	if (primitiveFunctionPointer == 0) {
		primitiveFunctionPointer = primitiveDoPrimitiveWithArgs;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	GIV(argumentCount) = arraySize;
	index = 1;
	while (index <= GIV(argumentCount)) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord()))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
		externalQuickPrimitiveResponse();
		return;
	}

	/* prim might alloc/gc */
	/* Run the primitive (sets primFailCode) */
	GIV(tempOop) = argumentArray;
	GIV(tempOop2) = GIV(newMethod);
	GIV(newMethod) = ((primIdx << 3) | 1);
	/* begin slowPrimitiveResponse */
	assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
	assert((remapBufferCount()) == 0);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	dispatchFunctionPointer(primitiveFunctionPointer);
	/* begin maybeRetryFailureDueToForwarding */
	if (GIV(primFailCode)
	 && (checkForAndFollowForwardedPrimitiveState())) {
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
	}
	/* begin maybeFailForLastObjectOverwrite */
	if (checkAllocFiller) {
		if (((freeStart()) < GIV(scavengeThreshold))
		 && ((longAt(freeStart())) != (freeStart()))) {
			GIV(primFailCode) = PrimErrWritePastObject;
		}
	}
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	!GIV(primFailCode);
	GIV(newMethod) = GIV(tempOop2);
	GIV(tempOop2) = 0;

	if (GIV(primFailCode)) {

		/* If primitive failed, then restore state for failure code */
		/* begin pop: */
		GIV(stackPointer) += arraySize * BytesPerWord;
		/* begin pushInteger: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((primIdx << 3) | 1));
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(tempOop));
		GIV(stackPointer) = sp2;
		primitiveFunctionPointer = primitiveDoPrimitiveWithArgs;
		GIV(argumentCount) = 2;
	}
	GIV(tempOop) = 0;
}


/*	receiver, args, then method are on top of stack. Execute method against
	receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

	/* StackInterpreterPrimitives>>#primitiveExecuteMethod */
static void
primitiveExecuteMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt firstBytecode;
    sqInt i;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt table;
    sqInt top;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	methodArgument = longAt(GIV(stackPointer));
	if (!(((methodArgument & (tagMask())) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (!((GIV(argumentCount) - 1) == (argumentCountOf(methodArgument)))) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = top;
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	if (methodHeader & AlternateHeaderHasPrimFlag) {
		firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
		primitiveIndex = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
	}
	else {
		primitiveIndex = 0;
	}

	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) -= 1;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l2;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l2;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((int) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader1)) < 0
								? AltLongStoreBytecode
								: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
						goto l1;
					}
				}
				errorCode = ((GIV(primFailCode) << 3) | 1);
			l1:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader2 = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader2));
	}
l2:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	receiver, argsArray, then method are on top of stack. Execute method
	against receiver and args. Allow for up to two extra arguments (e.g. for
	mirror primitives).
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and hence primitiveFunctionPointer is stale. */

	/* StackInterpreterPrimitives>>#primitiveExecuteMethodArgsArray */
static void
primitiveExecuteMethodArgsArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argCnt;
    sqInt argumentArray;
    sqInt errorCode;
    sqInt firstBytecode;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt rcvr;
    sqInt rcvr1;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	methodArgument = longAt(GIV(stackPointer));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((methodArgument & (tagMask())) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
		 && (((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2)))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	/* begin argumentCountOf: */
	assert(isCompiledMethod(methodArgument));
	header = longAt((methodArgument + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	argCnt = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
	if (!(argCnt == (numSlotsOf(argumentArray)))) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	if (GIV(argumentCount) > 2) {

		/* CompiledMethod class>>receiver:withArguments:executeMethod:
		   SqueakObjectPrimitives class>>receiver:withArguments:apply:
		   VMMirror>>ifFail:object:with:executeMethod: et al */
		rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
		if ((GIV(argumentCount) > 4)
		 || (((rcvr & (tagMask())) == 0)
		 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))) {
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	for (i = 0; i < argCnt; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((long)i) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	GIV(newMethod) = methodArgument;
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	if (methodHeader & AlternateHeaderHasPrimFlag) {
		firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
		primitiveIndex = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
	}
	else {
		primitiveIndex = 0;
	}

	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = argCnt;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l2;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l2;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr1)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((int) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader1)) < 0
								? AltLongStoreBytecode
								: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
						goto l1;
					}
				}
				errorCode = ((GIV(primFailCode) << 3) | 1);
			l1:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader2 = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader2));
	}
l2:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Call an external primitive. External primitive methods first literals are
	an array of
	* The module name (String | Symbol)
	* The function name (String | Symbol)
	* The session ID (SmallInteger) [OBSOLETE] (or in Spur, the accessorDepth)
	* The function index (Integer) in the externalPrimitiveTable
	For fast interpreter dispatch in subsequent invocations the
	primitiveFunctionPointer in the method cache is rewritten, either to the
	function itself, or to zero if the external
	function is not found. This allows for fast responses as long as the
	method stays in
	the cache. The cache rewrite relies on lastMethodCacheProbeWrite which is
	set in
	addNewMethodToCache:.
	Now that the VM flushes function addresses from its tables, the session ID
	is obsolete,
	but it is kept for backward compatibility. Also, a failed lookup is
	reported specially. If a
	method has been looked up and not been found, the function address is
	stored as -1
	(i.e., the SmallInteger -1 to distinguish from 16rFFFFFFFF which may be
	returned from
	lookup), and the primitive fails with PrimErrNotFound.
 */

	/* StackInterpreterPrimitives>>#primitiveExternalCall */
static void
primitiveExternalCall(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt accessorDepth;
    void (*addr)();
    sqInt fmt;
    sqInt fmt1;
    sqInt functionLength;
    sqInt functionName;
    sqInt i;
    sqInt i1;
    sqInt index;
    sqInt lit;
    sqInt moduleLength;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt val;


	/* Check for it being a method for primitiveDoPrimitiveWithArgs.
	   Fetch the first literal of the method; check its an Array of length 4.
	   Look at the function index in case it has been loaded before */
	accessorDepth = 0;
	val = 0;
	if (!((((GIV(newMethod) & (tagMask())) == 0)
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
		 && (((literalCountOfMethodHeader(methodHeaderOf(GIV(newMethod)))) > 0)
		 && (((lit = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)(0 + LiteralStart)) << (shiftForWord())))),
		(((lit & (tagMask())) == 0)
			 && (((((usqInt) (longAt(lit))) >> (formatShift())) & (formatMask())) == 2))
			 && (((numSlotsOf(lit)) == 4)
			 && (((index = longAt((lit + BaseHeaderSize) + (3LL << (shiftForWord())))),
			(((index) & 7) == 1))))))))) {
		(GIV(primFailCode) = PrimErrBadMethod);
		return;
	}

	/* Check if we have already looked up the function and failed. */
	index = (index >> 3);
	if (index < 0) {

		/* Function address was not found in this session,
		   Void the primitive function. */
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		(GIV(primFailCode) = PrimErrNotFound);
		return;
	}
	if ((index > 0)
	 && (index <= MaxExternalPrimitiveTableSize)) {
		addr = externalPrimitiveTable[index - 1];
		if (addr != 0) {
			rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
			/* begin callExternalPrimitive: */
			primitiveFunctionPointer = addr;

			dispatchFunctionPointer(addr);
			/* begin maybeFailForLastObjectOverwrite */
			if (checkAllocFiller) {
				if (((freeStart()) < GIV(scavengeThreshold))
				 && ((longAt(freeStart())) != (freeStart()))) {
					GIV(primFailCode) = PrimErrWritePastObject;
				}
			}
			/* begin maybeRetryFailureDueToForwarding */
			if (GIV(primFailCode)
			 && (checkForAndFollowForwardedPrimitiveState())) {
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				dispatchFunctionPointer(primitiveFunctionPointer);
			}
			return;
		}
		(GIV(primFailCode) = PrimErrNamedInternal);
		return;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + BaseHeaderSize) + (2LL << (shiftForWord())), ConstZero);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + BaseHeaderSize) + (3LL << (shiftForWord())), ConstZero);
	moduleName = longAt((lit + BaseHeaderSize) + (0LL << (shiftForWord())));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		if (!(((moduleName & (tagMask())) == 0)
			 && (((((usqInt) (longAt(moduleName))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
			GIV(primFailCode) = PrimErrBadMethod;
		}
		/* begin lengthOf:format: */
		fmt = (((usqInt) (longAt(moduleName))) >> (formatShift())) & (formatMask());
		/* begin numSlotsOfAny: */
		numSlots2 = byteAt(moduleName + 7);
		numSlots = (numSlots2 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(moduleName - BaseHeaderSize))) << 8)))) >> 8
			: numSlots2);
		if (fmt <= 5) {
			moduleLength = numSlots;
			goto l1;
		}
		if (fmt >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			moduleLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			moduleLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
			goto l1;
		}
		if (fmt >= (firstLongFormat())) {
			moduleLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
			goto l1;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			moduleLength = numSlots;
			goto l1;
		}
		moduleLength = 0;
	l1:	/* end lengthOf:format: */;
	}
	functionName = longAt((lit + BaseHeaderSize) + (1LL << (shiftForWord())));
	if (!(((functionName & (tagMask())) == 0)
		 && (((((usqInt) (longAt(functionName))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		GIV(primFailCode) = PrimErrBadMethod;
	}
	/* begin lengthOf:format: */
	fmt1 = (((usqInt) (longAt(functionName))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots3 = byteAt(functionName + 7);
	numSlots1 = (numSlots3 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(functionName - BaseHeaderSize))) << 8)))) >> 8
		: numSlots3);
	if (fmt1 <= 5) {
		functionLength = numSlots1;
		goto l4;
	}
	if (fmt1 >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		functionLength = (((long)numSlots1) << (shiftForWord())) - (fmt1 & 7);
		goto l4;
	}
	if (fmt1 >= (firstShortFormat())) {
		functionLength = (((long)numSlots1) << ((shiftForWord()) - 1)) - (fmt1 & 3);
		goto l4;
	}
	if (fmt1 >= (firstLongFormat())) {
		functionLength = (((long)numSlots1) << ((shiftForWord()) - 2)) - (fmt1 & 1);
		goto l4;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat())) {
		functionLength = numSlots1;
		goto l4;
	}
	functionLength = 0;
l4:	/* end lengthOf:format: */;
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLengthAccessorDepthInto(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength, (&accessorDepth));
	if (addr == 0) {
		index = -1;
	}
	else {

		/* add the function to the external primitive table */
		/* begin addToExternalPrimitiveTable: */
		for (i = GIV(externalPrimitiveTableFirstFreeIndex); i < MaxExternalPrimitiveTableSize; i += 1) {
			if ((externalPrimitiveTable[i]) == 0) {
				externalPrimitiveTable[i] = (((void *) addr));
				index = (GIV(externalPrimitiveTableFirstFreeIndex) = i + 1);
				goto l2;
			}
		}
		index = 0;
	l2:	/* end addToExternalPrimitiveTable: */;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(lit)));
		longAtput((lit + BaseHeaderSize) + (2LL << (shiftForWord())), ((accessorDepth << 3) | 1));
	}

	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + BaseHeaderSize) + (3LL << (shiftForWord())), ((index << 3) | 1));
	if (index >= 0) {
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
		/* begin callExternalPrimitive: */
		primitiveFunctionPointer = addr;

		dispatchFunctionPointer(addr);
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
	}
	else {

		/* Otherwise void the primitive function and fail */
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		assert((fetchPointerofObject(2, lit)) == ConstZero);
		GIV(primFailCode) = PrimErrNotFound;
	}
}


/*	Primitive. Search up the context stack for the next method context marked
	for exception handling starting at the receiver. Return nil if none found */

	/* StackInterpreterPrimitives>>#primitiveFindHandlerContext */
static void
primitiveFindHandlerContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt handlerOrNilOrZero;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(199, longAt(GIV(stackPointer)), GIV(nilObj));
	if (handlerOrNilOrZero == 0) {
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	Primitive. Search up the context stack for the next method context marked
	for unwind
	handling from the receiver up to but not including the argument. Return
	nil if none found.
 */

	/* StackInterpreterPrimitives>>#primitiveFindNextUnwindContext */
static void
primitiveFindNextUnwindContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    sqInt handlerOrNilOrZero;
    sqInt senderContext;
    sqInt senderOop;
    char *sp;
    sqInt startContext;
    char *startFP;
    sqInt stopContext;
    char *theFP;
    char *theFP1;
    char *theFPAbove;
    sqInt theMethod;
    char *theSP;

	stopContext = longAt(GIV(stackPointer));
	calleeContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((stopContext == GIV(nilObj))
		 || (((stopContext & (tagMask())) == 0)
		 && (((longAt(stopContext)) & (classIndexMask())) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((((longAt((calleeContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(calleeContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((calleeContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - 1);
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, longAt(theFP + FoxCallerContext), stopContext);
		}
		else {
			/* begin findMethodWithPrimitive:FromFP:UpToContext: */
			startFP = pointerForOop(longAt(theFP + FoxSavedFP));
			theFP1 = startFP;
			theFPAbove = startFP;
			do {
				if (((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0)
				 && (stopContext == (longAt(theFP1 + FoxThisContext)))) {
					handlerOrNilOrZero = 0;
					goto l1;
				}
				if (!((byteAt((theFP1 + FoxFrameFlags) + 3)) != 0)) {
					theMethod = longAt(theFP1 + FoxMethod);
					if ((primitiveIndexOfMethodheader(theMethod, methodHeaderOf(theMethod))) == 198) {
						if (theFP1 == theFPAbove) {
							theSP = findSPOfon(theFP1, stackPageFor(theFP1));
						}
						else {
							/* begin frameCallerStackPointer: */
							assert(!(isBaseFrame(theFPAbove)));
							theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
						}
						/* begin ensureFrameIsMarried:SP: */
						if ((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(theFP1)));
							handlerOrNilOrZero = longAt(theFP1 + FoxThisContext);
							goto l1;
						}
						handlerOrNilOrZero = marryFrameSP(theFP1, theSP);
						goto l1;
					}
				}
				theFPAbove = theFP1;
				theFP1 = pointerForOop(longAt(theFP1 + FoxSavedFP));
			} while(theFP1 != 0);
			senderContext = longAt(theFPAbove + FoxCallerContext);
			if (!(((senderContext & (tagMask())) == 0)
				 && (((longAt(senderContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
				handlerOrNilOrZero = GIV(nilObj);
				goto l1;
			}
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, stopContext);
		l1:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
		}
	}
	else {
		startContext = longAt((calleeContext + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		if (((startContext & (tagMask())) == 0)
		 && (((longAt(startContext)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, startContext, stopContext);
		}
		else {
			handlerOrNilOrZero = 0;
		}
	}
	if (handlerOrNilOrZero == 0) {
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that refer to this method, presumably because it has been redefined,
	overridden or removed.
 */

	/* StackInterpreterPrimitives>>#primitiveFlushCacheByMethod */
static void
primitiveFlushCacheByMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt i;
    sqInt i1;
    sqInt methodHeader;
    sqInt oldMethod;
    sqInt primBits;
    sqInt primIdx;
    sqInt probe;

	oldMethod = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheMethod]) == oldMethod) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(oldMethod));
	methodHeader = longAt((oldMethod + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	if (methodHeader & AlternateHeaderHasPrimFlag) {
		firstBytecode = (oldMethod + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
		primIdx = (byteAt(firstBytecode + 1)) + (((long)(byteAt(firstBytecode + 2))) << 8);
	}
	else {
		primIdx = 0;
	}

	if (primIdx == PrimitiveExternalCallIndex) {

		/* It's primitiveExternalCall */
		flushExternalPrimitiveOf(oldMethod);
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	The receiver is a message selector. Clear all entries in the method lookup
	cache with this selector, presumably because an associated method has been
	redefined.  */

	/* StackInterpreterPrimitives>>#primitiveFlushCacheBySelector */
static void
primitiveFlushCacheBySelector(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt probe;
    sqInt selector;

	selector = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == selector) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (fetchPointerofObject(16 * 2, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord()))))))
	 || (selector == (fetchPointerofObject(17 * 2, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)SpecialSelectors) << (shiftForWord()))))))) {
		/* begin flushAtCache */
		for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
			GIV(atCache)[i1] = 0;
		}
	}
}


/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */
/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */

	/* StackInterpreterPrimitives>>#primitiveFullGC */
static void
primitiveFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    sqInt integerVal1;
    char *sp;
    char *sp1;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin pop:thenPushInteger: */
	integerVal = fullGC();
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal << 3) | 1));
	GIV(stackPointer) = sp;
	return;

	/* begin incrementalGC */
	error("shouldNotImplement");
	fullGC();
	/* begin pop:thenPushInteger: */
	integerVal1 = (((GIV(totalFreeOldSpace) + ((((eden()).limit)) - GIV(freeStart))) + ((((pastSpace()).limit)) - GIV(pastSpaceStart))) + ((((futureSpace()).limit)) - (((futureSpace()).limit)))) - (interpreterAllocationReserveBytes());
	longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal1 << 3) | 1));
	GIV(stackPointer) = sp1;
}


/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */

	/* StackInterpreterPrimitives>>#primitiveIncrementalGC */
static void
primitiveIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin scavengingGC */
	scavengingGCTenuringIf(TenureByAge);

	/* begin pop:thenPushInteger: */
	integerVal = (((GIV(totalFreeOldSpace) + ((((eden()).limit)) - GIV(freeStart))) + ((((pastSpace()).limit)) - GIV(pastSpaceStart))) + ((((futureSpace()).limit)) - (((futureSpace()).limit)))) - (interpreterAllocationReserveBytes());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveInstVarAt */
static void
primitiveInstVarAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    sqInt integerValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;
    sqInt value;

	index = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & (tagMask())) != 1)
	 || ((GIV(argumentCount) > 1)
	 && (((rcvr & (tagMask())) == 0)
	 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if ((rcvr & (tagMask())) != 0) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	index = (index >> 3);
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l1;
	}
	totalLength = 0;
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		value = externalInstVarofContext(index - 1, rcvr);
	}
	else {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			value = longAt((rcvr + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord())));
			goto l2;
		}
		if (fmt >= (firstByteFormat())) {
			value = (((byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 3) | 1);
			goto l2;
		}
		if (fmt >= (firstShortFormat())) {
			value = (((shortAt((rcvr + BaseHeaderSize) + (((long)(index - 1)) << 1))) << 3) | 1);
			goto l2;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((long)(index - 1)) << 2));
		value = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
		goto l2;

	l2:	/* end subscript:with:format: */;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveInstVarAtPut */
static void
primitiveInstVarAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    sqInt newValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt signedValueToStore;
    char *sp;
    sqInt totalLength;
    usqInt unsignedValueToStore;

	newValue = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (((index & (tagMask())) != 1)
	 || ((GIV(argumentCount) > 2)
	 && (((rcvr & (tagMask())) == 0)
	 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if ((rcvr & (tagMask())) != 0) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	index = (index >> 3);
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		totalLength = (((long)numSlots) << (shiftForWord())) - (fmt & 7);
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l2;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (((long)numSlots) << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l2;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l2;
	}
	totalLength = 0;
l2:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (((long)InstanceSpecificationIndex) << (shiftForWord())))) >> 3)) & ((1LL << (fixedFieldsFieldWidth())) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		externalInstVarofContextput(index - 1, rcvr, newValue);
	}
	else {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */
				if (((newValue & (tagMask())) == 0)
				 && (oopisLessThan(newValue, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((long)(index - 1)) << (shiftForWord())), newValue);
			goto l1;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((((newValue) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l1;
			}
			signedValueToStore = (newValue >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l1;
			}
			byteAtput((rcvr + BaseHeaderSize) + (index - 1), signedValueToStore);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			if (!((((newValue) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l1;
			}
			signedValueToStore = (newValue >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l1;
			}
			shortAtput((rcvr + BaseHeaderSize) + (((long)(index - 1)) << 1), signedValueToStore);
			goto l1;
		}
		unsignedValueToStore = positive32BitValueOf(newValue);
		if (!GIV(primFailCode)) {
			long32Atput((rcvr + BaseHeaderSize) + (((long)(index - 1)) << 2), unsignedValueToStore);
		}
	l1:	/* end subscript:with:storing:format: */;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer an Array with the current long-running primitive method
	identified by
	the heartbeat, the minimum number of milliseconds it was active for, and
	the milliseconds
	of GC activity there-in, or nil if none. Since the
	longRunningPrimitiveCheckMethod is
	sampled at interrupt time be careful to validate it before returning it. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitive */
EXPORT(sqInt)
primitiveLongRunningPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt gcms;
    sqInt lrpcm;
    sqInt primms;
    sqInt result;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((((lrpcm = GIV(longRunningPrimitiveCheckMethod))) != null)
	 && ((addressCouldBeObj(lrpcm))
	 && ((!(((longAt(lrpcm)) & (classIndexMask())) == 0))
	 && (((((usqInt) (longAt(lrpcm))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))))) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassArray) << (shiftForWord()))), 3);
		primms = ((GIV(longRunningPrimitiveStopUsecs) - GIV(longRunningPrimitiveStartUsecs)) + 500) / 1000;
		gcms = (GIV(longRunningPrimitiveGCUsecs) + 500) / 1000;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((lrpcm & (tagMask())) == 0)
			 && (oopisLessThan(lrpcm, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (0LL << (shiftForWord())), lrpcm);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (1LL << (shiftForWord())), ((primms << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (2LL << (shiftForWord())), ((gcms << 3) | 1));
	}
	else {
		result = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
	voidLongRunningPrimitive("get");
}


/*	Primitive. Install the semaphore to be used for collecting long-running
	primitives, 
	or nil if no semaphore should be used. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitiveSemaphore */
EXPORT(sqInt)
primitiveLongRunningPrimitiveSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;

	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((((sema) & 7) == 1))
	 || (GIV(argumentCount) != 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (sema == GIV(nilObj)) {
		GIV(longRunningPrimitiveCheckSemaphore) = null;
	}
	else {
		if (!(((sema & (tagMask())) == 0)
			 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord())))))))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		GIV(longRunningPrimitiveCheckSemaphore) = sema;
	}
	voidLongRunningPrimitive("install");
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	This primitive is assumed to be fast (see e.g.
	MethodDictionary>>includesKey:) so make it so.
	N.B. Works forrectly for cogged methods too. */

	/* StackInterpreterPrimitives>>#primitiveObjectPointsTo */
static void
primitiveObjectPointsTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqLong header;
    sqInt i;
    sqInt methodHeader;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt thang;
    sqInt trueOrFalse;

	thang = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & (tagMask())) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	header = long64At(rcvr);
	fmt = (((unsigned sqLong)header) >> (formatShift())) & (formatMask());
	if (fmt <= 5) {
		if ((fmt == (indexablePointersFormat()))
		 && ((header & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			if (((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				if ((((((longAt((rcvr + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
				 && (!(isWidowedContext(rcvr)))) {
					/* begin pop:thenPushBool: */
					trueOrFalse = marriedContextpointsTostackDeltaForCurrentFrame(rcvr, thang, 2);
					longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (trueOrFalse
						? GIV(trueObj)
						: GIV(falseObj)));
					GIV(stackPointer) = sp1;
					return;
				}
			}
			numSlots = CtxtTempFrameStart + (fetchStackPointerOf(rcvr));
		}
		else {
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
			numSlots1 = byteAt(rcvr + 7);
			numSlots = (numSlots1 == (numSlotsMask())
				? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
				: numSlots1);
		}
	}
	else {
		if (fmt < (firstCompiledMethodFormat())) {

			/* no pointers */
			/* begin pop:thenPushBool: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(rcvr));
		methodHeader = longAt((rcvr + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
		if (methodHeader == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp3;
			return;
		}
		numSlots = (literalCountOfMethodHeader(methodHeader)) + LiteralStart;
	}
	assert((((numSlots - 1) * BytesPerOop) + BaseHeaderSize) == (lastPointerOf(rcvr)));
	for (i = BaseHeaderSize; i <= (((numSlots - 1) * BytesPerOop) + BaseHeaderSize); i += BytesPerOop) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp4 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp4;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp5 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp5;
}

	/* StackInterpreterPrimitives>>#primitivePerform */
static void
primitivePerform(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt newReceiver;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    usqInt performMethod;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt table;
    sqInt tagBits;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	performMethod = GIV(newMethod);
	GIV(messageSelector) = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));

	/* NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,
	   so we must adjust argumentCount and slide args now, so that will work. */
	/* Slide arguments down over selector */
	newReceiver = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	GIV(argumentCount) -= 1;
	for (i = GIV(argumentCount); i >= 1; i += -1) {
		longAtput(GIV(stackPointer) + (i * BytesPerWord), longAt(GIV(stackPointer) + ((i - 1) * BytesPerWord)));
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	lookupClassTag = (((tagBits = newReceiver & (tagMask()))) != 0
		? tagBits
		: (longAt(newReceiver)) & (classIndexMask()));
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), newReceiver);
	findNewMethodInClassTag(lookupClassTag);
	if (!((((GIV(newMethod) & (tagMask())) == 0)
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)))) {

		/* Slide the args back up (sigh) and re-insert the selector. */
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
		for (i = 1; i <= GIV(argumentCount); i += 1) {
			longAtput(GIV(stackPointer) + ((i - 1) * BytesPerWord), longAt(GIV(stackPointer) + (i * BytesPerWord)));
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), GIV(messageSelector));
		GIV(argumentCount) += 1;
		GIV(newMethod) = performMethod;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((long)HeaderIndex) << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((int) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((long)numArgs) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (((long)numArgs) << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((int) methodHeader1)) < 0
								? AltLongStoreBytecode
								: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)PrimErrTableIndex) << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((long)(GIV(primFailCode) - 1)) << (shiftForWord())));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 3) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Pin or unpin the receiver, i.e. make it immobile or mobile, based on the
	argument. Answer whether the object was already pinned. N.B. pinning does
	*not* prevent
	an object from being garbage collected. */

	/* StackInterpreterPrimitives>>#primitivePin */
static void
primitivePin(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt boolean;
    sqInt obj;
    char *sp;
    sqInt wasPinned;

	obj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((obj & (tagMask())) != 0)
	 || (((longAt(obj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	boolean = longAt(GIV(stackPointer));
	if (!((boolean == GIV(falseObj))
		 || (boolean == GIV(trueObj)))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (((((usqInt) (longAt(obj))) >> 30) & 1) != 0) {
		wasPinned = GIV(trueObj);
		if (boolean != wasPinned) {
			/* begin setIsPinnedOf:to: */
			longAtput(obj, (longAt(obj)) & (~(1LL << 30)));
		}
	}
	else {
		wasPinned = GIV(falseObj);
		if (boolean == GIV(trueObj)) {
			if ((((obj & (tagMask())) == 0)
			 && (((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex))
			 && ((((((longAt((obj + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
			 && (!(isWidowedContext(obj))))) {
				(GIV(primFailCode) = PrimErrBadReceiver);
				return;
			}
			if ((pinObject(obj)) == 0) {
				(GIV(primFailCode) = PrimErrNoMemory);
				return;
			}
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), wasPinned);
	GIV(stackPointer) = sp;
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage
	collection 
 */

	/* StackInterpreterPrimitives>>#primitiveSetGCSemaphore */
EXPORT(void)
primitiveSetGCSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcSemaphoreIndex) = index;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtMilliseconds */
static void
primitiveSignalAtMilliseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaMsecs;
    usqInt msecs;
    sqInt msecsObj;
    sqInt sema;

	msecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	msecs = positive32BitValueOf(msecsObj);
	if (!GIV(primFailCode)) {
		if (((sema & (tagMask())) == 0)
		 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord()))))))) {
			/* begin splObj:put: */
			assert(!(isForwarded(GIV(specialObjectsOop))));
			if (isOldObject(GIV(specialObjectsOop))) {

				/* most stores into young objects */
				if (((sema & (tagMask())) == 0)
				 && (oopisLessThan(sema, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(GIV(specialObjectsOop));
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheTimerSemaphore) << (shiftForWord())), sema);
			deltaMsecs = msecs - ((ioMSecs()) & MillisecondClockMask);
			if (deltaMsecs < 0) {
				deltaMsecs = (deltaMsecs + MillisecondClockMask) + 1;
			}
			GIV(nextWakeupUsecs) = (ioUTCMicroseconds()) + (deltaMsecs * 1000);
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(GIV(specialObjectsOop))));
			if (isOldObject(GIV(specialObjectsOop))) {

				/* most stores into young objects */
				if (((GIV(nilObj) & (tagMask())) == 0)
				 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(GIV(specialObjectsOop));
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheTimerSemaphore) << (shiftForWord())), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtUTCMicroseconds */
static void
primitiveSignalAtUTCMicroseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    usqLong usecs;
    sqInt usecsObj;

	usecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	usecs = positive64BitValueOf(usecsObj);
	if (!GIV(primFailCode)) {
		if (((sema & (tagMask())) == 0)
		 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassSemaphore) << (shiftForWord()))))))) {
			/* begin splObj:put: */
			assert(!(isForwarded(GIV(specialObjectsOop))));
			if (isOldObject(GIV(specialObjectsOop))) {

				/* most stores into young objects */
				if (((sema & (tagMask())) == 0)
				 && (oopisLessThan(sema, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(GIV(specialObjectsOop));
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheTimerSemaphore) << (shiftForWord())), sema);
			GIV(nextWakeupUsecs) = usecs;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(GIV(specialObjectsOop))));
			if (isOldObject(GIV(specialObjectsOop))) {

				/* most stores into young objects */
				if (((GIV(nilObj) & (tagMask())) == 0)
				 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(GIV(specialObjectsOop));
					}
				}
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)TheTimerSemaphore) << (shiftForWord())), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Answer a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive answers the raw integral value
	at each slot. 
	e.g. for Strings it answers the character code, not the Character object
	at each slot. */

	/* StackInterpreterPrimitives>>#primitiveSlotAt */
static void
primitiveSlotAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt integerValue;
    sqInt numLiveSlots;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    sqInt value;

	index = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if ((rcvr & (tagMask())) != 0) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
	index = ((index >> 3)) - 1;
	if (fmt <= 5) {
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots1 = byteAt(rcvr + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if ((((unsigned long)index)) < numSlots) {
			if (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				numLiveSlots = (stackPointerForMaybeMarriedContext(rcvr)) + CtxtTempFrameStart;
				if ((((unsigned long)index)) < numLiveSlots) {
					value = externalInstVarofContext(index, rcvr);
				}
				else {
					value = GIV(nilObj);
				}
			}
			else {
				value = longAt((rcvr + BaseHeaderSize) + (((long)index) << (shiftForWord())));
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
		assert(fmt1 >= (firstByteFormat()));
		numSlots = (((long)(numSlotsOf(rcvr))) << (shiftForWord())) - (fmt1 & 7);
		if ((((unsigned long)index)) < numSlots) {
			/* begin pop:thenPushInteger: */
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((byteAt((rcvr + BaseHeaderSize) + index)) << 3) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstShortFormat())) {
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 1;
		if ((((unsigned long)index)) < numSlots) {
			/* begin pop:thenPushInteger: */
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((shortAt((rcvr + BaseHeaderSize) + (((long)index) << 1))) << 3) | 1));
			GIV(stackPointer) = sp2;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 3;
		if ((((unsigned long)index)) < numSlots) {
			/* begin pop:thenPush: */
			oop = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((long)index) << 3)));
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp3;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstLongFormat())) {
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 2;
		if ((((unsigned long)index)) < numSlots) {
			/* begin pop:thenPush: */
			integerValue = long32At((rcvr + BaseHeaderSize) + (((long)index) << 2));
			oop1 = (((integerValue & 0xFFFFFFFFULL) << 3) | 1);
			goto l1;

		l1:	/* end positive32BitIntegerFor: */;
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop1);
			GIV(stackPointer) = sp4;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	(GIV(primFailCode) = PrimErrBadReceiver);
	return;
}


/*	Assign a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive assigns a raw integral value
	at each slot. */

	/* StackInterpreterPrimitives>>#primitiveSlotAtPut */
static void
primitiveSlotAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt badRcvr;
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt index;
    sqInt newValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt ok;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    unsigned long value;
    sqInt value1;

	newValue = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	
#  if IMMUTABILITY
	badRcvr = ((rcvr & (tagMask())) != 0)
	 || (((((usqInt) (longAt(rcvr))) >> 23) & 1) != 0);

#  else /* IMMUTABILITY */
	badRcvr = (rcvr & (tagMask())) != 0;

#  endif /* IMMUTABILITY */

	if (badRcvr) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
	index = ((index >> 3)) - 1;
	if (fmt <= 5) {
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots1 = byteAt(rcvr + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(rcvr - BaseHeaderSize))) << 8)))) >> 8
			: numSlots1);
		if ((((unsigned long)index)) < numSlots) {
			if (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				externalInstVarofContextput(index, rcvr, newValue);
			}
			else {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				if (isOldObject(rcvr)) {

					/* most stores into young objects */
					if (((newValue & (tagMask())) == 0)
					 && (oopisLessThan(newValue, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(rcvr);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((long)index) << (shiftForWord())), newValue);
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin positiveMachineIntegerValueOf: */
	if ((((newValue) & 7) == 1)) {
		value1 = (newValue >> 3);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = null;
			goto l2;
		}
		value = value1;
		goto l2;
	}
	if ((newValue & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(newValue)));
	ccIndex = (longAt(newValue)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l2;
	}
	/* begin numBytesOfBytes: */
	fmt2 = (((usqInt) (longAt(newValue))) >> (formatShift())) & (formatMask());
	assert(fmt2 >= (firstByteFormat()));
	bs = (((long)(numSlotsOf(newValue))) << (shiftForWord())) - (fmt2 & 7);
	if (bs > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l2;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		value = 
#    if VMBIGENDIAN
			(((((((byteAt((newValue + BaseHeaderSize))) + (((long)(byteAt((newValue + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((newValue + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((newValue + BaseHeaderSize) + 3))) << 24)) + (((long)(byteAt((newValue + BaseHeaderSize) + 4))) << 32)) + (((long)(byteAt((newValue + BaseHeaderSize) + 5))) << 40)) + (((long)(byteAt((newValue + BaseHeaderSize) + 6))) << 48)) + (((long)(byteAt((newValue + BaseHeaderSize) + 7))) << 56)
#    else /* VMBIGENDIAN */
			long64At((newValue + BaseHeaderSize) + (0LL << 3))
#    endif /* VMBIGENDIAN */
			;
		goto l2;
	}
	else {
		value = 
#    if VMBIGENDIAN
			(((byteAt((newValue + BaseHeaderSize))) + (((long)(byteAt((newValue + BaseHeaderSize) + 1))) << 8)) + (((long)(byteAt((newValue + BaseHeaderSize) + 2))) << 16)) + (((long)(byteAt((newValue + BaseHeaderSize) + 3))) << 24)
#    else /* VMBIGENDIAN */
			long32At((newValue + BaseHeaderSize) + (0LL << 2))
#    endif /* VMBIGENDIAN */
			;
		goto l2;
	}
l2:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		if ((((unsigned long)value)) > 0xFF) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
		assert(fmt1 >= (firstByteFormat()));
		numSlots = (((long)(numSlotsOf(rcvr))) << (shiftForWord())) - (fmt1 & 7);
		if ((((unsigned long)index)) < numSlots) {
			byteAtput((rcvr + BaseHeaderSize) + index, value);
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp1;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstShortFormat())) {
		if ((((unsigned long)value)) > 0xFFFF) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 1;
		if ((((unsigned long)index)) < numSlots) {
			shortAtput((rcvr + BaseHeaderSize) + (((long)index) << 1), value);
			/* begin pop:thenPush: */
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp2;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 3;
		if ((((unsigned long)index)) < numSlots) {
			long64Atput((rcvr + BaseHeaderSize) + (((long)index) << 3), value);
			/* begin pop:thenPush: */
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp3;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstLongFormat())) {
		if ((((unsigned long)value)) > 0xFFFFFFFFULL) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 2;
		if ((((unsigned long)index)) < numSlots) {
			long32Atput((rcvr + BaseHeaderSize) + (((long)index) << 2), value);
			/* begin pop:thenPush: */
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp4;
			return;
		}
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	(GIV(primFailCode) = PrimErrBadReceiver);
	return;
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil */

	/* StackInterpreterPrimitives>>#primitiveStoreStackp */
static void
primitiveStoreStackp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt newStackp;
    sqInt onCurrentPage;
    sqInt senderOop;
    sqInt sp;
    sqInt stackp;
    char *theFP;
    StackPage *thePage;

	ctxt = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		newStackp = (integerPointer >> 3);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		newStackp = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!((!GIV(primFailCode))
		 && (((newStackp >= 0) && (newStackp <= ((numSlotsOf(ctxt)) - CtxtTempFrameStart)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((((longAt((ctxt + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(ctxt)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((ctxt + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (((onCurrentPage = thePage == GIV(stackPage)))
		 && (theFP == GIV(framePointer))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		externalDivorceFrameandContext(theFP, ctxt);
		if (onCurrentPage) {
			GIV(framePointer) = (GIV(stackPage)->headFP);
			GIV(stackPointer) = (GIV(stackPage)->headSP);
		}
		else {
			assert(GIV(stackPage) == (stackPageFor(GIV(framePointer))));
			markStackPageMostRecentlyUsed(GIV(stackPage));
		}
	}
	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())));
	if (!((((sp) & 7) == 1))) {
		stackp = 0;
		goto l1;
	}
	assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(ctxt)));
	stackp = (sp >> 3);
l1:	/* end fetchStackPointerOf: */;
	for (i = (stackp + 1); i <= newStackp; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(ctxt)));
		longAtput((ctxt + BaseHeaderSize) + (((long)((i + CtxtTempFrameStart) - 1)) << (shiftForWord())), GIV(nilObj));
	}
	/* begin storeStackPointerValue:inContext: */
	assert((ReceiverIndex + newStackp) < (lengthOf(ctxt)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(ctxt)));
	longAtput((ctxt + BaseHeaderSize) + (((long)StackPointerIndex) << (shiftForWord())), ((newStackp << 3) | 1));
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Primitive. Terminate up the context stack from the receiver up to but not
	including the argument, if previousContext is on my Context stack. Make
	previousContext my
	sender. This prim has to shadow the code in ContextPart>terminateTo: to be
	correct. 
 */

	/* StackInterpreterPrimitives>>#primitiveTerminateTo */
static void
primitiveTerminateTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContextOrNil;
    char *callerFP;
    char *callerFP1;
    char *callerFP2;
    char *contextsFP;
    usqInt contextsIP;
    char *contextsSP;
    sqInt currentCtx;
    char *fp;
    char *fp1;
    char *fp2;
    char *frameAbove;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt index3;
    char *newFP;
    char *newSP;
    sqInt nextCntx;
    StackPage *pageToStopOn;
    sqInt senderOop;
    sqInt senderOop1;
    sqInt senderOop2;
    sqInt senderOop3;
    sqInt senderOop4;
    sqInt senderOop5;
    char *source;
    sqInt stackedReceiverOffset;
    char *theFP;
    char *theFP1;
    StackPage *thePage;
    sqInt thisCtx;
    sqInt valuePointer;
    sqInt valuePointer1;

	contextsFP = 0;
	aContextOrNil = longAt(GIV(stackPointer));
	if (!((aContextOrNil == GIV(nilObj))
		 || (((aContextOrNil & (tagMask())) == 0)
		 && (((longAt(aContextOrNil)) & (classIndexMask())) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	thisCtx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (thisCtx == aContextOrNil) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((aContextOrNil != GIV(nilObj))
	 && ((((((longAt((aContextOrNil + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(aContextOrNil))))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContextOrNil + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		contextsFP = pointerForOop(senderOop - 1);
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
		pageToStopOn = stackPageAtpages(index, GIV(pages));
	}
	else {
		pageToStopOn = 0;
	}
	if ((((((longAt((thisCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
	 && (!(isWidowedContext(thisCtx)))) {
		/* begin frameOfMarriedContext: */
		senderOop2 = longAt((thisCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop2) & 7) == 1));
		theFP = pointerForOop(senderOop2 - 1);
		if ((theFP == GIV(framePointer))
		 && (pageToStopOn == GIV(stackPage))) {
			if ((pointerForOop(longAt(theFP + FoxSavedFP))) != contextsFP) {
				stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()));
				/* begin findFrameAbove:inPage: */
				fp = (pageToStopOn->headFP);
				if (fp == contextsFP) {
					frameAbove = 0;
					goto l1;
				}
				while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
					if (callerFP == contextsFP) {
						frameAbove = fp;
						goto l1;
					}
					fp = callerFP;
				}
				error("did not find theFP in stack page");
				frameAbove = 0;
			l1:	/* end findFrameAbove:inPage: */;
				contextsIP = ((usqInt)(pointerForOop(longAt(frameAbove + FoxCallerSavedIP))));
				/* begin frameCallerSP: */
				assert(!(isBaseFrame(frameAbove)));
				newSP = (frameAbove + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
				newFP = (newSP - stackedReceiverOffset) - BytesPerWord;
				for (source = (theFP + stackedReceiverOffset); source >= GIV(stackPointer); source += (-BytesPerWord)) {
					newSP -= BytesPerWord;
					longAtput(newSP, longAt(source));
				}
				longAtput(newFP + FoxSavedFP, contextsFP);
				longAtput(newFP + FoxCallerSavedIP, contextsIP);
				assert(isContext(thisCtx));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(((oopForPointer(newFP)) & (BytesPerWord - 1)) == 0);
				valuePointer = (oopForPointer(newFP)) + 1;
				assert(!(isForwarded(thisCtx)));
				longAtput((thisCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), valuePointer);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(((oopForPointer(contextsFP)) & (BytesPerWord - 1)) == 0);
				valuePointer1 = (oopForPointer(contextsFP)) + 1;
				assert(!(isForwarded(thisCtx)));
				longAtput((thisCtx + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), valuePointer1);
				GIV(framePointer) = newFP;
				GIV(stackPointer) = newSP;
			}
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			assert(GIV(stackPage) == (mostRecentlyUsedPage()));
			return;
		}

		/* May cause a GC!! */
		theFP = externalEnsureIsBaseFrame(theFP);

		/* May also reclaim aContextOrNil's page, hence... */
		currentCtx = longAt(theFP + FoxCallerContext);
		if ((aContextOrNil != GIV(nilObj))
		 && ((((((longAt((aContextOrNil + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
		 && (!(isWidowedContext(aContextOrNil))))) {
			/* begin frameOfMarriedContext: */
			senderOop1 = longAt((aContextOrNil + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop1) & 7) == 1));
			contextsFP = pointerForOop(senderOop1 - 1);
			/* begin stackPageFor: */
			index1 = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
			pageToStopOn = stackPageAtpages(index1, GIV(pages));
		}
		else {
			pageToStopOn = 0;
		}
	}
	else {
		currentCtx = longAt((thisCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
	}
	if (contexthasSender(thisCtx, aContextOrNil)) {

		/* Need to walk the stack freeing stack pages and nilling contexts. */
		while (!((currentCtx == aContextOrNil)
		 || (currentCtx == GIV(nilObj)))) {
			assert(isContext(currentCtx));
			if (((((longAt((currentCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
				/* begin frameOfMarriedContext: */
				senderOop4 = longAt((currentCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
				/* begin withoutSmallIntegerTags: */
				assert((((senderOop4) & 7) == 1));
				theFP = pointerForOop(senderOop4 - 1);
				/* begin stackPageFor: */
				index3 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
				thePage = stackPageAtpages(index3, GIV(pages));
				if (thePage == GIV(stackPage)) {
					/* begin findFrameAbove:inPage: */
					fp1 = (thePage->headFP);
					if (fp1 == theFP) {
						frameAbove = 0;
						goto l2;
					}
					while (((callerFP1 = pointerForOop(longAt(fp1 + FoxSavedFP)))) != 0) {
						if (callerFP1 == theFP) {
							frameAbove = fp1;
							goto l2;
						}
						fp1 = callerFP1;
					}
					error("did not find theFP in stack page");
					frameAbove = 0;
				l2:	/* end findFrameAbove:inPage: */;
					assert(frameAbove != 0);

					/* May cause a GC!! May also reclaim aContextOrNil's page, hence... */
					frameAbove = externalEnsureIsBaseFrame(frameAbove);
					if ((aContextOrNil != GIV(nilObj))
					 && ((((((longAt((aContextOrNil + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1))
					 && (!(isWidowedContext(aContextOrNil))))) {
						/* begin frameOfMarriedContext: */
						senderOop3 = longAt((aContextOrNil + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop3) & 7) == 1));
						contextsFP = pointerForOop(senderOop3 - 1);
						/* begin stackPageFor: */
						index2 = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
						pageToStopOn = stackPageAtpages(index2, GIV(pages));
					}
					else {
						pageToStopOn = 0;
					}
				}
				else {
					if (thePage == pageToStopOn) {

						/* We're here.  Cut back the stack to aContextOrNil's frame,
						   push its instructionPointer if it's not already a head frame,
						   and we're done. */
						/* begin findFrameAbove:inPage: */
						fp2 = (thePage->headFP);
						if (fp2 == contextsFP) {
							frameAbove = 0;
							goto l3;
						}
						while (((callerFP2 = pointerForOop(longAt(fp2 + FoxSavedFP)))) != 0) {
							if (callerFP2 == contextsFP) {
								frameAbove = fp2;
								goto l3;
							}
							fp2 = callerFP2;
						}
						error("did not find theFP in stack page");
						frameAbove = 0;
					l3:	/* end findFrameAbove:inPage: */;
						if (frameAbove != 0) {
							contextsSP = (frameCallerSP(frameAbove)) - BytesPerWord;
							longAtput(contextsSP, pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
							/* begin setHeadFP:andSP:inPage: */
							assert(contextsSP < contextsFP);
							assert((contextsSP < ((thePage->baseAddress)))
							 && (contextsSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
							assert((contextsFP < ((thePage->baseAddress)))
							 && (contextsFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
							(thePage->headFP = contextsFP);
							(thePage->headSP = contextsSP);
						}
						currentCtx = aContextOrNil;
					}
					else {

						/* We can free the entire page without further ado. */
						/* begin frameCallerContext: */
						theFP1 = (thePage->baseFP);
						currentCtx = longAt(theFP1 + FoxCallerContext);
						freeStackPageNoAssert(thePage);
					}
				}
			}
			else {
				nextCntx = longAt((currentCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(currentCtx)));
				longAtput((currentCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), GIV(nilObj));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(currentCtx)));
				longAtput((currentCtx + BaseHeaderSize) + (((long)InstructionPointerIndex) << (shiftForWord())), GIV(nilObj));
				currentCtx = nextCntx;
			}
		}
	}
	assert(pageListIsWellFormed());
	if (((((longAt((thisCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord()))))) & 7) == 1)) {
		assert(checkIsStillMarriedContextcurrentFP(thisCtx, GIV(framePointer)));
		assert(isBaseFrame(frameOfMarriedContext(thisCtx)));
		/* begin frameOfMarriedContext: */
		senderOop5 = longAt((thisCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop5) & 7) == 1));
		theFP = pointerForOop(senderOop5 - 1);
		longAtput(theFP + FoxCallerContext, aContextOrNil);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(thisCtx)));
		if (isOldObject(thisCtx)) {

			/* most stores into young objects */
			if (((aContextOrNil & (tagMask())) == 0)
			 && (oopisLessThan(aContextOrNil, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(thisCtx))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(thisCtx);
				}
			}
		}
		longAtput((thisCtx + BaseHeaderSize) + (((long)SenderIndex) << (shiftForWord())), aContextOrNil);
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
}


/*	Behaviour depends on argument count:
	0 args:	return an Array of VM parameter values;
	1 arg:	return the indicated VM parameter;
	2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
	1	end (v3)/size(Spur) of old-space (0-based, read-only)
	2	end (v3)/size(Spur) of young/new-space (read-only)
	3	end (v3)/size(Spur) of heap (read-only)
	4	nil (was allocationCount (read-only))
	5	nil (was allocations between GCs (read-write)
	6	survivor count tenuring threshold (read-write)
	7	full GCs since startup (read-only)
	8	total milliseconds in full GCs since startup (read-only)
	9	incremental GCs (SqueakV3) or scavenges (Spur) since startup (read-only)
	10	total milliseconds in incremental GCs (SqueakV3) or scavenges (Spur)
	since startup (read-only)
	11	tenures of surving objects since startup (read-only)
	12-20 were specific to ikp's JITTER VM, now 12-19 are open for use
	20	utc microseconds at VM start-up (actually at time initialization, which
	precedes image load).
	21	root table size (read-only)
	22	root table overflows since startup (read-only)
	23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored
	in image file header).
	24	memory threshold above which shrinking object memory (rw)
	25	memory headroom when growing object memory (rw)
	26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds
	(rw) 27	number of times mark loop iterated for current IGC/FGC (read-only)
	includes ALL marking
	28	number of times sweep loop iterated for current IGC/FGC (read-only)
	29	number of times make forward loop iterated for current IGC/FGC
	(read-only) 30	number of times compact move loop iterated for current
	IGC/FGC (read-only)
	31	number of grow memory requests (read-only)
	32	number of shrink memory requests (read-only)
	33	number of root table entries used for current IGC/FGC (read-only)
	34	number of allocations done before current IGC/FGC (read-only)
	35	number of survivor objects after current IGC/FGC (read-only)
	36	millisecond clock when current IGC/FGC completed (read-only)
	37	number of marked objects for Roots of the world, not including Root
	Table entries for current IGC/FGC (read-only)
	38	milliseconds taken by current IGC (read-only)
	39	Number of finalization signals for Weak Objects pending when current
	IGC/FGC completed (read-only)
	40	BytesPerOop for this image
	41	imageFormatVersion for the VM
	42	number of stack pages in use
	43	desired number of stack pages (stored in image file header, max 65535)
	44	size of eden, in bytes
	45	desired size of eden, in bytes (stored in image file header)
	46	machine code zone size, in bytes (Cog only; otherwise nil)
	47	desired machine code zone size (stored in image file header; Cog only;
	otherwise nil)
	48	various header flags. See getCogVMFlags.
	49	max size the image promises to grow the external semaphore table to (0
	sets to default, which is 256 as of writing)
	50-51 nil; reserved for VM parameters that persist in the image (such as
	eden above)
	52	root table capacity
	53	number of segments (Spur only; otherwise nil)
	54	total size of free old space (Spur only, otherwise nil)
	55	ratio of growth and image size at or above which a GC will be performed
	post scavenge
	56	number of process switches since startup (read-only)
	57	number of ioProcessEvents calls since startup (read-only)
	58	number of ForceInterruptCheck calls since startup (read-only)
	59	number of check event calls since startup (read-only)
	60	number of stack page overflows since startup (read-only)
	61	number of stack page divorces since startup (read-only)
	62	compiled code compactions since startup (read-only; Cog only; otherwise
	nil) 63	total milliseconds in compiled code compactions since startup
	(read-only; Cog only; otherwise nil)
	64	the number of methods that currently have jitted machine-code
	65	whether the VM supports MULTIPLE_BYTECODE_SETS or not.
	66	the byte size of a stack page
	67	the max allowed size of old space (Spur only; nil otherwise; 0 implies
	no limit except that of the underlying platform)
	68	the average number of live stack pages when scanned by GC (at
	scavenge/gc/become et al)
	69	the maximum number of live stack pages when scanned by GC (at
	scavenge/gc/become et al)
	70	the vmProxyMajorVersion (the interpreterProxy VM_MAJOR_VERSION)
	71	the vmProxyMinorVersion (the interpreterProxy VM_MINOR_VERSION)
	Note: Thanks to Ian Piumarta for this primitive. */

	/* StackInterpreterPrimitives>>#primitiveVMParameter */
static void
primitiveVMParameter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double aDouble;
    float aProportion;
    sqInt arg;
    sqInt i;
    sqInt index;
    sqInt paramsArraySize;
    sqInt result;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt tagBits;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer10;
    sqInt valuePointer11;
    sqInt valuePointer12;
    sqInt valuePointer13;
    sqInt valuePointer14;
    sqInt valuePointer15;
    sqInt valuePointer16;
    sqInt valuePointer17;
    sqInt valuePointer18;
    sqInt valuePointer19;
    sqInt valuePointer2;
    sqInt valuePointer20;
    sqInt valuePointer21;
    sqInt valuePointer22;
    sqInt valuePointer23;
    sqInt valuePointer24;
    sqInt valuePointer25;
    sqInt valuePointer26;
    sqInt valuePointer27;
    sqInt valuePointer28;
    sqInt valuePointer29;
    sqInt valuePointer3;
    sqInt valuePointer4;
    sqInt valuePointer5;
    sqInt valuePointer6;
    sqInt valuePointer7;
    sqInt valuePointer8;
    sqInt valuePointer9;

	result = 0;
	paramsArraySize = 71;
	if (GIV(argumentCount) == 0) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((long)ClassArray) << (shiftForWord()))), paramsArraySize);
		/* begin storePointer:ofObject:withValue: */
		valuePointer4 = positive64BitIntegerFor(totalBytesInSegments());
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer4 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer4, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (0LL << (shiftForWord())), valuePointer4);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer5 = ((((GIV(freeStart) - (((eden()).start))) + (GIV(pastSpaceStart) - (((pastSpace()).start)))) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (1LL << (shiftForWord())), valuePointer5);
		/* begin storePointer:ofObject:withValue: */
		valuePointer6 = positive64BitIntegerFor((newSpaceCapacity()) + (totalBytesInSegments()));
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer6 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer6, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (2LL << (shiftForWord())), valuePointer6);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer7 = (((((sqInt)(((scavengerTenuringThreshold()) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (5LL << (shiftForWord())), valuePointer7);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (6LL << (shiftForWord())), ((GIV(statFullGCs) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (7LL << (shiftForWord())), ((((GIV(statFullGCUsecs) + 500) / 1000) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer8 = (((GIV(statScavenges)) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (8LL << (shiftForWord())), valuePointer8);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer9 = (((((GIV(statScavengeGCUsecs)) + 500) / 1000) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (9LL << (shiftForWord())), valuePointer9);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (10LL << (shiftForWord())), ((GIV(statTenures) << 3) | 1));
		for (i = 11; i <= 18; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(result)));
			longAtput((result + BaseHeaderSize) + (((long)i) << (shiftForWord())), ConstZero);
		}
		/* begin storePointer:ofObject:withValue: */
		valuePointer10 = positive64BitIntegerFor(ioUTCStartMicroseconds());
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer10 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer10, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (19LL << (shiftForWord())), valuePointer10);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer11 = (((rootTableCount()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (20LL << (shiftForWord())), valuePointer11);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (21LL << (shiftForWord())), ((GIV(statRootTableOverflows) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (22LL << (shiftForWord())), ((extraVMMemory << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (23LL << (shiftForWord())), ((GIV(shrinkThreshold) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (24LL << (shiftForWord())), ((GIV(growHeadroom) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer12 = (((ioHeartbeatMilliseconds()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (25LL << (shiftForWord())), valuePointer12);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (26LL << (shiftForWord())), ((GIV(statMarkCount) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (27LL << (shiftForWord())), (((sqInt)0 << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (28LL << (shiftForWord())), (((sqInt)0 << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (29LL << (shiftForWord())), ((GIV(statCompactPassCount) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (30LL << (shiftForWord())), ((GIV(statGrowMemory) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (0x1FLL << (shiftForWord())), ((GIV(statShrinkMemory) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (32LL << (shiftForWord())), ((GIV(statRootTableCount) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (34LL << (shiftForWord())), ((GIV(statSurvivorCount) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (35LL << (shiftForWord())), ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (36LL << (shiftForWord())), (((sqInt)0 << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (37LL << (shiftForWord())), ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (38LL << (shiftForWord())), ((GIV(statPendingFinalizationSignals) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (39LL << (shiftForWord())), ((BytesPerWord << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer13 = (((imageFormatVersion()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (40LL << (shiftForWord())), valuePointer13);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (41LL << (shiftForWord())), ((GIV(numStackPages) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (42LL << (shiftForWord())), ((desiredNumStackPages << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer14 = (((((GIV(eden).limit)) - ((GIV(eden).start))) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (43LL << (shiftForWord())), valuePointer14);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (44LL << (shiftForWord())), ((desiredEdenBytes << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (45LL << (shiftForWord())), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (46LL << (shiftForWord())), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer15 = ((((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | (4 + 16)) - (4 + 16)))) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (47LL << (shiftForWord())), valuePointer15);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer16 = (((ioGetMaxExtSemTableSize()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (48LL << (shiftForWord())), valuePointer16);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer17 = (((rootTableCapacity()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (51LL << (shiftForWord())), valuePointer17);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = (((numSegments()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (52LL << (shiftForWord())), valuePointer);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = ((GIV(totalFreeOldSpace) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (53LL << (shiftForWord())), valuePointer1);
		/* begin storePointer:ofObject:withValue: */
		valuePointer2 = floatObjectOf(getHeapGrowthToSizeGCRatio());
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer2 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer2, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (54LL << (shiftForWord())), valuePointer2);

		/* begin storePointer:ofObject:withValue: */
		valuePointer18 = positive64BitIntegerFor(GIV(statProcessSwitch));
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer18 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer18, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (55LL << (shiftForWord())), valuePointer18);
		/* begin storePointer:ofObject:withValue: */
		valuePointer19 = positive64BitIntegerFor(GIV(statIOProcessEvents));
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer19 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer19, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (56LL << (shiftForWord())), valuePointer19);
		/* begin storePointer:ofObject:withValue: */
		valuePointer20 = positive64BitIntegerFor(GIV(statForceInterruptCheck));
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer20 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer20, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (57LL << (shiftForWord())), valuePointer20);
		/* begin storePointer:ofObject:withValue: */
		valuePointer21 = positive64BitIntegerFor(GIV(statCheckForEvents));
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer21 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer21, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (58LL << (shiftForWord())), valuePointer21);
		/* begin storePointer:ofObject:withValue: */
		valuePointer22 = positive64BitIntegerFor(GIV(statStackOverflow));
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer22 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer22, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (59LL << (shiftForWord())), valuePointer22);
		/* begin storePointer:ofObject:withValue: */
		valuePointer23 = positive64BitIntegerFor(GIV(statStackPageDivorce));
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer23 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer23, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (60LL << (shiftForWord())), valuePointer23);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (61LL << (shiftForWord())), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (0x3ELL << (shiftForWord())), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (0x3FLL << (shiftForWord())), ConstZero);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer24 = GIV(trueObj);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (64LL << (shiftForWord())), valuePointer24);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer25 = (((stackPageByteSize()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (65LL << (shiftForWord())), valuePointer25);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer3 = (((maxOldSpaceSize()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (66LL << (shiftForWord())), valuePointer3);

		/* begin storePointer:ofObject:withValue: */
		valuePointer26 = floatObjectOf(statAverageLivePagesWhenMapping());
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */
			if (((valuePointer26 & (tagMask())) == 0)
			 && (oopisLessThan(valuePointer26, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (67LL << (shiftForWord())), valuePointer26);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer27 = (((statMaxPageCountWhenMapping()) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (68LL << (shiftForWord())), valuePointer27);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer28 = (((VM_PROXY_MAJOR) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (69LL << (shiftForWord())), valuePointer28);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer29 = (((VM_PROXY_MINOR) << 3) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + BaseHeaderSize) + (70LL << (shiftForWord())), valuePointer29);
		assert(paramsArraySize == 71);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	arg = longAt(GIV(stackPointer));
	if (GIV(argumentCount) == 1) {

		/* read VM parameter */
		if (!((((arg) & 7) == 1))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		arg = (arg >> 3);
		if ((arg < 1)
		 || (arg > paramsArraySize)) {
			(GIV(primFailCode) = PrimErrBadIndex);
			return;
		}
		result = GIV(nilObj);
		if (arg == 1) {
			result = positive64BitIntegerFor(totalBytesInSegments());
		}
		if (arg == 2) {
			result = ((((GIV(freeStart) - (((eden()).start))) + (GIV(pastSpaceStart) - (((pastSpace()).start)))) << 3) | 1);
		}
		if (arg == 3) {
			result = positive64BitIntegerFor((newSpaceCapacity()) + (totalBytesInSegments()));
		}
		if (arg == 4) {

			/* was allocationCount */
			result = GIV(nilObj);
		}
		if (arg == 5) {

			/* was allocationsBetweenGCs */
			result = GIV(nilObj);
		}
		if (arg == 6) {
			result = (((((sqInt)(((scavengerTenuringThreshold()) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);
		}
		if (arg == 7) {
			result = ((GIV(statFullGCs) << 3) | 1);
		}
		if (arg == 8) {
			result = ((((GIV(statFullGCUsecs) + 500) / 1000) << 3) | 1);
		}
		if (arg == 9) {
			result = (((GIV(statScavenges)) << 3) | 1);
		}
		if (arg == 10) {
			result = (((((GIV(statScavengeGCUsecs)) + 500) / 1000) << 3) | 1);
		}
		if (arg == 11) {
			result = ((GIV(statTenures) << 3) | 1);
		}
		if (((arg >= 12) && (arg <= 19))) {
			result = ConstZero;
		}
		if (arg == 20) {
			result = positive64BitIntegerFor(ioUTCStartMicroseconds());
		}
		if (arg == 21) {
			result = (((rootTableCount()) << 3) | 1);
		}
		if (arg == 22) {
			result = ((GIV(statRootTableOverflows) << 3) | 1);
		}
		if (arg == 23) {
			result = ((extraVMMemory << 3) | 1);
		}
		if (arg == 24) {
			result = ((GIV(shrinkThreshold) << 3) | 1);
		}
		if (arg == 25) {
			result = ((GIV(growHeadroom) << 3) | 1);
		}
		if (arg == 26) {
			result = (((ioHeartbeatMilliseconds()) << 3) | 1);
		}
		if (arg == 27) {
			result = ((GIV(statMarkCount) << 3) | 1);
		}
		if (arg == 28) {
			result = (((sqInt)0 << 3) | 1);
		}
		if (arg == 29) {
			result = (((sqInt)0 << 3) | 1);
		}
		if (arg == 30) {
			result = ((GIV(statCompactPassCount) << 3) | 1);
		}
		if (arg == 0x1F) {
			result = ((GIV(statGrowMemory) << 3) | 1);
		}
		if (arg == 32) {
			result = ((GIV(statShrinkMemory) << 3) | 1);
		}
		if (arg == 33) {
			result = ((GIV(statRootTableCount) << 3) | 1);
		}
		if (arg == 34) {

			/* was statAllocationCount */
			result = GIV(nilObj);
		}
		if (arg == 35) {
			result = ((GIV(statSurvivorCount) << 3) | 1);
		}
		if (arg == 36) {
			result = ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 3) | 1);
		}
		if (arg == 37) {
			result = (((sqInt)0 << 3) | 1);
		}
		if (arg == 38) {
			result = ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 3) | 1);
		}
		if (arg == 39) {
			result = ((GIV(statPendingFinalizationSignals) << 3) | 1);
		}
		if (arg == 40) {
			result = ((BytesPerWord << 3) | 1);
		}
		if (arg == 41) {
			result = (((imageFormatVersion()) << 3) | 1);
		}
		if (arg == 42) {
			result = ((GIV(numStackPages) << 3) | 1);
		}
		if (arg == 43) {
			result = ((desiredNumStackPages << 3) | 1);
		}
		if (arg == 44) {
			result = (((((GIV(eden).limit)) - ((GIV(eden).start))) << 3) | 1);
		}
		if (arg == 45) {
			result = ((desiredEdenBytes << 3) | 1);
		}
		if (arg == 46) {
			result = GIV(nilObj);
		}
		if (arg == 47) {
			result = GIV(nilObj);
		}
		if (arg == 48) {
			result = ((((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | (4 + 16)) - (4 + 16)))) << 3) | 1);
		}
		if (arg == 49) {
			result = (((ioGetMaxExtSemTableSize()) << 3) | 1);
		}
		if (arg == 52) {
			result = (((rootTableCapacity()) << 3) | 1);
		}
		if ((arg == 53)
		 && (1)) {
			result = (((numSegments()) << 3) | 1);
		}
		if ((arg == 54)
		 && (1)) {
			result = ((GIV(totalFreeOldSpace) << 3) | 1);
		}
		if ((arg == 55)
		 && (1)) {
			result = floatObjectOf(getHeapGrowthToSizeGCRatio());
		}
		if (arg == 56) {
			result = positive64BitIntegerFor(GIV(statProcessSwitch));
		}
		if (arg == 57) {
			result = positive64BitIntegerFor(GIV(statIOProcessEvents));
		}
		if (arg == 58) {
			result = positive64BitIntegerFor(GIV(statForceInterruptCheck));
		}
		if (arg == 59) {
			result = positive64BitIntegerFor(GIV(statCheckForEvents));
		}
		if (arg == 60) {
			result = positive64BitIntegerFor(GIV(statStackOverflow));
		}
		if (arg == 61) {
			result = positive64BitIntegerFor(GIV(statStackPageDivorce));
		}
		if (arg == 0x3E) {
			result = GIV(nilObj);
		}
		if (arg == 0x3F) {
			result = GIV(nilObj);
		}
		if (arg == 64) {
			result = ConstZero;
		}
		if (arg == 65) {
			result = GIV(trueObj);
		}
		if (arg == 66) {
			result = (((stackPageByteSize()) << 3) | 1);
		}
		if ((arg == 67)
		 && (1)) {
			result = (((maxOldSpaceSize()) << 3) | 1);
		}
		if (arg == 68) {
			result = floatObjectOf(statAverageLivePagesWhenMapping());
		}
		if (arg == 69) {
			result = (((statMaxPageCountWhenMapping()) << 3) | 1);
		}
		if (arg == 70) {
			result = (((VM_PROXY_MAJOR) << 3) | 1);
		}
		if (arg == 71) {
			result = (((VM_PROXY_MINOR) << 3) | 1);
		}
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	if (!(GIV(argumentCount) == 2)) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	index = (index >> 3);
	if ((index < 1)
	 || (index > paramsArraySize)) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((((arg) & 7) == 1)) {
		arg = (arg >> 3);
	}
	else {
		if (!((index == 55)
			 && ((((tagBits = arg & (tagMask()))) != 0
				? tagBits == (smallFloatTag())
				: ((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex)))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	if (index == 5) {

		/* Was:
		   result := allocationsBetweenGCs.
		   allocationsBetweenGCs := arg. */
		/* Ignore for now, because old images won't start up otherwise.
		   See 44 & 45 for eden size setting. */
		result = GIV(nilObj);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 6) {
		result = (((((sqInt)(((scavengerTenuringThreshold()) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);
		/* begin tenuringThreshold: */
		aProportion = (((double) (arg * (8 * BytesPerOop)) )) / (((double) (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) ));
		GIV(tenuringProportion) = aProportion;
		GIV(tenureThreshold) = (aProportion == 0.0
			? 0
			: (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - aProportion)))) + ((GIV(pastSpace).start)));
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 23) {
		result = ((extraVMMemory << 3) | 1);
		extraVMMemory = arg;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 24) {
		result = ((GIV(shrinkThreshold) << 3) | 1);
		if (arg > 0) {
			/* begin shrinkThreshold: */
			GIV(shrinkThreshold) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 25) {
		result = ((GIV(growHeadroom) << 3) | 1);
		if (arg > 0) {
			GIV(growHeadroom) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 26) {
		if (arg >= 0) {

			/* 0 turns off the heartbeat */
			result = (((ioHeartbeatMilliseconds()) << 3) | 1);
			ioSetHeartbeatMilliseconds(arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 43) {
		if ((arg >= 0)
		 && (arg <= 0xFFFF)) {
			result = ((desiredNumStackPages << 3) | 1);
			desiredNumStackPages = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 45) {
		if (arg >= 0) {
			result = ((desiredEdenBytes << 3) | 1);
			desiredEdenBytes = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 48) {
		if (arg >= 0) {
			result = (((((((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | (4 + 16)) - (4 + 16)))) << 3) | 1)) << 3) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setCogVMFlags: */
			if ((((usqInt)arg)) > 0x1F) {
				GIV(primFailCode) = PrimErrUnsupported;
				goto l1;
			}
			GIV(preemptionYields) = (arg & 4) == 0;
			GIV(newFinalization) = (arg & 16) != 0;
		l1:	/* end setCogVMFlags: */;
		}
	}
	if (index == 49) {
		if ((arg >= 0)
		 && (arg <= 0xFFFF)) {
			result = (((ioGetMaxExtSemTableSize()) << 3) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setMaxExtSemSizeTo: */
			GIV(maxExtSemTabSizeSet) = 1;
			ioSetMaxExtSemTableSize(arg);
		}
	}
	if ((index == 55)
	 && (1)) {
		result = floatObjectOf(getHeapGrowthToSizeGCRatio());
		/* begin setHeapGrowthToSizeGCRatio: */
		aDouble = floatValueOf(arg);
		GIV(heapGrowthToSizeGCRatio) = aDouble;
		GIV(primFailCode) = 0;
	}
	if ((index == 67)
	 && ((arg >= 0)
	 && (1))) {
		result = (((maxOldSpaceSize()) << 3) | 1);
		/* begin setMaxOldSpaceSize: */
		maxOldSpaceSize = arg;
		GIV(primFailCode) = 0;
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp2;
		return;
	}
	GIV(primFailCode) = PrimErrInappropriate;
}


/*	Potentially crash the VM by voiding the receiver. A subsequent inst var
	access in the caller's frame should indirect through a null pointer. */

	/* StackInterpreterPrimitives>>#primitiveVoidReceiver */
EXPORT(void)
primitiveVoidReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	longAtPointerput(GIV(framePointer) + FoxReceiver, 0);
}


/*	Void all internal VM state in the stack and machine code zones */

	/* StackInterpreterPrimitives>>#primitiveVoidVMState */
static void
primitiveVoidVMState(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(0);
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}


/*	Prune the stack to contain only the path, removing stacked indices
	and mapping frame pointers to contexts The issue here is that a
	GC can occur during ensureFrameIsMarried:SP:, but frame pointers
	are not valid objects. So first prune back to objects and framePointers
	as integers, and then replace frame pointers as integers by contexts. */

	/* StackInterpreterPrimitives>>#pruneStack:stackp: */
static void NoDbgRegParms
pruneStackstackp(sqInt stack, sqInt stackp)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt finger;
    char *fp;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt objOrFP;
    sqInt oop;
    sqInt oop1;
    char *theFP;
    char *theFPAbove;
    StackPage *thePage;
    char *theSP;
    sqInt theStack;

	finger = 1;
	for (i = 2; i < stackp; i += 2) {
		objOrFP = longAt((stack + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if ((((((usqInt)(((char *) objOrFP)))) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)(((char *) objOrFP)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) objOrFP)))) <= (((usqInt)GIV(pages))))))) {
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(((char *) objOrFP))) & (BytesPerWord - 1)) == 0);
			objOrFP = (oopForPointer(((char *) objOrFP))) + 1;
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(stack)));
		longAtput((stack + BaseHeaderSize) + (((long)finger) << (shiftForWord())), objOrFP);
		finger += 1;
	}
	for (i = finger, iLimiT = ((lengthOfformat(stack, (((usqInt) (longAt(stack))) >> (formatShift())) & (formatMask()))) - 1); i <= iLimiT; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(stack)));
		longAtput((stack + BaseHeaderSize) + (((long)i) << (shiftForWord())), GIV(nilObj));
	}
	/* begin pushRemappableOop: */
	oop = (theStack = stack);
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	for (i = 1; i < finger; i += 1) {
		objOrFP = longAt((theStack + BaseHeaderSize) + (((long)i) << (shiftForWord())));
		if ((((objOrFP) & 7) == 1)) {
			/* begin withoutSmallIntegerTags: */
			assert((((objOrFP) & 7) == 1));
			theFP = pointerForOop(objOrFP - 1);
			/* begin stackPageFor: */
			index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
			thePage = stackPageAtpages(index, GIV(pages));
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == theFP) {
				theFPAbove = 0;
				goto l1;
			}
			while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
				if (callerFP == theFP) {
					theFPAbove = fp;
					goto l1;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			theFPAbove = 0;
		l1:	/* end findFrameAbove:inPage: */;
			/* begin ensureFrameIsMarried:SP: */
			assert(!(isBaseFrame(theFPAbove)));
			theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + (((long)(byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))) + BytesPerWord;
			if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
				assert(isContext(frameContext(theFP)));
				objOrFP = longAt(theFP + FoxThisContext);
				goto l2;
			}
			objOrFP = marryFrameSP(theFP, theSP);
		l2:	/* end ensureFrameIsMarried:SP: */;
			theStack = GIV(remapBuffer)[GIV(remapBufferCount)];
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(theStack)));
			if (isOldObject(theStack)) {

				/* most stores into young objects */
				if (((objOrFP & (tagMask())) == 0)
				 && (oopisLessThan(objOrFP, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(theStack))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(theStack);
					}
				}
			}
			longAtput((theStack + BaseHeaderSize) + (((long)finger) << (shiftForWord())), objOrFP);
		}
	}
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
}

	/* StackInterpreterPrimitives>>#unmarkAfterPathTo */
static void
unmarkAfterPathTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWordAddress;
    sqInt followingWordAddress1;
    sqInt followingWordAddress2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt slotBytes;
    sqInt slotBytes1;
    sqInt slotBytes2;

	unmarkAllFrames();
	/* begin unmarkAllObjects */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((((usqInt) (longAt(objOop))) >> 55) & 1) != 0) {
			if (((longAt(objOop)) & (classIndexMask())) > 0x1F) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop)));
				longAtput(objOop, (longAt(objOop)) & (~(1LL << 55)));
			}
			else {
				if (!(((longAt(objOop)) & (classIndexMask())) == 3)) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop)));
					longAtput(objOop, (longAt(objOop)) & (~(1LL << 55)));
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		numSlots11 = byteAt(objOop + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop - BaseHeaderSize))) << 8)))) >> 8
			: numSlots11);
		if (numSlots2 == 0) {
			slotBytes = 8;
		}
		else {
			slotBytes = ((long)numSlots2) << (shiftForWord());
		}
		followingWordAddress = (objOop + BaseHeaderSize) + slotBytes;
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt) followingWord) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			if (((longAt(objOop1)) & (classIndexMask())) > 0x1F) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop1)));
				longAtput(objOop1, (longAt(objOop1)) & (~(1LL << 55)));
			}
			else {
				if (!(((longAt(objOop1)) & (classIndexMask())) == 3)) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop1)));
					longAtput(objOop1, (longAt(objOop1)) & (~(1LL << 55)));
				}
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots12 = byteAt(objOop1 + 7);
		numSlots3 = (numSlots12 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots12);
		if (numSlots3 == 0) {
			slotBytes1 = 8;
		}
		else {
			slotBytes1 = ((long)numSlots3) << (shiftForWord());
		}
		followingWordAddress2 = (objOop1 + BaseHeaderSize) + slotBytes1;
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			objOop1 = limit;
			goto l3;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt) followingWord2) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l3:	/* end objectAfter:limit: */;
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((((usqInt) (longAt(objOop1))) >> 55) & 1) != 0) {
			if (((longAt(objOop1)) & (classIndexMask())) > 0x1F) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop1)));
				longAtput(objOop1, (longAt(objOop1)) & (~(1LL << 55)));
			}
			else {
				if (!(((longAt(objOop1)) & (classIndexMask())) == 3)) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop1)));
					longAtput(objOop1, (longAt(objOop1)) & (~(1LL << 55)));
				}
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		numSlots13 = byteAt(objOop1 + 7);
		numSlots4 = (numSlots13 == (numSlotsMask())
			? ((usqInt) (((unsigned long)(((long)(longAt(objOop1 - BaseHeaderSize))) << 8)))) >> 8
			: numSlots13);
		if (numSlots4 == 0) {
			slotBytes2 = 8;
		}
		else {
			slotBytes2 = ((long)numSlots4) << (shiftForWord());
		}
		followingWordAddress1 = (objOop1 + BaseHeaderSize) + slotBytes2;
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt) followingWord1) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	}

	/* StackInterpreterPrimitives>>#unmarkAllFrames */
static void
unmarkAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    sqInt i;
    char *theFP;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			theFP = (thePage->headFP);
			do {
				flags = longAt(theFP + FoxFrameFlags);
				if ((flags & 2) != 0) {
					longAtput(theFP + FoxFrameFlags, flags - 2);
				}
			} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
		}
	}
}


void* vm_exports[][3] = {
	{"", "callbackEnter", (void*)callbackEnter},
	{"", "callbackLeave", (void*)callbackLeave},
	{"", "moduleUnloaded", (void*)moduleUnloaded},
	{"", "primitiveAddLargeIntegers\000\377", (void*)primitiveAddLargeIntegers},
	{"", "primitiveAllInstances\000\377", (void*)primitiveAllInstances},
	{"", "primitiveAllObjects\000\377", (void*)primitiveAllObjects},
	{"", "primitiveBitAndLargeIntegers\000\377", (void*)primitiveBitAndLargeIntegers},
	{"", "primitiveBitOrLargeIntegers\000\377", (void*)primitiveBitOrLargeIntegers},
	{"", "primitiveBitShiftLargeIntegers\000\377", (void*)primitiveBitShiftLargeIntegers},
	{"", "primitiveBitXorLargeIntegers\000\377", (void*)primitiveBitXorLargeIntegers},
	{"", "primitiveClockLogAddresses\000\377", (void*)primitiveClockLogAddresses},
	{"", "primitiveCompareBytes\000\377", (void*)primitiveCompareBytes},
	{"", "primitiveCrashVM\000\377", (void*)primitiveCrashVM},
	{"", "primitiveDisablePowerManager\000\377", (void*)primitiveDisablePowerManager},
	{"", "primitiveDivideLargeIntegers\000\377", (void*)primitiveDivideLargeIntegers},
	{"", "primitiveDivLargeIntegers\000\377", (void*)primitiveDivLargeIntegers},
	{"", "primitiveEqualLargeIntegers\000\377", (void*)primitiveEqualLargeIntegers},
	{"", "primitiveEventProcessingControl\000\377", (void*)primitiveEventProcessingControl},
	{"", "primitiveGetLogDirectory\000\377", (void*)primitiveGetLogDirectory},
	{"", "primitiveGetWindowLabel\000\377", (void*)primitiveGetWindowLabel},
	{"", "primitiveGetWindowSize\000\377", (void*)primitiveGetWindowSize},
	{"", "primitiveGreaterOrEqualLargeIntegers\000\377", (void*)primitiveGreaterOrEqualLargeIntegers},
	{"", "primitiveGreaterThanLargeIntegers\000\377", (void*)primitiveGreaterThanLargeIntegers},
	{"", "primitiveHeartbeatFrequency\000\377", (void*)primitiveHeartbeatFrequency},
	{"", "primitiveHighResClock\000\377", (void*)primitiveHighResClock},
	{"", "primitiveImageFormatVersion\000\377", (void*)primitiveImageFormatVersion},
	{"", "primitiveInterruptChecksPerMSec\000\377", (void*)primitiveInterruptChecksPerMSec},
	{"", "primitiveIsBigEnder\000\377", (void*)primitiveIsBigEnder},
	{"", "primitiveIsWindowObscured\000\377", (void*)primitiveIsWindowObscured},
	{"", "primitiveLessOrEqualLargeIntegers\000\377", (void*)primitiveLessOrEqualLargeIntegers},
	{"", "primitiveLessThanLargeIntegers\000\377", (void*)primitiveLessThanLargeIntegers},
	{"", "primitiveLongRunningPrimitive\000\377", (void*)primitiveLongRunningPrimitive},
	{"", "primitiveLongRunningPrimitiveSemaphore\000\377", (void*)primitiveLongRunningPrimitiveSemaphore},
	{"", "primitiveMillisecondClockMask\000\377", (void*)primitiveMillisecondClockMask},
	{"", "primitiveModLargeIntegers\000\377", (void*)primitiveModLargeIntegers},
	{"", "primitiveMultiplyLargeIntegers\000\377", (void*)primitiveMultiplyLargeIntegers},
	{"", "primitiveNotEqualLargeIntegers\000\377", (void*)primitiveNotEqualLargeIntegers},
	{"", "primitiveOriginalMillisecondClock\000\377", (void*)primitiveOriginalMillisecondClock},
	{"", "primitivePathToUsing\000\377", (void*)primitivePathToUsing},
	{"", "primitiveProfilePrimitive\000\377", (void*)primitiveProfilePrimitive},
	{"", "primitiveProfileSample\000\377", (void*)primitiveProfileSample},
	{"", "primitiveProfileSemaphore\000\377", (void*)primitiveProfileSemaphore},
	{"", "primitiveProfileStart\000\377", (void*)primitiveProfileStart},
	{"", "primitiveQuoLargeIntegers\000\377", (void*)primitiveQuoLargeIntegers},
	{"", "primitiveRemLargeIntegers\000\377", (void*)primitiveRemLargeIntegers},
	{"", "primitiveScreenDepth\000\377", (void*)primitiveScreenDepth},
	{"", "primitiveSetGCSemaphore\000\377", (void*)primitiveSetGCSemaphore},
	{"", "primitiveSetLogDirectory\000\377", (void*)primitiveSetLogDirectory},
	{"", "primitiveSetWindowLabel\000\377", (void*)primitiveSetWindowLabel},
	{"", "primitiveSetWindowSize\000\377", (void*)primitiveSetWindowSize},
	{"", "primitiveSubtractLargeIntegers\000\377", (void*)primitiveSubtractLargeIntegers},
	{"", "primitiveUtcWithOffset\000\377", (void*)primitiveUtcWithOffset},
	{"", "primitiveVoidReceiver\000\377", (void*)primitiveVoidReceiver},
	{"", "printFramesInPage", (void*)printFramesInPage},
	{"", "printFramesOnStackPageListInUse\000\377", (void*)printFramesOnStackPageListInUse},
	{"", "reestablishContextPriorToCallback", (void*)reestablishContextPriorToCallback},
	{"", "returnAsThroughCallbackContext", (void*)returnAsThroughCallbackContext},
	{"", "segmentContainingObj", (void*)segmentContainingObj},
	{"", "sendInvokeCallbackContext", (void*)sendInvokeCallbackContext},
	{"", "sendInvokeCallbackStackRegistersJmpbuf", (void*)sendInvokeCallbackStackRegistersJmpbuf},
	{"", "setInterruptCheckChain", (void*)setInterruptCheckChain},
	{"", "shortPrintFramesInPage", (void*)shortPrintFramesInPage},
	{"", "shortPrintFramesOnStackPageListInUse\000\377", (void*)shortPrintFramesOnStackPageListInUse},
	{NULL, NULL, NULL}
};

void initGlobalStructure(void) {
#if SQ_USE_GLOBAL_STRUCT_REG
foo = &fum;
#endif
}
