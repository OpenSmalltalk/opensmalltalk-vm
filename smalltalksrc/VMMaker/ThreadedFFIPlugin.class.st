"
This plugin provides access to foreign function interfaces on those platforms that provide such. For example Windows DLLs and unix .so's.  This version is designed to support reentrancy and threading, and so uses alloca to stack allocate all memory needed for a given callout.  Specific platforms are implemented by concrete subclasses.  Threaded calls can only be provided within the context of the threaded VM; othewise calls must be blocking.  So code specific to threading is guarded with a
	self cppIf: COGMTVM
		ifTrue: [...]
form to arrange that it is only compiled in the threaded VM context.
"
Class {
	#name : #ThreadedFFIPlugin,
	#superclass : #InterpreterPlugin,
	#instVars : [
		'ffiLogEnabled',
		'externalFunctionInstSize',
		'ffiLastError'
	],
	#classVars : [
		'DefaultMaxStackSize',
		'ExternalFunctionAddressIndex',
		'ExternalFunctionArgTypesIndex',
		'ExternalFunctionFlagsIndex',
		'ExternalFunctionStackSizeIndex',
		'MaxNumArgs'
	],
	#pools : [
		'FFIConstants'
	],
	#category : #'VMMaker-Plugins-FFI'
}

{ #category : #translation }
ThreadedFFIPlugin class >> ancilliaryClasses: options [
	^{ self calloutStateClass }
]

{ #category : #translation }
ThreadedFFIPlugin class >> calloutStateClass [
	^ThreadedFFICalloutState
]

{ #category : #translation }
ThreadedFFIPlugin class >> declareCVarsIn: cg [
	super declareCVarsIn: cg.
	cg removeConstant: #COGMTVM "this should be defined at compile time"
]

{ #category : #translation }
ThreadedFFIPlugin class >> excludingPredefinedMacros [
	"Answer the predefined macros that disqualify the platforms a subclass handles, if any.
	 These are anded together and with includingPredefinedMacros, whereas
	 identifyingPredefinedMacros are ored together.
	 This can be used to differentiate e.g. x64 Sys V from x64 Win64."
	^nil
]

{ #category : #translation }
ThreadedFFIPlugin class >> generateCodeStringForPrimitives [
	"Output a skeletal SqueakFFIPrims.c that includes the relevant FooFFIPlugin.c for
	 each subclass based on the identifyingPredefinedMacros the subclass defines."
	 
	^String streamContents:
		[:s|
		 s nextPutAll: '/* Automatically generated by\	' withCRs.
		 s nextPutAll: (CCodeGenerator monticelloDescriptionFor: self).
		 s cr; nextPutAll: ' */'.
		 s cr; cr; nextPut: $#.
		 (self allSubclasses sort: [:a :b| a name < b name]) do:
			[:class |
			class identifyingPredefinedMacros ifNotNil:
				[:predefinedMacros|
				 s nextPutAll: 'if '.
				class includingPredefinedMacros ifNotNil:
					[:includingMacros|
					 includingMacros do:
						[:predefinedMacro| s nextPutAll: 'defined('; nextPutAll: predefinedMacro; nextPutAll: ') && '].
					 s nextPut: $(].
				class excludingPredefinedMacros ifNotNil:
					[:excludingMacros|
					 excludingMacros do:
						[:predefinedMacro| s nextPutAll: '!defined('; nextPutAll: predefinedMacro; nextPutAll: ') && '].
					 s nextPut: $(].
				 predefinedMacros
					do: [:predefinedMacro| s nextPutAll: 'defined('; nextPutAll: predefinedMacro; nextPut: $)]
					separatedBy: [s nextPutAll: ' || '].
				class excludingPredefinedMacros ifNotNil:
					[s nextPut: $)].
				class includingPredefinedMacros ifNotNil:
					[s nextPut: $)].
				 s cr; cr; nextPutAll: '#	include "'; nextPutAll: class moduleName; nextPutAll: '.c"'.
				 s cr; cr; nextPutAll: '#el']].
		 s nextPutAll: 'se'.
		 #(	'As yet no FFI implementation appears to exist for your platform.'
			'Consider implementing it, starting by adding a subclass of ThreadedFFIPlugin.') do:
			[:msg| s cr; nextPutAll: '#	error '; nextPutAll: msg].
		 s cr; nextPutAll: '#endif'; cr]
]

{ #category : #translation }
ThreadedFFIPlugin class >> identifyingPredefinedMacros [
	"Answer the predefined macros that identify the platforms a subclass handles, if any.
	 These are ored together.
	 If the subclass isn't yet ready for production (a work in progress) simply answer nil."
	^nil
]

{ #category : #translation }
ThreadedFFIPlugin class >> includingPredefinedMacros [
	"Answer the predefined macros that qualify the platforms a subclass handles, if any.
	 These are anded together and with excludingPredefinedMacros, whereas
	 identifyingPredefinedMacros are ored together.
	 This can be used to differentiate e.g. x64 Sys V from x64 Win64."
	^nil
]

{ #category : #'class initialization' }
ThreadedFFIPlugin class >> initialize [
	"c.f. ExternalFunction allInstVarNames
		old: #('handle' 'flags' 'argTypes')
		new: #('handle' 'flags' 'argTypes' 'stackSize')"
	ExternalFunctionAddressIndex := 0.
	ExternalFunctionFlagsIndex := 1.
	ExternalFunctionArgTypesIndex := 2.
	ExternalFunctionStackSizeIndex := 3.

	"c.f. e.g. CoInterpreter class initializeMiscConstants"
	MaxNumArgs := 15.

	DefaultMaxStackSize := 1024 * 16
]

{ #category : #accessing }
ThreadedFFIPlugin class >> maxNumArgs [
	^MaxNumArgs
]

{ #category : #translation }
ThreadedFFIPlugin class >> moduleName [
	"IMPORTANT: IF YOU CHANGE THE NAME OF THIS PLUGIN YOU MUST CHANGE
		Interpreter>>primitiveCalloutToFFI *and* ThreadedFFIPlugin>>getModuleName
	TO REFLECT THE CHANGE."
	^#('SqueakFFIPrims' 'FFIPlugin') first
]

{ #category : #translation }
ThreadedFFIPlugin class >> preambleCCode [
	"For a source of builtin defines grep for builtin_define in a gcc release config directory."
	^'
#include "sqAssert.h" /* for assert */

#ifdef _MSC_VER
# define alloca _alloca
#endif
#if defined(__GNUC__) && (defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__))
# define setsp(sp) asm volatile ("movl %0,%%esp" : : "m"(sp))
# define getsp() ({ void *esp; asm volatile ("movl %%esp,%0" : "=r"(esp) : ); esp;})
# elif defined(__GNUC__) && (defined(__arm__))
# define setsp(sp) asm volatile ("ldr %%sp, %0" : : "m"(sp))
# define getsp() ({ void *sp; asm volatile ("mov %0, %%sp" : "=r"(sp) : ); sp;})
#endif
#if !defined(getsp)
# define getsp() 0
#endif 
#if !defined(setsp)
# define setsp(ignored) 0
#endif 

#if !defined(STACK_ALIGN_BYTES)
# if __APPLE__ && __MACH__ && __i386__
#  define STACK_ALIGN_BYTES 16
# elif __linux__ && __i386__
#  define STACK_ALIGN_BYTES 16
# elif defined(__amd64__) || defined(__x86_64__) ||  defined(__amd64) || defined(__x86_64)
#  define STACK_ALIGN_BYTES 16
# elif defined(powerpc) || defined(__powerpc__) || defined(_POWER) || defined(__POWERPC__) || defined(__PPC__)
#  define STACK_ALIGN_BYTES 16
# elif defined(__sparc64__) || defined(__sparcv9__) || defined(__sparc_v9__) /* must precede 32-bit sparc defs */
#  define STACK_ALIGN_BYTES 16
# elif defined(sparc) || defined(__sparc__) || defined(__sparclite__)
#  define STACK_ALIGN_BYTES 8
# elif defined(__arm__) 
#  define STACK_ALIGN_BYTES 8
# else
#  define STACK_ALIGN_BYTES 0
# endif
#endif /* !defined(STACK_ALIGN_BYTES) */

#if !defined(STACK_OFFSET_BYTES)
# define STACK_OFFSET_BYTES 0
#endif

#if defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__)
/* Both Mac OS X x86 and Win32 x86 return structs of a power of two in size
 * less than or equal to eight bytes in length in registers. Linux never does so.
 */
# if __linux__
#	define WIN32_X86_STRUCT_RETURN 0
# else
#	define WIN32_X86_STRUCT_RETURN 1
# endif
# if WIN32
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 1
# endif
#endif /* defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__) */

#if !defined(ALLOCA_LIES_SO_USE_GETSP)
# if defined(__MINGW32__) && (__GNUC__ >= 3)
    /*
     * cygwin -mno-cygwin (MinGW) gcc 3.4.x''s alloca is a library routine that answers
     * %esp + 4, so the outgoing stack is offset by one word if uncorrected.
     * Grab the actual stack pointer to correct.
     */
#	define ALLOCA_LIES_SO_USE_GETSP 1
# else
#	define ALLOCA_LIES_SO_USE_GETSP 0
# endif
#endif /* !defined(ALLOCA_LIES_SO_USE_GETSP) */

#if !defined(PLATFORM_API_USES_CALLEE_POPS_CONVENTION)
# define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 0
#endif

/* The dispatchOn:in:with:with: generates an unwanted call on error.  Just squash it. */
#define error(foo) 0
#ifndef SQUEAK_BUILTIN_PLUGIN
/* but print assert failures. */
void
warning(char *s) { /* Print an error message but don''t exit. */
	printf("\n%s\n", s);
}
#endif

/* sanitize */
#ifdef SQUEAK_BUILTIN_PLUGIN
# define EXTERN 
#else
# define EXTERN extern
#endif
int ffiLogCallOfLength(void *, int);               			/* sqFFIPlugin.c */
int ffiLogFileNameOfLength(void *, int);             		/* sqFFIPlugin.c */
EXTERN void initSurfacePluginFunctionPointers();				/* sqManualSurface.c */
EXTERN int createManualSurface(int, int, int, int, int); 	/* sqManualSurface.c */
EXTERN int destroyManualSurface(int);							/* sqManualSurface.c */
EXTERN int setManualSurfacePointer(int, void*);				/* sqManualSurface.c */
'
]

{ #category : #translation }
ThreadedFFIPlugin class >> translateInDirectory: directory doInlining: inlineFlag [
	"As a hack to allow ThreadedFFIPlugin to generate a skeletal SqueakFFIPrims.c that
	 simply includes the fleshed-out SqueakIA32FFIPrims.c, SqueakARMFFIPrims.c et al,
	 intercept for ThreadedFFIPlugin and output generateCodeStringForPrimitives."
	| ffiPluginRootClass |
	ffiPluginRootClass := thisContext method methodClass soleInstance.
	^self == ffiPluginRootClass
		ifTrue:
			[self
				storeString: self generateCodeStringForPrimitives
				onFileNamed: (directory fullNameFor: self moduleName, '.c').
			#()]
		ifFalse:
			[super
				translateInDirectory: (directory containingDirectory directoryNamed: ffiPluginRootClass moduleName) assureExistence
				doInlining: inlineFlag]
]

{ #category : #marshalling }
ThreadedFFIPlugin >> allocaLiesSoUseGetsp [
	"At least one alloca implementation does not answer the actual top of stack.
	 If so we need to get the actual stack pointer.  Answer whether this is necessary."
	<cmacro: '() ALLOCA_LIES_SO_USE_GETSP'>
	^false
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> atomicTypeOf: typeSpec [
	^(typeSpec bitAnd: FFIAtomicTypeMask) >> FFIAtomicTypeShift
]

{ #category : #marshalling }
ThreadedFFIPlugin >> cStackAlignment [
	"Many ABIs mandate a particular stack alignment greater than the natural word size.
	 If so, this macro will answer that alignment.  If not, this macro will answer 0.  See
	 class-side preambleCCode."
	<cmacro: '() STACK_ALIGN_BYTES'>
	^0
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> cleanupCalloutState: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<returnTypeC: #void>
	"Free any temporary arg strings."
	<inline: true>
	[calloutState stringArgIndex > 0] whileTrue:
		[self free: (calloutState stringArgs at: (calloutState stringArgIndex: calloutState stringArgIndex - 1))]
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> dispatchFunctionPointer: aFunctionPointer [
	"In C aFunctionPointer is void (*aFunctionPointer)()"
	<cmacro: '(aFunctionPointer) (aFunctionPointer)()'>
	^self perform: aFunctionPointer
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> dispatchFunctionPointer: aFunctionPointer with: int1 with: int2 with: int3 with: int4 [
	"In C aFunctionPointer is void (*aFunctionPointer)(int, int, int, int)"
	<cmacro: '(aFunctionPointer, int1, int2, int3, int4) (aFunctionPointer)(int1, int2, int3, int4)'>
	^self 
		perform: aFunctionPointer
		with: int1
		with: int2
		with: int3
		with: int4
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> dispatchFunctionPointer: aFunctionPointer with: int1 with: int2 with: int3 with: int4 with: int5 with: int6 [
	"In C aFunctionPointer is void (*aFunctionPointer)(int, int, int, int)"
	<cmacro: '(aFunctionPointer,a1,a2, a3, a4,a5,a6) (aFunctionPointer)(a1,a2, a3, a4,a5,a6)'>
	^self 
		perform: aFunctionPointer
		with: int1
		with: int2
		with: int3
		with: int4
		with: int5
		with: int6
]

{ #category : #'symbol loading' }
ThreadedFFIPlugin >> externalFunctionHasStackSizeSlot [
	<inline: true>
	^externalFunctionInstSize > ExternalFunctionStackSizeIndex
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> ffiAddressOf: rcvr startingAt: byteOffset size: byteSize [
"return an int of the address of the byteSize slot (byte, short, int, whatever) at byteOffset in rcvr. Nominally intended for use with ExternalAddress objects, this code will work (for obscure historical reasons) with plain Byte or Word Arrays as well. "
	| rcvrClass rcvrSize addr |
	self flag: 'This needs more thought.  It is 32-bit specific.  What about 64-bit platforms?'.
	(interpreterProxy isBytes: rcvr) ifFalse:[^interpreterProxy primitiveFail].
	(byteOffset > 0) ifFalse:[^interpreterProxy primitiveFail].
	rcvrClass := interpreterProxy fetchClassOf: rcvr.
	rcvrSize := interpreterProxy byteSizeOf: rcvr.
	rcvrClass = interpreterProxy classExternalAddress ifTrue:[
		(rcvrSize = 4) ifFalse:[^interpreterProxy primitiveFail].
		addr := interpreterProxy fetchPointer: 0 ofObject: rcvr.
		"don't you dare to read from object memory (unless is pinned)!"
		(addr = 0" or: [(interpreterProxy isInMemory: addr) or: [(interpreterProxy isPinned: rcvr) not]]")
			ifTrue:[^interpreterProxy primitiveFail].
	] ifFalse:[
		(byteOffset+byteSize-1 <= rcvrSize)
			ifFalse:[^interpreterProxy primitiveFail].
		addr := self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'int'.
	].
	addr := addr + byteOffset - 1.
	^addr
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> ffiAlloc: bytes [
	"Default to malloc/free.  If a platform needs a different allocator define
	 something in the preamble and redefine this to take account of that."
	<cmacro: '(bytes) (usqInt)malloc(bytes)'>
	^ByteArray new: bytes
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiArgByValue: oop in: calloutState [
	"Support for generic callout. Prepare an argument by value for a callout."
	<var: #calloutState type: #'CalloutState *'>
	| atomicType intValue floatValue |
	<inline: true>
	<var: #floatValue type: #double>
	atomicType := self atomicTypeOf: calloutState ffiArgHeader.
	"check if the range is valid"
	(atomicType < 0 or:[atomicType > FFITypeDoubleFloat])
		ifTrue:[^FFIErrorBadAtomicType].
	atomicType < FFITypeSingleFloat ifTrue:["integer types"
		(atomicType >> 1) = (FFITypeSignedLongLong >> 1)
			ifTrue:[intValue := oop] "ffi support code must coerce longlong"
			ifFalse:[intValue := self ffiIntegerValueOf: oop]. "does all the coercions"
		interpreterProxy failed ifTrue:[^FFIErrorCoercionFailed].
		^self dispatchOn: atomicType
			in: #(
				ffiPushVoid:in:
				ffiPushUnsignedInt:in:
				ffiPushUnsignedByte:in:
				ffiPushSignedByte:in:
				ffiPushUnsignedShort:in:
				ffiPushSignedShort:in:
				ffiPushUnsignedInt:in:
				ffiPushSignedInt:in:
				ffiPushUnsignedLongLongOop:in:
				ffiPushSignedLongLongOop:in:
				ffiPushUnsignedChar:in:
				ffiPushSignedChar:in:)
			with: intValue
			with: calloutState].
	"either float or double"
	floatValue := self ffiFloatValueOf: oop.
	interpreterProxy failed ifTrue:
		[^FFIErrorCoercionFailed].
	atomicType = FFITypeSingleFloat
		ifTrue: [^self ffiPushSingleFloat: floatValue in: calloutState]
		ifFalse:[^self ffiPushDoubleFloat: floatValue in: calloutState]
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiArgument: oop Spec: argSpec Class: argClass in: calloutState [
	"Callout support. Prepare the given oop as argument.
	argSpec defines the compiled spec for the argument.
	argClass (if non-nil) defines the required (super)class for the argument."
	<var: #calloutState type: #'CalloutState *'>
	| valueOop oopClass isStruct nilOop |
	<inline: false>
	oopClass := interpreterProxy fetchClassOf: oop. "Prefetch class (we'll need it)"
	nilOop :=  interpreterProxy nilObject.
	"Do the necessary type checks"
	argClass = nilOop ifFalse:[
		"Type check 1: 
		Is the required class of the argument a subclass of ExternalStructure?"
		(interpreterProxy includesBehavior: argClass 
						ThatOf: interpreterProxy classExternalStructure)
			ifFalse:[^FFIErrorWrongType]. "Nope. Fail."
		"Type check 2:
		Is the class of the argument a subclass of required class?"
		((nilOop = oop) or:[interpreterProxy includesBehavior: oopClass ThatOf: argClass])
				ifFalse:[^FFIErrorCoercionFailed]. "Nope. Fail."
		"Okay, we've passed the type check (so far)"
	].

	"Check if oopClass is a subclass of ExternalStructure.
	If this is the case we'll work on it's handle and not the actual oop."
	isStruct := false.
	((interpreterProxy isImmediate: oop) or:[oop = nilOop]) ifFalse:[
		"#isPointers: will fail if oop is immediate so don't even attempt to use it"
		(interpreterProxy isPointers: oop) 
			ifTrue:[isStruct := interpreterProxy includesBehavior: oopClass 
								ThatOf: interpreterProxy classExternalStructure.
					(argClass = nilOop or:[isStruct]) 
						ifFalse:[^FFIErrorCoercionFailed]].
		"note: the test for #isPointers: above should speed up execution since no pointer type ST objects are allowed in external calls and thus if #isPointers: is true then the arg must be ExternalStructure to work. If it isn't then the code fails anyways so speed isn't an issue"
	].

	"Determine valueOop (e.g., the actual oop to pass as argument)"
	isStruct
		ifTrue:[valueOop := interpreterProxy fetchPointer: 0 ofObject: oop]
		ifFalse:[valueOop := oop].

	"Fetch and check the contents of the compiled spec"
	(interpreterProxy isWords: argSpec)
		ifFalse:[^FFIErrorWrongType].
	calloutState ffiArgSpecSize: (interpreterProxy slotSizeOf: argSpec).
	calloutState ffiArgSpecSize = 0 ifTrue:[^FFIErrorWrongType].
	calloutState ffiArgSpec: (interpreterProxy firstIndexableField: argSpec).
	calloutState ffiArgHeader: (interpreterProxy longAt: calloutState ffiArgSpec).

	"Do the actual preparation of the argument"
	"Note: Order is important since FFIFlagStructure + FFIFlagPointer is used to represent 'typedef void* VoidPointer' and VoidPointer really is *struct* not pointer."

	(calloutState ffiArgHeader anyMask: FFIFlagStructure) ifTrue:[
		"argument must be ExternalStructure"
		isStruct ifFalse:[^FFIErrorCoercionFailed].
		(calloutState ffiArgHeader anyMask: FFIFlagAtomic) 
			ifTrue:[^FFIErrorWrongType]. "bad combination"
		^self ffiPushStructureContentsOf: valueOop in: calloutState].

	(calloutState ffiArgHeader anyMask: FFIFlagPointer) ifTrue:[
		"no integers (or characters) for pointers please"
		(interpreterProxy isImmediate: oop) 
			ifTrue:[^FFIErrorIntAsPointer].

		"but allow passing nil pointer for any pointer type"
		oop = nilOop ifTrue:[^self ffiPushPointer: nil in: calloutState].

		"argument is reference to either atomic or structure type"
		(calloutState ffiArgHeader anyMask: FFIFlagAtomic) ifTrue:[
			isStruct "e.g., ExternalData"
				ifTrue:[^self ffiAtomicStructByReference: oop Class: oopClass in: calloutState]
				ifFalse:[^self ffiAtomicArgByReference: oop Class: oopClass in: calloutState].
			"********* NOTE: The above uses 'oop' not 'valueOop' (for ExternalData) ******"
		].

		"Needs to be external structure here"
		isStruct ifFalse:[^FFIErrorCoercionFailed].
		^self ffiPushPointerContentsOf: valueOop in: calloutState].

	(calloutState ffiArgHeader anyMask: FFIFlagAtomic) ifTrue:[
		"argument is atomic value"
		^self ffiArgByValue: valueOop in: calloutState].
	"None of the above - bad spec"
	^FFIErrorWrongType
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiAtomicArgByReference: oop Class: oopClass in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	"Support for generic callout. Prepare a pointer reference to an atomic type for callout.
	 Note: 
		for type 'void*' we allow ByteArray/String/Symbol, wordVariableSubclass, Alien or ExternalAddress.
		for other types we allow ByteArray, wordVariableSubclass, Alien or ExternalAddress."
	| atomicType isString isAlien |
	<inline: true>
	atomicType := self atomicTypeOf: calloutState ffiArgHeader.
	(atomicType = FFITypeBool) ifTrue: "No bools on input"
		[^FFIErrorCoercionFailed].
	isAlien := (isString := interpreterProxy 
					includesBehavior: oopClass 
					ThatOf: interpreterProxy classString)
				ifTrue: [false]
				ifFalse:
					[interpreterProxy 
						includesBehavior: oopClass 
						ThatOf: interpreterProxy classAlien].
	((atomicType >> 1) = (FFITypeSignedChar >> 1)) ifTrue:"string value (char*)"
		"note: the only types allowed for passing into char* types are
		ByteArray, String, Symbol, Alien and *no* other byte indexed objects
		(e.g., CompiledMethod, LargeInteger). We only check for strings
		here and fall through to the byte* check otherwise."
		[isString ifTrue:"String/Symbol"
			"Strings must be allocated by the ffi support code"
			[^self ffiPushString: (interpreterProxy firstIndexableField: oop)
				OfLength: (interpreterProxy byteSizeOf: oop)
				in: calloutState].
		"Fall through to byte* test"
		atomicType := FFITypeUnsignedByte].

	self cppIf: COGMTVM ifTrue:
	["Since all the following pass the address of the first indexable field we need to fail
	 the call if it is threaded and the object is young, since it may move during the call."
	((calloutState callFlags anyMask: FFICallFlagThreaded)
	and: [(isAlien not or: [self isDirectAlien: oop])
	and: [interpreterProxy isYoung: oop]]) ifTrue:
		[^PrimErrObjectMayMove negated]].

	(atomicType = FFITypeVoid or:[(atomicType >> 1) = (FFITypeSignedByte >> 1)]) ifTrue:
		"byte* -- see comment on string above"
		[(isString or: [oopClass = interpreterProxy classByteArray]) ifTrue: "String/Symbol/ByteArray"
			[^self ffiPushPointer: (interpreterProxy firstIndexableField: oop) in: calloutState].
		(oopClass = interpreterProxy classExternalAddress) ifTrue: 
			[^self ffiPushPointer: (self longAt: oop + interpreterProxy baseHeaderSize) in: calloutState].
		isAlien ifTrue:
			[^self ffiPushPointer: (self pointerForOop: (self startOfData: oop)) in: calloutState].
		atomicType = FFITypeVoid ifFalse:
			[^FFIErrorCoercionFailed]].
		"note: type void falls through"

	"I can push pointers to any type (take for instance calls who receive int* output arguments, etc.)
	 but I need to store them into a ByteArray, ExternalAddress or Alien"
	(atomicType <= FFITypeDoubleFloat) ifTrue:
		[((interpreterProxy isWords: oop) or: [oopClass = interpreterProxy classByteArray]) ifTrue:
			[^self ffiPushPointer: (interpreterProxy firstIndexableField: oop) in: calloutState].
		(oopClass = interpreterProxy classExternalAddress) ifTrue: 
			[^self ffiPushPointer: (self longAt: oop + interpreterProxy baseHeaderSize) in: calloutState].
		isAlien ifTrue:
			[^self ffiPushPointer: (self pointerForOop: (self startOfData: oop)) in: calloutState]].

	^FFIErrorCoercionFailed
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiAtomicStructByReference: oop Class: oopClass in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	"Support for generic callout. Prepare an external pointer reference to an atomic type for callout."
	| atomicType err valueOop |
	<inline: true>
	"must be external data to pass pointers to atomic type"
	oopClass = interpreterProxy classExternalData 
		ifFalse:[^FFIErrorCoercionFailed].
	atomicType := self atomicTypeOf: calloutState ffiArgHeader.
	"no type checks for void pointers"
	atomicType ~= FFITypeVoid ifTrue:[
		err := self ffiValidateExternalData: oop AtomicType: atomicType.
		err ~= 0 ifTrue:[^err].
	].
	"and push pointer contents"
	valueOop := interpreterProxy fetchPointer: 0 ofObject: oop.
	^self ffiPushPointerContentsOf: valueOop in: calloutState
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiCall: externalFunction ArgArrayOrNil: argArrayOrNil NumArgs: nArgs [
	"Generic callout. Does the actual work.  If argArrayOrNil is nil it takes args from the stack
	 and the spec from the method.  If argArrayOrNil is not nil takes args from argArrayOrNil
	 and the spec from the receiver."
	| flags argTypeArray address argType oop argSpec argClass err theCalloutState calloutState requiredStackSize stackSize allocation result |
	<inline: true>
	<var: #theCalloutState type: #'CalloutState'>
	<var: #calloutState type: #'CalloutState *'>
	<var: #allocation type: #'char *'>

	(interpreterProxy is: externalFunction KindOfClass: interpreterProxy classExternalFunction) ifFalse:
		[^self ffiFail: FFIErrorNotFunction].
	"Load and check the values in the externalFunction before we call out"
	flags := interpreterProxy fetchInteger: ExternalFunctionFlagsIndex ofObject: externalFunction.
	interpreterProxy failed ifTrue:
		[^self ffiFail: FFIErrorBadArgs].

	"This must come early for compatibility with the old FFIPlugin.  Image-level code
	 may assume the function pointer is loaded eagerly.  Thanks to Nicolas Cellier."
	address := self ffiLoadCalloutAddress: externalFunction.
	interpreterProxy failed ifTrue:
		[^0 "error code already set by ffiLoadCalloutAddress:"].
	
	argTypeArray := interpreterProxy fetchPointer: ExternalFunctionArgTypesIndex ofObject: externalFunction.
	"must be array of arg types"
	((interpreterProxy isArray: argTypeArray)
	and: [(interpreterProxy slotSizeOf: argTypeArray) = (nArgs + 1)]) ifFalse:
		[^self ffiFail: FFIErrorBadArgs].
	"check if the calling convention is supported"
	self cppIf: COGMTVM
		ifTrue:
			[(self ffiSupportsCallingConvention: (flags bitAnd: FFICallTypesMask)) ifFalse:
				[^self ffiFail: FFIErrorCallType]]
		ifFalse: "not masking causes threaded calls to fail, which is as they should if the plugin is not threaded."
			[(self ffiSupportsCallingConvention: flags) ifFalse:
				[^self ffiFail: FFIErrorCallType]].
		
	requiredStackSize := self externalFunctionHasStackSizeSlot
							ifTrue: [interpreterProxy
										fetchInteger: ExternalFunctionStackSizeIndex
										ofObject: externalFunction]
							ifFalse: [-1].
	interpreterProxy failed ifTrue:
		[^interpreterProxy primitiveFailFor: (argArrayOrNil isNil
												ifTrue: [PrimErrBadMethod]
												ifFalse: [PrimErrBadReceiver])].
	stackSize := requiredStackSize < 0 ifTrue: [DefaultMaxStackSize] ifFalse: [requiredStackSize].
	self cCode: [] inSmalltalk: [theCalloutState := self class calloutStateClass new].
	calloutState := self addressOf: theCalloutState.
	self cCode: [self me: calloutState ms: 0 et: (self sizeof: #CalloutState)].
	calloutState callFlags: flags.
	"Fetch return type and args"
	argType := interpreterProxy fetchPointer: 0 ofObject: argTypeArray.
	argSpec := interpreterProxy fetchPointer: 0 ofObject: argType.
	argClass := interpreterProxy fetchPointer: 1 ofObject: argType.
	(err := self ffiCheckReturn: argSpec With: argClass in: calloutState) ~= 0 ifTrue:
		[^self ffiFail: err]. "cannot return"
	"alloca the outgoing stack frame, leaving room for register args while marshalling, and including space for the return struct, if any."
	allocation := self alloca: stackSize + calloutState structReturnSize + self registerArgsSlop + self cStackAlignment.
	self allocaLiesSoUseGetsp ifTrue:
		[allocation := self getsp].
	self cStackAlignment ~= 0 ifTrue:
		[allocation := self cCoerce: (allocation asUnsignedInteger bitClear: self cStackAlignment - 1)
						to: #'char *'].
	calloutState
		argVector: allocation;
		currentArg: allocation + self registerArgsSlop;
		limit: allocation + stackSize + self registerArgsSlop.
	(calloutState structReturnSize > 0
	 and: [self nonRegisterStructReturnIsViaImplicitFirstArgument
	 and: [(self returnStructInRegisters: calloutState structReturnSize) not]]) ifTrue:
		[err := self ffiPushPointer: calloutState limit in: calloutState.
		 err ~= 0 ifTrue:
			[self cleanupCalloutState: calloutState.
			 self cppIf: COGMTVM ifTrue:
			 [err = PrimErrObjectMayMove negated ifTrue:
				[^PrimErrObjectMayMove]]. "N.B. Do not fail if object may move because caller will GC and retry."
			 ^self ffiFail: err]].
	1 to: nArgs do:
		[:i|
		argType := interpreterProxy fetchPointer: i ofObject: argTypeArray.
		argSpec := interpreterProxy fetchPointer: 0 ofObject: argType.
		argClass := interpreterProxy fetchPointer: 1 ofObject: argType.
		oop := argArrayOrNil isNil
				ifTrue: [interpreterProxy stackValue: nArgs - i]
				ifFalse: [interpreterProxy fetchPointer: i - 1 ofObject: argArrayOrNil].
		err := self ffiArgument: oop Spec: argSpec Class: argClass in: calloutState.
		err ~= 0 ifTrue:
			[self cleanupCalloutState: calloutState.
			 self cppIf: COGMTVM ifTrue:
			 [err = PrimErrObjectMayMove negated ifTrue:
				[^PrimErrObjectMayMove]]. "N.B. Do not fail if object may move because caller will GC and retry."
			 ^self ffiFail: err]]. "coercion failed or out of stack space"
	"Failures must be reported back from ffiArgument:Spec:Class:in:.
	 Should not fail from here on in."
	self assert: interpreterProxy failed not.
	self ffiLogCallout: externalFunction.
	(requiredStackSize < 0
	 and: [self externalFunctionHasStackSizeSlot]) ifTrue:
		[stackSize := calloutState currentArg - calloutState argVector.
		 interpreterProxy storeInteger: ExternalFunctionStackSizeIndex ofObject: externalFunction withValue: stackSize].
	"Go out and call this guy"
	result := self ffiCalloutTo: address SpecOnStack: argArrayOrNil notNil in: calloutState.
	self cleanupCalloutState: calloutState.
	^result
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiCalloutTo: procAddr SpecOnStack: specOnStack in: calloutState [
	<var: #procAddr type: #'void *'>
	<arg: #calloutState type: #'CalloutState *'>
	"Perform the callout, collect the result and and create the return value.
	 If a threaded call, disown and own VM around the call.  If there are floating-point
	 arguments that are passed in registers then call a dummy function to load them.
	 This *must* be inlined because of the alloca of the outgoing stack frame in
	 ffiCall:SpecOnStack:Flags:NumArgs:Args:AndTypes:"
	<inline: true>
	self subclassResponsibility
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiCheckReturn: retSpec With: retClass in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	"Make sure we can return an object of the given type"
	<inline: true>
	| ffiRetSpec |
	retClass = interpreterProxy nilObject ifFalse:[
		(interpreterProxy includesBehavior: retClass 
						ThatOf: interpreterProxy classExternalStructure)
			ifFalse:[^FFIErrorBadReturn]].

	(interpreterProxy isWords: retSpec)
		ifFalse:[^FFIErrorWrongType].
	(interpreterProxy slotSizeOf: retSpec) = 0 ifTrue:[^FFIErrorWrongType].
	ffiRetSpec := self cCoerce: (interpreterProxy firstIndexableField: retSpec) to: #int.
	calloutState ffiRetHeader: (interpreterProxy longAt: ffiRetSpec).
	(self isAtomicType: calloutState ffiRetHeader) ifFalse:[
		(retClass = interpreterProxy nilObject)
			ifTrue:[^FFIErrorBadReturn]].
	(calloutState ffiRetHeader bitAnd: (FFIFlagPointer bitOr: FFIFlagStructure)) = FFIFlagStructure ifTrue:
		[calloutState structReturnSize: (calloutState ffiRetHeader bitAnd: FFIStructSizeMask)].
	^0
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiContentsOfHandle: oop errCode: errCode [
	"Make sure that the given oop is a valid external handle"
	<inline: true>
	((interpreterProxy isBytes: oop)
	 and: [(interpreterProxy byteSizeOf: oop) = (self sizeof: #sqInt)]) ifFalse:
		[^self ffiFail: errCode].
	^interpreterProxy fetchPointer: 0 ofObject: oop
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiCreateIntegralResultOop: retVal ofAtomicType: atomicType in: calloutState [
	<inline: true>
	<var: #calloutState type: #'CalloutState *'>
	<var: #retVal type: #usqLong>
	"Callout support. Return the appropriate oop for the given atomic type"
	| shift value mask byteSize |
	self assert: atomicType < FFITypeSingleFloat.

	atomicType = FFITypeBool ifTrue:
		["Make sure bool honors the byte size requested"
		 byteSize := calloutState ffiRetHeader bitAnd: FFIStructSizeMask.
		 value := byteSize = (self sizeof: retVal)
					ifTrue:[retVal]
					ifFalse:[retVal bitAnd: 1 << (byteSize * 8) - 1].
		 ^value = 0
			ifTrue:[interpreterProxy falseObject]
			ifFalse:[interpreterProxy trueObject]].
	atomicType <= FFITypeSignedInt ifTrue:
		["these are all generall integer returns"
		atomicType <= FFITypeSignedShort ifTrue:
			["byte/short. first extract partial word, then sign extend"
			shift := (atomicType >> 1) * 8. "# of significant bits"
			value := retVal bitAnd: (1 << shift - 1). 
			(atomicType anyMask: 1) ifTrue:
				["make the guy signed"
				mask := 1 << (shift-1).
				value := (value bitAnd: mask-1) - (value bitAnd: mask)].
			^interpreterProxy integerObjectOf: value].
		"32bit integer return"
		^(atomicType anyMask: 1)
			ifTrue:[interpreterProxy signed32BitIntegerFor: retVal] "signed return"
			ifFalse:[interpreterProxy positive32BitIntegerFor: retVal]]. "unsigned return"

	"longlong, char"
	^(atomicType >> 1) = (FFITypeSignedLongLong >> 1) 
		ifTrue:
			[(atomicType anyMask: 1)
				ifTrue:[interpreterProxy signed64BitIntegerFor: retVal] "signed return"
				ifFalse:[interpreterProxy positive64BitIntegerFor: retVal]]
		ifFalse:
			[interpreterProxy characterObjectOf: (retVal bitAnd: Byte0Mask)]
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiFail: reason [
	<inline: false>
	"Map the FFI error code into a primitive error code.  If reason is negative it encodes one of the
	 standard PrimErr... codes, negated to distinguish it from the FFIError codes.  If it is an FFIError...
	 code then add the size of the primitive error table + 2 to disambiguate it from the PrimErr... codes.
	 For historic reasons the FFIError codes range from -1 on up hence adding size + 2 maps them to
	 size of table + 1 on up.  This OFFSET IS undone by ExternalFunction class>>externalCallFailedWith:.
	 Thus we can communicate back both PrimErr.. and FFIError codes.  Complex but necessary."
	ffiLastError := reason.
	^interpreterProxy primitiveFailFor:
		(reason >= FFINoCalloutAvailable
			ifTrue: [reason + 2 + (interpreterProxy slotSizeOf: interpreterProxy primitiveErrorTable)]
			ifFalse: [reason negated])
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiFloatValueOf: oop [
	"Support for generic callout. Return a float value that is coerced as C would do."
	| oopClass |
	<returnTypeC:'double'>
	oopClass := interpreterProxy fetchClassOf: oop.
	oopClass = interpreterProxy classFloat
		ifTrue:[^interpreterProxy floatValueOf: oop].
	"otherwise try the integer coercions and return its float value"
	^(self ffiIntegerValueOf: oop) asFloat
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> ffiFree: pointer [
	"Default to malloc/free.  If a platform needs a different allocator define
	 something in the preamble and redefine this to take account of that."
	<cmacro: '(pointer) free((void *)(pointer))'>
	^self
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiIntegerValueOf: oop [
	"Support for generic callout. Return an integer value that is coerced as C would do."
	| oopClass |
	<inline: true>
	(interpreterProxy isIntegerObject: oop) ifTrue:
		[^interpreterProxy integerValueOf: oop].
	oop = interpreterProxy nilObject ifTrue: [^0]. "@@: should we really allow this????"
	oop = interpreterProxy falseObject ifTrue: [^0].
	oop = interpreterProxy trueObject ifTrue: [^1].
	oopClass := interpreterProxy fetchClassOf: oop.
	oopClass = interpreterProxy classFloat ifTrue:
		[^(interpreterProxy floatValueOf: oop) asInteger].
	oopClass = interpreterProxy classCharacter ifTrue:
		[^interpreterProxy characterValueOf: oop].
	oopClass = interpreterProxy classLargePositiveInteger ifTrue:
		[^interpreterProxy positive32BitValueOf: oop].
	^interpreterProxy signedMachineIntegerValueOf: oop "<- will fail if not integer"
]

{ #category : #'symbol loading' }
ThreadedFFIPlugin >> ffiLoadCalloutAddress: lit [
	"Load the address of the foreign function from the given object"
	| addressPtr address ptr |
	<var: #ptr type: #'int *'>
	"Lookup the address"
	addressPtr := interpreterProxy fetchPointer: 0 ofObject: lit.
	"Make sure it's an external handle"
	address := self ffiContentsOfHandle: addressPtr errCode: FFIErrorBadAddress.
	interpreterProxy failed ifTrue:
		[^0].
	address = 0 ifTrue:"Go look it up in the module"
		[self externalFunctionHasStackSizeSlot ifTrue:
			[interpreterProxy
				storePointer: ExternalFunctionStackSizeIndex
				ofObject: lit
				withValue: (interpreterProxy integerObjectOf: -1)].
		(interpreterProxy slotSizeOf: lit) < 5 ifTrue:
			[^self ffiFail: FFIErrorNoModule].
		address := self ffiLoadCalloutAddressFrom: lit.
		interpreterProxy failed ifTrue:
			[^0].
		"Store back the address"
		ptr := interpreterProxy firstIndexableField: addressPtr.
		ptr at: 0 put: address].
	^address
]

{ #category : #'symbol loading' }
ThreadedFFIPlugin >> ffiLoadCalloutAddressFrom: oop [
	"Load the function address for a call out to an external function"
	| module moduleHandle functionName address |
	<inline: false>
	"First find and load the module"
	module := interpreterProxy fetchPointer: externalFunctionInstSize + 1 ofObject: oop.
	moduleHandle := self ffiLoadCalloutModule: module.
	interpreterProxy failed ifTrue:
		[^0]. "failed"
	"fetch the function name"
	functionName := interpreterProxy fetchPointer: externalFunctionInstSize ofObject: oop.
	(interpreterProxy isBytes: functionName) ifFalse:
		[^self ffiFail: FFIErrorBadExternalFunction].
	address := (interpreterProxy
					ioLoadSymbol: (interpreterProxy firstIndexableField: functionName) asInteger
					OfLength: (interpreterProxy byteSizeOf: functionName) 
					FromModule: moduleHandle) asInteger.
	(interpreterProxy failed or: [address = 0]) ifTrue:
		[^self ffiFail: FFIErrorAddressNotFound].
	^address
]

{ #category : #'symbol loading' }
ThreadedFFIPlugin >> ffiLoadCalloutModule: module [
	"Load the given module and return its handle"
	| moduleHandlePtr moduleHandle ffiModuleName moduleLength rcvr ptr |
	<var: #ptr type:'int *'>
	(interpreterProxy isBytes: module) ifTrue:[
		"plain module name"
		ffiModuleName := module.
		moduleLength := interpreterProxy byteSizeOf: ffiModuleName.
		moduleHandle := (interpreterProxy
							ioLoadModule: (interpreterProxy firstIndexableField: ffiModuleName) asInteger
							OfLength: moduleLength) asInteger.
		(interpreterProxy failed
		 or: [moduleHandle = 0]) ifTrue:
			[^self ffiFail: FFIErrorModuleNotFound]. "failed"
		^moduleHandle].
	"Check if the external method is defined in an external library"
	rcvr := interpreterProxy stackValue: interpreterProxy methodArgumentCount.
	(interpreterProxy is: rcvr KindOfClass: interpreterProxy classExternalLibrary) ifFalse:
		[^self ffiFail: FFIErrorNoModule].
	"external library"
	moduleHandlePtr := interpreterProxy fetchPointer: 0 ofObject: rcvr.
	moduleHandle := self ffiContentsOfHandle: moduleHandlePtr errCode: FFIErrorBadExternalLibrary.
	interpreterProxy failed ifTrue:[^0].
	moduleHandle = 0 ifTrue:["need to reload module"
		ffiModuleName := interpreterProxy fetchPointer: 1 ofObject: rcvr.
		(interpreterProxy isBytes: ffiModuleName) ifFalse:[^self ffiFail: FFIErrorBadExternalLibrary].
		moduleLength := interpreterProxy byteSizeOf: ffiModuleName.
		moduleHandle := (interpreterProxy
								ioLoadModule: (interpreterProxy firstIndexableField: ffiModuleName) asInteger
								OfLength: moduleLength) asInteger.
		(interpreterProxy failed
		 or: [moduleHandle = 0]) ifTrue:
			[^self ffiFail: FFIErrorModuleNotFound]. "failed"
		"and store back"
		ptr := interpreterProxy firstIndexableField: moduleHandlePtr.
		ptr at: 0 put: moduleHandle].
	^moduleHandle
]

{ #category : #'symbol loading' }
ThreadedFFIPlugin >> ffiLogCallout: lit [
	<returnTypeC: #void>
	"fetch the function name"
	| functionName |
	ffiLogEnabled ifTrue:[
		functionName := interpreterProxy fetchPointer: externalFunctionInstSize ofObject: lit.
		(interpreterProxy isBytes: functionName) ifFalse:[^nil].
		self ffiLogCall: (interpreterProxy firstIndexableField: functionName)
			OfLength: (interpreterProxy byteSizeOf: functionName).
	].
]

{ #category : #initialize }
ThreadedFFIPlugin >> ffiLogCallsTo: fileName [
	"This is a special entry point exposed such that client code can 
	enable and disable logging of FFI calls."
	| ok |
	<export: true>
	<var: #fileName type: 'char*'>
	fileName == nil ifTrue:[ "disable logging"
		ok := self ffiLogFileName: nil OfLength: 0.
		ok ifFalse:[^false].
		ffiLogEnabled := false.
	] ifFalse:[ "enable logging"
		ok := self ffiLogFileName: fileName OfLength: (self strlen: fileName).
		ok ifFalse:[^false].
		ffiLogEnabled := true.
	].
	^true
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushDoubleFloat: value in: calloutState [
	<var: #calloutState type: #double>
	<var: #calloutState type: #'CalloutState *'>
	^self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushPointer: pointer in: calloutState [
	<var: #pointer type: #'void *'>
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushPointerContentsOf: oop in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	"Push the contents of the given external structure"
	| ptrClass ptrAddress |
	<inline: false>
	ptrClass := interpreterProxy fetchClassOf: oop.
	ptrClass = interpreterProxy classExternalAddress ifTrue:[
		ptrAddress := interpreterProxy fetchPointer: 0 ofObject: oop.
		"Don't you dare to pass pointers into object memory"
		(interpreterProxy isInMemory: ptrAddress) ifTrue:
			[^FFIErrorInvalidPointer].
		^self ffiPushPointer: ptrAddress in: calloutState].

	ptrClass = interpreterProxy classByteArray ifTrue:
		["Since this involves passing the address of the first indexable field we need to fail
		  the call if it is threaded and the object is young, since it may move during the call."
		 self cppIf: COGMTVM ifTrue:
		 [((calloutState callFlags anyMask: FFICallFlagThreaded)
		   and: [interpreterProxy isYoung: oop]) ifTrue:
			[^PrimErrObjectMayMove negated]].

		ptrAddress := self cCoerce: (interpreterProxy firstIndexableField: oop) to: #int.
		^self ffiPushPointer: ptrAddress in: calloutState].

	(interpreterProxy includesBehavior: ptrClass ThatOf: interpreterProxy classAlien) ifTrue:
		[self cppIf: COGMTVM ifTrue:
		 [((calloutState callFlags anyMask: FFICallFlagThreaded)
		   and: [(self isDirectAlien: oop)
		   and: [interpreterProxy isYoung: oop]]) ifTrue:
			[^PrimErrObjectMayMove negated]].

		ptrAddress := self startOfData: oop.
		^self ffiPushPointer: ptrAddress in: calloutState].

	^FFIErrorBadArg
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushSignedByte: value in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushSignedChar: value in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushSignedInt: value in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushSignedLongLong: value in: calloutState [
	<var: #value type: #sqLong>
	<var: #calloutState type: #'CalloutState *'>
	^self subclassResponsibility
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiPushSignedLongLongOop: oop in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	"Push a longlong type (e.g., a 64bit integer).
	Note: Coercions from float are *not* supported."
	| value |
	<var: #value type: #sqLong>
	(oop = interpreterProxy nilObject
	 or: [oop = interpreterProxy falseObject])
		ifTrue:[value := 0] ifFalse:
	[oop = interpreterProxy trueObject
		ifTrue:[value := 1] ifFalse:
	[value := interpreterProxy signed64BitValueOf: oop.
	 interpreterProxy failed ifTrue:
		[^FFIErrorCoercionFailed]]].
	^self ffiPushSignedLongLong: value in: calloutState
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushSignedShort: value in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushSingleFloat: value in: calloutState [
	<var: #value type: #float>
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushString: pointer OfLength: length in: calloutState [
	<var: #pointer type: #'char *'>
	<var: #calloutState type: #'CalloutState *'>
	| copy |
	<var: #copy type: #'char *'>
	<inline: true>
	calloutState stringArgIndex >= MaxNumArgs ifTrue:
		[^PrimErrBadNumArgs negated].
	copy := self malloc: length + 1.
	copy isNil ifTrue:
		[^PrimErrNoCMemory negated].
	self mem: copy cp: pointer y: length.
	copy at: length put: 0.
	calloutState stringArgs at: calloutState stringArgIndex put: copy.
	calloutState stringArgIndex: calloutState stringArgIndex + 1.
	^self ffiPushPointer: copy in: calloutState
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushStructure: pointer ofSize: structSize typeSpec: argSpec ofLength: argSpecSize in: calloutState [
	<var: #pointer type: #'void *'>
	<var: #argSpec type: #'sqInt *'>
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiPushStructureContentsOf: oop in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	"Push the contents of the given external structure"
	| ptrClass ptrAddress |
	<inline: true>
	ptrClass := interpreterProxy fetchClassOf: oop.
	ptrClass = interpreterProxy classExternalAddress ifTrue: "ExternalAddress is bytes"
		[ptrAddress :=interpreterProxy fetchPointer: 0 ofObject: oop.
		"There is no way we can make sure the structure is valid.
		But we can at least check for attempts to pass pointers to ST memory."
		(interpreterProxy isInMemory: ptrAddress) ifTrue:
			[^FFIErrorInvalidPointer].
		^self ffiPushStructure:  (self cCoerceSimple: ptrAddress to: #'void *')
			ofSize: (calloutState ffiArgHeader bitAnd: FFIStructSizeMask)
			typeSpec: calloutState ffiArgSpec
			ofLength: calloutState ffiArgSpecSize
			in: calloutState].
	ptrClass = interpreterProxy classByteArray ifTrue:
		["The following is a somewhat pessimistic test but I like being sure..."
		(interpreterProxy byteSizeOf: oop) = (calloutState ffiArgHeader bitAnd: FFIStructSizeMask)
			ifFalse:[^FFIErrorStructSize].
		ptrAddress := self cCoerceSimple: (interpreterProxy firstIndexableField: oop) to: #int.
		(calloutState ffiArgHeader anyMask: FFIFlagPointer) ifFalse:[
			"Since this involves passing the address of the first indexable field we need to fail
			  the call if it is threaded and the object is young, since it may move during the call."
			self cppIf: COGMTVM ifTrue:
			 [((calloutState callFlags anyMask: FFICallFlagThreaded)
			 and: [interpreterProxy isYoung: oop]) ifTrue:
				[^PrimErrObjectMayMove negated]].
			^self ffiPushStructure: (self cCoerceSimple: ptrAddress to: #'void *') 
				ofSize: (calloutState ffiArgHeader bitAnd: FFIStructSizeMask)
				typeSpec: calloutState ffiArgSpec
				ofLength: calloutState ffiArgSpecSize
				in: calloutState].
		"If FFIFlagPointer + FFIFlagStructure is set use ffiPushPointer on the contents"
		(calloutState ffiArgHeader bitAnd: FFIStructSizeMask) = 4 ifFalse:
			[^FFIErrorStructSize].
		ptrAddress := interpreterProxy fetchPointer: 0 ofObject: oop.
		(interpreterProxy isInMemory: ptrAddress) ifTrue:
			[^FFIErrorInvalidPointer].
		^self ffiPushPointer: ptrAddress in: calloutState].
	^FFIErrorBadArg
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushUnsignedByte: value in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushUnsignedChar: value in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushUnsignedInt: value in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushUnsignedLongLong: value in: calloutState [
	<var: #value type: #usqLong>
	^self subclassResponsibility
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiPushUnsignedLongLongOop: oop in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	"Push an unsigned longlong type (e.g., a 64bit integer).
	Note: Coercions from float are *not* supported."
	| value |
	<var: #value type: #usqLong>
	(oop = interpreterProxy nilObject
	 or: [oop = interpreterProxy falseObject])
		ifTrue:[value := 0] ifFalse:
	[oop = interpreterProxy trueObject
		ifTrue:[value := 1] ifFalse:
	[value := interpreterProxy positive64BitValueOf: oop.
	 interpreterProxy failed ifTrue:
		[^FFIErrorCoercionFailed]]].
	^self ffiPushUnsignedLongLong: value in: calloutState
]

{ #category : #marshalling }
ThreadedFFIPlugin >> ffiPushUnsignedShort: value in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<inline: true>
	self subclassResponsibility
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiPushVoid: ignored in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	"This is a fallback in case somebody tries to pass a 'void' value.
	We could simply ignore the argument but I think it's better to let
	the caller know what he did"
	^FFIErrorAttemptToPassVoid
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiReturnCStringFrom: cPointer [
	"Create a Smalltalk string from a zero terminated C string"
	| strLen strOop cString strPtr |
	<var: #cString type: #'char *'>
	<var: #strPtr type: #'char *'>
	cPointer = nil ifTrue:[
		^interpreterProxy methodReturnValue: interpreterProxy nilObject]. "nil always returns as nil"
	cString := self cCoerce: cPointer to:'char *'.
	strLen := 0.
	[(cString at: strLen) = 0] whileFalse:[strLen := strLen+1].
	strOop := interpreterProxy 
				instantiateClass: interpreterProxy classString 
				indexableSize: strLen.
	strPtr := interpreterProxy firstIndexableField: strOop.
	0 to: strLen-1 do:[:i| strPtr at: i put: (cString at: i)].
	^interpreterProxy methodReturnValue: strOop
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiReturnPointer: retVal ofType: retType in: calloutState [
	<var: #calloutState type: #'CalloutState *'>
	<var: #retVal type: #usqLong>
	"Generic callout support. Create a pointer return value from an external function call"
	| retClass atomicType retOop oop ptr classOop |
	<var: #ptr type: #'sqInt *'>
	retClass := interpreterProxy fetchPointer: 1 ofObject: retType.
	retClass = interpreterProxy nilObject ifTrue:
		["Create ExternalData upon return"
		atomicType := self atomicTypeOf: calloutState ffiRetHeader.
		(atomicType >> 1) = (FFITypeSignedChar >> 1) ifTrue: "String return"
			[^self ffiReturnCStringFrom: (self cCoerceSimple: retVal to: #usqInt)].
		"generate external data"
		self remapOop: retType in:
			[oop := interpreterProxy
						instantiateClass: interpreterProxy classExternalAddress 
						indexableSize: 4.
			ptr := interpreterProxy firstIndexableField: oop.
			ptr at: 0 put: (self cCoerceSimple: retVal to: #sqInt).
			self remapOop: oop in:
				[retOop := interpreterProxy 
								instantiateClass: interpreterProxy classExternalData 
								indexableSize: 0].
			interpreterProxy storePointer: 0 ofObject: retOop withValue: oop].
		interpreterProxy storePointer: 1 ofObject: retOop withValue: retType.
		^interpreterProxy methodReturnValue: retOop].
	"non-atomic pointer return"
	classOop := (calloutState ffiRetHeader anyMask: FFIFlagStructure)
					ifTrue:[interpreterProxy classByteArray]
					ifFalse:[interpreterProxy classExternalAddress].
	self remapOop: retClass in:
		[oop := interpreterProxy 
					instantiateClass: classOop
					indexableSize: 4].
	ptr := interpreterProxy firstIndexableField: oop.
	ptr at: 0 put: (self cCoerceSimple: retVal to: #sqInt).
	self remapOop: oop in:
		[retOop := interpreterProxy instantiateClass: retClass indexableSize: 0].
	interpreterProxy storePointer: 0 ofObject: retOop withValue: oop.
	^interpreterProxy methodReturnValue: retOop
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiReturnStruct: longLongRet ofType: ffiRetClass in: calloutState [
	<var: #longLongRet type: #usqLong>
	<var: #calloutState type: #'CalloutState *'>
	"Create a structure return value from an external function call.  The value as been stored in
	 alloca'ed space pointed to by the calloutState."
	<inline: true>
	self subclassResponsibility
]

{ #category : #'symbol loading' }
ThreadedFFIPlugin >> ffiReturnType: specOnStack [
	"Answer the return type object for the current invocation"
	| specLiteral argTypes |
	specLiteral := specOnStack
					ifTrue: [interpreterProxy stackValue: 1]
					ifFalse: [interpreterProxy literal: 0 ofMethod: interpreterProxy primitiveMethod].
	argTypes := interpreterProxy fetchPointer: ExternalFunctionArgTypesIndex ofObject: specLiteral.
	^interpreterProxy fetchPointer: 0 ofObject: argTypes
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiSupportsCallingConvention: aCallingConvention [
	"Check that the calling convention is valid.  This test also filters out attempts
	 to do a threaded call in the non-threaded VM/plugin combinatioin."

	<inline: true>
	^aCallingConvention = FFICallTypeCDecl or: [aCallingConvention = FFICallTypeApi]
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> ffiValidateExternalData: oop AtomicType: atomicType [
	"Validate if the given oop (an instance of ExternalData) can be passed as a pointer to the given atomic type."
	| ptrType specOop spec specType |
	<inline: true>
	ptrType := interpreterProxy fetchPointer: 1 ofObject: oop.
	((interpreterProxy isPointers: ptrType)
	and: [(interpreterProxy slotSizeOf: ptrType) >= 2]) ifFalse:
		[^FFIErrorWrongType].
	specOop := interpreterProxy fetchPointer: 0 ofObject: ptrType.
	((interpreterProxy isWords: specOop)
	and: [(interpreterProxy slotSizeOf: specOop) > 0]) ifFalse:
		[^FFIErrorWrongType].
	spec := interpreterProxy fetchPointer: 0 ofObject: specOop.
	(self isAtomicType: spec) ifFalse:
		[^FFIErrorWrongType].
	specType := self atomicTypeOf: spec.
	specType ~= atomicType ifTrue:
		"Allow for signed/unsigned conversion but nothing else.
		 See FFIConstants class>>#initializeTypeConstants"
		[(atomicType >= FFITypeUnsignedByte
		  and: [atomicType <= FFITypeSignedChar
		  and: [(atomicType >> 1) = (specType >> 1)]]) ifFalse:
			[^FFIErrorCoercionFailed]].
	^0
]

{ #category : #initialize }
ThreadedFFIPlugin >> getModuleName [
	"Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important!"
	<returnTypeC: 'const char *'>
	<export: true>
	^'SqueakFFIPrims'
]

{ #category : #initialize }
ThreadedFFIPlugin >> initialiseModule [
	<export: true>
	"By default, disable logging"
	ffiLogEnabled := false.
	"Get the instSize of ExternalFunction to know whether it contains a cache of the stackSize,
	 and what the offset of ExternalLibraryFunction's functionName and moduleName slots are."
	externalFunctionInstSize := interpreterProxy instanceSizeOf: interpreterProxy classExternalFunction.
	self initSurfacePluginFunctionPointers.
	^1
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> isAlien: anOop [
	^interpreterProxy
		includesBehavior: (interpreterProxy fetchClassOf: anOop)
		ThatOf: interpreterProxy classAlien
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> isAtomicType: typeSpec [
	^typeSpec anyMask: FFIFlagAtomic
]

{ #category : #'callout support' }
ThreadedFFIPlugin >> isCalleePopsConvention: callType [
	<cmacro: '(callType) (PLATFORM_API_USES_CALLEE_POPS_CONVENTION && (callType) == FFICallTypeApi)'>
	^callType == FFICallTypeApi
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> isDirectAlien: oop [
	self assert: (self isAlien: oop).
	^(self sizeField: oop) > 0
]

{ #category : #debugging }
ThreadedFFIPlugin >> msg: s [
	<var: #s type: 'char *'>
	self cCode: 'fprintf(stderr, "\n%s: %s", getModuleName(), s)'
		inSmalltalk: [super msg: s].
	^0
]

{ #category : #marshalling }
ThreadedFFIPlugin >> nonRegisterStructReturnIsViaImplicitFirstArgument [
	"Answer if a struct returned in memory is returned to the
	 referent of a pointer passed as an implciit first argument.
	 It almost always is.  Subclasses can override if not."
	^true
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveCallout [
	"IMPORTANT: IF YOU CHANGE THE NAME OF THIS METHOD YOU MUST CHANGE
		Interpreter>>primitiveCalloutToFFI
	TO REFLECT THE CHANGE."

	"Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec."
 
	<returnTypeC: #void>
	<export: true>
	| meth externalFunction |
	meth := interpreterProxy primitiveMethod.
	(interpreterProxy literalCountOf: meth) > 0 ifFalse:
		[^interpreterProxy primitiveFailFor: PrimErrBadMethod].
	externalFunction := interpreterProxy literal: 0 ofMethod: meth.
	self cppIf: COGMTVM
		ifTrue:
			[ | nArgs retryCount result |
			nArgs := interpreterProxy methodArgumentCount.
			retryCount := 0.
			[result := self ffiCall: externalFunction ArgArrayOrNil: nil NumArgs: nArgs.
			 result = PrimErrObjectMayMove
			 and: [(retryCount := retryCount + 1) <= (nArgs + 1)]] whileTrue:
				[interpreterProxy tenuringIncrementalGC]]
		ifFalse:
			[self ffiCall: externalFunction ArgArrayOrNil: nil NumArgs: interpreterProxy methodArgumentCount].
	^0
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveCalloutWithArgs [
	"Perform a function call to a foreign function.
	 Only invoked from ExternalFunction>>invokeWithArguments:"

	<returnTypeC: #void>
	<export: true>
	| externalFunction argArray nArgs |
	interpreterProxy methodArgumentCount = 1 ifFalse:
		[^interpreterProxy primitiveFailFor: PrimErrBadNumArgs].
	self cppIf: COGMTVM
		ifTrue:
			[| retryCount result |
			retryCount := 0.
			[externalFunction := interpreterProxy stackValue: 1.
			 argArray := interpreterProxy stackValue: 0.
			 (interpreterProxy isArray: argArray) ifFalse:
				[^interpreterProxy primitiveFailFor: PrimErrBadArgument].
			 nArgs := interpreterProxy slotSizeOf: argArray.
			 result := self ffiCall: externalFunction ArgArrayOrNil: argArray NumArgs: nArgs.
			 result = PrimErrObjectMayMove
			  and: [(retryCount := retryCount + 1) <= (nArgs + 1)]] whileTrue:
				[interpreterProxy tenuringIncrementalGC]]
		ifFalse:
			[externalFunction := interpreterProxy stackValue: 1.
			argArray := interpreterProxy stackValue: 0.
			(interpreterProxy isArray: argArray) ifFalse:
				[^interpreterProxy primitiveFailFor: PrimErrBadArgument].
			nArgs := interpreterProxy slotSizeOf: argArray.
			self ffiCall: externalFunction ArgArrayOrNil: argArray NumArgs: nArgs].
	^0
]

{ #category : #'primitives - surfaces' }
ThreadedFFIPlugin >> primitiveCreateManualSurface [
	"arguments: name(type, stack offset)
		width(Integer, 4)
		height(Integer, 3)
		rowPitch(Integer, 2)
		depth(Integer, 1)
		isMSB(Boolean, 0)"
	| width height rowPitch depth isMSB result |
	<export: true>
	
	interpreterProxy methodArgumentCount == 5 ifFalse: [^interpreterProxy primitiveFail].
	width := interpreterProxy stackIntegerValue: 4.
	height := interpreterProxy stackIntegerValue: 3.
	rowPitch := interpreterProxy stackIntegerValue: 2.
	depth := interpreterProxy stackIntegerValue: 1.
	isMSB := interpreterProxy stackObjectValue: 0.
	isMSB := interpreterProxy booleanValueOf: isMSB. 
	interpreterProxy failed ifTrue: [^nil].
	
	self touch: width; touch: height; touch: rowPitch; touch: depth; touch: isMSB.
	
	result := self cCode: 'createManualSurface(width, height, rowPitch, depth, isMSB)'.
	result < 0 ifTrue: [^interpreterProxy primitiveFail].
	result := interpreterProxy signed32BitIntegerFor: result.
	^interpreterProxy pop: 6 thenPush: result
	
]

{ #category : #'primitives - surfaces' }
ThreadedFFIPlugin >> primitiveDestroyManualSurface [
	"arguments: name(type, stack offset)
		surfaceID(Integer, 0)"
	| surfaceID result |
	<export: true>
	
	interpreterProxy methodArgumentCount == 1 ifFalse: [^interpreterProxy primitiveFail].
	surfaceID := interpreterProxy stackIntegerValue: 0.
	interpreterProxy failed ifTrue: [^nil].
	result := self destroyManualSurface: surfaceID.
	result = 0 ifTrue: [^interpreterProxy primitiveFail].
	^interpreterProxy pop: 1
	
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIAllocate [
	"Primitive. Allocate an object on the external heap."
	| byteSize addr oop ptr |
	<export: true>
	<inline: false>
	<var: #ptr type:'int *'>
	byteSize := interpreterProxy stackIntegerValue: 0.
	interpreterProxy failed ifTrue:[^nil].
	addr := self ffiAlloc: byteSize.
	addr = 0 ifTrue:[^interpreterProxy primitiveFail].
	oop := interpreterProxy 
			instantiateClass: interpreterProxy classExternalAddress 
			indexableSize: 4.
	ptr := interpreterProxy firstIndexableField: oop.
	ptr at: 0 put: addr.
	^interpreterProxy pop: 2 thenPush: oop
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIDoubleAt [
	"Return a (signed or unsigned) n byte integer from the given byte offset."
	| byteOffset rcvr addr floatValue |
	<export: true>
	<inline: false>
	<var: #floatValue type:'double '>
	byteOffset := interpreterProxy stackIntegerValue: 0.
	rcvr := interpreterProxy stackObjectValue: 1.
	interpreterProxy failed ifTrue:[^0].
	addr := self ffiAddressOf: rcvr startingAt: byteOffset size: 8.
	interpreterProxy failed ifTrue:[^0].
	self cCode:'((int*)(&floatValue))[0] = ((int*)addr)[0]'.
	self cCode:'((int*)(&floatValue))[1] = ((int*)addr)[1]'.
	interpreterProxy pop: 2.
	^interpreterProxy pushFloat: floatValue

]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIDoubleAtPut [
	"Return a (signed or unsigned) n byte integer from the given byte offset."
	| byteOffset rcvr addr floatValue floatOop |
	<export: true>
	<inline: false>
	<var: #floatValue type:'double '>
	floatOop := interpreterProxy stackValue: 0.
	(interpreterProxy isIntegerObject: floatOop)
		ifTrue:[floatValue := self cCoerce: (interpreterProxy integerValueOf: floatOop) to:'double']
		ifFalse:[floatValue := self cCoerce: (interpreterProxy floatValueOf: floatOop) to:'double'].
	byteOffset := interpreterProxy stackIntegerValue: 1.
	rcvr := interpreterProxy stackObjectValue: 2.
	interpreterProxy failed ifTrue:[^0].
	addr := self ffiAddressOf: rcvr startingAt: byteOffset size: 8.
	interpreterProxy failed ifTrue:[^0].
	self cCode:'((int*)addr)[0] = ((int*)(&floatValue))[0]'.
	self cCode:'((int*)addr)[1] = ((int*)(&floatValue))[1]'.
	^interpreterProxy pop: 3 thenPush: floatOop
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIFloatAt [
	"Return a (signed or unsigned) n byte integer from the given byte offset."
	| byteOffset rcvr addr floatValue |
	<export: true>
	<inline: false>
	<var: #floatValue type:'float '>
	byteOffset := interpreterProxy stackIntegerValue: 0.
	rcvr := interpreterProxy stackObjectValue: 1.
	interpreterProxy failed ifTrue:[^0].
	addr := self ffiAddressOf: rcvr startingAt: byteOffset size: 4.
	interpreterProxy failed ifTrue:[^0].
	self cCode:'((int*)(&floatValue))[0] = ((int*)addr)[0]'.
	interpreterProxy pop: 2.
	^interpreterProxy pushFloat: floatValue
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIFloatAtPut [
	"Return a (signed or unsigned) n byte integer from the given byte offset."
	| byteOffset rcvr addr floatValue floatOop |
	<export: true>
	<inline: false>
	<var: #floatValue type:'float '>
	floatOop := interpreterProxy stackValue: 0.
	(interpreterProxy isIntegerObject: floatOop)
		ifTrue:[floatValue := self cCoerce: (interpreterProxy integerValueOf: floatOop) to:'float']
		ifFalse:[floatValue := self cCoerce: (interpreterProxy floatValueOf: floatOop) to:'float'].
	byteOffset := interpreterProxy stackIntegerValue: 1.
	rcvr := interpreterProxy stackObjectValue: 2.
	interpreterProxy failed ifTrue:[^0].
	addr := self ffiAddressOf: rcvr startingAt: byteOffset size: 4.
	interpreterProxy failed ifTrue:[^0].
	self cCode:'((int*)addr)[0] = ((int*)(&floatValue))[0]'.
	^interpreterProxy pop: 3 thenPush: floatOop
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIFree [
	"Primitive. Free the object pointed to on the external heap."
	| addr oop ptr |
	<export: true>
	<inline: false>
	<var: #ptr type:'int *'>
	oop := interpreterProxy stackObjectValue: 0.
	interpreterProxy failed ifTrue:[^nil].
	(interpreterProxy fetchClassOf: oop) = (interpreterProxy classExternalAddress)
		ifFalse:[^interpreterProxy primitiveFail].
	(interpreterProxy byteSizeOf: oop) = 4
		ifFalse:[^interpreterProxy primitiveFail].
	ptr := interpreterProxy firstIndexableField: oop.
	addr := ptr at: 0.
	"Don't you dare to free Squeak's memory!"
	(addr = 0 or:[interpreterProxy isInMemory: addr])
		ifTrue:[^interpreterProxy primitiveFail].
	self ffiFree: addr.
	^ptr at: 0 put: 0. "cleanup"

]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIGetLastError [
	"Primitive. Return the error code from a failed call to the foreign function interface.
	 This is for backwards-compatibility.  Thread-safe access to the error code is via the
	 primitive error code."
	<export: true>
	<inline: false>
	interpreterProxy pop: 1.
	^interpreterProxy pushInteger: ffiLastError
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIIntegerAt [
	"Return a (signed or unsigned) n byte integer from the given byte offset."
	| isSigned byteSize byteOffset rcvr addr value mask |
	<export: true>
	<inline: false>
	isSigned := interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).
	byteSize := interpreterProxy stackIntegerValue: 1.
	byteOffset := interpreterProxy stackIntegerValue: 2.
	rcvr := interpreterProxy stackObjectValue: 3.
	interpreterProxy failed ifTrue:[^0].
	(byteOffset > 0 and:[byteSize = 1 or:[byteSize = 2 or:[byteSize = 4]]])
		ifFalse:[^interpreterProxy primitiveFail].
	addr := self ffiAddressOf: rcvr startingAt: byteOffset size: byteSize.
	interpreterProxy failed ifTrue:[^0].
	byteSize < 4 ifTrue:[
		"short/byte"
		byteSize = 1 
			ifTrue:[value := interpreterProxy byteAt: addr]
			ifFalse:[	value := self cCode: '*((unsigned short int *) addr)' 
								inSmalltalk: [interpreterProxy shortAt: addr]].
		isSigned ifTrue:["sign extend value"
			mask := 1 << (byteSize * 8 - 1).
			value := (value bitAnd: mask-1) - (value bitAnd: mask)].
		"note: byte/short never exceed SmallInteger range"
		value := interpreterProxy integerObjectOf: value.
	] ifFalse:[
		"general 32 bit integer"
		value := interpreterProxy longAt: addr.
		value := isSigned
					ifTrue:[interpreterProxy signed32BitIntegerFor: value]
					ifFalse:[interpreterProxy positive32BitIntegerFor: value].
	].
	^interpreterProxy pop: 4 thenPush: value
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveFFIIntegerAtPut [
	"Store a (signed or unsigned) n byte integer at the given byte offset."
	| isSigned byteSize byteOffset rcvr addr value max valueOop |
	<export: true>
	<inline: false>
	isSigned := interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).
	byteSize := interpreterProxy stackIntegerValue: 1.
	valueOop := interpreterProxy stackValue: 2.
	byteOffset := interpreterProxy stackIntegerValue: 3.
	rcvr := interpreterProxy stackObjectValue: 4.
	interpreterProxy failed ifTrue:[^0].
	(byteOffset > 0 and:[byteSize = 1 or:[byteSize = 2 or:[byteSize = 4]]])
		ifFalse:[^interpreterProxy primitiveFail].
	addr := self ffiAddressOf: rcvr startingAt: byteOffset size: byteSize.
	interpreterProxy failed ifTrue:[^0].
	isSigned 
		ifTrue:[value := interpreterProxy signed32BitValueOf: valueOop]
		ifFalse:[value := interpreterProxy positive32BitValueOf: valueOop].
	interpreterProxy failed ifTrue:[^0].
	byteSize < 4 ifTrue:[
		isSigned ifTrue:[
			max := 1 << (8 * byteSize - 1).
			value >= max ifTrue:[^interpreterProxy primitiveFail].
			value < (0 - max) ifTrue:[^interpreterProxy primitiveFail].
		] ifFalse:[
			value >= (1 << (8*byteSize)) ifTrue:[^interpreterProxy primitiveFail].
		].
		"short/byte"
		byteSize = 1 
			ifTrue:[interpreterProxy byteAt: addr put: value]
			ifFalse:[	self cCode: '*((short int *) addr) = value' 
						inSmalltalk: [interpreterProxy shortAt: addr put: value]].
	] ifFalse:[interpreterProxy longAt: addr put: value].
	^interpreterProxy pop: 5 thenPush: valueOop
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveForceLoad [
	"Primitive. Force loading the receiver (an instance of ExternalLibrary)."
	| rcvr moduleHandlePtr moduleHandle ffiModuleName ptr |
	<export: true>
	<inline: false>
	<var: #ptr type: #'sqInt *'>
	interpreterProxy methodArgumentCount = 0 ifFalse:
		[^interpreterProxy primitiveFail].
	rcvr := interpreterProxy stackValue: 0.
	(interpreterProxy is: rcvr KindOfClass: interpreterProxy classExternalLibrary) ifFalse:
		[^self ffiFail: FFIErrorBadExternalLibrary].
	moduleHandlePtr := interpreterProxy fetchPointer: 0 ofObject: rcvr.
	moduleHandle := self ffiContentsOfHandle: moduleHandlePtr errCode: FFIErrorBadExternalLibrary.
	interpreterProxy failed ifTrue:
		[^0].
	ffiModuleName := interpreterProxy fetchPointer: 1 ofObject: rcvr.
	(interpreterProxy isBytes: ffiModuleName) ifFalse:
		[^self ffiFail: FFIErrorBadExternalLibrary].
	moduleHandle := (interpreterProxy
						ioLoadModule: (interpreterProxy firstIndexableField: ffiModuleName) asInteger
						OfLength: (interpreterProxy byteSizeOf: ffiModuleName)) asInteger.
	interpreterProxy failed ifTrue:
		[^self ffiFail: FFIErrorModuleNotFound]. "failed"
	"and store back"
	ptr := interpreterProxy firstIndexableField: moduleHandlePtr.
	ptr at: 0 put: moduleHandle.
	^0 "done"
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveLoadSymbolFromModule [
	"Attempt to find the address of a symbol in a loaded library.
	loadSymbol: aSymbol fromModule: moduleName
		<primitive: 'primitiveLoadSymbolFromModule' error: errorCode module: 'SqueakFFIPrims'>
	"
	<export: true>

	| symbol module moduleHandle address oop ptr |

	<var: #address type: #'void *'>
	<var: #ptr type:'unsigned int *'>
	
	interpreterProxy methodArgumentCount = 2 ifFalse:
		[^interpreterProxy primitiveFailFor: PrimErrBadNumArgs].	

	module := interpreterProxy stackValue: 0.
	symbol := interpreterProxy stackValue: 1.

	moduleHandle := self ffiLoadCalloutModule: module.
	interpreterProxy failed ifTrue:
		[^interpreterProxy primitiveFailFor: PrimErrNotFound].
	address := interpreterProxy
		ioLoadSymbol: (self cCoerce: (interpreterProxy firstIndexableField: symbol) to: #sqInt)
		OfLength: (interpreterProxy byteSizeOf: symbol)
		FromModule: moduleHandle.
	(interpreterProxy failed
	 or: [address = 0]) ifTrue:
		[^interpreterProxy primitiveFailFor: PrimErrNotFound].
	
	oop := interpreterProxy 
		instantiateClass: interpreterProxy classExternalAddress 
		indexableSize: 4.
	ptr := interpreterProxy firstIndexableField: oop.
	ptr at: 0 put: address.
	
	interpreterProxy methodReturnValue: oop
]

{ #category : #primitives }
ThreadedFFIPlugin >> primitiveLogCallsTo [
	"Enable logging of FFI calls by providing it with a log file name."
	| logFile ok |
	<export: true>
	interpreterProxy methodArgumentCount = 1 
		ifFalse:[^interpreterProxy primitiveFail].
	logFile := interpreterProxy stackObjectValue: 0.
	logFile = interpreterProxy nilObject ifTrue:[ "disable logging"
		ok := self ffiLogFileName: nil OfLength: 0.
		ok ifFalse:[^interpreterProxy primitiveFail].
		ffiLogEnabled := false.
	] ifFalse:[ "enable logging"
		(interpreterProxy isBytes: logFile) ifFalse:[^interpreterProxy primitiveFail].
		ok := self ffiLogFileName: (interpreterProxy firstIndexableField: logFile)
					OfLength: (interpreterProxy byteSizeOf: logFile).
		ok ifFalse:[^interpreterProxy primitiveFail].
		ffiLogEnabled := true.
	].
	^interpreterProxy pop: 1. "pop arg; return rcvr"

]

{ #category : #'primitives - surfaces' }
ThreadedFFIPlugin >> primitiveSetManualSurfacePointer [
	"Create a 'manual surface' data-structure.  See the ExternalForm class in the FFI package for example usage."
	"arguments: name(type, stack offset)
		surfaceID(Integer, 1)
		ptr(uint32, 0)"
	| surfaceID ptr result |
	<export: true>
	<var: #ptr type: #'unsigned int'>
	
	interpreterProxy methodArgumentCount == 2 ifFalse: [^interpreterProxy primitiveFail].
	surfaceID := interpreterProxy stackIntegerValue: 1.
	ptr := interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).
	interpreterProxy failed ifTrue: [^nil].

	self touch: surfaceID; touch: ptr.
	
	result := self cCode: 'setManualSurfacePointer(surfaceID, (void*)ptr)'.
	result = 0 ifTrue: [^interpreterProxy primitiveFail].
	^interpreterProxy pop: 2
	
]

{ #category : #marshalling }
ThreadedFFIPlugin >> registerArgsSlop [
	"Answer any space needed to prevent the alloca'ed outgoing arguments marshalling area from
	 being overwritten by any register arguments during calls during marshalling.  For example, on
	 PowerPC, which has 8 register arguments in the calling convention, register arguments are also
	 written to the stack.  So unless space is left for them, calls during marshalling prior to the actual
	 callout (e.g. to interpreterProxy object manipulation routines) can end up overwriting the
	 marshalling stack as register arguments are written to the stack during calls."
	self subclassResponsibility
]

{ #category : #marshalling }
ThreadedFFIPlugin >> returnStructInRegisters: returnStructSize [
	"Answer if a struct result of a given size is returned in memory or not."
	^self subclassResponsibility
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> sizeField: oop [
	"Answer the first field of oop which is assumed to be an Alien of at least 8 bytes"
	<inline: true>
	^self longAt: oop + interpreterProxy baseHeaderSize
]

{ #category : #'primitive support' }
ThreadedFFIPlugin >> startOfData: oop [ "<Alien oop> ^<Integer>"
	"Answer the start of oop's data.  For direct aliens this is the address of
	 the second field.  For indirect and pointer aliens it is what the second field points to."
	<inline: true>
	^(self sizeField: oop) > 0
	 	ifTrue: [oop + interpreterProxy baseHeaderSize + interpreterProxy bytesPerOop]
		ifFalse: [self longAt: oop + interpreterProxy baseHeaderSize + interpreterProxy bytesPerOop]
]
