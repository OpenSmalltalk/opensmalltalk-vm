"
This class provides the basic framework for creating VM plugins. Most of the useful methods are on the class side; particularly take note of the messages like #shouldBeTranslated and #requiresPlatformFiles.
"
Class {
	#name : #InterpreterPlugin,
	#superclass : #VMClass,
	#instVars : [
		'interpreterProxy',
		'moduleName'
	],
	#pools : [
		'VMBasicConstants'
	],
	#category : #'VMMaker-Plugins'
}

{ #category : #accessing }
InterpreterPlugin class >> allCallsOn [
	"Answer a SortedCollection of all the methods that refer to me. Most classes simply defer to SystemDictionary>allCallsOn: but some have special requirements - plugins may have a module name that does not match the class name"

	self theNonMetaClass name ~= self moduleName asSymbol
		ifTrue:[^super allCallsOn, (self systemNavigation allCallsOn: self moduleName asSymbol)]
		ifFalse:[^super allCallsOn]
]

{ #category : #translation }
InterpreterPlugin class >> baseDirectoryName [
	"Return the directory into which plugins should be generated by default."
	^FileDirectory default pathName
]

{ #category : #translation }
InterpreterPlugin class >> buildCodeGeneratorUpTo: aPluginClass [
	"Build a CCodeGenerator for the plugin"
	| cg pluginClasses |
	cg := self codeGeneratorClass new initialize.
	cg pluginClass: self.
	(pluginClasses := self pluginClassesUpTo: aPluginClass) do:
		[:aClass| cg addClass: aClass].
	(cg structClassesForTranslationClasses: pluginClasses) do:
		[:structClasss| cg addStructClass: structClasss].
	cg removeUnneededBuiltins.
	^cg
]

{ #category : #private }
InterpreterPlugin class >> codeGeneratorClass [
	"return the appropriate class of code generator for this kind ofplugin"

	^VMPluginCodeGenerator
]

{ #category : #translation }
InterpreterPlugin class >> declareCVarsIn: aCCodeGenerator [
	"Note: This method must be implemented by all subclasses to declare variables."

	aCCodeGenerator 
		var: #interpreterProxy 
		type: #'struct VirtualMachine*'.
	self declareHeaderFilesIn: aCCodeGenerator.
]

{ #category : #translation }
InterpreterPlugin class >> declareHeaderFilesIn: aCCodeGenerator [
	self hasHeaderFile ifTrue:[
		aCCodeGenerator addHeaderFile: '"', self moduleName,'.h"'].
]

{ #category : #'instance creation' }
InterpreterPlugin class >> doPrimitive: primitiveName [ 
	| proxy plugin |
	proxy := InterpreterProxy new.
	proxy loadStackFrom: thisContext sender.
	plugin := self simulatorClass new.
	plugin setInterpreter: proxy.
	(plugin respondsTo: #initialiseModule) ifTrue:[plugin initialiseModule].
	plugin perform: primitiveName asSymbol.
	^ proxy stackValue: 0
]

{ #category : #translation }
InterpreterPlugin class >> exportBuildInfoOrNil [
	"A hook for classes to emit some descriptive build string.
	 See CCodeGenerator>>fileHeaderVersionStampForSourceClass:"
	^nil
]

{ #category : #translation }
InterpreterPlugin class >> hasHeaderFile [
	"If there is a single intrinsic header file to be associated with the plugin, here is where you want to flag"
	^false
]

{ #category : #accessing }
InterpreterPlugin class >> isCPP [
	^ false
]

{ #category : #translation }
InterpreterPlugin class >> isPluginClass [
	^true
]

{ #category : #accessing }
InterpreterPlugin class >> moduleExtension [
	^ self isCPP ifTrue: ['.cpp'] ifFalse: ['.c']
]

{ #category : #translation }
InterpreterPlugin class >> moduleName [
	"Answer the receiver's module name that is used for the plugin's C code."

	^ self name asString
]

{ #category : #accessing }
InterpreterPlugin class >> moduleNameAndVersion [
	"Answer the receiver's module name and version info that is used for the plugin's C code. The default is to append the code generation date, but any useful text is ok (keep it short)"

	^ self moduleName
]

{ #category : #simulation }
InterpreterPlugin class >> newFor: anUnsimulatedInterpreterPluginClass [
	"Overridden by SmartSyntaxPluginSimulator to wrap a specific plugin class."
	^self new
]

{ #category : #translation }
InterpreterPlugin class >> pluginClassesUpTo: aPluginClass [
	"Answer the classes to include for translation of aPluginClass, superclasses first, aPluginClass last."
	| theClass classes |

	classes := OrderedCollection new.
	theClass := self.
	[theClass == Object
	 or: [theClass == VMClass]] whileFalse:
		[classes addLast: theClass.
		theClass := theClass superclass].
	^classes reverse
]

{ #category : #translation }
InterpreterPlugin class >> preambleCCode [
	"Defining this method to answer a string dumps that string in VMPluginCodeGenerator>>emitCHeaderOn:"
	^nil
]

{ #category : #translation }
InterpreterPlugin class >> requiresCrossPlatformFiles [
	"default is ok for most, any plugin needing cross platform files aside from a normal header must say so. See SoundCodecPlugin for example"
	^self hasHeaderFile
]

{ #category : #translation }
InterpreterPlugin class >> requiresPlatformFiles [
	"default is ok for most, any plugin needing platform specific files must say so"
	^false
]

{ #category : #translation }
InterpreterPlugin class >> shouldBeTranslated [
"is this class intended to be translated as a plugin? Most subclasses should answer true, but some such as:-
	TestInterpreterPlugin
	FlippArrayPlugin2
	InflatePlugin
	should answer false for various reasons."
	^true
]

{ #category : #translation }
InterpreterPlugin class >> shouldBeTranslatedFor: platformName [
	"Is this class intended to be translated as a plugin, perhaps specific to a platform?
	 Most subclasses should answer true, but some such as simulation-only versions
	 should answer false for various reasons."
	^self shouldBeTranslated
]

{ #category : #simulation }
InterpreterPlugin class >> simulatorClass [
	"For running from Smalltalk - answer a class that can be used to simulate the receiver, or nil if you want the primitives in this module to always fail, causing simulation to fall through to the Smalltalk code.  By default every non-TestInterpreterPlugin can simulate itself."

	^ self
]

{ #category : #translation }
InterpreterPlugin class >> storeString: s onFileNamed: fileName [
	"Store the given string in a file of the given name."

	| f |
	f := VMMaker forceNewFileNamed: fileName.
	f nextPutAll: s.
	f close.
]

{ #category : #translation }
InterpreterPlugin class >> translateInDirectory: directory doInlining: inlineFlag [
"This is the default method for writing out sources for a plugin. Several classes need special handling, so look at all implementors of this message"
	| cg fname fstat |
	 fname := self moduleName, '.c'.

	"don't translate if the file is newer than my timeStamp"
	fstat := directory entryAt: fname ifAbsent:[nil].
	fstat ifNotNil:
		[((self pluginClassesUpTo: self) allSatisfy:
				[:aPluginClass| aPluginClass timeStamp < fstat modificationTime]) ifTrue:
			[^nil]].

	self initialize.
	cg := self buildCodeGeneratorUpTo: self.
	cg storeCodeOnFile:  (directory fullNameFor: fname) doInlining: inlineFlag.
	^cg exportedPrimitiveNames asArray
]

{ #category : #initialize }
InterpreterPlugin >> expandDereferenceInterpreterProxyFunctionTable [
	"This is a dummy funciton that the VMPluginCodeGenerator expands into a
	 sequence of assignments from interpreterProxy funcitons to local function pointers."
]

{ #category : #initialize }
InterpreterPlugin >> getInterpreter [
	"Note: This is coded so that plugins can be run from Squeak."

	<returnTypeC: 'VirtualMachine *'>
	^interpreterProxy
]

{ #category : #initialize }
InterpreterPlugin >> getModuleName [
	"Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important!"
	<returnTypeC:'const char*'>
	<export: true>
	^moduleName
]

{ #category : #debugging }
InterpreterPlugin >> halt [
	self cCode: '' inSmalltalk: [nil halt].
	^0
]

{ #category : #'simulation support' }
InterpreterPlugin >> majorVersion [
	"This is implemented in sqVirtualMachine.c, so this form is for simulation only."
	<doNotGenerate>
	^1
]

{ #category : #'simulation support' }
InterpreterPlugin >> minorVersion [
	"This is implemented in sqVirtualMachine.c, so this form is for simulation only."
	<doNotGenerate>
	^8
]

{ #category : #debugging }
InterpreterPlugin >> msg: s [ 
	<var: #s type: 'char *'>
	self cCode: 'fprintf(stderr, "\n%s: %s", moduleName, s)' inSmalltalk: [Transcript cr; show: self class moduleName , ': ' , s; endEntry].
	^0
]

{ #category : #initialize }
InterpreterPlugin >> setInterpreter: anInterpreter [ 
	"Note: This is coded so that it can be run in Squeak."

	| ok |
	<export: true>
	<var: #anInterpreter type: #'struct VirtualMachine*'>
	interpreterProxy := anInterpreter.
	ok := interpreterProxy majorVersion = (self cCode: 'VM_PROXY_MAJOR' inSmalltalk: [self majorVersion])
		and: [interpreterProxy minorVersion >= (self cCode: 'VM_PROXY_MINOR' inSmalltalk: [self minorVersion])].
	ok ifTrue:
		[self expandDereferenceInterpreterProxyFunctionTable].
	^ok
]
