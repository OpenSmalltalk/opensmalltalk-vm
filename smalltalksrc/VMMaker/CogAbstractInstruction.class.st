"
I am an abstract instruction generated by the Cogit.  I am subsequently concretized to machine code for the current processor.  A sequence of concretized CogAbstractInstructions are concatenated to form the code for a CogMethod.  I am an abstract class.  My concrete subclasses concretize to the machine code of a specific processor.

Instance Variables
	address:			<Integer>
	bcpc:				<Integer>
	cogit:				<Cogit>
	dependent:			<AbstractInstruction|nil>
	machineCode:		<CArray on: (ByteArray|Array)>
	machineCodeSize:	<Integer>
	maxSize:			<Integer>
	objectMemory:		<NewCoObjectMemory|SpurCoMemoryManager etc>
	opcode:			<Integer>
	operands:			<CArray on: Array>

address
	- the address at which the instruction will be generated

bcpc
	- the bytecode pc for which the instruction was generated; simulation only

cogit
	- the Cogit assembling the receiver; simulation only

dependent
	- a reference to another instruction which depends on the receiver, if any; in C this is a pointer

machineCode
	- the array of machine code the receiver generates when concretized

machineCodeSize
	- the size of machineCode in bytes

maxSize
	- the maximum size of machine code that the current instruction will generate, in bytes

objectMemory
	- the memory manager for the system; simulation only

opcode
	- the opcode for the receiver which defines which abstract opcode it represents; see CogRTLOpcodes class>>initialize and CogAbstractInstruction subclass initialize methods

operands
	- the array containing any operands the instruction may have; the opcode defines implicitly how many operands are consdered
"
Class {
	#name : #CogAbstractInstruction,
	#superclass : #VMStructType,
	#instVars : [
		'opcode',
		'machineCodeSize',
		'maxSize',
		'annotation',
		'machineCode',
		'operands',
		'address',
		'dependent',
		'cogit',
		'objectMemory',
		'bcpc'
	],
	#classVars : [
		'NumOperands'
	],
	#pools : [
		'CogAbstractRegisters',
		'CogCompilationConstants',
		'CogRTLOpcodes'
	],
	#category : #'VMMaker-JIT'
}

{ #category : #translation }
CogAbstractInstruction class >> ISA [
	"Answer the name of the ISA the receiver's subclass implements."
	^self subclassResponsibility
]

{ #category : #'simulation only' }
CogAbstractInstruction class >> byteSizeForSimulator: aVMClass [
	"Answer an approximation of the byte size of an AbstractInstruction struct.
	 This is for estimating the alloca in allocateOpcodes:bytecodes:ifFail:
	 self allSubclasses collect: [:ea| {ea. ea byteSizeForSimulator: ea basicNew}]"
	| ptrsize |
	ptrsize := self == CogAbstractInstruction ifTrue: [VMClass bytesPerWord] ifFalse: [self wordSize].
	^CogCompilerClass instSize
		- 4 "cogit, objectMemory, bcpc, machineCode"
		- 4 + 1
	"opcode machineCodeSize maxSize annotation are all bytes -> 1 long" * ptrsize
	+ CogCompilerClass basicNew machineCodeBytes
		roundTo: ptrsize
]

{ #category : #translation }
CogAbstractInstruction class >> defaultCompilerClass [
	^self
]

{ #category : #translation }
CogAbstractInstruction class >> filteredInstVarNames [
	"Eliminate bcpc, which is development-time only."
	^super filteredInstVarNames copyWithout: 'bcpc'
]

{ #category : #'instance creation' }
CogAbstractInstruction class >> for: aCogit [
	^self new cogit: aCogit
]

{ #category : #translation }
CogAbstractInstruction class >> identifyingPredefinedMacros [
	"Answer the predefined macros that identify the processors a subclass handles, if any.
	 If the subclass isn't yet ready for production (a work in progress) simply answer nil."
	^nil
]

{ #category : #translation }
CogAbstractInstruction class >> ifTranslateableAddWithOptionsTo: aCollection [
	(self wordSize = Cogit objectMemoryClass wordSize
	 and: [self identifyingPredefinedMacros notNil]) ifTrue:
		[aCollection add: {self. {#ISA. self ISA}}]
]

{ #category : #'class initialization' }
CogAbstractInstruction class >> initialize [
	NumOperands := 4
]

{ #category : #'class initialization' }
CogAbstractInstruction class >> initializeAbstractRegisters [
	"Assign the abstract registers with the identities/indices of the relevant concrete registers,
	 and assign CallerSavedRegisterMask appropriately.
	 First set all abstract registers to #undefined via CogAbstractRegisters initialize, and then,
	 each subclasses assigns the subset they choose with values of specific concrete registers."
	CallerSavedRegisterMask := #undefined.
	CogAbstractRegisters initialize
]

{ #category : #'class initialization' }
CogAbstractInstruction class >> initializeSpecificOpcodes: opcodeSymbolSequence in: initializeMethod [
	"Declare as class variables, the opcodes in opcodeSymbolSequence.
	 Assign values to them from LastRTLOpcode on.  
	This method should be used by subclasses wishing to declare
	 their own specific opcodes."
	| pool classVariablesDefinedInMethod |
	self assert: self ~~ CogAbstractInstruction.
	pool := initializeMethod methodClass classPool.
	LastRTLCode ifNil:
		[CogRTLOpcodes initialize].
	classVariablesDefinedInMethod := (initializeMethod allLiterals select: [:l| l isVariableBinding and: [pool includesKey: l key]]) collect:
											[:ea| ea key].

	"Declare opcodeSymbolSequence's elements from LastRTLCode on up."
	opcodeSymbolSequence withIndexDo:
		[:classVarName :value|
		pool
			declare: classVarName from: Undeclared;
			at: classVarName put: value + LastRTLCode - 1]
]

{ #category : #translation }
CogAbstractInstruction class >> instVarNamesAndTypesForTranslationDo: aBinaryBlock [
	"Enumerate aBinaryBlock with the names and C type strings for the inst vars to include in an AbstractInstruction struct."
	"(CogAbstractInstruction withAllSubclasses reject: [:c| c name includesSubString: 'ForTests']) do:
		[:c| Transcript print: c; cr. c printTypedefOn: Transcript]"
	(self filteredInstVarNames copyWithout: 'machineCode'), #('machineCode') do:
		[:ivn|
		 aBinaryBlock
			value: ivn
			value: (ivn caseOf: {
						['address']			-> [#usqInt]. "usqInt is always large enough to contain a pointer; we do not need to use usqIntptr_t"
						['machineCode']	-> [self machineCodeDeclaration].
						['operands']		-> [{#usqInt. '[', NumOperands printString, ']'}].
						['dependent']		-> ['struct _AbstractInstruction *']}
					otherwise:
						[#'unsigned char'])]
]

{ #category : #testing }
CogAbstractInstruction class >> isAbstract [
	^self == CogAbstractInstruction
]

{ #category : #translation }
CogAbstractInstruction class >> isAccessor: aSelector [
	^(#(cogit coInterpreter objectMemory) includes: aSelector) not
	   and: [super isAccessor: aSelector]
]

{ #category : #testing }
CogAbstractInstruction class >> isRISCTempRegister: reg [
	"For tests to filter-out bogus values left in the RISCTempRegister, if any."
	^self subclassResponsibility
]

{ #category : #'accessing class hierarchy' }
CogAbstractInstruction class >> literalsManagerClass [
	"Answer the manager that generates in-line literals;
	 subclasses that use out-of-line literals override."
	^InLineLiteralsManager
]

{ #category : #printing }
CogAbstractInstruction class >> localNameForOpcode: opcode [
	^(self classPool keyAtValue: opcode ifAbsent: nil)
		ifNotNil: [:opcodeName| opcodeName]
		ifNil: [self == CogAbstractInstruction
				ifTrue: [opcode printString]
				ifFalse: [superclass localNameForOpcode: opcode]]
]

{ #category : #translation }
CogAbstractInstruction class >> machineCodeDeclaration [
	"Answer a dummy declaration.  Subclasses will override to provide the real one."
	^#(#'unsigned char' '[4]')
]

{ #category : #translation }
CogAbstractInstruction class >> moduleName [
	"CogAbstractInstruction subclasses collect: [:ea| ea moduleName]"
	^'cogit', self ISA
]

{ #category : #'debug printing' }
CogAbstractInstruction class >> nameForOpcode: opcode [ "<Integer>"
	^(CogRTLOpcodes nameForOpcode: opcode)
		ifNotNil:
			[:opcodeName| opcodeName]
		ifNil:
			[self localNameForOpcode: opcode]
]

{ #category : #'debug printing' }
CogAbstractInstruction class >> printFormatForOpcodeName: opcodeName [
	"Answer a sequence of $r, $f or nil for the operands in the opcode, used for printing, where
	 r => integer register, f => floating point register, and nil => numeric or address operand.
	 Subclasses can override to provide a format string for their own private opcodes."
	^#()
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg [
	^Cogit basicNew registerMaskFor: reg
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 and: reg3 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2 and: reg3
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2 and: reg3 and: reg4
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 and: reg7 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 and: reg7
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 and: reg7 and: reg8 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 and: reg7 and: reg8
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 and: reg7 and: reg8 and: reg9 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 and: reg7 and: reg8 and: reg9
]

{ #category : #'register management' }
CogAbstractInstruction class >> registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 and: reg7 and: reg8 and: reg9 and: reg10 [
	^Cogit basicNew registerMaskFor: reg1 and: reg2 and: reg3 and: reg4 and: reg5 and: reg6 and: reg7 and: reg8 and: reg9 and: reg10
]

{ #category : #translation }
CogAbstractInstruction class >> requiredMethodNames: options [
	^self selectors reject:
		[:s| | m |
		(self isAccessor: s)
		or: [((m := self compiledMethodAt: s) isQuick and: [m pragmas isEmpty])
		or: [(m pragmaAt: #doNotGenerate) notNil
		or: [(m pragmaAt: #inline:) notNil and: [(m pragmaAt: #inline:) arguments first == true]]]]]
]

{ #category : #verification }
CogAbstractInstruction class >> specificOpcodes [
	^self subclassResponsibility
]

{ #category : #translation }
CogAbstractInstruction class >> structTypeName [
	^'AbstractInstruction'
]

{ #category : #translation }
CogAbstractInstruction class >> translateableSubclassesAndOptions [
	"CogAbstractInstruction translateableSubclassesAndOptions"
	| translateableSubclassesAndOptions |
	translateableSubclassesAndOptions := OrderedCollection new.
	self subclasses do:
		[:subclass|
		subclass ifTranslateableAddWithOptionsTo: translateableSubclassesAndOptions].
	^translateableSubclassesAndOptions sort:
		[:a :b|
		a first name < b first name
		or: [a first name = b first name "If equal, sort on the ABI"
			and: [a last last < b last last]]]
]

{ #category : #translation }
CogAbstractInstruction class >> typeForSelf [
	"Answer the type to give self if appropriate, or nil if not.
	 In C all subclasses are mapped to the AbstractInstruction type."
	^#'AbstractInstruction *'
]

{ #category : #verification }
CogAbstractInstruction class >> unimplementedOpcodes [
	"Check computeMaximumSize and dispatchConcretize for unimplemented opcodes."
	"self subclasses collect: [:compiler| {compiler. compiler unimplementedOpcodes}]"
	| opcodes cmsLiterals dcLiterals |
	opcodes := CogRTLOpcodes opcodes, self specificOpcodes.
	cmsLiterals := (self >> #computeMaximumSize) literals
						select: [:l| l isVariableBinding]
						thenCollect: [:l| l key].
	dcLiterals := (self >> #dispatchConcretize) literals
						select: [:l| l isVariableBinding]
						thenCollect: [:l| l key].
	^Dictionary new
		at: #computeMaximumSize put: (opcodes reject: [:opcode| cmsLiterals includes: opcode]);
		at: #dispatchConcretize put: (opcodes reject: [:opcode| dcLiterals includes: opcode]);
		yourself
]

{ #category : #verification }
CogAbstractInstruction class >> usedUnimplementedOpcodes [
	"Check for uses of unimplemented opcodes"
	"self subclasses collect: [:compiler| {compiler. compiler usedUnimplementedOpcodes}]"
	| genericUnimplementedOpcodeBindings specificUnimplementedOpcodeBindings |
	genericUnimplementedOpcodeBindings := Set new.
	specificUnimplementedOpcodeBindings := Set new.
	self unimplementedOpcodes do:
		[:arrayOfOpcodes|
		arrayOfOpcodes do:
			[:opcode|
			(self bindingOf: opcode)
				ifNotNil: [:b| specificUnimplementedOpcodeBindings add: b]
				ifNil: [genericUnimplementedOpcodeBindings add: (CogRTLOpcodes bindingOf: opcode)]]].
	^ { (SystemNavigation new allCallsOn: genericUnimplementedOpcodeBindings localToPackage: #VMMaker)
			inject: Set new
			into:  [:them :methodRef| "These should be in Cogit's abstract instructions category"
				them
					addAll: (SystemNavigation new allCallsOn: methodRef method selector localToPackage: #VMMaker);
					yourself].
		SystemNavigation new allCallsOn: specificUnimplementedOpcodeBindings localToPackage: #VMMaker }
]

{ #category : #translation }
CogAbstractInstruction class >> wordSize [
	"Answer either 4 or 8 depending on the processor's basic architacture."
	self subclassResponsibility
]

{ #category : #comparing }
CogAbstractInstruction >> <= anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^false]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) <= (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #comparing }
CogAbstractInstruction >> > anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^true]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) > (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #comparing }
CogAbstractInstruction >> >= anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^true]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) >= (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #accessing }
CogAbstractInstruction >> addDependent: anInstruction [
	<var: #anInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	dependent ifNotNil:
		[anInstruction dependent: dependent].
	^dependent := anInstruction
]

{ #category : #accessing }
CogAbstractInstruction >> address [
	^address
]

{ #category : #accessing }
CogAbstractInstruction >> address: theAddress [
	^address := theAddress
]

{ #category : #accessing }
CogAbstractInstruction >> annotation [
	^annotation
]

{ #category : #accessing }
CogAbstractInstruction >> annotation: aByte [
	self assert: (annotation isNil or: [annotation = aByte]).
	^annotation := aByte
]

{ #category : #coercion }
CogAbstractInstruction >> asInteger [
	<doNotGenerate>
	^self
]

{ #category : #coercion }
CogAbstractInstruction >> asIntegerPtr [
	<doNotGenerate>
	^self
]

{ #category : #coercion }
CogAbstractInstruction >> asUnsignedInteger [
	<doNotGenerate>
	^self
]

{ #category : #coercion }
CogAbstractInstruction >> asUnsignedIntegerPtr [
	<doNotGenerate>
	^self
]

{ #category : #'register allocation' }
CogAbstractInstruction >> availableFloatRegisterOrNoneFor: liveRegsMask [
	"Answer an unused abstract register in the liveRegMask.
	 Subclasses with more registers can override to answer them."
	<returnTypeC: #sqInt>
	(liveRegsMask anyMask: (cogit registerMaskFor: DPFPReg0)) ifFalse:
		[^DPFPReg0].
	(liveRegsMask anyMask: (cogit registerMaskFor: DPFPReg1)) ifFalse:
		[^DPFPReg1].
	(liveRegsMask anyMask: (cogit registerMaskFor: DPFPReg2)) ifFalse:
		[^DPFPReg2].
	(liveRegsMask anyMask: (cogit registerMaskFor: DPFPReg3)) ifFalse:
		[^DPFPReg3].
	(liveRegsMask anyMask: (cogit registerMaskFor: DPFPReg4)) ifFalse:
		[^DPFPReg4].
	(liveRegsMask anyMask: (cogit registerMaskFor: DPFPReg5)) ifFalse:
		[^DPFPReg5].
	(liveRegsMask anyMask: (cogit registerMaskFor: DPFPReg6)) ifFalse:
		[^DPFPReg6].
	(liveRegsMask anyMask: (cogit registerMaskFor: DPFPReg7)) ifFalse:
		[^DPFPReg7].

	^ NoReg
]

{ #category : #'register allocation' }
CogAbstractInstruction >> availableRegisterOrNoneFor: liveRegsMask [
	"Answer an unused abstract register in the liveRegMask.
	 Subclasses with more registers can override to answer them.
	 N.B. Do /not/ allocate TempReg."
	<returnTypeC: #sqInt>
	(cogit register: Arg1Reg isInMask: liveRegsMask) ifFalse:
		[^Arg1Reg].
	(cogit register: Arg0Reg isInMask: liveRegsMask) ifFalse:
		[^Arg0Reg].
	(cogit register: SendNumArgsReg isInMask: liveRegsMask) ifFalse:
		[^SendNumArgsReg].
	(cogit register: ClassReg isInMask: liveRegsMask) ifFalse:
		[^ClassReg].
	(cogit register: ReceiverResultReg isInMask: liveRegsMask) ifFalse:
		[^ReceiverResultReg].
	^NoReg
]

{ #category : #accessing }
CogAbstractInstruction >> bcpc [
	^bcpc
]

{ #category : #accessing }
CogAbstractInstruction >> bcpc: theBcpc [
	^bcpc := theBcpc
]

{ #category : #comparing }
CogAbstractInstruction >> between: min and: max [
	"Support for CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	(min isInteger and: [max isInteger]) ifTrue:
		[^false].
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self)
		between: (opcodesArray identityIndexOf: min)
		and: (opcodesArray identityIndexOf: max)
]

{ #category : #testing }
CogAbstractInstruction >> byteReadsZeroExtend [
	"Answer if a byte read, via MoveAbR, MoveMbrR, or MoveXbrRR zero-extends
	 into the full register, or merely affects the least significant 8 bits of the
	 the register.  By default the code generator assumes that byte reads
	 to not zero extend.  Note that byte reads /must not/ sign extend."
	^false
]

{ #category : #accessing }
CogAbstractInstruction >> cResultRegister [
	"Answer the register through which C funcitons return integral results."
	<inline: true>
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> cStackPointer [
	
	"Return the SP register for the current platform used by C code"
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> callInstructionByteSize [
	self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canDivQuoRem [
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canMulRR [
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canPushPopMultipleRegisters [
	<inline: true>
	^false
]

{ #category : #testing }
CogAbstractInstruction >> canSignExtend [
	"Answer if the processor provides native sign extension instructions.  If it does it must be able to generate
		SignExtend8RR SignExtend16RR
	 and if 64-bits, SignExtend32RR."
	<inline: true>
	^false
]

{ #category : #testing }
CogAbstractInstruction >> canZeroExtend [
	"Answer if the processor provides native zero extension instructions.  If it does it must be able to generate
		ZeroExtend8RR ZeroExtend16RR
	 and if 64-bits, ZeroExtend32RR."
	<inline: true>
	^false
]

{ #category : #initialization }
CogAbstractInstruction >> cloneLiteralFrom: existingLiteral [
	"For out-of-line literal support, clone a literal from a literal."
	<var: 'existingLiteral' type: #'AbstractInstruction *'>
	self assert: (existingLiteral opcode = Literal and: [dependent isNil and: [address isNil]]).
	opcode := Literal.
	annotation := existingLiteral annotation.
	operands
		at: 0 put: (existingLiteral operands at: 0);
		at: 1 put: (existingLiteral operands at: 1);
		at: 2 put: (existingLiteral operands at: 2)
]

{ #category : #accessing }
CogAbstractInstruction >> cmpC32RTempByteSize [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> codeGranularity [
	"Answer the size in bytes of a unit of machine code."
	<inline: true>
	^self subclassResponsibility
]

{ #category : #initialization }
CogAbstractInstruction >> cogit: aCogit [
	<doNotGenerate>
	cogit := aCogit.
	objectMemory := aCogit objectMemory
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> computeJumpTargetOffsetPlus: anPCOffset [
	<inline: true> "Since it's an extraction from other methods."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := self jumpTargetAddress.
	^jumpTarget signedIntFromLong - (address + anPCOffset) signedIntFromLong.
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeAt: actualAddress [
	"Generate concrete machine code for the instruction at actualAddress,
	 setting machineCodeSize, and answer the following address."

	address := actualAddress.
	self dispatchConcretize.
	self assert: (maxSize = nil or: [maxSize >= machineCodeSize]).
	^actualAddress + machineCodeSize
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFill32 [
	"fill with operand 0 according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeLabel [
	<inline: true>
	<var: #dependentChain type: #'AbstractInstruction *'>
	| dependentChain |
	dependentChain := dependent.
	[dependentChain isNil] whileFalse:
		[dependentChain updateLabel: self.
		 dependentChain := dependentChain dependent].
	^machineCodeSize := 0
]

{ #category : #'as yet unclassified' }
CogAbstractInstruction >> concretizeMovePatcheableC32R [
	"Move a 32 bit literal to a register.
	This is patcheable instruction so it needs to be a fixed size instruction.
	Subclasses decide to store the literal in many instructions or use a literal, depending on the literal manager strategy.
	
	This instruction generator should never try to generate compact instructions, even if possible.
	Or it should complete the size with NOPs"
	self subclassResponsibility 
]

{ #category : #accessing }
CogAbstractInstruction >> dependent [
	^dependent
]

{ #category : #accessing }
CogAbstractInstruction >> dependent: anInstruction [
	^dependent := anInstruction
]

{ #category : #'full transfer run-time support' }
CogAbstractInstruction >> disassemble [
	<doNotGenerate>
	self disassembleOn: Transcript
]

{ #category : #'full transfer run-time support' }
CogAbstractInstruction >> disassembleOn: aStream [
	<doNotGenerate>
	cogit processor
		disassembleFrom: 0
		to: machineCodeSize - 1
		in: machineCode object
		on: aStream
]

{ #category : #abi }
CogAbstractInstruction >> fullCallsAreRelative [
	"Answer if CallFull and/or JumpFull are relative and hence need relocating on method
	 compation. If so, they are annotated with IsRelativeCall in methods and relocated in
	 relocateIfCallOrMethodReference:mcpc:delta:"
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genAlignCStackSavingRegisters: regMask numArgs: numArgs wordAlignment: alignment [
	<inline: true>
	| regMaskCopy numRegsPushed wordsPushedModAlignment delta |
	<var: 'regMaskCopy' type: #usqInt>
	regMaskCopy := regMask asUnsignedInteger.
	numRegsPushed := 0.
	[regMaskCopy ~= 0] whileTrue:
		[numRegsPushed := numRegsPushed + (regMaskCopy bitAnd: 1).
		 regMaskCopy := regMaskCopy bitShift: -1].
	(numRegsPushed = 0
	 and: [self numIntRegArgs >= numArgs]) ifTrue:
		[^0].
	wordsPushedModAlignment := numRegsPushed + numArgs \\ alignment.
	wordsPushedModAlignment ~= 0 ifTrue:
		[delta := alignment - wordsPushedModAlignment.
		 cogit SubCq: delta * objectMemory wordSize R: SPReg].
	^0
]

{ #category : #abi }
CogAbstractInstruction >> genCaptureCStackPointers: captureFramePointer [

	self hasVarBaseRegister ifTrue:
		[cogit
			PushR: VarBaseReg;
			MoveCq: cogit varBaseAddress R: VarBaseReg].
	captureFramePointer ifTrue:
		[cogit MoveR: FPReg Aw: cogit cFramePointerAddress].
	"Capture the stack pointer prior to the call.  If we've pushed VarBaseReg take that into account."
	(self leafCallStackPointerDelta ~= 0
	 or: [self hasVarBaseRegister])
		ifTrue:
			[cogit MoveR: self cStackPointer R: TempReg.
			 cogit AddCq: (self hasVarBaseRegister
							ifTrue: [self leafCallStackPointerDelta + objectMemory wordSize]
							ifFalse: [self leafCallStackPointerDelta]) R: TempReg.
			 cogit MoveR: TempReg Aw: cogit cStackPointerAddress]
		ifFalse: [cogit MoveR: self cStackPointer Aw: cogit cStackPointerAddress].
	self hasVarBaseRegister ifTrue:
		[cogit PopR: VarBaseReg].
	cogit RetN: 0.
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPGreater: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPGreater operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPGreaterOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPGreaterOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPLess: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPLess operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPLessOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPLessOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPNotEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPNotEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpMultiplyOverflow: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit JumpOverflow: jumpTarget
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadCStackPointer [
	"Load the stack pointer register with that of the C stack, effecting
	 a switch to the C stack.  Used when machine code calls into the
	 CoInterpreter run-time (e.g. to invoke interpreter primitives)."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadCStackPointers [
	"Load the frame and stack pointer registers with those of the C stack,
	 effecting a switch to the C stack.  Used when machine code calls into
	 the CoInterpreter run-time (e.g. to invoke interpreter primitives)."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadStackPointers [
	"Switch back to the Smalltalk stack. Assign SPReg first
	 because typically it is used immediately afterwards."
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genMarshallNArgs: numArgs arg: regOrConst0 arg: regOrConst1 arg: regOrConst2 arg: regOrConst3 [
	"Generate the code to pass up to four arguments in a C run-time call.  Hack: each argument is
	 either a negative number, which encodes a constant, or a non-negative number, that of a register.

	 Run-time calls have no more than four arguments, so chosen so that on ARM, where in its C ABI the
	 first four integer arguments are passed in registers, all arguments can be passed in registers.  We
	 defer to the back end to generate this code not so much that the back end knows whether it uses
	 the stack or registers to pass arguments (it does, but...). In fact we defer for an extremely evil reason.
	 Doing so allows the x64 (where up to 6 args are passed) to assign the register arguments in an order
	 that allows some of the argument registers to be used for specific abstract  registers, specifically
	 ReceiverResultReg and ClassReg.  This is evil, evil, evil, but also it's really nice to keep using the old
	 register assignments the original author has grown accustomed to."
	<inline: true>
	^self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genMarshallNArgs: numArgs floatArg: regOrConst0 floatArg: regOrConst1 floatArg: regOrConst2 floatArg: regOrConst3 [
	"Generate the code to pass up to four arguments in a C run-time call.  Hack: each argument is
	 either a negative number, which encodes a constant, or a non-negative number, that of a register.

	 Run-time calls have no more than four arguments, so chosen so that on ARM, where in its C ABI the
	 first four integer arguments are passed in registers, all arguments can be passed in registers.  We
	 defer to the back end to generate this code not so much that the back end knows whether it uses
	 the stack or registers to pass arguments (it does, but...). In fact we defer for an extremely evil reason.
	 Doing so allows the x64 (where up to 6 args are passed) to assign the register arguments in an order
	 that allows some of the argument registers to be used for specific abstract  registers, specifically
	 ReceiverResultReg and ClassReg.  This is evil, evil, evil, but also it's really nice to keep using the old
	 register assignments the original author has grown accustomed to."
	<inline: true>
	^self subclassResponsibility
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genMulR: regSource R: regDest [
	"Generate whatever code necessary to do a bytesPerOop x bytesPerOop multiplication,
	 answering the first instruction uin the sequence."
	<returnTypeC: #'AbstractInstruction *'>
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genPushRegisterArgsForAbortMissNumArgs: numArgs [
	"Ensure that the register args are pushed before the outer and
	 inner retpcs at an entry miss for arity <= self numRegArgs.  The
	 outer retpc is that of a call at a send site.  The inner is the call
	 from a method or PIC abort/miss to the trampoline."

	"This won't be as clumsy on a RISC.  But putting the receiver and
	 args above the return address means the CoInterpreter has a
	 single machine-code frame format which saves us a lot of work."

	"Iff there are register args convert
		base	->	outerRetpc		(send site retpc)
		sp		->	innerRetpc		(PIC abort/miss retpc)
	 to
		base	->	receiver
					(arg0)
					(arg1)
					outerRetpc
		sp		->	innerRetpc		(PIC abort/miss retpc)"
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genPushRegisterArgsForNumArgs: numArgs scratchReg: scratchReg [
	"Ensure that the register args are pushed before the retpc for arity <= self numRegArgs.
	 This isn't as clumsy on a RISC.  But putting the receiver and
	 args above the return address means the CoInterpreter has a
	 single machine-code frame format which saves us a lot of work."

	"Iff there are register args convert
		sp		->	retpc		(send site retpc)
	 to
		base	->	receiver
					(arg0)
					(arg1)
		sp		->	retpc		(send site retpc)"
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genSaveStackPointers [
	"Save the frame and stack pointer registers to the framePointer
	 and stackPointer variables.  Used to save the machine code frame
	 for use by the run-time when calling into the CoInterpreter run-time."
	self subclassResponsibility
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genSubstituteReturnAddress: retpc [
	"Fake the return address for a call/jump so that the ``call'' returns
	 to retpc given that the ``call'' will be made by a following jump."
	self subclassResponsibility
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genSwapR: regA R: regB Scratch: regTmp [
	"Generic register swap code.  Subclasses for processors that have a true exchange operation will override to use it."
	| first |
	<var: 'first' type: #'AbstractInstruction *'>
	first :=
	cogit MoveR: regA R: regTmp.
	cogit MoveR: regB R: regA.
	cogit MoveR: TempReg R: regB.
	^first
]

{ #category : #abi }
CogAbstractInstruction >> genWriteCResultIntoReg: abstractRegister [
	| cResultReg |
	cResultReg := self cResultRegister.
	abstractRegister ~= cResultReg ifTrue:
		[cogit gen: MoveRR operand: cResultReg operand: abstractRegister]
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> generateICacheFlush [
	"A dummy routine.
	 Processors that can generate code to flush the icache can override."

]

{ #category : #'multi-threading' }
CogAbstractInstruction >> generateLowLevelTryLock: vmOwnerLockAddress [
	self subclassResponsibility
]

{ #category : #'multi-threading' }
CogAbstractInstruction >> generateLowLevelUnlock: vmOwnerLockAddress [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> getDefaultCogCodeSize [
	"Answer the default number of bytes to allocate for native code at startup.
	 The actual value can be set via vmParameterAt: and/or a preference in the ini file.
	 Subclasses may this default override to arrange that the code zone has about
	 the same number of methods as the x86 back-end at a similar point in execution."
	<inline: true>
	^1024 * 1024
]

{ #category : #accessing }
CogAbstractInstruction >> getJmpTarget [
	"Get the target of a jump instruction.  Jumps have the target in the first operand."
	<inline: true>
	^cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'
]

{ #category : #testing }
CogAbstractInstruction >> hasConditionRegister [
	"Answer if the receiver supports, e.g., JumpOverflow after a regular AddRR"
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasDoublePrecisionFloatingPointSupport [
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasLinkRegister [
	"Answer if the processor has a link register, i.e. if calls pass
	 the return pc in a register instead of pushing it on a stack."
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasPCRegister [
	"Answer if the processor has a generally addressable pc register, such as the ARM.
	 On such processors we can execute jumping to pop top of stack by popping into
	 the pc register.  Note that this is not a generic RISC feature.  The PowerPC does not
	 allow one to pop into the pc for example.  So by default, answer false."
	^false
]

{ #category : #testing }
CogAbstractInstruction >> hasThreeAddressArithmetic [
	"Answer if the receiver supports three-address arithmetic instructions (currently only AndCqRR)"
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasVarBaseRegister [
	"Answer if the processor has a dedicated callee-saved register to point to
	 the base of commonly-accessed variables. By default this is false."
	^false
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> inCurrentCompilation: operand [
	"Answer if operand is in the current compilation; and henced could be a candidate for pc-relative addressing."
	<inline: true>
	^(self isAnInstruction: (cogit cCoerceSimple: operand to: #'AbstractInstruction *')) "i.e. a label, which by definition will be in the current compilation."
	   or: [cogit addressIsInCurrentCompilation: operand]
]

{ #category : #initialization }
CogAbstractInstruction >> initialize [
	"This method intializes the Smalltalk instance.  The C instance is merely a struct and doesn't need initialization."
	<doNotGenerate>
	operands := CArrayAccessor on: (Array new: NumOperands).
	machineCode := CArrayAccessor on: (ByteArray new: self machineCodeBytes)
]

{ #category : #initialization }
CogAbstractInstruction >> initializeSharableLiteral: literal [
	"For out-of-line literal support, initialize a sharable literal."
	opcode := Literal.
	annotation := nil. "separate := nil for Slang"
	address := nil.
	dependent := nil.
	operands
		at: 0 put: literal;
		at: 1 put: true;		"isSharable/isUnique not"
		at: 2 put: -1			"opcodeIndex"
]

{ #category : #initialization }
CogAbstractInstruction >> initializeUniqueLiteral: literal [
	"For out-of-line literal support, initialize an unsharable literal."
	opcode := Literal.
	annotation := nil. "separate := nil for Slang"
	address := nil.
	dependent := nil.
	operands
		at: 0 put: literal;
		at: 1 put: false;		"isSharable/isUnique not"
		at: 2 put: -1			"opcodeIndex"
]

{ #category : #disassembly }
CogAbstractInstruction >> instructionSizeAt: pc [
	"Answer the instruction size at pc. This is used in method disassembly
	 to decode the jumps in block dispatch to discover where block methods
	 occur within a larger method."
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isAFixup: fixupOrAddress [
	<var: #fixupOrAddress type: #'void *'>
	<inline: true>
	^cogit addressIsInFixups: fixupOrAddress
]

{ #category : #testing }
CogAbstractInstruction >> isAnInstruction: addressOrInstruction [
	<var: #addressOrInstruction type: #'AbstractInstruction *'>
	<inline: true>
	^(cogit addressIsInInstructions: addressOrInstruction)
	  or: [addressOrInstruction == cogit methodLabel]
]

{ #category : #testing }
CogAbstractInstruction >> isBigEndian [
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isCallPrecedingReturnPC: mcpc [
	"Assuming mcpc is a send return pc answer if the instruction before it is a call (not a CallFull)."
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isJump [
	^opcode between: FirstJump and: LastJump
]

{ #category : #testing }
CogAbstractInstruction >> isLiteral [

	^ opcode = Literal
]

{ #category : #testing }
CogAbstractInstruction >> isPCDependent [
	"Answer if the receiver is a pc-dependent instruction, such as a relative jump."
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isWithinMwOffsetRange: anAddress [
	"Answer if an address can be accessed using the offset in a MoveMw:r:R: or similar instruction.
	 We assume this is true for 32-bit processors and expect 64-bit processors to answer false
	 for values in the interpreter or the object memory."

	^true
]

{ #category : #accessing }
CogAbstractInstruction >> jmpTarget: anAbstractInstruction [
	"Set the target of a jump instruction.  These all have the target in the first operand."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #anAbstractInstruction type: #'AbstractInstruction *'>
	self cCode: [] "check for inadvertent smashing of already-set jmpTargets; development only"
		inSmalltalk: [self assert: ((operands at: 0)
									ifNil: [true]
									ifNotNil: [:o|
											o = 0
											or: [(self isAFixup: o)
											or: [self isAnInstruction: anAbstractInstruction]]])].
	operands at: 0 put: anAbstractInstruction asUnsignedInteger.
	^anAbstractInstruction
]

{ #category : #accessing }
CogAbstractInstruction >> jumpLongByteSize [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jumpLongConditionalByteSize [
	self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> jumpLongConditionalTargetBeforeFollowingAddress: mcpc [
	"Extract the target from a long conditional jump.  On many ISAs this si the same as
	 extracting the target from a long unconditional jump, so we provide the default here.
	 Processors such as MIPS override as appropriate."
	<inline: true>
	^self jumpLongTargetBeforeFollowingAddress: mcpc
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> jumpLongTargetBeforeFollowingAddress: mcpc [
	^self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jumpShortByteSize [
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> jumpTargetAddress [
	<inline: true> "Since it's an extraction from other methods."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'.
	cogit assertSaneJumpTarget: jumpTarget.
	(self isAnInstruction: jumpTarget) ifTrue:
		[jumpTarget := cogit cCoerceSimple: jumpTarget address to: #'AbstractInstruction *'].
	self assert: jumpTarget ~= 0.
	^jumpTarget
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> labelOffset [
	"Hack:  To arrange that the block method field pushed in a block entry has
	 its MFMethodFlagIsBlockFlag bit set we provide labels with an offset.  The
	 offset for the fakeHeader reference is MFMethodFlagIsBlockFlag.  See
	 compileBlockFrameBuild:"
	<inline: true>
	^operands at: 1
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> literal32BeforeFollowingAddress: followingAddress [
	"Answer the constant loaded by the instruction sequence just before this address:"
	<inline: true>
	^ self literalBeforeFollowingAddress: followingAddress
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> literalBeforeFollowingAddress: followingAddress [
	"Answer the constant loaded by the instruction sequence just before this address:"
	^self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> loadLiteralByteSize [
	"Answer the byte size of a MoveCwR opcode's corresponding machine code"
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> loadPICLiteralByteSize [
	"Answer the byte size of a MoveCwR opcode's corresponding machine code
	 when the argument is a PIC.  This is for the self-reference at the end of a
	 closed PIC."
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> longJumpTargetAddress [
	<inline: true> "Since it's an extraction from other methods."
	"This needs to be different from jumpTargetAddress because long jumps can
	be to absolute addresses and hence we can't assert that the jump target is sane."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'.
	(self isAnInstruction: jumpTarget) ifTrue:
		[jumpTarget := cogit cCoerceSimple: jumpTarget address to: #'AbstractInstruction *'].
	self assert: jumpTarget ~= 0.
	^jumpTarget
]

{ #category : #accessing }
CogAbstractInstruction >> machineCode [
	^machineCode
]

{ #category : #accessing }
CogAbstractInstruction >> machineCode: anObject [
	"Set the value of machineCode"

	machineCode := anObject
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> machineCodeBytes [
	"Answer the maximum number of bytes of machine code generated for any abstract instruction."
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> machineCodeSize [
	"N.B. This is a byte size."
	^machineCodeSize
]

{ #category : #accessing }
CogAbstractInstruction >> machineCodeSize: size [ "<signed byte>"
	"N.B. This is a byte size."
	^machineCodeSize := size
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> mapEntryAddress [
	"Typically map entries apply to the end of an instruction, for two reasons:
	  a)	to cope with literals embedded in variable-length instructions, since, e.g.
		on x86, the literal typically comes at the end of the instruction.
	  b)	in-line cache detection is based on return addresses, which are typically
		to the instruction following a call."
	<inline: true>
	^address + machineCodeSize
]

{ #category : #accessing }
CogAbstractInstruction >> maxSize [
	"N.B. This is a byte size."
	^maxSize
]

{ #category : #accessing }
CogAbstractInstruction >> maxSize: size [ "<signed byte>"
	"N.B. This is a byte size."
	maxSize := size
]

{ #category : #printing }
CogAbstractInstruction >> nameForFPRegister: reg [ "<Integer>"
	"subclasses with special purpose registers may need to override."
	<doNotGenerate>
	^CogAbstractRegisters nameForFPRegister: reg
]

{ #category : #printing }
CogAbstractInstruction >> nameForRegister: reg [ "<Integer>"
	"subclasses with special purpose registers may need to override."
	<doNotGenerate>
	^CogAbstractRegisters nameForRegister: reg
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> noteFollowingConditionalBranch: branch [
	"Support for processors without condition codes, such as the MIPS.
	 Answer the branch opcode.  If there are no condition codes, modify
	 the receiver and the branch to implement a suitable conditional
	 branch that doesn't depend on condition codes being set by the
	 receiver.  By default a noop. Overridden in subclasses as required."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #branch type: #'AbstractInstruction *'>
	<inline: true>
	^branch
]

{ #category : #initialization }
CogAbstractInstruction >> numCheckFeaturesOpcodes [
	"If the priocessor has a feature check facility answer the number
	 of opcodes required to compile an accessor for the feature."
	^0
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> numICacheFlushOpcodes [
	"If the processor has the ablity to generate code to flush the icache answer
	 the number of opcodes required to compile an accessor for the feature."
	^0
]

{ #category : #accessing }
CogAbstractInstruction >> numIntRegArgs [
	^self subclassResponsibility
]

{ #category : #'multi-threading' }
CogAbstractInstruction >> numLowLevelLockOpcodes [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> opcode [
	^opcode
]

{ #category : #accessing }
CogAbstractInstruction >> opcode: value [
	^opcode := value
]

{ #category : #accessing }
CogAbstractInstruction >> operand0: operand [
	<inline: true>
	operands at: 0 put: operand
]

{ #category : #accessing }
CogAbstractInstruction >> operand1: operand [
	<inline: true>
	operands at: 1 put: operand
]

{ #category : #accessing }
CogAbstractInstruction >> operand2: operand [
	<inline: true>
	operands at: 2 put: operand
]

{ #category : #accessing }
CogAbstractInstruction >> operands [
	^operands
]

{ #category : #accessing }
CogAbstractInstruction >> operands: anObject [
	"Set the value of operands"

	operands := anObject
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> outputMachineCodeAt: targetAddress [
	"By default move machine code a byte at a time
	  Subclasses with coarser granularity can override as desired."
	<inline: true>
	0 to: machineCodeSize - 1 do:
		[:j|
		objectMemory byteAt: targetAddress + j put: (machineCode at: j)]
]

{ #category : #'calling C function in Smalltalk stack' }
CogAbstractInstruction >> prepareStackToCallCFunctionInSmalltalkStack: anObject [
	
	"This is a hook to allow the backends to implement special handling when calling a C function in the Smalltalk stack"
	
	<doNotGenerate>
	self subclassResponsibility
]

{ #category : #printing }
CogAbstractInstruction >> printStateOn: aStream [
	| opcodeName orneryOperands format |
	<doNotGenerate> "Smalltalk-side only"
	opcode ifNil:
		[^self].
	aStream space; nextPut: $(; nextPutAll: (opcodeName := self class nameForOpcode: opcode).
	orneryOperands := operands isCObjectAccessor
							ifTrue: [operands object]
							ifFalse: [operands].
	format := ((CogRTLOpcodes classPool includesKey: opcodeName)
				ifTrue: [CogRTLOpcodes]
				ifFalse: [self class]) printFormatForOpcodeName: opcodeName.
	orneryOperands withIndexDo:
		[:operand :index|
		operand ifNotNil:
			[aStream space.
			 index >= (orneryOperands identityIndexOf: nil ifAbsent: [orneryOperands size + 1]) ifTrue:
				[aStream print: index - 1; nextPut: $:].
			 (format notNil and: ['rf' includes: (format at: index ifAbsent: $-)])
				ifTrue: [aStream nextPutAll: ((format at: index) = $r
												ifTrue: [self nameForRegister: operand]
												ifFalse: [self nameForFPRegister: operand])]
				ifFalse:
					[aStream print: operand.
					 (operand isInteger and: [operand > 16 and: [opcode ~= Label]]) ifTrue:
						[(operand allMask: 16r80000000) ifTrue:
							[aStream nextPut: $/; print: operand signedIntFromLong].
						 aStream nextPut: $/.
						 operand printOn: aStream base: 16]]]].
	machineCodeSize ifNotNil:
		[(machineCodeSize between: 1 and: machineCode size) ifTrue:
			[0 to: machineCodeSize - 1 by: self codeGranularity do:
				[:i|
				 aStream space.
				 (self machineCodeAt: i)
					ifNil: [aStream nextPut: $.]
					ifNotNil:
						[:mc|
						mc isInteger
							ifTrue: [mc printOn: aStream base: 16]
							ifFalse: [mc printOn: aStream]]]]].
	address ifNotNil:
		[aStream nextPut: $@.
		 address printOn: aStream base: 16].
	aStream nextPut: $)
]

{ #category : #initialization }
CogAbstractInstruction >> reinitializeOpcode [
	<inline: true>
	annotation := nil.
	dependent := nil.
	operands at: 0 put: (operands at: 1 put: (operands at: 2 put: 0))
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateCallBeforeReturnPC: retpc by: delta [
	^self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateJumpLongBeforeFollowingAddress: pc by: delta [
	"We assume here that calls and jumps look the same as regards their displacement.
	 This works on at least x86, ARM and x86_64.  Processors on which that isn't the
	 case can override as necessary."
	self relocateCallBeforeReturnPC: pc by: delta
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateJumpLongConditionalBeforeFollowingAddress: pc by: delta [
	"Relocate a long conditional jump before pc.  Default to relocating a non-conditional jump.
	 Processors that have different formats for conditional and unconditional jumps override."
	self relocateJumpLongBeforeFollowingAddress: pc by: delta
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateMethodReferenceBeforeAddress: pc by: delta [
	"On some processors the method reference is a load constant and
	 hence needs changing when methods are moved.  On others the
	 method reference is pc-relative and hence nothing needs to happen."
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> resolveJumpTarget [
	<var: #fixup type: #'BytecodeFixup *'>
	| fixup |
	self assert: self isJump.
	fixup := cogit cCoerceSimple: (operands at: 0) to: #'BytecodeFixup *'.
	self cCode: [] inSmalltalk:
		[(fixup isKindOf: CogBytecodeFixup) ifTrue:
			[self assert: (self isAFixup: fixup)]].
	(self isAFixup: fixup) ifTrue:
		[self assert: (cogit addressIsInInstructions: fixup targetInstruction).
		 self jmpTarget: fixup targetInstruction]
]

{ #category : #'calling C function in Smalltalk stack' }
CogAbstractInstruction >> returnFromCallCFunctionInSmalltalkStack: anObject [
	
	"This is a hook to allow the backends to implement special handling when calling a C function in the Smalltalk stack"
	
	<doNotGenerate>
	self subclassResponsibility
]

{ #category : #'full transfer run-time support' }
CogAbstractInstruction >> rewriteCallFullAt: callSiteReturnAddress target: callTargetAddress [
	"Rewrite a CallFull instruction to call a different target.  This variant is used to rewrite cached primitive calls.
	 Answer the extent of the code change which is used to compute the range of the icache to flush.
	 This defaults to rewriteCallAt:target:; processors that differentiate between Call and CallFull will override."
	^self rewriteCallAt: callSiteReturnAddress target: callTargetAddress
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> rewriteConditionalJumpLongAt: callSiteReturnAddress target: callTargetAddress [
	"Rewrite a conditional jump long to jump to target.  This version defaults to using
	 rewriteJumpLongAt:, which works for many ISAs.  Subclasses override if necessary."
	^self rewriteJumpLongAt: callSiteReturnAddress target: callTargetAddress
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> rewriteInlineCacheTag: cacheTag at: callSiteReturnAddress [
	"Rewrite an inline cache with a new tag.  This variant is used
	 by the garbage collector."
	self subclassResponsibility
]

{ #category : #'full transfer run-time support' }
CogAbstractInstruction >> rewriteJumpFullAt: callSiteReturnAddress target: callTargetAddress [
	"Rewrite a JumpFull instruction to jump to a different target.  This variant is used to rewrite cached primitive calls.
	 Answer the extent of the code change which is used to compute the range of the icache to flush.
	 This defaults to rewriteJumpLongAt:target:; processors that differentiate between Jump and JumpFull will override."
	^self rewriteJumpLongAt: callSiteReturnAddress target: callTargetAddress
]

{ #category : #abi }
CogAbstractInstruction >> saveAndRestoreLinkRegAround: aBlock [
	"If the processor's ABI includes a link register, generate instructions
	 to save and restore it around aBlock, which is assumed to generate code."
	<inline: true>
	self subclassResponsibility
]

{ #category : #'as yet unclassified' }
CogAbstractInstruction >> seeAlso: aString [ 
	
	<cmacro: '(self, msg) '>
	"like a flag"
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> setLabelOffset: aValue [
	"Hack:  To arrange that the block method field pushed in a block entry has
	 its MFMethodFlagIsBlockFlag bit set we provide labels with an offset.  The
	 offset for the fakeHeader reference is MFMethodFlagIsBlockFlag.  See
	 compileBlockFrameBuild:"
	<inline: true>
	^operands at: 1 put: aValue
]

{ #category : #testing }
CogAbstractInstruction >> setsConditionCodesFor: aConditionalJumpOpcode [
	"Answer if the receiver's opcode sets the condition codes correctly for the given conditional jump opcode."
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> sizePCDependentInstructionAt: eventualAbsoluteAddress [
	"Size a jump and set its address.  The target may be another instruction
	 or an absolute address.  On entry the address inst var holds our virtual
	 address. On exit address is set to eventualAbsoluteAddress, which is
	 where this instruction will be output.  The span of a jump to a following
	 instruction is therefore between that instruction's address and this
	 instruction's address ((which are both still their virtual addresses), but the
	 span of a jump to a preceding instruction or to an absolute address is
	 between that instruction's address (which by now is its eventual absolute
	 address) or absolute address and eventualAbsoluteAddress."

	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> stackPageInterruptHeadroomBytes [
	"Return a minimum amount of headroom for each stack page (in bytes).  In a
	 JIT the stack has to have room for interrupt handlers which will run on the stack."
	self subclassResponsibility
]

{ #category : #'as yet unclassified' }
CogAbstractInstruction >> stackPointerAlignment [
	
	<doNotGenerate>
	^ cogit objectMemory wordSize 
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> storeLiteral32: literal32 beforeFollowingAddress: followingAddress [
	"Answer the constant loaded by the instruction sequence just before this address:"
	<inline: true>
	self storeLiteral: literal32 beforeFollowingAddress: followingAddress
]

{ #category : #printing }
CogAbstractInstruction >> symbolic [
	<doNotGenerate> "Smalltalk-side only"
	^String streamContents: [:s| self symbolicOn: s]
]

{ #category : #printing }
CogAbstractInstruction >> symbolicOn: aStream [
	| orneryOperands |
	<doNotGenerate> "Smalltalk-side only"
	(machineCodeSize isNil
	 or: [opcode = 16rAAA]) ifTrue:
		[^aStream nextPut: 'uninitialized opcode'].
	aStream space; nextPut: $(; nextPutAll: (self class nameForOpcode: opcode).
	orneryOperands := operands isCObjectAccessor
							ifTrue: [operands object]
							ifFalse: [operands].
	orneryOperands withIndexDo:
		[:operand :index|
		operand ifNotNil:
			[aStream space.
			 index >= (orneryOperands identityIndexOf: nil ifAbsent: [orneryOperands size + 1]) ifTrue:
				[aStream print: index - 1; nextPut: $:].
			 operand class == self class
				ifTrue:
					[operand symbolicOn: aStream]
				ifFalse:
					[aStream print: operand.
					 (operand isInteger and: [operand > 16]) ifTrue:
						[(operand allMask: 16r80000000) ifTrue:
							[aStream nextPut: $/; print: operand signedIntFromLong].
						 aStream nextPut: $/.
						 operand printOn: aStream base: 16]]]].
	machineCodeSize > 0 ifTrue:
		[machineCodeSize > machineCode size
			ifTrue: [aStream nextPutAll: ' no mcode']
			ifFalse:
				[0 to: machineCodeSize - 1 by: self codeGranularity do:
					[:i|
					 aStream space.
					 (self machineCodeAt: i) printOn: aStream base: 16]]].
	aStream nextPut: $)
]

{ #category : #'memory access' }
CogAbstractInstruction >> unalignedLongAt: byteAddress [
	"Some processors need this, but word-oriented RISCs don't. Hence doNotGenerate."
	<doNotGenerate>
	^self subclassResponsibility
]

{ #category : #'memory access' }
CogAbstractInstruction >> unalignedLongAt: byteAddress put: aWord [
	"Some processors need this, but word-oriented RISCs don't. Hence doNotGenerate."
	^self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> updateLabel: labelInstruction [
	"Update an instruction that depends on a label outside
	 of generated code (e.g. a method or block header)."
	<var: #labelInstruction type: #'AbstractInstruction *'>
	<inline: true>
	self assert: (opcode = MoveCwR or: [opcode = PushCw]).
	operands at: 0 put: labelInstruction address + labelInstruction labelOffset
]

{ #category : #testing }
CogAbstractInstruction >> usesTempRegForAbsoluteLoads [
	"Answer if TempReg is used in absolute memory loads (as it is on x64).  By default answer false, allowing subclasses to override."
	<inline: true>
	^false
]

{ #category : #simulation }
CogAbstractInstruction >> wantsNearAddressFor: anObject [
	"A hack hook to allow ARM to override the simulated address for the short-cut trampolines,
	 and to allow x64 to address CStackPointer and CFramePointer relative to VarBaseReg."
	^false
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> zoneCallsAreRelative [
	"Answer if Call and JumpLong are relative and hence need to take the caller's
	 relocation delta into account during code compaction, rather than just the
	 callee's delta."
	self subclassResponsibility
]
