"
I am an abstract instruction generated by the Cogit.  I am subsequently concretized to machine code for the current processor.  A sequence of concretized CogAbstractInstructions are concatenated to form the code for a CogMethod.  I am an abstract class.  My concrete subclasses concretize to the machine code of a specific processor.

Instance Variables
	address:			<Integer>
	bcpc:				<Integer>
	cogit:				<Cogit>
	dependent:			<AbstractInstruction|nil>
	machineCode:		<CArray on: (ByteArray|Array)>
	machineCodeSize:	<Integer>
	maxSize:			<Integer>
	objectMemory:		<NewCoObjectMemory|SpurCoMemoryManager etc>
	opcode:			<Integer>
	operands:			<CArray on: Array>

address
	- the address at which the instruction will be generated

bcpc
	- the bytecode pc for which the instruction was generated; simulation only

cogit
	- the Cogit assembling the receiver; simulation only

dependent
	- a reference to another instruction which depends on the receiver, if any; in C this is a pointer

machineCode
	- the array of machine code the receiver generates when concretized

machineCodeSize
	- the size of machineCode in bytes

maxSize
	- the maximum size of machine code that the current instruction will generate, in bytes

objectMemory
	- the memory manager for the system; simulation only

opcode
	- the opcode for the receiver which defines which abstract opcode it represents; see CogRTLOpcodes class>>initialize and CogAbstractInstruction subclass initialize methods

operands
	- the array containing any operands the instruction may have; the opcode defines implicitly how many operands are consdered
"
Class {
	#name : #CogAbstractInstruction,
	#superclass : #VMStructType,
	#instVars : [
		'opcode',
		'machineCodeSize',
		'maxSize',
		'annotation',
		'machineCode',
		'operands',
		'address',
		'dependent',
		'cogit',
		'objectMemory',
		'bcpc'
	],
	#classVars : [
		'NumOperands'
	],
	#pools : [
		'CogCompilationConstants',
		'CogRTLOpcodes'
	],
	#category : #'VMMaker-JIT'
}

{ #category : #translation }
CogAbstractInstruction class >> ISA [
	"Answer the name of the ISA the receiver's subclass implements."
	^self subclassResponsibility
]

{ #category : #'simulation only' }
CogAbstractInstruction class >> byteSizeForSimulator: aVMClass [
	"Answer an approximation of the byte size of an AbstractInstruction struct.
	 This is for estimating the alloca in allocateOpcodes:bytecodes:ifFail:"
	| ptrsize |
	ptrsize := aVMClass sizeof: #'void *'.
	^CogCompilerClass instSize - 4 "cogit, objectMemory et al" * ptrsize
	+ CogCompilerClass basicNew machineCodeBytes
		roundTo: ptrsize
]

{ #category : #translation }
CogAbstractInstruction class >> defaultCompilerClass [
	^self
]

{ #category : #'instance creation' }
CogAbstractInstruction class >> for: aCogit [
	^self new cogit: aCogit
]

{ #category : #translation }
CogAbstractInstruction class >> identifyingPredefinedMacros [
	"Answer the predefined macros that identify the processors a subclass handles, if any.
	 If the subclass isn't yet ready for production (a work in progress) simply answer nil."
	^nil
]

{ #category : #'class initialization' }
CogAbstractInstruction class >> initialize [
	NumOperands := 3
]

{ #category : #translation }
CogAbstractInstruction class >> instVarNamesAndTypesForTranslationDo: aBinaryBlock [
	"enumerate aBinaryBlock with the names and C type strings for the inst vars to include in an AbstractInstruction struct."
	"{CogAbstractInstruction. CogIA32Compiler. CogARMCompiler} do:
		[:c| Transcript print: c; cr. c printTypedefOn: Transcript]"
	(self filteredInstVarNames copyWithout: 'machineCode'), #('machineCode') do:
		[:ivn|
		ivn ~= 'bcpc' ifTrue:
			[aBinaryBlock
				value: ivn
				value: (ivn caseOf: {
							['address']			-> [#'unsigned long'].
							['machineCode']	-> [self machineCodeDeclaration].
							['operands']		-> [{#'unsigned long'. '[', NumOperands, ']'}].
							['dependent']		-> ['struct _AbstractInstruction *']}
						otherwise:
							[#'unsigned char'])]]
]

{ #category : #testing }
CogAbstractInstruction class >> isAbstract [
	^self == CogAbstractInstruction
]

{ #category : #translation }
CogAbstractInstruction class >> isAccessor: aSelector [
	^(#(cogit coInterpreter objectMemory) includes: aSelector) not
	   and: [super isAccessor: aSelector]
]

{ #category : #testing }
CogAbstractInstruction class >> isConcreteRISCTempRegister: concreteRegister [
	"For tests to filter-out bogus values left in the ConcreteRISCTempRegister, if any."
	^self subclassResponsibility
]

{ #category : #'accessing class hierarchy' }
CogAbstractInstruction class >> literalsManagerClass [
	"Answer the manager that generates in-line literals;
	 subclasses that use out-of-line literals override."
	^InLineLiteralsManager
]

{ #category : #printing }
CogAbstractInstruction class >> localNameForOpcode: opcode [
	^(self classPool keyAtValue: opcode ifAbsent: nil)
		ifNotNil: [:opcodeName| opcodeName]
		ifNil: [self == CogAbstractInstruction
				ifTrue: [opcode printString]
				ifFalse: [superclass localNameForOpcode: opcode]]
]

{ #category : #translation }
CogAbstractInstruction class >> machineCodeDeclaration [
	"Answer a dummy declaration.  Subclasses will override to provgide the real one."
	^#(#'unsigned char' '[4]')
]

{ #category : #translation }
CogAbstractInstruction class >> moduleName [
	"CogAbstractInstruction subclasses collect: [:ea| ea moduleName]"
	^'cogit', self ISA
]

{ #category : #'debug printing' }
CogAbstractInstruction class >> nameForOpcode: opcode [ "<Integer>"
	^(CogRTLOpcodes nameForOpcode: opcode)
		ifNotNil:
			[:opcodeName| opcodeName]
		ifNil:
			[self localNameForOpcode: opcode]
]

{ #category : #translation }
CogAbstractInstruction class >> requiredMethodNames: options [
	^self selectors reject:
		[:s|
		(self isAccessor: s)
		or: [((self compiledMethodAt: s) pragmaAt: #doNotGenerate) notNil
		or: [((self compiledMethodAt: s) pragmaAt: #inline:) notNil
			and: [((self compiledMethodAt: s) pragmaAt: #inline:) arguments first == true]]]]
]

{ #category : #verification }
CogAbstractInstruction class >> specificOpcodes [
	^self subclassResponsibility
]

{ #category : #translation }
CogAbstractInstruction class >> structTypeName [
	^'AbstractInstruction'
]

{ #category : #translation }
CogAbstractInstruction class >> translateableSubclasses [
	"CogAbstractInstruction translateableSubclasses"
	^self subclasses select: [:compilerClass| compilerClass identifyingPredefinedMacros notNil]
]

{ #category : #translation }
CogAbstractInstruction class >> typeForSelf [
	"Answer the type to give self if appropriate, or nil if not.
	 In C all subclasses are mapped to the AbstractInstruction type."
	^#'AbstractInstruction *'
]

{ #category : #verification }
CogAbstractInstruction class >> unimplementedOpcodes [
	"Check computeMaximumSize and dispatchConcretize for unimplemented opcodes."
	"self subclasses collect: [:compiler| {compiler. compiler unimplementedOpcodes}]"
	| opcodes cmsLiterals dcLiterals |
	opcodes := CogRTLOpcodes opcodes, self specificOpcodes.
	cmsLiterals := (self >> #computeMaximumSize) literals
						select: [:l| l isVariableBinding]
						thenCollect: [:l| l key].
	dcLiterals := (self >> #dispatchConcretize) literals
						select: [:l| l isVariableBinding]
						thenCollect: [:l| l key].
	^Dictionary new
		at: #computeMaximumSize put: (opcodes reject: [:opcode| cmsLiterals includes: opcode]);
		at: #dispatchConcretize put: (opcodes reject: [:opcode| dcLiterals includes: opcode]);
		yourself
]

{ #category : #verification }
CogAbstractInstruction class >> usedUnimplementedOpcodes [
	"Check for uses of unimplemented opcodes"
	"self subclasses collect: [:compiler| {compiler. compiler usedUnimplementedOpcodes}]"
	| genericUnimplementedOpcodeBindings specificUnimplementedOpcodeBindings |
	genericUnimplementedOpcodeBindings := Set new.
	specificUnimplementedOpcodeBindings := Set new.
	self unimplementedOpcodes do:
		[:arrayOfOpcodes|
		arrayOfOpcodes do:
			[:opcode|
			(self bindingOf: opcode)
				ifNotNil: [:b| specificUnimplementedOpcodeBindings add: b]
				ifNil: [genericUnimplementedOpcodeBindings add: (CogRTLOpcodes bindingOf: opcode)]]].
	^ { (SystemNavigation new allCallsOn: genericUnimplementedOpcodeBindings localToPackage: #VMMaker)
			inject: Set new
			into:  [:them :methodRef| "These should be in Cogit's abstract instructions category"
				them
					addAll: (SystemNavigation new allCallsOn: methodRef method selector localToPackage: #VMMaker);
					yourself].
		SystemNavigation new allCallsOn: specificUnimplementedOpcodeBindings localToPackage: #VMMaker }
]

{ #category : #comparing }
CogAbstractInstruction >> <= anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^false]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) <= (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #comparing }
CogAbstractInstruction >> > anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^true]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) > (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #comparing }
CogAbstractInstruction >> >= anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^true]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) >= (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #private }
CogAbstractInstruction >> abstractRegisterForConcreteRegister: reg [
	(self concreteRegister: TempReg) = reg ifTrue: [^TempReg].
	(self concreteRegister: ReceiverResultReg) = reg ifTrue: [^ReceiverResultReg].
	(self concreteRegister: ClassReg) = reg ifTrue: [^ClassReg].
	(self concreteRegister: SendNumArgsReg) = reg ifTrue: [^SendNumArgsReg].
	(self concreteRegister: Arg0Reg) = reg ifTrue: [^Arg0Reg].
	(self concreteRegister: Arg1Reg) = reg ifTrue: [^Arg1Reg].
	(self concreteRegister: FPReg) = reg ifTrue: [^FPReg].
	(self concreteRegister: SPReg) = reg ifTrue: [^SPReg].
	self error: 'could not find abstract register'.
	^0

	"While the below works fine in Smalltalk it of course doesn't work in C ;)"
	
	"^reg caseOf: {
		[self concreteRegister: TempReg] -> [TempReg].
		[self concreteRegister: ReceiverResultReg] -> [ReceiverResultReg].
		[self concreteRegister: ClassReg] -> [ClassReg].
		[self concreteRegister: SendNumArgsReg] -> [SendNumArgsReg].
		[self concreteRegister: Arg0Reg] -> [Arg0Reg].
		[self concreteRegister: Arg1Reg] -> [Arg1Reg].
		[self concreteRegister: FPReg] -> [FPReg].
		[self concreteRegister: SPReg] -> [SPReg] }"
]

{ #category : #accessing }
CogAbstractInstruction >> addDependent: anInstruction [
	<var: #anInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	dependent notNil ifTrue:
		[anInstruction dependent: dependent].
	^dependent := anInstruction
]

{ #category : #accessing }
CogAbstractInstruction >> address [
	^address
]

{ #category : #accessing }
CogAbstractInstruction >> address: theAddress [
	^address := theAddress
]

{ #category : #accessing }
CogAbstractInstruction >> annotation [
	^annotation
]

{ #category : #accessing }
CogAbstractInstruction >> annotation: aByte [
	self assert: (annotation isNil or: [annotation = aByte]).
	^annotation := aByte
]

{ #category : #coercion }
CogAbstractInstruction >> asInteger [
	<doNotGenerate>
	^self
]

{ #category : #coercion }
CogAbstractInstruction >> asUnsignedInteger [
	<doNotGenerate>
	^self
]

{ #category : #'register allocation' }
CogAbstractInstruction >> availableRegisterOrNilFor: liveRegsMask [
	"Answer an unused abstract register in the liveRegMask.
	 Subclasses with more registers can override to answer them."
	<returnTypeC: #sqInt>
	self flag: 'searching physical registers that are not assigned to abstract registers first will do a better job and allocate with fewer conflicts'.
	(cogit register: Arg1Reg isInMask: liveRegsMask) ifFalse:
		[^Arg1Reg].
	(cogit register: Arg0Reg isInMask: liveRegsMask) ifFalse:
		[^Arg0Reg].
	(cogit register: SendNumArgsReg isInMask: liveRegsMask) ifFalse:
		[^SendNumArgsReg].
	(cogit register: ClassReg isInMask: liveRegsMask) ifFalse:
		[^ClassReg].
	(cogit register: ReceiverResultReg isInMask: liveRegsMask) ifFalse:
		[^ReceiverResultReg].
	^nil
]

{ #category : #accessing }
CogAbstractInstruction >> bcpc [
	^bcpc
]

{ #category : #accessing }
CogAbstractInstruction >> bcpc: theBcpc [
	^bcpc := theBcpc
]

{ #category : #comparing }
CogAbstractInstruction >> between: min and: max [
	"Support for CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	(min isInteger and: [max isInteger]) ifTrue:
		[^false].
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self)
		between: (opcodesArray identityIndexOf: min)
		and: (opcodesArray identityIndexOf: max)
]

{ #category : #testing }
CogAbstractInstruction >> byteReadsZeroExtend [
	"Answer if a byte read, via MoveAbR, MoveMbrR, or MoveXbrRR zero-extends
	 into the full register, or merely affects the least significant 8 bits of the
	 the register.  By default the code generator assumes that byte reads
	 to not zero extend.  Note that byte reads /must not/ sign extend."
	^false
]

{ #category : #accessing }
CogAbstractInstruction >> cResultRegister [
	"Answer the abstract register for the C result register.
	 Only partially implemented (there is as yet no CResultReg abstract reg).
	 Works on x86 since TempReg = EAX = C result reg."
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> callInstructionByteSize [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> callerSavedRegisterMask [
	"Answer an abstract register mask as computed by StackToRegisterMappingCogit registerMaskFor:"
	self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canDivQuoRem [
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canMulRR [
	<inline: true>
	^self subclassResponsibility
]

{ #category : #initialization }
CogAbstractInstruction >> cloneLiteralFrom: existingLiteral [
	"For out-of-line literal support, clone a literal from a literal."
	<var: 'existingLiteral' type: #'AbstractInstruction *'>
	self assert: (existingLiteral opcode = Literal and: [dependent isNil and: [address isNil]]).
	opcode := Literal.
	annotation := existingLiteral annotation.
	operands
		at: 0 put: (existingLiteral operands at: 0);
		at: 1 put: (existingLiteral operands at: 1);
		at: 2 put: (existingLiteral operands at: 2)
]

{ #category : #accessing }
CogAbstractInstruction >> codeGranularity [
	"Answer the size in bytes of a unit of machine code."
	<inline: true>
	^self subclassResponsibility
]

{ #category : #initialization }
CogAbstractInstruction >> cogit: aCogit [
	<doNotGenerate>
	cogit := aCogit.
	objectMemory := aCogit objectMemory
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> computeJumpTargetOffsetPlus: anPCOffset [
	<inline: true> "Since it's an extraction from other methods."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := self jumpTargetAddress.
	^jumpTarget signedIntFromLong - (address + anPCOffset) signedIntFromLong.
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeAt: actualAddress [
	"Generate concrete machine code for the instruction at actualAddress,
	 setting machineCodeSize, and answer the following address."

	address := actualAddress.
	self dispatchConcretize.
	self assert: (maxSize = nil or: [maxSize >= machineCodeSize]).
	^actualAddress + machineCodeSize
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFill16 [
	"fill with (operand 0 bitAnd: 16rFFFF) according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFill32 [
	"fill with operand 0 according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFillFromWord [
	"fill with operand 0 + operand 1 according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeLabel [
	<inline: true>
	<var: #dependentChain type: #'AbstractInstruction *'>
	| dependentChain |
	dependentChain := dependent.
	[dependentChain isNil] whileFalse:
		[dependentChain updateLabel: self.
		 dependentChain := dependentChain dependent].
	^machineCodeSize := 0
]

{ #category : #accessing }
CogAbstractInstruction >> dependent [
	^dependent
]

{ #category : #accessing }
CogAbstractInstruction >> dependent: anInstruction [
	^dependent := anInstruction
]

{ #category : #abi }
CogAbstractInstruction >> fullCallsAreRelative [
	"Answer if CallFull and/or JumpFull are relative and hence need relocating on method
	 compation. If so, they are annotated with IsRelativeCall in methods and relocated in
	 relocateIfCallOrMethodReference:mcpc:delta:"
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genAlignCStackSavingRegisters: saveRegs numArgs: numArgs wordAlignment: alignment [ 
	| wordsPushedModAlignment delta |
	self numIntRegArgs >= (saveRegs
								ifTrue: [self numberOfSaveableRegisters + numArgs]
								ifFalse: [numArgs])  ifTrue:
		[^0].
	wordsPushedModAlignment := ((saveRegs ifTrue: [self numberOfSaveableRegisters] ifFalse: [0])
									+ numArgs)
									\\ alignment.
	wordsPushedModAlignment ~= 0 ifTrue:
		[delta := alignment - wordsPushedModAlignment.
		 cogit SubCq: delta * 4 R: SPReg].
	^0
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPGreater: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPGreater operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPGreaterOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPGreaterOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPLess: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPLess operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPLessOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPLessOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPNotEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPNotEqual operand: jumpTarget asInteger
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadCStackPointer [
	"Load the stack pointer register with that of the C stack, effecting
	 a switch to the C stack.  Used when machine code calls into the
	 CoInterpreter run-time (e.g. to invoke interpreter primitives)."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadCStackPointers [
	"Load the frame and stack pointer registers with those of the C stack,
	 effecting a switch to the C stack.  Used when machine code calls into
	 the CoInterpreter run-time (e.g. to invoke interpreter primitives)."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadStackPointers [
	"Switch back to the Smalltalk stack. Assign SPReg first
	 because typically it is used immediately afterwards."
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genMarshallNArgs: numArgs arg: regOrConst0 arg: regOrConst1 arg: regOrConst2 arg: regOrConst3 [
	"Generate the code to pass up to four arguments in a C run-time call.  Hack: each argument is either a
	 negative number, that of an abstract register, or a non-negative number, that of a constant parameter.

	 Run-time calls have no more than four arguments, so chosen so that on ARM, where in its C ABI the
	 first four integer arguments are passed in registers, all arguments can be passed in registers.  We
	 defer to the back end to generate this code not so much that teh back end knows whether it uses
	 the stack or registers to pass arguments (it does, but...). In fact we defer for an extremely evil reason.
	 Doing so allows the x64 (where up to 6 args are passed) to assign the register arguments in an order
	 that allows some of the argument registers to be used for specificabstract  registers, specifically
	 ReceiverResultReg and ClassReg.  This is evil, evil, evil, but also its really nice to keep using the old
	 register assignments the principal author has grown accustomed to."
	<inline: true>
	^self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genPushRegisterArgsForAbortMissNumArgs: numArgs [
	"Ensure that the register args are pushed before the outer and
	 inner retpcs at an entry miss for arity <= self numRegArgs.  The
	 outer retpc is that of a call at a send site.  The inner is the call
	 from a method or PIC abort/miss to the trampoline."

	"This won't be as clumsy on a RISC.  But putting the receiver and
	 args above the return address means the CoInterpreter has a
	 single machine-code frame format which saves us a lot of work."

	"Iff there are register args convert
		base	->	outerRetpc		(send site retpc)
		sp		->	innerRetpc		(PIC abort/miss retpc)
	 to
		base	->	receiver
					(arg0)
					(arg1)
					outerRetpc
		sp		->	innerRetpc		(PIC abort/miss retpc)"
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genPushRegisterArgsForNumArgs: numArgs scratchReg: scratchReg [
	"Ensure that the register args are pushed before the retpc for arity <= self numRegArgs.
	 This isn't as clumsy on a RISC.  But putting the receiver and
	 args above the return address means the CoInterpreter has a
	 single machine-code frame format which saves us a lot of work."

	"Iff there are register args convert
		sp		->	retpc		(send site retpc)
	 to
		base	->	receiver
					(arg0)
					(arg1)
		sp		->	retpc		(send site retpc)"
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genSaveRegisters [
	"Save the general purpose registers for a trampoline call."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genSaveStackPointers [
	"Save the frame and stack pointer registers to the framePointer
	 and stackPointer variables.  Used to save the machine code frame
	 for use by the run-time when calling into the CoInterpreter run-time."
	self subclassResponsibility
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genSubstituteReturnAddress: retpc [
	"Fake the return address for a call/jump so that the ``call'' returns
	 to retpc given that the ``call'' will be made by a following jump."
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genWriteCResultIntoReg: abstractRegister [
	| cResultReg |
	cResultReg := self cResultRegister.
	abstractRegister ~= cResultReg ifTrue:
		[cogit gen: MoveRR operand: cResultReg operand: abstractRegister]
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> generateICacheFlush [
	"A dummy routine.
	 Processors that can generate code to flush the icache can override."

]

{ #category : #'multi-threading' }
CogAbstractInstruction >> generateLowLevelTryLock: vmOwnerLockAddress [
	self subclassResponsibility
]

{ #category : #'multi-threading' }
CogAbstractInstruction >> generateLowLevelUnlock: vmOwnerLockAddress [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> getDefaultCogCodeSize [
	"Return the default number of bytes to allocate for native code at startup.
	 The actual value can be set via vmParameterAt: and/or a preference in the ini file."
	<inline: true>
	^1024 * 1024
]

{ #category : #accessing }
CogAbstractInstruction >> getJmpTarget [
	"Get the target of a jump instruction.  Jumps have the target in the first operand."
	^cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'
]

{ #category : #testing }
CogAbstractInstruction >> hasDoublePrecisionFloatingPointSupport [
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasLinkRegister [
	"Answer if the processor has a link register, i.e. if calls pass
	 the return pc in a register instead of pushing it on a stack."
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasPCRegister [
	"Answer if the processor has a generally addressable pc register, such as the ARM.
	 On such processors we can execute jumping to pop top of stack by popping into
	 the pc register.  Note that this is not a generic RISC feature.  The PowerPC does not
	 allow one to pop into the pc for example.  So by default, answer false."
	<inline: true>
	^false
]

{ #category : #testing }
CogAbstractInstruction >> hasThreeAddressArithmetic [
	"Answer if the receiver supports three-address arithmetic instructions (currently only AndCqRR)"
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasVarBaseRegister [
	"Answer if the processor has a dedicated callee-saved register to point to
	 the base of commonly-accessed variables. By default this is false."
	<inline: true>
	^false
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> implicitReceiveCacheAt: callSiteReturnAddress [
	"Answer the implicit receiver cache for the return address
	 of a call to the ceImplicitReceiverTrampoline."
	<option: #NewspeakVM>
	^self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> inCurrentCompilation: operand [
	"Answer if operand is in the current compilation; and henced could be a candidate for pc-relative addressing."
	<inline: true>
	^(self isAnInstruction: (cogit cCoerceSimple: operand to: #'AbstractInstruction *')) "i.e. a label, which by definition will be in the current compilation."
	   or: [cogit addressIsInCurrentCompilation: operand]
]

{ #category : #initialization }
CogAbstractInstruction >> initialize [
	"This method intializes the Smalltalk instance.  The C instance is merely a struct and doesn't need initialization."
	<doNotGenerate>
	operands := CArrayAccessor on: (Array new: NumOperands).
	machineCode := CArrayAccessor on: (ByteArray new: self machineCodeBytes)
]

{ #category : #initialization }
CogAbstractInstruction >> initializeSharableLiteral: literal [
	"For out-of-line literal support, initialize a sharable literal."
	opcode := Literal.
	annotation := nil. "separate := nil for Slang"
	address := nil.
	dependent := nil.
	operands
		at: 0 put: literal;
		at: 1 put: true;		"isSharable/isUnique not"
		at: 2 put: -1			"opcodeIndex"
]

{ #category : #initialization }
CogAbstractInstruction >> initializeUniqueLiteral: literal [
	"For out-of-line literal support, initialize an unsharable literal."
	opcode := Literal.
	annotation := nil. "separate := nil for Slang"
	address := nil.
	dependent := nil.
	operands
		at: 0 put: literal;
		at: 1 put: false;		"isSharable/isUnique not"
		at: 2 put: -1			"opcodeIndex"
]

{ #category : #testing }
CogAbstractInstruction >> isAFixup: fixupOrAddress [
	<var: #fixupOrAddress type: #'void *'>
	^cogit addressIsInFixups: fixupOrAddress
]

{ #category : #testing }
CogAbstractInstruction >> isAnInstruction: addressOrInstruction [
	<var: #addressOrInstruction type: #'AbstractInstruction *'>
	<inline: true>
	^(cogit addressIsInInstructions: addressOrInstruction)
	  or: [addressOrInstruction == cogit methodLabel]
]

{ #category : #testing }
CogAbstractInstruction >> isBigEndian [
	<inline: true>
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isCallPrecedingReturnPC: mcpc [
	"Assuming mcpc is a return pc answer if the instruction before it is a call."
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isJump [
	^opcode between: FirstJump and: LastJump
]

{ #category : #testing }
CogAbstractInstruction >> isLongJump [
	^opcode between: FirstJump and: FirstShortJump - 1
]

{ #category : #testing }
CogAbstractInstruction >> isPCDependent [
	"Answer if the receiver is a pc-dependent instruction, such as a relative jump."
	^self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jmpTarget: anAbstractInstruction [
	"Set the target of a jump instruction.  These all have the target in the first operand."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #anAbstractInstruction type: #'AbstractInstruction *'>
	self cCode: [] "check for inadvertent smashing of already-set jmpTargets; development only"
		inSmalltalk: [self assert: ((operands at: 0)
									ifNil: [true]
									ifNotNil: [:o| o = 0 or: [self isAFixup: o]])].
	operands at: 0 put: anAbstractInstruction asUnsignedInteger.
	^anAbstractInstruction
]

{ #category : #accessing }
CogAbstractInstruction >> jumpLongByteSize [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jumpLongConditionalByteSize [
	self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> jumpLongTargetBeforeFollowingAddress: mcpc [
	^self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jumpShortByteSize [
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> jumpTargetAddress [
	<inline: true> "Since it's an extraction from other methods."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'.
	cogit assertSaneJumpTarget: jumpTarget.
	(self isAnInstruction: jumpTarget) ifTrue:
		[jumpTarget := cogit cCoerceSimple: jumpTarget address to: #'AbstractInstruction *'].
	self assert: jumpTarget ~= 0.
	^jumpTarget
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> labelOffset [
	"Hack:  To arrange that the block method field pushed in a block entry has
	 its MFMethodFlagIsBlockFlag bit set we provide labels with an offset.  The
	 offset for the fakeHeader reference is MFMethodFlagIsBlockFlag.  See
	 compileBlockFrameBuild:"
	^operands at: 1
]

{ #category : #accessing }
CogAbstractInstruction >> loadLiteralByteSize [
	"Answer the byte size of a MoveCwR opcode's corresponding machine code"
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> loadPICLiteralByteSize [
	"Answer the byte size of a MoveCwR opcode's corresponding machine code
	 when the argument is a PIC.  This is for the self-reference at the end of a
	 closed PIC."
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> longJumpTargetAddress [
	<inline: true> "Since it's an extraction from other methods."
	"This needs to be different from jumpTargetAddress because long jumps can
	be to absolute addresses and hence we can't assert that the jump target is sane."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'.
	(self isAnInstruction: jumpTarget) ifTrue:
		[jumpTarget := cogit cCoerceSimple: jumpTarget address to: #'AbstractInstruction *'].
	self assert: jumpTarget ~= 0.
	^jumpTarget
]

{ #category : #accessing }
CogAbstractInstruction >> machineCode [
	^machineCode
]

{ #category : #accessing }
CogAbstractInstruction >> machineCode: anObject [
	"Set the value of machineCode"

	machineCode := anObject
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> machineCodeBytes [
	"Answer the maximum number of bytes of machine code generated for any abstract instruction."
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> machineCodeSize [
	"N.B. This is a byte size."
	^machineCodeSize
]

{ #category : #accessing }
CogAbstractInstruction >> machineCodeSize: size [ "<signed byte>"
	"N.B. This is a byte size."
	^machineCodeSize := size
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> mapEntryAddress [
	"Typically map entries apply to the end of an instruction, for two reasons:
	  a)	to cope with literals embedded in variable-length instructions, since, e.g.
		on x86, the literal typically comes at the end of the instruction.
	  b)	in-line cache detection is based on return addresses, which are typically
		to the instruction following a call."
	<inline: true>
	^address + machineCodeSize
]

{ #category : #accessing }
CogAbstractInstruction >> maxAbstractGeneralPurposeReg [
	"Answer the largest index of an abstract general-purpose register used by this compiler.
	 N.B.  Abstract registers are negative numbers."
	<inline: true>
	^ReceiverResultReg
]

{ #category : #accessing }
CogAbstractInstruction >> maxSize [
	"N.B. This is a byte size."
	^maxSize
]

{ #category : #accessing }
CogAbstractInstruction >> maxSize: size [ "<signed byte>"
	"N.B. This is a byte size."
	maxSize := size
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> maybeEstablishVarBase [
	"If the receiver has a VarBaseReg, generate the code to set it to its value."
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> minAbstractGeneralPurposeReg [
	"Answer the smallest index of an abstract general-purpose register used by this compiler.
	 N.B.  Abstract registers are negative numbers."
	<inline: true>
	^self subclassResponsibility
]

{ #category : #printing }
CogAbstractInstruction >> nameForRegister: reg [ "<Integer>"
	"subclasses with special purpose registers may need to override."
	<doNotGenerate>
	^CogRTLOpcodes nameForRegister: reg
]

{ #category : #initialization }
CogAbstractInstruction >> numCheckFeaturesOpcodes [
	"If the priocessor has a feature check facility answer the number
	 of opcodes required to compile an accessor for the feature."
	^0
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> numICacheFlushOpcodes [
	"If the processor has the ablity to generate code to flush the icache answer
	 the number of opcodes required to compile an accessor for the feature."
	^0
]

{ #category : #accessing }
CogAbstractInstruction >> numIntRegArgs [
	^self subclassResponsibility
]

{ #category : #'multi-threading' }
CogAbstractInstruction >> numLowLevelLockOpcodes [
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> numberOfSaveableRegisters [
	"Answer the number of registers to be saved in a trampoline call that saves registers.
	 See genSaveRegisters"
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> opcode [
	^opcode
]

{ #category : #accessing }
CogAbstractInstruction >> opcode: value [
	^opcode := value
]

{ #category : #accessing }
CogAbstractInstruction >> operand0: operand [
	<inline: true>
	operands at: 0 put: operand
]

{ #category : #accessing }
CogAbstractInstruction >> operand1: operand [
	<inline: true>
	operands at: 1 put: operand
]

{ #category : #accessing }
CogAbstractInstruction >> operand2: operand [
	<inline: true>
	operands at: 2 put: operand
]

{ #category : #accessing }
CogAbstractInstruction >> operands [
	^operands
]

{ #category : #accessing }
CogAbstractInstruction >> operands: anObject [
	"Set the value of operands"

	operands := anObject
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> outputMachineCodeAt: targetAddress [
	"By default move machine code a byte at a time
	  Subclasses with coarser granularity can override as desired."
	<inline: true>
	0 to: machineCodeSize - 1 do:
		[:j|
		objectMemory byteAt: targetAddress + j put: (machineCode at: j)]
]

{ #category : #printing }
CogAbstractInstruction >> printStateOn: aStream [
	| opcodeName orneryOperands format |
	<doNotGenerate> "Smalltalk-side only"
	opcode ifNil:
		[^self].
	aStream space; nextPut: $(; nextPutAll: (opcodeName := self class nameForOpcode: opcode).
	orneryOperands := operands isCObjectAccessor
							ifTrue: [operands object]
							ifFalse: [operands].
	(cogit isKindOf: Cogit) ifTrue:
		[format := CogRTLOpcodes printFormatForOpcodeName: opcodeName].
	orneryOperands withIndexDo:
		[:operand :index|
		operand notNil ifTrue:
			[aStream space.
			 index >= (orneryOperands identityIndexOf: nil ifAbsent: [orneryOperands size + 1]) ifTrue:
				[aStream print: index - 1; nextPut: $:].
			 (format notNil and: [(format at: index ifAbsent: nil) = $r])
				ifTrue: [aStream nextPutAll: (self nameForRegister: operand)]
				ifFalse:
					[aStream print: operand.
					 (operand isInteger and: [operand > 16 and: [opcode ~= Label]]) ifTrue:
						[(operand allMask: 16r80000000) ifTrue:
							[aStream nextPut: $/; print: operand signedIntFromLong].
						 aStream nextPut: $/.
						 operand printOn: aStream base: 16]]]].
	machineCodeSize ifNotNil:
		[(machineCodeSize between: 1 and: machineCode size) ifTrue:
			[0 to: machineCodeSize - 1 by: self codeGranularity do:
				[:i|
				 aStream space.
				 (self machineCodeAt: i)
					ifNil: [aStream nextPut: $.]
					ifNotNil:
						[:mc|
						mc isInteger
							ifTrue: [mc printOn: aStream base: 16]
							ifFalse: [mc printOn: aStream]]]]].
	address ifNotNil:
		[aStream nextPut: $@.
		 address printOn: aStream base: 16].
	aStream nextPut: $)
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateCallBeforeReturnPC: retpc by: delta [
	^self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateJumpLongBeforeFollowingAddress: pc by: delta [
	"We assume here that calls and jumps look the same as regards their displacement.
	 This works on at least x86, ARM and x86_64.  Processors on which that isn't the
	 case can override as necessary."
	self relocateCallBeforeReturnPC: pc by: delta
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateMethodReferenceBeforeAddress: pc by: delta [
	"On some processors the method reference is a load constant and
	 hence needs changing when methods are moved.  On others the
	 method reference is pc-relative and hence nothing needs to happen."
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> resolveJumpTarget [
	<var: #fixup type: #'BytecodeFixup *'>
	| fixup |
	self assert: self isJump.
	fixup := cogit cCoerceSimple: (operands at: 0) to: #'BytecodeFixup *'.
	self cCode: [] inSmalltalk:
		[(fixup isKindOf: CogBytecodeFixup) ifTrue:
			[self assert: (self isAFixup: fixup)]].
	(self isAFixup: fixup) ifTrue:
		[self assert: (cogit addressIsInInstructions: fixup targetInstruction).
		 self jmpTarget: fixup targetInstruction]
]

{ #category : #'full transfer run-time support' }
CogAbstractInstruction >> rewriteCallFullAt: callSiteReturnAddress target: callTargetAddress [
	"Rewrite a CallFull instruction to call a different target.  This variant is used to rewrite cached primitive calls.
	 Answer the extent of the code change which is used to compute the range of the icache to flush.
	 This defaults to rewriteCallAt:target:; processors that differentiate between Call and CallFull will override."
	^self rewriteCallAt: callSiteReturnAddress target: callTargetAddress
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> rewriteInlineCacheTag: cacheTag at: callSiteReturnAddress [
	"Rewrite an inline cache with a new tag.  This variant is used
	 by the garbage collector."
	self subclassResponsibility
]

{ #category : #'full transfer run-time support' }
CogAbstractInstruction >> rewriteJumpFullAt: callSiteReturnAddress target: callTargetAddress [
	"Rewrite a JumpFull instruction to jump to a different target.  This variant is used to rewrite cached primitive calls.
	 Answer the extent of the code change which is used to compute the range of the icache to flush.
	 This defaults to rewriteJumpLongAt:target:; processors that differentiate between Jump and JumpFull will override."
	^self rewriteJumpLongAt: callSiteReturnAddress target: callTargetAddress
]

{ #category : #abi }
CogAbstractInstruction >> saveAndRestoreLinkRegAround: aBlock [
	"If the processor's ABI includes a link register, generate instructions
	 to save and restore it around aBlock, which is assumed to generate code."
	<inline: true>
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> setLabelOffset: aValue [
	"Hack:  To arrange that the block method field pushed in a block entry has
	 its MFMethodFlagIsBlockFlag bit set we provide labels with an offset.  The
	 offset for the fakeHeader reference is MFMethodFlagIsBlockFlag.  See
	 compileBlockFrameBuild:"
	^operands at: 1 put: aValue
]

{ #category : #testing }
CogAbstractInstruction >> setsConditionCodesFor: aConditionalJumpOpcode [
	"Answer if the receiver's opcode sets the condition codes correctly for the given conditional jump opcode."
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> sizePCDependentInstructionAt: eventualAbsoluteAddress [
	"Size a jump and set its address.  The target may be another instruction
	 or an absolute address.  On entry the address inst var holds our virtual
	 address. On exit address is set to eventualAbsoluteAddress, which is
	 where this instruction will be output.  The span of a jump to a following
	 instruction is therefore between that instruction's address and this
	 instruction's address ((which are both still their virtual addresses), but the
	 span of a jump to a preceding instruction or to an absolute address is
	 between that instruction's address (which by now is its eventual absolute
	 address) or absolute address and eventualAbsoluteAddress."

	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> stackPageInterruptHeadroomBytes [
	"Return a minimum amount of headroom for each stack page (in bytes).  In a
	 JIT the stack has to have room for interrupt handlers which will run on the stack."
	self subclassResponsibility
]

{ #category : #printing }
CogAbstractInstruction >> symbolic [
	<doNotGenerate> "Smalltalk-side only"
	^String streamContents: [:s| self symbolicOn: s]
]

{ #category : #printing }
CogAbstractInstruction >> symbolicOn: aStream [
	| orneryOperands |
	<doNotGenerate> "Smalltalk-side only"
	(machineCodeSize isNil
	 or: [opcode = 16rAAA]) ifTrue:
		[^aStream nextPut: 'uninitialized opcode'].
	aStream space; nextPut: $(; nextPutAll: (self class nameForOpcode: opcode).
	orneryOperands := operands isCObjectAccessor
							ifTrue: [operands object]
							ifFalse: [operands].
	orneryOperands withIndexDo:
		[:operand :index|
		operand notNil ifTrue:
			[aStream space.
			 index >= (orneryOperands identityIndexOf: nil ifAbsent: [orneryOperands size + 1]) ifTrue:
				[aStream print: index - 1; nextPut: $:].
			 operand class == self class
				ifTrue:
					[operand symbolicOn: aStream]
				ifFalse:
					[aStream print: operand.
					 (operand isInteger and: [operand > 16]) ifTrue:
						[(operand allMask: 16r80000000) ifTrue:
							[aStream nextPut: $/; print: operand signedIntFromLong].
						 aStream nextPut: $/.
						 operand printOn: aStream base: 16]]]].
	machineCodeSize > 0 ifTrue:
		[machineCodeSize > machineCode size
			ifTrue: [aStream nextPutAll: ' no mcode']
			ifFalse:
				[0 to: machineCodeSize - 1 by: self codeGranularity do:
					[:i|
					 aStream space.
					 (self machineCodeAt: i) printOn: aStream base: 16]]].
	aStream nextPut: $)
]

{ #category : #'memory access' }
CogAbstractInstruction >> unalignedLongAt: byteAddress [
	^self subclassResponsibility
]

{ #category : #'memory access' }
CogAbstractInstruction >> unalignedLongAt: byteAddress put: aWord [
	^self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> updateLabel: labelInstruction [
	"Update an instruction that depends on a label outside of
	 generated code (e.g. a method or block header)."
	<var: #labelInstruction type: #'AbstractInstruction *'>
	| offsetAddress |
	offsetAddress := labelInstruction address + labelInstruction labelOffset.
	opcode caseOf: {
		[MoveCwR]		-> [operands at: 0 put: offsetAddress].
		[PushCw]		-> [operands at: 0 put: offsetAddress].
		[FillFromWord]	-> [operands at: 0 put: offsetAddress]}
]

{ #category : #simulation }
CogAbstractInstruction >> wantsNearAddressFor: anObject [
	"A hack hook to allow ARM to override the simulated address for the short-cut trampolines,
	 and to allow x64 to address CStackPointer and CFramePointer relative to VarBaseReg."
	^false
]
