"
I generate code that can be loaded dynamically from external libraries (e.g., DSOs on Unix or DLLs on Windows)
"
Class {
	#name : #VMPluginCodeGenerator,
	#superclass : #CCodeGenerator,
	#instVars : [
		'pluginClass',
		'pluginName',
		'pluginFunctionsUsed',
		'inProgressSelectors',
		'inliningDone'
	],
	#category : #'VMMaker-Translation to C'
}

{ #category : #'spur primitive compilation' }
VMPluginCodeGenerator >> accessorChainsForMethod: method interpreterClass: interpreterClass [
	inProgressSelectors := Set new.
	^[super accessorChainsForMethod: method interpreterClass: interpreterClass] ensure:
		[inProgressSelectors := nil]
]

{ #category : #'spur primitive compilation' }
VMPluginCodeGenerator >> accessorDepthDeterminationFollowsSelfSends [
	^true
]

{ #category : #'spur primitive compilation' }
VMPluginCodeGenerator >> accessorsAndAssignmentsForSubMethodNamed: selector actuals: actualParameters depth: depth interpreterClass: interpreterClass into: aTrinaryBlock [
	"Evaluate aTrinaryBlock with the root accessor sends, accessor sends and assignments in the sub-method named selector."

	| method map |
	(inProgressSelectors includes: selector) ifTrue:
		[^nil].
	inProgressSelectors add: selector.
	method := self methodNamed: selector.
	"this is unsatisfactory.  a pluggable scheme that asks the relevant plugin the right question would
	 be better but for now the only cross-plugin load is for loadBitBltFrom:warping: and variants."
	(#(loadBitBltFrom: loadWarpBltFrom: loadBitBltFrom:warping:) includes: selector) ifTrue:
		[(method isNil
		  or: [method definingClass ~~ BitBltSimulation]) ifTrue:
			[method := (BitBltSimulation >> selector) methodNode asTranslationMethodOfClass: TMethod]].
	method ifNil:
		[^nil].
	map := Dictionary new.
	method args do: [:var| map at: var put: depth asString, var].
	method locals do: [:var| map at: var put: depth asString, var].
	^self accessorsAndAssignmentsForMethod: (method copy renameVariablesUsing: map)
		actuals: actualParameters
		depth: depth + 1
		interpreterClass: interpreterClass
		into: aTrinaryBlock
]

{ #category : #'spur primitive compilation' }
VMPluginCodeGenerator >> actualsForMethod: aTMethod [
	"Normal primitives have no arguments, but translated primitives do.
	 Override to answer actuals for translated primitives."
	^(aTMethod args size - 1 to: 0 by: -1) collect:
		[:i|
		 TSendNode new
			setSelector: #stackValue:
			receiver: (TVariableNode new setName: 'interpreterProxy')
			arguments: {TConstantNode new setValue: i}]
]

{ #category : #'C translation' }
VMPluginCodeGenerator >> atLeastVMProxyMajor: major minor: minor [ 
	^String streamContents:
		[:s|
		s	nextPutAll: 'VM_PROXY_MAJOR > '; print: major;
			nextPutAll: ' || (VM_PROXY_MAJOR == '; print: major;
			nextPutAll: ' && VM_PROXY_MINOR >= '; print: minor;
			nextPutAll: ')']
]

{ #category : #inlining }
VMPluginCodeGenerator >> doInlining: inlineFlag [
	"do inlining for a plugin; avoid doing it twice and make sure that
	 primitive prolog preparation is done immediately after inlining.
	 Also, since sharing between plugins means that normal pruning
	 can't be done, allow plugins that want to prune specific methods."
	inliningDone ifFalse:
		[self doBasicInlining: inlineFlag.
		 self prepareTranslatedPrimitives.
		 pluginClass methodsToBePruned do:
			[:sel|
			methods removeKey: sel].
		 inliningDone := true]
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> emitAccessorDepthsOn: aStream [ 
	"Output accessor depth bytes for all primitives in the plugin.
	 This is for external primitives in Spur."
	(self sortStrings: self exportedPrimitiveNames) do:
		[:primName|
		 (self accessorDepthForSelector: primName asSymbol) ifNotNil:
			[:depth|
			 "store the accessor depth in a byte variable; save a little space
			  by omitting depths < 0; support code supplies the default."
			 self assert: depth < 128.
			 depth >= 0 ifTrue:
				[aStream
					nextPutAll: 'signed char ';
					nextPutAll: primName;
					nextPutAll: 'AccessorDepth = ';
					nextPutAll: (self cLiteralFor: depth);
					nextPut: $;;
					cr]]]
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> emitCCodeOn: aStream doInlining: inlineFlag doAssertions: assertionFlag [
	"Generate twice; the first time to collect the used functions, the second to output the used functions."
	| savedHeaders |
	savedHeaders := headerFiles copy.
	[super emitCCodeOn: NullStream new doInlining: inlineFlag doAssertions: assertionFlag]
		on: MessageNotUnderstood
		do: [:ex|
				(#(cr crtab: ensureCr peekLast space tab tab:) includes: ex message selector) ifTrue:
					[ex resume: nil].
				ex pass].
	headerFiles := savedHeaders.
	super emitCCodeOn: aStream doInlining: inlineFlag doAssertions: assertionFlag
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> emitCHeaderOn: aStream [
	"Write a C file header onto the given stream."

	aStream nextPutAll: (self fileHeaderVersionStampForSourceClass: pluginClass).
	aStream cr; cr.

	#('<math.h>' '<stdio.h>' '<stdlib.h>' '<string.h>' '<time.h>') reverseDo:
		[:hdr| self addHeaderFileFirst: hdr].

	"Additional header files; include C library ones first."
	self emitHeaderFiles: (headerFiles select: [:hdr| hdr includes: $<]) on: aStream.

	aStream cr; nextPutAll:'/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using ''null'' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif'; cr; cr.
	self addHeaderFile: '"sqMemoryAccess.h"'.
	"Additional header files; include squeak VM ones last"
	self emitHeaderFiles: (headerFiles reject: [:hdr| hdr includes: $<]) on: aStream.
	self maybePutPreambleFor: pluginClass on: aStream.
	aStream cr
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> emitCTypesOn: aStream [
	"Store local type declarations on the given stream."
	(self structClassesForTranslationClasses: { pluginClass }) do:
		[:structClass|
		(structClass isAbstract not
		 and: [pluginClass shouldGenerateTypedefFor: structClass]) ifTrue:
			[structClass printTypedefOn: aStream.
			 aStream cr; cr]]
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> emitExportsOn: aStream [
	"Store all the exported primitives in the form used by the internal named prim system."
	aStream cr; cr; nextPutAll:'#ifdef SQUEAK_BUILTIN_PLUGIN'.
	self emitExportsNamed: pluginName pluginName: pluginName on: aStream.
	aStream cr; nextPutAll: '#else /* ifdef SQ_BUILTIN_PLUGIN */'; cr; cr.
	self emitAccessorDepthsOn: aStream.
	aStream cr; nextPutAll: '#endif /* ifdef SQ_BUILTIN_PLUGIN */'; cr
]

{ #category : #'C translation' }
VMPluginCodeGenerator >> emitIfdefForPluginFunctionOption: anArrayOrSymbol on: aStream [
	"See e.g. senders of atLeastVMProxyMajor:minor: or <option: #IMMUTABLITY>
	 in InterpreterProxy"
	aStream nextPutAll: '#if '; nextPutAll: (anArrayOrSymbol isSymbol
											ifTrue: [anArrayOrSymbol]
											ifFalse: [self perform: anArrayOrSymbol first
														withArguments: anArrayOrSymbol allButFirst])
]

{ #category : #'C translation' }
VMPluginCodeGenerator >> generateInterpreterProxyFunctionDeference: aNode on: aStream indent: anInteger [
	| pluginsToClone |
	(pluginsToClone := self pluginFunctionsToClone) isEmpty ifTrue:
		[^self].
	aStream cr; nextPutAll: '#if !defined(SQUEAK_BUILTIN_PLUGIN)'.
	pluginsToClone do:
		[:s| | cs |
		cs := self cFunctionNameFor: s.
		self withOptionalVerbiageFor: s
			on: aStream
			do: [aStream crtab: anInteger; nextPutAll: cs; nextPutAll: ' = interpreterProxy->'; nextPutAll: cs; nextPut: $;]
			ifOptionalDo: [aStream
							cr; nextPutAll: '# if !defined('; nextPutAll: cs; nextPut: $);
							crtab: anInteger; nextPutAll: cs; nextPutAll: ' = 0;';
							cr; nextPutAll: '# endif']].
	aStream cr; nextPutAll: '#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */'.
]

{ #category : #'C translation' }
VMPluginCodeGenerator >> generateRemapOopIn: aNode on: aStream indent: level [
	"Generate the C code for this message onto the given stream."

	aStream cr; nextPutAll: '#if SPURVM'; cr.
	self generateSpurRemapOopIn: aNode on: aStream indent: level.
	aStream cr; nextPutAll: '#else /* SPURVM */'; cr.
	self generateV3RemapOopIn: aNode on: aStream indent: level.
	aStream cr; nextPutAll: '#endif /* SPURVM */'; cr
]

{ #category : #'C translation' }
VMPluginCodeGenerator >> generateSpurRemapOopIn: aNode on: aStream indent: level [
	"Generate just the block argument for this message as Spur does not GC on allocation."

	aNode args second emitCCodeOn: aStream level: level generator: self
]

{ #category : #'C translation' }
VMPluginCodeGenerator >> generateV3RemapOopIn: aNode on: aStream indent: level [
	"Generate call on remapOop: for the variable oopOrList (or all of the
	 variables in oopOrList) before evaluating aBlock, and restore them after.
	 This keeps the oops valid if, as V3 will, there is a GC on allocation."

	| idList |
	pluginFunctionsUsed add: #pushRemappableOop:; add: #popRemappableOop.
	idList := aNode args first nameOrValue.
	idList class == Array ifFalse: [idList := Array with: idList].
	idList do:
		[:each | 
		 aStream
			tab: level;
			nextPutAll: 'pushRemappableOop(';
			nextPutAll: each asString;
			nextPutAll: ');']
		separatedBy: [aStream cr].
	aStream cr.
	aNode args second emitCCodeOn: aStream level: level generator: self.
	level timesRepeat: [aStream tab].
	idList reversed do:
		[:each |
		 aStream 
			nextPutAll: each asString;
			nextPutAll: ' = popRemappableOop()']
		separatedBy: [aStream nextPut: $;; crtab: level]
]

{ #category : #'type inference' }
VMPluginCodeGenerator >> harmonizeReturnTypesIn: aSetOfTypes [
	"Eliminate signed/unsigned conflicts in aSetOfTypes.  Override to
	 default to void if any one return type is void."
	^(aSetOfTypes includes: #void)
		ifTrue: [Set with: #void]
		ifFalse: [super harmonizeReturnTypesIn: aSetOfTypes]
]

{ #category : #public }
VMPluginCodeGenerator >> initialize [
	super initialize.
	pluginFunctionsUsed := Set new.
	inliningDone := false
]

{ #category : #public }
VMPluginCodeGenerator >> initializeCTranslationDictionary [ 
	"Initialize the dictionary mapping message names to actions for C code generation."

	super initializeCTranslationDictionary.
	translationDict
		at: #expandDereferenceInterpreterProxyFunctionTable
			put: #generateInterpreterProxyFunctionDeference:on:indent:;
		at: #remapOop:in:
			put: #generateRemapOopIn:on:indent:
]

{ #category : #testing }
VMPluginCodeGenerator >> isGeneratingPluginCode [
	^true
]

{ #category : #'spur primitive compilation' }
VMPluginCodeGenerator >> isObjectAccessor: selector given: interpreterClass [
	"Override to include the selectors transformed into accessors for translated primitives.
	 InterpreterPlugin browseTranslatedPrimitives"
	^(#(asciiValue at: at:put: basicAt: size) includes: selector)
	  or: [super isObjectAccessor: selector given: interpreterClass]
]

{ #category : #public }
VMPluginCodeGenerator >> localizeGlobalVariables [
"TPR - we don't do this for plugins"
]

{ #category : #public }
VMPluginCodeGenerator >> noteUsedPluginFunction: aSelector [
	"Remember aSelector and answer whether the call should be made through
	 interpreterProxy. If not, it will be made either directly (in an internal plugin)
	 or through a local copy of the function pointer (in an external plugin)."
	pluginFunctionsUsed add: aSelector.
	"These two are static to sqVirtualMachine.c and so
	 they must be called through the interpreterProxy."
	^#(majorVersion minorVersion) includes: aSelector
]

{ #category : #public }
VMPluginCodeGenerator >> pluginClass: aPluginClass [
	"Set the plugin class and name when generating plugins.
	 And for run-time use, answer the name string."
	| packageId |
	pluginClass := aPluginClass.
	pluginName := pluginClass moduleName.
	packageId := self shortMonticelloDescriptionForClass: pluginClass.
	(packageId beginsWith: pluginClass name) ifTrue:
		[packageId := packageId allButFirst: pluginClass name size].
	(packageId beginsWith: pluginName) ifTrue:
		[packageId := packageId allButFirst: pluginName size].
	^self declareModuleName: pluginClass moduleNameAndVersion, packageId
]

{ #category : #public }
VMPluginCodeGenerator >> pluginFunctionsToClone [
	"Answer those of the used plugin functions to clone as a sorted collection.
	 Exclude those that are static to sqVirtualMachine.c and hence always need
	 to be called through interpreterProxy."

	^((pluginFunctionsUsed
		reject: [:selector| self noteUsedPluginFunction: selector])
			select: [:selector| InterpreterProxy includesSelector: selector])
				asSortedCollection
]

{ #category : #public }
VMPluginCodeGenerator >> pluginName: aString [
"TPR - moved from CCodeGenerator"
	"Set the plugin name when generating plugins."
	pluginName := aString.
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> preDeclareInterpreterProxyOn: aStream [
	"Put the necessary #defines needed before interpreterProxy.  Basically
	 internal plugins use the VM's interpreterProxy variable and external plugins
	 use their own.  Override to keep local copies of all functions in external
	 prims, and link directly in internal plugins."
	"| pcc |
	pcc := self new.
	(InterpreterProxy selectors reject: [:s| #(initialize private) includes: (InterpreterProxy whichCategoryIncludesSelector: s)]) do:
		[:s| pcc noteUsedPluginFunction: s].
	pcc preDeclareInterpreterProxyOn: Transcript.
	Transcript flush"
	| pluginFuncs interpreterClass objectMemoryClass |
	(pluginFuncs := self pluginFunctionsToClone) isEmpty ifTrue:
		[^super preDeclareInterpreterProxyOn: aStream].
	aStream cr; nextPutAll: '#if !defined(SQUEAK_BUILTIN_PLUGIN)'; cr.
	interpreterClass := self referenceInterpreterClass.
	objectMemoryClass := self referenceObjectMemoryClass.
	pluginFuncs := pluginFuncs collect:
						[:selector| | reference actual |
						reference := self compileToTMethodSelector: selector
										in: ((interpreterClass whichClassIncludesSelector: selector) ifNil:
											[(objectMemoryClass whichClassIncludesSelector: selector) ifNil:
												[InterpreterProxy]]).
						actual := self compileToTMethodSelector: selector in: InterpreterProxy.
						(reference returnType ~= actual returnType
						 or: [(1 to: reference args size) anySatisfy:
								[:i| (reference typeFor: (reference args at: i) in: self)
								  ~= (actual typeFor: (actual args at: i) in: self)]]) ifTrue:
							[self logger
								nextPutAll: 'warning, signature of InterpreterProxy>>';
								nextPutAll: selector;
								nextPutAll: ' does not match reference implementation.';
								cr].
						actual].
	pluginFuncs do:
		[:tMethod|
		 tMethod recordDeclarationsIn: self.
		 tMethod returnType ifNil:
			[tMethod inferReturnTypeIn: self]].
	pluginFuncs do:
		[:tMethod| | functionName |
		functionName := self cFunctionNameFor: tMethod selector.
		aStream nextPutAll:
			((String streamContents:
					[:s|
					tMethod
						static: true;
						emitCFunctionPrototype: s generator: self])
				copyReplaceAll: functionName
				with: '(*', functionName, ')'
				tokenish: [:ch| ch = $_ or: [ch isAlphaNumeric]])].
	aStream nextPutAll: '#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */'.
	pluginFuncs do:
		[:tMethod|
		self withOptionalVerbiageFor: tMethod selector
			on: aStream
			do: [aStream cr.
				tMethod static: false; export: false; emitCFunctionPrototype: aStream generator: self.
				aStream nextPut: $;]
			ifOptionalDo:
				[aStream cr; nextPutAll: '# define '.
				 (TSendNode new
					setSelector: tMethod selector
						receiver: (TVariableNode new setName: 'interpreterProxy')
							arguments: (tMethod args collect: [:a| TVariableNode new setName: a]))
					emitCCodeAsArgumentOn: aStream
						level: 0
							generator: self.
				 aStream nextPutAll: ' 0']].
	aStream cr; nextPutAll: 'extern'.
	aStream cr; nextPutAll: '#endif'; cr
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> prepareTranslatedPrimitives [
	"Translated primitives need their prolog and epilog adding and all
	 sends to self that should be sends to interpreterproxy changing."
	methods do:
		[:meth|
		 meth primitive > 0 ifTrue:
			[meth
				preparePrimitivePrologue;
				mapSendsFromSelfToInterpreterProxy: InterpreterProxy selectors]]
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> referenceInterpreterClass [
	"Define the class from which to take methods to define the interpreter proxy imports."
	^(Smalltalk classNamed: #StackInterpreter) ifNil:
		[(Smalltalk classNamed: #Interpreter) ifNil:
			[InterpreterProxy]]
]

{ #category : #'C code generator' }
VMPluginCodeGenerator >> referenceObjectMemoryClass [
	"Define the class from which to take methods to define the interpreter proxy imports."
	^(Smalltalk classNamed: #SpurMemoryManager) ifNil:
		[(Smalltalk classNamed: #NewObjectMemory) ifNil:
			[ObjectMemory]]
]

{ #category : #private }
VMPluginCodeGenerator >> storeVirtualMachineProxyHeader: categoryList on: fileName [
	"Store the interpreter definitions on the given file"
	| stream |
	stream := FileStream newFileNamed: fileName.
	stream nextPutAll:
'#ifndef _SqueakVM_H
#define _SqueakVM_H

/* Increment the following number if you change the order of
   functions listed or if you remove functions */
#define VM_PROXY_MAJOR 1

/* Increment the following number if you add functions at the end */
#define VM_PROXY_MINOR 0

typedef struct VirtualMachine {
	int (*minorVersion) (void);
	int (*majorVersion) (void);
'.

	categoryList do:[:assoc|
		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr; crtab.
		(self sortStrings: assoc value) do:[:sel|
			(methods at: sel) emitProxyFunctionPrototype: stream generator: self.
			stream nextPutAll: ';'; crtab]].

	stream nextPutAll:'
} VirtualMachine;

#endif /* _SqueakVM_H */
'.
	stream close.
]

{ #category : #private }
VMPluginCodeGenerator >> storeVirtualMachineProxyImplementation: categoryList on: fileName [
	"Store the interpreter definitions on the given file"
	| stream |
	stream := FileStream newFileNamed: fileName.
	stream nextPutAll:'
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "sqVirtualMachine.h"'; cr;cr.
	stream nextPutAll:'/*** Function prototypes ***/'.

	categoryList do:[:assoc|
		stream cr; cr; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; cr.
		(self sortStrings: assoc value) do:[:sel|
			(methods at: sel) emitCFunctionPrototype: stream generator: self]].

	stream cr; nextPutAll:'struct VirtualMachine *VM = NULL;'; cr.
	stream cr; nextPutAll:
'static int majorVersion(void) {
	return VM_PROXY_MAJOR;
}

static int minorVersion(void) {
	return VM_PROXY_MINOR;
}

struct VirtualMachine* sqGetInterpreterProxy(void)
{
	if(VM) return VM;
	VM = (struct VirtualMachine *) calloc(1, sizeof(VirtualMachine));
	/* Initialize Function pointers */
	VM->majorVersion = majorVersion;
	VM->minorVersion = minorVersion;
'.
	categoryList do:[:assoc|
		stream cr; crtab; nextPutAll:'/* InterpreterProxy methodsFor: ''',assoc key, ''' */'; crtab.
		assoc value asSortedCollection do:[:sel|
		stream nextPutAll:'VM->';
			nextPutAll: (self cFunctionNameFor: sel);
			nextPutAll:' = ';
			nextPutAll: (self cFunctionNameFor: sel);
			nextPutAll:';';
			crtab]].

	stream cr; crtab; nextPutAll:'return VM;'; cr; nextPutAll:'}'; cr.
	stream close.
]

{ #category : #'type inference' }
VMPluginCodeGenerator >> typeFor: aNode in: aTMethod [
	"Override to provide the type for InterpreterProxy's implicit stack variable."
	aNode isVariable ifTrue:
		[^(aTMethod typeFor: aNode in: self) ifNil:
			[aNode name = 'stack'
				ifTrue: [#'sqInt *']
				ifFalse: [#sqInt]]].
	^super typeFor: aNode in: aTMethod
]

{ #category : #'C translation' }
VMPluginCodeGenerator >> withOptionalVerbiageFor: selector on: aStream do: mainBlock ifOptionalDo: optionalBlock [
	(InterpreterProxy >> selector pragmaAt: #option:)
		ifNil:
			[mainBlock value]
		ifNotNil:
			[:pragma|
			 aStream cr.
			 self emitIfdefForPluginFunctionOption: pragma arguments first on: aStream.
			 mainBlock value.
			 aStream cr; nextPutAll: '#else'.
			 optionalBlock value.
			 aStream cr; nextPutAll: '#endif']
]
