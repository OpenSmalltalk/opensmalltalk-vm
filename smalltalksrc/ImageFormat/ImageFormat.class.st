"
ImageFormat represents the requirements of the image in terms of capabilities that must be supported by the virtual machine. The image format version is saved as an integer value in the header of an image file. When an image is loaded, the virtual machine checks the image format version to determine whether it is capable of supporting the requirements of that image.

The image format version value is treated as a bit map of size 32, derived from the 32-bit integer value saved in the image header. Bits in the bit map represent image format requirements. For example, if the image sets bit 15 to indicate that it requires some capability from the VM, then the VM can check bit 15 and decide whether it is able to satisfy that requirement.

The base image format numbers (6502, 6504, 68000, and 68002) utiliize 10 of the 32 available bits. The high order bit is reserved as an extension bit for future use. The remaining 21 bits are used to represent additional image format requirements. For example, the low order bit is used to indication that the image uses (and requires support for) the platform byte ordering implemented in the StackInterpreter (Cog) VM.

	""(ImageFormat fromFile: Smalltalk imageName) description""

"
Class {
	#name : #ImageFormat,
	#superclass : #Object,
	#instVars : [
		'wordSize',
		'requiresClosureSupport',
		'requiresPlatformByteOrder',
		'requiresCogSupport'
	],
	#classVars : [
		'BaseVersionMask',
		'BaseVersionNumbers',
		'CapabilitiesBitsMask',
		'KnownVersionNumbers',
		'PlatformByteOrderBit',
		'ReservedBitsMask'
	],
	#category : #ImageFormat
}

{ #category : #'image formats' }
ImageFormat class >> allVersionNumberByteArrays [
	"All known version numbers expressed as byte arrays of size 4 and 8 in little
	endian and big endian byte ordering."

	"ImageFormat allVersionNumberByteArrays"

	| byteArrays |
	byteArrays := OrderedCollection new.
	KnownVersionNumbers do: [:version |
		byteArrays add: ((WriteStream on: (ByteArray new: 4)) nextNumber: 4 put: version; yourself) contents.
		byteArrays add: ((WriteStream on: (ByteArray new: 8)) nextNumber: 8 put: version; yourself) contents.
		byteArrays add: ((WriteStream on: (ByteArray new: 4)) nextLittleEndianNumber: 4 put: version; yourself) contents.
		byteArrays add: ((WriteStream on: (ByteArray new: 8)) nextLittleEndianNumber: 8 put: version; yourself) contents].
	^byteArrays
]

{ #category : #'initialize-release' }
ImageFormat class >> baseVersionMask [
	"Mask the bits associated with base format number exclusive of capability bits"

	"ImageFormat baseVersionMask printStringBase: 2"

	^ BaseVersionNumbers
		inject: 0
		into: [:accum :e | accum bitOr: e]

]

{ #category : #'initialize-release' }
ImageFormat class >> baseVersionNumbers [
	"The well-known image format versions for basic 32 and 64 bit images,
	including images that require closure bytecode support. These base
	format numbers my be modified by application of various capability bits
	representing additional requirements that the image expects to be
	supported by the virtual machine."

	^#(6502 6504 68000 68002)

]

{ #category : #'image formats' }
ImageFormat class >> bitsInUse [
	"Answer a mask of the bits used by all known version format numbers"

	"Transcript cr; show: (ImageFormat bitsInUse printStringBase: 2)"

	^ self baseVersionMask bitOr: self capabilitiesBitsMask
]

{ #category : #'initialize-release' }
ImageFormat class >> capabilitiesBitsMask [
	"Bits currently used as capability bits."
	
	"ImageFormat capabilitiesBitsMask printStringBase: 2"

	^PlatformByteOrderBit "only one so far"

]

{ #category : #utility }
ImageFormat class >> createCkStatusProgram [
	"Create ckformat source file in the default directory"

	"ImageFormat createCkStatusProgram"

	^self storeCkstatusOnFile: 'ckformat.c' 
]

{ #category : #'instance creation' }
ImageFormat class >> default [
	"The original Squeak image format number"

	^ self wordSize: 4
]

{ #category : #'instance creation' }
ImageFormat class >> fromBytes: bytes [
	^ self fromStream: (ReadStream on: bytes)

]

{ #category : #'instance creation' }
ImageFormat class >> fromFile: imageFile [
	"Answer a new instance from a saved image file. The image format number
	is saved in the first 4 or 8 bytes of the file. Word size and byte ordering are
	dependent on the image and platform that saved the file, and must be decoded
	to obtain the image format."

	"ImageFormat fromFile: Smalltalk imageName"

	| f |
	f := (FileStream oldFileNamed: imageFile) ifNil: [FileStream readOnlyFileNamed: imageFile].
	f ifNotNil: [f binary.
		^self fromStream: f].
	^self error: 'could not open ', imageFile

]

{ #category : #'instance creation' }
ImageFormat class >> fromInteger: anInteger [
	"Answer a new instance from an integer, typically obtained from an
	image file header."

	^ self new fromInteger: anInteger
]

{ #category : #'instance creation' }
ImageFormat class >> fromStream: stream [
	"Answer a new instance from a saved image file stream. Word size and byte ordering
	are dependent on the image and platform that saved the file, and must be decoded
	to obtain the image format."

	| num |
	num := stream nextNumber: 4.  "try 32 bit big endian format"
	[^ self fromInteger: num]
		on: Error
		do: [stream position: 0.
			num := stream nextLittleEndianNumber: 4. "try 32 bit little endian format"
			^ self fromInteger: num]
			on: Error
			do: [stream position: 0.
				num := stream nextNumber: 8. "try 64 bit big endian format"
				^ self fromInteger: num]
				on: Error
				do: [stream position: 0.
					num := stream nextLittleEndianNumber: 8. "try 64 bit little endian format"
					^ self fromInteger: num].
	self error: 'unrecognized image format'
]

{ #category : #utility }
ImageFormat class >> generateCkStatusProgram: programName on: stream [
	"Generate source code for an image format version reader. The program
	is intended for testing image file format from a unix shell script such that
	the shell script can decide what VM to run based on image requirements."

	| formatNumber |
	stream nextPutAll: '/* ', programName, ': Print the image format number on standard output */'; cr;
			nextPutAll: '/* for use in a shell script to test image format requirements. */'; cr;
			nextPutAll: '/* A non-zero return status code indicates failure. */'; cr; cr;
			nextPutAll: '/* Usage: ', programName, ' imageFileName */'; cr; cr;
			nextPutAll: '/* --- DO NOT EDIT THIS FILE --- */'; cr;
			nextPutAll: '/* --- Automatically generated from class ', self name, ' ', DateAndTime now asString, '--- */'; cr;
			nextPutAll: '/* --- Souce code is in package ImageFormat, archive www.squeaksource.com/VMMaker --- */'; cr;
			nextPutAll: '/* --- DO NOT EDIT THIS FILE --- */'; cr; cr;
			nextPutAll: '#include <stdio.h>'; cr;
			nextPutAll: '#include <stdlib.h>'; cr;
			nextPutAll: '#include <string.h>'; cr; cr;
			nextPutAll: 'main(int argc, char **argv) {'; cr;
			tab; nextPutAll: 'FILE *f;'; cr;
			tab; nextPutAll: 'unsigned char buf[8];'; cr;		
			tab; nextPutAll: 'int formatNumber;'; cr;		
			tab; nextPutAll: 'unsigned char c;'; cr;		
			tab; nextPutAll: 'int match;'; cr;		
			tab; nextPutAll: 'if (argc != 2) {'; cr;
			tab; tab; nextPutAll: 'printf("usage: ', programName,  ' imageFileName\n");'; cr;
			tab; tab; nextPutAll: 'exit(1);'; cr;
			tab; nextPutAll: '}'; cr;
			tab; nextPutAll: 'f = fopen(argv[1], "r");'; cr;
			tab; nextPutAll: 'if (f == NULL) {'; cr;
			tab; tab; nextPutAll: 'perror(argv[1]);'; cr;
			tab; tab; nextPutAll: 'exit(2);'; cr;
			tab; nextPutAll: '}'; cr;
			tab; nextPutAll: 'if (fread(buf, 1, 8, f) < 8) {'; cr;
			tab; tab; nextPutAll: 'fprintf(stderr, "cannot read %s\n", argv[1]);'; cr;
			tab; tab; nextPutAll: 'exit(3);'; cr;
			tab; nextPutAll: '}'; cr.
	self versionNumberByteArrays withIndexDo: [ :v :tag | | b |
		formatNumber := (self fromBytes: v) asInteger.
		b := 'b_', formatNumber asString, '_', tag asString.
		stream tab; nextPutAll: 'unsigned char ', b, '[', v size asString, ']= { '.
		v inject: true into: [:first : elem |
			first ifFalse: [stream nextPutAll: ', '].
			stream nextPutAll: elem asString.
			false].
		stream nextPutAll: '};'; cr;
				tab; nextPutAll: 'if (strncmp(buf, ', b, ', ', v size asString, ') == 0) {'; cr;
				tab; tab; nextPutAll: 'printf("%d", ', formatNumber, ');'; cr;
				tab; tab; nextPutAll: 'exit(0);'; cr;
				tab; nextPutAll: '}'; cr].
	stream tab; nextPutAll: 'printf("0"); /* print an invalid format number */';cr;
			tab; nextPutAll: 'exit (-1); /* not found, exit with error code */'; cr;
			nextPutAll: '}'; cr

]

{ #category : #'initialize-release' }
ImageFormat class >> initialize [
	"ImageFormat initialize"

	BaseVersionNumbers := self baseVersionNumbers.
	BaseVersionMask := self baseVersionMask.
	CapabilitiesBitsMask := self capabilitiesBitsMask.
	ReservedBitsMask := self reservedBitsMask.
	KnownVersionNumbers := self knownVersionNumbers.
	PlatformByteOrderBit := 1
]

{ #category : #'initialize-release' }
ImageFormat class >> knownVersionNumbers [
	"Version number currently in use or likely to be used (e.g. 64-bit Cog formats)"

	"ImageFormat knownVersionNumbers collect: [:e | (ImageFormat fromInteger: e) description]"

	^ #(6502 6504 6505 68000 68002 68003)
]

{ #category : #'initialize-release' }
ImageFormat class >> reservedBitsMask [
	"Bits available for use as capability bits. Reserve high order bit as the
	extension bit, to be set true if additional bits are required in the future."
	
	"ImageFormat reservedBitsMask printStringBase: 2"

	^(16rFFFFFFFF bitXor: BaseVersionMask)
		bitAt: PlatformByteOrderBit put: 0

]

{ #category : #utility }
ImageFormat class >> storeCkstatusOnFile: fileName [
	"Store source code for an image format version reader in a file. The program
	is intended for testing image file format from a unix shell script such that
	the shell script can decide what VM to run based on image requirements."

	| f |
	f := CrLfFileStream newFileNamed: fileName.
	[self generateCkStatusProgram: 'ckformat' on: f]
		ensure: [f ifNotNil: [f close]].
	^fileName
]

{ #category : #'instance creation' }
ImageFormat class >> thisImageFileFormat [
	"The image format read from the header of the file from which the current
	image was loaded. This may be different from the current format if the VM
	has modified the image at load time or in the course of running the image."

	"ImageFormat thisImageFileFormat description"

	^self fromFile: Smalltalk imageName

]

{ #category : #'image formats' }
ImageFormat class >> versionDescriptions [

	"ImageFormat versionDescriptions"
	"ImageFormat versionDescriptions do: [:e | Transcript cr; show: e]"

	^ Dictionary
		withAll: (KnownVersionNumbers
				collect: [:e | e -> (self fromInteger: e) description])
]

{ #category : #'image formats' }
ImageFormat class >> versionNumberByteArrays [
	"All byte array expressions of known version numbers. These are the possible values
	that may appear in the first 4 or 8 bytes of a saved image file. A 64 bit image saves
	its image format number as a 64 bit value in the file header, and a 32 bit image saves
	its image format as a 32 bit value. The value may be stored in little endian or big endian
	byte ordering depending on the host platform."

	"ImageFormat versionNumberByteArrays do: [:e |
		Transcript cr; show: e printString , ': ', (ImageFormat fromBytes: e) description]"

	^self allVersionNumberByteArrays select: [:e |
		e size = (self fromBytes: e) wordSize]

]

{ #category : #'instance creation' }
ImageFormat class >> wordSize: bytesPerWord [
	bytesPerWord = 4
		ifTrue: [^self new fromInteger: 6502].
	bytesPerWord = 8
		ifTrue: [^self new fromInteger: 68000].
	self error: 'unsupported word size ', bytesPerWord
]

{ #category : #'instance creation' }
ImageFormat class >> wordSize: bytesPerWord closures: aBoolean [

	^(self wordSize: bytesPerWord) setClosureSupportRequirement: aBoolean

]

{ #category : #'instance creation' }
ImageFormat class >> wordSize: bytesPerWord cog: cogRequired [

	^(self wordSize: bytesPerWord)
		setClosureSupportRequirement: cogRequired;
		setCogSupportRequirement: cogRequired

]

{ #category : #converting }
ImageFormat >> asInteger [
	"Answer an integer representation of this image format suitable for storage
	in an image file header. The stored value in the file header will be used when
	loading the image from the snapshot file."

	| val |
	val := wordSize = 4
		ifTrue: [6502]
		ifFalse: [68000].
	self requiresClosureSupport ifTrue: [val := val + 2].
	self requiresPlatformByteOrder ifTrue: [val := val + 1].
	^val

]

{ #category : #private }
ImageFormat >> baseVersionBits [
	"Answer the bits associated with base format number exclusive of capability bits"

	^self baseVersionBitsOf: self asInteger

]

{ #category : #private }
ImageFormat >> baseVersionBitsOf: anInteger [
	"Answer the bits of anInteger associated with base format number exclusive
	of capability bits"

	^ anInteger bitAnd: BaseVersionMask
]

{ #category : #printing }
ImageFormat >> description [

	"(ImageFormat fromInteger: 6502) description"

	^String streamContents: [:s | self printDescriptionOn: s]

]

{ #category : #'initialize-release' }
ImageFormat >> fromInteger: anInteger [
	"Initialize a new instance from anInteger obtained from an image file header."

	| baseVersion capabilitiesBits |
	(anInteger bitAnd: ReservedBitsMask) ~= 0
		ifTrue: [self error: 'invalid format number ', anInteger printString].
	baseVersion := self  baseVersionBitsOf: anInteger.
	(baseVersion = 6504 or: [baseVersion = 68002])
		ifTrue: [requiresClosureSupport := true].
	(baseVersion = 6502 or: [baseVersion = 6504])
		ifTrue: [wordSize := 4]
		ifFalse: [(baseVersion = 68000 or: [baseVersion = 68002])
			ifTrue: [wordSize := 8]
			ifFalse: [self error: 'invalid format number ', anInteger printString]].
	capabilitiesBits := anInteger bitAnd: CapabilitiesBitsMask.
	(capabilitiesBits bitAt: PlatformByteOrderBit) = 1
		ifTrue: [requiresPlatformByteOrder := true.
			requiresClosureSupport
				ifFalse: [self error: 'Images requiring platform byte order also require closure support (Cog)'].
			capabilitiesBits := capabilitiesBits bitAt: PlatformByteOrderBit put: 0].
	"add additional capability bit handling here"
	capabilitiesBits == 0
		ifFalse: [self error: 'invalid format number ', anInteger printString]
	

]

{ #category : #'initialize-release' }
ImageFormat >> initialize [
	requiresClosureSupport := false.
	requiresPlatformByteOrder := false
]

{ #category : #testing }
ImageFormat >> is32Bit [
	"True if the image uses 4 byte object memory words and 4 byte object pointers."
	^wordSize = 4
]

{ #category : #testing }
ImageFormat >> is64Bit [
	"True if the image uses 8 byte object memory words and 8 byte object pointers."
	^wordSize = 8
]

{ #category : #private }
ImageFormat >> isValidVersionNumber [
	"True if the version number uses a known base version number and does not
	use any reserved bits. Used only for unit tests, by definition this must always
	be true."

	^(BaseVersionNumbers includes: self baseVersionBits)
		and: [(self asInteger bitAnd: ReservedBitsMask) = 0]
]

{ #category : #printing }
ImageFormat >> printDescriptionOn: stream [

		stream nextPutAll: 'A ';
			nextPutAll: (wordSize * 8) asString;
			nextPutAll: '-bit image with '.
		self requiresClosureSupport ifFalse: [stream nextPutAll: 'no '].
		stream nextPutAll: 'closure support and '.
		self requiresPlatformByteOrder ifFalse: [stream nextPutAll: 'no '].
		stream nextPutAll: 'Cog byte reversal'.
		stream nextPutAll: ' (';
			nextPutAll: self asInteger asString;
			nextPut: $).
		^ stream

]

{ #category : #printing }
ImageFormat >> printOn: aStream [

	aStream nextPutAll: 'ImageFormat fromInteger: ', self asInteger asString

]

{ #category : #testing }
ImageFormat >> requiresClosureSupport [
	"True if this image contains closure bytecodes that must be supported by
	the virtual machine."
	^requiresClosureSupport
]

{ #category : #testing }
ImageFormat >> requiresPlatformByteOrder [
	"True if this image requires a Cog VM (stack VM possibly including a Cog jitter)"
	^requiresPlatformByteOrder
]

{ #category : #'initialize-release' }
ImageFormat >> setClosureSupportRequirement: aBoolean [
	"If true, the image expects the virtual machine to be able to provide support
	for closure bytecodes that are present in the image. If false, the image does
	not require this support, although the virtual machine is free to provide it."

	requiresClosureSupport := aBoolean

]

{ #category : #'initialize-release' }
ImageFormat >> setCogSupportRequirement: aBoolean [
	"If true, the image expects the virtual machine to be able to provide Cog
	support, either in the form of a Stack VM or a Cog VM. If false, the image does
	not require this support, although the virtual machine is free to provide it."

	aBoolean ifTrue: [requiresClosureSupport := true]. "required in all Cog images"
	self setPlatformByteOrderRequirement: aBoolean

]

{ #category : #'initialize-release' }
ImageFormat >> setPlatformByteOrderRequirement: aBoolean [
	"If true, certain object are implemented in native platform byte order.
	The StackInterpreter and Cog make use of this for performance reasons."

	requiresPlatformByteOrder := aBoolean

]

{ #category : #accessing }
ImageFormat >> wordSize [
	^ wordSize
]
