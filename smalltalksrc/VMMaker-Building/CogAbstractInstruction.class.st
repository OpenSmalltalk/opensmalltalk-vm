"
I am an abstract instruction generated by the Cogit.  I am subsequently concretized to machine code for the current processor.  A sequence of concretized CogAbstractInstructions are concatenated to form the code for a CogMethod.  I am an abstract class.  My concrete subclasses concretize to the machine code of a specific processor.
"
Class {
	#name : #CogAbstractInstruction,
	#superclass : #VMStructType,
	#instVars : [
		'opcode',
		'machineCodeSize',
		'maxSize',
		'machineCode',
		'operands',
		'address',
		'dependent',
		'cogit',
		'objectMemory',
		'bcpc'
	],
	#classVars : [
		'NumOperands'
	],
	#pools : [
		'CogRTLOpcodes'
	],
	#category : #'VMMaker-JIT'
}

{ #category : #'simulation only' }
CogAbstractInstruction class >> byteSizeForSimulator: aVMClass [
	"Answer an approximation of the byte size of an AbstractInstruction struct.
	 This is for estimating the alloca in allocateOpcodes:bytecodes:ifFail:"
	| concreteClass ptrsize |
	concreteClass := aVMClass processor abstractInstructionCompilerClass.
	ptrsize := aVMClass sizeof: #'void *'.
	^concreteClass instSize - 4 "cogit, objectMemory et al" * ptrsize
	+ concreteClass basicNew machineCodeBytes
		roundTo: ptrsize
]

{ #category : #'instance creation' }
CogAbstractInstruction class >> for: aCogit [
	^self new cogit: aCogit
]

{ #category : #'class initialization' }
CogAbstractInstruction class >> initialize [
	NumOperands := 3
]

{ #category : #translation }
CogAbstractInstruction class >> instVarNamesAndTypesForTranslationDo: aBinaryBlock [
	"enumerate aBinaryBlock with the names and C type strings for the inst vars to include in an AbstractInstruction struct."
	"{CogAbstractInstruction. CogIA32Compiler. CogARMCompiler} do:
		[:c| Transcript print: c; cr. c printTypedefOn: Transcript]"
	| machineCodeBytes |
	machineCodeBytes := self ==  CogAbstractInstruction
								ifTrue: [0]
								ifFalse: [self basicNew machineCodeBytes].
	(self filteredInstVarNames copyWithout: 'machineCode'), #('machineCode') do:
		[:ivn|
		ivn ~= 'bcpc' ifTrue:
			[aBinaryBlock
				value: ivn
				value: (ivn caseOf: {
							['address']			-> ['unsigned long'].
							['machineCode']	-> [{'unsigned char'. '[', machineCodeBytes printString, ']'}].
							['operands']		-> [{'unsigned long'. '[', NumOperands, ']'}].
							['dependent']		-> ['struct _AbstractInstruction *']}
						otherwise:
							[#char])]]
]

{ #category : #testing }
CogAbstractInstruction class >> isAbstract [
	^self == CogAbstractInstruction
]

{ #category : #translation }
CogAbstractInstruction class >> isAccessor: aSelector [
	^(#(cogit coInterpreter objectMemory) includes: aSelector) not
	   and: [super isAccessor: aSelector]
]

{ #category : #'debug printing' }
CogAbstractInstruction class >> nameForOpcode: opcode [ "<Integer>"
	^(CogRTLOpcodes nameForOpcode: opcode)
		ifNotNil:
			[:opcodeName| opcodeName]
		ifNil:
			[(self classPool keyAtValue: opcode ifAbsent: [])
				ifNotNil: [:opcodeName| opcodeName]
				ifNil: [opcode printString]]
]

{ #category : #translation }
CogAbstractInstruction class >> requiredMethodNames: options [
	^self selectors reject:
		[:s|
		(self isAccessor: s)
		or: [((self compiledMethodAt: s) pragmaAt: #doNotGenerate) notNil]]
]

{ #category : #verification }
CogAbstractInstruction class >> specificOpcodes [
	^self subclassResponsibility
]

{ #category : #translation }
CogAbstractInstruction class >> structTypeName [
	^'AbstractInstruction'
]

{ #category : #translation }
CogAbstractInstruction class >> typeForSelf [
	"Answer the type to give self if appropriate, or nil if not.
	 In C all subclasses are mapped to the AbstractInstruction type."
	^#'AbstractInstruction *'
]

{ #category : #verification }
CogAbstractInstruction class >> unimplementedOpcodes [
	"Check computeMaximumSize and dispatchConcretize for unimplemented opcodes."
	"self subclasses collect: [:compiler| {compiler. compiler unimplementedOpcodes}]"
	| opcodes cmsLiterals dcLiterals |
	opcodes := CogRTLOpcodes opcodes, self specificOpcodes.
	cmsLiterals := (self >> #computeMaximumSize) literals
						select: [:l| l isVariableBinding]
						thenCollect: [:l| l key].
	dcLiterals := (self >> #dispatchConcretize) literals
						select: [:l| l isVariableBinding]
						thenCollect: [:l| l key].
	^Dictionary new
		at: #computeMaximumSize put: (opcodes reject: [:opcode| cmsLiterals includes: opcode]);
		at: #dispatchConcretize put: (opcodes reject: [:opcode| dcLiterals includes: opcode]);
		yourself
]

{ #category : #verification }
CogAbstractInstruction class >> usedUnimplementedOpcodes [
	"Check for uses of unimplemented opcodes"
	"self subclasses collect: [:compiler| {compiler. compiler usedUnimplementedOpcodes}]"
	| genericUnimplementedOpcodeBindings specificUnimplementedOpcodeBindings |
	genericUnimplementedOpcodeBindings := Set new.
	specificUnimplementedOpcodeBindings := Set new.
	self unimplementedOpcodes do:
		[:arrayOfOpcodes|
		arrayOfOpcodes do:
			[:opcode|
			(self bindingOf: opcode)
				ifNotNil: [:b| specificUnimplementedOpcodeBindings add: b]
				ifNil: [genericUnimplementedOpcodeBindings add: (CogRTLOpcodes bindingOf: opcode)]]].
	^ { (SystemNavigation new allCallsOn: genericUnimplementedOpcodeBindings localToPackage: #VMMaker)
			inject: Set new
			into:  [:them :methodRef| "These should be in Cogit's abstract instructions category"
				them
					addAll: (SystemNavigation new allCallsOn: methodRef method selector localToPackage: #VMMaker);
					yourself].
		SystemNavigation new allCallsOn: specificUnimplementedOpcodeBindings localToPackage: #VMMaker }
]

{ #category : #comparing }
CogAbstractInstruction >> <= anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^false]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) <= (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #comparing }
CogAbstractInstruction >> > anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^true]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) > (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #comparing }
CogAbstractInstruction >> >= anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows: and CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	anAbstractInstruction isInteger ifTrue:
		[self assert: anAbstractInstruction < 16.
		 ^true]. 
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) >= (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #private }
CogAbstractInstruction >> abstractRegisterForConcreteRegister: reg [
	(self concreteRegister: TempReg) = reg ifTrue: [^TempReg].
	(self concreteRegister: ReceiverResultReg) = reg ifTrue: [^ReceiverResultReg].
	(self concreteRegister: ClassReg) = reg ifTrue: [^ClassReg].
	(self concreteRegister: SendNumArgsReg) = reg ifTrue: [^SendNumArgsReg].
	(self concreteRegister: Arg0Reg) = reg ifTrue: [^Arg0Reg].
	(self concreteRegister: Arg1Reg) = reg ifTrue: [^Arg1Reg].
	(self concreteRegister: FPReg) = reg ifTrue: [^FPReg].
	(self concreteRegister: SPReg) = reg ifTrue: [^SPReg].
	self error: 'could not find abstract register'.
	^0

	"While the below works fine in Smalltalk it of course doesn't work in C ;)"
	
	"^reg caseOf: {
		[self concreteRegister: TempReg] -> [TempReg].
		[self concreteRegister: ReceiverResultReg] -> [ReceiverResultReg].
		[self concreteRegister: ClassReg] -> [ClassReg].
		[self concreteRegister: SendNumArgsReg] -> [SendNumArgsReg].
		[self concreteRegister: Arg0Reg] -> [Arg0Reg].
		[self concreteRegister: Arg1Reg] -> [Arg1Reg].
		[self concreteRegister: FPReg] -> [FPReg].
		[self concreteRegister: SPReg] -> [SPReg] }"
]

{ #category : #accessing }
CogAbstractInstruction >> addDependent: anInstruction [
	<var: #anInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	dependent notNil ifTrue:
		[anInstruction dependent: dependent].
	^dependent := anInstruction
]

{ #category : #accessing }
CogAbstractInstruction >> address [
	^address
]

{ #category : #accessing }
CogAbstractInstruction >> address: theAddress [
	^address := theAddress
]

{ #category : #coercion }
CogAbstractInstruction >> asInteger [
	<doNotGenerate>
	^self
]

{ #category : #coercion }
CogAbstractInstruction >> asUnsignedInteger [
	<doNotGenerate>
	^self
]

{ #category : #'register allocation' }
CogAbstractInstruction >> availableRegisterOrNilFor: liveRegsMask [
	"Answer an unused abstract register in the liveRegMask.
	 Subclasses with more registers can override to answer them."
	<returnTypeC: #sqInt>
	(liveRegsMask anyMask: (cogit registerMaskFor: Arg1Reg)) ifFalse:
		[^Arg1Reg].
	(liveRegsMask anyMask: (cogit registerMaskFor: Arg0Reg)) ifFalse:
		[^Arg0Reg].
	(liveRegsMask anyMask: (cogit registerMaskFor: SendNumArgsReg)) ifFalse:
		[^SendNumArgsReg].
	(liveRegsMask anyMask: (cogit registerMaskFor: ClassReg)) ifFalse:
		[^ClassReg].
	(liveRegsMask anyMask: (cogit registerMaskFor: ReceiverResultReg)) ifFalse:
		[^ReceiverResultReg].
	^nil
]

{ #category : #accessing }
CogAbstractInstruction >> bcpc [
	^bcpc
]

{ #category : #accessing }
CogAbstractInstruction >> bcpc: theBcpc [
	^bcpc := theBcpc
]

{ #category : #comparing }
CogAbstractInstruction >> between: min and: max [
	"Support for CogBytecodeFixup>targetInstruction testing:"
	<doNotGenerate>
	| opcodesArray |
	(min isInteger and: [max isInteger]) ifTrue:
		[^false].
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self)
		between: (opcodesArray identityIndexOf: min)
		and: (opcodesArray identityIndexOf: max)
]

{ #category : #accessing }
CogAbstractInstruction >> cResultRegister [
	"Answer the abstract register for the C result register.
	 Only partially implemented (there is as yet no CResultReg abstract reg).
	 Works on x86 since TempReg = EAX = C result reg."
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> callInstructionByteSize [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> callerSavedRegisterMask [
	"Answer an abstract register mask as computed by StackToRegisterMappingCogit registerMaskFor:"
	self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> callsAreRelative [
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canDivQuoRem [
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canMulRR [
	^self subclassResponsibility
]

{ #category : #initialization }
CogAbstractInstruction >> cogit: aCogit [
	<doNotGenerate>
	cogit := aCogit.
	objectMemory := aCogit objectMemory
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> computeJumpTargetOffsetPlus: anPCOffset [
	<inline: true> "Since it's an extraction from other methods."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := self jumpTargetAddress.
	^jumpTarget signedIntFromLong - (address + anPCOffset) signedIntFromLong.
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeAt: actualAddress [
	"Generate concrete machine code for the instruction at actualAddress,
	 setting machineCodeSize, and answer the following address."
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFill16 [
	"fill with (operand 0 bitAnd: 16rFFFF) according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFill32 [
	"fill with operand 0 according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFillFromWord [
	"fill with operand 0 + operand 1 according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeLabel [
	<inline: true>
	<var: #dependentChain type: #'AbstractInstruction *'>
	| dependentChain |
	dependentChain := dependent.
	[dependentChain isNil] whileFalse:
		[dependentChain updateLabel: self.
		 dependentChain := dependentChain dependent].
	^machineCodeSize := 0
]

{ #category : #accessing }
CogAbstractInstruction >> dependent [
	^dependent
]

{ #category : #accessing }
CogAbstractInstruction >> dependent: anInstruction [
	^dependent := anInstruction
]

{ #category : #abi }
CogAbstractInstruction >> genAlignCStackSavingRegisters: saveRegs numArgs: numArgs wordAlignment: alignment [ 
	| wordsPushedModAlignment delta |
	wordsPushedModAlignment := ((saveRegs ifTrue: [self numberOfSaveableRegisters] ifFalse: [0])
									+ numArgs)
									\\ alignment.
	wordsPushedModAlignment ~= 0 ifTrue:
		[delta := alignment - wordsPushedModAlignment.
		 cogit SubCq: delta * 4 R: SPReg].
	^0
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPGreater: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPGreater operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPGreaterOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPGreaterOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPLess: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPLess operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPLessOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPLessOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPNotEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPNotEqual operand: jumpTarget asInteger
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadCStackPointer [
	"Load the stack pointer register with that of the C stack, effecting
	 a switch to the C stack.  Used when machine code calls into the
	 CoInterpreter run-time (e.g. to invoke interpreter primitives)."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadCStackPointers [
	"Load the frame and stack pointer registers with those of the C stack,
	 effecting a switch to the C stack.  Used when machine code calls into
	 the CoInterpreter run-time (e.g. to invoke interpreter primitives)."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genLoadStackPointers [
	"Switch back to the Smalltalk stack. Assign SPReg first
	 because typically it is used immediately afterwards."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genPushRegisterArgsForAbortMissNumArgs: numArgs [
	"Ensure that the register args are pushed before the outer and
	 inner retpcs at an entry miss for arity <= self numRegArgs.  The
	 outer retpc is that of a call at a send site.  The inner is the call
	 from a method or PIC abort/miss to the trampoline."

	"This won't be as clumsy on a RISC.  But putting the receiver and
	 args above the return address means the CoInterpreter has a
	 single machine-code frame format which saves us a lot of work."

	"Iff there are register args convert
		base	->	outerRetpc		(send site retpc)
		sp		->	innerRetpc		(PIC abort/miss retpc)
	 to
		base	->	receiver
					(arg0)
					(arg1)
					outerRetpc
		sp		->	innerRetpc		(PIC abort/miss retpc)"
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genPushRegisterArgsForNumArgs: numArgs [
	"Ensure that the register args are pushed before the retpc for arity <= self numRegArgs."
	"This won't be as clumsy on a RISC.  But putting the receiver and
	 args above the return address means the CoInterpreter has a
	 single machine-code frame format which saves us a lot of work."

	"This won't be as clumsy on a RISC.  But putting the receiver and
	 args above the return address means the CoInterpreter has a
	 single machine-code frame format which saves us a lot of work."

	"Iff there are register args convert
		sp		->	retpc		(send site retpc)
	 to
		base	->	receiver
					(arg0)
					(arg1)
		sp		->	retpc		(send site retpc)"
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genSaveRegisters [
	"Save the general purpose registers for a trampoline call."
	self subclassResponsibility
]

{ #category : #'smalltalk calling convention' }
CogAbstractInstruction >> genSaveStackPointers [
	"Save the frame and stack pointer registers to the framePointer
	 and stackPointer variables.  Used to save the machine code frame
	 for use by the run-time when calling into the CoInterpreter run-time."
	self subclassResponsibility
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genSubstituteReturnAddress: retpc [
	"Fake the return address for a call/jump so that the ``call'' returns
	 to retpc given that the ``call'' will be made by a following jump."
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> genWriteCResultIntoReg: abstractRegister [
	| cResultReg |
	cResultReg := self cResultRegister.
	abstractRegister ~= cResultReg ifTrue:
		[cogit gen: MoveRR operand: cResultReg operand: abstractRegister]
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> generateICacheFlush [
	"A dummy routine.
	 Processors that can generate code to flush the icache can override."

]

{ #category : #'multi-threading' }
CogAbstractInstruction >> generateLowLevelTryLock: vmOwnerLockAddress [
	self subclassResponsibility
]

{ #category : #'multi-threading' }
CogAbstractInstruction >> generateLowLevelUnlock: vmOwnerLockAddress [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> getJmpTarget [
	"Get the target of a jump instruction.  Jumps have the target in the first operand."
	^cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'
]

{ #category : #testing }
CogAbstractInstruction >> hasDoublePrecisionFloatingPointSupport [
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasLinkRegister [
	"Answer if the processor has a link register, i.e. if calls pass
	 the return pc in a register instead of pushing it on a stack."
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasPCDependentInstructions [
	"Answer whether the concrete machine code contains pc-dependent
	 instructions, such as the IA32/x86's short and long relative jumps
	 and the EMT64/x86-64's pc-relative addressing mode.  Such
	 instructions require an extra pass to generate them correctly."
	^false
]

{ #category : #testing }
CogAbstractInstruction >> hasPCRegister [
	"Answer if the processor has a generally addressable pc register, such as the ARM.
	 On such processors we can execute jumping to pop top of stack by popping into
	 the pc register.  Note that this is not a generic RISC feature.  The PowerPC does not
	 allow one to pop into the pc for example.  So by default, answer false."
	^false
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> implicitReceiveCacheAt: callSiteReturnAddress [
	"Answer the implicit receiver cache for the return address
	 of a call to the ceImplicitReceiverTrampoline."
	<option: #NewspeakVM>
	^self subclassResponsibility
]

{ #category : #initialization }
CogAbstractInstruction >> initialize [
	"This method intializes the Smalltalk instance.  The C instance is merely a struct and doesn't need initialization."
	<doNotGenerate>
	operands := CArrayAccessor on: (Array new: NumOperands).
	machineCode := CArrayAccessor on: (ByteArray new: self machineCodeBytes)
]

{ #category : #testing }
CogAbstractInstruction >> isAFixup: fixupOrAddress [
	<var: #fixupOrAddress type: #'void *'>
	^cogit addressIsInFixups: fixupOrAddress
]

{ #category : #testing }
CogAbstractInstruction >> isAnInstruction: addressOrInstruction [
	<var: #addressOrInstruction type: #'AbstractInstruction *'>
	^cogit addressIsInInstructions: addressOrInstruction
]

{ #category : #testing }
CogAbstractInstruction >> isBigEndian [
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isCallPreceedingReturnPC: mcpc [
	"Assuming mcpc is a return pc answer if the instruction before it is a call."
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isJump [
	^opcode between: FirstJump and: LastJump
]

{ #category : #testing }
CogAbstractInstruction >> isLongJump [
	^opcode between: FirstJump and: FirstShortJump - 1
]

{ #category : #testing }
CogAbstractInstruction >> isPCDependent [
	"Answer if the receiver is a pc-dependent instruction, such as a relative jump."
	^self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jmpTarget: anAbstractInstruction [
	"Set the target of a jump instruction.  These all have the target in the first operand."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #anAbstractInstruction type: #'AbstractInstruction *'>
	self cCode: [] "check for inadvertent smashing of already-set jmpTargets; development only"
		inSmalltalk: [self assert: ((operands at: 0)
									ifNil: [true]
									ifNotNil: [:o| o = 0 or: [self isAFixup: o]])].
	operands at: 0 put: anAbstractInstruction asUnsignedInteger.
	^anAbstractInstruction
]

{ #category : #accessing }
CogAbstractInstruction >> jumpLongByteSize [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jumpLongConditionalByteSize [
	self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> jumpLongTargetBeforeFollowingAddress: mcpc [
	^self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jumpShortByteSize [
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> jumpTargetAddress [
	<inline: true> "Since it's an extraction from other methods."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'.
	cogit assertSaneJumpTarget: jumpTarget.
	(self isAnInstruction: jumpTarget) ifTrue:
		[jumpTarget := cogit cCoerceSimple: jumpTarget address to: #'AbstractInstruction *'].
	self assert: jumpTarget ~= 0.
	^jumpTarget
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> labelOffset [
	"To arrange that the block method field pushed in a block entry has
	 its MFMethodFlagIsBlockFlag bit set we provide labels with an offset.
	 The offset for the fakeHeader reference is MFMethodFlagIsBlockFlag.
	 See compileBlockFrameBuild:"
	^operands at: 1
]

{ #category : #accessing }
CogAbstractInstruction >> loadLiteralByteSize [
	"Answer the byte size of a MoveCwR opcode's corresponding machine code"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> longJumpTargetAddress [
	<inline: true> "Since it's an extraction from other methods."
	"This needs to be digfferent from jumpTargetAddress because long jumps can
	be to absolute addresses and hence we can't assert that the jump target is sane."
	| jumpTarget |
	<var: #jumpTarget type: #'AbstractInstruction *'>
	jumpTarget := cogit cCoerceSimple: (operands at: 0) to: #'AbstractInstruction *'.
	(self isAnInstruction: jumpTarget) ifTrue:
		[jumpTarget := cogit cCoerceSimple: jumpTarget address to: #'AbstractInstruction *'].
	self assert: jumpTarget ~= 0.
	^jumpTarget
]

{ #category : #accessing }
CogAbstractInstruction >> machineCode [
	^machineCode
]

{ #category : #accessing }
CogAbstractInstruction >> machineCode: anObject [
	"Set the value of machineCode"

	machineCode := anObject
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> machineCodeBytes [
	"Answer the maximum number of bytes of machine code generated for any abstract instruction."
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> machineCodeSize [
	^machineCodeSize
]

{ #category : #accessing }
CogAbstractInstruction >> machineCodeSize: size [ "<signed byte>"
	^machineCodeSize := size
]

{ #category : #accessing }
CogAbstractInstruction >> maxSize [
	^maxSize
]

{ #category : #accessing }
CogAbstractInstruction >> maxSize: anObject [
	"Set the value of maxSize"

	maxSize := anObject
]

{ #category : #printing }
CogAbstractInstruction >> nameForRegister: reg [ "<Integer>"
	"subclasses with special purpose registers may need to override."
	<doNotGenerate>
	^CogRTLOpcodes nameForRegister: reg
]

{ #category : #initialization }
CogAbstractInstruction >> numCheckFeaturesOpcodes [
	"If the priocessor has a feature check facility answer the number
	 of opcodes required to compile an accessor for the feature."
	^0
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> numICacheFlushOpcodes [
	"If the processor has the ablity to generate code to flush the icache answer
	 the number of opcodes required to compile an accessor for the feature."
	^0
]

{ #category : #'multi-threading' }
CogAbstractInstruction >> numLowLevelLockOpcodes [
	self subclassResponsibility
]

{ #category : #abi }
CogAbstractInstruction >> numberOfSaveableRegisters [
	"Answer the number of registers to be saved in a trampoline call that saves registers.
	 See genSaveRegisters"
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> opcode [
	^opcode
]

{ #category : #accessing }
CogAbstractInstruction >> opcode: value [
	^opcode := value
]

{ #category : #accessing }
CogAbstractInstruction >> operands [
	^operands
]

{ #category : #accessing }
CogAbstractInstruction >> operands: anObject [
	"Set the value of operands"

	operands := anObject
]

{ #category : #printing }
CogAbstractInstruction >> printStateOn: aStream [
	| opcodeName orneryOperands format |
	<doNotGenerate> "Smalltalk-side only"
	opcode isNil ifTrue:
		[^self].
	aStream space; nextPut: $(; nextPutAll: (opcodeName := self class nameForOpcode: opcode).
	orneryOperands := operands isCObjectAccessor
							ifTrue: [operands object]
							ifFalse: [operands].
	(cogit isKindOf: Cogit) ifTrue:
		[format := CogRTLOpcodes printFormatForOpcodeName: opcodeName].
	orneryOperands withIndexDo:
		[:operand :index|
		operand notNil ifTrue:
			[aStream space.
			 index >= (orneryOperands identityIndexOf: nil ifAbsent: [orneryOperands size + 1]) ifTrue:
				[aStream print: index - 1; nextPut: $:].
			 (format notNil and: [(format at: index ifAbsent: nil) = $r])
				ifTrue: [aStream nextPutAll: (self nameForRegister: operand)]
				ifFalse:
					[aStream print: operand.
					 (operand isInteger and: [operand > 16 and: [opcode ~= Label]]) ifTrue:
						[(operand allMask: 16r80000000) ifTrue:
							[aStream nextPut: $/; print: operand signedIntFromLong].
						 aStream nextPut: $/.
						 operand printOn: aStream base: 16]]]].
	machineCodeSize ifNotNil:
		[(machineCodeSize between: 1 and: machineCode size) ifTrue:
			[0 to: machineCodeSize - 1 do:
				[:i|
				 aStream space.
				 (machineCode at: i) printOn: aStream base: 16]]].
	address ifNotNil:
		[aStream nextPut: $@.
		 address printOn: aStream base: 16].
	aStream nextPut: $)
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateCallBeforeReturnPC: retpc by: delta [
	^self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateJumpBeforeFollowingAddress: pc by: delta [
	^self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> resolveJumpTarget [
	<var: #fixup type: #'BytecodeFixup *'>
	| fixup |
	self assert: self isJump.
	fixup := cogit cCoerceSimple: (operands at: 0) to: #'BytecodeFixup *'.
	self cCode: [] inSmalltalk:
		[(fixup isKindOf: CogBytecodeFixup) ifTrue:
			[self assert: (self isAFixup: fixup)]].
	(self isAFixup: fixup) ifTrue:
		[self assert: (cogit addressIsInInstructions: fixup targetInstruction).
		 self jmpTarget: fixup targetInstruction]
]

{ #category : #abi }
CogAbstractInstruction >> saveAndRestoreLinkRegAround: aBlock [
	"If the processor's ABI includes a link register, generate instructions
	 to save and restore it around aBlock, which is assumed to generate code."
	<inline: true>
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> setLabelOffset: aValue [
	"Hack:  To arrange that the block method field pushed in a block entry has
	 its MFMethodFlagIsBlockFlag bit set we provide labels with an offset.  The
	 offset for the fakeHeader reference is MFMethodFlagIsBlockFlag.  See
	 compileBlockFrameBuild:"
	^operands at: 1 put: aValue
]

{ #category : #testing }
CogAbstractInstruction >> setsConditionCodesFor: aConditionalJumpOpcode [
	"Answer if the receiver's opcode sets the condition codes correctly for the given conditional jump opcode."
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> stackPageInterruptHeadroomBytes [
	"Return a minimum amount of headroom for each stack page (in bytes).  In a
	 JIT the stack has to have room for interrupt handlers which will run on the stack."
	self subclassResponsibility
]

{ #category : #printing }
CogAbstractInstruction >> symbolic [
	<doNotGenerate> "Smalltalk-side only"
	^String streamContents: [:s| self symbolicOn: s]
]

{ #category : #printing }
CogAbstractInstruction >> symbolicOn: aStream [
	| orneryOperands |
	<doNotGenerate> "Smalltalk-side only"
	(machineCodeSize isNil
	 or: [opcode = 16rAAA]) ifTrue:
		[^aStream nextPut: 'uninitialized opcode'].
	aStream space; nextPut: $(; nextPutAll: (self class nameForOpcode: opcode).
	orneryOperands := operands isCObjectAccessor
							ifTrue: [operands object]
							ifFalse: [operands].
	orneryOperands withIndexDo:
		[:operand :index|
		operand notNil ifTrue:
			[aStream space.
			 index >= (orneryOperands identityIndexOf: nil ifAbsent: [orneryOperands size + 1]) ifTrue:
				[aStream print: index - 1; nextPut: $:].
			 operand class == self class
				ifTrue:
					[operand symbolicOn: aStream]
				ifFalse:
					[aStream print: operand.
					 (operand isInteger and: [operand > 16]) ifTrue:
						[(operand allMask: 16r80000000) ifTrue:
							[aStream nextPut: $/; print: operand signedIntFromLong].
						 aStream nextPut: $/.
						 operand printOn: aStream base: 16]]]].
	machineCodeSize > 0 ifTrue:
		[machineCodeSize > machineCode size
			ifTrue: [aStream nextPutAll: ' no mcode']
			ifFalse:
				[0 to: machineCodeSize - 1 do:
					[:i|
					 aStream space.
					 (machineCode at: i) printOn: aStream base: 16]]].
	aStream nextPut: $)
]

{ #category : #'memory access' }
CogAbstractInstruction >> unalignedLongAt: byteAddress [
	^self subclassResponsibility
]

{ #category : #'memory access' }
CogAbstractInstruction >> unalignedLongAt: byteAddress put: aWord [
	^self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> updateLabel: labelInstruction [
	"Update an instruction that depends on a label outside of
	 generated code (e.g. a method or block header)."
	<var: #labelInstruction type: #'AbstractInstruction *'>
	| offsetAddress |
	offsetAddress := labelInstruction address + labelInstruction labelOffset.
	opcode caseOf: {
		[MoveCwR]		-> [operands at: 0 put: offsetAddress].
		[PushCw]		-> [operands at: 0 put: offsetAddress].
		[FillFromWord]	-> [operands at: 0 put: offsetAddress]}
]

{ #category : #simulation }
CogAbstractInstruction >> wantsNearAddressFor: anObject [
	"A hack hook to allow ARM to override the simulated address for the short-cut trampolines"
	^false
]
