"
I am an abstract instruction generated by the Cogit.  I am subsequently concretized to machine code for the current processor.  A sequence of concretized CogAbstractInstructions are concatenated to form the code for a CogMethod.
"
Class {
	#name : #CogAbstractInstruction,
	#superclass : #VMStructType,
	#instVars : [
		'opcode',
		'machineCodeSize',
		'maxSize',
		'machineCode',
		'operands',
		'address',
		'dependent',
		'cogit',
		'coInterpreter'
	],
	#classVars : [
		'MachineCodeSize'
	],
	#pools : [
		'CogRTLOpcodes'
	],
	#category : #'VMMaker-JIT'
}

{ #category : #translation }
CogAbstractInstruction class >> declareCVarsIn: aCCodeGenerator [
]

{ #category : #'instance creation' }
CogAbstractInstruction class >> for: aCogit [
	^self new cogit: aCogit
]

{ #category : #translation }
CogAbstractInstruction class >> instVarNamesAndTypesForTranslationDo: aBinaryBlock [
	"enumerate aBinaryBlock with the names and C type strings for the inst vars to include in an AbstractInstruction struct."
	"self printTypedefOn: Transcript"
	self instVarNames do:
		[:ivn|
		(#('cogit' 'coInterpreter') includes: ivn) ifFalse:
			[aBinaryBlock
				value: ivn
				value: (ivn caseOf: {
							['address']		-> ['unsigned long'].
							['machineCode']	-> [{'unsigned char'. '[', MachineCodeSize printString, ']'}].
							['operands']		-> [#('unsigned long' '[3]')].
							['dependent']	-> ['struct _AbstractInstruction *']}
						otherwise:
							[#char])]]
]

{ #category : #translation }
CogAbstractInstruction class >> isAccessor: aSelector [
	^(#(cogit coInterpreter) includes: aSelector) not
	   and: [super isAccessor: aSelector]
]

{ #category : #'debug printing' }
CogAbstractInstruction class >> nameForOpcode: opcode [ "<Integer>"
	^(self classPool keyAtValue: opcode ifAbsent: [])
		ifNotNil:
			[:opcodeName|
			((opcodeName beginsWith: 'First')
			 or: [opcodeName beginsWith: 'Last'])
				ifTrue: [#(JumpLong JumpBelowOrEqual Jump) detect: [:k| (classPool at: k) = opcode]]
				ifFalse: [opcodeName]]
		ifNil: [CogRTLOpcodes nameForOpcode: opcode]
]

{ #category : #translation }
CogAbstractInstruction class >> prepareToBeAddedToCodeGenerator: aCodeGen [
	"Hook to allow subclasses to interact with the code generation
	 immediately before having their code assimilated.  e.g. a class
	 might wish to remove methods it is about to override."
	^self
]

{ #category : #translation }
CogAbstractInstruction class >> requiredMethodNames [
	^self selectors reject:
		[:s|
		(self isAccessor: s)
		or: [((self compiledMethodAt: s) pragmaAt: #doNotGenerate) notNil]]
]

{ #category : #translation }
CogAbstractInstruction class >> structTypeName [
	^self name allButFirst: 3 "Drop initial Cog"
]

{ #category : #translation }
CogAbstractInstruction class >> typeForSelf [
	"Answer the type to give self if appropriate, or nil if not.
	 In C all subclasses are mapped to the AbstractInstruction type."
	^#'AbstractInstruction *'
]

{ #category : #comparing }
CogAbstractInstruction >> > anAbstractInstruction [
	"Support for Cogit>>abstractInstruction:follows:"
	<doNotGenerate>
	| opcodesArray |
	opcodesArray := cogit abstractOpcodes object.
	^(opcodesArray identityIndexOf: self) > (opcodesArray identityIndexOf: anAbstractInstruction)
]

{ #category : #accessing }
CogAbstractInstruction >> addDependent: anInstruction [
	<var: #anInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	dependent notNil ifTrue:
		[anInstruction dependent: dependent].
	^dependent := anInstruction
]

{ #category : #accessing }
CogAbstractInstruction >> address [
	^address
]

{ #category : #accessing }
CogAbstractInstruction >> address: theAddress [
	^address := theAddress
]

{ #category : #coercion }
CogAbstractInstruction >> asInteger [
	<doNotGenerate>
	^self
]

{ #category : #coercion }
CogAbstractInstruction >> asUnsignedInteger [
	<doNotGenerate>
	^self
]

{ #category : #accessing }
CogAbstractInstruction >> callInstructionByteSize [
	self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> callsAreRelative [
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canDivQuoRem [
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> canMulRR [
	^self subclassResponsibility
]

{ #category : #initialization }
CogAbstractInstruction >> cogit: aCogit [
	<doNotGenerate>
	cogit := aCogit.
	coInterpreter := aCogit coInterpreter
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeAt: actualAddress [
	"Attempt to generate concrete machine code for the instruction at actualAddress.
	 If possible, generate the relevant machine code, setting machineCodeSize,
	 and answer the following address.  Otherwise answer -1."
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFill16 [
	"fill with (operand 0 bitAnd: 16rFFFF) according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeFillFromWord [
	"fill with operand 0 + operand 1 according to the processor's endianness"
	self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> concretizeLabel [
	<var: #dependentChain type: #'AbstractInstruction *'>
	| dependentChain |
	dependentChain := dependent.
	[dependentChain isNil] whileFalse:
		[dependentChain updateLabel: self.
		 dependentChain := dependentChain dependent].
	^machineCodeSize := 0
]

{ #category : #accessing }
CogAbstractInstruction >> dependent [
	^dependent
]

{ #category : #accessing }
CogAbstractInstruction >> dependent: anInstruction [
	^dependent := anInstruction
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPGreater: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPGreater operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPGreaterOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPGreaterOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPLess: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPLess operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPLessOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPLessOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genJumpFPNotEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^cogit gen: JumpFPNotEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
CogAbstractInstruction >> genSubstituteReturnAddress: retpc [
	"Fake the return address for a call/jump so that the ``call'' returns
	 to retpc given that the ``call'' will be made by a following jump."
	self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> generateICacheFlush [
	"A dummy routine.
	 Processors that can generate code to flush the icache can override."

]

{ #category : #'multi-threading' }
CogAbstractInstruction >> generateLowLevelTryLock: vmOwnerLockAddress [
	self subclassResponsibility
]

{ #category : #'multi-threading' }
CogAbstractInstruction >> generateLowLevelUnlock: vmOwnerLockAddress [
	self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasDoublePrecisionFloatingPointSupport [
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> hasPCDependentInstructions [
	"Answer whether the concrete machine code contains pc-dependent
	 instructions, such as the IA32/x86's short and lopng relative jumps
	 and the EMT64/x86-64's pc-relative addressing mode.  Such
	 instructions require an extra pass to generate them correctly."
	^false
]

{ #category : #initialization }
CogAbstractInstruction >> initialize [
	"This method intializes the Smalltalk instance.  The C instance is merely a struct and doesn't need initialization."
	<doNotGenerate>
	operands := CArrayAccessor on: (Array new: 3).
	machineCode := CArrayAccessor on: (ByteArray new: MachineCodeSize)
]

{ #category : #testing }
CogAbstractInstruction >> isAFixup: fixupOrAddress [
	<var: #fixupOrAddress type: #'void *'>
	^cogit addressIsInFixups: fixupOrAddress
]

{ #category : #testing }
CogAbstractInstruction >> isAnInstruction: addressOrInstruction [
	<var: #addressOrInstruction type: #'void *'>
	^cogit addressIsInInstructions: addressOrInstruction
]

{ #category : #testing }
CogAbstractInstruction >> isBigEndian [
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isCallPreceedingReturnPC: mcpc [
	"Assuming mcpc is a return pc answer if the instruction before it is a call."
	^self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> isJump [
	^opcode between: FirstJump and: LastJump
]

{ #category : #testing }
CogAbstractInstruction >> isPCDependent [
	"Answer if the receiver is a pc-dependent instruction, such as a relative jump."
	^self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jmpTarget: anAbstractInstruction [
	"Set the target of a jump instruction.  These all have the target in the first operand."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #anAbstractInstruction type: #'AbstractInstruction *'>
	operands at: 0 put: anAbstractInstruction asUnsignedInteger.
	^anAbstractInstruction
]

{ #category : #accessing }
CogAbstractInstruction >> jumpLongByteSize [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> jumpLongConditionalByteSize [
	self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> jumpLongTargetBeforeFollowingAddress: mcpc [
	^self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> labelOffset [
	"To arrange that the block method field pushed in a block entry has
	 its MFMethodFlagIsBlockFlag bit set we provide labels with an offset.
	 The offset for the fakeHeader reference is MFMethodFlagIsBlockFlag.
	 See compileBlockFrameBuild:"
	^operands at: 1
]

{ #category : #accessing }
CogAbstractInstruction >> loadLiteralByteSize [
	"Answer the byte size of a MoveCwR opcode's corresponding machine code"
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> machineCode [
	^machineCode
]

{ #category : #accessing }
CogAbstractInstruction >> machineCode: anObject [
	"Set the value of machineCode"

	machineCode := anObject
]

{ #category : #accessing }
CogAbstractInstruction >> machineCodeSize [
	^machineCodeSize
]

{ #category : #accessing }
CogAbstractInstruction >> machineCodeSize: size [ "<signed byte>"
	^machineCodeSize := size
]

{ #category : #accessing }
CogAbstractInstruction >> maxSize [
	^maxSize
]

{ #category : #accessing }
CogAbstractInstruction >> maxSize: anObject [
	"Set the value of maxSize"

	maxSize := anObject
]

{ #category : #initialization }
CogAbstractInstruction >> numCheckFeaturesOpcodes [
	"If the priocessor has a feature check facility answer the number
	 of opcodes required to compile an accessor for the feature."
	^0
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> numICacheFlushOpcodes [
	"If the processor has the ablity to generate code to flush the icache answer
	 the number of opcodes required to compile an accessor for the feature."
	^0
]

{ #category : #'multi-threading' }
CogAbstractInstruction >> numLowLevelLockOpcodes [
	self subclassResponsibility
]

{ #category : #accessing }
CogAbstractInstruction >> opcode [
	^opcode
]

{ #category : #accessing }
CogAbstractInstruction >> opcode: value [
	^opcode := value
]

{ #category : #accessing }
CogAbstractInstruction >> operands [
	^operands
]

{ #category : #accessing }
CogAbstractInstruction >> operands: anObject [
	"Set the value of operands"

	operands := anObject
]

{ #category : #'debug printing' }
CogAbstractInstruction >> printOn: aStream [
	| orneryOperands |
	<doNotGenerate> "Smalltalk-side only"
	super printOn: aStream.
	opcode isNil ifTrue:
		[^self].
	aStream space; nextPut: $(; nextPutAll: (self class nameForOpcode: opcode).
	orneryOperands := operands isCObjectAccessor
							ifTrue: [operands object]
							ifFalse: [operands].
	orneryOperands withIndexDo:
		[:operand :index|
		operand notNil ifTrue:
			[aStream space.
			 index >= (orneryOperands identityIndexOf: nil ifAbsent: [orneryOperands size + 1]) ifTrue:
				[aStream print: index - 1; nextPut: $:].
			 aStream print: operand.
			 (operand isInteger and: [operand > 16]) ifTrue:
				[(operand allMask: 16r80000000) ifTrue:
					[aStream nextPut: $/; print: operand signedIntFromLong].
				 aStream nextPut: $/.
				 operand printOn: aStream base: 16]]].
	machineCodeSize ifNotNil:
		[(machineCodeSize between: 1 and: machineCode size) ifTrue:
			[0 to: machineCodeSize - 1 do:
				[:i|
				 aStream space.
				 (machineCode at: i) printOn: aStream base: 16]]].
	address ifNotNil:
		[aStream nextPut: $@.
		 address printOn: aStream base: 16].
	aStream nextPut: $)
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateCallBeforeReturnPC: retpc by: delta [
	^self subclassResponsibility
]

{ #category : #'inline cacheing' }
CogAbstractInstruction >> relocateJumpBeforeFollowingAddress: pc by: delta [
	^self subclassResponsibility
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> resolveJumpTarget [
	<var: #fixup type: #'BytecodeFixup *'>
	| fixup |
	self assert: self isJump.
	fixup := cogit cCoerceSimple: (operands at: 0) to: #'BytecodeFixup *'.
	(self isAFixup: fixup) ifTrue:
		[self assert: (cogit addressIsInInstructions: fixup targetInstruction).
		 self jmpTarget: fixup targetInstruction]
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> setLabelOffset: aValue [
	"Hack:  To arrange that the block method field pushed in a block entry has
	 its MFMethodFlagIsBlockFlag bit set we provide labels with an offset.  The
	 offset for the fakeHeader reference is MFMethodFlagIsBlockFlag.  See
	 compileBlockFrameBuild:"
	^operands at: 1 put: aValue
]

{ #category : #testing }
CogAbstractInstruction >> setsConditionCodesFor: aConditionalJumpOpcode [
	"Answer if the receiver's opcode sets the condition codes correctly for the given conditional jump opcode."
	self subclassResponsibility
]

{ #category : #testing }
CogAbstractInstruction >> sizeof: objectOrClass [
	<doNotGenerate>
	"This had better be the machineCode field.  Probably won't work otherwise..."
	^objectOrClass size
]

{ #category : #accessing }
CogAbstractInstruction >> stackPageInterruptHeadroomBytes [
	"Return a minimum amount of headroom for each stack page (in bytes).  In a
	 JIT the stack has to have room for interrupt handlers which will run on the stack."
	self subclassResponsibility
]

{ #category : #'debug printing' }
CogAbstractInstruction >> symbolic [
	<doNotGenerate> "Smalltalk-side only"
	^String streamContents: [:s| self symbolicOn: s]
]

{ #category : #'debug printing' }
CogAbstractInstruction >> symbolicOn: aStream [
	| orneryOperands |
	<doNotGenerate> "Smalltalk-side only"
	(machineCodeSize isNil
	 or: [opcode = 16rAAA]) ifTrue:
		[^aStream nextPut: 'uninitialized opcode'].
	aStream space; nextPut: $(; nextPutAll: (self class nameForOpcode: opcode).
	orneryOperands := operands isCObjectAccessor
							ifTrue: [operands object]
							ifFalse: [operands].
	orneryOperands withIndexDo:
		[:operand :index|
		operand notNil ifTrue:
			[aStream space.
			 index >= (orneryOperands identityIndexOf: nil ifAbsent: [orneryOperands size + 1]) ifTrue:
				[aStream print: index - 1; nextPut: $:].
			 operand class == self class
				ifTrue:
					[operand symbolicOn: aStream]
				ifFalse:
					[aStream print: operand.
					 (operand isInteger and: [operand > 16]) ifTrue:
						[(operand allMask: 16r80000000) ifTrue:
							[aStream nextPut: $/; print: operand signedIntFromLong].
						 aStream nextPut: $/.
						 operand printOn: aStream base: 16]]]].
	machineCodeSize > 0 ifTrue:
		[machineCodeSize > machineCode size
			ifTrue: [aStream nextPutAll: ' no mcode']
			ifFalse:
				[0 to: machineCodeSize - 1 do:
					[:i|
					 aStream space.
					 (machineCode at: i) printOn: aStream base: 16]]].
	aStream nextPut: $)
]

{ #category : #'generate machine code' }
CogAbstractInstruction >> updateLabel: labelInstruction [
	"Update an instruction that depends on a label outside of
	 generated code (e.g. a method or block header)."
	<var: #labelInstruction type: #'AbstractInstruction *'>
	| offsetAddress |
	offsetAddress := labelInstruction address + labelInstruction labelOffset.
	opcode caseOf: {
		[MoveCwR]		-> [operands at: 0 put: offsetAddress].
		[PushCw]		-> [operands at: 0 put: offsetAddress].
		[FillFromWord]	-> [operands at: 0 put: offsetAddress]}
]
