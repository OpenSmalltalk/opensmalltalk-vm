"
I am the code generator for the Cog VM.  My job is to produce machine code versions of methods for faster execution and to manage inline caches for faster send performance.

coInterpreter <CoInterpreterSimulator>
	the VM's interpreter with which I cooperate
methodZoneManager <CogMethodZoneManager>
	the manager of the machine code zone
objectRepresentation <CogObjectRepresentation>
	the object used to generate object accesses
processor <BochsIA32Alien|?>
	the simulator that executes the IA32/x86 machine code I generate when simulating execution in Smalltalk
simulatedTrampolines <Dictionary of Integer -> MessageSend>
	the dictionary mapping trap jump addresses to run-time routines used to warp from simulated machine code in to the Smalltalk run-time.
simulatedVariableGetters <Dictionary of Integer -> MessageSend>
	the dictionary mapping trap read addresses to variables in run-time objects used to allow simulated machine code to read variables in the Smalltalk run-time.
simulatedVariableSetters <Dictionary of Integer -> MessageSend>
	the dictionary mapping trap write addresses to variables in run-time objects used to allow simulated machine code to write variables in the Smalltalk run-time.
printRegisters printInstructions clickConfirm <Boolean>
	flags controlling debug printing and code simulation
breakPC <Integer>
	machine code pc breakpoint
cFramePointer cStackPointer <Integer>
	the variables representing the C stack & frame pointers, which must change on FFI callback and return
selectorOop <sqInt>
	the oop of the methodObj being compiled
methodObj <sqInt>
	the bytecode method being compiled
initialPC endPC <Integer>
	the start and end pcs of the methodObj being compiled
methodOrBlockNumArgs <Integer>
	argument count of current method or block being compiled
needsFrame <Boolean>
	whether methodObj or block needs a frame to execute
primitiveIndex <Integer>
	primitive index of current method being compiled
methodLabel <CogAbstractOpcode>
	label for the method header
blockEntryLabel <CogAbstractOpcode>
	label for the start of the block dispatch code
stackOverflowCall <CogAbstractOpcode>
	label for the call of ceStackOverflow in the method prolog
sendMissCall <CogAbstractOpcode>
	label for the call of ceSICMiss in the method prolog
entryOffset <Integer>
	offset of method entry code from start (header) of method
entry <CogAbstractOpcode>
	label for the first instruction of the method entry code
noCheckEntryOffset <Integer>
	offset of the start of a method proper (after the method entry code) from start (header) of method
noCheckEntry <CogAbstractOpcode>
	label for the first instruction of start of a method proper
fixups <Array of <AbstractOpcode Label | nil>>
	the labels for forward jumps that will be fixed up when reaching the relevant bytecode.  fixup shas one element per byte in methodObj's bytecode
abstractOpcodes <Array of <AbstractOpcode>>
	the code generated when compiling methodObj
byte0 byte1 byte2 byte3 <Integer>
	individual bytes of current bytecode being compiled in methodObj
bytecodePointer <Integer>
	bytecode pc (same as Smalltalk) of the current bytecode being compiled
opcodeIndex <Integer>
	the index of the next free entry in abstractOpcodes (this code is translated into C where OrderedCollection et al do not exist)
numAbstractOpcodes <Integer>
	the number of elements in abstractOpcocdes
blockStarts <Array of <BlockStart>>
	the starts of blocks in the current method
blockCount
	the index into blockStarts as they are being noted, and hence eventuakly teh total number of blocks in the current method
labelCounter <Integer>
	a nicety for numbering labels not needed in the production system but probably not expensive enough to worry about
ceStackOverflowTrampoline <Integer>
ceSend0ArgsTrampoline <Integer>
ceSend1ArgsTrampoline <Integer>
ceSend2ArgsTrampoline <Integer>
ceSendNArgsTrampoline <Integer>
ceSendSuper0ArgsTrampoline <Integer>
ceSendSuper1ArgsTrampoline <Integer>
ceSendSuper2ArgsTrampoline <Integer>
ceSendSuperNArgsTrampoline <Integer>
ceSICMissTrampoline <Integer>
ceCPICMissTrampoline <Integer>
ceStoreCheckTrampoline <Integer>
ceReturnToInterpreterTrampoline <Integer>
ceBaseFrameReturnTrampoline <Integer>
ceSendMustBeBooleanTrampoline <Integer>
ceClosureCopyTrampoline <Integer>
	the various trampolines (system-call-like jumps from machine code to the run-time).
	See Cogit>>generateTrampolines for the mapping from trampoline to run-time
	routine and then read the run-time routine for a funcitonal description.
ceEnterCogCodePopReceiverReg <Integer>
	the enilopmart (jump from run-time to machine-code)
methodZoneBase <Integer>

"
Class {
	#name : #Cogit,
	#superclass : #CogClass,
	#instVars : [
		'coInterpreter',
		'objectRepresentation',
		'processor',
		'threadManager',
		'methodZone',
		'methodZoneBase',
		'codeBase',
		'lastNInstructions',
		'simulatedTrampolines',
		'simulatedVariableGetters',
		'simulatedVariableSetters',
		'illegalAddressCounter',
		'printRegisters',
		'printInstructions',
		'clickConfirm',
		'breakPC',
		'singleStep',
		'guardPageSize',
		'traceLinkedSends',
		'traceStores',
		'breakMethod',
		'methodObj',
		'initialPC',
		'endPC',
		'methodOrBlockNumArgs',
		'inBlock',
		'needsFrame',
		'hasYoungReferent',
		'primitiveIndex',
		'backEnd',
		'postCompileHook',
		'primInvokeLabel',
		'methodLabel',
		'stackCheckLabel',
		'blockEntryLabel',
		'blockEntryNoContextSwitch',
		'blockNoContextSwitchOffset',
		'stackOverflowCall',
		'sendMissCall',
		'missOffset',
		'entryPointMask',
		'checkedEntryAlignment',
		'cmEntryOffset',
		'entry',
		'cmNoCheckEntryOffset',
		'noCheckEntry',
		'mnuCall',
		'interpretCall',
		'endCPICCase0',
		'endCPICCase1',
		'numPICCases',
		'firstCPICCaseOffset',
		'cPICCaseSize',
		'cPICEndSize',
		'closedPICSize',
		'openPICSize',
		'fixups',
		'abstractOpcodes',
		'annotations',
		'generatorTable',
		'primitiveGeneratorTable',
		'byte0',
		'byte1',
		'byte2',
		'byte3',
		'bytecodePointer',
		'opcodeIndex',
		'numAbstractOpcodes',
		'annotationIndex',
		'blockStarts',
		'blockCount',
		'labelCounter',
		'cStackAlignment',
		'expectedSPAlignment',
		'expectedFPAlignment',
		'codeModified',
		'maxMethodBefore',
		'ceMethodAbortTrampoline',
		'cePICAbortTrampoline',
		'ceCheckForInterruptTrampoline',
		'ceCPICMissTrampoline',
		'ceStoreCheckTrampoline',
		'ceReturnToInterpreterTrampoline',
		'ceBaseFrameReturnTrampoline',
		'ceSendMustBeBooleanTrampoline',
		'ceCannotResumeTrampoline',
		'ceClosureCopyTrampoline',
		'ceCreateNewArrayTrampoline',
		'ceEnterCogCodePopReceiverReg',
		'ceEnterCogCodePopReceiverAndClassRegs',
		'cePrimReturnEnterCogCode',
		'ceNonLocalReturnTrampoline',
		'cePushActiveContextTrampoline',
		'ceFetchContextInstVarTrampoline',
		'ceStoreContextInstVarTrampoline',
		'cePositive32BitIntegerTrampoline',
		'ceSendFromInLineCacheMissTrampoline',
		'ceCaptureCStackPointers',
		'ceFlushICache',
		'ceCheckFeaturesFunction',
		'ceTraceLinkedSendTrampoline',
		'ceTraceBlockActivationTrampoline',
		'ceTraceStoreTrampoline',
		'ceGetSP',
		'sendTrampolines',
		'superSendTrampolines',
		'firstSend',
		'lastSend',
		'realCEEnterCogCodePopReceiverReg',
		'realCEEnterCogCodePopReceiverAndClassRegs',
		'trampolineTableIndex',
		'trampolineAddresses',
		'cFramePointerInUse',
		'debugPrimCallStackOffset',
		'ceTryLockVMOwner',
		'ceUnlockVMOwner'
	],
	#classVars : [
		'AnnotationConstantNames',
		'AnnotationShift',
		'Debug',
		'DisplacementMask',
		'DisplacementX2N',
		'EncounteredUnknownBytecode',
		'FirstAnnotation',
		'GeneratorTable',
		'HasBytecodePC',
		'InsufficientCodeSpace',
		'IsDisplacement',
		'IsDisplacementX2N',
		'IsMethodReference',
		'IsObjectReference',
		'IsRelativeCall',
		'IsSendCall',
		'MapEnd',
		'MaxCompiledPrimitiveIndex',
		'MaxNegativeErrorCode',
		'MaxUnitDisplacement',
		'MaxX2NDisplacement',
		'NumSendTrampolines',
		'NumTrampolines',
		'PrimitiveTable',
		'ProcessorClass'
	],
	#pools : [
		'CogMethodConstants',
		'CogRTLOpcodes',
		'VMBasicConstants',
		'VMStackFrameOffsets'
	],
	#category : #'VMMaker-JIT'
}

{ #category : #translation }
Cogit class >> additionalHeadersDo: aBinaryBlock [
	"Evaluate aBinaryBlock with the names and contents of
	 any additional header files that need to be generated."
	aBinaryBlock
		value: 'cogmethod.h'
		value: CogMethod cogMethodHeader
]

{ #category : #translation }
Cogit class >> additionalSelectorTables [
	^self tableFunctions
]

{ #category : #translation }
Cogit class >> ancilliaryClasses [
	^super ancilliaryClasses,
	  { CogMethodZone }
]

{ #category : #translation }
Cogit class >> ancilliaryStructClasses [
	ProcessorClass ifNil: [thisContext methodClass theNonMetaClass initialize].
	^{	CogAbstractInstruction.
		ProcessorClass basicNew abstractInstructionCompilerClass.
		CogBlockStart.
		CogBytecodeDescriptor.
		CogBytecodeFixup.
		CogInstructionAnnotation.
		CogPrimitiveDescriptor.
		CogBlockMethod.
		CogMethod	}
]

{ #category : #'class initialization' }
Cogit class >> annotationConstantNames [
	"for printing..."
	^AnnotationConstantNames
]

{ #category : #translation }
Cogit class >> apiExportHeaderName [
	^'cogit.h'
]

{ #category : #documentation }
Cogit class >> assumptions [
	"Byte architecture; no 9-bit bit bytes etc.

	 Stacks grow down.  No support for HPPA.

	 No delay slots.  No support for SPARC.

	 Relative jumps.

	 All long conditional branches are of the same size.

	 All long unconditional branches are of the same size.

	 All MoveCwRs are of the same size.

	 A long jump and a call have the same displacement layout so both can be labelled with IsRelativeCall.

	 A PushCw and a MoveCwR have the same constant layout so both can be labelled with IsObjectReference or IsMethodReference.

	 64k of code per method more than enough"
]

{ #category : #translation }
Cogit class >> declareCVarsIn: aCCodeGenerator [
	#(	'coInterpreter' 'objectMemory' 'methodZone' 'objectRepresentation' 'processor' 'lastNInstructions'
		'simulatedTrampolines' 'simulatedVariableGetters' 'simulatedVariableSetters'
		'printRegisters' 'printInstructions' 'clickConfirm' 'singleStep' 'illegalAddressCounter' ) do:
			[:simulationVariableNotNeededForRealVM|
			aCCodeGenerator removeVariable: simulationVariableNotNeededForRealVM].
	aCCodeGenerator
		addHeaderFile:'<stddef.h>'; "for e.g. offsetof"
		addHeaderFile:'"sqCogStackAlignment.h"';
		addHeaderFile:'"cogmethod.h"';
		addHeaderFile:'#if COGMTVM';
		addHeaderFile:'"cointerpmt.h"';
		addHeaderFile:'#else';
		addHeaderFile:'"cointerp.h"';
		addHeaderFile:'#endif';
		addHeaderFile:'"cogit.h"';
		addHeaderFile:'"dispdbg.h"'.
	aCCodeGenerator
		var: #ceGetSP
			declareC: 'unsigned long (*ceGetSP)(void)';
		var: #ceCaptureCStackPointers
			declareC: 'void (*ceCaptureCStackPointers)(void)';
		var: #ceEnterCogCodePopReceiverReg
			declareC: 'void (*ceEnterCogCodePopReceiverReg)(void)';
		var: #realCEEnterCogCodePopReceiverReg
			declareC: 'void (*realCEEnterCogCodePopReceiverReg)(void)';
		var: #ceEnterCogCodePopReceiverAndClassRegs
			declareC: 'void (*ceEnterCogCodePopReceiverAndClassRegs)(void)';
		var: #realCEEnterCogCodePopReceiverAndClassRegs
			declareC: 'void (*realCEEnterCogCodePopReceiverAndClassRegs)(void)';
		var: #ceFlushICache
			declareC: 'static void (*ceFlushICache)(unsigned long from, unsigned long to)';
		var: #ceCheckFeaturesFunction
			declareC: 'static unsigned long (*ceCheckFeaturesFunction)(void)';
		var: #ceTryLockVMOwner
			declareC: 'unsigned long (*ceTryLockVMOwner)(void)';
		var: #ceUnlockVMOwner
			declareC: 'void (*ceUnlockVMOwner)(void)';
		var: #postCompileHook
			declareC: 'void (*postCompileHook)(CogMethod *, void *)';
		var: #openPICList declareC: 'CogMethod *openPICList = 0';
		var: #maxMethodBefore type: #'CogBlockMethod *'.
	aCCodeGenerator
		declareVar: 'aMethodLabel' type: #'AbstractInstruction'; "Has to come lexicographically before backEnd & methodLabel"
		var: #backEnd declareC: 'AbstractInstruction *backEnd = &aMethodLabel';
		var: #methodLabel declareC: 'AbstractInstruction *methodLabel = &aMethodLabel';
		var: #primInvokeLabel type: #'AbstractInstruction *'.
	self declareC: #(abstractOpcodes stackCheckLabel
					blockEntryLabel blockEntryNoContextSwitch
					stackOverflowCall sendMissCall entry noCheckEntry
					mnuCall interpretCall endCPICCase0 endCPICCase1)
			as: #'AbstractInstruction *'
				in: aCCodeGenerator.
	aCCodeGenerator
		declareVar: #annotations type: #'InstructionAnnotation *';
		declareVar: #blockStarts type: #'BlockStart *';
		declareVar: #fixups type: #'BytecodeFixup *'.
	aCCodeGenerator
		var: #sendTrampolines
			declareC: 'sqInt sendTrampolines[NumSendTrampolines]';
		var: #superSendTrampolines
			declareC: 'sqInt superSendTrampolines[NumSendTrampolines]';
		var: #generatorTable
			declareC: 'BytecodeDescriptor generatorTable[256]'
						, (self tableInitializerFor: GeneratorTable
							in: aCCodeGenerator);
		var: #primitiveGeneratorTable
			declareC: 'PrimitiveDescriptor primitiveGeneratorTable[MaxCompiledPrimitiveIndex+1]'
						, (self tableInitializerFor: PrimitiveTable
							in: aCCodeGenerator);
		var: #trampolineAddresses
			declareC: 'static char *trampolineAddresses[NumTrampolines*2]';
		var: #cePositive32BitIntegerTrampoline
			declareC: 'static sqInt cePositive32BitIntegerTrampoline';
		var: #labelCounter
			declareC: 'static int labelCounter';
		var: #traceLinkedSends
			declareC: 'int traceLinkedSends = 2 /* prim trace log on by default */';
		var: #cStackAlignment
			declareC: 'const int cStackAlignment = STACK_ALIGN_BYTES'.
	aCCodeGenerator
		declareVar: #CFramePointer type: #'void *';
		declareVar: #CStackPointer type: #'void *';
		declareVar: #EnilopmartCFP type: #'void *';
		declareVar: #EnilopmartCSP type: #'void *';
		declareVar: #debugPrimCallStackOffset type: #'unsigned long'.
	"In C the abstract opcode names clash with the Smalltak generator syntactic sugar.
	 Most of the syntactic sugar is inlined, but alas some remains.  Rename the syntactic
	 sugar to avoid the clash."
	(self organization listAtCategoryNamed: #'abstract instructions') do:
		[:s|
		aCCodeGenerator addSelectorTranslation: s to: 'g', (aCCodeGenerator cFunctionNameFor: s)].
	aCCodeGenerator addSelectorTranslation: #halt: to: 'haltmsg'
]

{ #category : #translation }
Cogit class >> doInlining [
	"At least while getting this to compile we choose not to"
	self flag: #revisit.
	^false
]

{ #category : #translation }
Cogit class >> emitExportPragma [
	^false
]

{ #category : #translation }
Cogit class >> exportAPISelectors [
	^super exportAPISelectors,
	  ((self ancilliaryClasses collect: [:c| c exportAPISelectors]) fold: [:a :b| a, b])
]

{ #category : #'class initialization' }
Cogit class >> generatorTableFrom: anArray [
	| generatorTable |
	generatorTable := CArrayAccessor on: (Array new: 256).
	anArray do:
		[:tuple| | descriptor |
		(descriptor := CogBytecodeDescriptor new)
						numBytes: tuple first;
						generator: tuple fourth;
						needsFrame: (tuple includes: #frameful);
						needsFrameInBlock: ((tuple includes: #frameful)
											  or: [tuple includes: #framefulInBlock]);
						isReturn: (tuple includes: #return);
						isMapped: (tuple includes: #mapped);
						isBlockCreation: (tuple includes: #block);
						isBranch: ((tuple includes: #forward) or: [tuple includes: #backward]);
						spanFunction: ((descriptor isBranch or: [descriptor isBlockCreation]) ifTrue:
										[tuple last]);
						isBackwardBranch: (tuple includes: #backward);
						yourself.
		tuple last isInteger
			ifTrue: [descriptor stackDelta: tuple last]
			ifFalse:
				[descriptor needsFrameInBlock ifFalse:
					[self error: 'frameless block bytecodes must specify a stack delta']].
		tuple second to: tuple third do:
			[:index| 
			generatorTable at: index put: descriptor]].
	^generatorTable
]

{ #category : #translation }
Cogit class >> implicitReturnTypeFor: aSelector [
	"Answer the return type for methods that don't have an explicit return."
	^#void
]

{ #category : #'class initialization' }
Cogit class >> initialize [
	Debug := false.
	self initializeErrorCodes.
	self initializeCogMethodConstants.
	self initializeAnnotationConstants.
	self initializeCompilationConstants.
	SimpleStackBasedCogit initialize
]

{ #category : #'class initialization' }
Cogit class >> initializeAnnotationConstants [
	"These form the method map for a cog method.  Each annotated instruction has a
	 byte in the map, and each byte in the map has two parts.  In the least signficant
	 bits are a byte distance from the start of the method or previous map entry.  In
	 the most signficant bits are the type of annotation at the point reached.  A null
	 byte ends the map.

	 The map occurs at the end of a method, in reverse, so that its start is found
	 by rounding up the method's block size.  If the distance between two mapped
	 instructions will not fit in the displacement field then one or more displacement
	 entries are placed in the map to bridge the gap.  There are either unit displacement
	 bytes or * 32 displacement bytes.

	 There is only one kind of call annotation that serves for all calls from machine
	 code. There are four kinds of call, sends, super sends, calls of the generated
	 run-time, and direct calls of primitive functions in the interpreter.  These need
	 different treatment at different times.  For example, when the send cache is
	 flushed or the method zone is shrunk some sends must be unlinked and some
	 sends must be relocated.

	 Sends can be distinguished from run-time or direct primitive calls based on
	 address; only sends have their target between methodZoneBase and methodZone
	 freeStart.  Further, normal sends can be distinguished from super sends because
	 normal sends link top the checked entry-point, whereas super sends link to the
	 unchecked entry-point, and both entry points have different alignment.
	 But to be able to parse bytecoded methods and match their pcs with corresponding
	 machine code pcs the map needs to differentiate between sends and run-time calls. 

	 While run-time calls can be distinguished from direct primitive calls on the basis
	 of address there is no need to do so.  They are merely calls to locations that
	 don't move during method zone compaction."
	"self initializeAnnotationConstants"
	IsSendCall := 7.
	IsRelativeCall := 6.
	HasBytecodePC := 5.
	IsMethodReference := 4.
	IsObjectReference := 3. "IsNewObjectReference? code 2 is unused"

	IsDisplacementX2N := 1.
	IsDisplacement := 0.
	AnnotationShift := 5.

	DisplacementMask := (1 << AnnotationShift) - 1.
	DisplacementX2N := IsDisplacementX2N << AnnotationShift.
	FirstAnnotation := IsDisplacementX2N + 1 << AnnotationShift.
	MaxUnitDisplacement := DisplacementMask.
	MaxX2NDisplacement := DisplacementMask << AnnotationShift.

	MapEnd := 0.

	AnnotationConstantNames := #(	Displacement DisplacementX32 unused
									IsObjectReference
									IsMethodReference
									HasBytecodePC
									IsRelativeCall
									IsSendCall)
]

{ #category : #'class initialization' }
Cogit class >> initializeCogMethodConstants [
	CMOpenPIC := 1 + (CMClosedPIC := 1 + (CMBlock := 1 +(CMMethod := 1 + (CMFree := 1))))
]

{ #category : #'class initialization' }
Cogit class >> initializeCompilationConstants [
	ProcessorClass := BochsIA32Alien.
	NumSendTrampolines := 4.
	NumTrampolines := 38
]

{ #category : #'class initialization' }
Cogit class >> initializeErrorCodes [
	InsufficientCodeSpace := -1.
	EncounteredUnknownBytecode := -2.
	MaxNegativeErrorCode := EncounteredUnknownBytecode
]

{ #category : #translation }
Cogit class >> isCogitClass [
	^true
]

{ #category : #translation }
Cogit class >> isNonArgumentImplicitReceiverVariableName: aString [
	^#('cogit' 'coInterpreter'
		'methodZone'
		'objectMemory' 'objectRepresentation') includes: aString
]

{ #category : #translation }
Cogit class >> isTypePointerToStruct: type [ "<String>"
	^type notNil
	  and: [(type includes: $*)
	  and: [#('AbstractInstruction'  'InstructionAnnotation'
			  'CogMethod' 'CogBlockMethod'
			  'BlockStart' 'BytecodeDescriptor' 'BytecodeFixup'
			  'PrimitiveDescriptor') includes:
				(type copyUpTo: Character space)]]
]

{ #category : #translation }
Cogit class >> mustBeGlobal: var [
	"Answer if a variable must be global and exported.  Used for inst vars that are accessed from VM
	 support code.  include cePositive32BitIntegerTrampoline as a hack to prevent it being inlined (it is
	 only used outside of Cogit by the object representation).  Include labelCounter as a hack to stop it
	 being inlined into genLabel, and CFramePointer CStackPointer as a hack to get them declared at all."
	^#('ceBaseFrameReturnTrampoline' 'ceCaptureCStackPointers' 'ceCheckForInterruptTrampoline'
		'ceEnterCogCodePopReceiverReg' 'realCEEnterCogCodePopReceiverReg'
		'ceEnterCogCodePopReceiverAndClassRegs' 'realCEEnterCogCodePopReceiverAndClassRegs'
		'ceReturnToInterpreterTrampoline' 'ceCannotResumeTrampoline'
		'cePositive32BitIntegerTrampoline' 'ceFlushICache'
		'cmEntryOffset' 'cmNoCheckEntryOffset' 'blockNoContextSwitchOffset' 'breakPC'
		'labelCounter' 'CFramePointer' 'CStackPointer' 'cFramePointerInUse' 'ceGetSP'
		'traceLinkedSends' 'traceStores' 'EnilopmartCFP' 'EnilopmartCSP' 'debugPrimCallStackOffset'
		'ceTryLockVMOwner' 'ceUnlockVMOwner')
			includes: var
]

{ #category : #translation }
Cogit class >> namesOfVariablesToLocalize [
	^#()
]

{ #category : #documentation }
Cogit class >> notesAndQueries [
	"Mitigating cost of bytecode to machinecode pc mapping.
		HPS's scheme is to allow contexts ot contain machine-code pcs in the form of negative pc values.
		This is reified at the image level and relevant accessors must check before accessing the pc.

		We can hide a similar scheme entirely within the VM.  When a spouse context of a machine-code
		frame is divorced we set its pc to the negative machine-code pc.  All accesses to the instruction
		pointer of a stable context are checked (in instVar:ofContext: and externalInstVar:ofContext:).
		If the value is negative we look for, and if not found, compile the context's method and map the
		negative pc.

		The downside of this scheme is on snapshot having to trawl throguh the entire image looking for
		single contexts with negative pcs and mapping them to proper bytecode pcs."
]

{ #category : #translation }
Cogit class >> preGenerationHook: aCCodeGenerator [
	"Perform any last-minute changes to the code generator immediately
	 before it performs code analysis and generation.  In this case, make
	 all non-exported methods private."
	| exportAPISelectors |
	exportAPISelectors := self exportAPISelectors.
	aCCodeGenerator selectorsAndMethodsDo:
		[:s :m|
		(exportAPISelectors includes: s)
			ifTrue: [m static: false]
			ifFalse:
				[m export ifFalse:
					[m static: true]]]
]

{ #category : #translation }
Cogit class >> requiredMethodNames [
	"self requiredMethodNames"
	^self exportAPISelectors
		addAll: self tableFunctions;
		yourself
]

{ #category : #translation }
Cogit class >> shouldGenerateTypedefFor: aStructClass [
	"Hack to work-around mutliple definitions.  Sometimes a type has been defined in an include."
	^({ CogBlockMethod. CogMethod } includes: aStructClass) not
]

{ #category : #translation }
Cogit class >> sourceFileName [
	^'cogit.c'
]

{ #category : #translation }
Cogit class >> specialValueForConstant: constantName [
	^CoInterpreter specialValueForConstant: constantName
]

{ #category : #'class initialization' }
Cogit class >> table: primArray from: specArray [ 
	"Fill in the specified entries in the primitive table."
	specArray do:
		[:spec | | descriptor |
		(primArray at: spec first put: CogPrimitiveDescriptor new)
			primitiveGenerator: spec second;
			primNumArgs: (spec at: 3 ifAbsent: -1);
			enabled: (spec at: 4 ifAbsent: nil)].
	primArray object withIndexDo:
		[:generator :i|
		generator ifNil:
			[(primArray object at: i put: CogPrimitiveDescriptor new)
				primNumArgs: -1]]
]

{ #category : #translation }
Cogit class >> tableFunctions [
	"self tableFunctions"
	^Set new
		addAll: (GeneratorTable object
					collect: [:ea| ea generator]);
		addAll: (GeneratorTable object
					select: [:ea| ea spanFunction notNil]
					thenCollect: [:ea| ea spanFunction]);
		addAll: (PrimitiveTable object
					select: [:ea| ea notNil and: [ea primitiveGenerator notNil]]
					thenCollect: [:ea| ea primitiveGenerator]);
		addAll: (PrimitiveTable object
					select: [:ea| ea notNil and: [ea enabled notNil]]
					thenCollect: [:ea| ea enabled]);
		asSortedCollection: [:a :b| a caseInsensitiveLessOrEqual: b]
]

{ #category : #translation }
Cogit class >> tableInitializerFor: aTable in: aCCodeGenerator [
	^String streamContents:
		[:s|
		s nextPutAll: ' = {'.
		aTable object
			do: [:gt|
				s crtab.
				gt printCInitializerOn: s in: aCCodeGenerator]
			separatedBy: [s nextPut: $,].
		s cr; nextPut: $}]
]

{ #category : #documentation }
Cogit class >> trampolines [
	"Trampolines are called from machine-code for a number of tasks (e.g. doing an unlinked send,
	 creating a closure, doing a non-local return, etc, etc.
	 Some trampolines save their return pc on the Smalltalk stack, and some pop it into instructionPointer,
	 depending on whether the trampoline always returns or whether control might transfer elsewhere,
	 or depending on whether the callee run-time routine expects to see a normal Smalltalk stack.  This
	 documents which trampolines do what and why.

ceSend0Args .. ceSendNArgs, ceSuperSend0Args..ceSuperSendNArgs
	return pc left on stack because it is the return pc of the send and must be there

ceMethodAbort, cePICAbort
	return pc left on stack because it is used to locate the failing send target method/PIC of a linked send

ceClosureCopyTrampoline
	return pc left on stack because ceClosureCopy:... always returns directly

cePushActiveContextTrampoline
	return pc left on stack because cePushActiveContext always returns directly

ceNonLocalReturnTrampoline
	pops return pc into instructionPointer

ceBaseFrameReturnTrampoline
	this is returned-to and never called; i.e. it is the return pc of a base machine-code frame

ceCreateNewArrayTrampoline
	return pc left on stack because ceNewArraySlotSize always returns directly

ceSendMustBeBooleanTrampoline
	return pc left on stack because it is the return pc of the send and must be there

ceCheckForInterruptsTrampoline
	pops return pc into instructionPointer

ceCPICMissTrampoline
	return pc left on stack because it is used to locate the failing send target PIC of a linked send

ceSendFromInLineCacheMissTrampoline
	not used, but its addres is used as a key in the simulator.  An open PIC calls ceSendFromInLineCacheMiss
	after it has switched from the Smalltalk to teh C stack (an inline trampoline) hence there is no return pc
	left on the Smalltalk stack (except that of the send that invoked the open PIC).

ceStoreCheckTrampoline
	return pc left on stack because ceStoreCheck always returns directly

ceFetchContextInstVarTrampoline
	return pc left on stack because ceContextInstVar always returns directly.
	ceContextInstVar manages popping the pc into instructionPointer if necessary.

ceStoreContextInstVarTrampoline
	return pc left on stack because ceContextInstVarvalue always returns directly.
	ceContextInstVarvalue manages popping the pc into instructionPointer if necessary.

cePositive32BitIntegerTrampoline
	return pc left on stack because cePositive32BitInteger always returns directly
	
ceReturnToInterpreterTrampoline
	this is returned-to and never called; i.e. it is the return pc of a machine-code frame with an interpreted callee

ceResendCannotReturnTrampoline
	this is returned-to and never called; it is the pc for a machine-code frame which has been returned from

ceEnterCogCodePopReceiverReg
	this is an enilopmart and not called from machine code

cePrimReturnEnterCogCode
	this is an enilopmart and not called from machine code

ceTraceLinkedSendTrampoline
	return pc left on stack because ceTraceLinkedSend always returns directly

ceTraceBlockActivationTrampoline
	return pc left on stack because ceTraceBlockActivation always returns directly

ceTraceStoreTrampoline
	return pc left on stack because ceTraceStore always returns directly"
]

{ #category : #translation }
Cogit class >> typeForSelf [
	^#implicit
]

{ #category : #translation }
Cogit class >> wantsLabels [
	^true
]

{ #category : #'abstract instructions' }
Cogit >> AddCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: AddCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> AddCw: wordConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: AddCwR operand: wordConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> AddR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: AddRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> AddRd: dpreg1 Rd: dpreg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: AddRdRd operand: dpreg1 operand: dpreg2
]

{ #category : #'abstract instructions' }
Cogit >> AlignmentNops: alignment [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: AlignmentNops operand: alignment
]

{ #category : #'abstract instructions' }
Cogit >> AndCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: AndCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> AndCw: wordConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: AndCwR operand: wordConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> AndR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: AndRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> ArithmeticShiftRightCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: ArithmeticShiftRightCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> ArithmeticShiftRightR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: ArithmeticShiftRightRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> Call: callTarget [ 
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: Call operand: callTarget
]

{ #category : #'method map' }
Cogit >> CallRT: callTarget [
	<returnTypeC: #'AbstractInstruction *'>
	^self annotateCall: (self Call: callTarget)
]

{ #category : #'method map' }
Cogit >> CallSend: callTarget [
	<returnTypeC: #'AbstractInstruction *'>
	^self annotateSend: (self Call: callTarget)
]

{ #category : #'abstract instructions' }
Cogit >> CmpCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: CmpCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> CmpCw: wordConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: CmpCwR operand: wordConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> CmpR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: CmpRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> CmpRd: dpreg1 Rd: dpreg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: CmpRdRd operand: dpreg1 operand: dpreg2
]

{ #category : #'abstract instructions' }
Cogit >> ConvertR: reg1 Rd: dpreg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: ConvertRRd operand: reg1 operand: dpreg2
]

{ #category : #'abstract instructions' }
Cogit >> DivR: rDivisor R: rDividend Quo: rQuotient Rem: rRemainder [
	"Division is a little weird on some processors.  Defer to the backEnd
	 to allow it to generate any special code it may need to."
	<returnTypeC: #'AbstractInstruction *'>
	<inline: false>
	backEnd genDivR: rDivisor R: rDividend Quo: rQuotient Rem: rRemainder.
	^self abstractInstructionAt: opcodeIndex - 1
]

{ #category : #'abstract instructions' }
Cogit >> DivRd: dpreg1 Rd: dpreg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: DivRdRd operand: dpreg1 operand: dpreg2
]

{ #category : #'abstract instructions' }
Cogit >> Fill16: value [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	self assert: (value between: 0 and: 16rFFFF).
	^self gen: Fill16 operand: value
]

{ #category : #'abstract instructions' }
Cogit >> FillFrom: address Word: value [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: FillFromWord operand: address operand: value
]

{ #category : #'abstract instructions' }
Cogit >> Jump: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: Jump operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpAbove: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpAbove operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpAboveOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpAboveOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpBelow: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpBelow operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpBelowOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpBelowOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpCarry: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpCarry operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpFPEqual: jumpTarget [
	"Floating-point jumps are a little weird on some processors.  Defer to
	 the backEnd to allow it to generate any special code it may need to."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	<inline: false>
	^backEnd genJumpFPEqual: jumpTarget
]

{ #category : #'abstract instructions' }
Cogit >> JumpFPGreater: jumpTarget [
	"Floating-point jumps are a little weird on some processors.  Defer to
	 the backEnd to allow it to generate any special code it may need to."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	<inline: false>
	^backEnd genJumpFPGreater: jumpTarget
]

{ #category : #'abstract instructions' }
Cogit >> JumpFPGreaterOrEqual: jumpTarget [
	"Floating-point jumps are a little weird on some processors.  Defer to
	 the backEnd to allow it to generate any special code it may need to."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	<inline: false>
	^backEnd genJumpFPGreaterOrEqual: jumpTarget
]

{ #category : #'abstract instructions' }
Cogit >> JumpFPLess: jumpTarget [
	"Floating-point jumps are a little weird on some processors.  Defer to
	 the backEnd to allow it to generate any special code it may need to."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	<inline: false>
	^backEnd genJumpFPLess: jumpTarget
]

{ #category : #'abstract instructions' }
Cogit >> JumpFPLessOrEqual: jumpTarget [
	"Floating-point jumps are a little weird on some processors.  Defer to
	 the backEnd to allow it to generate any special code it may need to."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	<inline: false>
	^backEnd genJumpFPLessOrEqual: jumpTarget
]

{ #category : #'abstract instructions' }
Cogit >> JumpFPNotEqual: jumpTarget [
	"Floating-point jumps are a little weird on some processors.  Defer to
	 the backEnd to allow it to generate any special code it may need to."
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	<inline: false>
	^backEnd genJumpFPNotEqual: jumpTarget
]

{ #category : #'abstract instructions' }
Cogit >> JumpGreater: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpGreater operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpGreaterOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpGreaterOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpLess: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpLess operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpLessOrEqual: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpLessOrEqual operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpLong: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpLong operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpLongNonZero: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpLongNonZero operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpLongZero: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpLongZero operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpNegative: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpNegative operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpNoCarry: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpNoCarry operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpNoOverflow: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpNoOverflow operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpNonNegative: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpNonNegative operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpNonZero: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpNonZero operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpOverflow: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpOverflow operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> JumpR: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: JumpR operand: reg
]

{ #category : #'method map' }
Cogit >> JumpRT: callTarget [
	"Big assumption here that calls and jumps look the same as regards their displacement.
	 This works on x86 and I think on ARM."
	<returnTypeC: #'AbstractInstruction *'>
	^self annotateCall: (self JumpLong: (self cCoerceSimple: callTarget to: #'void *'))
]

{ #category : #'abstract instructions' }
Cogit >> JumpZero: jumpTarget [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #jumpTarget type: #'void *'>
	^self gen: JumpZero operand: jumpTarget asInteger
]

{ #category : #'abstract instructions' }
Cogit >> Label [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: Label operand: (labelCounter := labelCounter + 1)
]

{ #category : #'abstract instructions' }
Cogit >> LoadEffectiveAddressMw: offset r: baseReg R: destReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: LoadEffectiveAddressMwrR operand: offset operand: baseReg operand: destReg
]

{ #category : #'abstract instructions' }
Cogit >> LogicalShiftLeftCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: LogicalShiftLeftCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> LogicalShiftLeftR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: LogicalShiftLeftRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> LogicalShiftRightCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: LogicalShiftRightCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> LogicalShiftRightR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: LogicalShiftRightRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> MoveAw: address R: reg [ 
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveAwR operand: address operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> MoveCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> MoveCw: wordConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveCwR operand: wordConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> MoveM16: offset r: baseReg R: destReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveM16rR operand: offset operand: baseReg operand: destReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveM64: offset r: baseReg Rd: destDPReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveM64rRd operand: offset operand: baseReg operand: destDPReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveMb: offset r: baseReg R: destReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveMbrR operand: offset operand: baseReg operand: destReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveMw: offset r: baseReg R: destReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveMwrR operand: offset operand: baseReg operand: destReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveR: reg Aw: address [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveRAw operand: reg operand: address
]

{ #category : #'abstract instructions' }
Cogit >> MoveR: sourceReg Mb: offset r: baseReg [ 
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveRMbr operand: sourceReg operand: offset operand: baseReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveR: sourceReg Mw: offset r: baseReg [ 
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveRMwr operand: sourceReg operand: offset operand: baseReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> MoveR: sourceReg Xwr: indexReg R: baseReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveRXwrR operand: sourceReg operand: indexReg operand: baseReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveRd: sourceDPReg M64: offset r: baseReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveRdM64r operand: sourceDPReg operand: offset operand: baseReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveRd: dpreg1 Rd: dpreg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveRdRd operand: dpreg1 operand: dpreg2
]

{ #category : #'abstract instructions' }
Cogit >> MoveXbr: indexReg R: baseReg R: destReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveXbrRR operand: indexReg operand: baseReg operand: destReg
]

{ #category : #'abstract instructions' }
Cogit >> MoveXwr: indexReg R: baseReg R: destReg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MoveXwrRR operand: indexReg operand: baseReg operand: destReg
]

{ #category : #'abstract instructions' }
Cogit >> MulR: reg1 R: reg2 [
	"Multiplication is a little weird on some processors.  Defer to the backEnd
	 to allow it to generate any special code it may need to."
	<returnTypeC: #'AbstractInstruction *'>
	<inline: false>
	backEnd genMulR: reg1 R: reg2.
	^self abstractInstructionAt: opcodeIndex - 1
]

{ #category : #'abstract instructions' }
Cogit >> MulRd: dpreg1 Rd: dpreg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: MulRdRd operand: dpreg1 operand: dpreg2
]

{ #category : #'abstract instructions' }
Cogit >> NegateR: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: NegateR operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> OrCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: OrCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> OrCw: wordConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: OrCwR operand: wordConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> OrR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: OrRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> PopR: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: PopR operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> PushCw: wordConstant [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: PushCw operand: wordConstant
]

{ #category : #'abstract instructions' }
Cogit >> PushR: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: PushR operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> RetN: offset [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: RetN operand: offset
]

{ #category : #'abstract instructions' }
Cogit >> SqrtRd: dpreg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: SqrtRd operand: dpreg
]

{ #category : #'abstract instructions' }
Cogit >> SubCq: quickConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: SubCqR operand: quickConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> SubCw: wordConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: SubCwR operand: wordConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> SubR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: SubRR operand: reg1 operand: reg2
]

{ #category : #'abstract instructions' }
Cogit >> SubRd: dpreg1 Rd: dpreg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: SubRdRd operand: dpreg1 operand: dpreg2
]

{ #category : #'abstract instructions' }
Cogit >> XorCw: wordConstant R: reg [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: XorCwR operand: wordConstant operand: reg
]

{ #category : #'abstract instructions' }
Cogit >> XorR: reg1 R: reg2 [
	<inline: true>
	<returnTypeC: #'AbstractInstruction *'>
	^self gen: XorRR operand: reg1 operand: reg2
]

{ #category : #'in-line cacheing' }
Cogit >> abortOffset [
	<api>
	^missOffset
]

{ #category : #testing }
Cogit >> abstractInstruction: theAbstractInstruction follows: anAbstractInstruction [
	<var: #theAbstractInstruction type: #'AbstractInstruction *'>
	<var: #anAbstractInstruction  type: #'AbstractInstruction *'>
	^theAbstractInstruction > anAbstractInstruction
]

{ #category : #'compile abstract instructions' }
Cogit >> abstractInstructionAt: index [
	<cmacro: '(index) (&abstractOpcodes[index])'>
	^abstractOpcodes at: index
]

{ #category : #accessing }
Cogit >> abstractOpcodes [
	"For CogAbstractInstruction>>#>, which in turn is for Cogit>>abstractInstruction:follows:"
	<doNotGenerate>
	^abstractOpcodes
]

{ #category : #'compile abstract instructions' }
Cogit >> addBlockStartAt: bytecodepc numArgs: numArgs numCopied: numCopied span: span [
	"Add a blockStart for an embedded block.  For a binary tree walk block dispatch
	 blocks must be compiled in pc/depth-first order but are scanned in breadth-first
	 order, so do an insertion sort (which of course is really a bubble sort because we
	 have to move everything higher to make room)."
	<returnTypeC: #'BlockStart *'>
	| i blockStart |
	<var: #blockStart type: #'BlockStart *'>
	blockCount > 0
		ifTrue:
			[i := blockCount - 1.
			 [blockStart := self cCode: '&blockStarts[i]' inSmalltalk: [blockStarts at: i].
			   blockStart startpc > bytecodepc
			   and: [i > 0]] whileTrue:
				[i := i - 1].
			 blockCount to: i + 1 by: -1 do:
				[:j|
				blockStarts at: j put: (blockStarts at: j - 1)].
			blockStart := self cCode: '&blockStarts[i + 1]'
							inSmalltalk: [blockStarts at: i + 1 put: CogBlockStart new]]
		ifFalse:
			[blockStart := self cCode: '&blockStarts[blockCount]'
								inSmalltalk: [blockStarts at: blockCount put: CogBlockStart new]].
	blockCount := blockCount + 1.
	blockStart
		startpc: bytecodepc;
		numArgs: numArgs;
		numCopied: numCopied;
		stackCheckLabel: nil;
		span: span.
	^blockStart
]

{ #category : #debugging }
Cogit >> addCogMethodsToHeapMap [
	<api>
	"Perform an integrity/leak check using the heapMap.
	 Set a bit at each cog method's header."	
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType = CMMethod ifTrue:
			[self heapMapAtWord: cogMethod Put: 1].
		cogMethod := methodZone methodAfter: cogMethod]
]

{ #category : #testing }
Cogit >> addressIsInFixups: address [
	<var: #address type: #'void *'>
	^self cCode: 'address >= &fixups[0] && address < &fixups[opcodeIndex]'
		inSmalltalk: [fixups notNil
					and: [(fixups object identityIndexOf: address) between: 1 and: opcodeIndex]]
]

{ #category : #testing }
Cogit >> addressIsInInstructions: address [
	<var: #address type: #'void *'>
	self flag: 'faster if a macro'.
	^self cCode: 'address >= (void *)&abstractOpcodes[0] && address < (void *)&abstractOpcodes[opcodeIndex]'
		inSmalltalk: [(abstractOpcodes object identityIndexOf: address) between: 1 and: opcodeIndex]
]

{ #category : #'in-line cacheing' }
Cogit >> addressOfEndOfCase: n inCPIC: cPIC [
	"N.B. zero-relative"
	<var: #cPIC type: #'CogMethod *'>
	^cPIC asInteger + firstCPICCaseOffset + (n * cPICCaseSize)
]

{ #category : #accessing }
Cogit >> addressSpaceMask [
	<doNotGenerate>
	^(1 << (8 * BytesPerWord)) - 1
]

{ #category : #'generate machine code' }
Cogit >> alignUptoRoutineBoundary: anAddress [ 
	^anAddress + 7 bitAnd: 7 bitInvert32
]

{ #category : #'garbage collection' }
Cogit >> allMachineCodeObjectReferencesValid [
	"Check that all methods have valid selectors, and that all linked sends are to valid targets and have valid cache tags"
	| ok cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	ok := true.
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType ~= CMFree ifTrue:
			[(self asserta: (objectRepresentation checkValidObjectReference: cogMethod selector)) ifFalse:
				[ok := false].
			 (self asserta: (self cogMethodDoesntLookKosher: cogMethod) = 0) ifFalse:
				[ok := false]].
		(cogMethod cmType = CMMethod
		 or: [cogMethod cmType = CMOpenPIC]) ifTrue:
			[(self asserta: ((self mapFor: cogMethod
								 performUntil: #checkIfValidObjectRefAndTarget:pc:cogMethod: asSymbol
								 arg: cogMethod asInteger) = 0)) ifFalse:
				[ok := false]].
		cogMethod cmType = CMClosedPIC ifTrue:
			[(self asserta: (self noTargetsFreeInClosedPIC: cogMethod)) ifFalse:
				[ok := false]].
		cogMethod := methodZone methodAfter: cogMethod].
	^ok
]

{ #category : #'garbage collection' }
Cogit >> allMethodsHaveCorrectHeader [
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType = CMMethod ifTrue:
			[(objectRepresentation hasValidHeaderPostGC: cogMethod) ifFalse:
				[^false]].
		 cogMethod := methodZone methodAfter: cogMethod].
	^true
]

{ #category : #initialization }
Cogit >> allocateBlockStarts: numBlocks [
	"Allocate the structures used to manage block compilation.  This
	 needs to be a macro since the structures are alloca'ed (stack
	 allocated) to ensure their being freed when compilation is done."
	<cmacro: '(numBlocks) do { \
		blockStarts = numBlocks ? alloca(sizeof(BlockStart) * numBlocks) : 0; \
} while (0)'>
	blockStarts := numBlocks > 0 ifTrue:
					[CArrayAccessor on:
						((1 to: numBlocks) collect:
							[:ign| CogBlockStart new])]
]

{ #category : #initialization }
Cogit >> allocateOpcodes: numberOfAbstractOpcodes bytecodes: numberOfBytecodes [
	"Allocate the various arrays needed to compile abstract instructions.
	 This needs to be a macro since the arrays are alloca'ed (stack allocated)
	 to ensure their being freed when compilation is done.
	 Notionally we only need as many fixups as there are bytecodes.  But we
	 reuse fixups to record pc-dependent instructions in generateInstructionsAt:
	 and so need at least as many as there are abstract opcodes.

	 N.B. We do one single alloca to save embarrassing C optimizers that
	 generate incorrect code as both gcc and the intel compiler do on x86."
	<cmacro: '(numberOfAbstractOpcodes,numberOfBytecodes) do { \
		int opcodeSize = sizeof(AbstractInstruction) * (numAbstractOpcodes = (numberOfAbstractOpcodes)); \
		int fixupSize = sizeof(BytecodeFixup) * numAbstractOpcodes; \
		int annotationSize = sizeof(InstructionAnnotation) * ((numAbstractOpcodes + 3) / 4); \
		abstractOpcodes = alloca(opcodeSize + fixupSize + annotationSize); \
		bzero(abstractOpcodes, opcodeSize + fixupSize); \
		fixups = (void *)((char *)abstractOpcodes + opcodeSize); \
		annotations = (void *)((char *)fixups + fixupSize); \
		opcodeIndex = labelCounter = annotationIndex = 0; \
} while (0)'>
	numAbstractOpcodes := numberOfAbstractOpcodes.
	abstractOpcodes := CArrayAccessor on:
						((1 to: numAbstractOpcodes) collect:
							[:ign| processor abstractInstructionCompilerClass for: self]).
	fixups := CArrayAccessor on:
						((1 to: numAbstractOpcodes) collect:
							[:ign| CogBytecodeFixup new targetInstruction: 0; instructionIndex: 0; yourself]).
	annotations := CArrayAccessor on:
						((1 to: numAbstractOpcodes + 3 // 4) collect:
							[:ign| CogInstructionAnnotation new]).
	opcodeIndex := labelCounter := annotationIndex := 0
]

{ #category : #'method map' }
Cogit >> annotate: abstractInstruction objRef: anOop [
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	(objectRepresentation shouldAnnotateObjectReference: anOop) ifTrue:
		[(coInterpreter isYoung: anOop) ifTrue:
			[hasYoungReferent := true].
		^self annotate: abstractInstruction with: IsObjectReference].
	^abstractInstruction
]

{ #category : #'method map' }
Cogit >> annotate: abstractInstruction with: annotationFlag [ "<Integer>"
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	| annotation |
	<var: #annotation type: #'InstructionAnnotation *'>
	annotation := self addressOf: (annotations at: annotationIndex).
	annotationIndex := annotationIndex + 1.
	annotation
		instruction: abstractInstruction;
		annotation: annotationFlag.
	^abstractInstruction
]

{ #category : #'method map' }
Cogit >> annotateBytecode: abstractInstruction [
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	<inline: true>
	^self annotate: abstractInstruction with: HasBytecodePC
]

{ #category : #'method map' }
Cogit >> annotateCall: abstractInstruction [
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	<inline: true>
	^self annotate: abstractInstruction with: IsRelativeCall
]

{ #category : #'method map' }
Cogit >> annotateMethodRef: abstractInstruction [
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	<inline: true>
	^self annotate: abstractInstruction with: IsMethodReference
]

{ #category : #'method map' }
Cogit >> annotateSend: abstractInstruction [
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	<returnTypeC: #'AbstractInstruction *'>
	<inline: true>
	^self annotate: abstractInstruction with: IsSendCall
]

{ #category : #'simulation only' }
Cogit >> assertCStackWellAligned [
	"Check alignment of the C stack.  This is a simulation only facsimilie.
	 See platforms/Cross/vm/sqCogStackAlignment.h for the real code."
	<doNotGenerate>
	self assert: processor sp \\ cStackAlignment = expectedSPAlignment.
	self assert: processor fp \\ cStackAlignment = expectedFPAlignment
]

{ #category : #'method map' }
Cogit >> assertCheckMapEntry: annotation mcpc: mcpc arg: tupleOfCogMethodAndMcpcToBcpcMap [
	<doNotGenerate>
	(self mapFor: tupleOfCogMethodAndMcpcToBcpcMap first
		performUntil: #checkIsRealMapEntry:mcpc:forMcpc: asSymbol
		arg: mcpc) ifFalse:
		[^0]."keep scanning"
	[:cogMethod :mcpcToBcpcMap|
	 self startMcpcAndCogMethodForMcpc: mcpc in: cogMethod do:
		[:startMcpc :theMethod| | bcpc startBcpc mcpcForBcpc |
		annotation = IsMethodReference ifTrue:
			[self assert: (backEnd literalBeforeFollowingAddress: mcpc)
			 = (theMethod asInteger + (theMethod cmType = CMBlock
										ifTrue: [MFMethodFlagIsBlockFlag]
										ifFalse: [0])).
			 ^0].
		annotation = IsObjectReference ifTrue:
			[objectRepresentation assertIsValidOop: (backEnd literalBeforeFollowingAddress: mcpc).
			 ^0]. "keep scannng"
		(annotation = HasBytecodePC or: [annotation = IsSendCall]) ifFalse:
			[^0]. "keep scanning"
		startMcpc = mcpc ifTrue: "The first mcpc is in the map as a fiducial but does not map."
			[^0]. "keep scanning"
		startBcpc := mcpcToBcpcMap at: startMcpc.
		"Now check that the bytecode pc actually maps"
		bcpc := self bytecodePCFor: mcpc startBcpc: startBcpc in: theMethod.
		self assert: bcpc ~= 0.
		self canMapBytecodePCsToNativePCs ifTrue:
			[mcpcForBcpc := self mcPCForBcpc: bcpc startBcpc: startBcpc in: theMethod.
			 self assert: mcpcForBcpc = mcpc]]]
		valueWithArguments: tupleOfCogMethodAndMcpcToBcpcMap.
	^0 "keep scanning"
]

{ #category : #debugging }
Cogit >> assertSaneJumpTarget: jumpTarget [
	<var: #jumpTarget type: #'void *'>

	self assert: (closedPICSize isNil "don't whinge when producing the PIC prototypes"
			or: [openPICSize isNil
			or: [(self addressIsInInstructions: jumpTarget)
			or: [(jumpTarget asInteger
					between: codeBase
					and: methodZone limitZony asInteger + (closedPICSize max: openPICSize))]]])
]

{ #category : #'simulation only' }
Cogit >> assertStackPointersBelongToCurrentThread [
	<doNotGenerate>
	| range |
	coInterpreter isThreadedVM ifTrue:
		[range := coInterpreter cStackRangeForCurrentThread.
		self assert: ((range includes: processor sp)
					and: [range includes: processor fp])]
]

{ #category : #'simulation only' }
Cogit >> assertStackPointersBelongToCurrentVMOwner [
	<doNotGenerate>
	| range |
	range := coInterpreter cStackRangeForCurrentVMOwner.
	self assert: ((range includes: processor sp)
				and: [range includes: processor fp])
]

{ #category : #'method map' }
Cogit >> assertValidMethodMap: cogMethod [
	<doNotGenerate>
	self mapFor: cogMethod
		performUntil: #assertCheckMapEntry:mcpc:arg: asSymbol
		arg: { cogMethod. self mcpcToBcpcMapFor: cogMethod }
]

{ #category : #disassembly }
Cogit >> blockDispatchFor: cogMethod perform: quaternaryFunction arg: arg [
	"Evaluate quaternaryFunction with the block start mcpc, prev pc in block
	 dispatch, current pc in block dispatch and the supplied arg for each entry
	 in the block dispatch.  If the function answers non-zero answer the value
	 it answered. Used for disassembling blockDispatch."
	<doNotGenerate>
	| pc prevpc blockEntry end targetpc result |
	cogMethod blockEntryOffset = 0 ifTrue:
		[^nil].
	blockEntry := cogMethod blockEntryOffset + cogMethod asInteger.
	prevpc := pc := blockEntry.
	end := (self mapEndFor: cogMethod) - 1.
	[pc < end] whileTrue:
		[(backEnd isJumpAt: pc)
			ifTrue:
				[targetpc := backEnd jumpTargetAt: pc.
				 pc := pc + (backEnd instructionSizeAt: pc).
				 targetpc < blockEntry ifTrue:
					[result := self perform: quaternaryFunction
								with: targetpc
								with: prevpc
								with: pc
								with: arg.
					 result ~= 0 ifTrue:
						[^result].
					 prevpc := pc]]
			ifFalse:
				[pc := pc + (backEnd instructionSizeAt: pc)]].
	^0
]

{ #category : #disassembly }
Cogit >> blockDispatchTargetsFor: cogMethod perform: binaryFunction arg: arg [
	"Evaluate binaryFunction with the block start mcpc and supplied arg for each
	 entry in the block dispatch.  If the function answers non-zero answer the value
	 it answered.  Used to update back-references to the home method in compaction."
	<var: #cogMethod type: #'CogMethod *'>
	<var: #binaryFunction declareC: 'usqInt (*binaryFunction)(sqInt mcpc, sqInt arg)'>
	| pc blockEntry end targetpc result |
	cogMethod blockEntryOffset = 0 ifTrue:
		[^nil].
	blockEntry := cogMethod blockEntryOffset + cogMethod asInteger.
	pc := blockEntry.
	end := (self mapEndFor: cogMethod) - 1.
	[pc < end] whileTrue:
		[(backEnd isJumpAt: pc) ifTrue:
			[targetpc := backEnd jumpTargetAt: pc.
			 targetpc < blockEntry ifTrue:
				[result := self perform: binaryFunction
							with: targetpc
							with: arg.
				 result ~= 0 ifTrue:
					[^result]]].
		pc := pc + (backEnd instructionSizeAt: pc)].
	^0
]

{ #category : #'compile abstract instructions' }
Cogit >> blockStartAt: index [
	<cmacro: '(index) (&blockStarts[index])'>
	^blockStarts at: index
]

{ #category : #disassembly }
Cogit >> blockStartPcsIn: aMethod [
	"Answer the start bytecopde pcs in a method in compilation order, i.e. depth-first.
	 Blocks must occur in pc/depth-first order for binary tree block dispatch to work."
	| startpcs pc latestContinuation end descriptor |
	<doNotGenerate>
	startpcs := OrderedCollection new.
	startpcs add: (pc := latestContinuation := coInterpreter startPCOfMethod: aMethod).
	end := coInterpreter byteSizeOf: aMethod.
	[pc <= end] whileTrue:
		[descriptor := self generatorAt: (coInterpreter fetchByte: pc ofObject: aMethod).
		(descriptor isReturn
		 and: [pc >= latestContinuation]) ifTrue:
			[end := pc].
		descriptor isBranch ifTrue:
			[| distance targetPC |
			 distance := self spanFor: descriptor at: pc byte0: byte0 in: methodObj.
			 targetPC := pc + descriptor numBytes + distance.
			 descriptor isBackwardBranch ifFalse:
				[latestContinuation := latestContinuation max: targetPC]].
		 pc := pc + descriptor numBytes.
		 descriptor isBlockCreation ifTrue:
			[startpcs add: pc]].
	^startpcs
]

{ #category : #'simulation only' }
Cogit >> breakMethod [
	<doNotGenerate>
	^breakMethod
]

{ #category : #'simulation only' }
Cogit >> breakPC [
	<doNotGenerate>
	^breakPC
]

{ #category : #'simulation only' }
Cogit >> breakPC: anAddress [
	<doNotGenerate>
	breakPC := anAddress
]

{ #category : #'generate machine code' }
Cogit >> byteAt: anAddress put: aValue [
	"Store a byte in memory.  In Smaltalk defer to the coInterpreter.
	 In C this will be replaced by a macro (byteAtPut)."
	<doNotGenerate> 
	coInterpreter byteAt: anAddress put: aValue
]

{ #category : #'method map' }
Cogit >> bytecodePCFor: mcpc startBcpc: startbcpc in: cogMethod [
	"Answer the zero-relative bytecode pc matching the machine code pc argument in
	 cogMethod, given the start of the bytecodes for cogMethod's block or method object."
	<api>
	<var: #cogMethod type: #'CogBlockMethod *'>
	| startmcpc homeMethod mapStart |
	<var: #homeMethod type: #'CogMethod *'>
	"All map entries for bytecodes (sends, mustBeBooleans et al) map to the following
	 bytecode except the first bytecode (stackCheckOffset).  So special case that here."
	mcpc = (cogMethod asInteger + cogMethod stackCheckOffset) ifTrue:
		[^startbcpc].
	cogMethod cmType = CMMethod
		ifTrue:
			[startmcpc := cogMethod asInteger + cmNoCheckEntryOffset.
			 homeMethod := self cCoerceSimple: cogMethod to: #'CogMethod *'.
			 self assert: startbcpc = (coInterpreter startPCOfMethodHeader: homeMethod methodHeader).
			 mapStart := self findMapLocationForMcpc: startmcpc inMethod: homeMethod.
			 self assert: ((coInterpreter byteAt: mapStart) >> AnnotationShift = IsMethodReference
						 or: [(coInterpreter byteAt: mapStart) >> AnnotationShift = IsRelativeCall
						 or: [(coInterpreter byteAt: mapStart) >> AnnotationShift = IsDisplacementX2N]])]
		ifFalse:
			[startmcpc := cogMethod asInteger + (self sizeof: CogBlockMethod).
			 homeMethod := self cogHomeMethod: cogMethod.
			 mapStart := self findMapLocationForMcpc: startmcpc inMethod: homeMethod.
			 self assert: (coInterpreter byteAt: mapStart) >> AnnotationShift = HasBytecodePC. "fiducial"
			 mapStart := mapStart - 1]. "skip fiducial"
	^self
		mapAt: mapStart
		methodObj: homeMethod methodObject
		startmcpc: startmcpc
		bcpc: startbcpc
		performUntil: #find:Matching:Bcpc:Size:PC: asSymbol
		arg: (self cCoerceSimple: mcpc to: #'void *')
]

{ #category : #'translation support' }
Cogit >> cCoerceSimple: value to: cTypeString [
	<doNotGenerate>
	cTypeString == #'CogMethod *' ifTrue:
		[^(value isInteger and: [value < 0])
			ifTrue: [value] "it's an error code; leave it be"
			ifFalse: [coInterpreter cogMethodSurrogateAt: value asUnsignedInteger]].
	cTypeString == #'CogBlockMethod *' ifTrue:
		[^coInterpreter cogBlockMethodSurrogateAt: value asUnsignedInteger].
	^super cCoerceSimple: value to: cTypeString
]

{ #category : #'trampoline support' }
Cogit >> cFramePointerAddress [
	<cmacro: '() ((unsigned long)&CFramePointer)'>
	^coInterpreter inMemoryCFramePointerAddress
]

{ #category : #accessing }
Cogit >> cFramePointerInUse [
	<api>
	<cmacro: '() cFramePointerInUse'>
	^cFramePointerInUse
]

{ #category : #'in-line cacheing' }
Cogit >> cPIC: cPIC HasTarget: targetMethod [
	<var: #cPIC type: #'CogMethod *'>
	<var: #targetMethod type: #'CogMethod *'>
	| pc target |
	target := targetMethod asUnsignedInteger + cmNoCheckEntryOffset.
	pc := cPIC asInteger + firstCPICCaseOffset.
	1 to: cPIC cPICNumCases do:
		[:i|
		target = (backEnd jumpLongTargetBeforeFollowingAddress: pc) ifTrue:
			[^true].
		pc := pc + cPICCaseSize].
	^false
]

{ #category : #'in-line cacheing' }
Cogit >> cPICHasFreedTargets: cPIC [
	<var: #cPIC type: #'CogMethod *'>
	| pc entryPoint targetMethod |
	<var: #targetMethod type: #'CogMethod *'>
	pc := cPIC asInteger + firstCPICCaseOffset.
	1 to: cPIC cPICNumCases do:
		[:i|
		entryPoint := backEnd jumpLongTargetBeforeFollowingAddress: pc.
		"Find target from jump.  Ignore jumps to the interpret and MNU calls within this PIC"
		(entryPoint < cPIC asInteger
		 or: [entryPoint > (cPIC asInteger + cPIC blockSize)]) ifTrue:
			[targetMethod := self cCoerceSimple: entryPoint - cmNoCheckEntryOffset to: #'CogMethod *'.
			 self assert: (targetMethod cmType = CMMethod or: [targetMethod cmType = CMFree]).
			 targetMethod cmType = CMFree ifTrue:
				[^true]].
		pc := pc + cPICCaseSize].
	^false
]

{ #category : #'trampoline support' }
Cogit >> cStackPointerAddress [
	<cmacro: '() ((unsigned long)&CStackPointer)'>
	^coInterpreter inMemoryCStackPointerAddress
]

{ #category : #'jit - api' }
Cogit >> canLinkToYoungClasses [
	<api>
	^methodZone roomOnYoungReferrersList
]

{ #category : #'method map' }
Cogit >> canMapBytecodePCsToNativePCs [
	<api>
	"For now finesse the whole issue of bytecode pc to machine code pc mapping."
	self flag: #revisit.
	^false
]

{ #category : #accessing }
Cogit >> ceBaseFrameReturnPC [
	<api>
	<cmacro: '() ceBaseFrameReturnTrampoline'>
	^ceBaseFrameReturnTrampoline
]

{ #category : #'in-line cacheing' }
Cogit >> ceCPICMiss: cPIC receiver: receiver [
	"Code entry closed PIC miss.  A send has fallen
	 through a closed (finite) polymorphic inline cache.
	 Either extend it or patch the send site to an open PIC.
	 The stack looks like:
			receiver
			args
	  sp=>	sender return address"
	<var: #cPIC type: #'CogMethod *'>
	<api>
	| outerReturn newTargetMethodOrNil cacheTag result |
	self cCode: ''
		inSmalltalk:
			[cPIC isInteger ifTrue:
				[^self ceCPICMiss: (coInterpreter cogMethodSurrogateAt: cPIC) receiver: receiver]].
	outerReturn := coInterpreter stackTop.
	newTargetMethodOrNil := self lookupAndCog: cPIC selector for: receiver.
	"We assume lookupAndCog:for: will *not* reclaim the method zone"
	self assert: outerReturn = coInterpreter stackTop.
	cacheTag := objectRepresentation inlineCacheTagForInstance: receiver.
	(cPIC cPICNumCases >= numPICCases
	 or: [(objectRepresentation inlineCacheTagIsYoung: cacheTag)
	 or: [newTargetMethodOrNil notNil
		 and: [coInterpreter isYoung: newTargetMethodOrNil]]]) ifTrue:
		[result := self patchToOpenPICFor: cPIC selector
					numArgs: cPIC cmNumArgs
					receiver: receiver.
		 self assert: result not. "If patchToOpenPICFor:.. returns we're out of code memory"
		 ^coInterpreter ceSendFromInLineCacheMiss: cPIC].
	"Now extend the PIC with the new case."
	self cogExtendPIC: cPIC
		CaseNMethod: newTargetMethodOrNil
		tag: cacheTag.
	"Jump back into the pic at its entry in case this is an MNU (newTargetMethodOrNil is nil)"
	coInterpreter
		executeCogMethodFromLinkedSend: cPIC
		withReceiver: receiver
		andCacheTag: (backEnd inlineCacheTagAt: outerReturn).
	"NOTREACHED"
	^nil
]

{ #category : #accessing }
Cogit >> ceCannotResumePC [
	<api>
	<cmacro: '() ((usqInt)ceCannotResumeTrampoline)'>
	<returnTypeC: #usqInt> "for Slang"
	^ceCannotResumeTrampoline
]

{ #category : #'jit - api' }
Cogit >> ceCaptureCStackPointers [
	<api: 'extern void (*ceCaptureCStackPointers)()'>
	<doNotGenerate>
	| range |
	coInterpreter isThreadedVM ifFalse:
		[^self].
	thisContext sender selector == #generateStackPointerCapture ifTrue:
		[^self].
	range := coInterpreter cStackRangeForThreadIndex: coInterpreter threadManager getVMOwner.
	self assert: ((range includes: processor sp)
				and: [range includes: processor fp]).
	self setCStackPointer: processor sp.
	self setCFramePointer: processor fp
]

{ #category : #testing }
Cogit >> ceCheckFeatures [
	<cmacro: '() ceCheckFeaturesFunction()'>
	^self simulateLeafCallOf: ceCheckFeaturesFunction
]

{ #category : #'simulation only' }
Cogit >> ceEnterCogCodePopReceiverAndClassRegs [
	<api: 'extern void (*ceEnterCogCodePopReceiverAndClassRegs)()'>
	<doNotGenerate>
	self simulateEnilopmart: ceEnterCogCodePopReceiverAndClassRegs numArgs: 2
]

{ #category : #'simulation only' }
Cogit >> ceEnterCogCodePopReceiverReg [
	<api: 'extern void (*ceEnterCogCodePopReceiverReg)()'>
	<doNotGenerate>
	self simulateEnilopmart: ceEnterCogCodePopReceiverReg numArgs: 1
]

{ #category : #accessing }
Cogit >> cePositive32BitIntegerTrampoline [
	<cmacro: '() cePositive32BitIntegerTrampoline'>
	^cePositive32BitIntegerTrampoline
]

{ #category : #accessing }
Cogit >> ceReturnToInterpreterPC [
	<api>
	<cmacro: '() ((usqInt)ceReturnToInterpreterTrampoline)'>
	<returnTypeC: #usqInt> "for Slang"
	^ceReturnToInterpreterTrampoline
]

{ #category : #'in-line cacheing' }
Cogit >> ceSICMiss: receiver [
	"An in-line cache check in a method has failed.  The failing entry check has jumped
	 to the ceSendMiss abort call at the start of the method which has called this routine.
	 If possible allocate a closed PIC for the current and existing classes.
	 The stack looks like:
			receiver
			args
			sender return address
	  sp=>	ceSendMiss call return address
	 So we can find the method that did the failing entry check at
		ceSendMiss call return address - sicMissReturnOffset
	 and we can find the send site from the outer return address."
	<api>
	| pic innerReturn outerReturn entryPoint targetMethod newTargetMethodOrNil cacheTag extent result |
	<var: #pic type: #'CogMethod *'>
	<var: #targetMethod type: #'CogMethod *'>
	"Whether we can relink to a PIC or not we need to pop off the inner return and identify the target method."
	innerReturn := coInterpreter popStack.
	targetMethod := self cCoerceSimple: innerReturn - missOffset to: #'CogMethod *'.
	outerReturn := coInterpreter stackTop.
	entryPoint := backEnd callTargetFromReturnAddress: outerReturn.

	self assert: targetMethod asInteger + cmEntryOffset = entryPoint.
	self assert: targetMethod selector ~= coInterpreter nilObject.

	newTargetMethodOrNil := self lookupAndCog: targetMethod selector for: receiver.
	"We assume lookupAndCog:for: will *not* reclaim the method zone"
	self assert: outerReturn = coInterpreter stackTop.
	cacheTag := objectRepresentation inlineCacheTagForInstance: receiver.
	((objectRepresentation inlineCacheTagIsYoung: cacheTag)
	  or: [newTargetMethodOrNil notNil
		 and: [coInterpreter isYoung: newTargetMethodOrNil]]) ifTrue:
		[result := self patchToOpenPICFor: targetMethod selector
					numArgs: targetMethod cmNumArgs
					receiver: receiver.
		 self assert: result not. "If patchToOpenPICFor:.. returns we're out of code memory"
		 ^coInterpreter ceSendFromInLineCacheMiss: targetMethod].
	"See if an Open PIC is already available."
	pic := methodZone openPICWithSelector: targetMethod selector.
	pic isNil ifTrue:
		["otherwise attempt to create a closed PIC for the two cases."
		 pic := self cogPICSelector: targetMethod selector
					numArgs: targetMethod cmNumArgs
					Case0Method: targetMethod
					Case1Method: newTargetMethodOrNil
					tag: cacheTag.
		 (pic asInteger between: MaxNegativeErrorCode and: -1) ifTrue:
			["For some reason the PIC couldn't be generated, most likely a lack of code memory.
			  Continue as if this is an unlinked send."
			 pic asInteger = InsufficientCodeSpace ifTrue:
				[coInterpreter callForCogCompiledCodeCompaction].
			^coInterpreter ceSendFromInLineCacheMiss: targetMethod]].
	extent := backEnd
				rewriteCallAt: outerReturn
				target: pic asInteger + cmEntryOffset.
	processor
		flushICacheFrom: outerReturn - 1 - extent to: outerReturn - 1;
		flushICacheFrom: pic asInteger to: pic asInteger + closedPICSize.
	"Jump back into the pic at its entry in case this is an MNU (newTargetMethodOrNil is nil)"
	coInterpreter
		executeCogMethodFromLinkedSend: pic
		withReceiver: receiver
		andCacheTag: (backEnd inlineCacheTagAt: outerReturn).
	"NOTREACHED"
	^nil
]

{ #category : #accessing }
Cogit >> ceStoreCheckTrampoline [
	<cmacro: '() ceStoreCheckTrampoline'>
	^ceStoreCheckTrampoline
]

{ #category : #debugging }
Cogit >> checkAssertsEnabledInCogit [
	<api>
	| assertsAreEnabledInCogit |
	assertsAreEnabledInCogit := false.
	self assert: assertsAreEnabledInCogit
]

{ #category : #'garbage collection' }
Cogit >> checkIfValidObjectRef: annotation pc: mcpc cogMethod: cogMethod [
	<var: #mcpc type: #'char *'>
	annotation = IsObjectReference ifTrue:
		[| literal |
		 literal := backEnd literalBeforeFollowingAddress: mcpc asInteger.
		 (objectRepresentation checkValidObjectReference: literal) ifFalse:
			[self print: 'object ref leak in CM '; printHex: cogMethod asInteger; print: ' @ '; printHex: mcpc asInteger; cr.
			^1]].
	annotation = IsSendCall ifTrue:
		[| cacheTag |
		 cacheTag := backEnd inlineCacheTagAt: mcpc asInteger.
		 (objectRepresentation checkValidInlineCacheTag: cacheTag) ifFalse:
			[self print: 'cache tag/selector leak in CM '; printHex: cogMethod asInteger; print: ' @ '; printHex: mcpc asInteger; cr.
			^1]].
	^0 "keep scanning"
]

{ #category : #'garbage collection' }
Cogit >> checkIfValidObjectRefAndTarget: annotation pc: mcpc cogMethod: cogMethod [
	<var: #mcpc type: #'char *'>
	| literal cacheTag entryPoint offset targetMethod |
	<var: #targetMethod type: #'CogMethod *'>
	annotation = IsObjectReference ifTrue:
		[literal := backEnd literalBeforeFollowingAddress: mcpc asInteger.
		 (self asserta: (objectRepresentation checkValidObjectReference: literal)) ifFalse:
			[^1].
		((objectRepresentation couldBeObject: literal)
		 and: [coInterpreter isReallyYoungObject: literal]) ifTrue:
			[(self asserta: (self cCoerceSimple: cogMethod to: #'CogMethod *') cmRefersToYoung) ifFalse:
				[^2]]].
	annotation = IsSendCall ifTrue:
		[(self asserta: (self cCoerceSimple: cogMethod to: #'CogMethod *') cmType = CMMethod) ifFalse:
			[^3].
		 cacheTag := backEnd inlineCacheTagAt: mcpc asInteger.
		 (self asserta: (objectRepresentation checkValidInlineCacheTag: cacheTag)) ifFalse:
			[^4].
		((objectRepresentation couldBeObject: cacheTag)
		 and: [coInterpreter isReallyYoungObject: cacheTag]) ifTrue:
			[(self asserta: (self cCoerceSimple: cogMethod to: #'CogMethod *') cmRefersToYoung) ifFalse:
				[^5]].
		entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
		entryPoint > methodZoneBase ifTrue:
			["It's a linked send; find which kind."
			offset := (entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
						ifTrue: [cmEntryOffset]
						ifFalse: [cmNoCheckEntryOffset].
			 targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
			 (self asserta: (targetMethod cmType = CMMethod
						   or: [targetMethod cmType = CMClosedPIC
						   or: [targetMethod cmType = CMOpenPIC]])) ifFalse:
				[^6]]].
	^0 "keep scanning"
]

{ #category : #debugging }
Cogit >> checkIntegrityOfObjectReferencesInCode: fullGCFlag [
	<api>
	"Answer if all references to objects in machine-code are valid."	
	| cogMethod ok count |
	<var: #cogMethod type: #'CogMethod *'>
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	ok := true.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType ~= CMFree ifTrue:
			[cogMethod cmRefersToYoung ifTrue:
				[(count := methodZone occurrencesInYoungReferrers: cogMethod) ~= 1 ifTrue:
					[self print: 'young referrer CM '; printHex: cogMethod asInteger.
					 count = 0
						ifTrue: [self print: ' is not in youngReferrers'; cr]
						ifFalse: [self print: ' is in youngReferrers '; printNum: count; print: ' times!'; cr].
					 ok := false]].
		 (objectRepresentation checkValidObjectReference: cogMethod selector) ifFalse:
				[self print: 'object leak in CM '; printHex: cogMethod asInteger; print: ' selector'; cr.
				 ok := false].
		 cogMethod cmType = CMMethod
				ifTrue:
					[self assert: cogMethod objectHeader = coInterpreter nullHeaderForMachineCodeMethod.
					 (objectRepresentation checkValidObjectReference: cogMethod methodObject) ifFalse:
						[self print: 'object leak in CM '; printHex: cogMethod asInteger; print: ' methodObject'; cr.
						 ok := false].
					 (self mapFor: cogMethod
						 performUntil: #checkIfValidObjectRef:pc:cogMethod: asSymbol
						 arg: cogMethod asInteger) ~= 0
							ifTrue: [ok := false].
					 fullGCFlag ifFalse:
						[(((coInterpreter isYoung: cogMethod methodObject)
						    or: [coInterpreter isYoung: cogMethod selector])
						   and: [cogMethod cmRefersToYoung not]) ifTrue:
							[self print: 'CM '; printHex: cogMethod asInteger; print: ' refers to young but not marked as such'; cr.
							 ok := false]]]
				ifFalse:
					[cogMethod cmType = CMClosedPIC
						ifTrue:
							[(self checkValidObjectReferencesInClosedPIC: cogMethod) ifFalse:
								[ok := false]]
						ifFalse:
							[cogMethod cmType = CMOpenPIC
								ifTrue:
									[(self mapFor: cogMethod
										performUntil: #checkIfValidObjectRef:pc:cogMethod: asSymbol
										arg: cogMethod asInteger) ~= 0
											ifTrue: [ok := false]]]]].
		cogMethod := methodZone methodAfter: cogMethod].
	^ok
]

{ #category : #'method map' }
Cogit >> checkIsRealMapEntry: annotation mcpc: mcpc forMcpc: targetMcpc [
	"For the mapEntry matching targetMcpc answer if its annotation is real or merely
	 a displacement.  Since the enumerator mapFor:performUntil:arg: only invokes
	 its argument with real entries this is simply a check for targetMcpc existing at all."
	^mcpc = targetMcpc
]

{ #category : #'garbage collection' }
Cogit >> checkMaybeObjRefAt: mcpc [
	| maybeObject |
	maybeObject := backEnd literalBeforeFollowingAddress: mcpc.
	(objectRepresentation couldBeObject: maybeObject) ifFalse:
		[^true].
	^objectRepresentation checkValidObjectReference: maybeObject
]

{ #category : #initialization }
Cogit >> checkPrimitiveTableEnablers [
	"Disable primitive generators with enablers that answer false."
	| primitiveDescriptor |
	<var: #primitiveDescriptor type: #'PrimitiveDescriptor *'>
	1 to: MaxCompiledPrimitiveIndex do:
		[:i|
		primitiveDescriptor := self addressOf: (primitiveGeneratorTable at: i).
		primitiveDescriptor enabled notNil ifTrue:
			[(self perform: primitiveDescriptor enabled with: i) ifFalse:
				[primitiveDescriptor primitiveGenerator: nil]]]
]

{ #category : #'garbage collection' }
Cogit >> checkValidObjectReferencesInClosedPIC: cPIC [
	<var: #cPIC type: #'CogMethod *'>
	| ok pc |
	ok := true.
	pc := cPIC asInteger + firstCPICCaseOffset.
	(self checkMaybeObjRefAt: pc - backEnd jumpLongByteSize) ifFalse:
		[self print: 'object leak in CPIC '; printHex: cPIC asInteger;
			print: ' @ '; printHex: pc - backEnd jumpLongByteSize; cr.
		 ok := false].
	pc := pc + cPICCaseSize.
	2 to: cPIC cPICNumCases do:
		[:i|
		(self checkMaybeObjRefAt: pc - backEnd jumpLongConditionalByteSize - backEnd loadLiteralByteSize) ifFalse:
			[self print: 'object leak in CPIC '; printHex: cPIC asInteger;
				print: ' @ '; printHex: pc - backEnd jumpLongConditionalByteSize - backEnd loadLiteralByteSize; cr.
			 ok := false].
		(self checkMaybeObjRefAt: pc - backEnd jumpLongConditionalByteSize) ifFalse:
			[self print: 'object leak in CPIC '; printHex: cPIC asInteger;
				print: ' @ '; printHex: pc - backEnd jumpLongConditionalByteSize; cr.
			 ok := false].
		pc := pc + cPICCaseSize].
	^ok
]

{ #category : #'garbage collection' }
Cogit >> closedPICRefersToUnmarkedObject: cPIC [
	"Answer if the ClosedPIC refers to any unmarked objects or freed/freeable target methods,
	 applying markAndTraceOrFreeCogMethod:firstVisit: to those targets to determine if freed/freeable."
	<var: #cPIC type: #'CogMethod *'>
	| pc offsetToLiteral object entryPoint targetMethod |
	<var: #targetMethod type: #'CogMethod *'>
	(coInterpreter isMarked: cPIC selector)  ifFalse:
		[^true].
	pc := cPIC asInteger + firstCPICCaseOffset.
	"First jump is unconditional; subsequent ones are conditional"
	offsetToLiteral := backEnd jumpLongByteSize.
	1 to: cPIC cPICNumCases do:
		[:i|
		object := backEnd literalBeforeFollowingAddress: pc - offsetToLiteral - backEnd loadLiteralByteSize.
		((objectRepresentation couldBeObject: object)
		 and: [(coInterpreter isMarked: object) not]) ifTrue:
			[^true].
		object := backEnd literalBeforeFollowingAddress: pc - offsetToLiteral.
		((objectRepresentation couldBeObject: object)
		 and: [(coInterpreter isMarked: object) not]) ifTrue:
			[^true].
		entryPoint := backEnd jumpLongTargetBeforeFollowingAddress: pc.
		"Find target from jump.  Ignore jumps to the interpret and MNU calls within this PIC"
		(entryPoint asUnsignedInteger < cPIC asUnsignedInteger
		 or: [entryPoint asUnsignedInteger > (cPIC asUnsignedInteger + cPIC blockSize) asUnsignedInteger]) ifTrue:
			[targetMethod := self cCoerceSimple: entryPoint - cmNoCheckEntryOffset to: #'CogMethod *'.
			 self assert: (targetMethod cmType = CMMethod
						or: [targetMethod cmType = CMFree]).
			 (self markAndTraceOrFreeCogMethod: targetMethod
				  firstVisit: targetMethod asUnsignedInteger > pc asUnsignedInteger) ifTrue:
				[^true]].
		offsetToLiteral := backEnd jumpLongConditionalByteSize.
		pc := pc + cPICCaseSize].
	^false
]

{ #category : #accessing }
Cogit >> coInterpreter [
	<doNotGenerate>
	^coInterpreter
]

{ #category : #debugging }
Cogit >> codeEntryFor: address [
	<api>
	<returnTypeC: #'char *'>
	<var: #address type: #'char *'>
	0 to: trampolineTableIndex - 3 by: 2 do:
		[:i|
		(address between: (trampolineAddresses at: i + 1)
				and: (trampolineAddresses at: i + 3) - 1) ifTrue:
			[^trampolineAddresses at: i + 1]].
	^nil
]

{ #category : #debugging }
Cogit >> codeEntryNameFor: address [
	<api>
	<returnTypeC: #'char *'>
	<var: #address type: #'char *'>
	0 to: trampolineTableIndex - 3 by: 2 do:
		[:i|
		(address between: (trampolineAddresses at: i + 1)
				and: (trampolineAddresses at: i + 3) - 1) ifTrue:
			[^trampolineAddresses at: i]].
	^nil
]

{ #category : #disassembly }
Cogit >> codeRangesFor: cogMethod [
	"Answer a sequence of ranges of code for the main method and all of the blocks in a CogMethod.
	 N.B.  These are in order of block dispatch, _not_ necessarily address order in the method."
	<doNotGenerate>
	| pc end blockEntry starts |
	cogMethod cmType = CMClosedPIC ifTrue:
		[end := (self addressOfEndOfCase: cogMethod cPICNumCases - 1 inCPIC: cogMethod) + cPICEndSize.
		 ^{ CogCodeRange
				from: cogMethod asInteger + (self sizeof: cogMethod)
				to: end }].
	end := (self mapEndFor: cogMethod) - 1.
	cogMethod blockEntryOffset = 0 ifTrue:
		[^{ CogCodeRange
				from: cogMethod asInteger + (self sizeof: cogMethod)
				to: end }].
	pc := blockEntry := cogMethod blockEntryOffset + cogMethod asInteger.
	starts := OrderedCollection with: cogMethod asInteger + (self sizeof: cogMethod).
	[pc < end] whileTrue:
		[(backEnd isJumpAt: pc) ifTrue:
			[| targetpc |
			 targetpc := backEnd jumpTargetAt: pc.
			 targetpc < blockEntry ifTrue:
				[starts add: targetpc]].
		 pc := pc + (backEnd instructionSizeAt: pc)].
	starts add: blockEntry.
	starts := starts asSortedCollection.
	^(1 to: starts size) collect:
		[:i| | startpc nextpc |
		startpc := starts at: i.
		nextpc := starts at: i + 1 ifAbsent: [end].
		CogCodeRange
			from: startpc
			to: nextpc - (nextpc < blockEntry
							ifTrue: [self sizeof: CogBlockMethod]
							ifFalse: [1])]
]

{ #category : #'jit - api' }
Cogit >> cog: aMethodObj selector: aSelectorOop [
	"Attempt to produce a machine code method for the bytecode method
	 object aMethodObj.  N.B. If there is no code memory available do *NOT*
	 attempt to reclaim the method zone.  Certain clients (e.g. ceSICMiss:)
	 depend on the zone remaining constant across method generation."
	<api>
	<returnTypeC: #'CogMethod *'>
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	methodObj := aMethodObj.
	"coInterpreter stringOf: aSelectorOop"
	coInterpreter
		compilationBreak: aSelectorOop + BaseHeaderSize
		point: (coInterpreter lengthOf: aSelectorOop).
	aMethodObj = breakMethod ifTrue: [self halt: 'Compilation of breakMethod'].
	cogMethod := self compileCogMethod: aSelectorOop.
	(cogMethod asInteger between: MaxNegativeErrorCode and: -1) ifTrue:
		[cogMethod asInteger = InsufficientCodeSpace
			ifTrue: [coInterpreter callForCogCompiledCodeCompaction]
			ifFalse: "For now.  Probably better is to keep on interpreting and send some run-time error, e.g. cannotTranslate:"
				[self reportError: (self cCoerceSimple: cogMethod to: #sqInt)].
		 ^nil].
	"self cCode: ''
		inSmalltalk:
			[coInterpreter printCogMethod: cogMethod.
			 self assertValidMethodMap: cogMethod."
			 "self disassembleMethod: cogMethod."
			 "printInstructions := clickConfirm := true""]."
	^cogMethod
]

{ #category : #'simulation only' }
Cogit >> cogBlockMethodSurrogateClass [
	<doNotGenerate>
	^BytesPerWord = 4
		ifTrue: [CogBlockMethodSurrogate32]
		ifFalse: [CogBlockMethodSurrogate64]
]

{ #category : #disassembly }
Cogit >> cogCodeBase [
	<api>
	^codeBase
]

{ #category : #'profiling primitives' }
Cogit >> cogCodeConstituents [
	"Answer the contents of the code zone as an array of pair-wise element, address in ascending address order.
	 Answer a string for a runtime routine or abstract label (beginning, end, etc), a CompiledMethod for a CMMethod,
	 or a selector (presumably a Symbol) for a PIC."
	<api>
	| count cogMethod constituents label value |
	<var: #cogMethod type: #'CogMethod *'>
	count := trampolineTableIndex / 2 + 3. "+ 3 for start, freeStart and end"
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType ~= CMFree ifTrue:
			[count := count + 1].
		cogMethod := methodZone methodAfter: cogMethod].
	constituents := coInterpreter instantiateClass: coInterpreter classArray indexableSize: count * 2.
	constituents isNil ifTrue:
		[^constituents].
	coInterpreter pushRemappableOop: constituents.
	((label := coInterpreter stringForCString: 'CogCode') isNil
	 or: [(value := coInterpreter cePositive32BitIntegerFor: codeBase) isNil]) ifTrue:
		[^nil].
	coInterpreter
		storePointerUnchecked: 0 ofObject: coInterpreter topRemappableOop withValue: label;
		storePointerUnchecked: 1 ofObject: coInterpreter topRemappableOop withValue: value.
	0 to: trampolineTableIndex - 1 by: 2 do:
		[:i|
		((label := coInterpreter stringForCString: (trampolineAddresses at: i)) isNil
		 or: [(value := coInterpreter cePositive32BitIntegerFor: (trampolineAddresses at: i + 1) asUnsignedInteger) isNil]) ifTrue:
			[coInterpreter popRemappableOop.
			 ^nil].
		coInterpreter
			storePointerUnchecked: 2 + i ofObject: coInterpreter topRemappableOop withValue: label;
			storePointerUnchecked: 3 + i ofObject: coInterpreter topRemappableOop withValue: value].
	count := trampolineTableIndex + 2.
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType ~= CMFree ifTrue:
			[coInterpreter
				storePointerUnchecked: count
				ofObject: coInterpreter topRemappableOop
				withValue: (cogMethod cmType = CMMethod
								ifTrue: [cogMethod methodObject]
								ifFalse: [cogMethod selector]).
			 (value := coInterpreter cePositive32BitIntegerFor: cogMethod asUnsignedInteger) isNil ifTrue:
				[coInterpreter popRemappableOop.
				 ^nil].
			 coInterpreter
				storePointerUnchecked: count + 1
				ofObject: coInterpreter topRemappableOop
				withValue: value.
			 count := count + 2].
		cogMethod := methodZone methodAfter: cogMethod].
	((label := coInterpreter stringForCString: 'CCFree') isNil
	 or: [(value := coInterpreter cePositive32BitIntegerFor: methodZone zoneLimit) isNil]) ifTrue:
		[coInterpreter popRemappableOop.
		 ^nil].
	coInterpreter
		storePointerUnchecked: count ofObject: coInterpreter topRemappableOop withValue: label;
		storePointerUnchecked: count + 1 ofObject: coInterpreter topRemappableOop withValue: value.
	((label := coInterpreter stringForCString: 'CCEnd') isNil
	 or: [(value := coInterpreter cePositive32BitIntegerFor: methodZone zoneEnd) isNil]) ifTrue:
		[coInterpreter popRemappableOop.
		 ^nil].
	coInterpreter
		storePointerUnchecked: count + 2 ofObject: coInterpreter topRemappableOop withValue: label;
		storePointerUnchecked: count + 3 ofObject: coInterpreter topRemappableOop withValue: value.
	constituents := coInterpreter popRemappableOop.
	coInterpreter beRootIfOld: constituents.
	^constituents
]

{ #category : #'in-line cacheing' }
Cogit >> cogExtendPIC: cPIC CaseNMethod: caseNMethodOrNil tag: caseNTag [
 	<var: #cPIC type: #'CogMethod *'>
	| operand target address size end |
	"stack allocate the various collections so that they
	 are effectively garbage collected on return."
	coInterpreter
		compilationBreak: cPIC selector + BaseHeaderSize
		point: (coInterpreter lengthOf: cPIC selector).
	self allocateOpcodes: 5 bytecodes: 0.
	self assert: (objectRepresentation inlineCacheTagIsYoung: caseNTag) not.
	(caseNMethodOrNil ~= nil
	 and: [coInterpreter methodHasCogMethod: caseNMethodOrNil])
		ifTrue:
			[operand := 0.
			 target :=  (coInterpreter cogMethodOf: caseNMethodOrNil) asInteger + cmNoCheckEntryOffset]
		ifFalse:
			["Caller patches to open pic if caseNMethodOrNil is young."
			 self assert: (caseNMethodOrNil isNil or: [(coInterpreter isYoung: caseNMethodOrNil) not]).
			 operand := caseNMethodOrNil.
			 target := cPIC asInteger
					+ (caseNMethodOrNil isNil
						ifTrue: [self sizeof: CogMethod]
						ifFalse: [self interpretOffset - backEnd callInstructionByteSize])].
	self CmpCw: caseNTag R: TempReg.
	self MoveCw: operand R: SendNumArgsReg.
	self JumpLongZero: (self cCoerceSimple: target to: #'void *').
	self MoveCw: cPIC asInteger R: ClassReg.
	self JumpLong: (self cCoerceSimple: ceCPICMissTrampoline to: #'void *').

	self computeMaximumSizes.
	address := self addressOfEndOfCase: cPIC cPICNumCases - 1 inCPIC: cPIC.
	size := self generateInstructionsAt: address.
	end := self outputInstructionsAt: address.
	processor flushICacheFrom: address to: cPIC asInteger + closedPICSize.
	cPIC cPICNumCases: cPIC cPICNumCases + 1.
	^0
]

{ #category : #'method map' }
Cogit >> cogHomeMethod: aCogMethod [
	<api>
	"Arg type can be #'CogBlockMethod *' but slightly more convenient as #'CogMethod *'"
	<var: #aCogMethod type: #'CogBlockMethod *'>
	<returnTypeC: #'CogMethod *'>
	self assert: aCogMethod cmType = CMBlock.
	^self cCoerceSimple: aCogMethod objectHeader to: #'CogMethod *'
]

{ #category : #debugging }
Cogit >> cogMethodDoesntLookKosher: cogMethod [
	"Check that the header fields onf a non-free method are consistent with
	 the type. Answer 0 if it is ok, otherwise answer a code for the error."
	<var: #cogMethod type: #'CogMethod *'>
	((cogMethod blockSize bitAnd: BytesPerWord - 1) ~= 0
	 or: [cogMethod blockSize < (self sizeof: CogMethod)
	 or: [cogMethod blockSize >= 32768]]) ifTrue:
		[^1].

	cogMethod cmType = CMFree ifTrue: [^2].

	cogMethod cmType = CMMethod ifTrue:
		[(coInterpreter isIntegerObject: cogMethod methodHeader) ifFalse:
			[^11].
		 (objectRepresentation couldBeObject: cogMethod methodObject) ifFalse:
			[^12].
		 (cogMethod stackCheckOffset > 0
		 and: [cogMethod stackCheckOffset < cmNoCheckEntryOffset]) ifTrue:
			[^13].
		 ^0].

	cogMethod cmType = CMOpenPIC ifTrue:
		[cogMethod blockSize ~= openPICSize ifTrue:
			[^21].
		 cogMethod methodHeader ~= 0 ifTrue:
			[^22].
		
		 "Check the nextOpenPIC link unless we're compacting"
		 cogMethod objectHeader signedIntFromLong >= 0 ifTrue:
			[(cogMethod methodObject ~= 0
			 and: [cogMethod methodObject < methodZoneBase
				   or: [cogMethod methodObject > (methodZone zoneLimit - openPICSize)
				   or: [(cogMethod methodObject bitAnd: BytesPerWord - 1) ~= 0
				   or: [(self cCoerceSimple: cogMethod methodObject
							to: #'CogMethod *') cmType ~= CMOpenPIC]]]]) ifTrue:
				[^23]].
		 cogMethod stackCheckOffset ~= 0 ifTrue:
			[^24].
		 ^0].

	cogMethod cmType = CMClosedPIC ifTrue:
		[cogMethod blockSize ~= closedPICSize ifTrue:
			[^31].
		 (cogMethod cPICNumCases between: 1 and: numPICCases) ifFalse:
			[^32].
		 cogMethod methodHeader ~= 0 ifTrue:
			[^33].
		 cogMethod methodObject ~= 0 ifTrue:
			[^34].
		 ^0].

	^9
]

{ #category : #'simulation only' }
Cogit >> cogMethodSurrogateClass [
	<doNotGenerate>
	^BytesPerWord = 4
		ifTrue: [CogMethodSurrogate32]
		ifFalse: [CogMethodSurrogate64]
]

{ #category : #'in-line cacheing' }
Cogit >> cogOpenPICSelector: selector numArgs: numArgs [
	"Create an Open PIC.  Temporarily create a direct call of ceSendFromOpenPIC:.
	 Should become a probe of the first-level method lookup cache followed by a
	 call of ceSendFromOpenPIC: if the probe fails."
	<returnTypeC: #'CogMethod *'>
	| startAddress headerSize codeSize mapSize end |
	coInterpreter
		compilationBreak: selector + BaseHeaderSize
		point: (coInterpreter lengthOf: selector).
	startAddress := methodZone allocate: openPICSize.
	startAddress = 0 ifTrue:
		[^self cCoerceSimple: InsufficientCodeSpace to: #'CogMethod *'].
	methodLabel
		address: startAddress;
		dependent: nil.
	"stack allocate the various collections so that they
	 are effectively garbage collected on return."
	self allocateOpcodes: 100 bytecodes: 0.
	self compileOpenPIC: selector.
	self computeMaximumSizes.
	methodLabel concretizeAt: startAddress.
	headerSize := self sizeof: CogMethod.
	codeSize := self generateInstructionsAt: startAddress + headerSize.
	mapSize := self generateMapAt: startAddress + openPICSize - 1 start: startAddress + cmNoCheckEntryOffset.
	self assert: entry address - startAddress = cmEntryOffset.
	self assert: headerSize + codeSize + mapSize <= openPICSize.
	end := self outputInstructionsAt: startAddress + headerSize.
	^self
		fillInOPICHeader: (self cCoerceSimple: startAddress to: #'CogMethod *')
		size: openPICSize
		numArgs: numArgs
		selector: selector 
]

{ #category : #'in-line cacheing' }
Cogit >> cogPICSelector: selector numArgs: numArgs Case0Method: case0CogMethod Case1Method: case1MethodOrNil tag: case1Tag [
	"Attempt to create a two-case PIC for case0CogMethod and  case1MethodOrNil,case1Tag.
	 The tag for case0CogMethod is at the send site and so doesn't need to be generated.
	 case1MethodOrNil may be any of
		- a Cog method; link to its unchecked entry-point
		- a CompiledMethod; link to ceInterpretMethodFromPIC:
		- nil; link to ceMNUFromPICMNUMethod:receiver:"
	<var: #case0CogMethod type: #'CogMethod *'>
	<returnTypeC: #'CogMethod *'>
	| startAddress headerSize size end |
	coInterpreter
		compilationBreak: selector + BaseHeaderSize
		point: (coInterpreter lengthOf: selector).
	startAddress := methodZone allocate: closedPICSize.
	startAddress = 0 ifTrue:
		[^self cCoerceSimple: InsufficientCodeSpace to: #'CogMethod *'].
	methodLabel
		address: startAddress;
		dependent: nil.
	"stack allocate the various collections so that they
	 are effectively garbage collected on return."
	self allocateOpcodes: numPICCases * 7 bytecodes: 0.
	self compileCPIC: (self cCoerceSimple: startAddress to: #'CogMethod *')
		Case0: case0CogMethod
		Case1Method: case1MethodOrNil
		tag: case1Tag.
	self computeMaximumSizes.
	headerSize := self sizeof: CogMethod.
	size := self generateInstructionsAt: startAddress + headerSize.
	end := self outputInstructionsAt: startAddress + headerSize.
	"The missOffset is th same as the interpretOffset."
	self assert: missOffset = (interpretCall address + interpretCall machineCodeSize - startAddress).
	self assert: startAddress + cmEntryOffset = entry address.
	self assert: endCPICCase0 address = (startAddress + firstCPICCaseOffset).
	self assert: endCPICCase1 address = (startAddress + firstCPICCaseOffset + cPICCaseSize).
	^self
		fillInCPICHeader: (self cCoerceSimple: startAddress to: #'CogMethod *')
		size: closedPICSize
		numArgs: numArgs
		numCases: 2
		selector: selector 
]

{ #category : #'jit - api' }
Cogit >> cogitPostGCAction [
	<api>
	"Post-GC update every full method's objectHeader to whatever it needs to be"
	self assert: self allMethodsHaveCorrectHeader.
	self assert: methodZone kosherYoungReferrers
]

{ #category : #disassembly }
Cogit >> collectMapEntry: annotation address: mcpc into: aDictionary [
	<doNotGenerate>
	aDictionary at: mcpc put: (self class annotationConstantNames at: annotation + 1).
	^0
]

{ #category : #'jit - api' }
Cogit >> compactCogCompiledCode [
	<api>
	self assert: self noCogMethodsMaximallyMarked.
	coInterpreter markActiveMethodsAndReferents.
	methodZone freeOlderMethodsForCompaction.
	self freePICsWithFreedTargets.
	methodZone planCompaction.
	coInterpreter updateStackZoneReferencesToCompiledCodePreCompaction.
	self relocateMethodsPreCompaction.
	methodZone compactCompiledCode: coInterpreter nullHeaderForMachineCodeMethod.
	self assert: methodZone kosherYoungReferrers.
	processor flushICacheFrom: methodZoneBase to: methodZone zoneLimit
]

{ #category : #'compile abstract instructions' }
Cogit >> compileAbstractInstructions [
	"Compile the abstract instructions for a method."
	| result |
	self compileProlog.
	self compileEntry.
	(primitiveIndex > 0
	 and: [(result := self compilePrimitive) < 0]) ifTrue:
		[^result].
	needsFrame ifTrue:
		[self compileFrameBuild].
	^self compileMethodBody
]

{ #category : #'compile abstract instructions' }
Cogit >> compileAbstractInstructionsFrom: start through: end [
	"Loop over bytecodes, dispatching to the generator for each bytecode, handling fixups in due course."
	| nextOpcodeIndex descriptor fixup result |
	<var: #descriptor type: #'BytecodeDescriptor *'>
	<var: #fixup type: #'BytecodeFixup *'>
	bytecodePointer := start.
	[byte0 := coInterpreter fetchByte: bytecodePointer ofObject: methodObj.
	 descriptor := self generatorAt: byte0.
	 descriptor numBytes > 1 ifTrue:
		[byte1 := coInterpreter fetchByte: bytecodePointer + 1 ofObject: methodObj.
		 descriptor numBytes > 2 ifTrue:
			[byte2 := coInterpreter fetchByte: bytecodePointer + 2 ofObject: methodObj.
			 descriptor numBytes > 3 ifTrue:
				[byte3 := coInterpreter fetchByte: bytecodePointer + 3 ofObject: methodObj.
				 descriptor numBytes > 4 ifTrue:
					[self notYetImplemented]]]].
	 nextOpcodeIndex := opcodeIndex.
	 result := self perform: descriptor generator.
	 fixup := self fixupAt: bytecodePointer - initialPC.
	 fixup targetInstruction notNil ifTrue:
		["There is a fixup for this bytecode.  It must point to the first generated
		   instruction for this bytecode.  If there isn't one we need to add a label."
		 opcodeIndex = nextOpcodeIndex ifTrue:
			[self Label].
		 fixup targetInstruction: (self abstractInstructionAt: nextOpcodeIndex)].
	 bytecodePointer := self nextBytecodePCFor: descriptor at: bytecodePointer byte0: byte0 in: methodObj.
	 result = 0 and: [bytecodePointer <= end]] whileTrue.
	^result
]

{ #category : #'compile abstract instructions' }
Cogit >> compileBlockDispatchFrom: lowBlockStartIndex to: highBlockStartIndex [
	<var: #blockStart type: #'BlockStart *'>
	<var: #jmp type: #'AbstractInstruction *'>
	| blockStart halfWay jmp |
	lowBlockStartIndex = highBlockStartIndex ifTrue:
		[blockStart := self blockStartAt: lowBlockStartIndex.
		 self Jump: blockStart entryLabel.
		^nil].
	halfWay := highBlockStartIndex + lowBlockStartIndex // 2.
	self assert: (halfWay between: lowBlockStartIndex and: highBlockStartIndex).
	blockStart := self blockStartAt: halfWay.
	"N.B. FLAGS := TempReg - startpc"
	self CmpCq: (coInterpreter integerObjectOf: blockStart startpc + 1) R: TempReg.
	lowBlockStartIndex = halfWay ifTrue:
		[self JumpLessOrEqual: blockStart entryLabel.
		 self compileBlockDispatchFrom: halfWay + 1 to: highBlockStartIndex.
		 ^nil].
	halfWay + 1 = highBlockStartIndex ifTrue:
		[blockStart := self blockStartAt: highBlockStartIndex.
		 self JumpGreater: blockStart entryLabel.
		 ^self compileBlockDispatchFrom: lowBlockStartIndex to: halfWay].
	jmp := self JumpGreater: 0.
	self compileBlockDispatchFrom: lowBlockStartIndex to: halfWay.
	halfWay = highBlockStartIndex
		ifTrue:
			[blockStart := self blockStartAt: highBlockStartIndex.
			 jmp jmpTarget: blockStart entryLabel]
		ifFalse:
			[jmp jmpTarget: self Label.
			 self compileBlockDispatchFrom: halfWay + 1 to: highBlockStartIndex]
]

{ #category : #'compile abstract instructions' }
Cogit >> compileBlockEntry: blockStart [
	"Compile a block's entry.  This looks like a dummy CogBlockMethod header (for frame parsing)
	 followed by either a frame build, if a frame is required, or nothing.  The CogMethodHeader's
	 objectHeader field is a back pointer to the method, but this can't be filled in until code generation."
	<var: #blockStart type: #'BlockStart *'>
	self scanBlock: blockStart.
	self AlignmentNops: (self sizeof: CogBlockMethod).
	blockStart fakeHeader: self Label.
	self assert: (self sizeof: CogBlockMethod) = (2 * BytesPerWord).
	methodLabel addDependent: (self FillFrom: methodLabel asInteger Word: 0).
	blockStart fillInstruction: (self FillFrom: 0 Word: 0). "Will get filled-in later"
	blockStart entryLabel: self Label.
	needsFrame
		ifTrue:
			[self compileBlockFrameBuild: blockStart.
			 self recordSendTrace ifTrue:
				[self CallRT: ceTraceBlockActivationTrampoline]]
		ifFalse:
			[self compileBlockFramelessEntry: blockStart]
]

{ #category : #'compile abstract instructions' }
Cogit >> compileBlockFrameBuild: blockStart [
	self subclassResponsibility
]

{ #category : #'compile abstract instructions' }
Cogit >> compileBlockFramelessEntry: blockStart [
	self subclassResponsibility
]

{ #category : #'in-line cacheing' }
Cogit >> compileCPIC: cPIC Case0: case0CogMethod Case1Method: case1MethodOrNil tag: case1Tag [
	"Compile the code for a two-case PIC for case0CogMethod and  case1MethodOrNil,case1Tag.
	 The tag for case0CogMethod is at the send site and so doesn't need to be generated.
	 case1MethodOrNil may be any of
		- a Cog method; jump to its unchecked entry-point
		- a CompiledMethod; jump to the ceInterpretFromPIC trampoline
		- nil; call ceMNUFromPIC"
	<var: #cPIC type: #'CogMethod *'>
	| operand targetEntry jumpNext |
	<var: #case0CogMethod type: #'CogMethod *'>
	<var: #targetEntry type: #'void *'>
	<var: #jumpNext type: #'AbstractInstruction *'>
	self compilePICProlog.
	self assert: (objectRepresentation inlineCacheTagIsYoung: case1Tag) not.
	(case1MethodOrNil ~= nil
	 and: [coInterpreter methodHasCogMethod: case1MethodOrNil])
		ifTrue:
			[operand := 0.
			 targetEntry := self cCoerceSimple: (coInterpreter cogMethodOf: case1MethodOrNil) asInteger + cmNoCheckEntryOffset
								to: #'void *']
		ifFalse:
			[self assert: (case1MethodOrNil isNil or: [(coInterpreter isYoung: case1MethodOrNil) not]).
			 operand := case1MethodOrNil.
			 targetEntry := case1MethodOrNil isNil ifTrue: [mnuCall] ifFalse: [interpretCall]].

	jumpNext := self compileCPICEntry.
	self MoveCw: 0 R: SendNumArgsReg.
	self JumpLong: (self cCoerceSimple: case0CogMethod asInteger + cmNoCheckEntryOffset
						to: #'void *').
	endCPICCase0 := self CmpCw: case1Tag R: TempReg.
	jumpNext jmpTarget: endCPICCase0.
	self MoveCw: operand R: SendNumArgsReg.
	self JumpLongZero: targetEntry.
	endCPICCase1 := self MoveCw: cPIC asInteger R: ClassReg.
	self JumpLong: (self cCoerceSimple: ceCPICMissTrampoline to: #'void *').
	^0

]

{ #category : #'in-line cacheing' }
Cogit >> compileCPICEntry [
	<returnTypeC: #'AbstractInstruction *'>
	"Compile the cache tag computation and the first comparison.  Answer the address of that comparison."
	self AlignmentNops: (BytesPerWord max: 8).
	entry := self Label.
	objectRepresentation getInlineCacheClassTagFrom: ReceiverResultReg into: TempReg.
	self CmpR: ClassReg R: TempReg.
	^self JumpNonZero: 0
]

{ #category : #'in-line cacheing' }
Cogit >> compileClosedPICPrototype [
	"Compile the abstract instructions for a full closed PIC used to initialize closedPICSize"
	| jumpNext |
	<var: #jumpNext type: #'AbstractInstruction *'>
	self compilePICProlog.
	jumpNext := self compileCPICEntry.
	self MoveCw: 16r5EAF00D R: ClassReg.
	self JumpLong: (self cCoerceSimple: 16r5EEDCA5E to: #'void *').
	jumpNext jmpTarget: (endCPICCase0 := self Label).
	1 to: numPICCases - 1 do:
		[:h|
		self CmpCw: 16rBABE1F15+h R: TempReg.
		self MoveCw: 16rBADA550 + h R: ClassReg.
		self JumpLongZero: (self cCoerceSimple: 16rBEDCA5E0 + h to: #'void *').
		h = 1 ifTrue:
			[endCPICCase1 := self Label]].
	self MoveCw: 16rAB5CE55 R: ClassReg.
	self JumpLong: (self cCoerceSimple: ceCPICMissTrampoline to: #'void *').
	^0
]

{ #category : #'compile abstract instructions' }
Cogit >> compileCogMethod: selector [
	<returnTypeC: #'CogMethod *'>
	| numBytecodes numBlocks result extra |
	hasYoungReferent := (coInterpreter isYoung: methodObj)
						  or: [coInterpreter isYoung: selector].
	methodOrBlockNumArgs := coInterpreter argumentCountOf: methodObj.
	inBlock := false.
	primInvokeLabel := nil.
	postCompileHook := nil.
	extra := ((primitiveIndex := coInterpreter primitiveIndexOf: methodObj) > 0
			and: [(coInterpreter isQuickPrimitiveIndex: primitiveIndex) not])
				ifTrue: [30]
				ifFalse: [10].
	initialPC := coInterpreter startPCOfMethod: methodObj.
	"initial estimate.  Actual endPC is determined in scanMethod."
	endPC := (coInterpreter isQuickPrimitiveIndex: primitiveIndex)
					ifTrue: [initialPC - 1]
					ifFalse: [coInterpreter byteSizeOf: methodObj].
	numBytecodes := endPC - initialPC + 1.
	self allocateOpcodes: (numBytecodes + extra) * 10 bytecodes: numBytecodes.
	(numBlocks := self scanMethod) < 0 ifTrue:
		[^coInterpreter cCoerceSimple: numBlocks to: #'CogMethod *'].
	self allocateBlockStarts: numBlocks.
	blockEntryLabel := nil.
	methodLabel dependent: nil.
	(result := self compileAbstractInstructions) < 0 ifTrue:
		[^coInterpreter cCoerceSimple: result to: #'CogMethod *'].
	^self generateCogMethod: selector
]

{ #category : #'compile abstract instructions' }
Cogit >> compileEntry [
	self AlignmentNops: (BytesPerWord max: 8).
	entry := self Label.
	objectRepresentation getInlineCacheClassTagFrom: ReceiverResultReg into: TempReg.
	self CmpR: ClassReg R: TempReg.
	self JumpNonZero: sendMissCall.
	noCheckEntry := self Label.
	self recordSendTrace ifTrue:
		[self CallRT: ceTraceLinkedSendTrampoline]
]

{ #category : #'compile abstract instructions' }
Cogit >> compileFrameBuild [
	self subclassResponsibility
]

{ #category : #'in-line cacheing' }
Cogit >> compileOpenPIC: selector [
	"Compile the code for an open PIC.  Perform a probe of the first-level method
	 lookup cache followed by a call of ceSendFromOpenPIC: if the probe fails.
	 Since open PICs replicate the CoInterpreter's first-level method cache lookup
	 this is a subclass responsibility."
	self subclassResponsibility
]

{ #category : #'in-line cacheing' }
Cogit >> compilePICProlog [
	"The start of a PIC has a call to a run-time abort routine that either handles
	 a dispatch to an interpreted method or a dispatch of an MNU case.  The
	 routine selects the path depending on ClassReg; if zero it takes the MNU
	 path; if nonzero the dispatch to interpreter path.  Neither of these paths
	 returns. The abort routine must be called;  In the callee the PIC is located
	 by adding the relevant offset to the return address of the call."
	mnuCall := self MoveCq: 0 R: ClassReg.
	interpretCall := self Call: cePICAbortTrampoline.
	^0
]

{ #category : #'compile abstract instructions' }
Cogit >> compilePrimitive [
	"Compile a primitive.  If possible, performance-critical primtiives will
	 be generated by their own routines (primitiveGenerator).  Otherwise,
	 if there is a primitive at all, we call the C routine with the usual
	 stack-switching dance, test the primFailCode and then either return
	 on success or continue to the method body."
	<inline: false>
	| primitiveDescriptor primitiveRoutine |
	<var: #primitiveDescriptor type: #'PrimitiveDescriptor *'>
	<var: #primitiveRoutine declareC: 'void (*primitiveRoutine)(void)'>
	((primitiveDescriptor := self primitiveGeneratorOrNil) notNil
	 and: [primitiveDescriptor primitiveGenerator notNil]) ifTrue:
		["If a descriptor specifies an argument count (by numArgs >= 0)
		  then it must match for the generated code to be correct.  For
		  example for speed many primitives use ResultReceiverReg
		  instead of accessing the stack, so the receiver better be at
		  numArgs down the stack.  Use the interpreter version if not."
		 (primitiveDescriptor primNumArgs < 0 "means don't care"
		  or: [primitiveDescriptor primNumArgs = (coInterpreter argumentCountOf: methodObj)]) ifTrue:
			[^self perform: primitiveDescriptor primitiveGenerator]].
	((primitiveRoutine := coInterpreter
							functionPointerForCompiledMethod: methodObj
							primitiveIndex: primitiveIndex) isNil "no primitive"
	or: [primitiveRoutine = (coInterpreter functionPointerFor: 0 inClass: nil) "routine = primitiveFail"]) ifTrue:
		[^self genFastPrimFail].
	^self compileInterpreterPrimitive: primitiveRoutine
]

{ #category : #'compile abstract instructions' }
Cogit >> compileProlog [
	"The start of a CogMethod has a call to a run-time abort routine that either
	 handles an in-line cache failure or a stack overflow.  The routine selects the
	 path depending on ReceiverResultReg; if zero it takes the stack overflow
	 path; if nonzero the in-line cache miss path.  Neither of these paths returns.
	 The abort routine must be called;  In the callee the method is located by
	 adding the relevant offset to the return address of the call."
	stackOverflowCall := self MoveCq: 0 R: ReceiverResultReg.
	sendMissCall := self Call: ceMethodAbortTrampoline
]

{ #category : #initialization }
Cogit >> compileTrampolineFor: aRoutine callJumpBar: callJumpBar "<Boolean>" numArgs: numArgs arg: regOrConst0 arg: regOrConst1 arg: regOrConst2 arg: regOrConst3 saveRegs: saveRegs resultReg: resultRegOrNil [
	"Generate a trampoline with up to four arguments.  Generate either a call or a jump to aRoutine
	 as requested by callJumpBar.  If generating a call and resultRegOrNil is non-zero pass the C result
	 back in resultRegOrNil.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<inline: false>
	self genSaveStackPointers.
	self genLoadCStackPointers.
	cStackAlignment > BytesPerWord ifTrue:
		[backEnd
			genAlignCStackSavingRegisters: saveRegs
			numArgs: numArgs
			wordAlignment: cStackAlignment / BytesPerWord].
	saveRegs ifTrue:
		[callJumpBar ifFalse:
			[self error: 'why save registers when you''re not going to return?'].
		 backEnd genSaveRegisters].
	numArgs > 0 ifTrue:
		[numArgs > 1 ifTrue:
			[numArgs > 2 ifTrue:
				[numArgs > 3 ifTrue:
					[regOrConst3 < 0
						ifTrue: [backEnd genPassReg: regOrConst3 asArgument: 3]
						ifFalse: [backEnd genPassConst: regOrConst3 asArgument: 3]].
				 regOrConst2 < 0
					ifTrue: [backEnd genPassReg: regOrConst2 asArgument: 2]
					ifFalse: [backEnd genPassConst: regOrConst2 asArgument: 2]].
			regOrConst1 < 0
				ifTrue: [backEnd genPassReg: regOrConst1 asArgument: 1]
				ifFalse: [backEnd genPassConst: regOrConst1 asArgument: 1]].
		regOrConst0 < 0
			ifTrue: [backEnd genPassReg: regOrConst0 asArgument: 0]
			ifFalse: [backEnd genPassConst: regOrConst0 asArgument: 0]].
	self gen: (callJumpBar ifTrue: [Call] ifFalse: [Jump])
		operand: (self cCode: [aRoutine asUnsignedInteger]
					   inSmalltalk: [self uniqueAddressForTrampoline: aRoutine]).
	callJumpBar ifTrue:
		[resultRegOrNil ifNotNil:
			[backEnd genWriteCResultIntoReg: resultRegOrNil].
		 saveRegs ifTrue:
			[numArgs > 0 ifTrue:
				[backEnd genRemoveNArgsFromStack: numArgs].
			resultRegOrNil
				ifNotNil: [backEnd genRestoreRegsExcept: resultRegOrNil]
				ifNil: [backEnd genRestoreRegs]].
		self genLoadStackPointers.
		self RetN: 0]
]

{ #category : #initialization }
Cogit >> computeEntryOffsets [
	"Generate the entry code for a method to determine cmEntryOffset and cmNoCheckEntryOffset.  We
	 need cmNoCheckEntryOffset up front to be able to generate the map starting from cmNoCheckEntryOffset"
	"stack allocate the various collections so that they
	 are effectively garbage collected on return."
	self allocateOpcodes: 20 bytecodes: 0.
	self compileProlog.
	self compileEntry.
	self computeMaximumSizes.
	self generateInstructionsAt: methodZoneBase + (self sizeof: CogMethod).
	cmEntryOffset := entry address - methodZoneBase.
	cmNoCheckEntryOffset := noCheckEntry address - methodZoneBase.
	missOffset := sendMissCall address + sendMissCall machineCodeSize - methodZoneBase.
	entryPointMask := 1.
	[(cmEntryOffset bitAnd: entryPointMask) = (cmNoCheckEntryOffset bitAnd: entryPointMask)] whileTrue:
		[entryPointMask := entryPointMask + entryPointMask + 1].
	entryPointMask >= (methodZone roundUpLength: 1) ifTrue:
		[self error: 'cannot differentiate checked and unchecked entry-points with current cog method alignment'].
	checkedEntryAlignment := cmEntryOffset bitAnd: entryPointMask.
	self assert: checkedEntryAlignment ~= (cmNoCheckEntryOffset bitAnd: entryPointMask)
]

{ #category : #'generate machine code' }
Cogit >> computeMaximumSizes [
	"This pass assigns maximum sizes to all abstract instructions and eliminates jump fixups.
	 It hence assigns the maximum address an instruction will occur at which allows the next
	 pass to conservatively size jumps."
	<inline: false>
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	| relativeAddress |
	relativeAddress := 0.
	0 to: opcodeIndex - 1 do:
		[:i| | abstractInstruction |
		abstractInstruction := self abstractInstructionAt: i.
		abstractInstruction address: relativeAddress.
		abstractInstruction computeMaximumSize.
		relativeAddress := relativeAddress + abstractInstruction maxSize].

]

{ #category : #printing }
Cogit >> cr [
	<cmacro: '() putchar(''\n'')'>
	coInterpreter transcript cr; flush
]

{ #category : #disassembly }
Cogit >> disassemble: targetmcpc from: startpc to: endpc arg: tupleOfStreamAndMcpcToBcpcMap [
	<doNotGenerate>
	[:aStream :mcpcToBcpcMap|
	 self disassembleFrom: startpc to: endpc - 1 labels: Dictionary new on: aStream.
	 aStream nextPutAll: 'block startpc: '; print: (mcpcToBcpcMap at: targetmcpc); cr; flush]
		valueWithArguments: tupleOfStreamAndMcpcToBcpcMap.
	^0
]

{ #category : #disassembly }
Cogit >> disassembleFrom: startAddress to: endAddress [
	<doNotGenerate>
	| labels |
	labels := Dictionary new.
	0 to: trampolineTableIndex - 1 by: 2 do:
		[:i| labels at: (trampolineAddresses at: i + 1) put: (trampolineAddresses at: i)].
	self disassembleFrom: startAddress to: endAddress labels: labels on: coInterpreter transcript
]

{ #category : #disassembly }
Cogit >> disassembleFrom: startAddress to: endAddress labels: labelDictionary on: aStream [
	<doNotGenerate>
	processor disassembleFrom: startAddress to: endAddress in: coInterpreter memory for: self labels: labelDictionary on: aStream.
	aStream flush
]

{ #category : #disassembly }
Cogit >> disassembleMethod: surrogateOrAddress [
	<doNotGenerate>
	self disassembleMethod: surrogateOrAddress on: coInterpreter transcript
]

{ #category : #disassembly }
Cogit >> disassembleMethod: surrogateOrAddress on: aStream [
	<doNotGenerate>
	| cogMethod mapEntries codeRanges mcpcToBcpcMap |
	cogMethod := surrogateOrAddress isInteger
								ifTrue: [coInterpreter cogMethodSurrogateAt: surrogateOrAddress]
								ifFalse: [surrogateOrAddress].
	cogMethod cmType = CMBlock ifTrue:
		[^self disassembleMethod: (self cogHomeMethod: cogMethod) on: aStream].
	self printMethodHeader: cogMethod on: aStream.

	(mapEntries := Dictionary new)
		at: cogMethod asInteger + cmEntryOffset put: 'entry'.
	
	cogMethod cmType = CMMethod ifTrue:
		[mapEntries at: cogMethod asInteger + cmNoCheckEntryOffset put: 'noCheckEntry'].

	self mapFor: cogMethod
		performUntil: #collectMapEntry:address:into: asSymbol
		arg: mapEntries.

	"This would all be far more elegant and simple if we used blocks.
	 But there are no blocks in C and the basic enumerators here need
	 to be used in the real VM.  Apologies."
	mcpcToBcpcMap := self mcpcToBcpcMapFor: cogMethod.
	(codeRanges := self codeRangesFor: cogMethod) do:
		[:range|
		range startpc: (mcpcToBcpcMap at: range first ifAbsent: [nil]).
		(cogMethod blockEntryOffset ~= 0
		 and: [range first = (cogMethod blockEntryOffset + cogMethod asInteger)])
			ifTrue:
				[aStream nextPutAll: 'blockEntry:'; cr.
				 self blockDispatchFor: cogMethod
					perform: #disassemble:from:to:arg:
					arg: { aStream. mcpcToBcpcMap }]
			ifFalse:
				[range first > (cogMethod address + cmNoCheckEntryOffset) ifTrue:
					[self printMethodHeader: (self cCoerceSimple: range first - (self sizeof: CogBlockMethod)
												to: #'CogBlockMethod *')
						on: aStream].
				self disassembleFrom: range first to: range last labels: mapEntries on: aStream]].
	aStream nextPutAll: 'startpc: '; print: codeRanges first startpc; cr.
	(cogMethod cmType = CMMethod
	 or: [cogMethod cmType = CMOpenPIC]) ifTrue:
		[[self mapFor: cogMethod
			performUntil: #printMapEntry:mcpc:args:
			arg: { aStream. codeRanges. cogMethod }]
			on: AssertionFailure
			do: [:ex|
				ex primitiveChangeClassTo: MyResumableTestError basicNew. ":) :) :)"
				ex resume: nil]]
]

{ #category : #disassembly }
Cogit >> disassembleMethodFor: pc [
	<doNotGenerate>
	| method |
	method := methodZone methodFor: pc.
	(method isNil or: [method isZero]) ifTrue:
		[self error: 'not a method'].
	self disassembleMethod: method
]

{ #category : #'trampoline support' }
Cogit >> enilopmartCFPAddress [
	<cmacro: '() ((unsigned long)&EnilopmartCFP)'>
	^coInterpreter inMemoryEnilopmartCFPAddress
]

{ #category : #'trampoline support' }
Cogit >> enilopmartCSPAddress [
	<cmacro: '() ((unsigned long)&EnilopmartCSP)'>
	^coInterpreter inMemoryEnilopmartCSPAddress
]

{ #category : #'compile abstract instructions' }
Cogit >> ensureFixupAt: targetIndex [
	"Make sure there's a flagged fixup at the targetIndex (pc relative to first pc) in fixups.
	 Initially a fixup's target is just a flag.  Later on it is replaced with a proper instruction."
	<returnTypeC: #'BytecodeFixup *'>
	| fixup |
	<var: #fixup type: #'BytecodeFixup *'>
	fixup := self fixupAt: targetIndex.
	self assert: fixup notNil.
	fixup targetInstruction = 0 ifTrue:
		[fixup targetInstruction: (self cCoerceSimple: 1 to: #'AbstractInstruction *')].
	^fixup
]

{ #category : #debugging }
Cogit >> enterCogCodePopReceiver [
	"This is a static version of ceEnterCogCodePopReceiverReg
	 for break-pointing when debugging in C."
	<api>
	<inline: false>
	"(and this exists only to reference Debug)"
	Debug ifFalse: [self error: 'what??'].
	coInterpreter assertValidMachineCodeFrame: (coInterpreter stackValue: 1).
	"This exists only for break-pointing."
	self cCode: 'realCEEnterCogCodePopReceiverReg()'
		inSmalltalk: [self ceEnterCogCodePopReceiverReg]
]

{ #category : #debugging }
Cogit >> enterCogCodePopReceiverAndClassRegs [
	"This is a static version of ceEnterCogCodePopReceiverAndClassRegs
	 for break-pointing when debugging in C."
	<api>
	<inline: false>
	"(and this exists only to reference Debug)"
	Debug ifFalse: [self error: 'what??'].
	coInterpreter assertValidMachineCodeFrame: (coInterpreter stackValue: 2).
	"This exists only for break-pointing."
	self cCode: 'realCEEnterCogCodePopReceiverAndClassRegs()'
		inSmalltalk: [self ceEnterCogCodePopReceiverAndClassRegs]
]

{ #category : #accessing }
Cogit >> entryOffset [
	<api>
	<cmacro: '() cmEntryOffset'>
	^cmEntryOffset
]

{ #category : #'generate machine code' }
Cogit >> fillInCPICHeader: pic size: size numArgs: numArgs numCases: numCases selector: selector [
	<returnTypeC: #'CogMethod *'>
	<var: #pic type: #'CogMethod *'>
	self assert: (coInterpreter isYoung: selector) not.
	pic cmType: CMClosedPIC.
	pic objectHeader: 0.
	pic blockSize: size.
	pic methodObject: 0.
	pic methodHeader: 0.
	pic selector: selector.
	pic cmNumArgs: numArgs.
	pic cmRefersToYoung: false.
	pic cmUsageCount: self initialClosedPICUsageCount.
	pic cmIsUnlinked: false.
	pic cPICNumCases: numCases.
	pic blockEntryOffset: 0.
	self assert: pic cmType = CMClosedPIC.
	self assert: pic selector = selector.
	self assert: pic cmNumArgs = numArgs.
	self assert: pic cPICNumCases = numCases.
	self assert: (backEnd callTargetFromReturnAddress: pic asInteger + missOffset) = cePICAbortTrampoline.
	self assert: size = (methodZone roundUpLength: size).
	^pic
]

{ #category : #'generate machine code' }
Cogit >> fillInMethodHeader: method size: size selector: selector [
	<returnTypeC: #'CogMethod *'>
	<var: #method type: #'CogMethod *'>
	| methodHeader |
	method cmType: CMMethod.
	methodHeader := coInterpreter rawHeaderOf: methodObj.
	method objectHeader: coInterpreter nullHeaderForMachineCodeMethod.
	method blockSize: size.
	method methodObject: methodObj.
	method methodHeader: methodHeader.
	coInterpreter rawHeaderOf: methodObj put: method.
	method selector: selector.
	method cmNumArgs: (coInterpreter argumentCountOfMethodHeader: methodHeader).
	(method cmRefersToYoung: hasYoungReferent) ifTrue:
		[methodZone addToYoungReferrers: method].
	method cmUsageCount: self initialMethodUsageCount.
	method cmIsUnlinked: false.
	method blockEntryOffset: (blockEntryLabel notNil
								ifTrue: [blockEntryLabel address - method asInteger]
								ifFalse: [0]).
	method stackCheckOffset: (needsFrame
								ifTrue: [stackCheckLabel address - method asInteger]
								ifFalse: [0]).
	self assert: (backEnd callTargetFromReturnAddress: method asInteger + missOffset) = ceMethodAbortTrampoline.
	self assert: size = (methodZone roundUpLength: size).
	^method
]

{ #category : #'generate machine code' }
Cogit >> fillInOPICHeader: pic size: size numArgs: numArgs selector: selector [
	<returnTypeC: #'CogMethod *'>
	<var: #pic type: #'CogMethod *'>
	pic cmType: CMOpenPIC.
	pic objectHeader: 0.
	pic blockSize: size.
	"pic methodObject: 0.""This is also the nextOpenPIC link so don't initialize it"
	methodZone addToOpenPICList: pic.
	pic methodHeader: 0.
	pic selector: selector.
	pic cmNumArgs: numArgs.
	(pic cmRefersToYoung: (coInterpreter isYoung: selector)) ifTrue:
		[methodZone addToYoungReferrers: pic].
	pic cmUsageCount: self initialOpenPICUsageCount.
	pic cmIsUnlinked: false.
	pic cPICNumCases: 0.
	pic blockEntryOffset: 0.
	self assert: pic cmType = CMOpenPIC.
	self assert: pic selector = selector.
	self assert: pic cmNumArgs = numArgs.
	self assert: (backEnd callTargetFromReturnAddress: pic asInteger + missOffset) = cePICAbortTrampoline.
	self assert: size = (methodZone roundUpLength: size).
	^pic
]

{ #category : #'method map' }
Cogit >> find: annotation Matching: mcpc Bcpc: bcpc Size: numBytes PC: targetMcpc [
	<var: #annotation type: #char>
	<var: #mcpc type: #'char *'>
	<var: #targetMcpc type: #'void *'>
	"Transcript
		print: (#(IsMethodReference HasBytecodePC IsSendCall) select: [:k| (Cogit classPool at: k) = annotation]);
		space; nextPutAll: (mcpc printStringRadix: 16);
		space; print: bcpc;
		space; print: numBytes; cr; flush."
	"All machine code pcs with bytecode map entries (sends, mustBeBooleans, et al)
	 map to the following bytecode, except the first bytecode/stackCheckOffset, which
	 is handled in the caller bytecodePCFor:startBcpc:in:."
	^targetMcpc = mcpc
		ifTrue: [bcpc + numBytes]
		ifFalse: [0]
]

{ #category : #'method map' }
Cogit >> findBlockMethodWithStartMcpc: blockEntryPC bcpc: startBcpc [
	<returnTypeC: #usqInt>
	| cogBlockMethod stackCheckMcpc |
	<var: #cogBlockMethod type: #'CogBlockMethod *'>
	cogBlockMethod := self cCoerceSimple: blockEntryPC - (self sizeof: CogBlockMethod)
								   to: #'CogBlockMethod *'.
	stackCheckMcpc := cogBlockMethod asUnsignedInteger + cogBlockMethod stackCheckOffset.
	(self bytecodePCFor: stackCheckMcpc startBcpc: startBcpc in: cogBlockMethod) = startBcpc ifTrue:
		[^cogBlockMethod asUnsignedInteger].
	^0 "keep scanning..."
]

{ #category : #'method map' }
Cogit >> findEnclosingMethodFor: mcpc inHomeMethod: cogMethod [
	<var: #cogMethod type: #'CogMethod *'>
	<returnTypeC: #'CogBlockMethod *'>
	"Find the CMMethod or CMBlock that encloses mcpc.
	 If the method contains blocks then, because block dispatch is not in order,
	 enumerate the block dispatch and find the nearest preceeding entry."
	self assert: cogMethod cmType = CMMethod.
	cogMethod blockEntryOffset = 0 ifTrue:
		[^self cCoerceSimple: cogMethod to: #'CogBlockMethod *'].
	maxMethodBefore := self cCoerceSimple: cogMethod to: #'CogBlockMethod *'.
	self blockDispatchTargetsFor: cogMethod perform: #findMinAndMaxMethodsPC:around: asSymbol arg: mcpc.
	^maxMethodBefore
]

{ #category : #'method map' }
Cogit >> findMapLocationForMcpc: targetMcpc inMethod: cogMethod [
	<var: #cogMethod type: #'CogMethod *'>
	| mcpc map mapByte annotation |
	mcpc := cogMethod asInteger + cmNoCheckEntryOffset.
	map := cogMethod asInteger + cogMethod blockSize - 1.
	mcpc = targetMcpc ifTrue: [^map].
	[(mapByte := coInterpreter byteAt: map) ~= MapEnd] whileTrue:
		[annotation := mapByte >> AnnotationShift.
		 mcpc := mcpc + (annotation = IsDisplacementX2N
							ifTrue: [mapByte - DisplacementX2N << AnnotationShift]
							ifFalse: [mapByte bitAnd: DisplacementMask]).
		 mcpc >= targetMcpc ifTrue:
			[self assert: mcpc = targetMcpc.
			 ^map].
		 map := map - 1].
	^0
]

{ #category : #'method map' }
Cogit >> findMethodForStartBcpc: startbcpc inHomeMethod: cogMethod [
	<api>
	<var: #cogMethod type: #'CogMethod *'>
	<returnTypeC: #'CogBlockMethod *'>
	"Find the CMMethod or CMBlock that has zero-relative startbcpc as its first bytecode pc.
	 As this is for cannot resme processing it doesn't have to be fast.
	 Enumerate block returns and map to bytecode pcs"
	self assert: cogMethod cmType = CMMethod.
	startbcpc = (coInterpreter startPCOfMethodHeader: cogMethod methodHeader) ifTrue:
		[^self cCoerceSimple: cogMethod to: #'CogBlockMethod *'].
	self assert: cogMethod blockEntryOffset ~= 0.
	^self cCoerceSimple: (self blockDispatchTargetsFor: cogMethod
								perform: #findBlockMethodWithStartMcpc:bcpc: asSymbol
								arg: startbcpc)
		to: #'CogBlockMethod *'
]

{ #category : #'method map' }
Cogit >> findMinAndMaxMethodsPC: blockEntryPC around: mcpc [
	<returnTypeC: #usqInt>
	(blockEntryPC asUnsignedInteger <= mcpc asUnsignedInteger
	and: [blockEntryPC asUnsignedInteger > maxMethodBefore asUnsignedInteger]) ifTrue:
		[maxMethodBefore := self cCoerceSimple: blockEntryPC - (self sizeof: CogBlockMethod)
								   to: #'CogBlockMethod *'].
	^0 "keep scanning..."
]

{ #category : #'compile abstract instructions' }
Cogit >> fixupAt: index [
	<cmacro: '(index) (&fixups[index])'>
	^fixups at: index
]

{ #category : #compaction }
Cogit >> freePICsWithFreedTargets [
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[(cogMethod cmType = CMClosedPIC
		 and: [self cPICHasFreedTargets: cogMethod]) ifTrue:
			[cogMethod cmType: CMFree].
		 cogMethod := methodZone methodAfter: cogMethod]
]

{ #category : #'compile abstract instructions' }
Cogit >> gen: opcode [ "<Integer>"
	| abstractInstruction |
	<inline: false>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	self assert: opcodeIndex < numAbstractOpcodes.
	abstractInstruction := self abstractInstructionAt: opcodeIndex.
	opcodeIndex := opcodeIndex + 1.
	abstractInstruction opcode: opcode.
	^abstractInstruction
]

{ #category : #'compile abstract instructions' }
Cogit >> gen: opcode "<Integer>" operand: operand [ "<Integer|CogAbstractInstruction>"
	| abstractInstruction |
	<inline: false>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	self assert: opcodeIndex < numAbstractOpcodes.
	abstractInstruction := self abstractInstructionAt: opcodeIndex.
	opcodeIndex := opcodeIndex + 1.
	abstractInstruction opcode: opcode.
	abstractInstruction operands at: 0 put: operand.
	^abstractInstruction
]

{ #category : #'compile abstract instructions' }
Cogit >> gen: opcode "<Integer>" operand: operandOne "<Integer|CogAbstractInstruction>"  operand: operandTwo [ "<Integer|CogAbstractInstruction>"
	| abstractInstruction |
	<inline: false>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	self assert: opcodeIndex < numAbstractOpcodes.
	abstractInstruction := self abstractInstructionAt: opcodeIndex.
	opcodeIndex := opcodeIndex + 1.
	abstractInstruction opcode: opcode.
	abstractInstruction operands at: 0 put: operandOne.
	abstractInstruction operands at: 1 put: operandTwo.
	^abstractInstruction
]

{ #category : #'compile abstract instructions' }
Cogit >> gen: opcode "<Integer>" operand: operandOne "<Integer|CogAbstractInstruction>"  operand: operandTwo "<Integer|CogAbstractInstruction>" operand: operandThree [ "<Integer|CogAbstractInstruction>"
	| abstractInstruction |
	<inline: false>
	<returnTypeC: #'AbstractInstruction *'>
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	self assert: opcodeIndex < numAbstractOpcodes.
	abstractInstruction := self abstractInstructionAt: opcodeIndex.
	opcodeIndex := opcodeIndex + 1.
	abstractInstruction opcode: opcode.
	abstractInstruction operands at: 0 put: operandOne.
	abstractInstruction operands at: 1 put: operandTwo.
	abstractInstruction operands at: 2 put: operandThree.
	^abstractInstruction
]

{ #category : #initialization }
Cogit >> genCheckForInterruptsTrampoline [
	opcodeIndex := 0.
	self PopR: TempReg. "instruction pointer"
	self MoveR: TempReg Aw: coInterpreter instructionPointerAddress.
	^self genTrampolineFor: #ceCheckForInterrupts asSymbol
		called: 'ceCheckForInterruptsTrampoline'
		callJumpBar: true
		numArgs: 0
		arg: nil
		arg: nil
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil
		appendOpcodes: true
]

{ #category : #initialization }
Cogit >> genEnilopmartFor: regArg1 and: regArg2 called: trampolineName [
	"An enilopmart (the reverse of a trampoline) is a piece of code that makes
	 the system-call-like transition from the C runtime into generated machine
	 code.  The desired arguments and entry-point are pushed on a stackPage's
	 stack.  The enilopmart pops off the values to be loaded into registers and
	 then executes a return instruction to pop off the entry-point and jump to it."
	<returnTypeC: 'void (*genEnilopmartForandcalled(sqInt regArg1, sqInt regArg2, char *trampolineName))(void)'>
	| size endAddress enilopmart |
	opcodeIndex := 0.
	cFramePointerInUse ifTrue:
		[self MoveR: FPReg Aw: self enilopmartCFPAddress].
	self MoveR: SPReg Aw: self enilopmartCSPAddress.
	self genLoadStackPointers.
	self PopR: regArg2.
	self PopR: regArg1.
	self RetN: 0.
	self computeMaximumSizes.
	size := self generateInstructionsAt: methodZoneBase.
	endAddress := self outputInstructionsAt: methodZoneBase.
	self assert: methodZoneBase + size = endAddress.
	enilopmart := methodZoneBase.
	methodZoneBase := self alignUptoRoutineBoundary: endAddress.
	backEnd nopsFrom: endAddress to: methodZoneBase - 1.
	self recordGeneratedRunTime: trampolineName address: enilopmart.
	^self cCoerceSimple: enilopmart to: #'void (*)(void)'
]

{ #category : #initialization }
Cogit >> genEnilopmartFor: regArg called: trampolineName [
	"An enilopmart (the reverse of a trampoline) is a piece of code that makes
	 the system-call-like transition from the C runtime into generated machine
	 code.  The desired arguments and entry-point are pushed on a stackPage's
	 stack.  The enilopmart pops off the values to be loaded into registers and
	 then executes a return instruction to pop off the entry-point and jump to it."
	<returnTypeC: 'void (*genEnilopmartForcalled(sqInt regArg, char *trampolineName))(void)'>
	| size endAddress enilopmart |
	opcodeIndex := 0.
	cFramePointerInUse ifTrue:
		[self MoveR: FPReg Aw: self enilopmartCFPAddress].
	self MoveR: SPReg Aw: self enilopmartCSPAddress.
	self genLoadStackPointers.
	self PopR: regArg.
	self RetN: 0.
	self computeMaximumSizes.
	size := self generateInstructionsAt: methodZoneBase.
	endAddress := self outputInstructionsAt: methodZoneBase.
	self assert: methodZoneBase + size = endAddress.
	enilopmart := methodZoneBase.
	methodZoneBase := self alignUptoRoutineBoundary: endAddress.
	backEnd nopsFrom: endAddress to: methodZoneBase - 1.
	self recordGeneratedRunTime: trampolineName address: enilopmart.
	^self cCoerceSimple: enilopmart to: #'void (*)(void)'
]

{ #category : #'trampoline support' }
Cogit >> genExternalizePointersForPrimitiveCall [
	self MoveMw: 0 r: SPReg R: ClassReg.
	self MoveR: FPReg Aw: coInterpreter framePointerAddress.
	"Set coInterpreter stackPointer to the topmost argument, skipping the return address."
	self LoadEffectiveAddressMw: BytesPerWord r: SPReg R: TempReg.
	self MoveR: ClassReg Aw: coInterpreter instructionPointerAddress.
	self MoveR: TempReg Aw: coInterpreter stackPointerAddress.
	^0
]

{ #category : #initialization }
Cogit >> genGetLeafCallStackPointer [
	"Generate a routine that answers the stack pointer immedately
	 after a leaf call, used for checking stack pointer alignment."
	| startAddress |
	<inline: false>
	self allocateOpcodes: 32 bytecodes: 0.
	initialPC := 0.
	endPC := numAbstractOpcodes - 1.
	startAddress := methodZoneBase.
	backEnd genGetLeafCallStackPointerFunction.
	self outputInstructionsForGeneratedRuntimeAt: startAddress.
	self recordGeneratedRunTime: 'ceGetSP' address: startAddress.
	^startAddress
]

{ #category : #'trampoline support' }
Cogit >> genLoadCStackPointers [
	self MoveAw: self cStackPointerAddress R: SPReg.
	cFramePointerInUse ifTrue:
		[self MoveAw: self cFramePointerAddress R: FPReg].
	^0
]

{ #category : #'trampoline support' }
Cogit >> genLoadCStackPointersForPrimCall [
	debugPrimCallStackOffset = 0
		ifTrue:
			[self MoveAw: self cStackPointerAddress R: SPReg]
		ifFalse:
			[self MoveAw: self cStackPointerAddress R: TempReg.
			 self SubCq: debugPrimCallStackOffset R: TempReg.
			 self MoveR: TempReg R: SPReg].
	cFramePointerInUse ifTrue:
		[self MoveAw: self cFramePointerAddress R: FPReg].
	^0
]

{ #category : #'trampoline support' }
Cogit >> genLoadStackPointers [
	"Switch back to the Smalltalk stack. Assign SPReg first
	 because typically it is used immediately afterwards."
	self MoveAw: coInterpreter stackPointerAddress R: SPReg.
	self MoveAw: coInterpreter framePointerAddress R: FPReg.
	^0
]

{ #category : #initialization }
Cogit >> genMethodAbortTrampoline [
	"Generate the abort for a method.  This abort performs either a call of ceSICMiss:
	 to handle a single-in-line cache miss or a call of ceStackOverflow: to handle a
	 stack overflow.  It distinguishes the two by testing ResultReceiverReg.  If the
	 register is zero then this is a stack-overflow because a) the receiver has already
	 been pushed and so can be set to zero before calling the abort, and b) the
	 receiver must always contain an object (and hence be non-zero) on SIC miss."
	| jumpSICMiss |
	<var: #jumpSICMiss type: #'AbstractInstruction *'>
	opcodeIndex := 0.
	self CmpCq: 0 R: ReceiverResultReg.
	jumpSICMiss := self JumpNonZero: 0.
	self compileTrampolineFor: #ceStackOverflow: asSymbol
		callJumpBar: true
		numArgs: 1
		arg: SendNumArgsReg
		arg: nil
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil.
	jumpSICMiss jmpTarget: self Label.
	^self genTrampolineFor: #ceSICMiss: asSymbol
		called: 'ceMethodAbort'
		callJumpBar: true
		numArgs: 1
		arg: ReceiverResultReg
		arg: nil
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil
		appendOpcodes: true
]

{ #category : #initialization }
Cogit >> genNonLocalReturnTrampoline [
	opcodeIndex := 0.
	self PopR: TempReg. "instruction pointer"
	self MoveR: TempReg Aw: coInterpreter instructionPointerAddress.
	^self genTrampolineFor: #ceNonLocalReturn: asSymbol
		called: 'ceNonLocalReturnTrampoline'
		callJumpBar: true
		numArgs: 1
		arg: ReceiverResultReg
		arg: nil
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil
		appendOpcodes: true
]

{ #category : #initialization }
Cogit >> genPICAbortTrampoline [
	"Generate the abort for a PIC.  This abort performs either a call of
	 ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged
	 target or a call of ceMNUFromPICMNUMethod:receiver: to handle an
	 MNU dispatch in a closed PIC.  It distinguishes the two by testing
	 ClassReg.  If the register is zero then this is an MNU."
	| jumpMNUCase |
	<var: #jumpMNUCase type: #'AbstractInstruction *'>
	opcodeIndex := 0.
	self CmpCq: 0 R: ClassReg.
	jumpMNUCase := self JumpZero: 0.
	self compileTrampolineFor: #ceInterpretMethodFromPIC:receiver: asSymbol
		callJumpBar: true
		numArgs: 2
		arg: SendNumArgsReg
		arg: ReceiverResultReg
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil.
	jumpMNUCase jmpTarget: self Label.
	^self genTrampolineFor: #ceMNUFromPICMNUMethod:receiver: asSymbol
		called: 'cePICAbort'
		callJumpBar: true
		numArgs: 2
		arg: SendNumArgsReg
		arg: ReceiverResultReg
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil
		appendOpcodes: true
]

{ #category : #initialization }
Cogit >> genPrimReturnEnterCogCodeEnilopmart [
	self subclassResponsibility
]

{ #category : #initialization }
Cogit >> genPushActiveContextTrampoline [
	"Short-circuit the trampoline if a frame is already married."
	| jumpSingle |
	<var: #jumpSingle type: #'AbstractInstruction *'>
	opcodeIndex := 0.
	self MoveMw: FoxMethod r: FPReg R: TempReg.
	self AndCq: MFMethodFlagHasContextFlag R: TempReg.
	jumpSingle := self JumpZero: 0.
	self MoveMw: FoxThisContext r: FPReg R: ReceiverResultReg.
	self RetN: 0.
	jumpSingle jmpTarget: self Label.
	^self genTrampolineFor: #cePushActiveContext asSymbol
		called: 'cePushActiveContextTrampoline'
		callJumpBar: true
		numArgs: 0
		arg: nil
		arg: nil
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: ReceiverResultReg
		appendOpcodes: true
]

{ #category : #initialization }
Cogit >> genSafeTrampolineFor: aRoutine called: aString arg: regOrConst0 [
	"Generate a trampoline with one argument that will
	 save and restore all registers around the call"
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 1
		arg: regOrConst0
		arg: nil
		arg: nil
		arg: nil
		saveRegs: true
		resultReg: nil
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genSafeTrampolineFor: aRoutine called: aString arg: regOrConst0 arg: regOrConst1 [
	"Generate a trampoline with two arguments that
	 will save and restore all registers around the call"
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 2
		arg: regOrConst0
		arg: regOrConst1
		arg: nil
		arg: nil
		saveRegs: true
		resultReg: nil
		appendOpcodes: false
]

{ #category : #'trampoline support' }
Cogit >> genSaveStackPointers [
	self MoveR: FPReg Aw: coInterpreter framePointerAddress.
	self MoveR: SPReg Aw: coInterpreter stackPointerAddress.
	^0
]

{ #category : #initialization }
Cogit >> genTraceStoreTrampoline [
	self subclassResponsibility
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine called: aString [
	"Generate a trampoline with no arguments"
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 0
		arg: nil
		arg: nil
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine  called: aString arg: regOrConst0 [
	"Generate a trampoline with one argument.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 1
		arg: regOrConst0
		arg: nil
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine called: aString arg: regOrConst0 arg: regOrConst1 [
	"Generate a trampoline with two arguments.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 2
		arg: regOrConst0
		arg: regOrConst1
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: nil
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine called: aString arg: regOrConst0 arg: regOrConst1 arg: regOrConst2 [
	"Generate a trampoline with three arguments.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 3
		arg: regOrConst0
		arg: regOrConst1
		arg: regOrConst2
		arg: nil
		saveRegs: false
		resultReg: nil
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine called: aString arg: regOrConst0 arg: regOrConst1 arg: regOrConst2 arg: regOrConst3 [
	"Generate a trampoline with four arguments.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 4
		arg: regOrConst0
		arg: regOrConst1
		arg: regOrConst2
		arg: regOrConst3
		saveRegs: false
		resultReg: nil
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine called: aString arg: regOrConst0 arg: regOrConst1 arg: regOrConst2 result: resultReg [
	"Generate a trampoline with two arguments that answers a result.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 3
		arg: regOrConst0
		arg: regOrConst1
		arg: regOrConst2
		arg: nil
		saveRegs: false
		resultReg: resultReg
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine called: aString arg: regOrConst0 arg: regOrConst1 result: resultReg [
	"Generate a trampoline with two arguments that answers a result.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 2
		arg: regOrConst0
		arg: regOrConst1
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: resultReg
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine called: aString arg: regOrConst0 result: resultReg [
	"Generate a trampoline with one argument that answers a result.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<var: #aString type: #'char *'>
	^self
		genTrampolineFor: aRoutine
		called: aString
		callJumpBar: true
		numArgs: 1
		arg: regOrConst0
		arg: nil
		arg: nil
		arg: nil
		saveRegs: false
		resultReg: resultReg
		appendOpcodes: false
]

{ #category : #initialization }
Cogit >> genTrampolineFor: aRoutine called: trampolineName callJumpBar: callJumpBar "<Boolean>" numArgs: numArgs arg: regOrConst0 arg: regOrConst1 arg: regOrConst2 arg: regOrConst3 saveRegs: saveRegs resultReg: resultRegOrNil appendOpcodes: appendBoolean [
	"Generate a trampoline with up to four arguments.  Generate either a call or a jump to aRoutineOrNil
	 as requested by callJumpBar.  If generating a call and resultRegOrNil is non-zero pass the C result
	 back in resultRegOrNil.
	 Hack: a negative value indicates an abstract register, a non-negative value indicates a constant."
	<var: #aRoutine type: #'void *'>
	<var: #trampolineName type: #'char *'>
	| startAddress |
	<inline: false>
	startAddress := methodZoneBase.
	appendBoolean ifFalse:
		[opcodeIndex := 0].
	self compileTrampolineFor: aRoutine
		callJumpBar: callJumpBar
		numArgs: numArgs
		arg: regOrConst0
		arg: regOrConst1
		arg: regOrConst2
		arg: regOrConst3
		saveRegs: saveRegs
		resultReg: resultRegOrNil.
	self outputInstructionsForGeneratedRuntimeAt: startAddress.
	self recordGeneratedRunTime: trampolineName address: startAddress.
	^startAddress
]

{ #category : #'generate machine code' }
Cogit >> generateBlockEntryRelatedCode [
	"We need to compute the block headers now we know the exact layout of the code.
	 We also need to compute the block entry."
	| blockStart blockHeader blockHeaderPtr "Slang is dumb" |
	<var: #blockStart type: #'BlockStart *'>
	<var: #blockHeader type: #'CogBlockMethod'>
	<var: #blockHeaderPtr type: #'CogBlockMethod *'>

	(needsFrame and: [blockCount > 0]) ifFalse:
		[^nil].
	blockNoContextSwitchOffset = nil
		ifTrue: [blockNoContextSwitchOffset := blockEntryLabel address - blockEntryNoContextSwitch address]
		ifFalse: [self assert: blockNoContextSwitchOffset = (blockEntryLabel address - blockEntryNoContextSwitch address)].

	blockHeaderPtr := self cCode: [self addressOf: blockHeader]
							inSmalltalk: [blockHeader := coInterpreter cogBlockMethodSurrogateAt: 0].
	0 to: blockCount - 1 do:
		[:i|
		blockStart := self blockStartAt: i.
		blockHeaderPtr
			cmType: CMBlock;
			objectHeader: 16rB10CEAD; "Ian Dury click, click clicked.  R.I.P."
			cmNumArgs: blockStart numArgs;
			stackCheckOffset: (blockStart stackCheckLabel = nil
								ifTrue: [0]
								ifFalse: [blockStart stackCheckLabel address - blockStart fakeHeader address]).
		blockStart fillInstruction operands at: 0 put: blockHeaderPtr typeEtAlWord.
		blockStart fillInstruction concretizeAt: blockStart fillInstruction address]
]

{ #category : #initialization }
Cogit >> generateCaptureCStackPointers: captureFramePointer [
	"Generate the routine that writes the current values of the C frame and stack pointers into
	 variables.  These are used to establish the C stack in trampolines back into the C run-time.

	 This is a presumptuous quick hack for x86.  It is presumptuous for two reasons.  Firstly
	 the system's frame and stack pointers may differ from those we use in generated code,
	 e.g. on register-rich RISCs.  Secondly the ABI may not support a simple frameless call
	 as written here (for example 128-bit stack alignment on Mac OS X)."
	| startAddress |
	<inline: false>
	self allocateOpcodes: 32 bytecodes: 0.
	initialPC := 0.
	endPC := numAbstractOpcodes - 1.
	startAddress := methodZoneBase.
	captureFramePointer ifTrue:
		[self MoveR: FPReg Aw: self cFramePointerAddress].
	"Capture the stack pointer prior to the call."
	backEnd leafCallStackPointerDelta = 0
		ifTrue: [self MoveR: SPReg Aw: self cStackPointerAddress]
		ifFalse: [self MoveR: SPReg R: TempReg.
				self AddCq: backEnd leafCallStackPointerDelta R: TempReg.
				self MoveR: TempReg Aw: self cStackPointerAddress].
	self RetN: 0.
	self outputInstructionsForGeneratedRuntimeAt: startAddress.
	self recordGeneratedRunTime: 'ceCaptureCStackPointers' address: startAddress.
	ceCaptureCStackPointers := self cCoerceSimple: startAddress to: #'void (*)(void)'
]

{ #category : #initialization }
Cogit >> generateClosedPICPrototype [
	"Generate the prototype ClosedPIC to determine how much space as full PIC takes.
	 When we first allocate a closed PIC it only has one or two cases and we want to grow it.
	 So we have to determine how big a full one is before hand."
	| headerSize |
	numPICCases := 6.
	"stack allocate the various collections so that they
	 are effectively garbage collected on return."
	self allocateOpcodes: numPICCases * 7 bytecodes: 0.
	self compileClosedPICPrototype.
	self computeMaximumSizes.
	headerSize := self sizeof: CogMethod.
	closedPICSize := methodZone roundUpLength: headerSize + (self generateInstructionsAt: methodZoneBase + headerSize).
	firstCPICCaseOffset := endCPICCase0 address - methodZoneBase.
	cPICCaseSize := endCPICCase1 address - endCPICCase0 address.
	cPICEndSize := closedPICSize - (numPICCases - 1 * cPICCaseSize + firstCPICCaseOffset)
	"self cCode: ''
		inSmalltalk:
			[| end |
			 end := self outputInstructionsAt: methodZoneBase + headerSize.
			 self disassembleFrom: methodZoneBase + headerSize to: end - 1.
			 self halt]"
]

{ #category : #'generate machine code' }
Cogit >> generateCogMethod: selector [
	"We handle jump sizing simply.  First we make a pass that asks each
	 instruction to compute its maximum size.  Then we make a pass that
	 sizes jumps based on the maxmimum sizes.  Then we make a pass
	 that fixes up jumps.  When fixing up a jump the jump is not allowed to
	 choose a smaller offset but must stick to the size set in the second pass."
	| codeSize headerSize mapSize totalSize startAddress result method |
	<var: #method type: #'CogMethod *'>
	<var: #blockStart type: #'BlockStart *'>
	<var: #headerReference type: #'AbstractInstruction *'>
	<returnTypeC: #'CogMethod *'>
	headerSize := self sizeof: CogMethod.
	methodLabel address: headerSize negated.
	self computeMaximumSizes.
	methodLabel concretizeAt: (methodZone allocate: 0).
	codeSize := self generateInstructionsAt: methodLabel address + headerSize.
	mapSize := self generateMapAt: 0 start: methodLabel address + cmNoCheckEntryOffset.
	totalSize := methodZone roundUpLength: headerSize + codeSize + mapSize.
	startAddress := methodZone allocate: totalSize.
	startAddress = 0 ifTrue:
		[^self cCoerceSimple: InsufficientCodeSpace to: #'CogMethod *'].
	self assert: startAddress + cmEntryOffset = entry address.
	self assert: startAddress + cmNoCheckEntryOffset = noCheckEntry address.
	self generateBlockEntryRelatedCode.
	result := self outputInstructionsAt: startAddress + headerSize.
	self assert: startAddress + headerSize + codeSize = result.
	backEnd nopsFrom: result to: startAddress + totalSize - mapSize.
	self generateMapAt: startAddress + totalSize - 1 start: startAddress + cmNoCheckEntryOffset.
	method := self fillInMethodHeader: (self cCoerceSimple: startAddress to: #'CogMethod *')
					size: totalSize
					selector: selector.
	postCompileHook notNil ifTrue:
		[self perform: postCompileHook with: method with: primInvokeLabel.
		 postCompileHook := nil].
	processor flushICacheFrom: startAddress to: startAddress + headerSize + codeSize.
	^method
]

{ #category : #initialization }
Cogit >> generateEnilopmarts [
	"Enilopmarts transfer control from C into machine code (backwards trampolines)."
	(self cCode: 'Debug' inSmalltalk: [false])
		ifTrue:
			[realCEEnterCogCodePopReceiverReg := self genEnilopmartFor: ReceiverResultReg
														called: 'realCEEnterCogCodePopReceiverReg'.
			 ceEnterCogCodePopReceiverReg := #enterCogCodePopReceiver asSymbol.
			 realCEEnterCogCodePopReceiverAndClassRegs :=
													self genEnilopmartFor: ReceiverResultReg
														and: ClassReg
														called: 'realCEEnterCogCodePopReceiverAndClassRegs'.
			 ceEnterCogCodePopReceiverAndClassRegs := #enterCogCodePopReceiverAndClassRegs asSymbol]
		ifFalse:
			[ceEnterCogCodePopReceiverReg := self genEnilopmartFor: ReceiverResultReg
													called: 'ceEnterCogCodePopReceiverReg'.
			 ceEnterCogCodePopReceiverAndClassRegs :=
													self genEnilopmartFor: ReceiverResultReg
														and: ClassReg
														called: 'ceEnterCogCodePopReceiverAndClassRegs'].

	self genPrimReturnEnterCogCodeEnilopmart
]

{ #category : #'generate machine code' }
Cogit >> generateInstructionsAt: eventualAbsoluteAddress [
	"Size pc-dependent instructions and assign eventual addresses to all instructions.
	 Answer the size of the code.
	 Compute forward branches based on virtual address (abstract code starts at 0),
	 assuming that any branches branched over are long.
	 Compute backward branches based on actual address.
	 Reuse the fixups array to record the pc-dependent instructions that need to have
	 their code generation postponed until after the others."
	| absoluteAddress pcDependentIndex abstractInstruction fixup |
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	<var: #fixup type: #'BytecodeFixup *'>
	absoluteAddress := eventualAbsoluteAddress.
	pcDependentIndex := 0.
	0 to: opcodeIndex - 1 do:
		[:i|
		breakPC = absoluteAddress ifTrue:
			[self halt: 'breakPC reached in generateInstructionsAt:'].
		abstractInstruction := self abstractInstructionAt: i.
		abstractInstruction isPCDependent
			ifTrue:
				[abstractInstruction sizePCDependentInstructionAt: absoluteAddress.
				 fixup := self fixupAt: pcDependentIndex.
				 pcDependentIndex := pcDependentIndex + 1.
				 fixup instructionIndex: i.
				 absoluteAddress := absoluteAddress + abstractInstruction machineCodeSize]
			ifFalse:
				[absoluteAddress := abstractInstruction concretizeAt: absoluteAddress]].
	0 to: pcDependentIndex - 1 do:
		[:i|
		fixup := self fixupAt: i.
		abstractInstruction := self abstractInstructionAt: fixup instructionIndex.
		breakPC = absoluteAddress ifTrue:
			[self halt: 'breakPC reached in generateInstructionsAt:'].
		abstractInstruction concretizeAt: abstractInstruction address].
	self cCode: ''
		inSmalltalk:
			[breakPC ifNotNil:
				[breakPC <= absoluteAddress ifTrue:
					[self singleStep: true]]].
	^absoluteAddress - eventualAbsoluteAddress
]

{ #category : #'method map' }
Cogit >> generateMapAt: addressOrNull start: startAddress [
	"Generate the method map at addressrNull (or compute it if adressOrNull is null).
	 Answer the length of the map in byes.  Each entry in the map is in two parts.  In the
	 least signficant bits are a displacement of how far from the start or previous entry.
	 In the most signficant bits are the type of annotation at the point reached.  A null
	 byte ends the map."
	| length location |
	<var: #annotation type: #'InstructionAnnotation *'>
	length := 0.
	location := startAddress.
	0 to: annotationIndex - 1 do:
		[:i| | annotation mcpc delta maxDelta mapEntry |
		 annotation := self addressOf: (annotations at: i).
		 mcpc := annotation instruction address + annotation instruction machineCodeSize.
		 [(delta := mcpc - location) > MaxUnitDisplacement] whileTrue:
			[maxDelta := (delta min: MaxX2NDisplacement) bitAnd: DisplacementMask bitInvert32.
			 self assert: maxDelta >> AnnotationShift <= DisplacementMask.
			 addressOrNull ~= 0 ifTrue:
				[coInterpreter
					byteAt: addressOrNull - length
					put: maxDelta >> AnnotationShift + DisplacementX2N].
			 location := location + maxDelta.
			 length := length + 1].
		 addressOrNull ~= 0 ifTrue:
			[mapEntry := delta + (annotation annotation << AnnotationShift).
			 coInterpreter byteAt: addressOrNull - length put: mapEntry].
		 location := location + delta.
		 length := length + 1].
	addressOrNull ~= 0 ifTrue:
		[coInterpreter byteAt: addressOrNull - length put: MapEnd].
	^length + 1
]

{ #category : #initialization }
Cogit >> generateOpenPICPrototype [
	"Generate the prototype ClosedPIC to determine how much space as full PIC takes.
	 When we first allocate a closed PIC it only has one or two cases and we want to grow it.
	 So we have to determine how big a full one is before hand."
	| headerSize codeSize mapSize |
	"stack allocate the various collections so that they
	 are effectively garbage collected on return."
	self allocateOpcodes: 100 bytecodes: 0.
	self compileOpenPIC: 16r5E1EC70.
	self computeMaximumSizes.
	headerSize := self sizeof: CogMethod.
	methodLabel concretizeAt: methodZoneBase.
	codeSize := self generateInstructionsAt: methodZoneBase + headerSize.
	mapSize := self generateMapAt: 0 start: methodZoneBase + cmNoCheckEntryOffset.
	openPICSize := methodZone roundUpLength: headerSize + codeSize + mapSize.
	"self cCode: ''
		inSmalltalk:
			[| end |
			 end := self outputInstructionsAt: methodZoneBase + headerSize.
			 self disassembleFrom: methodZoneBase + headerSize to: end - 1.
			 self halt]"
]

{ #category : #initialization }
Cogit >> generateStackPointerCapture [
	"Generate a routine ceCaptureCStackPointers that will capture the C stack pointer,
	 and, if it is in use, the C frame pointer.  These are used in trampolines to call
	 run-time routines in the interpreter from machine-code."

	| oldMethodZoneBase oldTrampolineTableIndex |
	self assertCStackWellAligned.
	oldMethodZoneBase := methodZoneBase.
	oldTrampolineTableIndex := trampolineTableIndex.
	self generateCaptureCStackPointers: true.
	self perform: #ceCaptureCStackPointers asSymbol.
	(cFramePointerInUse := self isCFramePointerInUse) ifFalse:
		[methodZoneBase := oldMethodZoneBase.
		 trampolineTableIndex := oldTrampolineTableIndex.
		 self generateCaptureCStackPointers: false]
]

{ #category : #initialization }
Cogit >> generateTrampolines [
	"Generate the run-time entries at the base of the native code zone and update the base.
	 Read the class-side method trampolines for documentation on the various trampolines"
	| methodZoneStart |
	methodZoneStart := methodZoneBase.
	self allocateOpcodes: 32 bytecodes: 0.
	initialPC := 0.
	endPC := numAbstractOpcodes - 1.
	"Slang needs these apparently superfluous asSymbol sends."
	0 to: NumSendTrampolines - 2 do:
		[:numArgs|
		sendTrampolines
			at: numArgs
			put: (self genTrampolineFor: #ceSend:super:to:numArgs: asSymbol
					  called: (self sendTrampolineName: 'ceSend' args: numArgs)
					  arg: ClassReg
					  arg: 0
					  arg: ReceiverResultReg
					  arg: numArgs)].
	sendTrampolines
		at: NumSendTrampolines - 1
		put: (self genTrampolineFor: #ceSend:super:to:numArgs: asSymbol
					called: (self sendTrampolineName: 'ceSend' args: -1)
					arg: ClassReg
					arg: 0
					arg: ReceiverResultReg
					arg: SendNumArgsReg).
	0 to: NumSendTrampolines - 2 do:
		[:numArgs|
		superSendTrampolines
			at: numArgs
			put: (self genTrampolineFor: #ceSend:super:to:numArgs: asSymbol
					  called: (self sendTrampolineName: 'ceSuperSend' args: numArgs)
					  arg: ClassReg
					  arg: 1
					  arg: ReceiverResultReg
					  arg: numArgs)].
	superSendTrampolines
		at: NumSendTrampolines - 1
		put: (self genTrampolineFor: #ceSend:super:to:numArgs: asSymbol
					called: (self sendTrampolineName: 'ceSuperSend' args: -1)
					arg: ClassReg
					arg: 1
					arg: ReceiverResultReg
					arg: SendNumArgsReg).
	firstSend := sendTrampolines at: 0.
	lastSend := superSendTrampolines at: NumSendTrampolines - 1.
	ceMethodAbortTrampoline := self genMethodAbortTrampoline.
	cePICAbortTrampoline := self genPICAbortTrampoline.
	ceClosureCopyTrampoline := self genTrampolineFor: #ceClosureCopyDescriptor: asSymbol
									called: 'ceClosureCopyTrampoline'
									arg: SendNumArgsReg
									result: ReceiverResultReg.
	cePushActiveContextTrampoline := self genPushActiveContextTrampoline.
	ceNonLocalReturnTrampoline := self genNonLocalReturnTrampoline.
	ceBaseFrameReturnTrampoline := self genTrampolineFor: #ceBaseFrameReturn: asSymbol
										called: 'ceBaseFrameReturnTrampoline'
										arg: ReceiverResultReg.
	ceCreateNewArrayTrampoline := self genTrampolineFor: #ceNewArraySlotSize: asSymbol
										called: 'ceCreateNewArrayTrampoline'
										arg: SendNumArgsReg
										result: ReceiverResultReg.
	ceSendMustBeBooleanTrampoline := self genTrampolineFor: #ceSendMustBeBoolean: asSymbol
											called: 'ceSendMustBeBooleanTrampoline'
											arg: TempReg.
	ceCheckForInterruptTrampoline := self genCheckForInterruptsTrampoline.
	ceCPICMissTrampoline := self genTrampolineFor: #ceCPICMiss:receiver: asSymbol
								called: 'ceCPICMissTrampoline'
								arg: ClassReg
								arg: ReceiverResultReg.
	"Don't remove this one.  The inst var isn't used but the routine is used in the simulator; see compileOpenPIC:."
	ceSendFromInLineCacheMissTrampoline := self genTrampolineFor: #ceSendFromInLineCacheMiss: asSymbol
										called: 'ceSendFromInLineCacheMissTrampoline'
										arg: ClassReg.
	ceStoreCheckTrampoline := objectRepresentation genStoreCheckTrampoline.
	ceFetchContextInstVarTrampoline := self genTrampolineFor: #ceContext:instVar: asSymbol
											called: 'ceFetchContextInstVarTrampoline'
											arg: ReceiverResultReg
											arg: SendNumArgsReg
											result: TempReg.
	ceStoreContextInstVarTrampoline := self genTrampolineFor: #ceContext:instVar:value: asSymbol
											called: 'ceStoreContextInstVarTrampoline'
											arg: ReceiverResultReg
											arg: SendNumArgsReg
											arg: ClassReg
											result: TempReg. "result unused but call returns"
	cePositive32BitIntegerTrampoline := self genTrampolineFor: #cePositive32BitIntegerFor: asSymbol
											called: 'cePositive32BitIntegerTrampoline'
											arg: ReceiverResultReg
											result: TempReg.
	ceReturnToInterpreterTrampoline := self genTrampolineFor: #ceReturnToInterpreter: asSymbol
											called: 'ceReturnToInterpreterTrampoline'
											arg: ReceiverResultReg.
	ceCannotResumeTrampoline := self genTrampolineFor: #ceCannotResume asSymbol
											called: 'ceCannotResumeTrampoline'.
	self generateEnilopmarts.

	"Tracing routines"
	ceTraceLinkedSendTrampoline := self genSafeTrampolineFor: #ceTraceLinkedSend: asSymbol
										called: 'ceTraceLinkedSendTrampoline'
										arg: ReceiverResultReg.
	ceTraceBlockActivationTrampoline := self genTrampolineFor: #ceTraceBlockActivation asSymbol
											called: 'ceTraceBlockActivationTrampoline'.
	self genTraceStoreTrampoline.

	"finish up"
	self recordGeneratedRunTime: 'methodZoneBase' address: methodZoneBase.
	processor flushICacheFrom: methodZoneStart to: methodZoneBase.
	self cCode: ''
		inSmalltalk:
			[simulatedTrampolines keysAndValuesDo:
				[:addr :selector|
				simulatedTrampolines
					at: addr
					put: (MessageSend
							receiver: ((self respondsTo: selector) ifTrue: [self] ifFalse: [coInterpreter])
							selector: selector
							arguments: (1 to: selector numArgs) asArray)]]
]

{ #category : #initialization }
Cogit >> generateVMOwnerLockFunctions [
	| startAddress |
	<inline: false>
	self cCode: ''
		inSmalltalk: [coInterpreter isThreadedVM ifFalse:
						[^self]].
	self cPreprocessorDirective: '#if COGMTVM'.
	self allocateOpcodes: backEnd numLowLevelLockOpcodes bytecodes: 0.
	initialPC := 0.
	endPC := numAbstractOpcodes - 1.
	startAddress := methodZoneBase.
	backEnd generateLowLevelTryLock: coInterpreter vmOwnerLockAddress.
	self outputInstructionsForGeneratedRuntimeAt: startAddress.
	self recordGeneratedRunTime: 'ceTryLockVMOwner' address: startAddress.
	ceTryLockVMOwner := self cCoerceSimple: startAddress to: #'unsigned long (*)(void)'.

	opcodeIndex := 0.
	initialPC := 0.
	endPC := numAbstractOpcodes - 1.
	startAddress := methodZoneBase.
	backEnd generateLowLevelUnlock: coInterpreter vmOwnerLockAddress.
	self outputInstructionsForGeneratedRuntimeAt: startAddress.
	self recordGeneratedRunTime: 'ceUnlockVMOwner' address: startAddress.
	ceUnlockVMOwner := self cCoerceSimple: startAddress to: #'void (*)(void)'.
	self cPreprocessorDirective: '#endif /* COGMTVM */'
]

{ #category : #'compile abstract instructions' }
Cogit >> generatorAt: index [
	<cmacro: '(index) (&generatorTable[index])'>
	^generatorTable at: index
]

{ #category : #accessing }
Cogit >> getCFramePointer [
	<api>
	<cmacro: '() CFramePointer'>
	"and in the simulator we use..."
	^coInterpreter longAt: coInterpreter inMemoryCFramePointerAddress
]

{ #category : #accessing }
Cogit >> getCStackPointer [
	<api>
	<cmacro: '() CStackPointer'>
	"and in the simulator we use..."
	^coInterpreter longAt: coInterpreter inMemoryCStackPointerAddress
]

{ #category : #'translation support' }
Cogit >> halt [
	<cmacro: '() warning("halt")'>
	super halt
]

{ #category : #'translation support' }
Cogit >> halt: foo [
	<cmacro: '(msg) error("halt: " msg)'>
	super halt: foo
]

{ #category : #'simulation only' }
Cogit >> handleCallOrJumpSimulationTrap: aProcessorSimulationTrap [
	<doNotGenerate>
	| evaluable function result savedFramePointer savedStackPointer savedArgumentCount |
	evaluable := simulatedTrampolines at: aProcessorSimulationTrap address.
	function := evaluable
					isBlock ifTrue: ['aBlock; probably some plugin primitive']
					ifFalse: [evaluable selector].
	function ~~ #ceBaseFrameReturn: ifTrue:
		[coInterpreter assertValidExternalStackPointers].
	aProcessorSimulationTrap type = #call
		ifTrue:
			[processor
				simulateCallOf: aProcessorSimulationTrap address
				nextpc: aProcessorSimulationTrap nextpc
				memory: coInterpreter memory.
			self recordInstruction: {'(simulated call of '. aProcessorSimulationTrap address. '/'. function. ')'}]
		ifFalse:
			[processor
				simulateJumpCallOf: aProcessorSimulationTrap address
				memory: coInterpreter memory.
			 self recordInstruction: {'(simulated jump to '. aProcessorSimulationTrap address. '/'. function. ')'}].
	savedFramePointer := coInterpreter framePointer.
	savedStackPointer := coInterpreter stackPointer.
	savedArgumentCount := coInterpreter argumentCount.
	result := ["self halt: evaluable selector."
			   evaluable valueWithArguments: (processor
												postCallArgumentsNumArgs: evaluable numArgs
												in: coInterpreter memory)]
				on: ReenterMachineCode
				do: [:ex| ex return: ex returnValue].
	threadManager ifNotNil:
		[threadManager
			ensureProcessor: processor
			isInThread: Processor activeProcess].
			
	coInterpreter assertValidExternalStackPointers.
	"Verify the stack layout assumption compileInterpreterPrimitive: makes, provided we've
	 not called something that has built a frame, such as closure value or evaluate method, or
	 switched frames, such as primitiveSignal, primitiveWait, primitiveResume, primitiveSuspend et al."
	(function beginsWith: 'primitive') ifTrue:
		[coInterpreter primFailCode = 0
			ifTrue: [(#(	primitiveClosureValue primitiveClosureValueWithArgs primitiveClosureValueNoContextSwitch
						primitiveSignal primitiveWait primitiveResume primitiveSuspend primitiveYield
						primitiveExecuteMethodArgsArray primitiveExecuteMethod
						primitivePerform primitivePerformWithArgs primitivePerformInSuperclass
						primitiveTerminateTo primitiveStoreStackp primitiveDoPrimitiveWithArgs)
							includes: function) ifFalse:
						[self assert: savedFramePointer = coInterpreter framePointer.
						 self assert: savedStackPointer + (savedArgumentCount * BytesPerWord)
								= coInterpreter stackPointer]]
			ifFalse:
				[self assert: savedFramePointer = coInterpreter framePointer.
				 self assert: savedStackPointer = coInterpreter stackPointer]].
	self assert: (result isInteger "an oop result"
			or: [result == coInterpreter
			or: [#(nil continue continueNoReturn) includes: result]]).
	processor cResultRegister: (result isInteger ifTrue: [result] ifFalse: [16rF00BA222]).
	result ~~ #continueNoReturn ifTrue:
		[self recordInstruction: {'(simulated return to '. processor retpcIn: coInterpreter memory. ')'}.
		 self assert: (processor retpcIn: coInterpreter memory) < methodZone zoneLimit.
		 processor simulateReturnIn: coInterpreter memory]

	"coInterpreter cr.
	 processor sp + 32 to: processor sp - 32 by: -4 do:
		[:sp|
		 sp = processor sp
			ifTrue: [coInterpreter print: 'sp->'; tab]
			ifFalse: [coInterpreter printHex: sp].
		 coInterpreter tab; printHex: (coInterpreter longAt: sp); cr]"
]

{ #category : #'simulation only' }
Cogit >> handleReadSimulationTrap: aProcessorSimulationTrap [
	<doNotGenerate>
	| variableValue |
	variableValue := (simulatedVariableGetters at: aProcessorSimulationTrap address) value asInteger.
	processor
		perform: aProcessorSimulationTrap registerAccessor
		with: variableValue signedIntToLong.
	processor pc: aProcessorSimulationTrap nextpc
]

{ #category : #'simulation only' }
Cogit >> handleSimulationTrap: aProcessorSimulationTrap [
	<doNotGenerate>
	coInterpreter isThreadedVM ifTrue:
		[coInterpreter assertCStackPointersBelongToCurrentThread.
		 coInterpreter assertCStackPointersBelongToCurrentVMOwner].
	aProcessorSimulationTrap type caseOf:
		{ [#read] -> [self handleReadSimulationTrap: aProcessorSimulationTrap].
		  [#write] -> [self handleWriteSimulationTrap: aProcessorSimulationTrap].
		  [#call] -> [self handleCallOrJumpSimulationTrap: aProcessorSimulationTrap].
		  [#jump] -> [self handleCallOrJumpSimulationTrap: aProcessorSimulationTrap] }
]

{ #category : #'simulation only' }
Cogit >> handleWriteSimulationTrap: aProcessorSimulationTrap [ 
	<doNotGenerate>
	| variableValue |
	variableValue := processor perform: aProcessorSimulationTrap registerAccessor.
	(simulatedVariableSetters at: aProcessorSimulationTrap address) value: variableValue.
	processor pc: aProcessorSimulationTrap nextpc
]

{ #category : #compaction }
Cogit >> incrementUsageOfTargetIfLinkedSend: annotation mcpc: mcpc ignored: superfluity [
	<var: #mcpc type: #'char *'>
	| entryPoint offset targetMethod |
	<var: #targetMethod type: #'CogMethod *'>
	annotation = IsSendCall ifTrue:
		[entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
		 entryPoint > methodZoneBase ifTrue: "It's a linked send."
			[offset := (entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
						ifTrue: [cmEntryOffset]
						ifFalse: [cmNoCheckEntryOffset].
			targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
			targetMethod cmUsageCount < (CMMaxUsageCount // 2) ifTrue:
				[targetMethod cmUsageCount: targetMethod cmUsageCount + 1]]].
	^0 "keep scanning"
]

{ #category : #'generate machine code' }
Cogit >> initialClosedPICUsageCount [
	"Answer a usage count that reflects likely long-term usage."
	^2
]

{ #category : #'generate machine code' }
Cogit >> initialMethodUsageCount [
	"Answer a usage count that reflects likely long-term usage.
	 Answer 0 for non-primitives or quick primitives (inst var accessors),
	 1 for methods with interpreter primitives, and 2 for compiled primitives."
	(primitiveIndex = 0
	 or: [coInterpreter isQuickPrimitiveIndex: primitiveIndex]) ifTrue:
		[^0].
	self primitiveGeneratorOrNil isNil ifTrue:
		[^1].
	^2
]

{ #category : #'generate machine code' }
Cogit >> initialOpenPICUsageCount [
	"Answer a usage count that reflects likely long-term usage."
	^3
]

{ #category : #initialization }
Cogit >> initializeCodeZoneFrom: startAddress upTo: endAddress [
	<api>
	self cCode: 'sqMakeMemoryExecutableFromTo(startAddress,endAddress)'
		inSmalltalk: [self initializeProcessor].
	codeBase := methodZoneBase := startAddress + (self cCode: '0' inSmalltalk: [guardPageSize]).
	methodLabel machineCodeSize: 0.
	methodLabel opcode: Label.
	methodLabel operands at: 0 put: 0.
	methodLabel operands at: 1 put: 0. "label offset"
	self maybeGenerateCheckFeatures.
	self maybeGenerateICacheFlush.
	self cPreprocessorDirective: '#if COGMTVM'.
	self cCode: 'generateVMOwnerLockFunctions()'
		inSmalltalk: [coInterpreter isThreadedVM ifTrue:
						[self generateVMOwnerLockFunctions]].
	self cPreprocessorDirective: '#endif'.
	ceGetSP := self cCoerceSimple: self genGetLeafCallStackPointer to: #'unsigned long (*)(void)'.
	self generateStackPointerCapture.
	self generateTrampolines.
	self checkPrimitiveTableEnablers.
	methodZone manageFrom: methodZoneBase to: endAddress.
	self computeEntryOffsets.
	self generateClosedPICPrototype.
	self generateOpenPICPrototype
]

{ #category : #initialization }
Cogit >> initializeProcessor [
	"Initialize the simulation processor, arranging that its initial stack is somewhere on the rump C stack."
	<doNotGenerate>
	guardPageSize := 1024.
	lastNInstructions := OrderedCollection new.
	"This is for testing.  On many OS's the stack must remain aligned when
	 entering certain system routines, e.g. on Mac OS X the alignment is
	 16 bytes and must be so aligned on entry into the dynamic linker."
	Smalltalk platformName
		caseOf:
			{ ['Mac OS']	->	[expectedSPAlignment := 0. expectedFPAlignment := 8. cStackAlignment := 16] }
		otherwise: "Mac OS is a good default.  It has a non-trivial alignment restriction."
			[expectedSPAlignment := 0. expectedFPAlignment := 8. cStackAlignment := 16].
	processor class setStackAlignmentDelta: cStackAlignment.
	self initializeProcessorStack: coInterpreter rumpCStackAddress.
	coInterpreter
		longAt: self cFramePointerAddress put: processor fp;
		longAt: self cStackPointerAddress put: processor sp
]

{ #category : #initialization }
Cogit >> initializeProcessorStack: rumpCStackAddress [
	"Initialize the simulation processor's stack pointers, arranging that they are somewhere on the rump C stack."
	<doNotGenerate>
	| stackPad cFramePointer cStackPointer |
	stackPad := 64 max: cStackAlignment.
	cStackPointer := rumpCStackAddress - stackPad + expectedSPAlignment.
	cFramePointer := rumpCStackAddress - stackPad + cStackAlignment + expectedFPAlignment.
	self assert: cStackPointer \\ cStackAlignment = expectedSPAlignment.
	self assert: cFramePointer \\ cStackAlignment = expectedFPAlignment.
	processor setFramePointer: cFramePointer stackPointer: cStackPointer
]

{ #category : #'in-line cacheing' }
Cogit >> interpretOffset [
	<api>
	^missOffset
]

{ #category : #initialization }
Cogit >> isCFramePointerInUse [
	<doNotGenerate>
	"This should be implemented externally, e.g. in sqPlatMain.c."
	^true
]

{ #category : #'jit - api' }
Cogit >> isSendReturnPC: retpc [
	<api>
	"Answer if the instruction preceeding retpc is a call instruction."
	| target |
	false
		ifTrue:
			[(backEnd isCallPreceedingReturnPC: retpc) ifFalse:
				[^false]]
		ifFalse: [self assert: (backEnd isCallPreceedingReturnPC: retpc)].
	target := backEnd callTargetFromReturnAddress: retpc.
	^(target between: firstSend and: lastSend)
	   or: [target between: methodZoneBase and: methodZone zoneLimit]
]

{ #category : #disassembly }
Cogit >> labelForPC: address [
	<doNotGenerate>
	^address < methodZoneBase ifTrue:
		[self lookupAddress: address]
]

{ #category : #'simulation only' }
Cogit >> labelForSimulationAccessor: blockOrMessageSendOrSelector [
	<doNotGenerate>
	^'&', (blockOrMessageSendOrSelector isBlock
			ifTrue: ['block in ', blockOrMessageSendOrSelector method selector]
			ifFalse: [blockOrMessageSendOrSelector isMessageSend
						ifTrue: [blockOrMessageSendOrSelector selector]
						ifFalse: [blockOrMessageSendOrSelector]])
]

{ #category : #'compile abstract instructions' }
Cogit >> lastOpcode [
	<returnTypeC: #'AbstractInstruction *'>
	self assert: opcodeIndex > 0.
	^self abstractInstructionAt: opcodeIndex - 1
]

{ #category : #'in-line cacheing' }
Cogit >> linkSendAt: callSiteReturnAddress in: sendingMethod to: targetMethod checked: checked receiver: receiver [
	<api>
	<var: #sendingMethod type: #'CogMethod *'>
	<var: #targetMethod type: #'CogMethod *'>
	| inlineCacheTag address extent |
	self assert: (callSiteReturnAddress between: methodZoneBase and: methodZone zoneLimit).
	inlineCacheTag := checked
						ifTrue: [objectRepresentation inlineCacheTagForInstance: receiver]
						ifFalse: [targetMethod selector "i.e. no change"].
	(sendingMethod cmRefersToYoung not
	 and: [(objectRepresentation inlineCacheTagIsYoung: inlineCacheTag)]) ifTrue:
		[self assert: (methodZone occurrencesInYoungReferrers: sendingMethod) = 0.
		 sendingMethod cmRefersToYoung: true.
		 methodZone addToYoungReferrers: sendingMethod].
	address := targetMethod asInteger
				+ (checked ifTrue: [cmEntryOffset] ifFalse: [cmNoCheckEntryOffset]).
	extent := backEnd
				rewriteInlineCacheAt: callSiteReturnAddress
				tag: inlineCacheTag
				target: address.
	processor
		flushICacheFrom: callSiteReturnAddress - 1 - extent
		to: callSiteReturnAddress - 1
]

{ #category : #disassembly }
Cogit >> lookupAddress: address [
	<doNotGenerate>
	| cogMethod |
	address < methodZone zoneLimit ifTrue:
		[address >= methodZoneBase
			ifTrue:
				[(cogMethod := methodZone methodFor: address) ~= 0 ifTrue:
					[cogMethod := self cCoerceSimple: cogMethod to: #'CogMethod *'.
					 ^((cogMethod selector ~= coInterpreter nilObject
					    and: [objectRepresentation couldBeObject: cogMethod selector])
						ifTrue: [coInterpreter stringOf: cogMethod selector]
						ifFalse: [cogMethod asInteger hex]),
					   '@', ((address - cogMethod asInteger) hex allButFirst: 3)]]
			ifFalse:
				[^address = (self codeEntryFor: address) ifTrue:
					[self codeEntryNameFor: address]].
		 ^nil].
	(simulatedTrampolines includesKey: address) ifTrue:
		[^self labelForSimulationAccessor: (simulatedTrampolines at: address)].
	(simulatedVariableGetters includesKey: address) ifTrue:
		[^self labelForSimulationAccessor: (simulatedVariableGetters at: address)].
	^coInterpreter lookupAddress: address
]

{ #category : #'in-line cacheing' }
Cogit >> lookupAndCog: selector for: receiver [
	"Lookup selector in the class of receiver.  If not found answer nil.
	 If found try to compile it to machine code if appropriate.  Answer
	 the method."
	| newTargetMethodOrNil |
	<inline: false>
	newTargetMethodOrNil := coInterpreter lookup: selector receiver: receiver.
	(newTargetMethodOrNil notNil
	 and: [(coInterpreter methodHasCogMethod: newTargetMethodOrNil) not
	 and: [coInterpreter methodShouldBeCogged: newTargetMethodOrNil]]) ifTrue:
		["We assume cog:selector: will *not* reclaim the method zone"
		 self cog: newTargetMethodOrNil selector: selector].
	^newTargetMethodOrNil
]

{ #category : #disassembly }
Cogit >> lookupCHexString: aCHexString [ 
	<doNotGenerate>
	(aCHexString beginsWith: '0x') ifFalse:
		[^aCHexString].
	^(self lookupAddress: (Number
								readFrom: (aCHexString copyFrom: 3 to: aCHexString size) asUppercase readStream
								base: 16))
		ifNotNil: [:string| aCHexString, '=', string]
		ifNil: [aCHexString]
]

{ #category : #'method map' }
Cogit >> mapAt: mapStart methodObj: aMethodObj startmcpc: startmcpc bcpc: startbcpc performUntil: functionSymbol arg: arg [
	"Evaluate functionSymbol for each mcpc, bcpc pair in the map until the function returns non-zero,
	 or 0 if it fails to."
	<api>
	<var: #functionSymbol declareC: 'sqInt (*functionSymbol)(char annotation, char *mcpc, sqInt bcpc, sqInt numBytes, void *arg)'>
	<var: #arg type: #'void *'>
	| mcpc bcpc endbcpc map mapByte firstTime |
	<var: #descriptor type: #'BytecodeDescriptor *'>
	map := mapStart.
	mcpc := startmcpc.
	bcpc := startbcpc.
	endbcpc := coInterpreter byteSizeOf: aMethodObj.
	firstTime := true.
	[(mapByte := coInterpreter byteAt: map) ~= MapEnd] whileTrue:
		[| annotation bcpcArg result descriptor numBytes |
		 mapByte >= FirstAnnotation
			ifTrue:
				[annotation := mapByte >> AnnotationShift.
				mcpc := mcpc + (mapByte bitAnd: DisplacementMask).
				(annotation = HasBytecodePC or: [annotation = IsSendCall])
					ifTrue:
						[| byte |
						bcpcArg := bcpc.
						byte := coInterpreter fetchByte: bcpc ofObject: aMethodObj.
						descriptor := self generatorAt: byte.
						numBytes := descriptor numBytes.
						 (bcpc = startbcpc
						  and: [descriptor isMapped
						  and: [firstTime]])
							ifTrue:
								["horrible special case for frame-building accessors in contexts, e.g.
								  MethodContext>>method.  In this case the first bytecode is mapped
								  and so counts twice, once for the stackCheckOffset and once for itself."
								 firstTime := false]
							ifFalse:
								[bcpc := self nextBytecodePCFor: descriptor at: bcpc byte0: byte in: aMethodObj.
								 bcpc := self nextBytecodePCInMapAfter: bcpc
											in: aMethodObj
											upTo: endbcpc].
						 self assert: bcpcArg ~= 0]
					ifFalse: [bcpcArg := numBytes := 0].
				 result := self perform: functionSymbol
								with: annotation
								with: (self cCoerceSimple: mcpc to: #'char *')
								with: bcpcArg
								with: numBytes
								with: arg.
				 result ~= 0 ifTrue:
					[^result]]
			ifFalse:
				[mcpc := mcpc + (mapByte >= DisplacementX2N
									ifTrue: [mapByte - DisplacementX2N << AnnotationShift]
									ifFalse: [mapByte])].
		 map := map - 1].
	^0
]

{ #category : #disassembly }
Cogit >> mapEndFor: cogMethod [
	"Answer the address of the null byte at the end of the method map."
	<var: #cogMethod type: #'CogMethod *'>
	| end |
	<inline: true>
	end := cogMethod asInteger + cogMethod blockSize - 1.
	[(coInterpreter byteAt: end) ~= MapEnd] whileTrue:
		[end := end - 1.
		 self assert: end > (cogMethod asInteger + cmNoCheckEntryOffset)].
	^end
]

{ #category : #'method map' }
Cogit >> mapFor: cogMethod performUntil: functionSymbol arg: arg [
	"Disassembly/GC support"
	<var: #cogMethod type: #'CogMethod *'>
	<var: #functionSymbol declareC: 'int (*functionSymbol)(sqInt annotation, char *mcpc, sqInt arg)'>
	| mcpc map mapByte result |
	mcpc := cogMethod asInteger + cmNoCheckEntryOffset.
	map := cogMethod asInteger + cogMethod blockSize - 1.
	[(mapByte := coInterpreter byteAt: map) ~= MapEnd] whileTrue:
		[mapByte >= FirstAnnotation
			ifTrue:
				[mcpc := mcpc + (mapByte bitAnd: DisplacementMask).
				 result := self perform: functionSymbol
							   with: mapByte >> AnnotationShift
							   with: (self cCoerceSimple: mcpc to: #'char *')
							   with: arg.
				 result ~= 0 ifTrue:
					[^result]]
			ifFalse:
				[mcpc := mcpc + (mapByte >= DisplacementX2N
									ifTrue: [mapByte - DisplacementX2N << AnnotationShift]
									ifFalse: [mapByte])].
		 map := map - 1].
	^0
]

{ #category : #'garbage collection' }
Cogit >> mapObjectReferencesInClosedPIC: cPIC [
	<var: #cPIC type: #'CogMethod *'>
	| pc |
	pc := cPIC asInteger + firstCPICCaseOffset.
	self updateMaybeObjRefAt: pc - backEnd jumpLongByteSize.
	pc := pc + cPICCaseSize.
	2 to: cPIC cPICNumCases do:
		[:i|
		self updateMaybeObjRefAt: pc - backEnd jumpLongConditionalByteSize - backEnd loadLiteralByteSize.
		self updateMaybeObjRefAt: pc - backEnd jumpLongConditionalByteSize.
		pc := pc + cPICCaseSize].
	^false
]

{ #category : #'jit - api' }
Cogit >> mapObjectReferencesInMachineCode: inFullGC [
	<api>
	"Update all references to objects in machine code."
	inFullGC
		ifTrue: [self mapObjectReferencesInMachineCodeForFullGC]
		ifFalse: [self mapObjectReferencesInMachineCodeForIncrementalGC]
]

{ #category : #'garbage collection' }
Cogit >> mapObjectReferencesInMachineCodeForFullGC [
	"Update all references to objects in machine code for a full gc."
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	codeModified := false.
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType ~= CMFree ifTrue:
			[self assert: (self cogMethodDoesntLookKosher: cogMethod) = 0.
			 cogMethod selector: (objectRepresentation remapOop: cogMethod selector).
			 cogMethod cmType = CMClosedPIC
				ifTrue:
					[self mapObjectReferencesInClosedPIC: cogMethod]
				ifFalse:
					[cogMethod cmType = CMMethod ifTrue:
						[self assert: cogMethod objectHeader = coInterpreter nullHeaderForMachineCodeMethod.
						 cogMethod methodObject: (objectRepresentation remapOop: cogMethod methodObject)].
					 self mapFor: cogMethod
						 performUntil: #remapIfObjectRef:pc:hasYoung: asSymbol
						 arg: 0.
					 (cogMethod cmRefersToYoung
					  and: [objectRepresentation allYoungObjectsAgeInFullGC]) ifTrue:
						[cogMethod cmRefersToYoung: false]]].
		cogMethod := methodZone methodAfter: cogMethod].
	methodZone pruneYoungReferrers.
	codeModified ifTrue: "After updating oops in inline caches we need to flush the icache."
		[processor flushICacheFrom: methodZoneBase to: methodZone limitZony asInteger]
]

{ #category : #'garbage collection' }
Cogit >> mapObjectReferencesInMachineCodeForIncrementalGC [
	"Update all references to objects in machine code for an incremental gc."
	| pointer cogMethod hasYoungObj hasYoungObjPtr |
	<var: #cogMethod type: #'CogMethod *'>
	<doNotGenerate: 'hasYoungObjPtr'>
	self cPreprocessorDirective: '#define hasYoungObjPtr (sqInt)&hasYoungObj'.
	hasYoungObj := false.
	codeModified := false.
	self cCode: ''
		inSmalltalk: [hasYoungObjPtr := CPluggableAccessor new
										setObject: nil;
										atBlock: [:obj :idx| hasYoungObj]
										atPutBlock: [:obj :idx :val| hasYoungObj := val]].
	pointer := methodZone youngReferrers.
	[pointer < methodZone zoneEnd] whileTrue:
		[cogMethod := coInterpreter cCoerceSimple: (coInterpreter longAt: pointer) to: #'CogMethod *'.
		 cogMethod cmType = CMFree
			ifTrue: [self assert: cogMethod cmRefersToYoung not]
			ifFalse:
				[self assert: (self cogMethodDoesntLookKosher: cogMethod) = 0.
				 cogMethod cmRefersToYoung ifTrue:
					[self assert: (cogMethod cmType = CMMethod
								or: [cogMethod cmType = CMOpenPIC]).
					 cogMethod selector: (objectRepresentation remapOop: cogMethod selector).
					 (coInterpreter isYoung: cogMethod selector) ifTrue:
						[hasYoungObj := true].
					 cogMethod cmType = CMMethod ifTrue:
						[self assert: cogMethod objectHeader = coInterpreter nullHeaderForMachineCodeMethod.
						 cogMethod methodObject: (objectRepresentation remapOop: cogMethod methodObject).
						 (coInterpreter isYoung: cogMethod methodObject) ifTrue:
							[hasYoungObj := true]].
					 self mapFor: cogMethod
						 performUntil: #remapIfObjectRef:pc:hasYoung: asSymbol
						 arg: hasYoungObjPtr.
					 hasYoungObj
						ifTrue: [hasYoungObj := false]
						ifFalse: [cogMethod cmRefersToYoung: false]]].
		 pointer := pointer + BytesPerWord].
	methodZone pruneYoungReferrers.
	codeModified ifTrue: "After updating oops in inline caches we need to flush the icache."
		[processor flushICacheFrom: methodZoneBase to: methodZone limitZony asInteger].
	self cPreprocessorDirective: '#undef hasYoungObjPtr'
]

{ #category : #'simulation only' }
Cogit >> mapPrimitive: primitiveRoutine "<Symbol>" withIndexToUniqueAddress: primitiveIndex [ "<SmallInteger>"
	| uniqueAddress |
	<doNotGenerate>
	self assert: (primitiveRoutine isSymbol or: [primitiveRoutine isBlock]).
	uniqueAddress := -1 - methodZoneBase - (primitiveIndex * 4) - 16r1000 bitAnd: self addressSpaceMask.
	simulatedTrampolines
		at: uniqueAddress
		ifAbsentPut:
			[primitiveRoutine isSymbol
				ifTrue: [MessageSend receiver: coInterpreter selector: primitiveRoutine]
				ifFalse: [primitiveRoutine]].
	^uniqueAddress
]

{ #category : #'jit - api' }
Cogit >> markAndTraceMachineCodeForIncrementalGC [
	"Free any methods that refer to unmarked objects, unlinking sends to freed methods."
	| pointer cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	coInterpreter leakCheckIncrementalGC ifTrue:
		[self assert: self allMachineCodeObjectReferencesValid].
	codeModified := false.
	pointer := methodZone youngReferrers.
	[pointer < methodZone zoneEnd] whileTrue:
		[cogMethod := coInterpreter cCoerceSimple: (coInterpreter longAt: pointer) to: #'CogMethod *'.
		 cogMethod cmRefersToYoung ifTrue:
			[self assert: (self cogMethodDoesntLookKosher: cogMethod) = 0.
			 self assert: (cogMethod cmType = CMMethod
						or: [cogMethod cmType = CMOpenPIC]).
			 (coInterpreter isYoung: cogMethod selector) ifTrue:
				[coInterpreter markAndTrace: cogMethod selector].
			 cogMethod cmType = CMMethod ifTrue:
				[(coInterpreter isYoung: cogMethod methodObject) ifTrue:
					[coInterpreter markAndTrace: cogMethod methodObject].
				self markYoungObjectsIn: cogMethod]].
		 pointer := pointer + BytesPerWord].
	coInterpreter leakCheckIncrementalGC ifTrue:
		[self assert: self allMachineCodeObjectReferencesValid].
	codeModified ifTrue: "After updating oops in inline caches we need to flush the icache."
		[processor flushICacheFrom: methodZoneBase to: methodZone limitZony asInteger]
]

{ #category : #'jit - api' }
Cogit >> markAndTraceObjectsOrFreeMachineCode: inFullGC [
	<api>
	inFullGC
		ifTrue: [self markAndTraceOrFreeMachineCodeForFullGC]
		ifFalse: [self markAndTraceMachineCodeForIncrementalGC]
]

{ #category : #'garbage collection' }
Cogit >> markAndTraceOrFreeCogMethod: cogMethod firstVisit: firstVisit [
	"Mark and trace objects in the argument and free if it is appropriate.
	 Answer if the method has been freed.  firstVisit is a hint used to avoid
	 scanning methods we've already seen.  False positives are fine.
	 For a CMMethod this
			frees if the bytecode method isnt marked,
			marks and traces object literals and selectors,
			unlinks sends to targets that should be freed.
	 For a CMClosedPIC this
			frees if it refers to anything that should be freed or isn't marked.
	 For a CMOpenPIC this
			frees if the selector isn't marked."
	<var: #cogMethod type: #'CogMethod *'>
	<inline: false> "this recurses at most one level down"
	cogMethod cmType = CMFree ifTrue:
		[^true].
	self assert: (self cogMethodDoesntLookKosher: cogMethod) = 0.
	cogMethod cmType = CMMethod ifTrue:
		[(coInterpreter isMarked: cogMethod methodObject) ifFalse:
			[methodZone freeMethod: cogMethod.
			 ^true].
		 firstVisit ifTrue:
			[self markLiteralsAndUnlinkUnmarkedSendsIn: cogMethod].
		^false].
	cogMethod cmType = CMClosedPIC ifTrue:
		[(self closedPICRefersToUnmarkedObject: cogMethod) ifFalse:
			[^false].
		 methodZone freeMethod: cogMethod.
		 ^true].
	cogMethod cmType = CMOpenPIC ifTrue:
		[(coInterpreter isMarked: cogMethod selector) ifTrue:
			[^false].
		 methodZone freeMethod: cogMethod.
		 ^true].
	self assert: (cogMethod cmType = CMMethod
				or: [cogMethod cmType = CMClosedPIC
				or: [cogMethod cmType = CMOpenPIC]]).
	^false
]

{ #category : #'jit - api' }
Cogit >> markAndTraceOrFreeMachineCodeForFullGC [
	"Free any methods that refer to unmarked objects, unlinking sends to freed methods."
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	coInterpreter leakCheckFullGC ifTrue:
		[self assert: self allMachineCodeObjectReferencesValid].
	codeModified := false.
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[self markAndTraceOrFreeCogMethod: cogMethod firstVisit: true.
		 cogMethod := methodZone methodAfter: cogMethod].
	coInterpreter leakCheckFullGC ifTrue:
		[self assert: self allMachineCodeObjectReferencesValid].
	codeModified ifTrue: "After updating oops in inline caches we need to flush the icache."
		[processor flushICacheFrom: methodZoneBase to: methodZone limitZony asInteger]
]

{ #category : #'garbage collection' }
Cogit >> markLiteralsAndUnlinkIfUnmarkedSend: annotation pc: mcpc method: cogMethod [
	"Mark and trace literals.  Unlink sends that have unmarked cache tags or targets."
	<var: #mcpc type: #'char *'>
	| literal cacheTag cacheTagMarked entryPoint targetMethod offset sendTable unlinkedRoutine |
	<var: #targetMethod type: #'CogMethod *'>
	<var: #sendTable type: #'sqInt *'>
	annotation = IsObjectReference ifTrue:
		[literal := backEnd literalBeforeFollowingAddress: mcpc asInteger.
		 objectRepresentation markAndTraceLiteral: literal].
	annotation = IsSendCall ifTrue:
		[cacheTag := backEnd inlineCacheTagAt: mcpc asInteger.
		 cacheTagMarked := objectRepresentation cacheTagIsMarked: cacheTag.
		 objectRepresentation markAndTraceLiteral: cacheTag.
		 entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
		 entryPoint > methodZoneBase ifTrue: "It's a linked send."
			[(entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
				ifTrue: [offset := cmEntryOffset. sendTable := sendTrampolines]
				ifFalse: [offset := cmNoCheckEntryOffset. sendTable := superSendTrampolines].
			targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
			(cacheTagMarked not
			 or: [self markAndTraceOrFreeCogMethod: targetMethod firstVisit: targetMethod asUnsignedInteger > mcpc asUnsignedInteger]) ifTrue:
				["Either the cacheTag is unmarked (e.g. new class) or the target
				  has been freed (because it is unmarked) so unlink the send."
				 unlinkedRoutine := sendTable at: (targetMethod cmNumArgs min: NumSendTrampolines - 1).
				 backEnd
					rewriteInlineCacheAt: mcpc asInteger
					tag: targetMethod selector
					target: unlinkedRoutine.
				 codeModified := true.
				 objectRepresentation markAndTraceLiteral: targetMethod selector]]].
	^0 "keep scanning"
]

{ #category : #'garbage collection' }
Cogit >> markLiteralsAndUnlinkUnmarkedSendsIn: cogMethod [
	"Unlink sends that have unmarked classes in inline caches or freed/freeable targets.
	 Nil-out inline caches linked to open PICs.
	 Assert that any selectors are marked.  We can do this since
	 this is only run on marked methods and thus any selectors they
	 reference should already be marked."
	<var: #cogMethod type: #'CogMethod *'>
	<inline: true>
	self assert: cogMethod cmType = CMMethod.
	self assert: (coInterpreter isMarked: cogMethod methodObject).
	objectRepresentation markAndTraceLiteral: cogMethod selector.
	self mapFor: cogMethod
		 performUntil: #markLiteralsAndUnlinkIfUnmarkedSend:pc:method: asSymbol
		 arg: cogMethod asInteger
]

{ #category : #'jit - api' }
Cogit >> markMethodAndReferents: aCogMethod [
	<api>
	<var: #aCogMethod type: #'CogBlockMethod *'>
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	self assert: (aCogMethod cmType = CMMethod
				or: [aCogMethod cmType = CMBlock]).
	cogMethod := aCogMethod cmType = CMMethod
					ifTrue: [self cCoerceSimple: aCogMethod to: #'CogMethod *']
					ifFalse: [self cogHomeMethod: aCogMethod].
	cogMethod cmUsageCount: CMMaxUsageCount.
	self mapFor: cogMethod
		performUntil: #incrementUsageOfTargetIfLinkedSend:mcpc:ignored: asSymbol
		arg: 0
]

{ #category : #'garbage collection' }
Cogit >> markYoungObjects: annotation pc: mcpc method: cogMethod [
	"Mark and trace young literals."
	<var: #mcpc type: #'char *'>
	| literal cacheTag |
	annotation = IsObjectReference ifTrue:
		[literal := backEnd literalBeforeFollowingAddress: mcpc asInteger.
		 objectRepresentation markAndTraceLiteralIfYoung: literal].
	annotation = IsSendCall ifTrue:
		[cacheTag := backEnd inlineCacheTagAt: mcpc asInteger.
		 objectRepresentation markAndTraceLiteralIfYoung: cacheTag].
	^0 "keep scanning"
]

{ #category : #'garbage collection' }
Cogit >> markYoungObjectsIn: cogMethod [
	"Mark young literals in the method."
	<var: #cogMethod type: #'CogMethod *'>
	<inline: true>
	self assert: (cogMethod cmType = CMMethod
				or: [cogMethod cmType = CMOpenPIC]).
	 (coInterpreter isYoung: cogMethod selector) ifTrue:
		[coInterpreter markAndTrace: cogMethod selector].
	(cogMethod cmType = CMMethod
	 and: [coInterpreter isYoung: cogMethod methodObject]) ifTrue:
		[coInterpreter markAndTrace: cogMethod methodObject].
	self mapFor: cogMethod
		 performUntil: #markYoungObjects:pc:method: asSymbol
		 arg: cogMethod asInteger
]

{ #category : #debugging }
Cogit >> maxCogMethodAddress [
	<api>
	<returnTypeC: #usqInt>
	^methodZone limitZony asUnsignedInteger
]

{ #category : #debugging }
Cogit >> maybeFreeCogMethodDoesntLookKosher: cogMethod [
	"Check that the header fields are consistent with the type.
	 Answer 0 if it is ok, otherwise answer a code for the error."
	<var: #cogMethod type: #'CogMethod *'>
	| result |
	result := self cogMethodDoesntLookKosher: cogMethod.
	^result = 2 ifTrue: [0] ifFalse: [result]
]

{ #category : #initialization }
Cogit >> maybeGenerateCheckFeatures [
	| startAddress |
	<inline: false>
	backEnd numCheckFeaturesOpcodes = 0 ifTrue:
		[^nil].
	self allocateOpcodes: backEnd numCheckFeaturesOpcodes bytecodes: 0.
	initialPC := 0.
	endPC := numAbstractOpcodes - 1.
	startAddress := methodZoneBase.
	backEnd generateCheckFeatures.
	self outputInstructionsForGeneratedRuntimeAt: startAddress.
	self recordGeneratedRunTime: 'ceCheckFeaturesFunction' address: startAddress.
	ceCheckFeaturesFunction := self cCoerceSimple: startAddress to: #'unsigned long (*)(void)'
]

{ #category : #initialization }
Cogit >> maybeGenerateICacheFlush [
	| startAddress |
	<inline: false>
	backEnd numICacheFlushOpcodes = 0 ifTrue:
		[^nil].
	self allocateOpcodes: backEnd numICacheFlushOpcodes bytecodes: 0.
	initialPC := 0.
	endPC := numAbstractOpcodes - 1.
	startAddress := methodZoneBase.
	backEnd generateICacheFlush.
	self outputInstructionsForGeneratedRuntimeAt: startAddress.
	self recordGeneratedRunTime: 'ceFlushICache' address: startAddress.
	ceFlushICache := self cCoerceSimple: startAddress to: #'void (*)(unsigned long,unsigned long)'
]

{ #category : #'method map' }
Cogit >> mcpcToBcpcMapFor: cogMethod [
	<doNotGenerate>
	| mcpcToBcpcMap blockStartBcpcs |
	mcpcToBcpcMap := Dictionary new.
	cogMethod cmType ~= CMMethod ifTrue:
		[^mcpcToBcpcMap].
	blockStartBcpcs := self blockStartPcsIn: cogMethod methodObject.
	blockStartBcpcs
		with: ((self codeRangesFor: cogMethod) first: blockStartBcpcs size)
		do: [:bcpc :range| mcpcToBcpcMap at: range first put: bcpc].
	^mcpcToBcpcMap
]

{ #category : #'simulation only' }
Cogit >> methodZone [
	<doNotGenerate>
	^methodZone
]

{ #category : #debugging }
Cogit >> minCogMethodAddress [
	<api>
	^methodZoneBase
]

{ #category : #'in-line cacheing' }
Cogit >> mnuOffset [
	<api>
	^missOffset
]

{ #category : #'compile abstract instructions' }
Cogit >> nextBytecodePCFor: descriptor at: pc byte0: opcodeByte in: aMethodObj [
	"Compute the distance to the logically subsequent bytecode, i.e. skip over blocks."
	<var: #descriptor type: #'BytecodeDescriptor *'>
	<inline: true>
	^pc
		+ descriptor numBytes
		+ (descriptor isBlockCreation
			ifTrue: [self spanFor: descriptor at: pc byte0: opcodeByte in: aMethodObj]
			ifFalse: [0])
]

{ #category : #'method map' }
Cogit >> nextBytecodePCInMapAfter: startbcpc in: methodObject upTo: endpc [ 
	| bcpc descriptor byte |
	<var: #descriptor type: #'BytecodeDescriptor *'>
	bcpc := startbcpc.
	[bcpc <= endpc] whileTrue:
		[byte := coInterpreter fetchByte: bcpc ofObject: methodObject.
		 descriptor := self generatorAt: byte.
		 descriptor isMapped ifTrue:
			[^bcpc].
		 bcpc := self nextBytecodePCFor: descriptor at: bcpc byte0: byte in: methodObject].
	^0
]

{ #category : #accessing }
Cogit >> noCheckEntryOffset [
	<api>
	<cmacro: '() cmNoCheckEntryOffset'>
	^cmNoCheckEntryOffset
]

{ #category : #compaction }
Cogit >> noCogMethodsMaximallyMarked [
	"Check that no metod is maximally marked.  A maximal mark is an indication the
	 method has been scanned to increase the usage count of its referent methods."
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[(cogMethod cmType ~= CMFree
		  and: [cogMethod cmUsageCount = CMMaxUsageCount]) ifTrue:
			[^false].
		 cogMethod := methodZone methodAfter: cogMethod].
	^true
]

{ #category : #accessing }
Cogit >> noContextSwitchBlockEntryOffset [
	<api>
	<cmacro: '() blockNoContextSwitchOffset'>
	self assert: blockNoContextSwitchOffset ~= 0.
	^blockNoContextSwitchOffset
]

{ #category : #compaction }
Cogit >> noTargetsFreeInClosedPIC: cPIC [
	"Answerr if all targets in the PIC are in-use methods."
	<var: #cPIC type: #'CogMethod *'>
	| pc entryPoint targetMethod |
	<var: #targetMethod type: #'CogMethod *'>
	pc := cPIC asInteger + firstCPICCaseOffset.
	1 to: cPIC cPICNumCases do:
		[:i|
		entryPoint := backEnd jumpLongTargetBeforeFollowingAddress: pc.
		"Find target from jump.  Ignore jumps to the interpret and MNU calls within this PIC"
		(entryPoint < cPIC asInteger
		 or: [entryPoint > (cPIC asInteger + cPIC blockSize)]) ifTrue:
			[targetMethod := self cCoerceSimple: entryPoint - cmNoCheckEntryOffset to: #'CogMethod *'.
			 targetMethod cmType ~= CMMethod ifTrue:
				[^false]].
		i < cPIC cPICNumCases ifTrue:
			[pc := pc + cPICCaseSize]].
	^true
]

{ #category : #'translation support' }
Cogit >> notYetImplemented [
	<cmacro: '() warning("not yet implemented")'>
	super notYetImplemented
]

{ #category : #'simulation only' }
Cogit >> offset: aClass of: fieldSymbol [
	"This is implemented by stddef's offsetof macro."
	<doNotGenerate>
	^aClass caseOf:
		{ [CogMethod] -> [self cogMethodSurrogateClass offsetOf: fieldSymbol] }
]

{ #category : #'generate machine code' }
Cogit >> outputInstructionsAt: startAddress [
	"Store the generated machine code, answering the last address"
	| absoluteAddress |
	<var: #abstractInstruction type: #'AbstractInstruction *'>
	absoluteAddress := startAddress.
	0 to: opcodeIndex - 1 do:
		[:i| | abstractInstruction |
		abstractInstruction := self abstractInstructionAt: i.
		self assert: abstractInstruction address = absoluteAddress.
		0 to: abstractInstruction machineCodeSize - 1 do:
			[:j|
			coInterpreter byteAt: absoluteAddress put: (abstractInstruction machineCode at: j).
			absoluteAddress := absoluteAddress + 1]].
	^absoluteAddress
]

{ #category : #initialization }
Cogit >> outputInstructionsForGeneratedRuntimeAt: startAddress [
	"Output instructions generated for one of the generated run-time routines, a trampoline, etc"
	| size endAddress |
	<inline: false>
	self computeMaximumSizes.
	size := self generateInstructionsAt: startAddress.
	endAddress := self outputInstructionsAt: startAddress.
	self assert: startAddress + size = endAddress.
	methodZoneBase := self alignUptoRoutineBoundary: endAddress.
	backEnd nopsFrom: endAddress to: methodZoneBase - 1.
	self cCode: '' inSmalltalk: [methodZone zoneLimit: methodZoneBase].
	^startAddress
]

{ #category : #'in-line cacheing' }
Cogit >> patchToOpenPICFor: selector numArgs: numArgs receiver: receiver [
	"Code entry closed PIC full or miss to an instance of a young class or to a young target method.
	 Attempt to patch the send site to an open PIC.  Answer if the attempt succeeded; in fact it will
	 only return if the attempt failed.
	 The stack looks like:
			receiver
			args
	 sp=>	sender return address"
	<api>
	| oPIC outerReturn extent |
	<var: #oPIC type: #'CogMethod *'>
	outerReturn := coInterpreter stackTop.
	"See if an Open PIC is already available."
	oPIC := methodZone openPICWithSelector: selector.
	oPIC isNil ifTrue:
		["otherwise attempt to create an Open PIC."
		oPIC := self cogOpenPICSelector: selector numArgs: numArgs.
		(oPIC asInteger between: MaxNegativeErrorCode and: -1) ifTrue:
			["For some reason the PIC couldn't be generated, most likely a lack of code memory."
			oPIC asInteger = InsufficientCodeSpace ifTrue:
				[coInterpreter callForCogCompiledCodeCompaction].
			^false]].
	extent := backEnd
				rewriteInlineCacheAt: outerReturn
				tag: selector
				target: oPIC asInteger + cmEntryOffset.
	processor
		flushICacheFrom: outerReturn - 1 - extent to: outerReturn - 1;
		flushICacheFrom: oPIC asInteger to: oPIC asInteger + openPICSize.
	"Jump into the oPIC at its entry"
	coInterpreter executeCogMethodFromLinkedSend: oPIC withReceiver: receiver.
	"NOTREACHED"
	^true
]

{ #category : #disassembly }
Cogit >> pc: address isWithinMethod: cogMethod [
	<api>
	<var: #address type: #'char *'>
	<var: #cogMethod type: #'CogMethod *'>
	^address asInteger
		between: cogMethod asInteger + (self sizeof: CogMethod)
		and: cogMethod asInteger + cogMethod blockSize
]

{ #category : #'compile abstract instructions' }
Cogit >> primitiveGeneratorOrNil [
	"If there is a generator for the current primitive then answer it;
	 otherwise answer nil."
	<returnTypeC: #'PrimitiveDescriptor *'>
	| primitiveDescriptor |
	<var: #primitiveDescriptor type: #'PrimitiveDescriptor *'>
	(coInterpreter isQuickPrimitiveIndex: primitiveIndex) ifTrue:
		[primitiveDescriptor := self addressOf: (primitiveGeneratorTable at: 0). "an unused one"
		 primitiveDescriptor primitiveGenerator: (coInterpreter quickPrimitiveGeneratorFor: primitiveIndex).
		 ^primitiveDescriptor].
	(primitiveIndex between: 1 and: MaxCompiledPrimitiveIndex) ifTrue:
		[^self addressOf: (primitiveGeneratorTable at: primitiveIndex)].
	^nil
]

{ #category : #printing }
Cogit >> print: aString [
	<cmacro: '(aString) printf(aString)'>
	coInterpreter transcript print: aString
]

{ #category : #printing }
Cogit >> printCogMethodFor: address [
	<api>
	<var: #address type: #'void *'>
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	cogMethod := methodZone methodFor: address.
	cogMethod = 0
		ifTrue: [coInterpreter print: 'not a method'; cr]
		ifFalse: [coInterpreter printCogMethod: cogMethod]
]

{ #category : #disassembly }
Cogit >> printInstructions: aBoolean [
	<doNotGenerate>
	printInstructions := aBoolean.
	singleStep := singleStep or: [aBoolean]
]

{ #category : #disassembly }
Cogit >> printMapEntry: annotation mcpc: mcpc args: tupleOfStreamCodeRangesAndMethod [
	"Print the Map entry's mcpc, its annotation and the corresponding bytecode pc, if any."
	<doNotGenerate>
	[:aStream :codeRanges :cogMethod|
	self startMcpcAndCogMethodForMcpc: mcpc in: cogMethod do:
		[:startmcpc :subMethod| | name codeRange |
		"Find the start of the block by searching the code ranges."
		codeRange := codeRanges detect: [:range| range includes: mcpc].
		codeRange first = mcpc ifTrue:
			[aStream nextPutAll: 'startpc: '; print: codeRange startpc; cr].
		aStream
			next: 2 put: Character space;
			nextPutAll: mcpc hex;  space;
			nextPutAll: (name := self class annotationConstantNames at: annotation + 1);
			next: 20 - name size put: Character space;
			nextPut: $(;
			nextPutAll: (self findMapLocationForMcpc: mcpc inMethod: cogMethod) hex.
		cogMethod cmType ~= CMOpenPIC ifTrue:
			[aStream
				nextPutAll: ', bc: ';
				print: (self bytecodePCFor: mcpc startBcpc: codeRange startpc in: subMethod)].
		aStream
			nextPut: $);
			cr; flush]]
		valueWithArguments: tupleOfStreamCodeRangesAndMethod.
	^0
]

{ #category : #disassembly }
Cogit >> printMethodHeader: cogMethod on: aStream [
	<doNotGenerate>
	self cCode: ''
		inSmalltalk:
			[cogMethod isInteger ifTrue:
				[^self printMethodHeader: (coInterpreter cogMethodSurrogateAt: cogMethod) on: aStream]].
	cogMethod asInteger printOn: aStream base: 16.
	aStream crtab; nextPutAll: (cogMethod cmType ~= CMBlock ifTrue: ['objhdr: '] ifFalse: ['homemth: ']).
	cogMethod objectHeader printOn: aStream base: 16.
	aStream
		crtab; nextPutAll: 'nArgs: ';	print: cogMethod cmNumArgs;
		tab;    nextPutAll: 'type: ';	print: cogMethod cmType.
	cogMethod cmType ~= CMBlock ifTrue:
		[aStream crtab; nextPutAll: 'blksiz: '.
		cogMethod blockSize printOn: aStream base: 16.
		aStream crtab; nextPutAll: 'method: '.
		cogMethod methodObject printOn: aStream base: 16.
		aStream crtab; nextPutAll: 'mthhdr: '.
		cogMethod methodHeader printOn: aStream base: 16.
		aStream crtab; nextPutAll: 'selctr: '.
		cogMethod selector printOn: aStream base: 16.
		(coInterpreter lookupAddress: cogMethod selector) ifNotNil:
			[:string| aStream nextPut: $=; nextPutAll: string].
		aStream crtab; nextPutAll: 'blkentry: '.
		cogMethod blockEntryOffset printOn: aStream base: 16.
		cogMethod blockEntryOffset ~= 0 ifTrue:
			[aStream nextPutAll: ' => '.
			 cogMethod asInteger + cogMethod blockEntryOffset printOn: aStream base: 16]].
	cogMethod cmType = CMClosedPIC
		ifTrue:
			[aStream crtab; nextPutAll: 'cPICNumCases: '.
			 cogMethod cPICNumCases printOn: aStream base: 16.]
		ifFalse:
			[aStream crtab; nextPutAll: 'stackCheckOffset: '.
			 cogMethod stackCheckOffset printOn: aStream base: 16.
			 cogMethod stackCheckOffset > 0 ifTrue:
				[aStream nextPut: $/.
				 cogMethod asInteger + cogMethod stackCheckOffset printOn: aStream base: 16]].
	aStream cr; flush
]

{ #category : #printing }
Cogit >> printNum: n [
	<cmacro: '(n) printf("%ld", (long) n)'>
	coInterpreter transcript printNum: n
]

{ #category : #debugging }
Cogit >> printOnTrace [
	<api>
	^(traceLinkedSends bitAnd: 4) ~= 0
]

{ #category : #debugging }
Cogit >> printRegisters: aBoolean [
	<doNotGenerate>
	printRegisters := aBoolean
]

{ #category : #debugging }
Cogit >> printTrampolineTable [
	<api>
	0 to: trampolineTableIndex - 1 by: 2 do:
		[:i|
		coInterpreter
			printHex: (trampolineAddresses at: i + 1) asInteger;
			print: ': ';
			print: (trampolineAddresses at: i);
			cr]
]

{ #category : #accessing }
Cogit >> processor [
	<doNotGenerate>
	^processor
]

{ #category : #initialization }
Cogit >> processorHasDivQuoRem: ignoredPrimIndex [ 
	^backEnd canDivQuoRem
]

{ #category : #initialization }
Cogit >> processorHasDoublePrecisionFloatingPointSupport: ignoredPrimIndex [ 
	^backEnd hasDoublePrecisionFloatingPointSupport
]

{ #category : #initialization }
Cogit >> processorHasMultiply: ignoredPrimIndex [ 
	^backEnd canMulRR
]

{ #category : #debugging }
Cogit >> recordEventTrace [
	<api>
	<cmacro: '() (traceLinkedSends & 4)'>
	^(traceLinkedSends bitAnd: 4) ~= 0
]

{ #category : #initialization }
Cogit >> recordGeneratedRunTime: aString address: address [
	<var: #aString type: #'char *'>
	trampolineAddresses
		at: trampolineTableIndex put: aString;
		at: trampolineTableIndex + 1 put: (self cCoerceSimple: address to: #'char *').
	trampolineTableIndex := trampolineTableIndex + 2
]

{ #category : #'simulation only' }
Cogit >> recordInstruction: thing [
	<doNotGenerate>
	lastNInstructions addLast: thing.
	[lastNInstructions size > 160"80"] whileTrue:
		[lastNInstructions removeFirst.
		 lastNInstructions size * 2 > lastNInstructions capacity ifTrue:
			[lastNInstructions makeRoomAtLast]]
]

{ #category : #'simulation only' }
Cogit >> recordLastInstruction [
	<doNotGenerate>
	self recordInstruction: (processor disassembleNextInstructionIn: coInterpreter memory for: self)
]

{ #category : #debugging }
Cogit >> recordPrimTrace [
	<api>
	<cmacro: '() (traceLinkedSends & 2)'>
	^(traceLinkedSends bitAnd: 2) ~= 0
]

{ #category : #debugging }
Cogit >> recordPrimTraceFunc [
	"This one for C support code."
	<api>
	^self recordPrimTrace
]

{ #category : #'simulation only' }
Cogit >> recordRegisters [
	<doNotGenerate>
	self recordInstruction: processor integerRegisterState
	"self recordInstruction: processor registerState"
]

{ #category : #debugging }
Cogit >> recordSendTrace [
	<api>
	<cmacro: '() (traceLinkedSends & 1)'>
	^(traceLinkedSends bitAnd: 1) ~= 0
]

{ #category : #compaction }
Cogit >> relocateCallsAndSelfReferencesInMethod: cogMethod [
	<var: #cogMethod type: #'CogMethod *'>
	| delta |
	delta := cogMethod objectHeader signedIntFromLong.
	backEnd relocateCallBeforeReturnPC: cogMethod asInteger + missOffset by: delta negated.
	self mapFor: cogMethod
		performUntil: #relocateIfCallOrMethodReference:mcpc:delta: asSymbol
		arg: delta.
	cogMethod blockEntryOffset ~= 0 ifTrue:
		[self blockDispatchTargetsFor: cogMethod
			perform: #updateBlockHeaderFor:to: asSymbol
			arg: cogMethod asInteger + delta]
]

{ #category : #compaction }
Cogit >> relocateCallsInClosedPIC: cPIC [
	<var: #cPIC type: #'CogMethod *'>
	| delta pc entryPoint targetMethod |
	<var: #targetMethod type: #'CogMethod *'>
	delta := cPIC objectHeader signedIntFromLong.
	self assert: (backEnd callTargetFromReturnAddress: cPIC asInteger + missOffset) = cePICAbortTrampoline.
	backEnd relocateCallBeforeReturnPC: cPIC asInteger + missOffset by: delta negated.

	pc := cPIC asInteger + firstCPICCaseOffset.
	1 to: cPIC cPICNumCases do:
		[:i|
		entryPoint := backEnd jumpLongTargetBeforeFollowingAddress: pc.
		"Find target from jump.  Ignore jumps to the interpret and MNU calls within this PIC"
		(entryPoint < cPIC asInteger
		 or: [entryPoint > (cPIC asInteger + cPIC blockSize)]) ifTrue:
			[targetMethod := self cCoerceSimple: entryPoint - cmNoCheckEntryOffset to: #'CogMethod *'.
			 self assert: targetMethod cmType = CMMethod.
			 backEnd
				relocateJumpBeforeFollowingAddress: pc
				by: (delta - targetMethod objectHeader signedIntFromLong) negated].
		pc := pc + cPICCaseSize].
	self assert: cPIC cPICNumCases > 0.
	pc := pc - cPICCaseSize.
	"Finally relocate the load of the PIC and the jump to the overflow routine ceCPICMiss:receiver:"
	backEnd relocateMethodReferenceBeforeAddress: pc + backEnd loadLiteralByteSize by: delta.
	backEnd relocateJumpBeforeFollowingAddress: pc + cPICEndSize by: delta negated
]

{ #category : #compaction }
Cogit >> relocateIfCallOrMethodReference: annotation mcpc: mcpc delta: delta [
	<var: #mcpc type: #'char *'>
	| entryPoint offset sendTable targetMethod unlinkedRoutine |
	<var: #sendTable type: #'sqInt *'>
	<var: #targetMethod type: #'CogMethod *'>
	annotation = IsSendCall ifTrue:
		[entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
		 entryPoint <= methodZoneBase ifTrue: "send is not linked; just relocate"
			[backEnd relocateCallBeforeReturnPC: mcpc asInteger by: delta negated.
			 ^0].
		"It's a linked send; find which kind."
		(entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
			ifTrue: [offset := cmEntryOffset. sendTable := sendTrampolines]
			ifFalse: [offset := cmNoCheckEntryOffset. sendTable := superSendTrampolines].
		 targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
		 targetMethod cmType = CMMethod ifTrue: "send target not freed; just relocate."
			[backEnd
				relocateCallBeforeReturnPC: mcpc asInteger
				by: (delta - targetMethod objectHeader signedIntFromLong) negated.
			 ^0].
		"Target was freed; map back to an unlinked send; but include this method's reocation"
		 unlinkedRoutine := sendTable at: (targetMethod cmNumArgs min: NumSendTrampolines - 1).
		 unlinkedRoutine := unlinkedRoutine - delta.
		 backEnd
			rewriteInlineCacheAt: mcpc asInteger
			tag: targetMethod selector
			target: unlinkedRoutine.
		 ^0].
	annotation = IsRelativeCall ifTrue:
		[backEnd relocateCallBeforeReturnPC: mcpc asInteger by: delta negated.
		 ^0].
	annotation = IsMethodReference ifTrue:
		[backEnd relocateMethodReferenceBeforeAddress: mcpc asInteger by: delta].
	^0 "keep scanning"
]

{ #category : #compaction }
Cogit >> relocateMethodsPreCompaction [
	"All surviving methods have had the amount they are going to relocate by
	 stored in their objectHeader fields.  Relocate all relative calls so that after
	 the compaction of both the method containing each call and the call target
	 the calls invoke the same target."
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType ~= CMFree ifTrue:
			[cogMethod cmType = CMClosedPIC
				ifTrue: [self relocateCallsInClosedPIC: cogMethod]
				ifFalse: [self relocateCallsAndSelfReferencesInMethod: cogMethod]].
		 cogMethod := methodZone methodAfter: cogMethod].
	methodZone relocateAndPruneYoungReferrers.
	^true
]

{ #category : #'garbage collection' }
Cogit >> remapIfObjectRef: annotation pc: mcpc hasYoung: hasYoungPtr [
	<var: #mcpc type: #'char *'>
	<var: #targetMethod type: #'CogMethod *'>
	annotation = IsObjectReference ifTrue:
		[| literal mappedLiteral |
		 literal := backEnd literalBeforeFollowingAddress: mcpc asInteger.
		 (objectRepresentation couldBeObject: literal) ifTrue:
			[mappedLiteral := coInterpreter remap: literal.
			 literal ~= mappedLiteral ifTrue:
				[backEnd storeLiteral: mappedLiteral beforeFollowingAddress: mcpc asInteger.
				 codeModified := true].
			 (hasYoungPtr ~= 0
			  and: [coInterpreter isYoung: mappedLiteral]) ifTrue:
				[(self cCoerceSimple: hasYoungPtr to: #'sqInt *') at: 0 put: true]]].
	annotation = IsSendCall ifTrue:
		[| cacheTag mappedCacheTag |
		 cacheTag := backEnd inlineCacheTagAt: mcpc asInteger.
		 (objectRepresentation couldBeObject: cacheTag) ifTrue:
			[mappedCacheTag := coInterpreter remap: cacheTag.
			 cacheTag ~= mappedCacheTag ifTrue:
				[backEnd rewriteInlineCacheTag: mappedCacheTag at: mcpc asInteger.
				 codeModified := true].
			 (hasYoungPtr ~= 0
			  and: [coInterpreter isYoung: mappedCacheTag]) ifTrue:
				[(self cCoerceSimple: hasYoungPtr to: #'sqInt *') at: 0 put: true]].
		 hasYoungPtr ~= 0 ifTrue:
			[| entryPoint offset targetMethod |
			 "Since the unlinking routines may rewrite the cacheTag to the send's selector, and
			  since they don't have the cogMethod to hand and can't add it to youngReferrers,
			  the method must remain in youngReferrers if the targetMethod's selector is young."
			 entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
			 entryPoint > methodZoneBase ifTrue: "It's a linked send."
				[offset := (entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
							ifTrue: [cmEntryOffset]
							ifFalse: [cmNoCheckEntryOffset].
				targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
				(coInterpreter isYoung: targetMethod selector) ifTrue:
					[(self cCoerceSimple: hasYoungPtr to: #'sqInt *') at: 0 put: true]]]].
	^0 "keep scanning"
]

{ #category : #'translation support' }
Cogit >> reportError: anInteger [
	<cmacro: '(n) warning("compilation error")'>
	self halt: 'Compilation error ', anInteger printString
]

{ #category : #debugging }
Cogit >> reportLastNInstructions [
	<doNotGenerate>
	lastNInstructions do:
		[:thing|
		thing isArray
			ifTrue:
				[thing first isString "i.e. { '(simulated return to '. processor retpcIn: coInterpreter memory. ')'}"
					ifTrue:
						[thing do:
							[:stringOrNumber|
							coInterpreter transcript nextPutAll: (stringOrNumber isString
													ifTrue: [stringOrNumber]
													ifFalse: [stringOrNumber hex])].
							coInterpreter transcript cr]
					ifFalse: [processor printRegisterState: thing on: coInterpreter transcript]]
			ifFalse: [coInterpreter transcript nextPutAll: thing; cr]].
	coInterpreter transcript flush
]

{ #category : #'compile abstract instructions' }
Cogit >> scanBlock: blockStart [
	"Scan the block to determine if the block needs a frame or not"
	| descriptor pc end stackDelta |
	<var: #blockStart type: #'BlockStart *'>
	<var: #descriptor type: #'BytecodeDescriptor *'>
	needsFrame := false.
	methodOrBlockNumArgs := blockStart numArgs.
	pc := blockStart startpc.
	end := blockStart startpc + blockStart span.
	stackDelta := 0.
	[pc < end] whileTrue:
		[byte0 := coInterpreter fetchByte: pc ofObject: methodObj.
		 descriptor := self generatorAt: byte0.
		 needsFrame ifFalse:
			[descriptor needsFrameInBlock
				ifTrue: [needsFrame := true]
				ifFalse: [stackDelta := stackDelta + descriptor stackDelta]].
		 pc := self nextBytecodePCFor: descriptor at: pc byte0: byte0 in: methodObj].
	needsFrame ifFalse:
		[stackDelta < 0 ifTrue:
			[self error: 'negative stack delta in block; block contains bogus code or internal error'].
		 [stackDelta > 0] whileTrue:
			[descriptor := self generatorAt: (coInterpreter fetchByte: blockStart startpc ofObject: methodObj).
			 descriptor generator ~~ #genPushConstantNilBytecode asSymbol ifTrue:
				[self error: 'frameless block doesn''t start with enough pushNils'].
			 blockStart
				startpc: blockStart startpc + descriptor numBytes;
				span: blockStart span - descriptor numBytes.
			 stackDelta := stackDelta - 1]]
]

{ #category : #'compile abstract instructions' }
Cogit >> scanMethod [
	"Scan the method to determine
		- what the last bytecode is; extra bytes at the end of a method are used to encode things like source pointers or temp names
		- if the method needs a frame or not
		- what are the targets of any backward branches.
		- how many blocks it creates
	 Answer the block count or on error a negative error code"
	| latestContinuation descriptor pc numBlocks distance targetPC |
	<var: #descriptor type: #'BytecodeDescriptor *'>
	needsFrame := false.
	(primitiveIndex > 0
	 and: [coInterpreter isQuickPrimitiveIndex: primitiveIndex]) ifTrue:
		[^0].
	numBlocks := 0.
	pc := latestContinuation := initialPC.
	[pc <= endPC] whileTrue:
		[byte0 := coInterpreter fetchByte: pc ofObject: methodObj.
		descriptor := self generatorAt: byte0.
		(descriptor isReturn
		 and: [pc >= latestContinuation]) ifTrue:
			[endPC := pc].
		 (needsFrame not and: [descriptor needsFrame]) ifTrue:
			[needsFrame := true].
		descriptor isBranch ifTrue:
			[distance := self spanFor: descriptor at: pc byte0: byte0 in: methodObj.
			 targetPC := pc + descriptor numBytes + distance.
			 descriptor isBackwardBranch
				ifTrue: [self ensureFixupAt: targetPC - initialPC]
				ifFalse: [latestContinuation := latestContinuation max: targetPC]].
		descriptor isBlockCreation ifTrue:
			[numBlocks := numBlocks + 1.
			 distance := self spanFor: descriptor at: pc byte0: byte0 in: methodObj.
			 targetPC := pc + descriptor numBytes + distance.
			 latestContinuation := latestContinuation max: targetPC].
		pc := pc + descriptor numBytes].
	^numBlocks
]

{ #category : #debugging }
Cogit >> sendTrace: aBooleanOrInteger [
	<doNotGenerate>
	"traceLinkedSends is a set of flags.
	 1 => trace sends & block activations
	 2 => trace interpreter primitives
	 4 => print trace"
	traceLinkedSends := aBooleanOrInteger isInteger
							ifTrue: [aBooleanOrInteger]
							ifFalse: [aBooleanOrInteger ifTrue: [1] ifFalse: [0]]
]

{ #category : #initialization }
Cogit >> sendTrampolineName: routinePrefix args: numArgs [ 
	"Malloc a string with the contents for the trampoline table"
	<returnTypeC: #'char *'>
	<var: #routinePrefix type: #'char *'>
	| theString |
	<var: #theString type: #'char *'>
	self cCode: '' inSmalltalk:
		[^routinePrefix, (numArgs >= 0 ifTrue: [numArgs printString] ifFalse: ['N']), 'Args'].
	theString := self malloc: (self strlen: routinePrefix) + 6.
	self s: theString pr: '%s%cArgs' in: routinePrefix tf: (numArgs >= 0 ifTrue: [$0 + numArgs] ifFalse: [$N]).
	^theString
]

{ #category : #debugging }
Cogit >> setBreakMethod: anObj [
	<api>
	breakMethod := anObj
]

{ #category : #accessing }
Cogit >> setCFramePointer: aFramePointer [
	<api>
	<cmacro: '(theFP) (CFramePointer = theFP)'>
	"and in the simulator we use..."
	^coInterpreter
		longAt: coInterpreter inMemoryCFramePointerAddress
		put: aFramePointer
]

{ #category : #accessing }
Cogit >> setCStackPointer: aStackPointer [
	<api>
	<cmacro: '(theSP) (CStackPointer = theSP)'>
	"and in the simulator we use..."
	^coInterpreter
		longAt: coInterpreter inMemoryCStackPointerAddress
		put: aStackPointer
]

{ #category : #initialization }
Cogit >> setInterpreter: aCoInterpreter [
	"Initialization of the code generator in the simulator.
	 These objects already exist in the generated C VM
	 or are used only in the simulation."
	<doNotGenerate>
	coInterpreter := aCoInterpreter.
	threadManager := aCoInterpreter threadManager. "N.B. may be nil"
	objectRepresentation := coInterpreter objectRepresentationClass for: self.
	methodZone := CogMethodZone new.
	methodZone setInterpreter: aCoInterpreter
				objectRepresentation: objectRepresentation
				cogit: self.
	generatorTable := GeneratorTable.
	primitiveGeneratorTable := PrimitiveTable.
	processor := ProcessorClass new.
	simulatedTrampolines := Dictionary new.
	simulatedVariableGetters := Dictionary new.
	simulatedVariableSetters := Dictionary new.
	illegalAddressCounter := BytesPerWord negated bitAnd: self addressSpaceMask.
	traceStores := 0.
	traceLinkedSends := 0.
	debugPrimCallStackOffset := 0.
	singleStep := printRegisters := printInstructions := clickConfirm := false.
	(backEnd := processor abstractInstructionCompilerClass new) cogit: self.
	(methodLabel := processor abstractInstructionCompilerClass new) cogit: self.
	sendTrampolines := CArrayAccessor on: (Array new: NumSendTrampolines).
	superSendTrampolines := CArrayAccessor on: (Array new: NumSendTrampolines).
	"debug metadata"
	trampolineAddresses := CArrayAccessor on: (Array new: NumTrampolines * 2).
	trampolineTableIndex := 0
]

{ #category : #'jit - api' }
Cogit >> setPostCompileHook: aFunction [
	<api>
	<var: #aFunction declareC: #'void (*aFunction)(CogMethod *, void *)'>
	postCompileHook := aFunction
]

{ #category : #'jit - api' }
Cogit >> setSelectorOf: cogMethod to: aSelectorOop [
	<api>
	"If a method is compiled to machine code via a block entry it won't have a selector.
	 A subsequent send can find the method and hence fill in the selector."
	<var: #cogMethod type: #'CogMethod *'>
	"self disassembleMethod: cogMethod"
	coInterpreter
		compilationBreak: aSelectorOop + BaseHeaderSize
		point: (coInterpreter lengthOf: aSelectorOop).
	self assert: cogMethod cmType = CMMethod.
	cogMethod selector: aSelectorOop.
	(cogMethod cmRefersToYoung not
	 and: [coInterpreter isYoung: aSelectorOop]) ifTrue:
		[self assert: (methodZone occurrencesInYoungReferrers: cogMethod) = 0.
		 cogMethod cmRefersToYoung: true.
		 methodZone addToYoungReferrers: cogMethod]
]

{ #category : #'simulation only' }
Cogit >> simulateCogCodeAt: address [ "<Integer>"
	<doNotGenerate>
	| stackZoneBase |
	stackZoneBase := coInterpreter stackZoneBase.
	processor eip: address.
	[[[singleStep ifTrue:
		[[processor sp < stackZoneBase ifTrue: [self halt].
		  self recordRegisters.
		  printRegisters ifTrue:
			[processor printRegistersOn: Transcript].
		  self recordLastInstruction.
		  printInstructions ifTrue:
			[Transcript nextPutAll: lastNInstructions last; cr; flush].
		  processor pc = breakPC ifTrue:
			["printRegisters := printInstructions := true"
			 "self reportLastNInstructions"
			 "coInterpreter printExternalHeadFrame"
			 "coInterpreter printFrameAndCallers: coInterpreter framePointer SP: coInterpreter stackPointer"
			 "coInterpreter shortPrintFrameAndCallers: coInterpreter framePointer"
			 "coInterpreter printFrame: processor fp WithSP: processor sp"
			 "coInterpreter printFrameAndCallers: processor fp SP: processor sp"
			 "coInterpreter shortPrintFrameAndCallers: processor fp"
			"self disassembleMethodFor: processor pc"
			 self halt: 'machine code breakpoint at ', breakPC hex]] value]. "So that the Debugger's Over steps over all this"
	   singleStep
		ifTrue: [processor
					singleStepIn: coInterpreter memory
					minimumAddress: guardPageSize
					readOnlyBelow: coInterpreter cogCodeSize]
		ifFalse: [processor
					runInMemory: coInterpreter memory
					minimumAddress: guardPageSize
					readOnlyBelow: coInterpreter cogCodeSize].
	   ((printRegisters or: [printInstructions]) and: [clickConfirm]) ifTrue:
	 	[(self confirm: 'continue?') ifFalse:
			[self halt]].
	   true] whileTrue]
		on: ProcessorSimulationTrap
		do: [:ex| self handleSimulationTrap: ex].
	 true] whileTrue
]

{ #category : #'simulation only' }
Cogit >> simulateEnilopmart: enilopmartAddress numArgs: n [
	<doNotGenerate>
	"Enter Cog code, popping the class reg and receiver from the stack and then
	 returning to the address beneath them."
	"In the actual VM teh enilopmart is a function pointer and so senders
	 of this method end up calling the enilopmart to enter machine code.
	 In simulation we either need to start simulating execution (if we're in the interpreter)
	 or return to the simulation (if we're in the run-time called from machine code."
	"If we're simulating the threaded VM then we need to ensure the processor's
	 register state is that of the current process."
	threadManager ifNotNil:
		[threadManager
			ensureProcessor: processor
			isInThread: Processor activeProcess].
	self assert: (coInterpreter isOnRumpCStack: processor sp).
	self assert: ((coInterpreter stackValue: n) between: guardPageSize and: methodZone zoneLimit - 1).
	(printInstructions or: [printRegisters]) ifTrue:
		[coInterpreter printExternalHeadFrame].
	processor
		simulateLeafCallOf: enilopmartAddress
		nextpc: 16rBADF00D
		memory: coInterpreter memory.
	"If we're already simulating in the context of machine code then
	 this will take us back to handleCallSimulationTrap:.  Otherwise
	 start executing machine code in the simulator."
	(ReenterMachineCode new returnValue: #continueNoReturn) signal.
	self simulateCogCodeAt: enilopmartAddress.
	"We should either longjmp back to the interpreter or
	 stay in machine code so control should not reach here."
	self assert: false
]

{ #category : #'simulation only' }
Cogit >> simulateLeafCallOf: someFunction [
	"Simulate execution of machine code that leaf-calls someFunction,
	 answering the result returned by someFunction."
	<doNotGenerate>
	| initialState |
	self recordRegisters.
	initialState := processor registerState.
	^coInterpreter
		withRegisterStateForCurrentThreadSetIn: processor
		do: [| spOnEntry |
			processor registerState ~= initialState ifTrue:
				[self recordInstruction: '(simulated thread switch)'.
				 self recordRegisters].
			self assertStackPointersBelongToCurrentThread.
			processor
				simulateLeafCallOf: someFunction
				nextpc: SmallInteger maxVal
				memory: coInterpreter memory.
			spOnEntry := processor sp.
			self recordInstruction: {'(simulated call of '. someFunction. ')'}.
			[[processor pc between: 0 and: coInterpreter cogCodeSize] whileTrue:
				[singleStep
					ifTrue: [self recordLastInstruction.
							self recordRegisters.
							processor
								singleStepIn: coInterpreter memory
								minimumAddress: guardPageSize
								readOnlyBelow: coInterpreter cogCodeSize]
					ifFalse: [processor
								runInMemory: coInterpreter memory
								minimumAddress: guardPageSize
								readOnlyBelow: coInterpreter cogCodeSize]]]
				on: ProcessorSimulationTrap
				do: [:ex|
					"If the ip is out of bounds the return has already occurred."
					((processor pc between: 0 and: coInterpreter cogCodeSize)
					 and: [processor sp <= spOnEntry]) ifTrue:
						[processor simulateLeafReturnIn: coInterpreter memory.
						 self recordInstruction: {'(simulated return to '. processor pc. ')'}.
						 self recordRegisters]].
			processor cResultRegister]
]

{ #category : #initialization }
Cogit >> simulatedReadWriteVariableAddress: getter in: receiver [
	"Answer a simulated variable.  This is a variable whose value can be read
	 and written by generated machine code."
	<doNotGenerate>
	| address setter |
	(address := simulatedVariableGetters at: getter ifAbsent: []) ifNotNil:
		[^address].
	address := (simulatedVariableGetters size + 101 * BytesPerWord) negated bitAnd: self addressSpaceMask.
	simulatedVariableGetters at: address put: (MessageSend receiver: receiver selector: getter).
	setter := (getter, ':') asSymbol.
	simulatedVariableSetters at: address put: ([:value| receiver perform: setter with: value]).
	^address
]

{ #category : #initialization }
Cogit >> simulatedVariableAddress: getter in: receiver [
	"Answer a simulated variable.  This is a variable whose value can be read
	 by generated machine code."
	<doNotGenerate>
	| address |
	(address := simulatedVariableGetters at: getter ifAbsent: []) ifNotNil:
		[^address].
	address := (simulatedVariableGetters size + 101 * BytesPerWord) negated bitAnd: self addressSpaceMask.
	simulatedVariableGetters at: address put: (MessageSend receiver: receiver selector: getter).
	^address
]

{ #category : #debugging }
Cogit >> singleStep [
	<doNotGenerate>
	^singleStep
]

{ #category : #debugging }
Cogit >> singleStep: aBoolean [
	<doNotGenerate>
	singleStep := aBoolean
]

{ #category : #'compile abstract instructions' }
Cogit >> spanFor: descriptor at: pc byte0: opcodeByte in: aMethodObj [
	"Compute the span (jump distance) for a particular bytecode, e.g. a backward branch or a block."
	<var: #descriptor type: #'BytecodeDescriptor *'>
	^descriptor numBytes caseOf:
		{ [1] -> [self
					perform: descriptor spanFunction
					with: opcodeByte].
		   [2] -> [self
					perform: descriptor spanFunction
					with: opcodeByte
					with: (coInterpreter fetchByte: pc + 1 ofObject: aMethodObj)].
		   [3] -> [self
					perform: descriptor spanFunction
					with: opcodeByte
					with: (coInterpreter fetchByte: pc + 1 ofObject: aMethodObj)
					with: (coInterpreter fetchByte: pc + 2 ofObject: aMethodObj)].
		   [4] -> [self
					perform: descriptor spanFunction
					with: opcodeByte
					with: (coInterpreter fetchByte: pc + 1 ofObject: aMethodObj)
					with: (coInterpreter fetchByte: pc + 2 ofObject: aMethodObj)
					with: (coInterpreter fetchByte: pc + 3 ofObject: aMethodObj)] }
]

{ #category : #'jit - api' }
Cogit >> stackPageHeadroomBytes [
	<api>
	"Delegate this to the processor..."
	^backEnd stackPageInterruptHeadroomBytes
]

{ #category : #disassembly }
Cogit >> startMcpcAndCogMethodForMcpc: mcpc in: cogMethod do: aBinaryBlock [
	"Evaluate aBinaryBlock with the startmcpc and method containing mcpc in cogMethod."
	<doNotGenerate>
	| startMcpc |
	startMcpc := ((self codeRangesFor: cogMethod)
					detect: [:range| range includes: mcpc]
					ifNone: [^nil]) first.
	^aBinaryBlock
		value: startMcpc
		value: (startMcpc = (cogMethod asInteger + (self sizeof: CogMethod))
					ifTrue: [cogMethod]
					ifFalse: [self cCoerceSimple: startMcpc - (self sizeof: CogBlockMethod)
								to: #'CogBlockMethod *'])
]

{ #category : #debugging }
Cogit >> traceLinkedSendOffset [
	<api>
	^cmNoCheckEntryOffset + backEnd callInstructionByteSize
]

{ #category : #debugging }
Cogit >> traceStores: aBooleanOrInteger [
	<doNotGenerate>
	traceStores := aBooleanOrInteger isInteger
							ifTrue: [aBooleanOrInteger]
							ifFalse: [aBooleanOrInteger ifTrue: [1] ifFalse: [0]]
]

{ #category : #'multi-threading' }
Cogit >> tryLockVMOwner [
	<api>
	<cmacro: '() ceTryLockVMOwner()'>
	^self simulateLeafCallOf: ceTryLockVMOwner
]

{ #category : #'simulation only' }
Cogit >> uniqueAddressForTrampoline: aSymbol [
	<doNotGenerate>
	self assert: aSymbol isSymbol.
	simulatedTrampolines
		at: (illegalAddressCounter := illegalAddressCounter - 4)
		put: aSymbol.
	^illegalAddressCounter
]

{ #category : #'bytecode generators' }
Cogit >> unknownBytecode [
	^EncounteredUnknownBytecode
]

{ #category : #'jit - api' }
Cogit >> unlinkAllSends [
	<api>
	"Unlink all sends in cog methods."
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	methodZoneBase isNil ifTrue: [^self].
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType = CMMethod
			ifTrue:
				[self mapFor: cogMethod
					 performUntil: #unlinkIfLinkedSend:pc:ignored: asSymbol
					 arg: 0]
			ifFalse:
				[cogMethod cmType ~= CMFree ifTrue:
					[methodZone freeMethod: cogMethod]].
		cogMethod := methodZone methodAfter: cogMethod].
	"After updating inline caches we need to flush the icache."
	processor flushICacheFrom: methodZoneBase to: methodZone limitZony asInteger
]

{ #category : #'in-line cacheing' }
Cogit >> unlinkIfLinkedSend: annotation pc: mcpc ignored: superfluity [
	<var: #mcpc type: #'char *'>
	| entryPoint targetMethod offset sendTable unlinkedRoutine |
	<var: #targetMethod type: #'CogMethod *'>
	<var: #sendTable type: #'sqInt *'>
	annotation = IsSendCall ifTrue:
		[entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
		 entryPoint > methodZoneBase ifTrue: "It's a linked send."
			[(entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
				ifTrue: [offset := cmEntryOffset. sendTable := sendTrampolines]
				ifFalse: [offset := cmNoCheckEntryOffset. sendTable := superSendTrampolines].
			targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
			unlinkedRoutine := sendTable at: (targetMethod cmNumArgs min: NumSendTrampolines - 1).
			backEnd
				rewriteInlineCacheAt: mcpc asInteger
				tag: targetMethod selector
				target: unlinkedRoutine]].
	^0 "keep scanning"
]

{ #category : #'in-line cacheing' }
Cogit >> unlinkIfLinkedSend: annotation pc: mcpc of: theSelector [
	<var: #mcpc type: #'char *'>
	| entryPoint targetMethod offset sendTable unlinkedRoutine |
	<var: #targetMethod type: #'CogMethod *'>
	<var: #sendTable type: #'sqInt *'>
	annotation = IsSendCall ifTrue:
		[entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
		 entryPoint > methodZoneBase ifTrue: "It's a linked send."
			[(entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
				ifTrue: [offset := cmEntryOffset. sendTable := sendTrampolines]
				ifFalse: [offset := cmNoCheckEntryOffset. sendTable := superSendTrampolines].
			targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
			targetMethod selector = theSelector ifTrue:
				[unlinkedRoutine := sendTable at: (targetMethod cmNumArgs min: NumSendTrampolines - 1).
				 backEnd
					rewriteInlineCacheAt: mcpc asInteger
					tag: targetMethod selector
					target: unlinkedRoutine.
				 codeModified := true]]].
	^0 "keep scanning"
]

{ #category : #'in-line cacheing' }
Cogit >> unlinkIfLinkedSend: annotation pc: mcpc to: theCogMethod [
	<var: #mcpc type: #'char *'>
	| entryPoint targetMethod offset sendTable unlinkedRoutine |
	<var: #targetMethod type: #'CogMethod *'>
	<var: #sendTable type: #'sqInt *'>
	annotation = IsSendCall ifTrue:
		[entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
		 entryPoint > methodZoneBase ifTrue: "It's a linked send."
			[(entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
				ifTrue: [offset := cmEntryOffset. sendTable := sendTrampolines]
				ifFalse: [offset := cmNoCheckEntryOffset. sendTable := superSendTrampolines].
			targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
			targetMethod asInteger = theCogMethod ifTrue:
				[unlinkedRoutine := sendTable at: (targetMethod cmNumArgs min: NumSendTrampolines - 1).
				 backEnd
					rewriteInlineCacheAt: mcpc asInteger
					tag: targetMethod selector
					target: unlinkedRoutine.
				 codeModified := true]]].
	^0 "keep scanning"
]

{ #category : #'in-line cacheing' }
Cogit >> unlinkIfLinkedSendToFree: annotation pc: mcpc ignored: superfluity [
	<var: #mcpc type: #'char *'>
	| entryPoint targetMethod offset sendTable unlinkedRoutine |
	<var: #targetMethod type: #'CogMethod *'>
	<var: #sendTable type: #'sqInt *'>
	annotation = IsSendCall ifTrue:
		[entryPoint := backEnd callTargetFromReturnAddress: mcpc asInteger.
		 entryPoint > methodZoneBase ifTrue: "It's a linked send."
			[(entryPoint bitAnd: entryPointMask) = checkedEntryAlignment
				ifTrue: [offset := cmEntryOffset. sendTable := sendTrampolines]
				ifFalse: [offset := cmNoCheckEntryOffset. sendTable := superSendTrampolines].
			targetMethod := self cCoerceSimple: entryPoint - offset to: #'CogMethod *'.
			targetMethod cmType = CMFree ifTrue:
				[unlinkedRoutine := sendTable at: (targetMethod cmNumArgs min: NumSendTrampolines - 1).
				 backEnd
					rewriteInlineCacheAt: mcpc asInteger
					tag: targetMethod selector
					target: unlinkedRoutine.
				 codeModified := true]]].
	^0 "keep scanning"
]

{ #category : #'jit - api' }
Cogit >> unlinkSendsOf: selector [
	<api>
	"Unlink all sends in cog methods."
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	methodZoneBase isNil ifTrue: [^self].
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	"First check if any method actually has the selector; if not there can't
	 be any linked send to it."
	[cogMethod < methodZone limitZony
	 and: [cogMethod selector ~= selector]] whileTrue:
		[cogMethod := methodZone methodAfter: cogMethod].
	cogMethod >= methodZone limitZony ifTrue:
		[^nil].
	codeModified := false.
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType = CMMethod
			ifTrue:
				[self mapFor: cogMethod
					 performUntil: #unlinkIfLinkedSend:pc:of: asSymbol
					 arg: selector]
			ifFalse:
				[(cogMethod cmType ~= CMFree
				  and: [cogMethod selector = selector]) ifTrue:
					[methodZone freeMethod: cogMethod]].
		cogMethod := methodZone methodAfter: cogMethod].
	codeModified ifTrue: "After possibly updating inline caches we need to flush the icache."
		[processor flushICacheFrom: methodZoneBase to: methodZone limitZony asInteger]
]

{ #category : #'jit - api' }
Cogit >> unlinkSendsTo: targetMethod [
	<api>
	"Unlink all sends in cog methods to a particular target method."
	<var: #targetMethod type: #'CogMethod *'>
	| cogMethod freedPIC |
	<var: #cogMethod type: #'CogMethod *'>
	methodZoneBase isNil ifTrue: [^self].
	codeModified := freedPIC := false.
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType = CMMethod
			ifTrue:
				[self mapFor: cogMethod
					 performUntil: #unlinkIfLinkedSend:pc:to: asSymbol
					 arg: targetMethod asInteger]
			ifFalse:
				[(cogMethod cmType = CMClosedPIC
				  and: [self cPIC: cogMethod HasTarget: targetMethod]) ifTrue:
					[methodZone freeMethod: cogMethod.
					 freedPIC := true]].
		cogMethod := methodZone methodAfter: cogMethod].
	freedPIC
		ifTrue: [self unlinkSendsToFree]
		ifFalse:
			[codeModified ifTrue: "After possibly updating inline caches we need to flush the icache."
				[processor flushICacheFrom: methodZoneBase to: methodZone limitZony asInteger]]
]

{ #category : #'garbage collection' }
Cogit >> unlinkSendsToFree [
	<api>
	"Unlink all sends in cog methods to free methods and/or pics."
	| cogMethod |
	<var: #cogMethod type: #'CogMethod *'>
	methodZoneBase isNil ifTrue: [^self].
	codeModified := false.
	cogMethod := self cCoerceSimple: methodZoneBase to: #'CogMethod *'.
	[cogMethod < methodZone limitZony] whileTrue:
		[cogMethod cmType = CMMethod
			ifTrue:
				[self mapFor: cogMethod
					 performUntil: #unlinkIfLinkedSendToFree:pc:ignored: asSymbol
					 arg: 0]
			ifFalse:
				[cogMethod cmType = CMClosedPIC ifTrue:
					[self assert: (self noTargetsFreeInClosedPIC: cogMethod)]].
		cogMethod := methodZone methodAfter: cogMethod].
	codeModified ifTrue: "After possibly updating inline caches we need to flush the icache."
		[processor flushICacheFrom: methodZoneBase to: methodZone limitZony asInteger]
]

{ #category : #'multi-threading' }
Cogit >> unlockVMOwner [
	<api>
	<cmacro: '() ceUnlockVMOwner()'>
	^self simulateLeafCallOf: ceUnlockVMOwner
]

{ #category : #compaction }
Cogit >> updateBlockHeaderFor: blockEntryPC to: newHomeMethodAddress [
	<returnTypeC: #usqInt>
	| cogBlockMethod |
	<var: #cogBlockMethod type: #'CogBlockMethod *'>
	cogBlockMethod := self cCoerceSimple: blockEntryPC - (self sizeof: CogBlockMethod)
							to: #'CogBlockMethod *'.
	cogBlockMethod objectHeader: newHomeMethodAddress.
	^0 "keep scanning..."
]

{ #category : #'garbage collection' }
Cogit >> updateMaybeObjRefAt: mcpc [
	"Update a potential object reference form a closed PIC.
	 This may be an object reference, an inline cache tag or null."
	| object subject |
	object := backEnd literalBeforeFollowingAddress: mcpc.
	(objectRepresentation couldBeObject: object) ifTrue:
		[subject := objectRepresentation remapOop: object.
		 object ~= subject ifTrue:
			[backEnd storeLiteral: subject beforeFollowingAddress: mcpc.
			 codeModified := true]]
]

{ #category : #'jit - api' }
Cogit >> voidCogCompiledCode [
	<api>
	methodZone clearCogCompiledCode
]
