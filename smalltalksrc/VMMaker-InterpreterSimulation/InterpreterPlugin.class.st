"
This class provides the basic framework for creating VM plugins. Most of the useful methods are on the class side; particularly take note of the messages like #shouldBeTranslated and #requiresPlatformFiles.
"
Class {
	#name : #InterpreterPlugin,
	#superclass : #Object,
	#instVars : [
		'interpreterProxy',
		'moduleName'
	],
	#classInstVars : [
		'timeStamp'
	],
	#category : #'VMMaker-Plugins'
}

{ #category : #accessing }
InterpreterPlugin class >> allCallsOn [
	"Answer a SortedCollection of all the methods that refer to me. Most classes simply defer to SystemDictionary>allCallsOn: but some have special requirements - plugins may have a module name that does not match the class name"

	self theNonMetaClass name ~= self moduleName asSymbol
		ifTrue:[^super allCallsOn, (self systemNavigation allCallsOn: self moduleName asSymbol)]
		ifFalse:[^super allCallsOn]
]

{ #category : #translation }
InterpreterPlugin class >> baseDirectoryName [
	"Return the directory into which plugins should be generated by default."
	^FileDirectory default pathName
]

{ #category : #translation }
InterpreterPlugin class >> buildCodeGeneratorUpTo: aPluginClass [
	"Build a CCodeGenerator for the plugin"
	 | cg theClass |
	cg := self codeGeneratorClass new initialize.
	cg pluginName: self moduleName.
	"Add an extra declaration for module name"
	cg declareModuleName: self moduleNameAndVersion.

	theClass := aPluginClass.
	[theClass == Object | (theClass == InterpreterSimulationObject)] whileFalse:[
		cg addClass: theClass.
		theClass := theClass superclass].
	^cg
]

{ #category : #private }
InterpreterPlugin class >> codeGeneratorClass [
	"return the appropriate class of code generator for this kind ofplugin"

	^VMPluginCodeGenerator
]

{ #category : #translation }
InterpreterPlugin class >> declareCVarsIn: aCCodeGenerator [
	"Note: This method must be implemented by all subclasses to declare variables."

	aCCodeGenerator 
		var: #interpreterProxy 
		type: #'struct VirtualMachine*'.
	self declareHeaderFilesIn: aCCodeGenerator.
]

{ #category : #translation }
InterpreterPlugin class >> declareHeaderFilesIn: aCCodeGenerator [
	self hasHeaderFile ifTrue:[
		aCCodeGenerator addHeaderFile: '"', self moduleName,'.h"'].
]

{ #category : #'instance creation' }
InterpreterPlugin class >> doPrimitive: primitiveName [ 
	| proxy plugin |
	proxy := InterpreterProxy new.
	proxy loadStackFrom: thisContext sender.
	plugin := self simulatorClass new.
	plugin setInterpreter: proxy.
	(plugin respondsTo: #initialiseModule) ifTrue:[plugin initialiseModule].
	plugin perform: primitiveName asSymbol.
	^ proxy stackValue: 0
]

{ #category : #translation }
InterpreterPlugin class >> hasHeaderFile [
	"If there is a single intrinsic header file to be associated with the plugin, here is where you want to flag"
	^false
]

{ #category : #'class initialization' }
InterpreterPlugin class >> initialize [
	"Nothing to do ..."
]

{ #category : #accessing }
InterpreterPlugin class >> isCPP [
	^ false
]

{ #category : #accessing }
InterpreterPlugin class >> moduleExtension [
	^ self isCPP ifTrue: ['.cpp'] ifFalse: ['.c']
]

{ #category : #accessing }
InterpreterPlugin class >> moduleName [
	"Answer the receiver's module name that is used for the plugin's C code."

	^ self name asString
]

{ #category : #accessing }
InterpreterPlugin class >> moduleNameAndVersion [
	"Answer the receiver's module name and version info that is used for the plugin's C code. The default is to append the code generation date, but any useful text is ok (keep it short)"

	^ self moduleName, Character space asString, Date today asString
]

{ #category : #compiling }
InterpreterPlugin class >> noteCompilationOf: aSelector meta: isMeta [
	"note the recompiliation by resetting the timeStamp "
	timeStamp := Time totalSeconds.
	^super noteCompilationOf: aSelector meta: isMeta
]

{ #category : #translation }
InterpreterPlugin class >> requiredMethodNames [
	"return the list of method names that should be retained for export or other support reasons"
	"just which methods?"
	^#()
]

{ #category : #translation }
InterpreterPlugin class >> requiresCrossPlatformFiles [
	"default is ok for most, any plugin needing cross platform files aside from a normal header must say so. See SoundCodecPlugin for example"
	^self hasHeaderFile
]

{ #category : #translation }
InterpreterPlugin class >> requiresPlatformFiles [
	"default is ok for most, any plugin needing platform specific files must say so"
	^false
]

{ #category : #translation }
InterpreterPlugin class >> shouldBeTranslated [
"is this class intended to be translated as a plugin? Most subclasses should answer true, but some such as:-
	TestInterpreterPlugin
	FlippArrayPlugin2
	InflatePlugin
	should answer false for various reasons."
	^true
]

{ #category : #accessing }
InterpreterPlugin class >> simulatorClass [
	"For running from Smalltalk - answer a class that can be used to simulate the receiver, or nil if you want the primitives in this module to always fail, causing simulation to fall through to the Smalltalk code.  By default every non-TestInterpreterPlugin can simulate itself."

	^ self
]

{ #category : #translation }
InterpreterPlugin class >> storeString: s onFileNamed: fileName [
	"Store the given string in a file of the given name."

	| f |
	f := CrLfFileStream forceNewFileNamed: fileName.
	f nextPutAll: s.
	f close.
]

{ #category : #accessing }
InterpreterPlugin class >> timeStamp [
	^timeStamp ifNil:[0]
]

{ #category : #translation }
InterpreterPlugin class >> translateInDirectory: directory doInlining: inlineFlag [
"This is the default method for writing out sources for a plugin. Several classes need special handling, so look at all implementors of this message"
	| cg fname fstat |
	 fname := self moduleName, '.c'.

	"don't translate if the file is newer than my timeStamp"
	fstat := directory entryAt: fname ifAbsent:[nil].
	fstat ifNotNil:[self timeStamp < fstat modificationTime ifTrue:[^nil]].

	self initialize.
	cg := self buildCodeGeneratorUpTo: self.
	cg storeCodeOnFile:  (directory fullNameFor: fname) doInlining: inlineFlag.
	^cg exportedPrimitiveNames asArray
]

{ #category : #initialize }
InterpreterPlugin >> getInterpreter [
	"Note: This is coded so that plugins can be run from Squeak."

	self returnTypeC: 'VirtualMachine *'.
	^interpreterProxy
]

{ #category : #initialize }
InterpreterPlugin >> getModuleName [
	"Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important!"
	self returnTypeC:'const char*'.
	self export: true.
	^moduleName
]

{ #category : #debugging }
InterpreterPlugin >> halt [
	self cCode: '' inSmalltalk: [nil halt].
]

{ #category : #debugging }
InterpreterPlugin >> msg: s [ 
	self var: #s type: 'char *'.
	self cCode: 'fprintf(stderr, "\n%s: %s", moduleName, s)' inSmalltalk: [Transcript cr; show: self class moduleName , ': ' , s; endEntry]
]

{ #category : #initialize }
InterpreterPlugin >> setInterpreter: anInterpreter [ 
	"Note: This is coded so that is can be run from Squeak."

	| ok |
	self export: true.
	self var: #anInterpreter type: #'struct VirtualMachine*'.
	interpreterProxy := anInterpreter.
	ok := self cCode: 'interpreterProxy->majorVersion() == VM_PROXY_MAJOR'.
	ok == false ifTrue: [^ false].
	ok := self cCode: 'interpreterProxy->minorVersion() >= VM_PROXY_MINOR'.
	^ ok
]
